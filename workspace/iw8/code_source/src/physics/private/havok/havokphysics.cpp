/*
==============
HavokPhysics_GetRigidBodyMaxAngSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxAngSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxAngSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM@Z(worldId, bodyId, maxAngSpeed);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  ?HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets@@YAXPEBUScreenPlacement@@PEAM1MM_N@Z(scrPlace, x, y, tabWidth, charHeight, excludeDoNotUse);
}

/*
==============
HavokPhysics_DrawDebugWorldCPU
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldCPU(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorldCPU@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyBounds
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, hkTransformf *transform, hkAabb *aabb)
{
  ?HavokPhysics_GetPhysicsAssetBodyBounds@@YAXPEBUPhysicsAsset@@HAEAVhkTransformf@@AEAVhkAabb@@@Z(physicsAsset, bodyIdx, transform, aabb);
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreBody
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::AddIgnoreBody(HavokPhysics_IgnoreBodies *this, unsigned int bodyId)
{
  ?AddIgnoreBody@HavokPhysics_IgnoreBodies@@QEAAXI@Z(this, bodyId);
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreEntity
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::AddIgnoreEntity(HavokPhysics_IgnoreBodies *this, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  ?AddIgnoreEntity@HavokPhysics_IgnoreBodies@@QEAAXH_N0000@Z(this, svEntNum, self, children, parent, siblings, linked);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_LoosenConstraint
==============
*/

bool __fastcall HavokPhysics_LoosenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *result)
{
  return ?HavokPhysics_LoosenConstraint@@YA_NW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, result);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@6@Z(worldId, numBodies, bodyIds, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_CopyXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_CopyXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_AreDetailModelsInterchangeable
==============
*/

bool __fastcall HavokPhysics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  return ?HavokPhysics_AreDetailModelsInterchangeable@@YA_NQEBUXModel@@0@Z(detailModelA, detailModelB);
}

/*
==============
HavokPhysics_InstantiateAssetBodySphere
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBodySphere@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44MW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, radius, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_GetNumContentsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumContentsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::Reset
==============
*/

void __fastcall HavokPhysics_BroadphaseCollisionQueryResult::Reset(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  ?Reset@HavokPhysics_BroadphaseCollisionQueryResult@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_AABBBroadphaseQuery
==============
*/

void __fastcall HavokPhysics_AABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?HavokPhysics_AABBBroadphaseQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(worldId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_AABBQuery
==============
*/

void __fastcall HavokPhysics_AABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_AABBQuery@@YAXW4Physics_WorldId@@UhknpBodyId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_DrawPhysicsXModels
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType sortType, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsXModels@@YAXW4Physics_DebugXModelSortType@@PEBUScreenPlacement@@PEAM2MM@Z(sortType, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddDebugLine
==============
*/

void __fastcall HavokPhysics_AddDebugLine(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, const unsigned int *color)
{
  ?HavokPhysics_AddDebugLine@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1AEBI@Z(worldId, start, end, color);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHit
==============
*/

const hknpCollisionResult *__fastcall HavokPhysics_CollisionQueryResult::GetHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetHit@HavokPhysics_CollisionQueryResult@@QEBAAEBUhknpCollisionResult@@H@Z(this, hitId);
}

/*
==============
HavokPhysics_AddXModelAsset
==============
*/

void __fastcall HavokPhysics_AddXModelAsset(XModel *xmodel)
{
  ?HavokPhysics_AddXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
HavokPhysics_GetInstanceDetailModel
==============
*/

const XModel *__fastcall HavokPhysics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceDetailModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsVFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsVFXEventAssets@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_StartDrawDebugWorld
==============
*/

void __fastcall HavokPhysics_StartDrawDebugWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_StartDrawDebugWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>
==============
*/

hknpShape *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VhknpShape@@@@YAPEAVhknpShape@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetRaycastHitPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_IsWorldMultithreaded
==============
*/

bool __fastcall HavokPhysics_IsWorldMultithreaded(Physics_WorldId worldId)
{
  return ?HavokPhysics_IsWorldMultithreaded@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_SetRigidBodyDynamic
==============
*/

void __fastcall HavokPhysics_SetRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyDynamic@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CalculateMassProperties
==============
*/

void __fastcall HavokPhysics_CalculateMassProperties(hknpShape *shape, float mass, hkMassProperties *massProperties)
{
  ?HavokPhysics_CalculateMassProperties@@YAXPEAVhknpShape@@MPEAUhkMassProperties@@@Z(shape, mass, massProperties);
}

/*
==============
HavokPhysics_IsChildOfShape
==============
*/

bool __fastcall HavokPhysics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  return ?HavokPhysics_IsChildOfShape@@YA_NPEBVhknpShape@@0@Z(possibleParent, possibleChild);
}

/*
==============
HavokPhysics_ReleasePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?HavokPhysics_ReleasePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@6@Z(worldId, bodyId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_GetRigidBodyName
==============
*/

const char *__fastcall HavokPhysics_GetRigidBodyName(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRigidBodyName@@YAPEBDW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_AABBQuery
==============
*/

void __fastcall HavokPhysics_AABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_AABBQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHits
==============
*/

const hknpCollisionResult *__fastcall HavokPhysics_CollisionQueryResult::GetHits(HavokPhysics_CollisionQueryResult *this)
{
  return ?GetHits@HavokPhysics_CollisionQueryResult@@QEBAPEBUhknpCollisionResult@@XZ(this);
}

/*
==============
HavokPhysics_InstantiateAsset
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateAsset(Physics_WorldId worldId, const XModel *xModel, const PhysicsAsset *physicsAsset, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAsset@@YAIW4Physics_WorldId@@PEBUXModel@@PEBUPhysicsAsset@@HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55PEAUPhysics_InstantiateShapeOverride@@W4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@5@Z(worldId, xModel, physicsAsset, ref, position, orientation, add, forceAddImmediate, tryStartDeactivated, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_WarpRigidBodyToRelative
==============
*/

void __fastcall HavokPhysics_WarpRigidBodyToRelative(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkStartPosition, const hkQuaternionf *hkStartOrientation, const hkVector4f *hkEndPosition, const hkQuaternionf *hkEndOrientation)
{
  ?HavokPhysics_WarpRigidBodyToRelative@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@23@Z(worldId, bodyId, hkStartPosition, hkStartOrientation, hkEndPosition, hkEndOrientation);
}

/*
==============
HavokPhysics_Shutdown
==============
*/

void HavokPhysics_Shutdown(void)
{
  ?HavokPhysics_Shutdown@@YAXXZ();
}

/*
==============
HavokPhysics_MovePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_MovePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_RemoveShapeList
==============
*/

void __fastcall HavokPhysics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  ?HavokPhysics_RemoveShapeList@@YAXPEADI@Z(rawShapeData, rawShapeDataSize);
}

/*
==============
HavokPhysics_CreateShapeConvexHullFromAABB
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeConvexHullFromAABB(const hkVector4f *mins, const hkVector4f *maxs)
{
  return ?HavokPhysics_CreateShapeConvexHullFromAABB@@YAPEAVhknpShape@@AEBVhkVector4f@@0@Z(mins, maxs);
}

/*
==============
HavokPhysics_FreeBroadphaseCollisionQueryResult
==============
*/

void __fastcall HavokPhysics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?HavokPhysics_FreeBroadphaseCollisionQueryResult@@YAXPEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(result);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyCount
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetBodyCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_DrawDebugShapecast
==============
*/

void __fastcall HavokPhysics_DrawDebugShapecast(Physics_WorldId worldId, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugShapecast@@YAXW4Physics_WorldId@@IPEBUScreenPlacement@@PEAM2MM@Z(worldId, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MoveXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_MoveXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_SwapPhysicsAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_SwapPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_BatchRaycast
==============
*/

void __fastcall HavokPhysics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const hkVector4f *starts, const hkVector4f *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  ?HavokPhysics_BatchRaycast@@YAXW4Physics_WorldId@@IPEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAPEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numRays, starts, ends, extendedData, results);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?HavokPhysics_GetDetailCollisionShapeTag@@YAGPEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::cannotAllocate
==============
*/

void __fastcall HavokPhysicsLBALimitedMemoryListener::cannotAllocate(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  ?cannotAllocate@HavokPhysicsLBALimitedMemoryListener@@EEAAX_K@Z(this, size);
}

/*
==============
HavokPhysics_GetRigidBodyContents
==============
*/

int __fastcall HavokPhysics_GetRigidBodyContents(const Physics_WorldId worldId, const hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRigidBodyContents@@YAHW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CreateShapeConvexHull
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeConvexHull(hkArray<hkVector4f,hkContainerHeapAllocator> *verts, unsigned int maxNumGeneratedVertices, bool useCache)
{
  return ?HavokPhysics_CreateShapeConvexHull@@YAPEAVhknpShape@@AEAV?$hkArray@VhkVector4f@@UhkContainerHeapAllocator@@@@I_N@Z(verts, maxNumGeneratedVertices, useCache);
}

/*
==============
HavokPhysics_GetThreadId
==============
*/

unsigned int __fastcall HavokPhysics_GetThreadId()
{
  return ?HavokPhysics_GetThreadId@@YAIXZ();
}

/*
==============
HavokPhysics_GetNumTriCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumTriCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@2AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@5@Z(worldId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_ProcessDeferredKeyframe
==============
*/

void __fastcall HavokPhysics_ProcessDeferredKeyframe(const Physics_WorldId worldId, const float velocityScale)
{
  ?HavokPhysics_ProcessDeferredKeyframe@@YAXW4Physics_WorldId@@M@Z(worldId, velocityScale);
}

/*
==============
HavokPhysics_IsInstanceInUse
==============
*/

bool __fastcall HavokPhysics_IsInstanceInUse(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_IsInstanceInUse@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits
==============
*/

unsigned int __fastcall HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  return ?GetNumHits@HavokPhysics_BroadphaseCollisionQueryResult@@QEBAIXZ(this);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitQueryContactNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_AddInstanceToWorld
==============
*/

void __fastcall HavokPhysics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  ?HavokPhysics_AddInstanceToWorld@@YAXW4Physics_WorldId@@I_N1@Z(worldId, instanceId, immediate, tryStartDeactivated);
}

/*
==============
HavokPhysics_DrawDebugGeneralCPU
==============
*/

void __fastcall HavokPhysics_DrawDebugGeneralCPU(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGeneralCPU@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_LockWorld
==============
*/

void __fastcall HavokPhysics_LockWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_LockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AntilagRestoreInstanceTo
==============
*/

void __fastcall HavokPhysics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation)
{
  ?HavokPhysics_AntilagRestoreInstanceTo@@YAXW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@@Z(worldId, instanceId, hkPosition, hkOrientation);
}

/*
==============
HavokPhysics_IsShapeCacheDisabled
==============
*/

bool __fastcall HavokPhysics_IsShapeCacheDisabled(unsigned int threadId)
{
  return ?HavokPhysics_IsShapeCacheDisabled@@YA_NI@Z(threadId);
}

/*
==============
HavokPhysics_InstantiateAssetBody
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBody@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44HW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_UnsubscribeFromEvent
==============
*/

void __fastcall HavokPhysics_UnsubscribeFromEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (__fastcall *function)(const hknpEventHandlerInput *, const hknpEvent *))
{
  ?HavokPhysics_UnsubscribeFromEvent@@YAXW4Physics_WorldId@@W4Enum@hknpEventType@@UhknpBodyId@@P6AXAEBUhknpEventHandlerInput@@AEBUhknpEvent@@@Z@Z(worldId, eventType, specificBodyId, function);
}

/*
==============
HavokPhysics_SetMassPropertiesInertiaTensor
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, hkVector4f *inertiaTensor)
{
  ?HavokPhysics_SetMassPropertiesInertiaTensor@@YAXPEAUhkMassProperties@@AEAVhkVector4f@@@Z(massProperties, inertiaTensor);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CopyPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_CopyPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitFraction
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetRaycastHitFraction@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_ClearShapeCache
==============
*/

void HavokPhysics_ClearShapeCache(void)
{
  ?HavokPhysics_ClearShapeCache@@YAXXZ();
}

/*
==============
HavokPhysics_AllocateBroadphaseCollisionQueryResult
==============
*/

HavokPhysics_BroadphaseCollisionQueryResult *__fastcall HavokPhysics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  return ?HavokPhysics_AllocateBroadphaseCollisionQueryResult@@YAPEAVHavokPhysics_BroadphaseCollisionQueryResult@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_RenderDebug
==============
*/

void __fastcall HavokPhysics_RenderDebug(GfxCmdBufContext *gfxContext, bool includeWorlds)
{
  ?HavokPhysics_RenderDebug@@YAXUGfxCmdBufContext@@_N@Z(gfxContext, includeWorlds);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDetailCollisionShape
==============
*/

const hknpShape *__fastcall HavokPhysics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?HavokPhysics_GetDetailCollisionShape@@YAPEBVhknpShape@@PEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTransform
==============
*/

void __fastcall HavokPhysics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, hkVector4f *shapePosition, hkQuaternionf *shapeOrientationAsQuat)
{
  ?HavokPhysics_GetDetailCollisionShapeTransform@@YAXPEBUXModelDetailCollision@@HAEAVhkVector4f@@AEAVhkQuaternionf@@@Z(detailCollision, shapeIdx, shapePosition, shapeOrientationAsQuat);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_TransientZoneLoaded
==============
*/

void __fastcall HavokPhysics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  ?HavokPhysics_TransientZoneLoaded@@YAXI_N@Z(worldTransientIndex, fullLoad);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualitys
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryBodyQualitys(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryBodyQualitys@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithColLods
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  ?HavokPhysics_DrawPhysicsXModelsWithColLods@@YAXPEBUScreenPlacement@@PEAM1MM_N@Z(scrPlace, x, y, tabWidth, charHeight, excludeDoNotUse);
}

/*
==============
HavokPhysics_GetShapeConvexCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeConvexCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_DebugSetVisualizeContents
==============
*/

void __fastcall HavokPhysics_DebugSetVisualizeContents(int visualizeContents)
{
  ?HavokPhysics_DebugSetVisualizeContents@@YAXH@Z(visualizeContents);
}

/*
==============
HavokPhysics_SetRigidBodyMass
==============
*/

void __fastcall HavokPhysics_SetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float mass)
{
  ?HavokPhysics_SetRigidBodyMass@@YAXW4Physics_WorldId@@UhknpBodyId@@M@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_GetShapeTypeName
==============
*/

const char *__fastcall HavokPhysics_GetShapeTypeName(const hknpShape *shape)
{
  return ?HavokPhysics_GetShapeTypeName@@YAPEBDPEBVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_StepWorldCollide
==============
*/

void __fastcall HavokPhysics_StepWorldCollide(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldCollide@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterials
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMaterials(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMaterials@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/

void __fastcall HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredShapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@2AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, start, end, rotation, extendedData, data);
}

/*
==============
HavokPhysics_IsPhysicsAssetBodyDynamic
==============
*/

bool __fastcall HavokPhysics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_IsPhysicsAssetBodyDynamic@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastBackfaceHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_MyChangesSaveAndShutdown
==============
*/

void HavokPhysics_MyChangesSaveAndShutdown(void)
{
  ?HavokPhysics_MyChangesSaveAndShutdown@@YAXXZ();
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyTransform
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, hkVector4f *bodyPosition, hkQuaternionf *bodyOrientationAsQuat)
{
  ?HavokPhysics_GetPhysicsAssetBodyTransform@@YAXPEBUPhysicsAsset@@HAEAVhkVector4f@@AEAVhkQuaternionf@@@Z(physicsAsset, bodyIdx, bodyPosition, bodyOrientationAsQuat);
}

/*
==============
HavokPhysics_GetShapeNameFromShapeList
==============
*/

const char *__fastcall HavokPhysics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeNameFromShapeList@@YAPEBDPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_UpdateGravityScalar
==============
*/

void __fastcall HavokPhysics_UpdateGravityScalar(Physics_WorldId worldId, Physics_GravityType gravityType, float scalar)
{
  ?HavokPhysics_UpdateGravityScalar@@YAXW4Physics_WorldId@@W4Physics_GravityType@@M@Z(worldId, gravityType, scalar);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetShapecastHitContactPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_UpdateLoosenedConstraint
==============
*/

bool __fastcall HavokPhysics_UpdateLoosenedConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  return ?HavokPhysics_UpdateLoosenedConstraint@@YA_NW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@AEBVhkTransformf@@2PEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, bodyATransform, bodyBTransform, result);
}

/*
==============
HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats
==============
*/

void __fastcall HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  ??0HavokPhysics_CylinderShapeStats@@QEAA@XZ(this);
}

/*
==============
HavokPhysics_DrawPhysicsAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsAssets(bool sortByName, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsAssets@@YAX_NPEBUScreenPlacement@@PEAM2MM@Z(sortByName, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ClearAntilagFlags
==============
*/

void __fastcall HavokPhysics_ClearAntilagFlags(Physics_WorldId worldId)
{
  ?HavokPhysics_ClearAntilagFlags@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetLandscapeShapeHelper
==============
*/

void __fastcall HavokPhysics_GetLandscapeShapeHelper(const hknpShape **shape, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *meshShapeKey, int *shapeKeyPathSizeOut, hknpShapeCollector *shapeCollector)
{
  ?HavokPhysics_GetLandscapeShapeHelper@@YAXAEAPEBVhknpShape@@AEAU?$hkHandle@I$0PPPPPPPP@UhknpShapeKeyDiscriminant@@@@AEAHAEAUhknpShapeCollector@@@Z(shape, meshShapeKey, shapeKeyPathSizeOut, shapeCollector);
}

/*
==============
HavokPhysics_GetRef
==============
*/

int __fastcall HavokPhysics_GetRef(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRef@@YAHW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_ReleasePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?HavokPhysics_ReleasePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_Raycast
==============
*/

void __fastcall HavokPhysics_Raycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_Raycast@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, start, end, extendedData, result);
}

/*
==============
HavokPhysics_DisableShapeCache
==============
*/

void __fastcall HavokPhysics_DisableShapeCache(unsigned int threadId, bool disable)
{
  ?HavokPhysics_DisableShapeCache@@YAXI_N@Z(threadId, disable);
}

/*
==============
HavokPhysics_Raycast
==============
*/

void __fastcall HavokPhysics_Raycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_Raycast@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, start, end, extendedData, result);
}

/*
==============
HavokPhysics_AddPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?HavokPhysics_AddPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_GetNumConvexCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumConvexCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_AddDetailCollisionShapesToInstanceList
==============
*/

unsigned int __fastcall HavokPhysics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const hkVector4f *origin, const float scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_AddDetailCollisionShapesToInstanceList@@YAIPEBUXModelDetailCollision@@AEBVhkVector4f@@MAEBVhkQuaternionf@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(detailCollision, origin, scale, orientation, instanceArray);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/

void __fastcall HavokPhysics_DeferredRaycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredRaycast@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, start, end, extendedData, data);
}

/*
==============
HavokPhysics_WarpLeafDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase, bool activate)
{
  return ?HavokPhysics_WarpLeafDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@_N4@Z(worldId, bodyId, hkPosition, hkOrientation, updateBroadphase, activate);
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMass)
{
  ?HavokPhysics_GetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
HavokPhysics_DrawPhysicsContents
==============
*/

void __fastcall HavokPhysics_DrawPhysicsContents(unsigned int contents, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsContents@@YAXIPEBUScreenPlacement@@PEAM1MM@Z(contents, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_QueryPoint@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, point, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_TransientZoneUnloading
==============
*/

void __fastcall HavokPhysics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  ?HavokPhysics_TransientZoneUnloading@@YAXI_N@Z(worldTransientIndex, fullUnload);
}

/*
==============
HavokPhysics_InstantiateDetailModel
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  return ?HavokPhysics_InstantiateDetailModel@@YAIW4Physics_WorldId@@PEBUXModel@@HAEBVhkVector4f@@AEBVhkQuaternionf@@_N444@Z(worldId, detailModel, ref, position, orientation, add, tryStartDeactivated, forQueryOnly, allowSingleBodyAddToWorld);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugWorld
==============
*/

void __fastcall HavokPhysics_DrawDebugWorld(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorld@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DestroyInstance
==============
*/

void __fastcall HavokPhysics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?HavokPhysics_DestroyInstance@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::HasHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::HasHit(HavokPhysics_CollisionQueryResult *this)
{
  return ?HasHit@HavokPhysics_CollisionQueryResult@@QEBA_NXZ(this);
}

/*
==============
HavokPhysics_GetShapeOverrideContents
==============
*/

int __fastcall HavokPhysics_GetShapeOverrideContents(int shapeOverride)
{
  return ?HavokPhysics_GetShapeOverrideContents@@YAHH@Z(shapeOverride);
}

/*
==============
HavokPhysics_IsRigidBodyDynamic
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyDynamic@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_InplaceLoad<hknpShape>
==============
*/

hknpShape *__fastcall HavokPhysics_InplaceLoad<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VhknpShape@@@@YAPEAVhknpShape@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSFXEventAssetId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  ?HavokPhysics_AddXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_DrawDebugGeneralMemory
==============
*/

void __fastcall HavokPhysics_DrawDebugGeneralMemory(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGeneralMemory@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddPhysicsLibrary
==============
*/

void __fastcall HavokPhysics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?HavokPhysics_AddPhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
HavokPhysics_GetAssetByName
==============
*/

const PhysicsAsset *__fastcall HavokPhysics_GetAssetByName(const char *name)
{
  return ?HavokPhysics_GetAssetByName@@YAPEBUPhysicsAsset@@PEBD@Z(name);
}

/*
==============
HavokPhysics_IsInstanceDeactivated
==============
*/

bool __fastcall HavokPhysics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_IsInstanceDeactivated@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinAngSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxLinAngSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM2@Z(worldId, bodyId, maxLinSpeed, maxAngSpeed);
}

/*
==============
HavokPhysics_IsRigidBodyStatic
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyStatic@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsShapeList>
==============
*/

HavokPhysicsShapeList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsShapeList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsShapeList@@@@YAPEAVHavokPhysicsShapeList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_StepWorldStart
==============
*/

void __fastcall HavokPhysics_StepWorldStart(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldStart@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_CreateShapeCylinder
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCylinder(const hkVector4f *center, float halfHeight, float radius, int numVertices, bool useCache)
{
  return ?HavokPhysics_CreateShapeCylinder@@YAPEAVhknpShape@@AEBVhkVector4f@@MMH_N@Z(center, halfHeight, radius, numVertices, useCache);
}

/*
==============
HavokPhysics_InstantiateAssetBodyCylinder
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBodyCylinder@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44MMW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, radius, height, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly(HavokPhysics_IgnoreBodies *this, bool simulationBodiesOnly)
{
  ?SetSimulationBodiesOnly@HavokPhysics_IgnoreBodies@@QEAAX_N@Z(this, simulationBodiesOnly);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetClosestPointHitHitPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_InstantiateKeyframedBody
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateKeyframedBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55@Z(worldId, shape, ref, name, physicsMaterial, collisionFilterInfo, position, orientation, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
HavokPhysics_UnlockAssetWrite
==============
*/

void HavokPhysics_UnlockAssetWrite(void)
{
  ?HavokPhysics_UnlockAssetWrite@@YAXXZ();
}

/*
==============
HavokPhysics_IsRigidBodyActive
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyActive(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyActive@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_DrawWorld
==============
*/

void __fastcall HavokPhysics_DrawWorld(Physics_WorldId worldId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawWorld@@YAXW4Physics_WorldId@@_NPEBUScreenPlacement@@PEAM3MM@Z(worldId, fullDisplay, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MovePhysicsAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_MovePhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_KeyframeInstanceTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeInstanceTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@M_N3M@Z(worldId, instanceId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetRaycastHitNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_SetMassPropertiesCenterOfMass
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, hkVector4f *centerOfMass)
{
  ?HavokPhysics_SetMassPropertiesCenterOfMass@@YAXPEAUhkMassProperties@@AEAVhkVector4f@@@Z(massProperties, centerOfMass);
}

/*
==============
HavokPhysics_AllocateCollisionQueryResult
==============
*/

HavokPhysics_CollisionQueryResult *__fastcall HavokPhysics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  return ?HavokPhysics_AllocateCollisionQueryResult@@YAPEAVHavokPhysics_CollisionQueryResult@@W4Physics_WorldId@@W4Physics_CollisionQueryCollectionType@@@Z(worldId, type);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBQuery@@YAXW4Physics_WorldId@@UhknpBodyId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_ApplyImpulse
==============
*/

void __fastcall HavokPhysics_ApplyImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2M@Z(worldId, bodyId, hkPosition, hkDirection, magnitude);
}

/*
==============
HavokPhysics_TakeSnapshot
==============
*/

void __fastcall HavokPhysics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  ?HavokPhysics_TakeSnapshot@@YAXW4Physics_WorldId@@PEBD_N@Z(worldId, filename, humanReadable);
}

/*
==============
HavokPhysics_AddClipMap
==============
*/

void __fastcall HavokPhysics_AddClipMap(clipMap_t *clipMap)
{
  ?HavokPhysics_AddClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
HavokPhysics_DecodeSubShapeKey
==============
*/

void __fastcall HavokPhysics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *shapeInstanceId)
{
  ?HavokPhysics_DecodeSubShapeKey@@YAXW4Physics_WorldId@@I_KPEAHAEAU?$hkHandle@G$0PPPP@UhknpShapeInstanceIdDiscriminant@@@@@Z(worldId, instanceId, key, bodyIdx, shapeInstanceId);
}

/*
==============
HavokPhysics_DebugSetVisualizeQuery
==============
*/

void __fastcall HavokPhysics_DebugSetVisualizeQuery(bool showQueryBodies)
{
  ?HavokPhysics_DebugSetVisualizeQuery@@YAX_N@Z(showQueryBodies);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDetailHitData
==============
*/

const Physics_DetailHitData *__fastcall HavokPhysics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  return ?HavokPhysics_GetDetailHitData@@YAPEBUPhysics_DetailHitData@@PEBVHavokPhysics_CollisionQueryResult@@HH@Z(result, modifierIndex, hitIndex);
}

/*
==============
HavokPhysics_GetInstantiatiationPenetrationDepthForAsset
==============
*/

double __fastcall HavokPhysics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const hkVector4f *position, const hkQuaternionf *orientation, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetInstantiatiationPenetrationDepthForAsset@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@AEBVhkVector4f@@AEBVhkQuaternionf@@PEAUPhysics_InstantiateShapeOverride@@H@Z(worldId, physicsAsset, position, orientation, shapeOverride, ignoreSystems);
  return result;
}

/*
==============
HavokPhysics_Init
==============
*/

void __fastcall HavokPhysics_Init(char *generalMemoryBuffer, int generalMemoryBufferSize, int generalMemoryBufferWarningThreshold, char *debugMemoryBuffer, int debugMemoryBufferSize)
{
  ?HavokPhysics_Init@@YAXPEADHH0H@Z(generalMemoryBuffer, generalMemoryBufferSize, generalMemoryBufferWarningThreshold, debugMemoryBuffer, debugMemoryBufferSize);
}

/*
==============
HavokPhysics_CopyXModelAsset
==============
*/

void __fastcall HavokPhysics_CopyXModelAsset(XModel *from, XModel *to)
{
  ?HavokPhysics_CopyXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
HavokPhysics_MoveXModelAsset
==============
*/

void __fastcall HavokPhysics_MoveXModelAsset(XModel *from, XModel *to)
{
  ?HavokPhysics_MoveXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
HavokPhysics_DrawDebugQueryPoint
==============
*/

void __fastcall HavokPhysics_DrawDebugQueryPoint(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugQueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MIPEBUScreenPlacement@@PEAM3MM@Z(worldId, position, maxDistance, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_LockAssetWrite
==============
*/

void HavokPhysics_LockAssetWrite(void)
{
  ?HavokPhysics_LockAssetWrite@@YAXXZ();
}

/*
==============
HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer
==============
*/

void __fastcall HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer(HavokPhysics_SimpleShapeBuffer *this)
{
  ??1HavokPhysics_SimpleShapeBuffer@@UEAA@XZ(this);
}

/*
==============
HavokPhysics_SnapshotFixup::Validate
==============
*/

void __fastcall HavokPhysics_SnapshotFixup::Validate(HavokPhysics_SnapshotFixup *this, HavokPhysicsWorld *world)
{
  ?Validate@HavokPhysics_SnapshotFixup@@QEAAXPEAUHavokPhysicsWorld@@@Z(this, world);
}

/*
==============
HavokPhysics_DrawDebugBadColLods
==============
*/

void __fastcall HavokPhysics_DrawDebugBadColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugBadColLods@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
hkKeycodeManager::setKeycodes
==============
*/

hkResult __fastcall hkKeycodeManager::setKeycodes()
{
  return ?setKeycodes@hkKeycodeManager@@SA?AUhkResult@@XZ();
}

/*
==============
HavokPhysics_DrawDebugAABBWorldQuery
==============
*/

void __fastcall HavokPhysics_DrawDebugAABBWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugAABBWorldQuery@@YAXW4Physics_WorldId@@IVhkAabb@@PEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, aabb, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_SwapPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_SwapPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_MovePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_MovePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_AddPhysicsAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  ?HavokPhysics_AddPhysicsAsset@@YAXPEAUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQuerySurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDebugWorldPersistantMemoryPeak
==============
*/

int __fastcall HavokPhysics_GetDebugWorldPersistantMemoryPeak(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetDebugWorldPersistantMemoryPeak@@YAHW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionProperties
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMotionProperties(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMotionProperties@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DrawDebugMutableShapesInWorld
==============
*/

void __fastcall HavokPhysics_DrawDebugMutableShapesInWorld(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, Physics_WorldId worldId, float detailRange)
{
  ?HavokPhysics_DrawDebugMutableShapesInWorld@@YAXPEBUScreenPlacement@@PEAM1MMW4Physics_WorldId@@M@Z(scrPlace, x, y, tabWidth, charHeight, worldId, detailRange);
}

/*
==============
HavokPhysics_DrawPhysicsXModelId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelId(bool indexByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsXModelId@@YAX_NHPEBUScreenPlacement@@PEAM2MM@Z(indexByName, assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetWorldId
==============
*/

Physics_WorldId __fastcall HavokPhysics_GetWorldId(const hknpWorld *world)
{
  return ?HavokPhysics_GetWorldId@@YA?AW4Physics_WorldId@@PEBVhknpWorld@@@Z(world);
}

/*
==============
HavokPhysics_GetNumShapesInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumShapesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_Write
==============
*/

void __fastcall HavokPhysics_Write(MemoryFile *memFile)
{
  ?HavokPhysics_Write@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DeactivateBody
==============
*/

void __fastcall HavokPhysics_DeactivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_DeactivateBody@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_Load
==============
*/

void __fastcall HavokPhysics_Load(SaveGame *save)
{
  ?HavokPhysics_Load@@YAXPEAUSaveGame@@@Z(save);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_CalcShapeRadius
==============
*/

void __fastcall HavokPhysics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  ?HavokPhysics_CalcShapeRadius@@YAXPEBVhknpShape@@AEAM@Z(shape, radiusOut);
}

/*
==============
HavokPhysics_StopDrawDebugWorld
==============
*/

void __fastcall HavokPhysics_StopDrawDebugWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_StopDrawDebugWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetRef
==============
*/

int __fastcall HavokPhysics_GetRef(const hknpBody *body)
{
  return ?HavokPhysics_GetRef@@YAHAEBVhknpBody@@@Z(body);
}

/*
==============
HavokPhysics_SetMapLocalAllocatorBuffer
==============
*/

void __fastcall HavokPhysics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  ?HavokPhysics_SetMapLocalAllocatorBuffer@@YAXPEAXI@Z(buffer, size);
}

/*
==============
HavokPhysics_SwapPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_SwapPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/

void __fastcall HavokPhysics_DeferredRaycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredRaycast@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, start, end, extendedData, data);
}

/*
==============
HavokPhysics_RemoveModifier
==============
*/

void __fastcall HavokPhysics_RemoveModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  ?HavokPhysics_RemoveModifier@@YAXW4Physics_WorldId@@PEAVhknpModifier@@@Z(worldId, modifier);
}

/*
==============
HavokPhysics_GetInstanceXModel
==============
*/

const XModel *__fastcall HavokPhysics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceXModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_RemoveInstanceFromWorld
==============
*/

void __fastcall HavokPhysics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?HavokPhysics_RemoveInstanceFromWorld@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>
==============
*/

HavokPhysicsBodyQualityList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsBodyQualityList@@@@YAPEAVHavokPhysicsBodyQualityList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2M@Z(worldId, bodyId, hkPosition, hkDirection, magnitude);
}

/*
==============
HavokPhysics_StepWorldSolve
==============
*/

void __fastcall HavokPhysics_StepWorldSolve(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldSolve@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyStatic
==============
*/

void __fastcall HavokPhysics_SetRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyStatic@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_ReleaseShape
==============
*/

void __fastcall HavokPhysics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  ?HavokPhysics_ReleaseShape@@YAXW4Physics_WorldId@@PEAVhknpShape@@_N@Z(worldId, shape, finalReference);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreBody
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreBody(HavokPhysics_IgnoreBodies *this, int index, unsigned int bodyId)
{
  ?SetIgnoreBody@HavokPhysics_IgnoreBodies@@QEAAXHI@Z(this, index, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQuerySurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsBody
==============
*/

void __fastcall HavokPhysics_DrawPhysicsBody(Physics_WorldId worldId, hknpBodyId bodyId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsBody@@YAXW4Physics_WorldId@@UhknpBodyId@@_NPEBUScreenPlacement@@PEAM4MM@Z(worldId, bodyId, fullDisplay, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetRigidBodyDynamicMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyDynamicMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  ?HavokPhysics_GetRigidBodyDynamicMass@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAM@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall HavokPhysics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *invInertia)
{
  ?HavokPhysics_GetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, invInertia);
}

/*
==============
HavokPhysics_GetRigidBodyAABB
==============
*/

void __fastcall HavokPhysics_GetRigidBodyAABB(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb, bool worldSpace)
{
  ?HavokPhysics_GetRigidBodyAABB@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkAabb@@_N@Z(worldId, bodyId, aabb, worldSpace);
}

/*
==============
HavokPhysics_SetInstanceDetailModel
==============
*/

void __fastcall HavokPhysics_SetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  ?HavokPhysics_SetInstanceDetailModel@@YAXW4Physics_WorldId@@IPEBUXModel@@@Z(worldId, instanceId, xModel);
}

/*
==============
HavokPhysics_UnlockWorld
==============
*/

void __fastcall HavokPhysics_UnlockWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_UnlockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetErrorString
==============
*/

const char *__fastcall HavokPhysics_GetErrorString()
{
  return ?HavokPhysics_GetErrorString@@YAPEBDXZ();
}

/*
==============
HavokPhysics_DecodeShapeKeyIntoShapes
==============
*/

unsigned int __fastcall HavokPhysics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> key, const hknpShape **shapes)
{
  return ?HavokPhysics_DecodeShapeKeyIntoShapes@@YAIW4Physics_WorldId@@UhknpBodyId@@U?$hkHandle@I$0PPPPPPPP@UhknpShapeKeyDiscriminant@@@@QEAPEBVhknpShape@@@Z(worldId, bodyId, key, shapes);
}

/*
==============
HavokPhysics_DrawDebugAABBBroadphaseWorldQuery
==============
*/

void __fastcall HavokPhysics_DrawDebugAABBBroadphaseWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugAABBBroadphaseWorldQuery@@YAXW4Physics_WorldId@@IVhkAabb@@PEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, aabb, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_CreateShapeCube
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCube(const hkVector4f *center, float halfSize)
{
  return ?HavokPhysics_CreateShapeCube@@YAPEAVhknpShape@@AEBVhkVector4f@@M@Z(center, halfSize);
}

/*
==============
HavokPhysics_GetConstraintBodyIds
==============
*/

void __fastcall HavokPhysics_GetConstraintBodyIds(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, hknpBodyId *bodyIdA, hknpBodyId *bodyIdB)
{
  ?HavokPhysics_GetConstraintBodyIds@@YAXW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUhknpBodyId@@2@Z(worldId, constraintId, bodyIdA, bodyIdB);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreEntity
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreEntity(HavokPhysics_IgnoreBodies *this, int index, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  ?SetIgnoreEntity@HavokPhysics_IgnoreBodies@@QEAAXHH_N0000@Z(this, index, svEntNum, self, children, parent, siblings, linked);
}

/*
==============
HavokPhysics_TightenConstraint
==============
*/

void __fastcall HavokPhysics_TightenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *values, float proportion)
{
  ?HavokPhysics_TightenConstraint@@YAXW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUPhysicsConstraintLooseningResult@@M@Z(worldId, constraintId, values, proportion);
}

/*
==============
HavokPhysics_StepWorldFX
==============
*/

void __fastcall HavokPhysics_StepWorldFX(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldFX@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_AddDeferredBulletEffectCallback
==============
*/

void __fastcall HavokPhysics_AddDeferredBulletEffectCallback(void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int), const Physics_WorldId worldId, hknpBodyId hitBodyId, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  ?HavokPhysics_AddDeferredBulletEffectCallback@@YAXP6AXW4LocalClientNum_t@@IIAEBTvec3_t@@1H1PEBW4scr_string_t@@IAEBUWeapon@@_NH@ZW4Physics_WorldId@@UhknpBodyId@@I11H1AEBW43@I34H@Z(effectCallback, worldId, hitBodyId, shapeKey, start, hitPos, hitSurfaceFlags, hitNormal, partName, inflictorEntNum, weapon, isAlternate, mod);
}

/*
==============
HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(HavokPhysics_IgnoreBodies *this, int minEntities, int minBodies)
{
  ??0HavokPhysics_IgnoreBodies@@QEAA@HH@Z(this, minEntities, minBodies);
}

/*
==============
HavokPhysics_DrawPhysicsSurfaceFlags
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSurfaceFlags(int surfFlags, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSurfaceFlags@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(surfFlags, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_IgnoreBodies::Reset
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::Reset(HavokPhysics_IgnoreBodies *this)
{
  ?Reset@HavokPhysics_IgnoreBodies@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_AddPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?HavokPhysics_AddPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_GetRigidBodyMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  ?HavokPhysics_GetRigidBodyMass@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAM@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_StepWorldPrep
==============
*/

void __fastcall HavokPhysics_StepWorldPrep(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldPrep@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_AddModifier
==============
*/

void __fastcall HavokPhysics_AddModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  ?HavokPhysics_AddModifier@@YAXW4Physics_WorldId@@PEAVhknpModifier@@@Z(worldId, modifier);
}

/*
==============
HavokPhysics_SetRigidBodyContents
==============
*/

void __fastcall HavokPhysics_SetRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  ?HavokPhysics_SetRigidBodyContents@@YAXW4Physics_WorldId@@UhknpBodyId@@H_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
HavokPhysics_PreStepWorld
==============
*/

void __fastcall HavokPhysics_PreStepWorld(Physics_WorldId worldId, float timeStep)
{
  ?HavokPhysics_PreStepWorld@@YAXW4Physics_WorldId@@M@Z(worldId, timeStep);
}

/*
==============
HavokPhysics_EnableShapeInstance
==============
*/

void __fastcall HavokPhysics_EnableShapeInstance(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> shapeInstanceId, bool enabled)
{
  ?HavokPhysics_EnableShapeInstance@@YAXW4Physics_WorldId@@UhknpBodyId@@U?$hkHandle@G$0PPPP@UhknpShapeInstanceIdDiscriminant@@@@_N@Z(worldId, bodyId, shapeInstanceId, enabled);
}

/*
==============
HavokPhysics_LockAssetRead
==============
*/

void HavokPhysics_LockAssetRead(void)
{
  ?HavokPhysics_LockAssetRead@@YAXXZ();
}

/*
==============
HavokPhysics_SetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall HavokPhysics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *invInertia)
{
  ?HavokPhysics_SetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@@Z(worldId, bodyId, invInertia);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId(HavokPhysics_BroadphaseCollisionQueryResult *this, unsigned int hitId)
{
  return ?GetHitBodyId@HavokPhysics_BroadphaseCollisionQueryResult@@QEBAII@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_UpdateBroadphase
==============
*/

void __fastcall HavokPhysics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  ?HavokPhysics_UpdateBroadphase@@YAXW4Physics_WorldId@@_N@Z(worldId, updateAll);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/

void __fastcall HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredShapecast@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, start, end, rotation, extendedData, data);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeCount
==============
*/

int __fastcall HavokPhysics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  return ?HavokPhysics_GetDetailCollisionShapeCount@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_AddPhysicsAssetShapesToInstanceList
==============
*/

unsigned int __fastcall HavokPhysics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const hkVector4f *origin, const float scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_AddPhysicsAssetShapesToInstanceList@@YAIPEBUPhysicsAsset@@AEBVhkVector4f@@MAEBVhkQuaternionf@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(physicsAsset, origin, scale, orientation, instanceArray);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitCoverWallId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_AddRigidBodyContents
==============
*/

void __fastcall HavokPhysics_AddRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  ?HavokPhysics_AddRigidBodyContents@@YAXW4Physics_WorldId@@UhknpBodyId@@H_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetWireframeGeometry
==============
*/

void __fastcall HavokPhysics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  ?HavokPhysics_GetWireframeGeometry@@YAXPEAVhknpShape@@PEATvec3_t@@HPEAH@Z(shape, pointArray, pointArraySize, numLines);
}

/*
==============
HavokPhysics_DrawDebugPhysicsRefSystemCounts
==============
*/

void __fastcall HavokPhysics_DrawDebugPhysicsRefSystemCounts(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugPhysicsRefSystemCounts@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddDeferredBulletForce
==============
*/

void __fastcall HavokPhysics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  ?HavokPhysics_AddDeferredBulletForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@1I_NAEBUWeapon@@_NHP6AXW4LocalClientNum_t@@II11H1PEBW4scr_string_t@@I34H@Z@Z(worldId, start, end, inflictorEntNum, isMelee, weapon, isAlternate, mod, effectCallback);
}

/*
==============
HavokPhysics_GetStepInput
==============
*/

hknpStepInput *__fastcall HavokPhysics_GetStepInput(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetStepInput@@YAPEAUhknpStepInput@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyToDefault
==============
*/

void __fastcall HavokPhysics_SetRigidBodyToDefault(Physics_WorldId worldId, hknpBodyId bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  ?HavokPhysics_SetRigidBodyToDefault@@YAXW4Physics_WorldId@@UhknpBodyId@@PEBUPhysicsAsset@@I@Z(worldId, bodyId, asset, assetIndex);
}

/*
==============
HavokPhysics_DrawDebugRaycast
==============
*/

void __fastcall HavokPhysics_DrawDebugRaycast(Physics_WorldId worldId, unsigned int collisionFilterInfo, bool isClutter, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugRaycast@@YAXW4Physics_WorldId@@I_NPEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, isClutter, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_SetRigidBodyKeyframed
==============
*/

void __fastcall HavokPhysics_SetRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyKeyframed@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_IsInstanceInWorld
==============
*/

bool __fastcall HavokPhysics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  return ?HavokPhysics_IsInstanceInWorld@@YA_NW4Physics_WorldId@@I_N@Z(worldId, instanceId, checkPending);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetNumHits
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetNumHits(HavokPhysics_CollisionQueryResult *this)
{
  return ?GetNumHits@HavokPhysics_CollisionQueryResult@@QEBAIXZ(this);
}

/*
==============
HavokPhysics_CollisionQueryResult::SortResults
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::SortResults(HavokPhysics_CollisionQueryResult *this)
{
  ?SortResults@HavokPhysics_CollisionQueryResult@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_GetTaskQueue
==============
*/

hkDefaultTaskQueue *__fastcall HavokPhysics_GetTaskQueue(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetTaskQueue@@YAPEAVhkDefaultTaskQueue@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_FindShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_FindShapeTag(HavokPhysicsShapeList::ShapeTagData *shapeTagData)
{
  return ?HavokPhysics_FindShapeTag@@YAGAEAUShapeTagData@HavokPhysicsShapeList@@@Z(shapeTagData);
}

/*
==============
HavokPhysics_DestroyWorld
==============
*/

void __fastcall HavokPhysics_DestroyWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_DestroyWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CreateInstance
==============
*/

unsigned int __fastcall HavokPhysics_CreateInstance(Physics_WorldId worldId)
{
  return ?HavokPhysics_CreateInstance@@YAIW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AntilagWarpInstanceTo
==============
*/

bool __fastcall HavokPhysics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, hkVector4f *hkRestorePosition, hkQuaternionf *hkRestoreOrientation)
{
  return ?HavokPhysics_AntilagWarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@AEAV2@AEAV3@@Z(worldId, instanceId, hkPosition, hkOrientation, hkRestorePosition, hkRestoreOrientation);
}

/*
==============
HavokPhysics_ActivateBody
==============
*/

void __fastcall HavokPhysics_ActivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_ActivateBody@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_FindMaterialId
==============
*/

hknpMaterialId *__fastcall HavokPhysics_FindMaterialId(hknpMaterialId *result, const char *physicsMaterial)
{
  return ?HavokPhysics_FindMaterialId@@YA?AUhknpMaterialId@@PEBD@Z(result, physicsMaterial);
}

/*
==============
HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled
==============
*/

bool __fastcall HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled(const Physics_WorldId worldId)
{
  return ?HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/

void __fastcall HavokPhysics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  ?HavokPhysics_DestroyConstraint@@YAXW4Physics_WorldId@@IH_N@Z(worldId, instanceId, constraintIdx, activate);
}

/*
==============
HavokPhysics_GetContentsFromShapeList
==============
*/

int __fastcall HavokPhysics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetContentsFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_CreateShapeCapsulePoints
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsulePoints(Physics_WorldId worldId, const hkVector4f *a, const hkVector4f *b, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?HavokPhysics_CreateShapeCapsulePoints@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBVhkVector4f@@1MPEADHW4Physics_ShapeStorage@@@Z(worldId, a, b, radius, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsVFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsVFXEventAssetId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_InstantiateHingeConstraint
==============
*/

bool __fastcall HavokPhysics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIndex, hkVector4f *pos, hkVector4f *dir, float friction, float minAngle, float maxAngle, float breakingThreshold, unsigned int *outConstraintId)
{
  return ?HavokPhysics_InstantiateHingeConstraint@@YA_NW4Physics_WorldId@@IIAEAVhkVector4f@@1MMMMPEAI@Z(worldId, instanceId, bodyIndex, pos, dir, friction, minAngle, maxAngle, breakingThreshold, outConstraintId);
}

/*
==============
HavokPhysics_DirtyBroadphase
==============
*/

void __fastcall HavokPhysics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  ?HavokPhysics_DirtyBroadphase@@YAXW4Physics_WorldId@@PEBV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@@Z(worldId, array);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_IsRigidBodyKeyframed
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyKeyframed@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_AccumulateAngularImpulse
==============
*/

void __fastcall HavokPhysics_AccumulateAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *impulseWs, const hkVector4f *atPointWs, hkVector4f *outAngularVelWs)
{
  ?HavokPhysics_AccumulateAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2AEAV3@@Z(worldId, bodyId, impulseWs, atPointWs, outAngularVelWs);
}

/*
==============
HavokPhysics_DoGarbageCollectionClient
==============
*/

void HavokPhysics_DoGarbageCollectionClient(void)
{
  ?HavokPhysics_DoGarbageCollectionClient@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetClosestPointHitQueryPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_GetDetailCollisionContents
==============
*/

int __fastcall HavokPhysics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  return ?HavokPhysics_GetDetailCollisionContents@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyVelocity
==============
*/

void __fastcall HavokPhysics_SetRigidBodyVelocity(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkLinVel, const hkVector4f *hkAngVel)
{
  ?HavokPhysics_SetRigidBodyVelocity@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2@Z(worldId, bodyId, hkLinVel, hkAngVel);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitHitContactNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_IsMeshShape
==============
*/

bool __fastcall HavokPhysics_IsMeshShape(const hknpShape *shape)
{
  return ?HavokPhysics_IsMeshShape@@YA_NPEBVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_SetRigidBodyUserData
==============
*/

void __fastcall HavokPhysics_SetRigidBodyUserData(Physics_WorldId worldId, hknpBodyId bodyId, unsigned __int64 userData)
{
  ?HavokPhysics_SetRigidBodyUserData@@YAXW4Physics_WorldId@@UhknpBodyId@@_K@Z(worldId, bodyId, userData);
}

/*
==============
HavokPhysics_SetMassPropertiesMass
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesMass(hkMassProperties *massProperties, float mass)
{
  ?HavokPhysics_SetMassPropertiesMass@@YAXPEAUhkMassProperties@@M@Z(massProperties, mass);
}

/*
==============
HavokPhysics_GetDetailBoundingSphereMax
==============
*/

double __fastcall HavokPhysics_GetDetailBoundingSphereMax(Physics_WorldId worldId)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetDetailBoundingSphereMax@@YAMW4Physics_WorldId@@@Z(worldId);
  return result;
}

/*
==============
HavokPhysics_FreeCollisionQueryResult
==============
*/

void __fastcall HavokPhysics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_FreeCollisionQueryResult@@YAXPEAVHavokPhysics_CollisionQueryResult@@@Z(result);
}

/*
==============
HavokPhysics_GetShape
==============
*/

hknpShape *__fastcall HavokPhysics_GetShape(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetShape@@YAPEAVhknpShape@@W4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_OnThreadShutdown
==============
*/

void __fastcall HavokPhysics_OnThreadShutdown(unsigned int threadId)
{
  ?HavokPhysics_OnThreadShutdown@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreRefs
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreRefs(HavokPhysics_IgnoreBodies *this, int refFlags)
{
  ?SetIgnoreRefs@HavokPhysics_IgnoreBodies@@QEAAXH@Z(this, refFlags);
}

/*
==============
HavokPhysics_EnableDeactivationForBody
==============
*/

void __fastcall HavokPhysics_EnableDeactivationForBody(Physics_WorldId worldId, hknpBodyId bodyId, bool enableDeactivation)
{
  ?HavokPhysics_EnableDeactivationForBody@@YAXW4Physics_WorldId@@UhknpBodyId@@_N@Z(worldId, bodyId, enableDeactivation);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionPropertiesId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMotionPropertiesId(const hknpMotionProperties *worldMotionProperties, int motionPropertiesId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMotionPropertiesId@@YAXPEBVhknpMotionProperties@@HPEBUScreenPlacement@@PEAM2MM@Z(worldMotionProperties, motionPropertiesId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MyChangesInitAndLoad
==============
*/

void HavokPhysics_MyChangesInitAndLoad(void)
{
  ?HavokPhysics_MyChangesInitAndLoad@@YAXXZ();
}

/*
==============
HavokPhysics_SetErrorString
==============
*/

void __fastcall HavokPhysics_SetErrorString(const char *string)
{
  ?HavokPhysics_SetErrorString@@YAXPEBD@Z(string);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationMapLocal
==============
*/

void __fastcall HavokPhysics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  ?HavokPhysics_SetThreadHeapAllocationMapLocal@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_SmoothTimeStep
==============
*/

void __fastcall HavokPhysics_SmoothTimeStep(Physics_WorldId worldId, float timeStep)
{
  ?HavokPhysics_SmoothTimeStep@@YAXW4Physics_WorldId@@M@Z(worldId, timeStep);
}

/*
==============
HavokPhysics_RemoveRigidBodiesFromWorld
==============
*/

void __fastcall HavokPhysics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, hknpBodyId *bodyIds, int bodyCount, bool activate)
{
  ?HavokPhysics_RemoveRigidBodiesFromWorld@@YAXW4Physics_WorldId@@PEAUhknpBodyId@@H_N@Z(worldId, bodyIds, bodyCount, activate);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CopyPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_CopyPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>
==============
*/

HavokPhysicsMotionPropertiesList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsMotionPropertiesList@@@@YAPEAVHavokPhysicsMotionPropertiesList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CreateShapeCompound
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_CreateShapeCompound@@YAPEAVhknpShape@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(instanceArray);
}

/*
==============
HavokPhysics_ReleasePhysicsLibrary
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?HavokPhysics_ReleasePhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
HavokPhysics_GetPhysicsAssetShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetShapeTag@@YAGPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_TakeMemorySnapshot
==============
*/

void __fastcall HavokPhysics_TakeMemorySnapshot(const char *filename)
{
  ?HavokPhysics_TakeMemorySnapshot@@YAXPEBD@Z(filename);
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintCount
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetConstraintCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_DeferredAABBBroadphaseQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBBroadphaseQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAUPhysics_DeferredBroadphaseCollisionQueryData@@@Z(worldId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_StepWorldDetail
==============
*/

void __fastcall HavokPhysics_StepWorldDetail(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldDetail@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetShapeVertCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeVertCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_GetNumServerRigidBodysInAsset
==============
*/

int __fastcall HavokPhysics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetNumServerRigidBodysInAsset@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSFXEventAssets@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitFraction
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetShapecastHitFraction@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_IsPhysicsAssetDynamic
==============
*/

bool __fastcall HavokPhysics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_IsPhysicsAssetDynamic@@YA_NPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_StepWorldPhysicsObjects
==============
*/

void __fastcall HavokPhysics_StepWorldPhysicsObjects(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldPhysicsObjects@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetNumVertCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumVertCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_CreateShapeSphere
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeSphere(const hkVector4f *center, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  return ?HavokPhysics_CreateShapeSphere@@YAPEAVhknpShape@@AEBVhkVector4f@@MPEADH@Z(center, radius, optionalInplaceBuffer, optionalInplaceBufferSize);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitSurfaceNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_RemoveClipMap
==============
*/

void __fastcall HavokPhysics_RemoveClipMap(clipMap_t *clipMap)
{
  ?HavokPhysics_RemoveClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
HavokPhysics_KeyframeRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@M_N4M@Z(worldId, bodyId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_ReleaseMapLocalAllocatorBuffer
==============
*/

void HavokPhysics_ReleaseMapLocalAllocatorBuffer(void)
{
  ?HavokPhysics_ReleaseMapLocalAllocatorBuffer@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit(HavokPhysics_CollisionQueryResult *this, Physics_WorldId worldId, HavokPhysics_CollisionQueryResult *queryPointResult, int hitIndex, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData)
{
  ?AddQueryPointHitAsRaycastHit@HavokPhysics_CollisionQueryResult@@QEAAXW4Physics_WorldId@@PEAV1@HAEBTvec3_t@@2PEAUPhysics_RaycastExtendedData@@@Z(this, worldId, queryPointResult, hitIndex, start, end, extendedData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualityId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryBodyQualityId(int bodyQualityId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryBodyQualityId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(bodyQualityId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DrawPhysicsAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsAssetId(bool sortByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsAssetId@@YAX_NHPEBUScreenPlacement@@PEAM2MM@Z(sortByName, assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_WarpInstanceTo
==============
*/

bool __fastcall HavokPhysics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphaseIfNecessary)
{
  return ?HavokPhysics_WarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@_N@Z(worldId, instanceId, hkPosition, hkOrientation, updateBroadphaseIfNecessary);
}

/*
==============
HavokPhysics_FlushMovedStatics
==============
*/

void __fastcall HavokPhysics_FlushMovedStatics(Physics_WorldId worldId)
{
  ?HavokPhysics_FlushMovedStatics@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AddPendingBodies
==============
*/

void __fastcall HavokPhysics_AddPendingBodies(Physics_WorldId worldId)
{
  ?HavokPhysics_AddPendingBodies@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_UnlockAssetRead
==============
*/

void HavokPhysics_UnlockAssetRead(void)
{
  ?HavokPhysics_UnlockAssetRead@@YAXXZ();
}

/*
==============
HavokPhysics_AddDetailTrace
==============
*/

void __fastcall HavokPhysics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  ?HavokPhysics_AddDetailTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@PEAE@Z(result, detailPriorityMap);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numBodies, bodyIds, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_GetClothVisContexts
==============
*/

void __fastcall HavokPhysics_GetClothVisContexts(const unsigned int clothIdx, unsigned int *numContexts, hclClothContext **clothContexts)
{
  ?HavokPhysics_GetClothVisContexts@@YAXIPEAIPEAPEAVhclClothContext@@@Z(clothIdx, numContexts, clothContexts);
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMassLocal
==============
*/

void __fastcall HavokPhysics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMassLocal)
{
  ?HavokPhysics_GetRigidBodyCenterOfMassLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, centerOfMassLocal);
}

/*
==============
HavokPhysics_AddRigidBodyIdToArray
==============
*/

void __fastcall HavokPhysics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, hknpBodyId bodyId)
{
  ?HavokPhysics_AddRigidBodyIdToArray@@YAXPEAV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@UhknpBodyId@@@Z(array, bodyId);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredQueryPoint@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, point, maxDistance, extendedData, data);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::allocationFailure
==============
*/

void __fastcall HavokPhysicsLBALimitedMemoryListener::allocationFailure(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  ?allocationFailure@HavokPhysicsLBALimitedMemoryListener@@EEAAX_K@Z(this, size);
}

/*
==============
HavokPhysics_WarpDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_WarpDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase, bool activate)
{
  return ?HavokPhysics_WarpDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@_N4@Z(worldId, bodyId, hkPosition, hkOrientation, updateBroadphase, activate);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationGeneral
==============
*/

void __fastcall HavokPhysics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  ?HavokPhysics_SetThreadHeapAllocationGeneral@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetClosestPointHitDistance@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_GetThreadPool
==============
*/

HavokPhysicsThreadPool *__fastcall HavokPhysics_GetThreadPool()
{
  return ?HavokPhysics_GetThreadPool@@YAPEAVHavokPhysicsThreadPool@@XZ();
}

/*
==============
HavokPhysics_GetWorld
==============
*/

hknpWorld *__fastcall HavokPhysics_GetWorld(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetWorld@@YAPEAVhknpWorld@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DrawDebugWorldMemory
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldMemory(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorldMemory@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ReleaseXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  ?HavokPhysics_ReleaseXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@_N@Z(detailCollision, unloadPackFileData);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_DoDeferredQueries
==============
*/

void __fastcall HavokPhysics_DoDeferredQueries(Physics_WorldId worldId)
{
  ?HavokPhysics_DoDeferredQueries@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_ProcessDeferredForce
==============
*/

void __fastcall HavokPhysics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  ?HavokPhysics_ProcessDeferredForce@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AddShapeReference
==============
*/

void __fastcall HavokPhysics_AddShapeReference(hknpShape *shape)
{
  ?HavokPhysics_AddShapeReference@@YAXPEAVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_GetShapeUserData
==============
*/

unsigned __int64 __fastcall HavokPhysics_GetShapeUserData(hknpShape *inShape)
{
  return ?HavokPhysics_GetShapeUserData@@YA_KPEAVhknpShape@@@Z(inShape);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredQueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, point, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugDetailModel
==============
*/

void __fastcall HavokPhysics_DrawDebugDetailModel(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugDetailModel@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintBodyIds
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  ?HavokPhysics_GetPhysicsAssetConstraintBodyIds@@YAXPEBUPhysicsAsset@@HPEAH1@Z(physicsAsset, constraintIdx, bodyId1, bodyId2);
}

/*
==============
HavokPhysics_InplaceUnload
==============
*/

void __fastcall HavokPhysics_InplaceUnload(void *buffer, const unsigned __int64 size)
{
  ?HavokPhysics_InplaceUnload@@YAXPEAX_K@Z(buffer, size);
}

/*
==============
HavokPhysics_CopyPhysicsAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_CopyPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_GetInstanceAsset
==============
*/

const PhysicsAsset *__fastcall HavokPhysics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceAsset@@YAPEBUPhysicsAsset@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_UpdateWorld
==============
*/

void __fastcall HavokPhysics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  ?HavokPhysics_UpdateWorld@@YAXW4Physics_WorldId@@_N@Z(worldId, syncStats);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_Task
==============
*/

void __fastcall HavokPhysics_Task(Physics_WorldId worldId, int taskId)
{
  ?HavokPhysics_Task@@YAXW4Physics_WorldId@@H@Z(worldId, taskId);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_GetRigidBodyDefaultMass
==============
*/

double __fastcall HavokPhysics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetRigidBodyDefaultMass@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@@Z(worldId, physAsset);
  return result;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_SnapshotFixup::getShapeForBody
==============
*/

const hknpShape *__fastcall HavokPhysics_SnapshotFixup::getShapeForBody(HavokPhysics_SnapshotFixup *this, hknpBody *body)
{
  return ?getShapeForBody@HavokPhysics_SnapshotFixup@@UEAAPEBVhknpShape@@AEAVhknpBody@@@Z(this, body);
}

/*
==============
HavokPhysics_IsRigidBodyValid
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyValid(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyValid@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_SwapXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_SwapXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastInternalHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastInternalHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastInternalHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_ApplyLinearImpulse
==============
*/

void __fastcall HavokPhysics_ApplyLinearImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyLinearImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@M@Z(worldId, bodyId, hkDirection, magnitude);
}

/*
==============
HavokPhysics_IsAssetBodyAnimationDriven
==============
*/

bool __fastcall HavokPhysics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_IsAssetBodyAnimationDriven@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_StepVDB
==============
*/

void __fastcall HavokPhysics_StepVDB(Physics_WorldId worldId, float time, bool updateStats)
{
  ?HavokPhysics_StepVDB@@YAXW4Physics_WorldId@@M_N@Z(worldId, time, updateStats);
}

/*
==============
HavokPhysics_GetNumShapeNamesInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumShapeNamesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_ReleaseXModelAsset
==============
*/

void __fastcall HavokPhysics_ReleaseXModelAsset(XModel *xmodel)
{
  ?HavokPhysics_ReleaseXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_QueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, point, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_ProcessDeferredForceCallbacks
==============
*/

void __fastcall HavokPhysics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  ?HavokPhysics_ProcessDeferredForceCallbacks@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_SetMainShapeList
==============
*/

void __fastcall HavokPhysics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  ?HavokPhysics_SetMainShapeList@@YAXPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>
==============
*/

HavokPhysicsAsset *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VHavokPhysicsAsset@@@@YAPEAVHavokPhysicsAsset@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_HasSFXEventAsset
==============
*/

bool __fastcall HavokPhysics_HasSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasSFXEventAsset@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/

void __fastcall HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, hknpBodyId bodyId, const hkVector4f *hkInstancePosition, const hkQuaternionf *hkInstanceOrientation, hkVector4f *hkBodyPosition, hkQuaternionf *hkBodyOrientation)
{
  ?HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo@@YAXW4Physics_WorldId@@IUhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@AEAV3@AEAV4@@Z(worldId, instanceId, bodyId, hkInstancePosition, hkInstanceOrientation, hkBodyPosition, hkBodyOrientation);
}

/*
==============
HavokPhysics_AllocateIgnoreBodies
==============
*/

HavokPhysics_IgnoreBodies *__fastcall HavokPhysics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  return ?HavokPhysics_AllocateIgnoreBodies@@YAPEAVHavokPhysics_IgnoreBodies@@HH@Z(minEntities, minBodies);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>
==============
*/

HavokPhysicsMaterialList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsMaterialList@@@@YAPEAVHavokPhysicsMaterialList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CalcRigidBodyShapeAABBWorld
==============
*/

void __fastcall HavokPhysics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb)
{
  ?HavokPhysics_CalcRigidBodyShapeAABBWorld@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkAabb@@@Z(worldId, bodyId, aabb);
}

/*
==============
HavokPhysics_GetShapeTriCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeTriCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_SetRigidBodyCenterOfMass
==============
*/

void __fastcall HavokPhysics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *centerOfMass)
{
  ?HavokPhysics_SetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetShapeFromShapeList
==============
*/

hknpShape *__fastcall HavokPhysics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeFromShapeList@@YAPEAVhknpShape@@PEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_ReleasePhysicsAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  ?HavokPhysics_ReleasePhysicsAsset@@YAXPEAUPhysicsAsset@@_N@Z(physicsAsset, unloadPackFileData);
}

/*
==============
HavokPhysics_StepWorldEnd
==============
*/

void __fastcall HavokPhysics_StepWorldEnd(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldEnd@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxLinSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM@Z(worldId, bodyId, maxLinSpeed);
}

/*
==============
HavokPhysics_CreateShapeCapsuleCenterHeight
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsuleCenterHeight(Physics_WorldId worldId, const hkVector4f *center, float halfHeight, float radius, hkVector4f *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?HavokPhysics_CreateShapeCapsuleCenterHeight@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBVhkVector4f@@MMV3@PEADHW4Physics_ShapeStorage@@@Z(worldId, center, halfHeight, radius, majorAxis, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetClosestPointHitSeparatingNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_CreateWorld
==============
*/

void __fastcall HavokPhysics_CreateWorld(Physics_WorldId worldId, Physics_WorldCInfo *worldCInfo)
{
  ?HavokPhysics_CreateWorld@@YAXW4Physics_WorldId@@PEAUPhysics_WorldCInfo@@@Z(worldId, worldCInfo);
}

/*
==============
HavokPhysics_GetVFXEventAsset
==============
*/

int __fastcall HavokPhysics_GetVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsVFXEventAsset **asset)
{
  return ?HavokPhysics_GetVFXEventAsset@@YAHW4Physics_WorldId@@UhknpBodyId@@1PEAPEAUPhysicsVFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DrawDebugGetClosestPoints(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGetClosestPoints@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MIPEBUScreenPlacement@@PEAM3MM@Z(worldId, position, maxDistance, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastFrontfaceHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats
==============
*/

void __fastcall HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  ??1HavokPhysics_CylinderShapeStats@@UEAA@XZ(this);
}

/*
==============
HavokPhysics_InstantiateAssetConstraint
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  return ?HavokPhysics_InstantiateAssetConstraint@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HH_N@Z(instanceId, worldId, physicsAsset, constraintIdx, instanceRef, deepCloneConstraintData);
}

/*
==============
HavokPhysics_InstantiateStaticBody
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateStaticBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55@Z(worldId, shape, ref, name, physicsMaterial, collisionFilterInfo, position, orientation, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
HavokPhysics_GetPhysicsAssetShape
==============
*/

const hknpShape *__fastcall HavokPhysics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetShape@@YAPEBVhknpShape@@PEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_KeyframeRigidBodyToFast
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeRigidBodyToFast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeRigidBodyToFast@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@M_N4M@Z(worldId, bodyId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_GetFixedMemoryPoolUsage
==============
*/

double __fastcall HavokPhysics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetFixedMemoryPoolUsage@@YAMW4Physics_WorldId@@@Z(worldId);
  return result;
}

/*
==============
HavokPhysics_DrawDebugWorldTimestep
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldTimestep(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool drawFrame)
{
  ?HavokPhysics_DrawDebugWorldTimestep@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM_N@Z(worldId, scrPlace, x, y, tabWidth, charHeight, drawFrame);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_GetDebugLines
==============
*/

hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *__fastcall HavokPhysics_GetDebugLines(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetDebugLines@@YAPEAV?$hkArray@UHavokPhysicsDebugLine@@UhkContainerHeapAllocator@@@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIsClutter
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIsClutter(HavokPhysics_IgnoreBodies *this, bool isClutter)
{
  ?SetIsClutter@HavokPhysics_IgnoreBodies@@QEAAX_N@Z(this, isClutter);
}

/*
==============
HavokPhysics_OnThreadInit
==============
*/

void __fastcall HavokPhysics_OnThreadInit(unsigned int threadId)
{
  ?HavokPhysics_OnThreadInit@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_GetPhysicsAssetContents
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetContents@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_GetSFXEventAsset
==============
*/

int __fastcall HavokPhysics_GetSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsSFXEventAsset **asset)
{
  return ?HavokPhysics_GetSFXEventAsset@@YAHW4Physics_WorldId@@UhknpBodyId@@1PEAPEAUPhysicsSFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
HavokPhysics_HasVFXEventAsset
==============
*/

bool __fastcall HavokPhysics_HasVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasVFXEventAsset@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyName
==============
*/

const char *__fastcall HavokPhysics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetBodyName@@YAPEBDPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_AddDeferredKeyframeInstance
==============
*/

void __fastcall HavokPhysics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  ?HavokPhysics_AddDeferredKeyframeInstance@@YAXW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@@Z(worldId, instanceId, origin, orientationAsQuat);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterialId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMaterialId(int materialId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMaterialId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(materialId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkTorqueVector, float magnitude)
{
  ?HavokPhysics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@M@Z(worldId, bodyId, hkTorqueVector, magnitude);
}

/*
==============
HavokPhysics_AddDeferredRadiusForce
==============
*/

void __fastcall HavokPhysics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, const float radius, const float innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  ?HavokPhysics_AddDeferredRadiusForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@MMMM1HM@Z(worldId, position, radius, innerDamage, outerDamage, impulseOverride, impulseVecOverride, randSeed, forceScalar);
}

/*
==============
HavokPhysics_AddShapeList
==============
*/

HavokPhysicsShapeList *__fastcall HavokPhysics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  return ?HavokPhysics_AddShapeList@@YAPEAVHavokPhysicsShapeList@@PEAPEADPEAIPEBDH@Z(rawShapeData, rawShapeDataSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::Reset
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::Reset(HavokPhysics_CollisionQueryResult *this, bool clearModifiers)
{
  ?Reset@HavokPhysics_CollisionQueryResult@@QEAAX_N@Z(this, clearModifiers);
}

/*
==============
HavokPhysics_FreeIgnoreBodies
==============
*/

void __fastcall HavokPhysics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  ?HavokPhysics_FreeIgnoreBodies@@YAXPEAVHavokPhysics_IgnoreBodies@@@Z(ignoreBodies);
}

/*
==============
HavokPhysics_InitialErrorReportFunction
==============
*/

void __fastcall HavokPhysics_InitialErrorReportFunction(const char *msg, void *__formal)
{
  ?HavokPhysics_InitialErrorReportFunction@@YAXPEBDPEAX@Z(msg, __formal);
}

/*
==============
HavokPhysics_DoGarbageCollectionServer
==============
*/

void HavokPhysics_DoGarbageCollectionServer(void)
{
  ?HavokPhysics_DoGarbageCollectionServer@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_ValidateWorld
==============
*/

void __fastcall HavokPhysics_ValidateWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_ValidateWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>
==============
*/

HavokPhysicsXModelLOD *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VHavokPhysicsXModelLOD@@@@YAPEAVHavokPhysicsXModelLOD@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_SnapshotFixup::getConstraintDataForConstraint
==============
*/

hkpConstraintData *__fastcall HavokPhysics_SnapshotFixup::getConstraintDataForConstraint(HavokPhysics_SnapshotFixup *this, hknpConstraint *constraint)
{
  return ?getConstraintDataForConstraint@HavokPhysics_SnapshotFixup@@QEAAPEAVhkpConstraintData@@AEAVhknpConstraint@@@Z(this, constraint);
}

/*
==============
HavokPhysics_HasTriggerEvent
==============
*/

bool __fastcall HavokPhysics_HasTriggerEvent(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasTriggerEvent@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_SetInstanceXModel
==============
*/

void __fastcall HavokPhysics_SetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  ?HavokPhysics_SetInstanceXModel@@YAXW4Physics_WorldId@@IPEBUXModel@@@Z(worldId, instanceId, xModel);
}

/*
==============
HavokPhysics_SetDebugCameras
==============
*/

void __fastcall HavokPhysics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  ?HavokPhysics_SetDebugCameras@@YAXPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
HavokPhysics_SubscribeToEvent
==============
*/

void __fastcall HavokPhysics_SubscribeToEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (__fastcall *function)(const hknpEventHandlerInput *, const hknpEvent *), const char *name)
{
  ?HavokPhysics_SubscribeToEvent@@YAXW4Physics_WorldId@@W4Enum@hknpEventType@@UhknpBodyId@@P6AXAEBUhknpEventHandlerInput@@AEBUhknpEvent@@@ZPEBD@Z(worldId, eventType, specificBodyId, function, name);
}

/*
==============
HavokPhysics_CheckWorldReplayDeterminism
==============
*/

void __fastcall HavokPhysics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  ?HavokPhysics_CheckWorldReplayDeterminism@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_BroadphaseBodiesChangedServerMain
==============
*/

void __fastcall HavokPhysics_BroadphaseBodiesChangedServerMain(Physics_WorldId worldId)
{
  GPlayerTraceInfo::ClearServerCages();
}

/*
==============
HavokPhysics_BroadphaseBodiesChangedClientPred
==============
*/
void HavokPhysics_BroadphaseBodiesChangedClientPred(Physics_WorldId worldId)
{
  LocalClientNum_t LocalClientForWorld; 

  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  CgPlayerTraceInfo::ClearCage(LocalClientForWorld);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::cannotAllocate
==============
*/
void HavokPhysicsLBALimitedMemoryListener::cannotAllocate(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  bool v4; 
  unsigned __int64 v5; 
  unsigned __int64 v6; 
  char dest[512]; 

  if ( this->m_isDebug || Physics_GetDebugMemorySize() )
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 538, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Cannot Allocate %zu bytes.", this->m_name, size);
  else
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 533, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Cannot Allocate %zu bytes.  Physics Debug Memory is NOT ENABLED - if you are trying to use a debug feature, please set dvar physics_debugMemoryEnable.", this->m_name, size);
  if ( v4 )
    __debugbreak();
  v5 = 0i64;
  if ( s_havokPhysicsGeneralLargeBlockAllocator )
    v6 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  else
    v6 = 0i64;
  if ( s_havokPhysicsMapLocalLargeBlockAllocator )
    v5 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Com_sprintf<512>((char (*)[512])dest, "Hk:s=%zum=%zu:%zu", size, v6, v5);
  Mem_Error_CannotAlloc_Dev((Mem_AllocatorType)9, "HavokPhysicsLBALimitedMemoryListener::cannotAllocate", "c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 550, (const char *)&queryFormat, dest);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::allocationFailure
==============
*/
void HavokPhysicsLBALimitedMemoryListener::allocationFailure(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  bool v4; 
  unsigned __int64 v5; 
  unsigned __int64 v6; 
  char dest[512]; 

  if ( this->m_isDebug || Physics_GetDebugMemorySize() )
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 562, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Allocation Failure: %zu bytes.", this->m_name, size);
  else
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 557, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Allocation Failure: %zu bytes.  Physics Debug Memory is NOT ENABLED - if you are trying to use a debug feature, please set dvar physics_debugMemoryEnable.", this->m_name, size);
  if ( v4 )
    __debugbreak();
  v5 = 0i64;
  if ( s_havokPhysicsGeneralLargeBlockAllocator )
    v6 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  else
    v6 = 0i64;
  if ( s_havokPhysicsMapLocalLargeBlockAllocator )
    v5 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Com_sprintf<512>((char (*)[512])dest, "Hk:s=%zum=%zu:%zu", size, v6, v5);
  Mem_Error_CannotAlloc_Dev((Mem_AllocatorType)9, "HavokPhysicsLBALimitedMemoryListener::allocationFailure", "c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 574, (const char *)&queryFormat, dest);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>
==============
*/
HavokPhysicsBodyQualityList *HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsBodyQualityList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsBodyQualityList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsBodyQualityList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>
==============
*/
HavokPhysicsMaterialList *HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMaterialList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMaterialList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsMaterialList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>
==============
*/
HavokPhysicsMotionPropertiesList *HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMotionPropertiesList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMotionPropertiesList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsMotionPropertiesList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsShapeList>
==============
*/
HavokPhysicsShapeList *HavokPhysics_InplaceLoad<HavokPhysicsShapeList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsShapeList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsShapeList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsShapeList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<hknpShape>
==============
*/
hknpShape *HavokPhysics_InplaceLoad<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  hknpShape *v7; 
  hkSerialize::InplaceLoad v9; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  v7 = hkSerialize::InplaceLoad::toObject<hknpShape>(v6, *outData, *outSize);
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return v7;
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>
==============
*/
HavokPhysicsAsset *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>(char **outData, unsigned int *outSize, const char *name, int type)
{
  void *m_addr; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsAsset::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsAsset::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return (HavokPhysicsAsset *)m_addr;
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return 0i64;
  }
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>
==============
*/
HavokPhysicsXModelLOD *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>(char **outData, unsigned int *outSize, const char *name, int type)
{
  void *m_addr; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsXModelLOD::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsXModelLOD::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return (HavokPhysicsXModelLOD *)m_addr;
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return 0i64;
  }
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>
==============
*/
hknpShape *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  return hkSerialize::InplaceLoad::toObject<hknpShape>(s_havokPhysicsInPlaceLoad, *outData, *outSize);
}

/*
==============
HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats
==============
*/
void HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  this->m_propertyBag.m_bag = NULL;
  this->__vftable = (HavokPhysics_CylinderShapeStats_vtbl *)&HavokPhysics_CylinderShapeStats::`vftable';
  *(_DWORD *)&this->m_memSizeAndFlags = 0x1FFFF;
}

/*
==============
HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies
==============
*/
void HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(HavokPhysics_IgnoreBodies *this, int minEntities, int minBodies)
{
  int v5; 
  hkMemoryAllocator *v6; 
  int v7; 
  int v8; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *v9; 
  int v10; 
  hkMemoryAllocator *v11; 
  int v12; 
  int v13; 
  hknpBodyId *v14; 
  int numInOut; 
  int v16; 

  this->m_ignoreRefs = 0;
  this->m_ignoreEntities.m_data = NULL;
  this->m_ignoreEntities.m_size = 0;
  v5 = 0x80000000;
  this->m_ignoreEntities.m_capacityAndFlags = 0x80000000;
  numInOut = minEntities;
  v6 = hkMemHeapAllocator();
  v7 = numInOut;
  v8 = numInOut;
  if ( numInOut )
  {
    v9 = (HavokPhysics_IgnoreBodies::IgnoreEntity *)hkMemoryAllocator::bufAlloc2(v6, 8, &numInOut);
    v7 = numInOut;
  }
  else
  {
    v9 = NULL;
  }
  v10 = 0x80000000;
  if ( v7 )
    v10 = v7;
  this->m_ignoreEntities.m_data = v9;
  this->m_ignoreEntities.m_size = v8;
  this->m_ignoreEntities.m_capacityAndFlags = v10;
  this->m_ignoreBodies.m_data = NULL;
  this->m_ignoreBodies.m_size = 0;
  this->m_ignoreBodies.m_capacityAndFlags = 0x80000000;
  v16 = minBodies;
  v11 = hkMemHeapAllocator();
  v12 = v16;
  v13 = v16;
  if ( v16 )
  {
    v14 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v11, 4, &v16);
    v12 = v16;
  }
  else
  {
    v14 = NULL;
  }
  if ( v12 )
    v5 = v12;
  this->m_ignoreBodies.m_data = v14;
  this->m_ignoreBodies.m_size = v13;
  this->m_ignoreBodies.m_capacityAndFlags = v5;
  *(_QWORD *)&this->m_ignorePhysicsVolumes = 0i64;
  *(_WORD *)&this->m_isClutter = 0;
  this->m_ignoreLayers = 32;
}

/*
==============
HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats
==============
*/
void HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  this->__vftable = (HavokPhysics_CylinderShapeStats_vtbl *)&HavokPhysics_CylinderShapeStats::`vftable';
  hkReferencedObject::~hkReferencedObject(this);
}

/*
==============
HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer
==============
*/
void HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer(HavokPhysics_SimpleShapeBuffer *this)
{
  this->m_shape = NULL;
  this->__vftable = (HavokPhysics_SimpleShapeBuffer_vtbl *)hknpShapeBuffer::`vftable';
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreBody
==============
*/
void HavokPhysics_IgnoreBodies::AddIgnoreBody(HavokPhysics_IgnoreBodies *this, unsigned int bodyId)
{
  hkArray<hknpBodyId,hkContainerHeapAllocator> *p_m_ignoreBodies; 
  hkMemoryAllocator *v4; 
  int m_size; 

  p_m_ignoreBodies = &this->m_ignoreBodies;
  v4 = hkMemHeapAllocator();
  m_size = p_m_ignoreBodies->m_size;
  if ( m_size == (p_m_ignoreBodies->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v4, p_m_ignoreBodies, 4);
    m_size = p_m_ignoreBodies->m_size;
  }
  p_m_ignoreBodies->m_data[m_size].m_serialAndIndex = bodyId;
  ++p_m_ignoreBodies->m_size;
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreEntity
==============
*/
void HavokPhysics_IgnoreBodies::AddIgnoreEntity(HavokPhysics_IgnoreBodies *this, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator> *p_m_ignoreEntities; 
  hkMemoryAllocator *v11; 
  int m_size; 
  __int64 v13; 
  char v14; 

  if ( svEntNum != 2047 )
  {
    p_m_ignoreEntities = &this->m_ignoreEntities;
    v11 = hkMemHeapAllocator();
    m_size = p_m_ignoreEntities->m_size;
    if ( m_size == (p_m_ignoreEntities->m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v11, p_m_ignoreEntities, 8);
      m_size = p_m_ignoreEntities->m_size;
    }
    v13 = (__int64)&p_m_ignoreEntities->m_data[m_size];
    p_m_ignoreEntities->m_size = m_size + 1;
    *(_BYTE *)(v13 + 4) &= ~1u;
    v14 = (*(_BYTE *)(v13 + 4) | self) & 0xE1;
    *(_DWORD *)v13 = svEntNum;
    *(_BYTE *)(v13 + 4) = v14 | (2 * (children & 0xF1 | (2 * (parent & 0xF9 | (2 * ((2 * linked) | siblings & 0xFD))))));
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit
==============
*/
void HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit(HavokPhysics_CollisionQueryResult *this, Physics_WorldId worldId, HavokPhysics_CollisionQueryResult *queryPointResult, int hitIndex, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpCollisionFilter **p_traceCollisionFilter; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v48; 
  HavokPhysicsHitCollector *m_collector; 
  __int64 v52; 
  __int64 v53; 
  __int64 v54[2]; 
  Physics_CharacterProxy_Type v55; 
  __int64 v57; 
  hknpRayCastQuery query; 
  hkVector4f v59; 
  hkVector4f v60; 
  __int128 v61[2]; 
  unsigned int m_serialAndIndex; 
  unsigned int m_value; 
  int v65; 
  unsigned __int16 v66; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  unsigned int v69; 
  unsigned int v70; 
  int v71; 
  unsigned __int16 v72; 
  unsigned int v73; 
  unsigned __int64 v74; 
  int v75; 
  unsigned int v76; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vxorps  xmm7, xmm7, xmm7
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2334, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to AddQueryPointHitAsRaycastHit with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !queryPointResult && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2335, ASSERT_TYPE_ASSERT, "(queryPointResult)", (const char *)&queryFormat, "queryPointResult") )
    __debugbreak();
  if ( hitIndex >= HavokPhysics_CollisionQueryResult::GetNumHits(queryPointResult) )
  {
    LODWORD(v53) = HavokPhysics_CollisionQueryResult::GetNumHits(queryPointResult);
    LODWORD(v52) = hitIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2336, ASSERT_TYPE_ASSERT, "(unsigned)( hitIndex ) < (unsigned)( queryPointResult->GetNumHits() )", "hitIndex doesn't index queryPointResult->GetNumHits()\n\t%i not in [0, %i)", v52, v53) )
      __debugbreak();
  }
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2338, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2340, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(queryPointResult, hitIndex);
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vxorps  xmm3, xmm3, xmm3
    vmovups xmm0, xmmword ptr [rax]
    vmovups [rbp+0D0h+var_D0], xmm0
    vmovups xmm1, xmmword ptr [rax+10h]
    vmovups [rbp+0D0h+var_C0], xmm1
    vmovss  [rbp+0D0h+var_B0], xmm3
  }
  m_serialAndIndex = _RAX->m_queryBodyInfo.m_bodyId.m_serialAndIndex;
  m_value = _RAX->m_queryBodyInfo.m_shapeKey.m_value;
  v65 = *(_DWORD *)_RAX->m_queryBodyInfo.m_levelOfDetail;
  v66 = _RAX->m_queryBodyInfo.m_filterData.m_materialId.m_value;
  m_collisionFilterInfo = _RAX->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
  m_userData = _RAX->m_queryBodyInfo.m_filterData.m_userData;
  v69 = _RAX->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
  v70 = _RAX->m_hitBodyInfo.m_shapeKey.m_value;
  v71 = *(_DWORD *)_RAX->m_hitBodyInfo.m_levelOfDetail;
  v72 = _RAX->m_hitBodyInfo.m_filterData.m_materialId.m_value;
  v73 = _RAX->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
  v74 = _RAX->m_hitBodyInfo.m_filterData.m_userData;
  v75 = 1;
  v76 = _RAX->m_rayCastResult.m_value;
  __asm
  {
    vmovss  dword ptr [rbp+0D0h+var_E0.m_quad+0Ch], xmm3
    vmovss  dword ptr [rbp+0D0h+var_F0.m_quad+0Ch], xmm3
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmulss  xmm2, xmm6, dword ptr [rax+4]
    vmulss  xmm1, xmm6, dword ptr [rax+8]
    vmovss  dword ptr [rbp+0D0h+var_E0.m_quad], xmm0
    vmovss  dword ptr [rbp+0D0h+var_E0.m_quad+4], xmm2
    vmovss  dword ptr [rbp+0D0h+var_E0.m_quad+8], xmm1
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmulss  xmm0, xmm6, dword ptr [rax+4]
    vmulss  xmm2, xmm6, dword ptr [rax+8]
    vmovss  dword ptr [rbp+0D0h+var_F0.m_quad], xmm1
    vmovss  dword ptr [rbp+0D0h+var_F0.m_quad+4], xmm0
    vmovss  dword ptr [rbp+0D0h+var_F0.m_quad+8], xmm2
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vmovups xmm5, xmmword ptr [rbp+0D0h+var_E0.m_quad]
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rsp+1D0h+var_180+8], xmm0
    vmulss  xmm1, xmm6, dword ptr [rdx+14h]
  }
  p_traceCollisionFilter = (const hknpCollisionFilter **)&ConstWorld->traceCollisionFilter;
  __asm { vmovups xmm0, xmmword ptr [rbp+0D0h+var_F0.m_quad] }
  v54[1] = (__int64)extendedData->ignoreBodies;
  characterProxyType = extendedData->characterProxyType;
  __asm
  {
    vmovss  dword ptr [rsp+1D0h+var_190], xmm1
    vsubps  xmm1, xmm0, xmm5
    vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
  }
  v55 = characterProxyType;
  __asm { vcmpeqps xmm0, xmm2, xmm7 }
  LODWORD(v57) = extendedData->phaseSelection;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  __asm { vmovups xmm4, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee }
  insideHitType = extendedData->insideHitType;
  __asm
  {
    vandnps xmm1, xmm0, xmm2
    vrcpps  xmm3, xmm1
    vmulps  xmm2, xmm3, xmm1
    vmovups xmmword ptr [rbp+0D0h+query.m_ray.m_direction.m_quad], xmm1
    vcmpeqps xmm0, xmm1, xmm7
    vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
    vsubps  xmm2, xmm1, xmm2
    vmulps  xmm3, xmm2, xmm3
    vblendvps xmm1, xmm3, xmm4, xmm0
    vmovups xmmword ptr [rbp+0D0h+query.m_ray.m_invDirection.m_quad], xmm1
    vmovups xmmword ptr [rbp+0D0h+query.m_ray.m_origin.m_quad], xmm5
  }
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v48 = 4;
  }
  else
  {
    v48 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v48 = 8;
  }
  query.m_flags.m_storage = v48;
  if ( extendedData->disableBackFacingTriangleHits )
    query.m_flags.m_storage = v48 | 1;
  m_collector = this->m_collector;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = *p_traceCollisionFilter;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)v54;
  *(_DWORD *)query.m_levelOfDetail = 0;
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(m_collector, &v60, &v59, &query);
  Collector->addHit(Collector, (const hknpCollisionResult *)v61);
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+1D0h+var_48+8]
    vmovaps xmm7, [rsp+1D0h+var_58+8]
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 911, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1011, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 932, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1027, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 994, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 925, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 918, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int AABBQueryHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v21; 
  hknpInplaceTriangleShape v22; 
  hknpShapeCollector v23; 

  v21 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 939, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 946, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    AABBQueryHitBodyId = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, AABBQueryHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 965, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v22, *(float *)&_XMM1);
      v23.m_internal.m_shapeBuffer.m_shape = NULL;
      v23.m_internal.m_shapeBuffer.m_buffer = v23.m_internal.m_shapeBuffer.m_storage;
      v23.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v23.m_internal.m_shape = NULL;
      v23.m_parentShape = NULL;
      v23.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v23.m_internal.m_flags.m_storage = 13i64;
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
        vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
        vmovups xmmword ptr [rbp+0CC0h+var_C70.m_internal.m_scale.m_quad], xmm0
      }
      v23.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v23);
      if ( (v23.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v23, 0, (hknpTriangleShape *)&v22);
      else
        TriangleShape = (const hknpTriangleShape *)v23.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v23.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v23.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v23.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v23.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v23.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v23.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance
==============
*/
float HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v8; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v8 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1700, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v8, NumHits) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vmovss  xmm0, dword ptr [rax+20h]
    vmulss  xmm0, xmm0, cs:__real@42000000
  }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1828, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1743, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1844, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1812, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1729, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  int v10; 
  unsigned int NumHits; 

  _RSI = pos;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v10 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1675, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v10, NumHits) )
      __debugbreak();
  }
  HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rax]
    vmovss  dword ptr [rsi], xmm0
    vmulss  xmm2, xmm3, dword ptr [rax+4]
    vmovss  dword ptr [rsi+4], xmm2
    vmulss  xmm1, xmm3, dword ptr [rax+8]
    vmovss  dword ptr [rsi+8], xmm1
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1715, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int ClosestPointHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v21; 
  hknpInplaceTriangleShape v22; 
  hknpShapeCollector v23; 

  v21 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1757, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1764, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, ClosestPointHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1783, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v22, *(float *)&_XMM1);
      v23.m_internal.m_shapeBuffer.m_shape = NULL;
      v23.m_internal.m_shapeBuffer.m_buffer = v23.m_internal.m_shapeBuffer.m_storage;
      v23.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v23.m_internal.m_shape = NULL;
      v23.m_parentShape = NULL;
      v23.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v23.m_internal.m_flags.m_storage = 13i64;
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
        vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
        vmovups xmmword ptr [rbp+0CC0h+var_C70.m_internal.m_scale.m_quad], xmm0
      }
      v23.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v23);
      if ( (v23.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v23, 0, (hknpTriangleShape *)&v22);
      else
        TriangleShape = (const hknpTriangleShape *)v23.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v23.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v23.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v23.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v23.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v23.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v23.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1891, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1750, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1907, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1875, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1736, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  int v16; 
  unsigned int NumHits; 

  _RSI = pos;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v16 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1683, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v16, NumHits) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vmovss  xmm2, cs:__real@42000000
    vbroadcastss xmm1, dword ptr [rax+20h]
    vmulps  xmm0, xmm1, xmmword ptr [rax+10h]
    vaddps  xmm3, xmm0, xmmword ptr [rax]
    vmulss  xmm0, xmm3, xmm2
    vshufps xmm1, xmm3, xmm3, 55h ; 'U'
    vmovss  dword ptr [rsi], xmm0
    vmulss  xmm0, xmm1, xmm2
    vshufps xmm3, xmm3, xmm3, 0AAh ; ''
    vmovss  dword ptr [rsi+4], xmm0
    vmulss  xmm0, xmm3, xmm2
    vmovss  dword ptr [rsi+8], xmm0
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1722, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1860, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return truncate_cast<unsigned int,unsigned __int64>(LODWORD(Hit->m_queryBodyInfo.m_filterData.m_userData));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetClosestPointHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1691, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHit
==============
*/
hknpCollisionResult *HavokPhysics_CollisionQueryResult::GetHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  __int64 v4; 
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  __int32 v8; 
  unsigned int NumHits; 

  v4 = hitId;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1931, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v4, NumHits) )
      __debugbreak();
  }
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1933, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1935, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY )
    return (hknpCollisionResult *)&Collector[1];
  v8 = CollectorType - 1;
  if ( !v8 )
    return (hknpCollisionResult *)&Collector[1];
  if ( v8 == 1 )
    return (hknpCollisionResult *)&Collector->getHits(Collector)[v4];
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1962, ASSERT_TYPE_ASSERT, "(false)", (const char *)&queryFormat, "false") )
    __debugbreak();
  if ( dword_150D5FA34 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
    return &dummy;
  j__Init_thread_header(&dword_150D5FA34);
  if ( dword_150D5FA34 != -1 )
    return &dummy;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups ymmword ptr cs:dummy.m_position.m_quad, ymm0
  }
  j__Init_thread_footer(&dword_150D5FA34);
  return &dummy;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId
==============
*/
__int64 HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId(HavokPhysics_BroadphaseCollisionQueryResult *this, unsigned int hitId)
{
  __int64 v2; 

  v2 = (int)hitId;
  if ( hitId >= this->m_hits.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 851, ASSERT_TYPE_ASSERT, "(hitId < GetNumHits())", (const char *)&queryFormat, "hitId < GetNumHits()") )
    __debugbreak();
  return this->m_hits.m_data[v2].m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHits
==============
*/
hknpCollisionQueryCollector *HavokPhysics_CollisionQueryResult::GetHits(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  __int32 v4; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1974, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1976, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY )
    return Collector + 1;
  v4 = CollectorType - 1;
  if ( !v4 )
    return Collector + 1;
  if ( v4 == 1 )
    return (hknpCollisionQueryCollector *)Collector->getHits(Collector);
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2003, ASSERT_TYPE_ASSERT, "(false)", (const char *)&queryFormat, "false") )
    __debugbreak();
  return 0i64;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits
==============
*/
__int64 HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  return (unsigned int)this->m_hits.m_size;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetNumHits
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetNumHits(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  unsigned int m_numHits; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 867, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 869, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  m_numHits = Collector->m_numHits;
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL )
    return m_numHits;
  else
    return m_numHits != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 1;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return (HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 2) != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1214, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1096, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  unsigned int m_value; 
  hknpWorld *world; 
  unsigned int RaycastHitBodyId; 
  __int64 v7; 
  hknpBodyId v8; 
  int Ref; 
  __int64 v10; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1159, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
    return 0xFFFFi64;
  world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1169, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
    __debugbreak();
  RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, RaycastHitBodyId);
  v8.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  Ref = HavokPhysics_GetRef(this->m_worldId, v8);
  if ( !PhysicsCoverWall_IsCoverWall(this->m_worldId, Ref) )
    return 0xFFFFi64;
  v10 = *(_QWORD *)(v7 + 96);
  if ( *(_BYTE *)(v10 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1180, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND") )
    __debugbreak();
  return (unsigned __int16)(m_value >> (32 - *(_BYTE *)(v10 + 27)));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1231, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitFraction
==============
*/
float HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1068, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm { vmovss  xmm0, dword ptr [rax+20h] }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1197, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1089, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1058, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  int v10; 
  unsigned int NumHits; 

  _RSI = pos;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v10 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1051, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v10, NumHits) )
      __debugbreak();
  }
  HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rax]
    vmovss  dword ptr [rsi], xmm0
    vmulss  xmm2, xmm3, dword ptr [rax+4]
    vmovss  dword ptr [rsi+4], xmm2
    vmulss  xmm1, xmm3, dword ptr [rax+8]
    vmovss  dword ptr [rsi+8], xmm1
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetRaycastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1082, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int RaycastHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v21; 
  hknpInplaceTriangleShape v22; 
  hknpShapeCollector v23; 

  v21 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1103, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1111, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, RaycastHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1130, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v22, *(float *)&_XMM1);
      v23.m_internal.m_shapeBuffer.m_shape = NULL;
      v23.m_internal.m_shapeBuffer.m_buffer = v23.m_internal.m_shapeBuffer.m_storage;
      v23.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v23.m_internal.m_shape = NULL;
      v23.m_parentShape = NULL;
      v23.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v23.m_internal.m_flags.m_storage = 13i64;
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
        vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
        vmovups xmmword ptr [rbp+0CC0h+var_C70.m_internal.m_scale.m_quad], xmm0
      }
      v23.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v23);
      if ( (v23.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v23, 0, (hknpTriangleShape *)&v22);
      else
        TriangleShape = (const hknpTriangleShape *)v23.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v23.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v23.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v23.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v23.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v23.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v23.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastInternalHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastInternalHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return (HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 4) != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1452, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  int v10; 
  unsigned int NumHits; 

  _RSI = pos;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v10 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1274, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v10, NumHits) )
      __debugbreak();
  }
  HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rax]
    vmovss  dword ptr [rsi], xmm0
    vmulss  xmm2, xmm3, dword ptr [rax+4]
    vmovss  dword ptr [rsi+4], xmm2
    vmulss  xmm1, xmm3, dword ptr [rax+8]
    vmovss  dword ptr [rsi+8], xmm1
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitFraction
==============
*/
float HavokPhysics_CollisionQueryResult::GetShapecastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1445, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm { vmovss  xmm0, dword ptr [rax+20h] }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1572, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  __int64 v7; 
  unsigned int NumHits; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1281, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    LODWORD(v7) = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1282, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1487, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1588, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1556, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1473, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1459, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int ShapecastHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v21; 
  hknpInplaceTriangleShape v22; 
  hknpShapeCollector v23; 

  v21 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1501, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1508, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    ShapecastHitBodyId = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, ShapecastHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1527, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v22, *(float *)&_XMM1);
      v23.m_internal.m_shapeBuffer.m_shape = NULL;
      v23.m_internal.m_shapeBuffer.m_buffer = v23.m_internal.m_shapeBuffer.m_storage;
      v23.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v23.m_internal.m_shape = NULL;
      v23.m_parentShape = NULL;
      v23.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v23.m_internal.m_flags.m_storage = 13i64;
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
        vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rbp+0CC0h+var_C70.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
        vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
        vmovups xmmword ptr [rbp+0CC0h+var_C70.m_internal.m_scale.m_quad], xmm0
      }
      v23.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v23);
      if ( (v23.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v23, 0, (hknpTriangleShape *)&v22);
      else
        TriangleShape = (const hknpTriangleShape *)v23.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v23.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v23.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v23.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v23.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v23.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v23.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v23.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1635, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  int v11; 
  unsigned int NumHits; 

  _RSI = normal;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v11 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1293, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v11, NumHits) )
      __debugbreak();
  }
  HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vpinsrw xmm0, xmm0, ecx, 1
    vpshufd xmm2, xmm0, 40h ; '@'
    vxorps  xmm3, xmm2, xmmword ptr [rax+10h]
    vmovss  dword ptr [rsi], xmm3
    vextractps dword ptr [rsi+4], xmm3, 1
    vextractps dword ptr [rsi+8], xmm3, 2
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1494, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1651, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1619, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1480, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1466, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1604, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return truncate_cast<unsigned int,unsigned __int64>(LODWORD(Hit->m_queryBodyInfo.m_filterData.m_userData));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetShapecastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const HavokPhysicsWorld *ConstWorld; 
  const hknpTriangleShape *TriangleShape; 
  int v16; 
  unsigned int v21; 
  char v38; 
  unsigned __int16 m_storage; 
  hknpTriangleShape *v44; 
  int m_size; 
  hknpConvexShape *v49; 
  int v61; 
  unsigned __int16 v62; 
  bool v63; 
  __int64 v76; 
  unsigned int NumHits; 
  float zero; 
  unsigned int m_value; 
  hkStridedVertices verticesInOrg; 
  __int64 v81; 
  hknpConvexShape::BuildConfig configInOrg; 
  hkVector4f v84; 
  hkVector4f v85; 
  hkVector4f b; 
  char v87[64]; 
  hkTransformf a; 
  hknpShapeCollector v89; 
  hknpInplaceTriangleShape v90; 
  void *retaddr; 

  _RAX = &retaddr;
  v81 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R14 = normal;
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1305, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    LODWORD(v76) = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1306, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v76, NumHits) )
      __debugbreak();
  }
  _R13 = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  ConstWorld = HavokPhysics_GetConstWorld(this->m_worldId);
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, _R13->m_hitBodyInfo.m_bodyId.m_serialAndIndex);
  TriangleShape = *(const hknpTriangleShape **)(_RAX + 96);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0F28h+var_E38], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+0F28h+var_E38+20h], ymm1
  }
  m_value = _R13->m_hitBodyInfo.m_shapeKey.m_value;
  __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v90, *(float *)&_XMM1);
  v16 = 0;
  v89.m_internal.m_shapeBuffer.m_shape = NULL;
  v89.m_internal.m_shapeBuffer.m_buffer = v89.m_internal.m_shapeBuffer.m_storage;
  v89.m_internal.m_shapeBuffer.m_bufferSize = 2048;
  v89.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
  v89.m_internal.m_shapeTags[0] = -1;
  v89.m_internal.m_shape = NULL;
  v89.m_parentShape = NULL;
  v89.m_shapeTagPath.m_size = 0;
  *(_QWORD *)&v89.m_internal.m_flags.m_storage = 8i64;
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+0F28h+var_E38]
    vmovups ymmword ptr [rsp+0F28h+var_DB8.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
    vmovups ymm0, ymmword ptr [rsp+0F28h+var_E38+20h]
    vmovups ymmword ptr [rsp+0F28h+var_DB8.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rsp+0F28h+var_DB8.m_internal.m_scale.m_quad], xmm0
    vmovss  xmm1, cs:__real@34000000
    vmovss  [rsp+0F28h+zero], xmm1
  }
  if ( hkMatrix3Impl<float>::isApproximatelyEqual((hkMatrix3Impl<float> *)v87, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], &zero) )
  {
    v21 = v89.m_internal.m_flags.m_storage | 4;
    v89.m_internal.m_flags.m_storage |= 4u;
    __asm
    {
      vmovups xmm4, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rsp+0F28h+b.m_quad], xmm4
      vmovups xmm0, xmmword ptr [rsp+0F28h+var_E38+30h]
      vsubps  xmm2, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
      vmovups xmm1, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
      vandnps xmm3, xmm1, xmm2
      vcmpleps xmm5, xmm3, xmm4
      vxorps  xmm2, xmm2, xmm2
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqd xmm1, xmm0, xmm0
      vblendps xmm2, xmm2, xmm1, 7
      vpand   xmm0, xmm5, xmm2
      vptest  xmm0, xmm2
    }
    if ( _CF )
      v89.m_internal.m_flags.m_storage = v21 | 1;
  }
  v89.m_internal.m_shapeTags[0] = -1;
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+0F28h+var_E38]
    vmovups ymmword ptr [rsp+0F28h+a.m_rotation.baseclass_0.m_col0.m_quad], ymm0
    vmovups ymm1, ymmword ptr [rsp+0F28h+var_E38+20h]
    vmovups ymmword ptr [rsp+0F28h+a.m_rotation.baseclass_0.m_col2.m_quad], ymm1
  }
  if ( m_value != -1 )
  {
    TriangleShape->getLeafShapes(&TriangleShape->hknpConvexPolytopeShape, (const hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *)&m_value, 1, &v89);
    if ( (v89.m_internal.m_flags.m_storage & 0x10) != 0 )
      TriangleShape = hknpShapeCollector::getTriangleShape(&v89, 0, (hknpTriangleShape *)&v90);
    else
      TriangleShape = (const hknpTriangleShape *)v89.m_internal.m_shape;
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+0F28h+var_DB8.m_transform.m_rotation.baseclass_0.m_col0.m_quad]
      vmovups ymmword ptr [rsp+0F28h+a.m_rotation.baseclass_0.m_col0.m_quad], ymm0
      vmovups ymm0, ymmword ptr [rsp+0F28h+var_DB8.m_transform.m_rotation.baseclass_0.m_col2.m_quad]
      vmovups ymmword ptr [rsp+0F28h+a.m_rotation.baseclass_0.m_col2.m_quad], ymm0
    }
  }
  v38 = 0;
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
  }
  if ( TriangleShape->m_type.m_storage == 17 )
  {
    _RAX = TriangleShape;
    TriangleShape = *(const hknpTriangleShape **)&TriangleShape->m_maxAllowedPenetration.m_value;
    __asm { vmovss  xmm6, dword ptr [rax+40h] }
  }
  m_storage = TriangleShape->m_flags.m_storage;
  v44 = (hknpTriangleShape *)TriangleShape;
  if ( (m_storage & 2) == 0 )
    v44 = NULL;
  if ( !v44 )
  {
    if ( (m_storage & 1) == 0 )
      TriangleShape = NULL;
    if ( !TriangleShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1354, ASSERT_TYPE_ASSERT, "(convexShape)", (const char *)&queryFormat, "convexShape") )
      __debugbreak();
    if ( (TriangleShape->m_flags.m_storage & 0x10) != 0 )
    {
      v44 = NULL;
      __asm
      {
        vmovups xmm0, xmmword ptr [r13+10h]
        vmovups xmmword ptr [rsp+0F28h+var_E68.m_quad], xmm0
      }
      goto LABEL_38;
    }
    v38 = 1;
    m_size = TriangleShape->m_vertices.m_size;
    verticesInOrg.m_vertices = (const float *)((char *)&TriangleShape->m_vertices.m_size + TriangleShape->m_vertices.m_offset);
    verticesInOrg.m_numVertices = m_size;
    verticesInOrg.m_striding = 16;
    hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
    configInOrg.m_buildMassProperties.m_bool = 0;
    __asm { vmovss  [rsp+0F28h+configInOrg.m_featurePreservationFactor], xmm7 }
    configInOrg.m_shrinkByRadius.m_bool = 0;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  [rsp+0F28h+configInOrg.m_simplificationTolerance], xmm0
      vmovss  xmm1, cs:__real@3c75c28f; convexRadius
    }
    v49 = hknpConvexShape::createFromVertices(&verticesInOrg, *(float *)&_XMM1, &configInOrg);
    v44 = NULL;
    if ( (v49->m_flags.m_storage & 2) != 0 )
      v44 = (hknpTriangleShape *)v49;
    hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
    if ( !v44 )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [r13+10h]
        vmovups xmmword ptr [rsp+0F28h+var_E68.m_quad], xmm0
      }
      goto LABEL_38;
    }
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups xmmword ptr [rsp+0F28h+b.m_quad], xmm0
  }
  hkVector4f::setTransformedInversePos(&v85, &a, &b);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+0F28h+var_E58.m_quad]
    vblendps xmm3, xmm0, cs:__xmm@3f8000003f8000003f8000003f800000, 8
    vmovups xmmword ptr [rsp+0F28h+var_E58.m_quad], xmm3
  }
  _R10 = (__int64)&v44->m_planes + v44->m_planes.m_offset;
  __asm
  {
    vmovups xmm0, xmmword ptr [r10]
    vmovups [rsp+0F28h+var_E78], xmm0
    vshufps xmm0, xmm0, xmm0, 0FFh
    vmulss  xmm0, xmm0, xmm6
    vmovups xmm1, [rsp+0F28h+var_E78]
    vinsertps xmm1, xmm1, xmm0, 30h ; '0'
    vmovups [rsp+0F28h+var_E78], xmm1
    vdpps   xmm2, xmm1, xmm3, 0FFh
  }
  if ( (v44->m_flags.m_storage & 0x200) == 0 )
  {
    v61 = 1;
    v62 = v44->m_planes.m_size;
    v63 = v62 != 0;
    if ( v62 > 1u )
    {
      _R8 = _R10 + 16;
      do
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [r8]
          vmovups [rsp+0F28h+var_E78], xmm0
          vshufps xmm0, xmm0, xmm0, 0FFh
          vmulss  xmm0, xmm0, xmm6
          vmovups xmm1, [rsp+0F28h+var_E78]
          vinsertps xmm1, xmm1, xmm0, 30h ; '0'
          vmovups [rsp+0F28h+var_E78], xmm1
          vdpps   xmm0, xmm1, xmm3, 0FFh
          vucomiss xmm0, xmm2
        }
        if ( !v63 )
        {
          v16 = v61;
          __asm { vmovups xmm2, xmm0 }
        }
        ++v61;
        _R8 += 16i64;
        v63 = v61 <= (unsigned int)v62;
      }
      while ( v61 < v62 );
    }
  }
  hkVector4f::setRotatedDir(&v84, &a.m_rotation, (const hkVector4f *)(_R10 + 16i64 * v16));
LABEL_38:
  if ( v38 && v44 )
    ((void (__fastcall *)(hknpTriangleShape *, __int64))v44->~hkBaseObject)(v44, 1i64);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+0F28h+var_E68.m_quad]
    vmovss  dword ptr [r14], xmm0
    vmovss  xmm1, dword ptr [rsp+0F28h+var_E68.m_quad+4]
    vmovss  dword ptr [r14+4], xmm1
    vmovss  xmm0, dword ptr [rsp+0F28h+var_E68.m_quad+8]
    vmovss  dword ptr [r14+8], xmm0
  }
  v89.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
  if ( v89.m_internal.m_shapeBuffer.m_shape )
    ((void (__fastcall *)(hknpShape *, _QWORD))v89.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v89.m_internal.m_shapeBuffer.m_shape, 0i64);
  __asm
  {
    vmovaps xmm6, [rsp+0F28h+var_48]
    vmovaps xmm7, [rsp+0F28h+var_58]
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::HasHit
==============
*/
bool HavokPhysics_CollisionQueryResult::HasHit(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 858, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 860, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  return Collector->m_numHits != 0;
}

/*
==============
HavokPhysics_AABBBroadphaseQuery
==============
*/
void HavokPhysics_AABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 traceCollisionFilter; 
  hkMonitorStream *Value; 
  hkMonitorStream *v16; 
  int v17; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v19; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v22[2]; 
  __int16 v23; 
  int contents; 
  int *v25; 
  int v26; 
  char v27; 
  void *retaddr; 

  _R11 = &retaddr;
  ignoreBodies = NULL;
  v19 = 1;
  phaseSelection = All;
  _RBP = aabb;
  v27 = -5;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+0E8h+var_A8], xmm0
    vmovdqu [rsp+0E8h+var_90], xmm0
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+240h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [r11-48h], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13758, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13759, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13760, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid result", "result") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm { vmovups ymm0, ymmword ptr [rbp+0] }
  ignoreBodies = extendedData->ignoreBodies;
  phaseSelection = extendedData->phaseSelection;
  v22[0] = (__int64)s_shapeTagCodec;
  __asm { vmovups [rsp+0E8h+var_48], ymm0 }
  traceCollisionFilter = (__int64)ConstWorld->traceCollisionFilter;
  v23 = -1;
  contents = extendedData->contents;
  v22[1] = traceCollisionFilter;
  v25 = &v17;
  v26 = 0;
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryBroadphaseAABB_HK");
  ConstWorld->world->queryAabb(&ConstWorld->world->hknpWorldReader, (const hknpAabbQuery *)v22, &result->m_hits);
  v16 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v16 )
    hkMonitorStream::timerEnd(v16, "Et");
}

/*
==============
HavokPhysics_AABBQuery
==============
*/
void HavokPhysics_AABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v73; 
  hkMonitorStream *v74; 
  hkMonitorStream *v78; 
  __int64 v86; 
  __int128 v87; 
  __int16 v88; 
  int contents; 
  int *v90; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v92; 
  hkReferencedObject *v93; 
  int v95; 
  __int128 v96; 
  int v97; 
  __int64 v98; 
  int v99; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v102; 
  hkMonitorStream *v103; 
  hkErrStream v104; 
  __int128 v105; 
  __int64 v106; 
  int v107; 
  int v108; 
  __int128 v109; 
  char v110; 
  int v111; 
  __int64 v115[2]; 
  __int16 v116; 
  int v117; 
  __int64 v118; 
  int v119; 
  char v120; 
  hkAabb v121; 
  __int128 v122; 
  __int64 v123; 
  int v124; 
  int v125; 
  char v127; 
  int v128; 
  hknpInplaceTriangleShape v132; 
  char buf[512]; 
  char v134; 
  void *retaddr; 

  _RAX = &retaddr;
  v102 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  _RDI = extendedData;
  _R12 = aabb;
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vmovss  [rbp+4A0h+var_510], xmm9
  }
  v98 = 0i64;
  v99 = 1;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+4A0h+var_4F8], xmm0
  }
  phaseSelection = All;
  v88 = -1;
  contents = 0;
  v90 = NULL;
  __asm { vxorps  xmm1, xmm1, xmm1; radius }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v132, *(float *)&_XMM1);
  m_collisionQueryDispatcher = NULL;
  v92 = (hkReferencedObject *)&v132;
  v93 = (hkReferencedObject *)&v132;
  __asm { vmovss  [rsp+5A0h+var_528], xmm9 }
  v95 = 1;
  v107 = -1;
  v108 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+4A0h+var_4B0], xmm0
  }
  v106 = 0i64;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu [rbp+4A0h+var_490], xmm1
  }
  v110 = 0;
  __asm
  {
    vmovups xmm10, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups [rbp+4A0h+var_470], xmm10
  }
  v111 = 0;
  __asm
  {
    vxorps  xmm11, xmm11, xmm11
    vmovups [rbp+4A0h+var_460], xmm11
    vmovss  [rbp+4A0h+var_478], xmm9
  }
  LOWORD(v87) = -1;
  DWORD1(v87) = 0;
  *((_QWORD *)&v87 + 1) = 0i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14592, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v86) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14593, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid body id %i", "bodyId.isValid()", v86) )
      __debugbreak();
  }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14594, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( _RDI->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14595, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire aabb query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( _RDI->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14596, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire aabb query with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14597, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14598, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14601, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  _RBX = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = _RBX->m_shape;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+10h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+4A0h+var_510], xmm1
  }
  phaseSelection = _RDI->phaseSelection;
  v88 = -1;
  contents = _RDI->contents;
  v90 = &v97;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, QUERY_AABB, (const hknpQueryFilterData *)&v88, _RBX) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    __asm
    {
      vmovups xmm3, xmmword ptr [r12+10h]
      vaddps  xmm0, xmm3, xmmword ptr [r12]
      vmulps  xmm8, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+150h; __m128 const near * const g_vectorfConstants
      vsubps  xmm0, xmm3, xmmword ptr [r12]
      vmulps  xmm5, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+150h; __m128 const near * const g_vectorfConstants
      vmovups xmm1, xmmword ptr [rbx]
      vmovups xmm0, xmmword ptr [rbx+10h]
      vmovups xmm3, xmmword ptr [rbx+20h]
      vunpcklps xmm2, xmm1, xmm0
      vunpckhps xmm0, xmm1, xmm0
      vblendps xmm7, xmm0, xmm3, 0Ch
      vmovlhps xmm4, xmm2, xmm3
      vmovhlps xmm0, xmm4, xmm2
      vshufps xmm6, xmm0, xmm3, 0D4h ; ''
      vshufps xmm1, xmm5, xmm5, 0
      vshufps xmm3, xmm5, xmm5, 55h ; 'U'
      vshufps xmm5, xmm5, xmm5, 0AAh ; ''
      vmulps  xmm0, xmm1, xmm4
      vmovups xmm2, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
      vandnps xmm4, xmm2, xmm0
      vmulps  xmm0, xmm6, xmm3
      vandnps xmm3, xmm2, xmm0
      vmulps  xmm1, xmm7, xmm5
      vandnps xmm2, xmm2, xmm1
      vaddps  xmm0, xmm3, xmm4
      vaddps  xmm7, xmm0, xmm2
      vpxor   xmm1, xmm1, xmm1
      vpinsrw xmm0, xmm1, eax, 1
      vpshufd xmm6, xmm0, 0
      vsubps  xmm5, xmm8, xmmword ptr [rbx+30h]
      vmovups xmm0, xmmword ptr [rbx]
      vmovups xmm1, xmmword ptr [rbx+10h]
      vmovups xmm3, xmmword ptr [rbx+20h]
      vdpps   xmm4, xmm0, xmm5, 71h ; 'q'
      vdpps   xmm2, xmm1, xmm5, 72h ; 'r'
      vdpps   xmm3, xmm3, xmm5, 74h ; 't'
      vorps   xmm0, xmm2, xmm4
      vorps   xmm1, xmm3, xmm0
      vxorps  xmm0, xmm7, xmm6
      vaddps  xmm6, xmm0, xmm1
      vaddps  xmm7, xmm1, xmm7
    }
    *(_QWORD *)&v105 = _RBX;
    *((_QWORD *)&v105 + 1) = _RBX->m_shape;
    *(_QWORD *)&v109 = _RBX;
    LOWORD(v87) = _RBX->m_materialId.m_value;
    DWORD1(v87) = _RBX->m_collisionFilterInfo;
    *((_QWORD *)&v87 + 1) = _RBX->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, QUERY_AABB, _RBX, m_shape, (hknpQueryFilterData *)&v87);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtQueryAABB_Body_HK");
    v116 = -1;
    v117 = 0;
    v118 = 0i64;
    v115[1] = 0i64;
    v115[0] = 0i64;
    v119 = 2;
    v120 = -5;
    __asm
    {
      vmovups xmmword ptr [rbp+4A0h+var_420.m_min.m_quad], xmm6
      vmovups xmmword ptr [rbp+4A0h+var_420.m_max.m_quad], xmm7
    }
    v73 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v74 = v73;
    if ( v73 )
      hkMonitorStream::timerBegin(v73, "TtQueryAabb");
    v103 = v74;
    if ( hkAabb::isValid(&v121) )
    {
      v124 = -1;
      v125 = 0;
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu [rbp+4A0h+var_400], xmm0
      }
      v123 = 0i64;
      __asm
      {
        vpxor   xmm1, xmm1, xmm1
        vmovdqu [rbp+4A0h+var_3E0], xmm1
      }
      v127 = 0;
      __asm { vmovups [rbp+4A0h+var_3C0], xmm10 }
      v128 = 0;
      __asm
      {
        vmovups [rbp+4A0h+var_3B0], xmm11
        vmovss  [rbp+4A0h+var_3C8], xmm9
        vmovups xmm0, [rsp+5A0h+var_568+8]
        vmovdqa [rbp+4A0h+var_520], xmm0
      }
      if ( v115[0] && (*(_BYTE *)(v115[0] + 24) & 1) != 0 )
        (*(void (__fastcall **)(__int64, __int64, _QWORD, const hknpShape *, __int128 *))(*(_QWORD *)v115[0] + 24i64))(v115[0], 5i64, v105, m_shape, &v96);
      m_shape->queryAabbImpl((hknpShape *)m_shape, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, (const hknpAabbQuery *)v115, (const hknpShapeQueryInfo *)&v122, (const hknpQueryFilterData *)&v96, (const hknpShapeQueryInfo *)&v105, Collector, NULL);
      if ( v74 )
        hkMonitorStream::timerEnd(v74, "Et");
    }
    else
    {
      hkErrStream::hkErrStream(&v104, buf, 512);
      hkOstream::operator<<(&v104, "Invalid AABB query. Please check your input AABB.");
      hkErrorFwd::messageWarning(-1357677090, buf, "c:\\workspace\\iw8\\shared\\codware\\sdk\\havok\\hk2018_2_0_r1\\source\\physics\\physics\\collide\\shape\\hknpshapequeryinterface.inl", 215);
      hkErrStream::~hkErrStream(&v104);
      if ( v74 )
        hkMonitorStream::timerEnd(v74, "Et");
    }
    v78 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v78 )
      hkMonitorStream::timerEnd(v78, "Et");
    if ( !v95 )
    {
      hkReferencedObject::removeReference(v92);
      hkReferencedObject::removeReference(v93);
    }
  }
  else if ( !v95 )
  {
    hkReferencedObject::removeReference(v92);
    hkReferencedObject::removeReference(v93);
  }
  _R11 = &v134;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
HavokPhysics_AABBQuery
==============
*/
void HavokPhysics_AABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v18; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v21; 
  int v22; 
  int v23; 
  __int64 v25; 
  hknpBodyId *i; 
  int Ref; 
  int v33; 
  unsigned int v34; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v36; 
  __int64 v37; 
  __int64 v38; 
  hknpBodyId *array; 
  int v40; 
  int v41; 
  int v42; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v44; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v47; 
  __int64 v48[2]; 
  __int16 v49; 
  int contents; 
  int *v51; 
  int v52; 
  char v53; 
  void *retaddr; 

  _R11 = &retaddr;
  v47 = -2i64;
  _RBX = extendedData;
  _R14 = aabb;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+118h+var_C0], xmm0
  }
  ignoreBodies = NULL;
  v44 = 1;
  __asm { vmovdqu [rsp+118h+var_A8], xmm0 }
  phaseSelection = All;
  v53 = -5;
  __asm
  {
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+240h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [r11-58h], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13830, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13831, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13832, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = _RBX->ignoreBodies;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+10h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rsp+118h+var_C0], xmm1
  }
  phaseSelection = _RBX->phaseSelection;
  __asm
  {
    vmovups ymm0, ymmword ptr [r14]
    vmovups [rsp+118h+var_58], ymm0
  }
  v48[0] = (__int64)s_shapeTagCodec;
  v48[1] = *ConstWorld;
  v49 = -1;
  contents = _RBX->contents;
  v51 = &v42;
  v52 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13852, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13855, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryAABB_HK");
  (*(void (__fastcall **)(__int64, __int64 *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 296i64))(ConstWorld[3] + 32, v48, Collector);
  v18 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v18 )
    hkMonitorStream::timerEnd(v18, "Et");
  if ( _RBX->simplify )
  {
    array = NULL;
    v40 = 0;
    v41 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v21 = hkMemHeapAllocator();
    v22 = 0;
    if ( (int)NumHits > 0 )
    {
      v23 = NumHits;
      if ( (int)NumHits < 0 )
        v23 = 0;
      hkArrayUtil::_reserve(v21, &array, v23, 112);
      v22 = v40;
    }
    _RCX = (char *)&array[28 * v22];
    v25 = NumHits;
    if ( (int)NumHits > 0 )
    {
      _RBX = (char *)Hits - _RCX;
      do
      {
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbx+rcx]
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr [rbx+rcx+20h]
            vmovups ymmword ptr [rcx+20h], ymm1
            vmovups ymm0, ymmword ptr [rbx+rcx+40h]
            vmovups ymmword ptr [rcx+40h], ymm0
            vmovups xmm1, xmmword ptr [rbx+rcx+60h]
            vmovups xmmword ptr [rcx+60h], xmm1
          }
        }
        _RCX += 112;
        --v25;
      }
      while ( v25 );
    }
    v40 = NumHits;
    Collector->reset(Collector);
    for ( i = array; i != &array[28 * v40]; i += 28 )
    {
      Ref = HavokPhysics_GetRef(result->m_worldId, i[18]);
      v33 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
      v34 = 0;
      if ( v33 <= 0 )
      {
LABEL_37:
        Collector->addHit(Collector, (const hknpCollisionResult *)i);
      }
      else
      {
        while ( 1 )
        {
          if ( v34 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
          {
            LODWORD(v38) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
            LODWORD(v37) = v34;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 911, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v37, v38) )
              __debugbreak();
          }
          Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v34);
          if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
            break;
          if ( (int)++v34 >= v33 )
            goto LABEL_37;
        }
      }
    }
    v36 = hkMemHeapAllocator();
    v40 = 0;
    if ( v41 >= 0 )
      hkMemoryAllocator::bufFree2(v36, array, 112, v41 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_AccumulateAngularImpulse
==============
*/
void HavokPhysics_AccumulateAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *impulseWs, const hkVector4f *atPointWs, hkVector4f *outAngularVelWs)
{
  hknpWorld *world; 
  __int64 v13; 
  hknpMotion *v14; 
  __int64 v35; 
  hkMatrix3Impl<float> invInertiaOut; 
  char v37; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  _RBP = outAngularVelWs;
  _R14 = atPointWs;
  _R15 = impulseWs;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11807, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to accumulate angular impulse from rigid body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v35) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11808, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to accumulate angular impulse from rigid body with invalid body id for world %i", "bodyId.isValid()", v35) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v35) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11813, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics AccumulateAngularImpulse %i: world is NULL", "world", v35) )
      __debugbreak();
  }
  v13 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v13 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11817, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  v14 = (hknpMotion *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getMotion)(&world->hknpWorldReader, *(unsigned int *)(v13 + 64));
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmm1, xmmword ptr [r15]
    vsubps  xmm2, xmm0, xmmword ptr [rax]
    vshufps xmm0, xmm2, xmm2, 0C9h ; ''
    vmulps  xmm3, xmm0, xmm1
    vshufps xmm1, xmm1, xmm1, 0C9h ; ''
    vmulps  xmm2, xmm1, xmm2
    vsubps  xmm0, xmm2, xmm3
    vshufps xmm6, xmm0, xmm0, 0C9h ; ''
  }
  hknpMotion::getInverseInertiaWorld(v14, &invInertiaOut);
  __asm
  {
    vshufps xmm0, xmm6, xmm6, 55h ; 'U'
    vmulps  xmm3, xmm0, xmmword ptr [rsp+0A8h+invInertiaOut.m_col1.m_quad]
    vshufps xmm1, xmm6, xmm6, 0
    vmulps  xmm2, xmm1, xmmword ptr [rsp+0A8h+invInertiaOut.m_col0.m_quad]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm6, xmm6, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rsp+0A8h+invInertiaOut.m_col2.m_quad]
    vaddps  xmm2, xmm4, xmm1
    vaddps  xmm3, xmm2, xmmword ptr [rbp+0]
    vmovups xmmword ptr [rbp+0], xmm3
  }
  _R11 = &v37;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
HavokPhysics_ActivateBody
==============
*/
void HavokPhysics_ActivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13176, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to activate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13177, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to activate a body with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD))MutableWorld->world->setBodyActivationState)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 0i64);
}

/*
==============
HavokPhysics_AddBodyQualityLibraryToWorld
==============
*/
void HavokPhysics_AddBodyQualityLibraryToWorld(HavokPhysicsBodyQualityLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpWorld *world; 
  unsigned __int8 v7; 
  HavokPhysicsBodyQualityList *list; 
  hknpBodyQuality *m_data; 
  hknpBodyQualityLibrary *m_ptr; 
  unsigned __int64 m_ptrAndInt; 
  unsigned __int64 *p_m_qualityModifiedSignal; 
  _QWORD *v13; 
  unsigned __int64 *v14; 
  unsigned __int64 v15; 
  __int64 v16; 
  hknpWorld *v17; 
  __int64 m_size; 
  unsigned int *v19; 
  __int64 v20; 
  HavokPhysicsWorld *v22; 
  _RTL_CRITICAL_SECTION *v23; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6456, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Body Quality Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v20) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6464, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Body Quality Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v20) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    v22 = MutableWorld;
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    v23 = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getBodyQualityLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v20) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6476, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getBodyQualityLibrary())", "%s\n\tHavokPhysics: Trying to Add Body Quality Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getBodyQualityLibrary()", v20) )
          __debugbreak();
      }
      v7 = 16;
      list = library->list;
      m_data = list->m_bodyQualitys.m_data;
      if ( list->m_bodyQualitys.m_data != &list->m_bodyQualitys.m_data[list->m_bodyQualitys.m_size] )
      {
        do
        {
          m_ptr = MutableWorld->world->m_qualityLibrary.m_ptr;
          if ( hkString::memCmp(&m_ptr->m_qualities[v7].m_priority, &m_data->m_priority, 24) )
          {
            hkPropertyBag::operator=(&m_ptr->m_qualities[v7].m_propertyBag, &m_data->m_propertyBag);
            m_ptr->m_qualities[v7].m_priority = m_data->m_priority;
            m_ptr->m_qualities[v7].m_supportedFlags.m_storage = m_data->m_supportedFlags.m_storage;
            m_ptr->m_qualities[v7].m_requestedFlags.m_storage = m_data->m_requestedFlags.m_storage;
            m_ptr->m_qualities[v7].m_contactCachingRelativeMovementThreshold = m_data->m_contactCachingRelativeMovementThreshold;
            m_ptr->m_qualities[v7].m_motionRangeBreachPolicy = m_data->m_motionRangeBreachPolicy;
            m_ptr->m_qualities[v7].m_motionWeldBreachPolicy = m_data->m_motionWeldBreachPolicy;
            m_ptrAndInt = (unsigned __int64)m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64 | 1;
            m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt = (hkSlot *)m_ptrAndInt;
            p_m_qualityModifiedSignal = (unsigned __int64 *)&m_ptr->m_qualityModifiedSignal;
            v13 = (_QWORD *)(m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64);
            if ( (m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64) != 0 )
            {
              do
              {
                v14 = v13 + 1;
                v15 = v13[1] & 0xFFFFFFFFFFFFFFFCui64;
                v16 = *v13;
                if ( (v13[1] & 3) != 0 )
                {
                  (*(void (__fastcall **)(_QWORD *, __int64))v16)(v13, 1i64);
                  *p_m_qualityModifiedSignal = v15 | *(_DWORD *)p_m_qualityModifiedSignal & 3;
                }
                else
                {
                  (*(void (__fastcall **)(_QWORD *, hknpBodyQualityLibrary *, _QWORD))(v16 + 16))(v13, m_ptr, v7);
                  p_m_qualityModifiedSignal = v14;
                }
                v13 = (_QWORD *)v15;
              }
              while ( v15 );
              m_ptrAndInt = (unsigned __int64)m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt;
            }
            m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt = (hkSlot *)(m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64);
            MutableWorld = v22;
          }
          ++v7;
          ++m_data;
        }
        while ( m_data != &library->list->m_bodyQualitys.m_data[library->list->m_bodyQualitys.m_size] );
        p_critSection = v23;
      }
      v17 = MutableWorld->world;
      m_size = (unsigned int)v17->m_dirtyQualities.m_storage.m_words.m_size;
      if ( (int)m_size > 0 )
      {
        v19 = v17->m_dirtyQualities.m_storage.m_words.m_data;
        while ( m_size )
        {
          *v19++ = 0;
          --m_size;
        }
      }
    }
    LeaveCriticalSection(p_critSection);
  }
}

/*
==============
HavokPhysics_AddClipMap
==============
*/
void HavokPhysics_AddClipMap(clipMap_t *clipMap)
{
  ;
}

/*
==============
HavokPhysics_AddDebugLine
==============
*/
void HavokPhysics_AddDebugLine(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, const unsigned int *color)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v9; 
  int m_size; 

  _RSI = end;
  _RBP = start;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->debugLines && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24015, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  debugLines = MutableWorld->debugLines;
  v9 = hkMemHeapAllocator();
  m_size = debugLines->m_size;
  if ( m_size == (debugLines->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v9, debugLines, 48);
    m_size = debugLines->m_size;
  }
  _RCX = (__int64)&debugLines->m_data[m_size];
  debugLines->m_size = m_size + 1;
  __asm
  {
    vmovups xmm0, xmmword ptr [rbp+0]
    vmovups xmmword ptr [rcx], xmm0
    vmovups xmm1, xmmword ptr [rsi]
    vmovups xmmword ptr [rcx+10h], xmm1
  }
  *(_DWORD *)(_RCX + 32) = *color;
}

/*
==============
HavokPhysics_AddDeferredBulletEffectCallback
==============
*/
void HavokPhysics_AddDeferredBulletEffectCallback(void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int), const Physics_WorldId worldId, hknpBodyId hitBodyId, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletEffectCallback,hkContainerHeapAllocator> *m_deferredBulletEffectEntries; 
  hkMemoryAllocator *v30; 
  int m_size; 
  scr_string_t v33; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  int v45; 
  int v46; 

  if ( !effectCallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12974, ASSERT_TYPE_ASSERT, "(effectCallback)", "%s\n\tHavok Physics: Trying to Add deferred bullte effect callback with no callback", "effectCallback") )
    __debugbreak();
  _RBP = start;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12975, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", (const char *)&queryFormat, "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  _R15 = hitPos;
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
  {
LABEL_28:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12976, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] )") )
      __debugbreak();
  }
  _R14 = hitNormal;
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+68h+arg_10], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
  {
LABEL_29:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12977, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredRadiusForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12983, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  v30 = hkMemHeapAllocator();
  m_size = m_deferredBulletEffectEntries->m_size;
  if ( m_size == (m_deferredBulletEffectEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v30, m_deferredBulletEffectEntries, 136);
    m_size = m_deferredBulletEffectEntries->m_size;
  }
  _RDI = (__int64)&m_deferredBulletEffectEntries->m_data[m_size];
  m_deferredBulletEffectEntries->m_size = m_size + 1;
  *(_QWORD *)_RDI = effectCallback;
  *(_DWORD *)(_RDI + 8) = Physics_GetLocalClientForWorld(worldId);
  *(_DWORD *)(_RDI + 16) = shapeKey;
  *(hknpBodyId *)(_RDI + 12) = hitBodyId;
  *(vec3_t *)(_RDI + 20) = *start;
  *(vec3_t *)(_RDI + 32) = *hitPos;
  *(_DWORD *)(_RDI + 44) = hitSurfaceFlags;
  *(vec3_t *)(_RDI + 48) = *hitNormal;
  v33 = *partName;
  *(_DWORD *)(_RDI + 64) = inflictorEntNum;
  _RAX = weapon;
  *(_DWORD *)(_RDI + 60) = v33;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+44h], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rdi+64h], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rdi+74h], xmm0
  }
  *(_DWORD *)(_RDI + 124) = *(_DWORD *)&weapon->weaponCamo;
  *(_BYTE *)(_RDI + 128) = isAlternate;
  *(_DWORD *)(_RDI + 132) = mod;
}

/*
==============
HavokPhysics_AddDeferredBulletForce
==============
*/
void HavokPhysics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletForce,hkContainerHeapAllocator> *m_deferredBulletForceEntries; 
  hkMemoryAllocator *v15; 
  int m_size; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12924, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add deferred bullet force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredBulletForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12930, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  v15 = hkMemHeapAllocator();
  m_size = m_deferredBulletForceEntries->m_size;
  if ( m_size == (m_deferredBulletForceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v15, m_deferredBulletForceEntries, 104);
    m_size = m_deferredBulletForceEntries->m_size;
  }
  _RCX = (__int64)&m_deferredBulletForceEntries->m_data[m_size];
  m_deferredBulletForceEntries->m_size = m_size + 1;
  *(float *)_RCX = start->v[0];
  *(float *)(_RCX + 4) = start->v[1];
  *(float *)(_RCX + 8) = start->v[2];
  *(float *)(_RCX + 12) = end->v[0];
  *(float *)(_RCX + 16) = end->v[1];
  *(float *)(_RCX + 20) = end->v[2];
  *(_BYTE *)(_RCX + 28) = isMelee;
  _RAX = weapon;
  *(_DWORD *)(_RCX + 24) = inflictorEntNum;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rcx+1Eh], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rcx+3Eh], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rcx+4Eh], xmm0
  }
  *(_DWORD *)(_RCX + 86) = *(_DWORD *)&weapon->weaponCamo;
  *(_BYTE *)(_RCX + 90) = isAlternate;
  *(_DWORD *)(_RCX + 92) = mod;
  *(_QWORD *)(_RCX + 96) = effectCallback;
}

/*
==============
HavokPhysics_AddDeferredKeyframeInstance
==============
*/
void HavokPhysics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredKeyframeInstance,hkContainerHeapAllocator> *m_deferredKeyframeInstanceEntries; 
  hkMemoryAllocator *v31; 
  int m_size; 
  __int64 v35; 
  double v36; 
  Physics_WorldId v37; 
  double v38; 
  double v39; 
  double v40; 
  double v41; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RDI = orientationAsQuat;
  __asm { vmovaps [rsp+78h+var_28], xmm7 }
  if ( worldId )
  {
    if ( !Physics_IsAuthoritativeWorld(worldId) )
    {
      v37 = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12902, ASSERT_TYPE_ASSERT, "(worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId ))", "%s\n\tHavok Physics: Trying to Add deferred keyframe with invalid world index %i", "worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId )", v37) )
        __debugbreak();
    }
  }
  __asm
  {
    vmovss  xmm4, dword ptr [rdi+4]
    vmovss  xmm5, dword ptr [rdi]
    vmovss  xmm6, dword ptr [rdi+8]
    vmovss  xmm7, dword ptr [rdi+0Ch]
    vmulss  xmm1, xmm5, xmm5
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm7, xmm7
    vaddss  xmm2, xmm3, xmm0
    vsubss  xmm1, xmm2, cs:__real@3f800000
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm1, cs:__real@3b03126f
    vsqrtss xmm0, xmm2, xmm2
    vcvtss2sd xmm1, xmm0, xmm0
    vmovsd  [rsp+78h+var_30], xmm1
    vcvtss2sd xmm0, xmm4, xmm4
    vcvtss2sd xmm2, xmm7, xmm7
    vmovsd  [rsp+78h+var_38], xmm2
    vcvtss2sd xmm3, xmm6, xmm6
    vmovsd  [rsp+78h+var_40], xmm3
    vmovsd  [rsp+78h+var_48], xmm0
    vcvtss2sd xmm4, xmm5, xmm5
    vmovsd  [rsp+78h+var_50], xmm4
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12904, ASSERT_TYPE_ASSERT, "( Vec4IsNormalized( orientationAsQuat ) )", "(%g, %g, %g, %g) len: %g", v36, v38, v39, v40, v41) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredKeyframeInstanceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12910, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  v31 = hkMemHeapAllocator();
  m_size = m_deferredKeyframeInstanceEntries->m_size;
  if ( m_size == (m_deferredKeyframeInstanceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v31, m_deferredKeyframeInstanceEntries, 32);
    m_size = m_deferredKeyframeInstanceEntries->m_size;
  }
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm7, [rsp+78h+var_28]
  }
  v35 = (__int64)&m_deferredKeyframeInstanceEntries->m_data[m_size];
  m_deferredKeyframeInstanceEntries->m_size = m_size + 1;
  *(float *)(v35 + 4) = origin->v[0];
  *(float *)(v35 + 8) = origin->v[1];
  *(float *)(v35 + 12) = origin->v[2];
  *(float *)(v35 + 16) = _RDI->v[0];
  *(float *)(v35 + 20) = _RDI->v[1];
  *(float *)(v35 + 24) = _RDI->v[2];
  *(float *)(v35 + 28) = _RDI->v[3];
  *(_DWORD *)v35 = instanceId;
}

/*
==============
HavokPhysics_AddDeferredRadiusForce
==============
*/

void __fastcall HavokPhysics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, double radius, double innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredRadiusForce,hkContainerHeapAllocator> *m_deferredRadiusForceEntries; 
  hkMemoryAllocator *v17; 
  int m_size; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm3
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12949, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add deferred radius force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredRadiusForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12955, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  m_deferredRadiusForceEntries = MutableWorld->m_deferredRadiusForceEntries;
  v17 = hkMemHeapAllocator();
  m_size = m_deferredRadiusForceEntries->m_size;
  if ( m_size == (m_deferredRadiusForceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v17, m_deferredRadiusForceEntries, 48);
    m_size = m_deferredRadiusForceEntries->m_size;
  }
  __asm
  {
    vmovss  xmm0, [rsp+68h+outerDamage]
    vmovss  xmm1, [rsp+68h+impulseOverride]
  }
  _RDX = (__int64)&m_deferredRadiusForceEntries->m_data[m_size];
  m_deferredRadiusForceEntries->m_size = m_size + 1;
  *(float *)_RDX = position->v[0];
  *(float *)(_RDX + 4) = position->v[1];
  *(float *)(_RDX + 8) = position->v[2];
  __asm
  {
    vmovss  dword ptr [rdx+0Ch], xmm7
    vmovaps xmm7, [rsp+68h+var_28]
    vmovss  dword ptr [rdx+10h], xmm6
    vmovaps xmm6, [rsp+68h+var_18]
    vmovss  dword ptr [rdx+14h], xmm0
    vmovss  xmm0, [rsp+68h+forceScalar]
    vmovss  dword ptr [rdx+18h], xmm1
  }
  *(vec3_t *)(_RDX + 28) = *impulseVecOverride;
  *(_DWORD *)(_RDX + 40) = randSeed;
  __asm { vmovss  dword ptr [rdx+2Ch], xmm0 }
}

/*
==============
HavokPhysics_AddDetailCollisionShapesToInstanceList
==============
*/

__int64 __fastcall HavokPhysics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const hkVector4f *origin, double scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  __int64 result; 
  int v16; 
  __int64 v17; 
  __int64 v18; 
  hkMemoryAllocator *v45; 
  int m_size; 
  hknpShapeInstance *m_data; 
  int v48; 
  hknpShapeInstance *v53; 
  hkVector4f direction; 
  hkQuaternionf v60; 
  hkQuaternionf qi; 
  hkVector4f scalea; 
  hkTransformf v63; 

  __asm { vmovaps [rsp+158h+var_38], xmm6 }
  _R13 = orientation;
  __asm { vmovaps xmm6, xmm2 }
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15792, ASSERT_TYPE_ASSERT, "(detailCollision)", (const char *)&queryFormat, "detailCollision") )
    __debugbreak();
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15793, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15797, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics AddDetailCollisionShapesToInstanceList %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  result = (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  v16 = 0;
  if ( (int)result > 0 )
  {
    v17 = 0i64;
    __asm { vmovaps [rsp+158h+var_48], xmm7 }
    v18 = 0i64;
    __asm
    {
      vmovaps [rsp+158h+var_58], xmm8
      vmovaps [rsp+158h+var_68], xmm9
      vmovaps xmm9, xmm6
      vshufps xmm9, xmm9, xmm9, 0
      vxorps  xmm0, xmm0, xmm0
      vmovaps [rsp+158h+var_78], xmm10
      vblendps xmm10, xmm9, xmm0, 8
    }
    do
    {
      hkQuaternionf::setAndNormalize(&v60, &HavokPhysicsXModelLODFromDetailCol->m_bodyBindPoses.m_data[v18].m_rotation);
      __asm
      {
        vmulps  xmm0, xmm9, xmmword ptr [rbx+30h]
        vmovups xmmword ptr [rsp+158h+direction.m_quad], xmm0
      }
      hkVector4f::setRotatedDir(&direction, _R13, &direction);
      __asm
      {
        vmovups xmm5, xmmword ptr [rsp+158h+var_F8.m_vec.m_quad]
        vmovups xmm8, xmmword ptr [r13+0]
        vmovups xmm0, xmmword ptr [rsp+158h+direction.m_quad]
        vbroadcastss xmm7, dword ptr [r13+0Ch]
        vshufps xmm6, xmm5, xmm5, 0FFh
        vaddps  xmm1, xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rsp+158h+direction.m_quad], xmm1
        vshufps xmm1, xmm8, xmm8, 0C9h ; ''
        vmulps  xmm2, xmm1, xmm5
        vshufps xmm0, xmm5, xmm5, 0C9h ; ''
        vmulps  xmm3, xmm0, xmm8
        vsubps  xmm4, xmm3, xmm2
        vmulps  xmm1, xmm6, xmm7
        vdpps   xmm0, xmm8, xmm5, 7Fh
        vsubps  xmm3, xmm1, xmm0
        vshufps xmm1, xmm4, xmm4, 0C9h ; ''
        vmulps  xmm0, xmm5, xmm7
        vaddps  xmm2, xmm1, xmm0
        vmulps  xmm1, xmm8, xmm6
        vaddps  xmm2, xmm2, xmm1
        vblendps xmm0, xmm2, xmm3, 8
        vmovups xmmword ptr [rsp+158h+qi.m_vec.m_quad], xmm0
      }
      hkRotationImpl<float>::set(&v63.m_rotation, &qi);
      __asm
      {
        vmovups xmm0, xmmword ptr [rsp+158h+direction.m_quad]
        vmovups [rsp+158h+var_98], xmm0
      }
      v45 = hkMemHeapAllocator();
      m_size = instanceArray->m_size;
      if ( m_size == (instanceArray->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v45, instanceArray, 112);
        m_size = instanceArray->m_size;
      }
      m_data = instanceArray->m_data;
      v48 = m_size;
      _RCX = &instanceArray->m_data[m_size];
      if ( _RCX )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rcx], ymm0
          vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rcx+20h], ymm1
          vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
          vmovups xmmword ptr [rcx+40h], xmm0
        }
        _RCX->m_shape.m_ptr = NULL;
        *(_DWORD *)&_RCX->m_shapeTag = -1;
        _RCX->m_isEmpty = 0;
        _RCX->m_nextEmptyElement = 0;
        _RCX->m_instanceId.m_value = -1;
        _RCX->m_parentShape = NULL;
        _RCX->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
        v48 = instanceArray->m_size;
        m_data = instanceArray->m_data;
      }
      instanceArray->m_size = v48 + 1;
      v53 = &m_data[v48];
      hknpShapeInstance::setShape(v53, HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v17]);
      __asm { vmovups xmmword ptr [rsp+158h+scale.m_quad], xmm10 }
      hknpShapeInstance::setScale(v53, &scalea, SCALE_SURFACE);
      hknpShapeInstance::setTransform(v53, &v63);
      result = (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
      ++v16;
      ++v18;
      ++v17;
    }
    while ( v16 < (int)result );
    __asm
    {
      vmovaps xmm10, [rsp+158h+var_78]
      vmovaps xmm9, [rsp+158h+var_68]
      vmovaps xmm8, [rsp+158h+var_58]
      vmovaps xmm7, [rsp+158h+var_48]
    }
  }
  __asm { vmovaps xmm6, [rsp+158h+var_38] }
  return result;
}

/*
==============
HavokPhysics_AddDetailTrace
==============
*/
void HavokPhysics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  hkMemoryRouter *Value; 
  HavokPhysicsHitCollector_DetailTraceModifier *v5; 
  HavokPhysicsHitCollector_Modifier *v6; 
  HavokPhysicsHitCollector_Modifier *v7; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (HavokPhysicsHitCollector_DetailTraceModifier *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
  if ( v5 )
  {
    HavokPhysicsHitCollector_DetailTraceModifier::HavokPhysicsHitCollector_DetailTraceModifier(v5, result->m_worldId, detailPriorityMap);
    v7 = v6;
  }
  else
  {
    v7 = NULL;
  }
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13644, ASSERT_TYPE_ASSERT, "(modifier)", (const char *)&queryFormat, "modifier", -2i64) )
    __debugbreak();
  HavokPhysicsHitCollector::AddModifier(result->m_collector, v7);
}

/*
==============
HavokPhysics_AddInstanceToWorld
==============
*/
void HavokPhysics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  __int64 v4; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  hknpBodyId *m_data; 
  int m_size; 
  int v12; 
  __int64 v13; 

  v4 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11134, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to add instance to world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v4 == -1 )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11135, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to add instance to world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v13) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11140, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics AddInstanceToWorld %i: world is NULL", "havokPhysicsWorld->world", v13) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", (_DWORD)MutableWorld + 228, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v4 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  m_data = p_instanceManager->buffer[v4].bodies.m_data;
  m_size = p_instanceManager->buffer[v4].bodies.m_size;
  if ( HavokPhysics_IsInstanceDetailBounded(worldId, v4) )
  {
    v12 = m_size - 1;
    m_size = 1;
    m_data += v12;
  }
  HavokPhysics_AddRigidBodies(MutableWorld, m_data, m_size, immediate, tryStartDeactivated);
  HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v4, immediate, !immediate);
}

/*
==============
HavokPhysics_AddMaterialLibraryToWorld
==============
*/
void HavokPhysics_AddMaterialLibraryToWorld(HavokPhysicsMaterialLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  hknpWorld *v6; 
  hknpMaterialLibrary *m_ptr; 
  int v8; 
  HavokPhysicsMaterialList *list; 
  hknpMaterial *m_data; 
  hknpWorld *v11; 
  __int64 m_size; 
  unsigned int *v13; 
  __int64 v14; 
  int capacity; 
  hkCriticalSection *p_critSection; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6500, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Material Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6508, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Material Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v14) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    p_critSection = &MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMaterialLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v14) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6520, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMaterialLibrary())", "%s\n\tHavokPhysics: Trying to Add Material Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getMaterialLibrary()", v14) )
          __debugbreak();
      }
      v6 = MutableWorld->world;
      m_ptr = v6->m_materialLibrary.m_ptr;
      v6->getMaterialLibrary(&v6->hknpWorldReader);
      hknpMaterialLibrary::setCapacity(m_ptr, (int)&capacity);
      v8 = 0;
      list = library->list;
      m_data = list->m_materials.m_data;
      if ( list->m_materials.m_data != &list->m_materials.m_data[list->m_materials.m_size] )
      {
        do
        {
          if ( v8 != hknpMaterialLibrary::addEntry(MutableWorld->world->m_materialLibrary.m_ptr, (hknpMaterialId *)&capacity, m_data)->m_value - library->firstId.m_value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6531, ASSERT_TYPE_ASSERT, "(materialIdx == materialId.value() - library->firstId.value())", "%s\n\tPhysics Material Library index is assumed to be linearly increasing", "materialIdx == materialId.value() - library->firstId.value()") )
            __debugbreak();
          ++v8;
          ++m_data;
        }
        while ( m_data != &library->list->m_materials.m_data[library->list->m_materials.m_size] );
      }
      v11 = MutableWorld->world;
      m_size = (unsigned int)v11->m_dirtyMaterials.m_storage.m_words.m_size;
      if ( (int)m_size > 0 )
      {
        v13 = v11->m_dirtyMaterials.m_storage.m_words.m_data;
        while ( m_size )
        {
          *v13++ = 0;
          --m_size;
        }
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_AddModifier
==============
*/
void HavokPhysics_AddModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16430, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to AddModifier with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16434, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics AddModifier %i: world is NULL", "physicsWorld->world", v5) )
      __debugbreak();
  }
  hknpModifierManager::addModifier(MutableWorld->world->m_modifierManager, (hknpCollisionFlags)128, modifier, PRIORITY_LOWER);
}

/*
==============
HavokPhysics_AddMotionPropertiesLibraryToWorld
==============
*/
void HavokPhysics_AddMotionPropertiesLibraryToWorld(HavokPhysicsMotionPropertiesLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpWorld *world; 
  hknpWorld *v8; 
  hknpMotionPropertiesLibrary *m_ptr; 
  HavokPhysicsMotionPropertiesList *list; 
  __int64 m_size; 
  hkMemoryAllocator *v12; 
  int v13; 
  __int64 v14; 
  __int64 v15; 
  char *v16; 
  unsigned int v17; 
  __int64 v18; 
  char *v25; 
  bool v26; 
  int v29; 
  __int64 v30; 
  signed int v31; 
  char *v32; 
  __int64 v33; 
  int m_value; 
  unsigned int v35; 
  char *v36; 
  unsigned int v37; 
  signed int v38; 
  __int64 v39; 
  __int64 v40; 
  unsigned __int16 v41; 
  signed int v42; 
  int v43; 
  hknpMotionProperties *v44; 
  __int64 v45; 
  unsigned __int16 v46; 
  __int64 v47; 
  unsigned int v48; 
  signed int v49; 
  unsigned __int16 v50; 
  hkMemoryAllocator *v51; 
  __int64 v52; 
  __int64 v53; 
  __int64 v54; 
  int numInOut; 
  int v56; 
  unsigned int v57; 
  void *p; 
  HavokPhysicsWorld *v59; 
  int v60; 
  int v61; 
  __int64 v62; 
  _RTL_CRITICAL_SECTION *v63; 
  char *v64; 
  int v65; 
  unsigned int v66; 
  __int64 v67; 
  int capacity; 
  hknpMotionPropertiesId result; 
  hknpMotionPropertiesId v70; 

  v67 = -2i64;
  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6549, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v52) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6557, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v52) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    v59 = MutableWorld;
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    v63 = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMotionPropertiesLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v52) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6569, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMotionPropertiesLibrary())", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getMotionPropertiesLibrary()", v52) )
          __debugbreak();
      }
      v8 = MutableWorld->world;
      m_ptr = v8->m_motionPropertiesLibrary.m_ptr;
      v8->getMotionPropertiesLibrary(&v8->hknpWorldReader);
      hknpMotionPropertiesLibrary::setCapacity(m_ptr, (int)&capacity);
      list = library->list;
      m_size = list->m_motionProperties.m_size;
      numInOut = list->m_motionProperties.m_size;
      v12 = hkMemHeapAllocator();
      v13 = numInOut;
      v14 = numInOut;
      v60 = numInOut;
      LODWORD(v15) = 0;
      v62 = 0i64;
      if ( numInOut )
      {
        v16 = (char *)hkMemoryAllocator::bufAlloc2(v12, 112, &numInOut);
        p = v16;
        v13 = numInOut;
      }
      else
      {
        v16 = NULL;
        p = NULL;
      }
      v17 = 0x80000000;
      if ( v13 )
        v17 = v13;
      v61 = v17;
      v64 = v16;
      v65 = v14;
      v66 = v17;
      v18 = m_size;
      if ( (int)m_size > 0 )
      {
        _RAX = v16;
        _RCX = (char *)list->m_motionProperties.m_data - v16;
        do
        {
          if ( _RAX )
          {
            __asm
            {
              vmovups ymm0, ymmword ptr [rcx+rax]
              vmovups ymmword ptr [rax], ymm0
              vmovups ymm1, ymmword ptr [rcx+rax+20h]
              vmovups ymmword ptr [rax+20h], ymm1
              vmovups ymm0, ymmword ptr [rcx+rax+40h]
              vmovups ymmword ptr [rax+40h], ymm0
              vmovups xmm1, xmmword ptr [rcx+rax+60h]
              vmovups xmmword ptr [rax+60h], xmm1
            }
          }
          _RAX += 112;
          --v18;
        }
        while ( v18 );
      }
      v25 = &v16[112 * v14];
      v26 = v16 == v25;
      if ( v16 != v25 )
      {
        _RCX = v16 + 4;
        __asm { vxorps  xmm0, xmm0, xmm0 }
        do
        {
          __asm { vucomiss xmm0, dword ptr [rcx+4] }
          if ( !v26 )
            *_RCX |= 0x10000u;
          _RCX += 28;
          v26 = _RCX - 1 == (_DWORD *)v25;
        }
        while ( _RCX - 1 != (_DWORD *)v25 );
      }
      v29 = 11;
      v56 = 11;
      if ( (unsigned int)v14 < 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6588, ASSERT_TYPE_ASSERT, "( SP_GOLD_MOTION_PROPERTIES_LIST_COUNT ) <= ( motionPropertiesArray.getSize() )", "%s <= %s\n\t%u, %u", "SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", "motionPropertiesArray.getSize()", 11, v14) )
        __debugbreak();
      if ( s_motionPropertiesAreReorderedForSPGold || (v29 = v14, v56 = v14, (int)v14 > 0) )
      {
        v30 = 0i64;
        v31 = 0;
        v32 = (char *)p;
        v33 = (__int64)v59;
        do
        {
          m_value = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v33 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, (const hknpMotionProperties *)&v32[v30])->m_value;
          if ( v31 != m_value - library->firstId.m_value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6599, ASSERT_TYPE_ASSERT, "(motionPropertiesIdx == motionPropertiesId.value() - library->firstId.value())", "%s\n\tPhysics Motion Properties Library index is assumed to be linearly increasing", "motionPropertiesIdx == motionPropertiesId.value() - library->firstId.value()") )
            __debugbreak();
          if ( (_WORD)m_value != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v31)->m_value )
          {
            LODWORD(v54) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v70, 0, v31)->m_value;
            LODWORD(v53) = m_value;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6600, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value()", v53, v54) )
              __debugbreak();
          }
          if ( v31 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)m_value) )
          {
            LODWORD(v54) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)m_value);
            LODWORD(v53) = v31;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6601, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v53, v54) )
              __debugbreak();
          }
          ++v31;
          v30 += 112i64;
        }
        while ( v31 < v29 );
        LODWORD(v15) = 0;
      }
      v35 = 0;
      v57 = 0;
      v36 = (char *)p;
      do
      {
        v37 = v35 + 1;
        v38 = 0;
        if ( v29 > 0 )
        {
          v39 = 0i64;
          v40 = (__int64)v59;
          do
          {
            v41 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v40 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, (const hknpMotionProperties *)&v36[v39])->m_value;
            if ( v41 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v37, v38)->m_value )
            {
              LODWORD(v54) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v70, v37, v38)->m_value;
              LODWORD(v53) = v41;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6615, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value()", v53, v54) )
                __debugbreak();
            }
            if ( v38 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v41) )
            {
              LODWORD(v54) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v41);
              LODWORD(v53) = v38;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6616, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v53, v54) )
                __debugbreak();
            }
            ++v38;
            v39 += 112i64;
          }
          while ( v38 < v29 );
          v35 = v57;
          LODWORD(v15) = 0;
        }
        v57 = ++v35;
      }
      while ( v35 < 4 );
      v42 = v29;
      v43 = v60;
      v44 = (hknpMotionProperties *)p;
      if ( v29 < v60 )
      {
        v45 = (__int64)v59;
        do
        {
          v46 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v45 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, &v44[v42])->m_value;
          if ( v46 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v42)->m_value )
          {
            LODWORD(v54) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v70, 0, v42)->m_value;
            LODWORD(v53) = v46;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6625, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value()", v53, v54) )
              __debugbreak();
          }
          if ( v42 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v46) )
          {
            LODWORD(v54) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v46);
            LODWORD(v53) = v42;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6626, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v53, v54) )
              __debugbreak();
          }
          ++v42;
        }
        while ( v42 < v43 );
        v29 = v56;
        LODWORD(v15) = 0;
      }
      v47 = (__int64)v59;
      do
      {
        v48 = v15 + 1;
        v49 = v29;
        if ( v29 < v43 )
        {
          do
          {
            v50 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v47 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, &v44[v49])->m_value;
            if ( v50 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v48, v49)->m_value )
            {
              LODWORD(v54) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v70, v48, v49)->m_value;
              LODWORD(v53) = v50;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6639, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value()", v53, v54) )
                __debugbreak();
            }
            if ( v49 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v50) )
            {
              LODWORD(v54) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v50);
              LODWORD(v53) = v49;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6640, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v53, v54) )
                __debugbreak();
            }
            ++v49;
          }
          while ( v49 < v43 );
          v29 = v56;
          LODWORD(v15) = v62;
        }
        v15 = (unsigned int)(v15 + 1);
        v62 = v15;
      }
      while ( (unsigned int)v15 < 4 );
      v51 = hkMemHeapAllocator();
      p_critSection = v63;
      if ( v61 >= 0 )
        hkMemoryAllocator::bufFree2(v51, v44, 112, v61 & 0x3FFFFFFF);
    }
    LeaveCriticalSection(p_critSection);
  }
}

/*
==============
HavokPhysics_AddPendingBodies
==============
*/
void HavokPhysics_AddPendingBodies(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  __int64 v4; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10905, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add Pending Bodies to invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10909, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavok Physics: Trying to Add Pending Bodies where index %i doesn't have a world yet", "havokPhysicsWorld->world", v4) )
      __debugbreak();
  }
  world = MutableWorld->world;
  if ( world->m_bodyManager.m_bodiesToAddAsActive.m_size || world->m_bodyManager.m_bodiesToAddAsInactive.m_size )
  {
    world->commitAddBodies(&world->hknpWorldWriter);
    MutableWorld->world->updateBroadPhase(&MutableWorld->world->hknpWorldWriter);
  }
}

/*
==============
HavokPhysics_AddPhysicsAsset
==============
*/
void HavokPhysics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  int v2; 
  int *m_addr; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  int v7; 
  int v8; 
  PhysicsAsset *key; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v10; 
  int v11; 
  int v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  PhysicsAsset *v18; 
  __int64 v19; 
  _DWORD *v20; 
  __int64 v21; 
  unsigned int v22; 
  int *m_data; 
  int *v24; 
  _DWORD *v25; 
  __int64 v26; 
  char v27; 
  int *v28; 
  int *v29; 
  _DWORD *v30; 
  __int64 v31; 
  __int16 v32; 
  int *v33; 
  int *v34; 
  char v35; 
  char containsDynamicBodies; 
  const char *v37; 
  const char *v38; 
  __int64 v39; 
  hkReflect::Var result; 
  hkMemoryAllocator alloc; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7327, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tTrying to add a NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7329, ASSERT_TYPE_ASSERT, "(physicsAsset->havokData)", "%s\n\tTrying to add a Physics Asset with NULL data", "physicsAsset->havokData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7330, ASSERT_TYPE_ASSERT, "(physicsAsset->havokDataSize > 0)", "%s\n\tTrying to add a Physics Asset with 0 data size", "physicsAsset->havokDataSize > 0") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  v2 = 0;
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, physicsAsset->havokData, physicsAsset->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsAsset::typeData);
  m_addr = (int *)result.m_addr;
  if ( !result.m_addr )
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
    goto LABEL_30;
  }
  if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsAsset::typeData) )
    m_addr = NULL;
  if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
    hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  if ( !m_addr )
  {
LABEL_30:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7335, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
      __debugbreak();
  }
  HavokPhysics_LockAssetWrite();
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7340, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Add a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v6 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v7 = m_hashMod & (v6 ^ ((v5 >> 2) + v5 + (v6 << 6) - 1640531527)), v8 = v7, key = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v7].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_39:
    v8 = m_hashMod + 1;
  }
  else
  {
    while ( key != physicsAsset )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = v7;
      key = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v7].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_39;
    }
  }
  if ( v8 <= m_hashMod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7341, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsAssets->hasKey( physicsAsset ))", "%s\n\tPhysics asset already exists in map", "!s_havokPhysicsAssets->hasKey( physicsAsset )") )
    __debugbreak();
  v10 = s_havokPhysicsAssets;
  v11 = (unsigned int)hkMemHeapAllocator();
  v12 = v10->m_map.m_hashMod;
  if ( 2 * v10->m_map.m_numElems > v12 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v10->m_map, &alloc, v11);
    v12 = v10->m_map.m_hashMod;
  }
  v13 = 1;
  v14 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset);
  v15 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset));
  v16 = v12 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527));
  m_elem = v10->m_map.m_elem;
  v18 = (PhysicsAsset *)v10->m_map.m_elem[v16].key;
  if ( v18 != (PhysicsAsset *)-1i64 )
  {
    while ( v18 != physicsAsset )
    {
      v16 = v10->m_map.m_hashMod & (v16 + 1);
      v18 = (PhysicsAsset *)m_elem[v16].key;
      if ( v18 == (PhysicsAsset *)-1i64 )
        goto LABEL_50;
    }
    v13 = 0;
  }
LABEL_50:
  v10->m_map.m_numElems += v13;
  v19 = (int)v16;
  m_elem[v19].key = (unsigned __int64)physicsAsset;
  v10->m_map.m_elem[v19].val = (unsigned __int64)m_addr;
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7342, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->insert( physicsAsset, havokPhysicsAsset ))", (const char *)&queryFormat, "s_havokPhysicsAssets->insert( physicsAsset, havokPhysicsAsset )") )
    __debugbreak();
  v20 = (_DWORD *)*((_QWORD *)m_addr + 6);
  if ( v20 != &v20[m_addr[14]] )
  {
    v21 = 0i64;
    do
    {
      v22 = 0;
      m_data = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_data;
      v24 = &m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size];
      if ( m_data == v24 )
        goto LABEL_60;
      while ( *m_data != *v20 )
      {
        ++v22;
        if ( ++m_data == v24 )
          goto LABEL_60;
      }
      if ( m_data == v24 )
      {
LABEL_60:
        LODWORD(v39) = *v20;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7374, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.end())", "%s\n\tMotion Properties %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(hknpMotionPropertiesId *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v21 + 136) = (hknpMotionPropertiesId)HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex((hknpMotionPropertiesId *)&alloc, 0, v22)->m_value;
      v21 += 192i64;
      ++v20;
    }
    while ( v20 != (_DWORD *)(*((_QWORD *)m_addr + 6) + 4i64 * m_addr[14]) );
  }
  v25 = (_DWORD *)*((_QWORD *)m_addr + 2);
  if ( v25 != &v25[m_addr[6]] )
  {
    v26 = 0i64;
    do
    {
      v27 = 0;
      v28 = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_data;
      v29 = &v28[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_size];
      if ( v28 == v29 )
        goto LABEL_70;
      while ( *v28 != *v25 )
      {
        ++v27;
        if ( ++v28 == v29 )
          goto LABEL_70;
      }
      if ( v28 == v29 )
      {
LABEL_70:
        LODWORD(v39) = *v25;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7407, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.end())", "%s\n\tBody Quality %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(_BYTE *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v26 + 22) = v27 + 16;
      v26 += 192i64;
      ++v25;
    }
    while ( v25 != (_DWORD *)(*((_QWORD *)m_addr + 2) + 4i64 * m_addr[6]) );
  }
  v30 = (_DWORD *)*((_QWORD *)m_addr + 4);
  if ( v30 != &v30[m_addr[10]] )
  {
    v31 = 0i64;
    do
    {
      v32 = 0;
      v33 = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data;
      v34 = &v33[s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size];
      if ( v33 == v34 )
        goto LABEL_80;
      while ( *v33 != *v30 )
      {
        ++v32;
        if ( ++v33 == v34 )
          goto LABEL_80;
      }
      if ( v33 == v34 )
      {
LABEL_80:
        LODWORD(v39) = *v30;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7440, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.end())", "%s\n\tMaterial %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(_WORD *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v31 + 20) = v32 + s_havokPhysicsMaterialLibrary.firstId.m_value;
      v31 += 192i64;
      ++v30;
    }
    while ( v30 != (_DWORD *)(*((_QWORD *)m_addr + 4) + 4i64 * m_addr[10]) );
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  v35 = 0;
  if ( *(int *)(*((_QWORD *)m_addr + 1) + 64i64) > 0 )
  {
    do
      v35 |= HavokPhysics_IsPhysicsAssetBodyDynamic(physicsAsset, v2++);
    while ( v2 < *(_DWORD *)(*((_QWORD *)m_addr + 1) + 64i64) );
  }
  containsDynamicBodies = physicsAsset->containsDynamicBodies;
  if ( v35 != containsDynamicBodies )
  {
    v37 = "doesn't";
    if ( v35 )
      v37 = "does";
    v38 = "not have";
    if ( containsDynamicBodies )
      v38 = "have";
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7462, ASSERT_TYPE_ASSERT, "(anyBodiesDynamic == physicsAsset->containsDynamicBodies)", "%s\n\tHavokPhysics AddPhysicsAsset %s: physics asset claims to %s dynamic bodies, but it %s", "anyBodiesDynamic == physicsAsset->containsDynamicBodies", physicsAsset->name, v38, v37) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_AddPhysicsAssetShapesToInstanceList
==============
*/

__int64 __fastcall HavokPhysics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const hkVector4f *origin, double scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  const hknpShape **p_m_ptr; 
  unsigned __int16 ShapeTag; 
  hkMemoryAllocator *v45; 
  int m_size; 
  hknpShapeInstance *m_data; 
  int v48; 
  hknpShapeInstance *v53; 
  hknpPhysicsSystemData *v54; 
  __int64 result; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 
  hkVector4f direction; 
  hkQuaternionf qi; 
  hkVector4f scalea; 
  hkTransformf v65; 

  __asm { vmovaps [rsp+158h+var_38], xmm6 }
  _R13 = orientation;
  __asm { vmovaps xmm6, xmm2 }
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15743, ASSERT_TYPE_ASSERT, "(physicsAsset)", (const char *)&queryFormat, "physicsAsset") )
    __debugbreak();
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15744, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15748, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics AddPhysicsAssetShapesToInstanceList %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  p_m_ptr = &m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr;
  if ( p_m_ptr == &p_m_ptr[24 * m_physicsSystemData->m_bodyCinfos.m_size] )
  {
    result = (unsigned int)m_physicsSystemData->m_bodyCinfos.m_size;
  }
  else
  {
    __asm { vmovaps [rsp+158h+var_48], xmm7 }
    _R14 = p_m_ptr + 8;
    __asm
    {
      vmovaps [rsp+158h+var_58], xmm8
      vmovaps [rsp+158h+var_68], xmm9
      vmovaps xmm9, xmm6
      vshufps xmm9, xmm9, xmm9, 0
      vxorps  xmm0, xmm0, xmm0
      vmovaps [rsp+158h+var_78], xmm10
      vblendps xmm10, xmm9, xmm0, 8
    }
    do
    {
      __asm
      {
        vmulps  xmm0, xmm9, xmmword ptr [r14-10h]
        vmovups xmmword ptr [rsp+158h+direction.m_quad], xmm0
      }
      hkVector4f::setRotatedDir(&direction, _R13, &direction);
      __asm
      {
        vmovups xmm8, xmmword ptr [r13+0]
        vmovups xmm7, xmmword ptr [r14]
        vmovups xmm0, xmmword ptr [rsp+158h+direction.m_quad]
        vaddps  xmm1, xmm0, xmmword ptr [r12]
        vbroadcastss xmm6, dword ptr [r13+0Ch]
        vbroadcastss xmm5, dword ptr [r14+0Ch]
        vmovups xmmword ptr [rsp+158h+direction.m_quad], xmm1
        vshufps xmm1, xmm7, xmm7, 0C9h ; ''
        vmulps  xmm2, xmm1, xmm8
        vshufps xmm0, xmm8, xmm8, 0C9h ; ''
        vmulps  xmm3, xmm0, xmm7
        vsubps  xmm4, xmm2, xmm3
        vmulps  xmm1, xmm5, xmm6
        vdpps   xmm0, xmm8, xmm7, 7Fh
        vsubps  xmm3, xmm1, xmm0
        vshufps xmm1, xmm4, xmm4, 0C9h ; ''
        vmulps  xmm0, xmm7, xmm6
        vaddps  xmm2, xmm1, xmm0
        vmulps  xmm1, xmm8, xmm5
        vaddps  xmm2, xmm2, xmm1
        vblendps xmm0, xmm2, xmm3, 8
        vmovups xmmword ptr [rsp+158h+qi.m_vec.m_quad], xmm0
      }
      hkRotationImpl<float>::set(&v65.m_rotation, &qi);
      __asm { vmovups xmm0, xmmword ptr [rsp+158h+direction.m_quad] }
      shapeTagData.m_collisionFilterInfo = *((_DWORD *)_R14 - 12);
      shapeTagData.m_materialId.m_value = *((_WORD *)_R14 - 22);
      __asm { vmovups [rsp+158h+var_98], xmm0 }
      shapeTagData.m_materialCRC = 0;
      shapeTagData.m_userData = 0i64;
      ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
      v45 = hkMemHeapAllocator();
      m_size = instanceArray->m_size;
      if ( m_size == (instanceArray->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v45, instanceArray, 112);
        m_size = instanceArray->m_size;
      }
      m_data = instanceArray->m_data;
      v48 = m_size;
      _RCX = &instanceArray->m_data[m_size];
      if ( _RCX )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rcx], ymm0
          vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rcx+20h], ymm1
          vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
          vmovups xmmword ptr [rcx+40h], xmm0
        }
        _RCX->m_shape.m_ptr = NULL;
        *(_DWORD *)&_RCX->m_shapeTag = -1;
        _RCX->m_isEmpty = 0;
        _RCX->m_nextEmptyElement = 0;
        _RCX->m_instanceId.m_value = -1;
        _RCX->m_parentShape = NULL;
        _RCX->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
        v48 = instanceArray->m_size;
        m_data = instanceArray->m_data;
      }
      v53 = &m_data[v48];
      instanceArray->m_size = v48 + 1;
      hknpShapeInstance::setShape(v53, *p_m_ptr);
      __asm { vmovups xmmword ptr [rsp+158h+scale.m_quad], xmm10 }
      hknpShapeInstance::setScale(v53, &scalea, SCALE_SURFACE);
      hknpShapeInstance::setTransform(v53, &v65);
      v53->m_shapeTag = ShapeTag;
      p_m_ptr += 24;
      v54 = HavokPhysicsAsset->m_physicsSystemData;
      _R14 += 24;
    }
    while ( p_m_ptr != &v54->m_bodyCinfos.m_data[v54->m_bodyCinfos.m_size].m_shape.m_ptr );
    result = (unsigned int)v54->m_bodyCinfos.m_size;
    __asm
    {
      vmovaps xmm10, [rsp+158h+var_78]
      vmovaps xmm9, [rsp+158h+var_68]
      vmovaps xmm8, [rsp+158h+var_58]
      vmovaps xmm7, [rsp+158h+var_48]
    }
  }
  __asm { vmovaps xmm6, [rsp+158h+var_38] }
  return result;
}

/*
==============
HavokPhysics_AddPhysicsLibrary
==============
*/
void HavokPhysics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  hkSerialize::InplaceLoad *v2; 
  HavokPhysicsBodyQualityList *m_addr; 
  int v4; 
  int v5; 
  int *m_data; 
  int *v7; 
  int v8; 
  int v9; 
  int v10; 
  hkSerialize::InplaceLoad *v11; 
  HavokPhysicsMaterialList *v12; 
  int v13; 
  hkSerialize::InplaceLoad *v14; 
  HavokPhysicsMotionPropertiesList *v15; 
  int v16; 
  int v17; 
  int *v18; 
  int *i; 
  int v20; 
  hkSerialize::InplaceLoad *v21; 
  hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *v22; 
  const char *HostString; 
  hkSerialize::InplaceLoad *v24; 
  __int64 v25; 
  hkSerialize::InplaceLoad v26; 
  hkReflect::Var result; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "HavokPhysics_AddPhysicsLibrary");
  if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6654, ASSERT_TYPE_ASSERT, "(physicsLibrary)", "%s\n\tTrying to add a NULL Physics Library", "physicsLibrary") )
    __debugbreak();
  if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6656, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokData)", "%s\n\tTrying to add a Physics Library with NULL data", "physicsLibrary->havokData") )
    __debugbreak();
  if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6657, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokDataSize > 0)", "%s\n\tTrying to add a Physics Library with 0 data size", "physicsLibrary->havokDataSize > 0") )
    __debugbreak();
  if ( physicsLibrary->isBodyQualityList )
  {
    if ( s_havokPhysicsBodyQualityLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6670, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Body Quality library supported", "s_havokPhysicsBodyQualityLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsBodyQualityLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v2, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsBodyQualityList::typeData);
    m_addr = (HavokPhysicsBodyQualityList *)result.m_addr;
    if ( result.m_addr )
    {
      v4 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsBodyQualityList::typeData) )
        m_addr = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v4 = 0;
      m_addr = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsBodyQualityLibrary.list = m_addr;
    if ( !m_addr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6673, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsBodyQualityLibrary.list") )
      __debugbreak();
    v5 = 0;
    m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_data;
    v7 = &m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_size];
    v8 = s_staticBodyQualityIdx;
    if ( m_data != v7 )
    {
      do
      {
        v9 = *m_data;
        if ( *m_data == s_staticBodyQualityCRC )
        {
          v8 = v5;
        }
        else if ( v9 == s_dynamicBodyQualityCRC )
        {
          s_dynamicBodyQualityIdx = v5;
        }
        else
        {
          v10 = s_vehicleBodyQualityIdx;
          if ( v9 == s_vehicleBodyQualityCRC )
            v10 = v5;
          s_vehicleBodyQualityIdx = v10;
        }
        ++v5;
        ++m_data;
      }
      while ( m_data != v7 );
      s_staticBodyQualityIdx = v8;
    }
    if ( (v8 < 0 || v8 >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6700, ASSERT_TYPE_ASSERT, "(s_staticBodyQualityIdx >= 0 && s_staticBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_staticBodyQualityIdx >= 0 && s_staticBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_staticBodyQualityName) )
      __debugbreak();
    if ( (s_dynamicBodyQualityIdx < 0 || s_dynamicBodyQualityIdx >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6701, ASSERT_TYPE_ASSERT, "(s_dynamicBodyQualityIdx >= 0 && s_dynamicBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_dynamicBodyQualityIdx >= 0 && s_dynamicBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_dynamicBodyQualityName) )
      __debugbreak();
    if ( (s_vehicleBodyQualityIdx < 0 || s_vehicleBodyQualityIdx >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6702, ASSERT_TYPE_ASSERT, "(s_vehicleBodyQualityIdx >= 0 && s_vehicleBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_vehicleBodyQualityIdx >= 0 && s_vehicleBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_vehicleBodyQualityName) )
      __debugbreak();
    do
      HavokPhysics_AddBodyQualityLibraryToWorld(&s_havokPhysicsBodyQualityLibrary, (Physics_WorldId)v4++);
    while ( v4 < 8 );
  }
  else if ( physicsLibrary->isMaterialList )
  {
    if ( s_havokPhysicsMaterialLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6712, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Material library supported", "s_havokPhysicsMaterialLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsMaterialLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v11, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMaterialList::typeData);
    v12 = (HavokPhysicsMaterialList *)result.m_addr;
    if ( result.m_addr )
    {
      v13 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMaterialList::typeData) )
        v12 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v13 = 0;
      v12 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsMaterialLibrary.list = v12;
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6715, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMaterialLibrary.list") )
      __debugbreak();
    s_havokPhysicsMaterialLibrary.firstId.m_value = 4;
    s_havokPhysicsMaterialLibrary.lastId.m_value = LOWORD(s_havokPhysicsMaterialLibrary.list->m_materials.m_size) + 3;
    do
      HavokPhysics_AddMaterialLibraryToWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)v13++);
    while ( v13 < 8 );
  }
  else if ( physicsLibrary->isMotionPropertiesList )
  {
    if ( s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6733, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Motion Properties library supported", "s_havokPhysicsMotionPropertiesLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsMotionPropertiesLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v14, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMotionPropertiesList::typeData);
    v15 = (HavokPhysicsMotionPropertiesList *)result.m_addr;
    if ( result.m_addr )
    {
      v16 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMotionPropertiesList::typeData) )
        v15 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v16 = 0;
      v15 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsMotionPropertiesLibrary.list = v15;
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6736, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMotionPropertiesLibrary.list") )
      __debugbreak();
    s_havokPhysicsMotionPropertiesLibrary.firstId.m_value = 5;
    s_havokPhysicsMotionPropertiesLibrary.lastId.m_value = LOWORD(s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) + 4;
    v17 = 0;
    v18 = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_data;
    for ( i = &v18[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size]; v18 != i; ++v18 )
    {
      if ( *v18 == s_staticMotionPropertiesCRC )
      {
        s_staticMotionPropertiesIdx = v17;
      }
      else
      {
        v20 = s_keyframedMotionPropertiesIdx;
        if ( *v18 == s_keyframedMotionPropertiesCRC )
          v20 = v17;
        s_keyframedMotionPropertiesIdx = v20;
      }
      ++v17;
    }
    if ( (s_staticMotionPropertiesIdx < 0 || s_staticMotionPropertiesIdx >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6760, ASSERT_TYPE_ASSERT, "(s_staticMotionPropertiesIdx >= 0 && s_staticMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and couldn't find motion Property%s", "s_staticMotionPropertiesIdx >= 0 && s_staticMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize()", s_staticMotionPropertiesName) )
      __debugbreak();
    if ( (s_keyframedMotionPropertiesIdx < 0 || s_keyframedMotionPropertiesIdx >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6761, ASSERT_TYPE_ASSERT, "(s_keyframedMotionPropertiesIdx >= 0 && s_keyframedMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and couldn't find motion Property%s", "s_keyframedMotionPropertiesIdx >= 0 && s_keyframedMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize()", s_keyframedMotionPropertiesName) )
      __debugbreak();
    s_motionPropertiesAreReorderedForSPGold = 1;
    if ( s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size >= 0xBu )
      goto LABEL_173;
    LODWORD(v25) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6770, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize() >= SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and expected at least %i motion properties from SP gold, but found %i", "!s_motionPropertiesAreReorderedForSPGold || s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize() >= SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", v25, s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) )
      __debugbreak();
    if ( s_motionPropertiesAreReorderedForSPGold )
    {
LABEL_173:
      if ( (unsigned int)s_staticMotionPropertiesIdx >= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6771, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_staticMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and found motion property %s after the last SP gold index", "!s_motionPropertiesAreReorderedForSPGold || s_staticMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", s_staticMotionPropertiesName) )
        __debugbreak();
      if ( s_motionPropertiesAreReorderedForSPGold && (unsigned int)s_keyframedMotionPropertiesIdx >= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6772, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_keyframedMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and found motion property %s after the last SP gold index", "!s_motionPropertiesAreReorderedForSPGold || s_keyframedMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", s_keyframedMotionPropertiesName) )
        __debugbreak();
    }
    do
      HavokPhysics_AddMotionPropertiesLibraryToWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)v16++);
    while ( v16 < 8 );
  }
  else if ( physicsLibrary->isGlobalTypeCompendium )
  {
    if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6784, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
      __debugbreak();
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v21, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&hkReflect::ReflectionOf<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>>::typeData);
    v22 = (hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *)result.m_addr;
    if ( result.m_addr )
    {
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &hkReflect::ReflectionOf<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>>::typeData) )
        v22 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v22 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsGlobalTypeCompendiumTypes = v22;
    if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6786, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", NULL, NULL) )
      __debugbreak();
    if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6789, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
      __debugbreak();
    *(_QWORD *)s_havokPhysicsGlobalTypeCompendiumDataBuffer = 0i64;
    *(_DWORD *)&s_havokPhysicsGlobalTypeCompendiumDataBuffer[8] = 0;
    *(_DWORD *)&s_havokPhysicsGlobalTypeCompendiumDataBuffer[12] = 0x80000000;
    s_havokPhysicsGlobalTypeCompendiumData = (hkArray<char,hkContainerHeapAllocator> *)s_havokPhysicsGlobalTypeCompendiumDataBuffer;
    HostString = hkReflect::TypeCopier::getHostString();
    HavokPhysics_GlobalTypeCompendium_PrepareData(s_havokPhysicsGlobalTypeCompendiumData, s_havokPhysicsGlobalTypeCompendiumTypes, HostString);
    if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6795, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&s_havokPhysicsInPlaceLoadBuffer);
    s_havokPhysicsInPlaceLoad = v24;
    if ( !v24 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6797, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
        __debugbreak();
      v24 = s_havokPhysicsInPlaceLoad;
    }
    HavokPhysics_GlobalTypeCompendium_PrepareInplaceLoad(v24, s_havokPhysicsGlobalTypeCompendiumData);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6804, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Library - type unknown") )
  {
    __debugbreak();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_AddPhysicsSFXAssetInternal
==============
*/
__int64 HavokPhysics_AddPhysicsSFXAssetInternal(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  int v8; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 j; 
  int v12; 
  PhysicsSFXEventAsset *val; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  signed __int64 v17; 
  char v18; 
  __int64 v19; 
  char v20; 
  __int64 v21; 
  bool v22; 
  __int64 v23; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v24; 
  int v25; 
  int v26; 
  int v27; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v28; 
  unsigned __int32 v29; 
  unsigned int key; 
  __int64 v31; 
  hkMemoryAllocator alloc; 

  if ( !physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7009, ASSERT_TYPE_ASSERT, "(physicsSFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsSFXEventAsset", "physicsSFXEventAsset") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7010, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tTrying to add a physics SFXevent asset but the container is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  name = physicsSFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  for ( i = -1; v3; --v3 )
  {
    v5 = *(unsigned __int8 *)name++;
    i = (i >> 8) ^ g_crc32Table[v5 ^ (unsigned __int8)i];
  }
  v6 = ~i;
  HavokPhysics_LockAssetWrite();
  v7 = g_physicsSFXEventAssets;
  v8 = 0;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsSFXEventAssets->m_elem;
    for ( j = 0i64; j <= m_hashMod; ++j )
    {
      if ( m_elem->key != -1 )
        break;
      ++v8;
      ++m_elem;
    }
  }
  v12 = 1;
  if ( v8 <= (int)m_hashMod )
  {
    do
    {
      val = v7->m_elem[v8].val;
      if ( val == physicsSFXEventAsset )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7023, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s with the same pointer already exists!", physicsSFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsSFXEventAssets;
      }
      if ( v7->m_elem[v8].key == v6 )
      {
        v14 = physicsSFXEventAsset->name;
        v15 = 0x7FFFFFFFi64;
        v16 = val->name;
        if ( !physicsSFXEventAsset->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v17 = v14 - v16;
        do
        {
          v18 = v16[v17];
          v19 = v15;
          v20 = *v16++;
          --v15;
          if ( !v19 )
            break;
          if ( v18 != v20 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7028, ASSERT_TYPE_ASSERT, "(I_strcmp( physicsSFXEventAsset->name, testAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( physicsSFXEventAsset->name, testAsset->name ) == 0", physicsSFXEventAsset->name, val->name) )
              __debugbreak();
            break;
          }
        }
        while ( v18 );
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7029, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s already added, but with a different pointer", physicsSFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsSFXEventAssets;
      }
      v21 = v7->m_hashMod;
      v22 = ++v8 <= (int)v21;
      if ( v8 <= (int)v21 )
      {
        v23 = v8;
        v24 = &v7->m_elem[v8];
        do
        {
          if ( v24->key != -1 )
            break;
          ++v8;
          ++v23;
          ++v24;
        }
        while ( v23 <= v21 );
        v22 = v8 <= (int)v21;
      }
    }
    while ( v22 );
  }
  v25 = (unsigned int)hkMemHeapAllocator();
  v26 = v7->m_hashMod;
  v27 = v26;
  if ( 2 * v7->m_numElems > v26 )
  {
    hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::resizeTable(v7, &alloc, v25);
    v26 = v7->m_hashMod;
    v27 = v26;
  }
  v28 = v7->m_elem;
  v29 = v27 & _byteswap_ulong(-1640531535 * v6);
  key = v7->m_elem[v29].key;
  if ( key != -1 )
  {
    while ( key != v6 )
    {
      v29 = v26 & (v29 + 1);
      key = v28[v29].key;
      if ( key == -1 )
        goto LABEL_50;
    }
    v12 = 0;
  }
LABEL_50:
  v7->m_numElems += v12;
  v31 = (int)v29;
  v28[v31].key = v6;
  v7->m_elem[v31].val = physicsSFXEventAsset;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v6;
}

/*
==============
HavokPhysics_AddPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  HavokPhysics_AddPhysicsSFXAssetInternal(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_AddPhysicsVFXAssetInternal
==============
*/
__int64 HavokPhysics_AddPhysicsVFXAssetInternal(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  int v8; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 j; 
  int v12; 
  PhysicsVFXEventAsset *val; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  signed __int64 v17; 
  char v18; 
  __int64 v19; 
  char v20; 
  __int64 v21; 
  bool v22; 
  __int64 v23; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v24; 
  int v25; 
  int v26; 
  int v27; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v28; 
  unsigned __int32 v29; 
  unsigned int key; 
  __int64 v31; 
  hkMemoryAllocator alloc; 

  if ( !physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7173, ASSERT_TYPE_ASSERT, "(physicsVFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsVFXEventAsset", "physicsVFXEventAsset") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7174, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tTrying to Add a physics VFXevent asset but the container is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  name = physicsVFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  for ( i = -1; v3; --v3 )
  {
    v5 = *(unsigned __int8 *)name++;
    i = (i >> 8) ^ g_crc32Table[v5 ^ (unsigned __int8)i];
  }
  v6 = ~i;
  HavokPhysics_LockAssetWrite();
  v7 = g_physicsVFXEventAssets;
  v8 = 0;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsVFXEventAssets->m_elem;
    for ( j = 0i64; j <= m_hashMod; ++j )
    {
      if ( m_elem->key != -1 )
        break;
      ++v8;
      ++m_elem;
    }
  }
  v12 = 1;
  if ( v8 <= (int)m_hashMod )
  {
    do
    {
      val = v7->m_elem[v8].val;
      if ( val == physicsVFXEventAsset )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7187, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s with the same pointer already exists!", physicsVFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsVFXEventAssets;
      }
      if ( v7->m_elem[v8].key == v6 )
      {
        v14 = physicsVFXEventAsset->name;
        v15 = 0x7FFFFFFFi64;
        v16 = val->name;
        if ( !physicsVFXEventAsset->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v17 = v14 - v16;
        do
        {
          v18 = v16[v17];
          v19 = v15;
          v20 = *v16++;
          --v15;
          if ( !v19 )
            break;
          if ( v18 != v20 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7192, ASSERT_TYPE_ASSERT, "(I_strcmp( physicsVFXEventAsset->name, testAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( physicsVFXEventAsset->name, testAsset->name ) == 0", physicsVFXEventAsset->name, val->name) )
              __debugbreak();
            break;
          }
        }
        while ( v18 );
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7193, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s already added, but with a different pointer", physicsVFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsVFXEventAssets;
      }
      v21 = v7->m_hashMod;
      v22 = ++v8 <= (int)v21;
      if ( v8 <= (int)v21 )
      {
        v23 = v8;
        v24 = &v7->m_elem[v8];
        do
        {
          if ( v24->key != -1 )
            break;
          ++v8;
          ++v23;
          ++v24;
        }
        while ( v23 <= v21 );
        v22 = v8 <= (int)v21;
      }
    }
    while ( v22 );
  }
  v25 = (unsigned int)hkMemHeapAllocator();
  v26 = v7->m_hashMod;
  v27 = v26;
  if ( 2 * v7->m_numElems > v26 )
  {
    hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::resizeTable(v7, &alloc, v25);
    v26 = v7->m_hashMod;
    v27 = v26;
  }
  v28 = v7->m_elem;
  v29 = v27 & _byteswap_ulong(-1640531535 * v6);
  key = v7->m_elem[v29].key;
  if ( key != -1 )
  {
    while ( key != v6 )
    {
      v29 = v26 & (v29 + 1);
      key = v28[v29].key;
      if ( key == -1 )
        goto LABEL_50;
    }
    v12 = 0;
  }
LABEL_50:
  v7->m_numElems += v12;
  v31 = (int)v29;
  v28[v31].key = v6;
  v7->m_elem[v31].val = physicsVFXEventAsset;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v6;
}

/*
==============
HavokPhysics_AddPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  HavokPhysics_AddPhysicsVFXAssetInternal(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_AddRigidBodies
==============
*/
void HavokPhysics_AddRigidBodies(HavokPhysicsWorld *world, hknpBodyId *bodies, int bodyCount, bool immediateAdd, bool tryStartDeactivated)
{
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8914, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( bodyCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8916, ASSERT_TYPE_ASSERT, "(bodyCount > 0)", (const char *)&queryFormat, "bodyCount > 0") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, _QWORD, bool))world->world->addBodies)(&world->world->hknpWorldWriter, bodies, (unsigned int)bodyCount, !immediateAdd);
}

/*
==============
HavokPhysics_AddRigidBodyContents
==============
*/
void HavokPhysics_AddRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  _BOOL8 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11932, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11933, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Add RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11938, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics AddRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = !forceCacheRebuild && (*(_BYTE *)(v9 + 68) & 9) == 0;
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _BOOL8))MutableWorld->world->setBodyCollisionFilterInfo)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, (unsigned int)contents | *(_DWORD *)(v9 + 108), v10);
}

/*
==============
HavokPhysics_AddRigidBodyIdToArray
==============
*/
void HavokPhysics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, hknpBodyId bodyId)
{
  hkMemoryAllocator *v4; 
  int m_size; 

  v4 = hkMemHeapAllocator();
  m_size = array->m_size;
  if ( m_size == (array->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v4, array, 4);
    m_size = array->m_size;
  }
  array->m_data[m_size] = bodyId;
  ++array->m_size;
}

/*
==============
HavokPhysics_AddShapeList
==============
*/
HavokPhysicsShapeList *HavokPhysics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  int *m_addr; 
  __int64 v8; 
  int v9; 
  int m_size; 
  __int64 v12; 
  hkSerialize::InplaceLoad v13; 
  hkReflect::Var result; 

  if ( !*rawShapeData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*rawShapeDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v13);
  hkSerialize::InplaceLoad::toVar(v6, &result, *rawShapeData, *rawShapeDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsShapeList::typeData);
  m_addr = (int *)result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsShapeList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v13);
  if ( !m_addr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7588, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  v8 = *((_QWORD *)m_addr + 13);
  if ( v8 != v8 + 24i64 * m_addr[28] )
  {
    do
    {
      v9 = 0;
      m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
      if ( m_size > 0 )
      {
        do
        {
          if ( *(_DWORD *)(v8 + 4) == s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v9] )
            break;
          ++v9;
        }
        while ( v9 < m_size );
      }
      if ( v9 >= m_size )
      {
        LODWORD(v12) = *(_DWORD *)(v8 + 4);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7616, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", "%s\n\tHavokPhysics: Couldn't find material crc %x", "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()", v12) )
          __debugbreak();
      }
      *(_WORD *)(v8 + 8) = s_havokPhysicsMaterialLibrary.firstId.m_value + v9;
      v8 += 24i64;
    }
    while ( v8 != *((_QWORD *)m_addr + 13) + 24i64 * m_addr[28] );
  }
  return (HavokPhysicsShapeList *)m_addr;
}

/*
==============
HavokPhysics_AddShapeReference
==============
*/

void __fastcall HavokPhysics_AddShapeReference(hknpShape *shape)
{
  hkReferencedObject::addReference(shape);
}

/*
==============
HavokPhysics_AddXModelAsset
==============
*/
void HavokPhysics_AddXModelAsset(XModel *xmodel)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v2; 
  hkMemoryAllocator *v3; 
  int m_size; 

  if ( !xmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7775, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tTrying to add a NULL XModel Asset", "xmodel") )
    __debugbreak();
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7778, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Add an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(xmodel) >= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7779, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( xmodel ) < 0)", "%s\n\txmodel %s already exists in debug list", "HavokPhysics_DebugXModelGetIndex( xmodel ) < 0", xmodel->name) )
    __debugbreak();
  v2 = s_havokPhysicsXModels;
  v3 = hkMemHeapAllocator();
  m_size = v2->m_size;
  if ( m_size == (v2->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v3, v2, 8);
    m_size = v2->m_size;
  }
  v2->m_data[m_size] = xmodel;
  ++v2->m_size;
}

/*
==============
HavokPhysics_AddXModelDetailCollisionAsset
==============
*/
void HavokPhysics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  XModelDetailCollision *v1; 
  int *m_addr; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v3; 
  int v4; 
  int m_hashMod; 
  int v6; 
  int v7; 
  unsigned __int32 v8; 
  unsigned __int32 v9; 
  unsigned int v10; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  XModelDetailCollision *key; 
  __int64 v13; 
  __int64 v14; 
  unsigned __int8 *v15; 
  unsigned int i; 
  unsigned __int64 v17; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v18; 
  int v19; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  int v23; 
  unsigned __int64 v24; 
  unsigned __int64 m_size; 
  int v26; 
  int v27; 
  unsigned __int32 v28; 
  unsigned __int32 v29; 
  unsigned int v30; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v31; 
  unsigned __int64 v32; 
  __int64 v33; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v34; 
  hkMemoryAllocator *v35; 
  int v36; 
  int v37; 
  hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *m_data; 
  __int64 v39; 
  hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *v40; 
  int v41; 
  __int64 v42; 
  hkMemoryAllocator *v43; 
  int v44; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *v45; 
  __int64 v46; 
  __int64 v47; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *v48; 
  __int64 v49; 
  __int64 v50; 
  int v51; 
  __int64 v52; 
  __int64 v53; 
  int v54; 
  __int64 v55; 
  const char *v56; 
  hkMemoryAllocator alloc; 
  XModelDetailCollision *v58; 
  hkReflect::Var result; 
  __int64 v60; 
  char dest[256]; 

  v60 = -2i64;
  v1 = detailCollision;
  v58 = detailCollision;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7788, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tTrying to add a NULL physics LOD", "detailCollision") )
    __debugbreak();
  if ( !v1->physicsLODDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7790, ASSERT_TYPE_ASSERT, "(detailCollision->physicsLODDataSize)", "%s\n\tPhysics LOD should not be empty", "detailCollision->physicsLODDataSize") )
    __debugbreak();
  if ( !v1->physicsLODData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !v1->physicsLODDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, v1->physicsLODData, v1->physicsLODDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsXModelLOD::typeData);
  m_addr = (int *)result.m_addr;
  if ( !result.m_addr )
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
    goto LABEL_27;
  }
  if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsXModelLOD::typeData) )
    m_addr = NULL;
  if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
    hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  if ( !m_addr )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7795, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", "%s\n\tCouldn't load XModel Physics LOD %s", "havokPhysicsXModelLOD", v1->name) )
      __debugbreak();
  }
  HavokPhysics_LockAssetWrite();
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7800, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tTrying to Add a physics LOD asset but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v3 = s_havokPhysicsXModelLODs;
  v4 = (unsigned int)hkMemHeapAllocator();
  m_hashMod = v3->m_map.m_hashMod;
  if ( 2 * v3->m_map.m_numElems > m_hashMod )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v3->m_map, (hkMemoryAllocator *)((char *)&alloc.__vftable + 4), v4);
    m_hashMod = v3->m_map.m_hashMod;
  }
  v6 = 1;
  v7 = 1;
  v8 = _byteswap_ulong(-1640531535 * (_DWORD)v1);
  v9 = _byteswap_ulong(-1640531535 * HIDWORD(v1));
  v10 = m_hashMod & (v9 ^ ((v8 >> 2) + v8 + (v9 << 6) - 1640531527));
  m_elem = v3->m_map.m_elem;
  key = (XModelDetailCollision *)v3->m_map.m_elem[v10].key;
  if ( key != (XModelDetailCollision *)-1i64 )
  {
    while ( key != v1 )
    {
      v10 = v3->m_map.m_hashMod & (v10 + 1);
      key = (XModelDetailCollision *)m_elem[v10].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_39;
    }
    v7 = 0;
  }
LABEL_39:
  v3->m_map.m_numElems += v7;
  v13 = (int)v10;
  m_elem[v13].key = (unsigned __int64)v1;
  v3->m_map.m_elem[v13].val = (unsigned __int64)m_addr;
  v14 = 8i64 * m_addr[14];
  v15 = (unsigned __int8 *)*((_QWORD *)m_addr + 6);
  for ( i = -1; v14; --v14 )
    i = (i >> 8) ^ g_crc32Table[*v15++ ^ (unsigned __int64)(unsigned __int8)i];
  v17 = ~i;
  v18 = s_havokPhysicsXModelLODShapeTagLookup;
  v19 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_hashMod;
  if ( v19 <= 0 || (v20 = _byteswap_ulong(-1640531535 * v17), v21 = _byteswap_ulong(0), v22 = v19 & (v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527)), v23 = v22, v24 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v22].key, v24 == -1i64) )
  {
LABEL_45:
    v23 = v19 + 1;
  }
  else
  {
    while ( v24 != v17 )
    {
      v22 = v19 & (v22 + 1);
      v23 = v22;
      v24 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v22].key;
      if ( v24 == -1i64 )
        goto LABEL_45;
    }
  }
  if ( v23 > v19 )
  {
    LODWORD(alloc.__vftable) = -2147220992;
    m_size = (unsigned int)g_havokPhysicsXModelLODShapeTagDatas->m_size;
    v26 = (unsigned int)hkMemHeapAllocator();
    v27 = v18->m_map.m_hashMod;
    if ( 2 * v18->m_map.m_numElems > v27 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v18->m_map, &alloc, v26);
      v27 = v18->m_map.m_hashMod;
    }
    v28 = _byteswap_ulong(-1640531535 * v17);
    v29 = _byteswap_ulong(-1640531535 * HIDWORD(v17));
    v30 = v27 & (v29 ^ ((v28 >> 2) + v28 + (v29 << 6) - 1640531527));
    v31 = v18->m_map.m_elem;
    v32 = v18->m_map.m_elem[v30].key;
    if ( v32 != -1i64 )
    {
      while ( v32 != v17 )
      {
        v30 = v18->m_map.m_hashMod & (v30 + 1);
        v32 = v31[v30].key;
        if ( v32 == -1i64 )
          goto LABEL_55;
      }
      v6 = 0;
    }
LABEL_55:
    v18->m_map.m_numElems += v6;
    v33 = (int)v30;
    v31[v33].key = v17;
    v18->m_map.m_elem[v33].val = m_size;
    v34 = g_havokPhysicsXModelLODShapeTagDatas;
    v35 = hkMemHeapAllocator();
    v36 = v34->m_size;
    v37 = v36;
    if ( v36 == (v34->m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v35, v34, 16);
      v36 = v34->m_size;
      v37 = v36;
    }
    m_data = v34->m_data;
    v39 = (__int64)&v34->m_data[v36];
    if ( v39 )
    {
      *(_QWORD *)v39 = 0i64;
      *(_DWORD *)(v39 + 8) = 0;
      *(_DWORD *)(v39 + 12) = 0x80000000;
      v37 = v34->m_size;
      m_data = v34->m_data;
    }
    v40 = &m_data[v37];
    v34->m_size = v37 + 1;
    v41 = m_addr[14];
    v42 = *((_QWORD *)m_addr + 6);
    v43 = hkMemHeapAllocator();
    if ( (v40->m_capacityAndFlags & 0x3FFFFFFF) < v41 )
      hkArrayUtil::_reserve(v43, v40, v41, 8);
    v44 = v41;
    if ( v41 > v40->m_size )
      v44 = v40->m_size;
    v45 = v40->m_data;
    if ( v44 > 0 )
    {
      v46 = v42 - (_QWORD)v45;
      v47 = v44;
      do
      {
        *v45 = *(HavokPhysicsXModelLOD::XModelCollisionTagData *)((char *)v45 + v46);
        ++v45;
        --v47;
      }
      while ( v47 );
      v45 = v40->m_data;
    }
    v48 = &v45[v44];
    v49 = v41 - v44;
    if ( v41 - v44 > 0 )
    {
      v50 = v42 + 8i64 * v44 - (_QWORD)v48;
      do
      {
        if ( v48 )
          *v48 = *(HavokPhysicsXModelLOD::XModelCollisionTagData *)((char *)v48 + v50);
        ++v48;
        --v49;
      }
      while ( v49 );
    }
    v40->m_size = v41;
  }
  else
  {
    m_size = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v23].val;
  }
  v51 = 0;
  if ( m_addr[2] > 0 )
  {
    v52 = 0i64;
    do
    {
      v53 = *(_QWORD *)(v52 + *(_QWORD *)m_addr);
      if ( (*(_BYTE *)(v53 + 24) & 4) == 0 )
        v53 = 0i64;
      if ( !v53 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7819, ASSERT_TYPE_ASSERT, "(compositeShape)", (const char *)&queryFormat, "compositeShape") )
        __debugbreak();
      *(_DWORD *)(v53 + 56) = m_size;
      ++v51;
      v52 += 8i64;
    }
    while ( v51 < m_addr[2] );
    v1 = v58;
  }
  v54 = 0;
  if ( m_addr[6] > 0 )
  {
    v55 = 0i64;
    do
    {
      v56 = (const char *)(*(_QWORD *)(v55 + *((_QWORD *)m_addr + 2)) & 0xFFFFFFFFFFFFFFFEui64);
      Core_strcpy(dest, 0x100ui64, v56);
      I_strlwr(dest);
      if ( !SL_FindString(dest) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7846, ASSERT_TYPE_ASSERT, "(scrName != ( static_cast< scr_string_t >( 0 ) ))", "%s\n\tCouldn't find script string for bone %s in detailCollision %s", "scrName != NULL_SCR_STRING", v56, v1->name) )
        __debugbreak();
      ++v54;
      v55 += 8i64;
    }
    while ( v54 < m_addr[6] );
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_AllocateBroadphaseCollisionQueryResult
==============
*/
HavokPhysics_BroadphaseCollisionQueryResult *HavokPhysics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  hkMemoryRouter *Value; 
  HavokPhysics_BroadphaseCollisionQueryResult *result; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  result = (HavokPhysics_BroadphaseCollisionQueryResult *)Value->m_heap->blockAlloc(Value->m_heap, 48i64);
  if ( result )
  {
    result->m_propertyBag.m_bag = NULL;
    result->__vftable = (HavokPhysics_BroadphaseCollisionQueryResult_vtbl *)&HavokPhysics_BroadphaseCollisionQueryResult::`vftable';
    *(_DWORD *)&result->m_memSizeAndFlags = 0x1FFFF;
    result->m_hits.m_data = NULL;
    result->m_hits.m_size = 0;
    result->m_hits.m_capacityAndFlags = 0x80000000;
    result->m_worldId = worldId;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13561, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result = NULL;
    MEMORY[0x28] = worldId;
  }
  return result;
}

/*
==============
HavokPhysics_AllocateCollisionQueryResult
==============
*/
HavokPhysics_CollisionQueryResult *HavokPhysics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  hkMemoryRouter *Value; 
  __int64 v5; 
  __int64 v6; 
  hknpCollisionQueryCollector *v7; 
  hkMemoryRouter *v8; 
  HavokPhysicsHitCollector *v9; 
  __int64 v10; 
  hkMemoryRouter *v11; 
  HavokPhysicsAllHitsCollector *v12; 
  hknpCollisionQueryCollector *v13; 
  hkMemoryRouter *v14; 
  HavokPhysicsClosestHitCollector *v15; 
  hknpCollisionQueryCollector *v16; 
  hkMemoryRouter *v17; 
  HavokPhysicsAnyHitCollector *v18; 
  hknpCollisionQueryCollector *v19; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (__int64)Value->m_heap->blockAlloc(Value->m_heap, 40i64);
  v6 = v5;
  v7 = NULL;
  if ( v5 )
  {
    *(_QWORD *)(v5 + 8) = 0i64;
    *(_DWORD *)(v5 + 16) = 0x1FFFF;
    *(_QWORD *)v5 = &HavokPhysics_CollisionQueryResult::`vftable';
  }
  else
  {
    v6 = 0i64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13590, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result", -2i64) )
      __debugbreak();
  }
  *(_DWORD *)(v6 + 32) = worldId;
  v8 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v8 )
    v8 = hkMemoryRouter::s_fallbackRouter;
  v9 = (HavokPhysicsHitCollector *)v8->m_heap->blockAlloc(v8->m_heap, 144i64);
  if ( v9 )
    HavokPhysicsHitCollector::HavokPhysicsHitCollector(v9);
  else
    v10 = 0i64;
  *(_QWORD *)(v6 + 24) = v10;
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13598, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  switch ( type )
  {
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY:
      v17 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v17 )
        v17 = hkMemoryRouter::s_fallbackRouter;
      v18 = (HavokPhysicsAnyHitCollector *)v17->m_heap->blockAlloc(v17->m_heap, 176i64);
      if ( v18 )
      {
        HavokPhysicsAnyHitCollector::HavokPhysicsAnyHitCollector(v18, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v19;
      }
LABEL_34:
      if ( v7 )
        goto LABEL_37;
      goto LABEL_35;
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST:
      v14 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v14 )
        v14 = hkMemoryRouter::s_fallbackRouter;
      v15 = (HavokPhysicsClosestHitCollector *)v14->m_heap->blockAlloc(v14->m_heap, 176i64);
      if ( v15 )
      {
        HavokPhysicsClosestHitCollector::HavokPhysicsClosestHitCollector(v15, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v16;
      }
      goto LABEL_34;
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL:
      v11 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v11 )
        v11 = hkMemoryRouter::s_fallbackRouter;
      v12 = (HavokPhysicsAllHitsCollector *)v11->m_heap->blockAlloc(v11->m_heap, 1216i64);
      if ( v12 )
      {
        HavokPhysicsAllHitsCollector::HavokPhysicsAllHitsCollector(v12, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v13;
      }
      goto LABEL_34;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13624, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics: Invalid type for collector") )
    __debugbreak();
LABEL_35:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13630, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
LABEL_37:
  HavokPhysicsHitCollector::SetCollector(*(HavokPhysicsHitCollector **)(v6 + 24), type, v7);
  return (HavokPhysics_CollisionQueryResult *)v6;
}

/*
==============
HavokPhysics_AllocateIgnoreBodies
==============
*/
HavokPhysics_IgnoreBodies *HavokPhysics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  hkMemoryRouter *Value; 
  HavokPhysics_IgnoreBodies *v5; 
  __int64 v6; 
  __int64 v7; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (HavokPhysics_IgnoreBodies *)Value->m_heap->blockAlloc(Value->m_heap, 56i64);
  if ( v5 )
  {
    HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(v5, minEntities, minBodies);
    v7 = v6;
  }
  else
  {
    v7 = 0i64;
  }
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13694, ASSERT_TYPE_ASSERT, "(ignoreBodies)", (const char *)&queryFormat, "ignoreBodies", -2i64) )
    __debugbreak();
  return (HavokPhysics_IgnoreBodies *)v7;
}

/*
==============
HavokPhysics_AntilagRestoreInstanceTo
==============
*/
void HavokPhysics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation)
{
  __int64 v4; 
  hknpWorld *world; 
  unsigned int v10; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  hknpBodyId result; 
  int NumRigidBodys; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v31; 
  hkTransformf transform; 
  hkTransformf aTb; 
  hkTransformf v34; 

  v4 = instanceId;
  _RBX = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12375, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v4 == -1 )
  {
    LODWORD(v24) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12376, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v24) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v24) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12381, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v24) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v31.m_rotation, hkOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rbp+120h+var_110], xmm0
  }
  v10 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v4);
  if ( NumRigidBodys > 0 )
  {
    do
    {
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v24) )
          __debugbreak();
      }
      if ( (_DWORD)v4 == -1 )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v24) )
          __debugbreak();
      }
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      if ( !ConstWorld->world )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v24) )
          __debugbreak();
      }
      p_instanceManager = &ConstWorld->instanceManager;
      if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v4 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      if ( v10 >= p_instanceManager->buffer[v4].bodies.m_size )
      {
        LODWORD(v25) = worldId;
        LODWORD(v24) = v10;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v24, v25) )
          __debugbreak();
      }
      HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v4, v10);
      m_serialAndIndex = result.m_serialAndIndex;
      if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        LODWORD(v26) = worldId;
        LODWORD(v25) = v4;
        LODWORD(v24) = v10;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12398, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v24, v25, v26) )
          __debugbreak();
      }
      if ( !v10 )
      {
        _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovups xmmword ptr [rsp+220h+t.m_rotation.baseclass_0.m_col0.m_quad], xmm0
          vmovups xmm1, xmmword ptr [rax+10h]
          vmovups xmmword ptr [rsp+220h+t.m_rotation.baseclass_0.m_col1.m_quad], xmm1
          vmovups xmm0, xmmword ptr [rax+20h]
          vmovups xmmword ptr [rbp+120h+t.m_rotation.baseclass_0.m_col2.m_quad], xmm0
          vmovups xmm1, xmmword ptr [rax+30h]
          vmovups xmmword ptr [rbp+120h+t.m_translation.m_quad], xmm1
        }
        hkTransformf::setInverse(&aTb, &t);
      }
      _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rbp+120h+bTc.m_rotation.baseclass_0.m_col0.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rax+10h]
        vmovups xmmword ptr [rbp+120h+bTc.m_rotation.baseclass_0.m_col1.m_quad], xmm1
        vmovups xmm0, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbp+120h+bTc.m_rotation.baseclass_0.m_col2.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rax+30h]
        vmovups xmmword ptr [rbp+120h+bTc.m_translation.m_quad], xmm1
      }
      hkTransformf::setMul(&v34, &aTb, &bTc);
      hkTransformf::setMul(&transform, &v31, &v34);
      hkRotationImpl<float>::renormalize(&transform.m_rotation);
      hknpBody::setTransform(&world->m_bodyManager.m_bodies.m_objects.m_data[m_serialAndIndex & 0xFFFFFF].m_pod, &transform);
      ++v10;
    }
    while ( (int)v10 < NumRigidBodys );
  }
}

/*
==============
HavokPhysics_AntilagWarpInstanceTo
==============
*/
__int64 HavokPhysics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, hkVector4f *hkRestorePosition, hkQuaternionf *hkRestoreOrientation)
{
  __int64 v10; 
  hknpWorld *world; 
  unsigned __int8 v13; 
  unsigned int v14; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  hkQuaternionf *v25; 
  hknpWorld *v26; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  __int64 v33; 
  __int64 v35; 
  __int64 v36; 
  __int64 v37; 
  hknpBodyId ids; 
  hknpBodyId result; 
  float zero; 
  int NumRigidBodys; 
  hkVector4f *v42; 
  hkQuaternionf *v43; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v46; 
  hkTransformf transform; 
  hkTransformf aTb; 
  hkTransformf v49; 

  v42 = hkRestorePosition;
  _RBX = hkPosition;
  v43 = hkRestoreOrientation;
  v10 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12295, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v10 == -1 )
  {
    LODWORD(v35) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12296, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v35) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v35) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12301, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v35) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v46.m_rotation, hkOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rbp+140h+var_120], xmm0
  }
  v13 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v10);
  v14 = 0;
  if ( NumRigidBodys <= 0 )
    return 0i64;
  __asm
  {
    vmovaps [rsp+240h+var_40], xmm6
    vmovss  xmm6, cs:__real@3a83126f
  }
  do
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v35) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v35) )
        __debugbreak();
    }
    if ( (_DWORD)v10 == -1 )
    {
      LODWORD(v35) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v35) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v35) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v35) )
        __debugbreak();
    }
    p_instanceManager = &ConstWorld->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v10 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v14 >= p_instanceManager->buffer[v10].bodies.m_size )
    {
      LODWORD(v36) = worldId;
      LODWORD(v35) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v35, v36) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v10, v14);
    ids.m_serialAndIndex = result.m_serialAndIndex;
    if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v37) = worldId;
      LODWORD(v36) = v10;
      LODWORD(v35) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12319, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v35, v36, v37) )
        __debugbreak();
    }
    if ( !v14 )
    {
      _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, ids.m_serialAndIndex);
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rsp+240h+t.m_rotation.baseclass_0.m_col0.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rax+10h]
        vmovups xmmword ptr [rbp+140h+t.m_rotation.baseclass_0.m_col1.m_quad], xmm1
        vmovups xmm0, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbp+140h+t.m_rotation.baseclass_0.m_col2.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rax+30h]
        vmovups xmmword ptr [rbp+140h+t.m_translation.m_quad], xmm1
      }
      hkTransformf::setInverse(&aTb, &t);
      __asm { vmovss  [rsp+240h+zero], xmm6 }
      if ( hkTransformf::isApproximatelyEqual(&t, &v46, &zero) )
        break;
      _RAX = v42;
      __asm { vmovups xmm0, xmmword ptr [rbp+140h+t.m_translation.m_quad] }
      v25 = v43;
      __asm { vmovups xmmword ptr [rax], xmm0 }
      hkQuaternionf::set(v25, &t.m_rotation);
    }
    v26 = HavokPhysics_GetMutableWorld(worldId)->world;
    _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, ids.m_serialAndIndex);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbp+140h+bTc.m_rotation.baseclass_0.m_col0.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rax+10h]
      vmovups xmmword ptr [rbp+140h+bTc.m_rotation.baseclass_0.m_col1.m_quad], xmm1
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rbp+140h+bTc.m_rotation.baseclass_0.m_col2.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rax+30h]
      vmovups xmmword ptr [rbp+140h+bTc.m_translation.m_quad], xmm1
    }
    hkTransformf::setMul(&v49, &aTb, &bTc);
    hkTransformf::setMul(&transform, &v46, &v49);
    hkRotationImpl<float>::renormalize(&transform.m_rotation);
    hknpBody::setTransform(&v26->m_bodyManager.m_bodies.m_objects.m_data[ids.m_serialAndIndex & 0xFFFFFF].m_pod, &transform);
    UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(world);
    hknpBroadPhase::markBodiesAntilag(UndecoratedBroadPhase, &ids, 1, 4);
    ++v14;
    v13 = 1;
  }
  while ( (int)v14 < NumRigidBodys );
  v33 = v13;
  __asm { vmovaps xmm6, [rsp+240h+var_40] }
  return v33;
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/
void HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  hknpWorld *world; 
  __int64 v12; 
  __int64 v22; 
  __int128 v24; 

  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  _R14 = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12859, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12860, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply angular impulse to a Body with invalid body id for world %i", "bodyId.isValid()", v22) )
      __debugbreak();
  }
  __asm
  {
    vbroadcastss xmm0, [rsp+88h+magnitude]
    vmulps  xmm6, xmm0, xmmword ptr [rbp+0]
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  v12 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  ((void (__fastcall *)(hknpWorldReader *, _QWORD))world->getMotion)(&world->hknpWorldReader, *(unsigned int *)(v12 + 64));
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vsubps  xmm2, xmm0, xmmword ptr [rax]
    vshufps xmm1, xmm2, xmm2, 0C9h ; ''
    vshufps xmm0, xmm6, xmm6, 0C9h ; ''
    vmulps  xmm2, xmm0, xmm2
    vmulps  xmm3, xmm1, xmm6
    vsubps  xmm1, xmm2, xmm3
    vshufps xmm0, xmm1, xmm1, 0C9h ; ''
    vmovups [rsp+88h+var_48], xmm0
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int128 *, _QWORD))world->applyBodyAngularImpulse)(&world->hknpWorldWriter, bodyId.m_serialAndIndex, &v24, 0i64);
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkTorqueVector, double magnitude)
{
  hknpWorldWriter *v11; 
  __int64 v13; 
  __int128 v15; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12884, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12885, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply angular impulse to a Body with invalid body id for world %i", "bodyId.isValid()", v13) )
      __debugbreak();
  }
  __asm
  {
    vmovaps xmm0, xmm6
    vshufps xmm0, xmm0, xmm0, 0
    vmulps  xmm0, xmm0, xmmword ptr [rsi]
  }
  v11 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  __asm { vmovups [rsp+78h+var_38], xmm0 }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int128 *, _QWORD))v11->applyBodyAngularImpulse)(v11, bodyId.m_serialAndIndex, &v15, 0i64);
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
HavokPhysics_ApplyImpulse
==============
*/
void HavokPhysics_ApplyImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  hknpWorldWriter *v10; 
  __int64 v11; 
  __int128 v13; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12819, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12820, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply Fimpulseorce to a Body with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  __asm
  {
    vbroadcastss xmm0, [rsp+78h+magnitude]
    vmulps  xmm0, xmm0, xmmword ptr [rsi]
  }
  v10 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  __asm { vmovups [rsp+78h+var_38], xmm0 }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int128 *, const hkVector4f *, _DWORD))v10->applyBodyImpulseAt)(v10, bodyId.m_serialAndIndex, &v13, hkPosition, 0);
}

/*
==============
HavokPhysics_ApplyLinearImpulse
==============
*/

void __fastcall HavokPhysics_ApplyLinearImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkDirection, double magnitude)
{
  hknpWorldWriter *v11; 
  __int64 v13; 
  __int128 v15; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12839, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12840, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply Fimpulseorce to a Body with invalid body id for world %i", "bodyId.isValid()", v13) )
      __debugbreak();
  }
  __asm
  {
    vmovaps xmm0, xmm6
    vshufps xmm0, xmm0, xmm0, 0
    vmulps  xmm0, xmm0, xmmword ptr [rsi]
  }
  v11 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  __asm { vmovups [rsp+78h+var_38], xmm0 }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int128 *, _QWORD))v11->applyBodyLinearImpulse)(v11, bodyId.m_serialAndIndex, &v15, 0i64);
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
HavokPhysics_AreDetailModelsInterchangeable
==============
*/
bool HavokPhysics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  XModelDetailCollision *detailCollision; 

  _RBX = detailModelB;
  _RDI = detailModelA;
  if ( !detailModelA && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9944, ASSERT_TYPE_ASSERT, "(detailModelA)", (const char *)&queryFormat, "detailModelA") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9945, ASSERT_TYPE_ASSERT, "(detailModelB)", (const char *)&queryFormat, "detailModelB") )
    __debugbreak();
  detailCollision = _RBX->detailCollision;
  if ( _RDI->detailCollision != detailCollision )
    return 0;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vucomiss xmm0, dword ptr [rdi+28h]
  }
  return _RDI->detailCollision == detailCollision;
}

/*
==============
HavokPhysics_BatchRaycast
==============
*/
void HavokPhysics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const hkVector4f *starts, const hkVector4f *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  HavokPhysics_CollisionQueryResult **v14; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  int v20; 
  int v21; 
  unsigned int v22; 
  const hkVector4f *v25; 
  hkMemoryAllocator *v27; 
  int m_size; 
  hknpCollisionQueryCollector *Collector; 
  hkMemoryAllocator *v44; 
  int v45; 
  hkMonitorStream *Value; 
  const hknpWorldReader *v47; 
  const hknpWorldReader *v48; 
  hkMonitorStream *v49; 
  hkMemoryAllocator *v50; 
  hkMemoryAllocator *v51; 
  __int64 v55; 
  hkArrayBase<hknpCollisionQueryCollector *> collectorPtrsOut; 
  hkArrayBase<hkcdRay> array; 
  hknpCollisionQuery query; 
  __int64 v59; 
  int v60; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_QueryPhaseSelection phaseSelection; 
  char v65; 
  void *retaddr; 
  char *v68; 
  HavokPhysics_CollisionQueryResult **resultsa; 

  _RAX = &retaddr;
  v59 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R14 = starts;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14014, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14015, ASSERT_TYPE_ASSERT, "(starts)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid starts", "starts") )
    __debugbreak();
  if ( !ends && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14016, ASSERT_TYPE_ASSERT, "(ends)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid ends", "ends") )
    __debugbreak();
  v14 = results;
  if ( !results && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14017, ASSERT_TYPE_ASSERT, "(results)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid results", "results") )
    __debugbreak();
  _R15 = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14018, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( numRays <= 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14019, ASSERT_TYPE_ASSERT, "(numRays > 1)", "%s\n\tHavok Physics: Trying to fire BatchRaycast with too few rays", "numRays > 1") )
    __debugbreak();
  if ( numRays > 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14020, ASSERT_TYPE_ASSERT, "(numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS)", "%s\n\tHavok Physics: Trying to fire BatchRaycast with too many rays", "numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS") )
    __debugbreak();
  resultsa = (HavokPhysics_CollisionQueryResult **)HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+47h+var_68], xmm0
  }
  ignoreBodies = extendedData->ignoreBodies;
  characterProxyType = extendedData->characterProxyType;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+14h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+47h+var_80], xmm1
  }
  phaseSelection = extendedData->phaseSelection;
  query.m_broadPhaseFilterMask = -5;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = (const hknpCollisionFilter *)*resultsa;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v60;
  *(_DWORD *)query.m_levelOfDetail = 0;
  insideHitType = extendedData->insideHitType;
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v20 = 4;
  }
  else
  {
    v20 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v20 = 8;
  }
  v21 = v20 | 1;
  if ( !extendedData->disableBackFacingTriangleHits )
    v21 = v20;
  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  collectorPtrsOut.m_data = NULL;
  collectorPtrsOut.m_size = 0;
  collectorPtrsOut.m_capacityAndFlags = 0x80000000;
  v22 = 0;
  if ( numRays )
  {
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vmovups xmm7, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
    }
    v25 = _R14;
    _R12 = (char *)((char *)ends - (char *)_R14);
    v68 = _R12;
    do
    {
      v27 = hkMemHeapAllocator();
      m_size = array.m_size;
      if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v27, &array, 48);
        m_size = array.m_size;
      }
      _RCX = &array.m_data[m_size];
      array.m_size = m_size + 1;
      __asm
      {
        vmovups xmm0, xmmword ptr [r12+r14]
        vsubps  xmm1, xmm0, xmmword ptr [r14]
        vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
        vcmpeqps xmm0, xmm6, xmm2
        vandnps xmm4, xmm0, xmm2
        vcmpeqps xmm0, xmm6, xmm4
        vrcpps  xmm3, xmm4
        vmulps  xmm2, xmm3, xmm4
        vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
        vsubps  xmm2, xmm1, xmm2
        vmulps  xmm3, xmm2, xmm3
        vblendvps xmm1, xmm3, xmm7, xmm0
        vmovups xmmword ptr [rcx+10h], xmm4
        vmovups xmmword ptr [rcx+20h], xmm1
        vmovups xmm0, xmmword ptr [r14]
        vmovups xmmword ptr [rcx], xmm0
      }
      if ( !(*v14)->m_collector )
      {
        LODWORD(v55) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14064, ASSERT_TYPE_ASSERT, "(results[rayIdx]->m_collector)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid collector %i", "results[rayIdx]->m_collector", v55) )
          __debugbreak();
      }
      HavokPhysicsHitCollector::SetBatchRaycastDataForModifiers((*v14)->m_collector, v25, (const hkVector4f *)((char *)v25 + (_QWORD)_R12), &query, (hkFlags<enum hkcdRayQueryFlags::Enum,unsigned int>)v21);
      HavokPhysicsHitCollector::EnableInsideHits((*v14)->m_collector, extendedData->collectInsideHits);
      Collector = HavokPhysicsHitCollector::GetCollector((*v14)->m_collector);
      if ( !Collector )
      {
        LODWORD(v55) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14070, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid havok collector %i", "collector", v55) )
          __debugbreak();
      }
      v44 = hkMemHeapAllocator();
      v45 = collectorPtrsOut.m_size;
      if ( collectorPtrsOut.m_size == (collectorPtrsOut.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v44, &collectorPtrsOut, 8);
        v45 = collectorPtrsOut.m_size;
      }
      collectorPtrsOut.m_data[v45] = Collector;
      ++collectorPtrsOut.m_size;
      ++v22;
      ++v25;
      ++_R14;
      ++v14;
      _R12 = v68;
    }
    while ( v22 < numRays );
  }
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtBatchRaycast_HK");
  v47 = (const hknpWorldReader *)resultsa[3];
  v48 = v47 + 4;
  if ( !v47 )
    v48 = NULL;
  hknpBatchQueryUtil::castBatch(v48, &array, &query, (hkFlags<enum hkcdRayQueryFlags::Enum,unsigned int>)v21, &collectorPtrsOut);
  v49 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v49 )
    hkMonitorStream::timerEnd(v49, "Et");
  v50 = hkMemHeapAllocator();
  collectorPtrsOut.m_size = 0;
  if ( collectorPtrsOut.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v50, collectorPtrsOut.m_data, 8, collectorPtrsOut.m_capacityAndFlags & 0x3FFFFFFF);
  collectorPtrsOut.m_data = NULL;
  collectorPtrsOut.m_capacityAndFlags = 0x80000000;
  v51 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v51, array.m_data, 48, array.m_capacityAndFlags & 0x3FFFFFFF);
  _R11 = &v65;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_BroadphaseBodiesChanged
==============
*/
void HavokPhysics_BroadphaseBodiesChanged(int worldId)
{
  void (__fastcall *v1)(Physics_WorldId); 

  v1 = s_havokPhysicsBroadphaseBodiesChangedFns[worldId];
  if ( v1 )
    v1((Physics_WorldId)worldId);
}

/*
==============
HavokPhysics_CalcRigidBodyShapeAABBWorld
==============
*/
void HavokPhysics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11711, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying toGet the AABB Shape with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11712, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get the AABB Shape with invalid body id for world %i", "bodyId.isValid()", v9) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11717, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v8 = *(_QWORD *)(*(_QWORD *)(v7 + 152) + 8i64 * (*(_BYTE *)(v7 + 147) & 7));
  (*(void (__fastcall **)(__int64, __int64, hkAabb *))(*(_QWORD *)v8 + 32i64))(v8, v7, aabb);
}

/*
==============
HavokPhysics_CalcShapeRadius
==============
*/
void HavokPhysics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  hknpShape_vtbl *v5; 
  __int128 v8; 
  __int128 v9; 

  _RDI = radiusOut;
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14245, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to calculate shape radius with an invalid shape", "shape") )
    __debugbreak();
  v5 = shape->__vftable;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups [rsp+68h+var_38], xmm0
  }
  v5->calcBoundingRadius((hknpShape *)shape, (const hkVector4f *)&v8, (hkSimdFloat32 *)&v9);
  __asm
  {
    vmovaps xmm0, [rsp+68h+var_28]
    vmovss  dword ptr [rdi], xmm0
  }
}

/*
==============
HavokPhysics_CalculateMassProperties
==============
*/

void __fastcall HavokPhysics_CalculateMassProperties(hknpShape *shape, double mass, hkMassProperties *massProperties)
{
  hkReferencedObject v5; 
  int v6; 
  __int64 v9; 
  hkDiagonalizedMassProperties v10; 

  v9 = -2i64;
  v5.m_propertyBag.m_bag = NULL;
  *(_DWORD *)&v5.m_memSizeAndFlags = 0x1FFFF;
  v5.__vftable = (hkReferencedObject_vtbl *)hknpShape::MassConfig::`vftable';
  __asm
  {
    vmovss  [rsp+0A8h+var_68], xmm1
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+0A8h+var_6C], xmm0
  }
  v6 = 1;
  shape->buildMassProperties(shape, (const hknpShape::MassConfig *)&v5, &v10);
  hkDiagonalizedMassProperties::unpack(&v10, massProperties);
  hkReferencedObject::~hkReferencedObject(&v5);
}

/*
==============
HavokPhysics_CheckWorldReplayDeterminism
==============
*/
void HavokPhysics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  ;
}

/*
==============
HavokPhysics_ClearAntilagFlags
==============
*/
void HavokPhysics_ClearAntilagFlags(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpBroadPhase *UndecoratedBroadPhase; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to ClearAntilagFlags with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(MutableWorld->world);
  hknpBroadPhase::clearAntilagBodies(UndecoratedBroadPhase);
}

/*
==============
HavokPhysics_ClearShapeCache
==============
*/
void HavokPhysics_ClearShapeCache(void)
{
  int v0; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v1; 
  __int64 v2; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v3; 
  int v4; 
  __int64 v5; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  hkReferencedObject *val; 
  unsigned __int16 m_refCount; 
  __int64 v10; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v11; 
  int v12; 
  int v13; 
  __int64 v14; 
  signed __int32 v15[8]; 

  v0 = 27;
  v1 = &s_havokPhysicsShapeCaches[27];
  v2 = 27i64;
  do
  {
    if ( !*v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15837, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId])", "%s\n\tHavokPhysics_ClearShapeCache: the cache should be valid", "s_havokPhysicsShapeCaches[threadId]") )
      __debugbreak();
    v3 = *v1;
    v4 = 0;
    v5 = 0i64;
    m_hashMod = (*v1)->m_map.m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = v3->m_map.m_elem;
      do
      {
        if ( m_elem->key != -1i64 )
          break;
        ++v4;
        ++v5;
        ++m_elem;
      }
      while ( v5 <= m_hashMod );
    }
    if ( v4 <= (int)m_hashMod )
    {
      do
      {
        val = (hkReferencedObject *)v3->m_map.m_elem[v4].val;
        if ( !val || (_InterlockedOr(v15, 0), m_refCount = val->m_refCount, _InterlockedOr(v15, 0), m_refCount != 1) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15843, ASSERT_TYPE_ASSERT, "(shape && shape->getReferenceCount() == 1)", "%s\n\tHavokPhysics_ClearShapeCache: havok physics shape cache entries should have a single reference only", "shape && shape->getReferenceCount() == 1") )
            __debugbreak();
        }
        hkReferencedObject::removeReference(val);
        v3 = *v1;
        ++v4;
        v10 = (*v1)->m_map.m_hashMod;
        if ( v4 > (int)v10 )
          break;
        v5 = v4;
        v11 = &v3->m_map.m_elem[v4];
        do
        {
          if ( v11->key != -1i64 )
            break;
          ++v4;
          ++v5;
          ++v11;
        }
        while ( v5 <= v10 );
      }
      while ( v4 <= (int)v10 );
    }
    v12 = v3->m_map.m_hashMod;
    if ( v12 )
    {
      v13 = v12 + 1;
      v14 = v13;
      if ( v13 > 0 )
      {
        v5 = 0i64;
        do
        {
          if ( *(unsigned __int64 *)((char *)&v3->m_map.m_elem->key + v5) != -1i64 )
            *(unsigned __int64 *)((char *)&v3->m_map.m_elem->key + v5) = -1i64;
          v5 += 16i64;
          --v14;
        }
        while ( v14 );
      }
    }
    v3->m_map.m_numElems &= 0x80000000;
    if ( v1 >= (hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **)s_havokPhysicsShapeCachesDisabled )
    {
      j___report_rangecheckfailure(v5);
      JUMPOUT(0x141B1AA2Ei64);
    }
    s_havokPhysicsShapeCachesDisabled[v2--] = 0;
    --v1;
    --v0;
  }
  while ( v0 >= 0 );
}

/*
==============
HavokPhysics_CopyPhysicsAsset
==============
*/
void HavokPhysics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  int v9; 
  PhysicsAsset *key; 
  int v11; 
  unsigned __int32 v12; 
  unsigned __int32 v13; 
  unsigned int v14; 
  int v15; 
  PhysicsAsset *v16; 
  unsigned __int64 val; 
  int v18; 
  int v19; 
  int v20; 
  unsigned __int32 v21; 
  unsigned __int32 v22; 
  int v23; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v25; 
  PhysicsAsset *v26; 
  __int64 v27; 
  hkMemoryAllocator alloc; 

  HavokPhysics_LockAssetWrite();
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7565, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7566, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7567, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)from), v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = m_hashMod + 1;
  }
  else
  {
    while ( key != from )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7570, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( it ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( it )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  v11 = v4->m_map.m_hashMod;
  if ( v11 <= 0 || (v12 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v13 = _byteswap_ulong(-1640531535 * (_DWORD)to), v14 = v11 & (v12 ^ ((v13 >> 2) + v13 + (v12 << 6) - 1640531527)), v15 = v14, v16 = (PhysicsAsset *)v4->m_map.m_elem[v14].key, v16 == (PhysicsAsset *)-1i64) )
  {
LABEL_24:
    v15 = v11 + 1;
  }
  else
  {
    while ( v16 != to )
    {
      v14 = v11 & (v14 + 1);
      v15 = v14;
      v16 = (PhysicsAsset *)v4->m_map.m_elem[v14].key;
      if ( v16 == (PhysicsAsset *)-1i64 )
        goto LABEL_24;
    }
  }
  if ( v15 <= v11 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7571, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsAssets->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsAssets->hasKey( to )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[v9].val;
  v18 = (unsigned int)hkMemHeapAllocator();
  v19 = v4->m_map.m_hashMod;
  if ( 2 * v4->m_map.m_numElems > v19 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v4->m_map, &alloc, v18);
    v19 = v4->m_map.m_hashMod;
  }
  v20 = 1;
  v21 = _byteswap_ulong(-1640531535 * (_DWORD)to);
  v22 = _byteswap_ulong(-1640531535 * HIDWORD(to));
  v23 = v22 ^ ((v21 >> 2) + v21 + (v22 << 6) - 1640531527);
  m_elem = v4->m_map.m_elem;
  v25 = v19 & v23;
  v26 = (PhysicsAsset *)v4->m_map.m_elem[v25].key;
  if ( v26 != (PhysicsAsset *)-1i64 )
  {
    while ( v26 != to )
    {
      v25 = v4->m_map.m_hashMod & (v25 + 1);
      v26 = (PhysicsAsset *)m_elem[v25].key;
      if ( v26 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v20 = 0;
  }
LABEL_36:
  v4->m_map.m_numElems += v20;
  v27 = (int)v25;
  m_elem[v27].key = (unsigned __int64)to;
  v4->m_map.m_elem[v27].val = val;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_CopyPhysicsSFXEventAsset
==============
*/
void HavokPhysics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7140, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7141, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7142, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7146, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  HavokPhysics_AddPhysicsSFXAssetInternal(to);
}

/*
==============
HavokPhysics_CopyPhysicsVFXEventAsset
==============
*/
void HavokPhysics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7304, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7305, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7306, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7310, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  HavokPhysics_AddPhysicsVFXAssetInternal(to);
}

/*
==============
HavokPhysics_CopyXModelAsset
==============
*/
void HavokPhysics_CopyXModelAsset(XModel *from, XModel *to)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v4; 
  hkMemoryAllocator *v5; 
  int m_size; 

  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7985, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(from) < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7986, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( from ) >= 0)", "%s\n\txmodel doesn't exist in debug list", "HavokPhysics_DebugXModelGetIndex( from ) >= 0") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(to) > 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7987, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( to ) <= 0)", "%s\n\tdest xmodel already exists", "HavokPhysics_DebugXModelGetIndex( to ) <= 0") )
    __debugbreak();
  v4 = s_havokPhysicsXModels;
  v5 = hkMemHeapAllocator();
  m_size = v4->m_size;
  if ( m_size == (v4->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v5, v4, 8);
    m_size = v4->m_size;
  }
  v4->m_data[m_size] = to;
  ++v4->m_size;
}

/*
==============
HavokPhysics_CopyXModelDetailCollisionAsset
==============
*/
void HavokPhysics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v5; 
  int m_hashMod; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  int v9; 
  int v10; 
  XModelDetailCollision *key; 
  unsigned __int32 v12; 
  unsigned __int32 v13; 
  int v14; 
  int v15; 
  XModelDetailCollision *v16; 
  int v17; 
  int v18; 
  int v19; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v24; 
  XModelDetailCollision *v25; 
  __int64 v26; 
  hkMemoryAllocator alloc; 

  val = 0i64;
  HavokPhysics_LockAssetWrite();
  v5 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = _byteswap_ulong(-1640531535 * (_DWORD)from), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = v9, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != from )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( v10 <= m_hashMod )
    val = s_havokPhysicsXModelLODs->m_map.m_elem[v10].val;
  if ( m_hashMod <= 0 || (v12 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v13 = _byteswap_ulong(-1640531535 * (_DWORD)to), v14 = m_hashMod & (v12 ^ ((v13 >> 2) + v13 + (v12 << 6) - 1640531527)), v15 = v14, v16 = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v14].key, v16 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v15 = m_hashMod + 1;
  }
  else
  {
    while ( v16 != to )
    {
      v14 = m_hashMod & (v14 + 1);
      v15 = v14;
      v16 = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v14].key;
      if ( v16 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( v15 <= m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8012, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsXModelLODs->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsXModelLODs->hasKey( to )") )
      __debugbreak();
    v5 = s_havokPhysicsXModelLODs;
  }
  if ( val )
  {
    v17 = (unsigned int)hkMemHeapAllocator();
    v18 = v5->m_map.m_hashMod;
    if ( 2 * v5->m_map.m_numElems > v18 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v5->m_map, &alloc, v17);
      v18 = v5->m_map.m_hashMod;
    }
    v19 = 1;
    v20 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v21 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v22 = v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527);
    m_elem = v5->m_map.m_elem;
    v24 = v18 & v22;
    v25 = (XModelDetailCollision *)v5->m_map.m_elem[v24].key;
    if ( v25 != (XModelDetailCollision *)-1i64 )
    {
      while ( v25 != to )
      {
        v24 = v5->m_map.m_hashMod & (v24 + 1);
        v25 = (XModelDetailCollision *)m_elem[v24].key;
        if ( v25 == (XModelDetailCollision *)-1i64 )
          goto LABEL_25;
      }
      v19 = 0;
    }
LABEL_25:
    v5->m_map.m_numElems += v19;
    v26 = (int)v24;
    m_elem[v26].key = (unsigned __int64)to;
    v5->m_map.m_elem[v26].val = val;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_CreateConstraint
==============
*/
hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *HavokPhysics_CreateConstraint(hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *result, HavokPhysicsWorld *world, hknpConstraintCinfo *constraintCinfo, const hkVector4f *position, const hkQuaternionf *orientation)
{
  hkpConstraintData *m_ptr; 
  hkpConstraintData *v10; 
  hkpConstraintData *v11; 
  __int64 m_value; 
  char v15[16]; 
  hkTransformf v16; 
  hkTransformf pivot; 
  hkTransformf v18; 

  _R15 = position;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8988, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8989, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( !constraintCinfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8990, ASSERT_TYPE_ASSERT, "(constraintCinfo)", (const char *)&queryFormat, "constraintCinfo") )
    __debugbreak();
  if ( (constraintCinfo->m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    m_ptr = constraintCinfo->m_constraintData.m_ptr;
    v10 = hkpConstraintDataUtils::deepClone(constraintCinfo->m_constraintData.m_ptr);
    v11 = v10;
    if ( v10 )
      hkReferencedObject::addReference(v10);
    if ( constraintCinfo->m_constraintData.m_ptr )
      hkReferencedObject::removeReference(constraintCinfo->m_constraintData.m_ptr);
    constraintCinfo->m_constraintData.m_ptr = v11;
    hkReferencedObject::removeReference(v11);
    hkRotationImpl<float>::set(&v16.m_rotation, orientation);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups [rsp+148h+var_D8], xmm0
    }
    hkpConstraintDataUtils::getPivotTransform(m_ptr, 1, &pivot);
    hkTransformf::setMul(&v18, &v16, &pivot);
    hkpConstraintDataUtils::setPivotTransform(constraintCinfo->m_constraintData.m_ptr, &v18, 1);
  }
  m_value = world->world->allocateConstraint(&world->world->hknpWorldWriter, v15, constraintCinfo)->m_value;
  result->m_value = m_value;
  ((void (__fastcall *)(hknpWorldWriter *, __int64, __int64))world->world->addConstraint)(&world->world->hknpWorldWriter, m_value, 1i64);
  return result;
}

/*
==============
HavokPhysics_CreateInstance
==============
*/
unsigned int HavokPhysics_CreateInstance(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int result; 
  unsigned int v4; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9061, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Create Instance world %i is NULL", "havokPhysicsWorld->world", worldId) )
    __debugbreak();
  result = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  v4 = result;
  if ( result == -1 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9065, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Create Instance: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    return v4;
  }
  return result;
}

/*
==============
HavokPhysics_CreateRigidBody
==============
*/
hknpBodyId *HavokPhysics_CreateRigidBody(hknpBodyId *result, Physics_WorldId worldId, HavokPhysicsWorld *world, const PhysicsAsset *physicsAsset, int assetId, hknpPhysicsSystemData::bodyCinfoWithAttachment *bodyCinfo, int ref, hkVector4f *position, hkQuaternionf *orientation, bool immediateAdd, bool tryStartDeactivated, bool wrapMutables)
{
  bool v21; 
  int v22; 
  PhysicsSFXEventAsset *v23; 
  PhysicsVFXEventAsset *v24; 
  char *v25; 
  char v26; 
  char v27; 
  const hknpShape *m_ptr; 
  hkMemoryRouter *Value; 
  hknpMaskedShape *v30; 
  hknpShape *v31; 
  hknpShape *v32; 
  __int64 v33; 
  Physics_RefSystem RefSystem; 
  __int64 v35; 
  __int64 v69; 
  PhysicsSFXEventAsset *v70; 
  __int64 v71; 
  const char *name; 
  __int64 v73; 
  unsigned int i; 
  int v75; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v76; 
  int m_hashMod; 
  unsigned __int32 v78; 
  int v79; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 
  PhysicsVFXEventAsset *v82; 
  const char *v83; 
  unsigned int j; 
  int v85; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v86; 
  int v87; 
  unsigned __int32 v88; 
  int v89; 
  unsigned int v90; 
  PhysicsVFXEventAsset *v91; 
  unsigned int m_serialAndIndex; 
  const HavokPhysicsWorld *ConstWorld; 
  hknpActionManager *ActionManager; 
  hknpBodyId *v95; 
  __int64 v100; 
  __int64 v101; 
  char v102; 
  char action[40]; 
  hkQuaternionf qi; 
  hkRotationImpl<float> v105; 
  char v107; 
  void *retaddr; 

  _RAX = &retaddr;
  *(_QWORD *)&action[16] = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _RBX = bodyCinfo;
  *(_QWORD *)&action[8] = orientation;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8689, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8690, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( !bodyCinfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8691, ASSERT_TYPE_ASSERT, "(bodyCinfo)", (const char *)&queryFormat, "bodyCinfo") )
    __debugbreak();
  if ( !bodyCinfo->m_shape.m_ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8692, ASSERT_TYPE_ASSERT, "(bodyCinfo->m_shape)", (const char *)&queryFormat, "bodyCinfo->m_shape") )
    __debugbreak();
  if ( Physics_IsQueryWorld(worldId) && bodyCinfo->m_motionType.m_storage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8693, ASSERT_TYPE_ASSERT, "(!Physics_IsQueryWorld( worldId ) || bodyCinfo->m_motionType == hknpMotionType::STATIC)", (const char *)&queryFormat, "!Physics_IsQueryWorld( worldId ) || bodyCinfo->m_motionType == hknpMotionType::STATIC") )
    __debugbreak();
  if ( !physicsAsset || physicsAsset->useCategory != PhysicsAssetUseCategory_Vehicle || (v102 = 1, (unsigned int)(*physicsAsset->simulationCategories - 7) > 1) )
    v102 = 0;
  v21 = 0;
  v22 = assetId;
  if ( Physics_IsAuthoritativeWorld(worldId) )
  {
    if ( !physicsAsset )
      goto LABEL_34;
    v23 = physicsAsset->sfxEventAssets[assetId];
    if ( v23 )
      v21 = v23->rules.numrules > 0;
    v24 = physicsAsset->vfxEventAssets[assetId];
    if ( v24 && v24->rules.numrules > 0 )
    {
LABEL_33:
      bodyCinfo->m_flags.m_storage |= 0x80u;
      goto LABEL_34;
    }
LABEL_32:
    if ( !v21 )
      goto LABEL_34;
    goto LABEL_33;
  }
  if ( worldId == PHYSICS_WORLD_ID_FIRST || Physics_IsPredictiveWorld(worldId) )
  {
    v21 = bodyCinfo->m_qualityId.m_value == s_vehicleBodyQualityIdx + 16;
    if ( v102 )
      bodyCinfo->m_flags.m_storage |= 0x400000u;
    goto LABEL_32;
  }
LABEL_34:
  bodyCinfo->m_motionId.m_value = 0x7FFFFFFF;
  v25 = (char *)((unsigned __int64)bodyCinfo->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  v26 = *v25;
  if ( *v25 )
  {
    do
    {
      if ( *v25 != (unsigned __int8)tolower(v26) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8771, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Rigid body name %s should be lower case\n", (const char *)((unsigned __int64)bodyCinfo->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64)) )
        __debugbreak();
      v26 = *++v25;
    }
    while ( *v25 );
    v22 = assetId;
  }
  v27 = 0;
  if ( wrapMutables && bodyCinfo->m_shape.m_ptr->getMutationSignals(bodyCinfo->m_shape.m_ptr) )
  {
    m_ptr = bodyCinfo->m_shape.m_ptr;
    if ( bodyCinfo->m_shape.m_ptr->m_type.m_storage != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8783, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND") )
      __debugbreak();
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v30 = (hknpMaskedShape *)Value->m_heap->blockAlloc(Value->m_heap, 104i64);
    *(_QWORD *)action = v30;
    if ( v30 )
    {
      hknpMaskedShape::hknpMaskedShape(v30, m_ptr);
      v32 = v31;
    }
    else
    {
      v32 = NULL;
    }
    if ( v32 )
    {
      hkReferencedObject::addReference(v32);
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8788, ASSERT_TYPE_ASSERT, "(maskedShape)", (const char *)&queryFormat, "maskedShape") )
    {
      __debugbreak();
    }
    if ( bodyCinfo->m_shape.m_ptr )
      hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    bodyCinfo->m_shape.m_ptr = v32;
    v27 = 1;
  }
  Sys_EnterCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  result->m_serialAndIndex = world->world->allocateBody(&world->world->hknpWorldWriter, action, bodyCinfo)->m_serialAndIndex;
  Sys_LeaveCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  if ( !*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, result->m_serialAndIndex) + 96) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8807, ASSERT_TYPE_ASSERT, "(world->world->getBody( bodyId ).getShape())", (const char *)&queryFormat, "world->world->getBody( bodyId ).getShape()") )
    __debugbreak();
  if ( v27 )
  {
    hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    if ( bodyCinfo->m_shape.m_ptr )
      hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    bodyCinfo->m_shape.m_ptr = NULL;
  }
  v33 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, result->m_serialAndIndex);
  *(_QWORD *)(v33 + 160) |= (unsigned int)ref;
  if ( immediateAdd )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, bool))world->world->addBody)(&world->world->hknpWorldWriter, result->m_serialAndIndex, 0i64, tryStartDeactivated);
  RefSystem = Physics_GetRefSystem(ref);
  v35 = RefSystem;
  if ( (unsigned int)RefSystem >= Physics_RefSystem_Count )
  {
    LODWORD(v100) = RefSystem;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8828, ASSERT_TYPE_ASSERT, "(unsigned)( refSystem ) < (unsigned)( Physics_RefSystem_Count )", "refSystem doesn't index Physics_RefSystem_Count\n\t%i not in [0, %i)", v100, 13) )
      __debugbreak();
  }
  ++world->refSystemCounts[v35];
  _RDI = *(_QWORD *)&action[8];
  hkVector4f::setRotatedDir((hkVector4f *)&action[24], *(const hkQuaternionf **)&action[8], &bodyCinfo->m_position);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+138h+action+18h]
    vaddps  xmm0, xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rsp+138h+action+18h], xmm0
    vmovups xmm8, xmmword ptr [rdi]
    vmovups xmm7, xmmword ptr [rbx+40h]
    vbroadcastss xmm6, dword ptr [rdi+0Ch]
    vbroadcastss xmm5, dword ptr [rbx+4Ch]
    vshufps xmm0, xmm8, xmm8, 0C9h ; ''
    vmulps  xmm3, xmm0, xmm7
    vshufps xmm1, xmm7, xmm7, 0C9h ; ''
    vmulps  xmm2, xmm1, xmm8
    vsubps  xmm4, xmm2, xmm3
    vmulps  xmm1, xmm5, xmm6
    vmovups xmmword ptr [rsp+138h+qi.m_vec.m_quad], xmm1
    vdpps   xmm0, xmm8, xmm7, 7Fh
    vsubps  xmm3, xmm1, xmm0
    vshufps xmm1, xmm4, xmm4, 0C9h ; ''
    vmulps  xmm0, xmm7, xmm6
    vaddps  xmm2, xmm1, xmm0
    vmulps  xmm1, xmm8, xmm5
    vaddps  xmm2, xmm2, xmm1
    vblendps xmm5, xmm2, xmm3, 8
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vmovups xmmword ptr [rsp+138h+qi.m_vec.m_quad], xmm0
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm4, xmm0
    vmulps  xmm2, xmm0, xmm4
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmulps  xmm1, xmm3, xmm2
    vmulps  xmm3, xmm1, xmm5
    vmovups xmmword ptr [rsp+138h+qi.m_vec.m_quad], xmm3
  }
  hkRotationImpl<float>::set(&v105, &qi);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+138h+action+18h]
    vmovups [rsp+138h+var_88], xmm0
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, hkRotationImpl<float> *, bool))world->world->setBodyTransform)(&world->world->hknpWorldWriter, result->m_serialAndIndex, &v105, tryStartDeactivated);
  world->bodySFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = NULL;
  world->bodyVFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = NULL;
  if ( physicsAsset )
  {
    v69 = v22;
    v70 = physicsAsset->sfxEventAssets[v69];
    v71 = -1i64;
    if ( v70 )
    {
      name = v70->name;
      v73 = -1i64;
      do
        ++v73;
      while ( name[v73] );
      for ( i = -1; v73; --v73 )
        i = (i >> 8) ^ g_crc32Table[*(unsigned __int8 *)name++ ^ (unsigned __int64)(unsigned __int8)i];
      v75 = ~i;
      Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
      AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      v76 = g_physicsSFXEventAssets;
      m_hashMod = g_physicsSFXEventAssets->m_hashMod;
      if ( m_hashMod <= 0 || (v78 = m_hashMod & _byteswap_ulong(-1640531535 * v75), v79 = v78, key = g_physicsSFXEventAssets->m_elem[v78].key, key == -1) )
      {
LABEL_79:
        v79 = m_hashMod + 1;
      }
      else
      {
        while ( key != v75 )
        {
          v78 = m_hashMod & (v78 + 1);
          v79 = v78;
          key = g_physicsSFXEventAssets->m_elem[v78].key;
          if ( key == -1 )
            goto LABEL_79;
        }
      }
      if ( v79 > m_hashMod )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8876, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->isValid( eventIt ))", (const char *)&queryFormat, "g_physicsSFXEventAssets->isValid( eventIt )") )
          __debugbreak();
        v76 = g_physicsSFXEventAssets;
      }
      val = v76->m_elem[v79].val;
      ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
      world->bodySFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = val;
    }
    v82 = physicsAsset->vfxEventAssets[v69];
    if ( v82 )
    {
      v83 = v82->name;
      do
        ++v71;
      while ( v83[v71] );
      for ( j = -1; v71; --v71 )
        j = (j >> 8) ^ g_crc32Table[*(unsigned __int8 *)v83++ ^ (unsigned __int64)(unsigned __int8)j];
      v85 = ~j;
      Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
      AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      v86 = g_physicsVFXEventAssets;
      v87 = g_physicsVFXEventAssets->m_hashMod;
      if ( v87 <= 0 || (v88 = v87 & _byteswap_ulong(-1640531535 * v85), v89 = v88, v90 = g_physicsVFXEventAssets->m_elem[v88].key, v90 == -1) )
      {
LABEL_94:
        v89 = v87 + 1;
      }
      else
      {
        while ( v90 != v85 )
        {
          v88 = v87 & (v88 + 1);
          v89 = v88;
          v90 = g_physicsVFXEventAssets->m_elem[v88].key;
          if ( v90 == -1 )
            goto LABEL_94;
        }
      }
      if ( v89 > v87 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8887, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->isValid( eventIt ))", (const char *)&queryFormat, "g_physicsVFXEventAssets->isValid( eventIt )") )
          __debugbreak();
        v86 = g_physicsVFXEventAssets;
      }
      v91 = v86->m_elem[v89].val;
      ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
      world->bodyVFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = v91;
    }
  }
  if ( !Physics_IsQueryWorld(worldId) )
  {
    m_serialAndIndex = result->m_serialAndIndex;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v101) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11402, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v101) )
        __debugbreak();
    }
    if ( (m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v101) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11403, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid body id for world %i", "bodyId.isValid()", v101) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v101) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11408, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v101) )
        __debugbreak();
    }
    if ( (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 6) == 2 && !Physics_IsPredictiveWorld(worldId) && !v102 )
    {
      PhysicsForceAction_Create(worldId, result->m_serialAndIndex);
      ActionManager = hknpWorld::getActionManager(world->world);
      hknpActionManager::addAction(ActionManager, (hknpAction *)action);
    }
  }
  v95 = result;
  _R11 = &v107;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return v95;
}

/*
==============
HavokPhysics_CreateShapeCapsuleCenterHeight
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsuleCenterHeight(Physics_WorldId worldId, const hkVector4f *center, double halfHeight, double radius, hkVector4f *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  hknpShape *result; 
  hkVector4f a; 
  hkVector4f b; 
  char v42; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovss  xmm0, cs:__real@38d1b717
  }
  _RBX = majorAxis;
  __asm
  {
    vmovaps xmm6, xmm2
    vmovdqu xmm2, xmmword ptr [rbx]
    vmovss  [rsp+0B8h+var_78], xmm0
    vpand   xmm0, xmm2, cs:?g_mantissaMaskf@@3QBIB; uint const near * const g_mantissaMaskf
    vpcmpeqd xmm1, xmm0, cs:?g_mantissaMaskf@@3QBIB; uint const near * const g_mantissaMaskf
    vpmovmskb eax, xmm1
    vmovaps xmm7, xmm3
  }
  if ( (_EAX & 0x111) != 0 )
    goto LABEL_8;
  __asm
  {
    vmovups xmm0, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
    vbroadcastss xmm1, [rsp+0B8h+var_78]
    vdpps   xmm3, xmm2, xmm2, 7Fh
    vmovups xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rsp+0B8h+a.m_quad], xmm2
    vsubps  xmm2, xmm3, xmm2
    vandnps xmm3, xmm0, xmm2
    vucomiss xmm1, xmm3
  }
  if ( (_EAX & 0x111) == 0 )
  {
LABEL_8:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15570, ASSERT_TYPE_ASSERT, "(majorAxis.isNormalized<3>())", (const char *)&queryFormat, "majorAxis.isNormalized<3>()") )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm6, cs:__xmm@80000000800000008000000080000000
    vshufps xmm0, xmm0, xmm0, 0
    vmulps  xmm0, xmm0, xmmword ptr [rbx]
    vaddps  xmm1, xmm0, xmmword ptr [rdi]
    vmovaps xmm2, xmm6
    vshufps xmm2, xmm2, xmm2, 0
    vmulps  xmm0, xmm2, xmmword ptr [rbx]
    vmovups xmmword ptr [rsp+0B8h+a.m_quad], xmm1
    vaddps  xmm1, xmm0, xmmword ptr [rdi]
    vmovaps xmm3, xmm7; radius
    vmovups xmmword ptr [rsp+0B8h+b.m_quad], xmm1
  }
  result = HavokPhysics_CreateShapeCapsulePoints(worldId, &a, &b, *(float *)&_XMM3, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
  _R11 = &v42;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
HavokPhysics_CreateShapeCapsulePoints
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsulePoints(Physics_WorldId worldId, const hkVector4f *a, const hkVector4f *b, double radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, hkMemoryAllocator shapeStorage)
{
  int v12; 
  hknpShape *v13; 
  hknpShape *v14; 
  hknpCapsuleShape *ConvexShape; 
  hknpShape *v17; 
  HavokPhysicsWorld *MutableWorld; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> > *p_m_map; 
  int v20; 
  int m_hashMod; 
  int v22; 
  unsigned __int32 v23; 
  unsigned __int32 v24; 
  unsigned int v25; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  hknpShape *key; 
  __int64 v28; 
  hknpShape *result; 
  char *optionalInplaceBuffera; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  v12 = (int)shapeStorage.__vftable;
  if ( optionalInplaceBuffer )
  {
    hknpCapsuleShape::hknpCapsuleShape((hknpCapsuleShape *)optionalInplaceBuffer, a, b, *(float *)&radius);
    v14 = v13;
    v13->m_memSizeAndFlags = 0;
  }
  else
  {
    if ( LODWORD(shapeStorage.__vftable) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15593, ASSERT_TYPE_ASSERT, "(shapeStorage == Physics_ShapeStorage::Permanent)", "%s\n\tShould not use heap allocator temporary storage", "shapeStorage == Physics_ShapeStorage::Permanent") )
      __debugbreak();
    ConvexShape = (hknpCapsuleShape *)hknpConvexShape::allocateConvexShape(2, 64, (int *)&shapeStorage);
    if ( ConvexShape )
    {
      __asm { vmovaps xmm3, xmm6; radius }
      hknpCapsuleShape::hknpCapsuleShape(ConvexShape, a, b, *(float *)&_XMM3);
      v14 = v17;
    }
    else
    {
      v14 = NULL;
    }
    v14->m_memSizeAndFlags = (unsigned __int16)shapeStorage.__vftable;
  }
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15596, ASSERT_TYPE_ASSERT, "(capsuleShape)", (const char *)&queryFormat, "capsuleShape") )
    __debugbreak();
  if ( !v12 )
  {
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15602, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics CreateShapeCapsule %i: world is NULL", "physicsWorld->world", worldId) )
      __debugbreak();
    p_m_map = &MutableWorld->capsuleRadii->m_map;
    __asm { vmovss  dword ptr [rsp+88h+shapeStorage], xmm6 }
    optionalInplaceBuffera = (char *)LODWORD(shapeStorage.__vftable);
    v20 = (unsigned int)hkMemHeapAllocator();
    m_hashMod = p_m_map->m_hashMod;
    if ( 2 * p_m_map->m_numElems > m_hashMod )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(p_m_map, &shapeStorage, v20);
      m_hashMod = p_m_map->m_hashMod;
    }
    v22 = 1;
    v23 = _byteswap_ulong(-1640531535 * (_DWORD)v14);
    v24 = _byteswap_ulong(-1640531535 * HIDWORD(v14));
    v25 = m_hashMod & (v24 ^ ((v23 >> 2) + v23 + (v24 << 6) - 1640531527));
    m_elem = p_m_map->m_elem;
    key = (hknpShape *)p_m_map->m_elem[v25].key;
    if ( key != (hknpShape *)-1i64 )
    {
      while ( key != v14 )
      {
        v25 = p_m_map->m_hashMod & (v25 + 1);
        key = (hknpShape *)m_elem[v25].key;
        if ( key == (hknpShape *)-1i64 )
          goto LABEL_24;
      }
      v22 = 0;
    }
LABEL_24:
    p_m_map->m_numElems += v22;
    v28 = (int)v25;
    m_elem[v28].key = (unsigned __int64)v14;
    p_m_map->m_elem[v28].val = (unsigned __int64)optionalInplaceBuffera;
  }
  result = v14;
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
  return result;
}

/*
==============
HavokPhysics_CreateShapeCompound
==============
*/
hknpShape *HavokPhysics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  __int64 m_size; 
  int v4; 
  int v5; 
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  hkMemoryAllocator *v10; 
  int v11; 
  __int64 v12; 
  bool v13; 
  hkReferencedObject *v18; 
  hkMemoryRouter *v19; 
  hknpCompoundShape *v20; 
  hknpShape *v21; 
  hknpShape *v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  hknpShapeInstance *v25; 
  hkMemoryAllocator *v30; 
  __int64 v31; 
  hkReferencedObject **p_m_shape; 
  hkMemoryRouter *v33; 
  hknpCompoundShape *v34; 
  __int64 v35; 
  __int64 v36; 
  hkMemoryAllocator *v37; 
  __int64 v38; 
  hkReferencedObject **v39; 
  hkMemoryRouter *Value; 
  hknpCompoundShape *v41; 
  __int64 v42; 
  __int64 v43; 
  hknpShapeInstance *array; 
  int v45; 
  int v46; 
  void *p; 
  int v48; 
  int v49; 
  hknpCompoundShapeCinfo v50; 
  __int64 v51; 
  hknpShapeInstance *v52; 
  hknpCompoundShapeCinfo cinfo; 
  int v54; 
  int v55; 
  __int64 v56; 

  v51 = -2i64;
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15660, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  m_size = instanceArray->m_size;
  v55 = m_size;
  if ( !(_DWORD)m_size )
    return 0i64;
  if ( (int)m_size < 0xFFFF )
  {
    hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&v50);
    v50.m_instances = instanceArray->m_data;
    v50.m_numInstances = instanceArray->m_size;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v41 = (hknpCompoundShape *)Value->m_heap->blockAlloc(Value->m_heap, 288i64);
    if ( v41 )
    {
      hknpCompoundShape::hknpCompoundShape(v41, &v50);
      v43 = v42;
    }
    else
    {
      v43 = 0i64;
    }
    if ( !v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15733, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    return (hknpShape *)v43;
  }
  else
  {
    p = NULL;
    v48 = 0;
    v49 = 0x80000000;
    v4 = 0;
    v54 = 0;
    if ( (int)m_size > 0 )
    {
      v56 = m_size;
      do
      {
        array = NULL;
        v5 = 0;
        v45 = 0;
        v46 = 0x80000000;
        v6 = 0i64;
        v7 = v4;
        v8 = v4;
        do
        {
          if ( v7 + v6 >= v56 )
            break;
          _RDI = &instanceArray->m_data[v8];
          v10 = hkMemHeapAllocator();
          v11 = v45;
          if ( v45 == (v46 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v10, &array, 112);
            v11 = v45;
          }
          v12 = v11;
          v13 = &array[v12] == NULL;
          _RBX = &array[v12];
          v52 = _RBX;
          if ( !v13 )
          {
            __asm
            {
              vmovups ymm0, ymmword ptr [rdi]
              vmovups ymmword ptr [rbx], ymm0
              vmovups ymm1, ymmword ptr [rdi+20h]
              vmovups ymmword ptr [rbx+20h], ymm1
              vmovups xmm0, xmmword ptr [rdi+40h]
              vmovups xmmword ptr [rbx+40h], xmm0
            }
            v18 = &_RDI->m_shape.m_ptr->hkReferencedObject;
            _RBX->m_shape.m_ptr = (const hknpShape *)v18;
            if ( v18 )
              hkReferencedObject::addReference(v18);
            _RBX->m_shapeTag = _RDI->m_shapeTag;
            _RBX->m_destructionTag = _RDI->m_destructionTag;
            _RBX->m_isEmpty = _RDI->m_isEmpty;
            _RBX->m_nextEmptyElement = _RDI->m_nextEmptyElement;
            _RBX->m_instanceId.m_value = _RDI->m_instanceId.m_value;
            _RBX->m_parentShape = _RDI->m_parentShape;
            v11 = v45;
          }
          v5 = v11 + 1;
          v45 = v5;
          ++v6;
          ++v8;
        }
        while ( v6 < 0xFFFF );
        if ( v5 <= 0 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15692, ASSERT_TYPE_ASSERT, "(childInstanceArray.getSize() > 0)", (const char *)&queryFormat, "childInstanceArray.getSize() > 0") )
            __debugbreak();
          v5 = v45;
        }
        v4 = v5 + v54;
        v54 += v5;
        hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
        cinfo.m_instances = array;
        cinfo.m_numInstances = v45;
        v19 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
        if ( !v19 )
          v19 = hkMemoryRouter::s_fallbackRouter;
        v20 = (hknpCompoundShape *)v19->m_heap->blockAlloc(v19->m_heap, 288i64);
        if ( v20 )
        {
          hknpCompoundShape::hknpCompoundShape(v20, &cinfo);
          v22 = v21;
        }
        else
        {
          v22 = NULL;
        }
        if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15702, ASSERT_TYPE_ASSERT, "(childShape)", (const char *)&queryFormat, "childShape") )
          __debugbreak();
        v23 = hkMemHeapAllocator();
        v24 = v48;
        if ( v48 == (v49 & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v23, &p, 112);
          v24 = v48;
        }
        v25 = (hknpShapeInstance *)p;
        _RCX = (char *)p + 112 * v24;
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rcx+20h], ymm1
            vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
            vmovups xmmword ptr [rcx+40h], xmm0
          }
          *((_QWORD *)_RCX + 10) = 0i64;
          *((_DWORD *)_RCX + 22) = -1;
          _RCX[92] = 0;
          *((_DWORD *)_RCX + 24) = 0;
          *((_WORD *)_RCX + 50) = -1;
          *((_QWORD *)_RCX + 13) = 0i64;
          *((_DWORD *)_RCX + 3) = 1056964672;
          v24 = v48;
          v25 = (hknpShapeInstance *)p;
        }
        v48 = v24 + 1;
        hknpShapeInstance::setShape(&v25[v24], v22);
        hkReferencedObject::removeReference(v22);
        v30 = hkMemHeapAllocator();
        v31 = v45 - 1;
        if ( v45 - 1 >= 0 )
        {
          p_m_shape = (hkReferencedObject **)&array[v31].m_shape;
          do
          {
            if ( *p_m_shape )
              hkReferencedObject::removeReference(*p_m_shape);
            p_m_shape -= 14;
            --v31;
          }
          while ( v31 >= 0 );
          v4 = v54;
        }
        v45 = 0;
        if ( v46 >= 0 )
          hkMemoryAllocator::bufFree2(v30, array, 112, v46 & 0x3FFFFFFF);
        array = NULL;
        v46 = 0x80000000;
      }
      while ( v4 < v55 );
    }
    hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&v50);
    v50.m_instances = (const hknpShapeInstance *)p;
    v50.m_numInstances = v48;
    v33 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v33 )
      v33 = hkMemoryRouter::s_fallbackRouter;
    v34 = (hknpCompoundShape *)v33->m_heap->blockAlloc(v33->m_heap, 288i64);
    if ( v34 )
    {
      hknpCompoundShape::hknpCompoundShape(v34, &v50);
      v36 = v35;
    }
    else
    {
      v36 = 0i64;
    }
    if ( !v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15719, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    v37 = hkMemHeapAllocator();
    v38 = v48 - 1;
    if ( v48 - 1 >= 0 )
    {
      v39 = (hkReferencedObject **)((char *)p + 112 * v38 + 80);
      do
      {
        if ( *v39 )
          hkReferencedObject::removeReference(*v39);
        v39 -= 14;
        --v38;
      }
      while ( v38 >= 0 );
    }
    v48 = 0;
    if ( v49 >= 0 )
      hkMemoryAllocator::bufFree2(v37, p, 112, v49 & 0x3FFFFFFF);
    return (hknpShape *)v36;
  }
}

/*
==============
HavokPhysics_CreateShapeConvexHull
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeConvexHull(hkArray<hkVector4f,hkContainerHeapAllocator> *verts, unsigned int maxNumGeneratedVertices, bool useCache)
{
  unsigned int v7; 
  __int64 ThreadId; 
  bool v9; 
  unsigned int v10; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v11; 
  int m_size; 
  hkVector4f *m_data; 
  unsigned __int8 *v14; 
  __int64 v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  int m_hashMod; 
  unsigned __int32 v28; 
  unsigned __int32 v29; 
  unsigned int v30; 
  int v31; 
  unsigned __int64 key; 
  hknpConvexShape *val; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  unsigned __int32 v40; 
  unsigned __int32 v41; 
  unsigned int v42; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 v44; 
  __int64 v45; 
  hkStridedVertices verticesInOrg; 
  hknpConvexShape::BuildConfig configInOrg; 
  hkMemoryAllocator alloc; 

  v7 = 252;
  if ( maxNumGeneratedVertices > 0xFC && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15963, ASSERT_TYPE_ASSERT, "(maxNumGeneratedVertices <= hknpConvexShape::MAX_NUM_VERTICES)", (const char *)&queryFormat, "maxNumGeneratedVertices <= hknpConvexShape::MAX_NUM_VERTICES", -2i64) )
    __debugbreak();
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  ThreadId = Physics_GetThreadId();
  v9 = 0;
  if ( !s_havokPhysicsShapeCachesDisabled[ThreadId] )
    v9 = useCache;
  if ( maxNumGeneratedVertices )
    v7 = maxNumGeneratedVertices;
  v10 = 0;
  v11 = NULL;
  if ( !v9 )
    goto LABEL_25;
  m_size = verts->m_size;
  if ( m_size > 0 )
  {
    m_data = verts->m_data;
    v14 = &verts->m_data->m_quad.m128_u8[6];
    v15 = (unsigned int)m_size;
    do
    {
      v16 = (~v10 >> 8) ^ g_crc32Table[m_data->m_quad.m128_u8[0] ^ (unsigned __int64)(unsigned __int8)~(_BYTE)v10];
      v17 = (v16 >> 8) ^ g_crc32Table[(unsigned __int8)v16 ^ (unsigned __int64)*(v14 - 5)];
      v18 = (v17 >> 8) ^ g_crc32Table[(unsigned __int8)v17 ^ (unsigned __int64)*(v14 - 4)];
      v19 = (v18 >> 8) ^ g_crc32Table[(unsigned __int8)v18 ^ (unsigned __int64)*(v14 - 3)];
      v20 = (v19 >> 8) ^ g_crc32Table[(unsigned __int8)v19 ^ (unsigned __int64)*(v14 - 2)];
      v21 = (v20 >> 8) ^ g_crc32Table[(unsigned __int8)v20 ^ (unsigned __int64)*(v14 - 1)];
      v22 = (v21 >> 8) ^ g_crc32Table[*v14 ^ (unsigned __int64)(unsigned __int8)v21];
      v23 = (v22 >> 8) ^ g_crc32Table[(unsigned __int8)v22 ^ (unsigned __int64)v14[1]];
      v24 = (v23 >> 8) ^ g_crc32Table[(unsigned __int8)v23 ^ (unsigned __int64)v14[2]];
      v25 = (v24 >> 8) ^ g_crc32Table[(unsigned __int8)v24 ^ (unsigned __int64)v14[3]];
      v26 = (v25 >> 8) ^ g_crc32Table[(unsigned __int8)v25 ^ (unsigned __int64)v14[4]];
      v10 = ~((v26 >> 8) ^ g_crc32Table[(unsigned __int8)v26 ^ (unsigned __int64)v14[5]]);
      ++m_data;
      v14 += 16;
      --v15;
    }
    while ( v15 );
  }
  v11 = s_havokPhysicsShapeCaches[ThreadId];
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15999, ASSERT_TYPE_ASSERT, "(cache)", "%s\n\tHavokPhysics_CreateShapeConvexHull: Cache is invalid", "cache") )
    __debugbreak();
  m_hashMod = v11->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v28 = _byteswap_ulong(-1640531535 * v10), v29 = _byteswap_ulong(0), v30 = m_hashMod & (v29 ^ ((v28 >> 2) + v28 + (v29 << 6) - 1640531527)), v31 = v30, key = v11->m_map.m_elem[v30].key, key == -1i64) )
  {
LABEL_19:
    v31 = m_hashMod + 1;
  }
  else
  {
    while ( key != v10 )
    {
      v30 = m_hashMod & (v30 + 1);
      v31 = v30;
      key = v11->m_map.m_elem[v30].key;
      if ( key == -1i64 )
        goto LABEL_19;
    }
  }
  if ( v31 <= m_hashMod )
  {
    val = (hknpConvexShape *)v11->m_map.m_elem[v31].val;
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16011, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    hkReferencedObject::addReference(val);
  }
  else
  {
LABEL_25:
    configInOrg.m_shrinkByRadius.m_bool = 0;
    __asm
    {
      vxorps  xmm1, xmm1, xmm1; convexRadius
      vmovss  [rsp+0C8h+configInOrg.m_simplificationTolerance], xmm1
    }
    configInOrg.m_maxNumVertices = v7;
    v35 = verts->m_size;
    verticesInOrg.m_vertices = verts->m_data->m_quad.m128_f32;
    verticesInOrg.m_numVertices = v35;
    verticesInOrg.m_striding = 16;
    val = hknpConvexShape::createFromVertices(&verticesInOrg, *(float *)&_XMM1, &configInOrg);
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16025, ASSERT_TYPE_ASSERT, "(hullShape)", (const char *)&queryFormat, "hullShape") )
      __debugbreak();
    if ( v9 )
    {
      hkReferencedObject::addReference(val);
      v36 = (unsigned int)hkMemHeapAllocator();
      v37 = v11->m_map.m_hashMod;
      v38 = v37;
      if ( 2 * v11->m_map.m_numElems > v37 )
      {
        hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v11->m_map, &alloc, v36);
        v37 = v11->m_map.m_hashMod;
        v38 = v37;
      }
      v39 = 1;
      v40 = _byteswap_ulong(-1640531535 * v10);
      v41 = _byteswap_ulong(0);
      v42 = v38 & (v41 ^ ((v40 >> 2) + v40 + (v41 << 6) - 1640531527));
      m_elem = v11->m_map.m_elem;
      v44 = v11->m_map.m_elem[v42].key;
      if ( v44 != -1i64 )
      {
        while ( v44 != v10 )
        {
          v42 = v37 & (v42 + 1);
          v44 = m_elem[v42].key;
          if ( v44 == -1i64 )
            goto LABEL_36;
        }
        v39 = 0;
      }
LABEL_36:
      v11->m_map.m_numElems += v39;
      v45 = (int)v42;
      m_elem[v45].key = v10;
      v11->m_map.m_elem[v45].val = (unsigned __int64)val;
    }
  }
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  return val;
}

/*
==============
HavokPhysics_CreateShapeConvexHullFromAABB
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeConvexHullFromAABB(const hkVector4f *mins, const hkVector4f *maxs)
{
  const hknpConvexShape::BuildConfig *v5; 
  hknpConvexShape *v6; 
  hknpConvexShape::BuildConfig v8; 
  hkAabb aabb; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+0C8h+aabb.m_min.m_quad], xmm0
    vmovups xmm1, xmmword ptr [rdx]
    vmovups xmmword ptr [rsp+0C8h+aabb.m_max.m_quad], xmm1
  }
  hknpConvexShape::BuildConfig::BuildConfig(&v8);
  __asm { vmovss  xmm1, cs:__real@3c75c28f; convexRadius }
  v6 = hknpConvexShape::createFromAabb(&aabb, *(float *)&_XMM1, v5);
  hkReferencedObject::~hkReferencedObject(&v8.m_massConfig);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16049, ASSERT_TYPE_ASSERT, "(hullShape)", (const char *)&queryFormat, "hullShape", -2i64) )
    __debugbreak();
  return v6;
}

/*
==============
HavokPhysics_CreateShapeCube
==============
*/

hknpConvexShape *__fastcall HavokPhysics_CreateShapeCube(const hkVector4f *center, double halfSize)
{
  int v6; 
  hkMemoryAllocator *v7; 
  __int64 v8; 
  __int64 v16; 
  __int64 v23; 
  __int64 v30; 
  __int64 v37; 
  __int64 v44; 
  __int64 v51; 
  __int64 v62; 
  hknpConvexShape *v66; 
  hkMemoryAllocator *v67; 
  hknpConvexShape *result; 
  float *array; 
  int v72; 
  int v73; 
  hkStridedVertices verticesInOrg; 
  hknpConvexShape::BuildConfig configInOrg; 
  char vars0; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmm6, xmm1
  }
  array = NULL;
  v72 = 0;
  v73 = 0x80000000;
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  v6 = numVertices;
  v7 = hkMemHeapAllocator();
  if ( v6 > 0 )
    hkArrayUtil::_reserve(v7, &array, v6, 16);
  v8 = v72++;
  _RAX = &array[4 * v8];
  __asm
  {
    vxorps  xmm2, xmm6, cs:__xmm@80000000800000008000000080000000
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v16 = v72++;
  _RAX = &array[4 * v16];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v23 = v72++;
  _RAX = &array[4 * v23];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v30 = v72++;
  _RAX = &array[4 * v30];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v37 = v72++;
  _RAX = &array[4 * v37];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v44 = v72++;
  _RAX = &array[4 * v44];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  v51 = v72++;
  _RAX = &array[4 * v51];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
    vaddps  xmm0, xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
    vxorps  xmm1, xmm1, xmm1
    vinsertps xmm1, xmm1, xmm2, 0
    vinsertps xmm1, xmm1, xmm6, 10h
    vinsertps xmm1, xmm1, xmm6, 20h ; ' '
  }
  v62 = v72++;
  _RAX = &array[4 * v62];
  __asm
  {
    vaddps  xmm0, xmm1, xmmword ptr [rdi]
    vmovups xmmword ptr [rax], xmm0
  }
  configInOrg.m_shrinkByRadius.m_bool = 0;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1; convexRadius
    vmovss  [rbp+57h+configInOrg.m_simplificationTolerance], xmm1
  }
  verticesInOrg.m_vertices = array;
  verticesInOrg.m_numVertices = v72;
  verticesInOrg.m_striding = 16;
  v66 = hknpConvexShape::createFromVertices(&verticesInOrg, *(float *)&_XMM1, &configInOrg);
  if ( !v66 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15651, ASSERT_TYPE_ASSERT, "(cubeShape)", (const char *)&queryFormat, "cubeShape", -2i64) )
    __debugbreak();
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  v67 = hkMemHeapAllocator();
  v72 = 0;
  if ( v73 >= 0 )
    hkMemoryAllocator::bufFree2(v67, array, 16, v73 & 0x3FFFFFFF);
  result = v66;
  _R11 = &vars0;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return result;
}

/*
==============
HavokPhysics_CreateShapeCylinder
==============
*/

hknpConvexShape *__fastcall HavokPhysics_CreateShapeCylinder(const hkVector4f *center, double halfHeight, double radius, int numVertices, hkMemoryAllocator useCache)
{
  __int64 ThreadId; 
  char v20; 
  unsigned int v21; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v22; 
  unsigned int v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  unsigned int v34; 
  unsigned int v35; 
  unsigned int v36; 
  unsigned int v37; 
  unsigned int v38; 
  unsigned int v39; 
  unsigned int v40; 
  unsigned int v41; 
  unsigned int v42; 
  unsigned int v43; 
  unsigned int v44; 
  int m_hashMod; 
  unsigned __int32 v46; 
  unsigned __int32 v47; 
  unsigned int v48; 
  int v49; 
  unsigned __int64 key; 
  hknpConvexShape *val; 
  hkMemoryAllocator *v52; 
  int v53; 
  int v54; 
  hkResult v55; 
  const __m128 *v56; 
  int v57; 
  int v58; 
  int v59; 
  const __m128 *v71; 
  __int64 v78; 
  __int64 v81; 
  hkMemoryRouter *Value; 
  __int64 v85; 
  int v87; 
  int v89; 
  int v90; 
  int v91; 
  unsigned __int32 v92; 
  unsigned __int32 v93; 
  unsigned int v94; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 v96; 
  __int64 v97; 
  hkMemoryAllocator *v98; 
  hknpConvexShape *v99; 
  char *array; 
  unsigned int v109; 
  int v110; 
  __m128 result; 
  __int64 v112; 
  hknpConvexShape::BuildConfig configInOrg; 
  __int64 v114; 
  char v115; 
  void *retaddr; 
  unsigned __int8 v117; 
  unsigned __int8 v118; 
  unsigned __int8 v119; 
  unsigned __int8 v120; 
  unsigned __int8 v121; 
  unsigned __int8 v122; 
  unsigned __int8 v123; 
  unsigned __int8 v124; 

  _RAX = &retaddr;
  __asm
  {
    vmovss  dword ptr [rax+18h], xmm2
    vmovss  dword ptr [rax+10h], xmm1
  }
  _RBP = &v114;
  v112 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmm8, xmm2
    vmovaps xmm9, xmm1
  }
  array = NULL;
  v109 = 0;
  v110 = 0x80000000;
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  ThreadId = Physics_GetThreadId();
  v20 = 0;
  if ( !s_havokPhysicsShapeCachesDisabled[ThreadId] )
    v20 = (char)useCache.__vftable;
  v21 = 0;
  v22 = NULL;
  if ( !v20 )
    goto LABEL_17;
  v23 = ((g_crc32Table[(unsigned __int8)~center->m_quad.m128_i8[0]] ^ 0xFFFFFF) >> 8) ^ g_crc32Table[center->m_quad.m128_u8[1] ^ (unsigned __int64)(unsigned __int8)~LOBYTE(g_crc32Table[(unsigned __int8)~center->m_quad.m128_i8[0]])];
  v24 = (v23 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[2] ^ (unsigned __int64)(unsigned __int8)v23];
  v25 = (v24 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[3] ^ (unsigned __int64)(unsigned __int8)v24];
  v26 = (v25 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[4] ^ (unsigned __int64)(unsigned __int8)v25];
  v27 = (v26 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[5] ^ (unsigned __int64)(unsigned __int8)v26];
  v28 = (v27 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[6] ^ (unsigned __int64)(unsigned __int8)v27];
  v29 = (v28 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[7] ^ (unsigned __int64)(unsigned __int8)v28];
  v30 = (v29 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[8] ^ (unsigned __int64)(unsigned __int8)v29];
  v31 = (v30 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[9] ^ (unsigned __int64)(unsigned __int8)v30];
  v32 = (v31 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[10] ^ (unsigned __int64)(unsigned __int8)v31];
  v33 = (v32 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[11] ^ (unsigned __int64)(unsigned __int8)v32];
  v34 = (v33 >> 8) ^ g_crc32Table[v117 ^ (unsigned __int64)(unsigned __int8)v33];
  v35 = (v34 >> 8) ^ g_crc32Table[v118 ^ (unsigned __int64)(unsigned __int8)v34];
  v36 = (v35 >> 8) ^ g_crc32Table[v119 ^ (unsigned __int64)(unsigned __int8)v35];
  v37 = (v36 >> 8) ^ g_crc32Table[v120 ^ (unsigned __int64)(unsigned __int8)v36];
  v38 = (v37 >> 8) ^ g_crc32Table[v121 ^ (unsigned __int64)(unsigned __int8)v37];
  v39 = (v38 >> 8) ^ g_crc32Table[v122 ^ (unsigned __int64)(unsigned __int8)v38];
  v40 = (v39 >> 8) ^ g_crc32Table[v123 ^ (unsigned __int64)(unsigned __int8)v39];
  v41 = (v40 >> 8) ^ g_crc32Table[v124 ^ (unsigned __int64)(unsigned __int8)v40];
  v42 = (v41 >> 8) ^ g_crc32Table[(unsigned __int8)numVertices ^ (unsigned __int64)(unsigned __int8)v41];
  v43 = (v42 >> 8) ^ g_crc32Table[BYTE1(numVertices) ^ (unsigned __int64)(unsigned __int8)v42];
  v44 = (v43 >> 8) ^ g_crc32Table[BYTE2(numVertices) ^ (unsigned __int64)(unsigned __int8)v43];
  v21 = ~((v44 >> 8) ^ g_crc32Table[HIBYTE(numVertices) ^ (unsigned __int64)(unsigned __int8)v44]);
  v22 = s_havokPhysicsShapeCaches[ThreadId];
  if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15897, ASSERT_TYPE_ASSERT, "(cache)", "%s\n\tHavokPhysics_CreateShapeCylinder: Cache is invalid", "cache") )
    __debugbreak();
  m_hashMod = v22->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v46 = _byteswap_ulong(-1640531535 * v21), v47 = _byteswap_ulong(0), v48 = m_hashMod & (v47 ^ ((v46 >> 2) + v46 + (v47 << 6) - 1640531527)), v49 = v48, key = v22->m_map.m_elem[v48].key, key == -1i64) )
  {
LABEL_11:
    v49 = m_hashMod + 1;
  }
  else
  {
    while ( key != v21 )
    {
      v48 = m_hashMod & (v48 + 1);
      v49 = v48;
      key = v22->m_map.m_elem[v48].key;
      if ( key == -1i64 )
        goto LABEL_11;
    }
  }
  if ( v49 <= m_hashMod )
  {
    val = (hknpConvexShape *)v22->m_map.m_elem[v49].val;
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15909, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    hkReferencedObject::addReference(val);
  }
  else
  {
LABEL_17:
    v52 = hkMemHeapAllocator();
    if ( (v110 & 0x3FFFFFFF) >= numVertices )
    {
      v55.m_code = 0;
    }
    else
    {
      v53 = 2 * (v110 & 0x3FFFFFFF);
      if ( (unsigned int)v53 >= 0x3FFFFFFF )
        v53 = 1073741822;
      v54 = numVertices;
      if ( numVertices < v53 )
        v54 = v53;
      v55.m_code = hkArrayUtil::_reserve(v52, &array, v54, 16).m_code;
    }
    LODWORD(useCache.__vftable) = v55;
    v56 = (const __m128 *)(unsigned int)(numVertices >> 31);
    v57 = numVertices / 2;
    v58 = numVertices / 2;
    v59 = 0;
    if ( v57 > 0 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vmovss  xmm0, cs:__real@3f800000
        vdivss  xmm10, xmm0, xmm1
        vxorps  xmm11, xmm9, cs:__xmm@80000000800000008000000080000000
        vmovss  xmm12, cs:__real@40c90fdb
      }
      do
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ebx
          vmulss  xmm1, xmm0, xmm12
          vmulss  xmm6, xmm1, xmm10
          vmovss  dword ptr [rbp+80h], xmm6
          vmovups xmmword ptr [rsp+158h+result], xmm6
        }
        hkMath::quadSin(&result, v56);
        __asm
        {
          vmulss  xmm7, xmm0, xmm8
          vmovss  dword ptr [rbp+80h], xmm6
          vmovups xmmword ptr [rsp+158h+result], xmm6
        }
        hkMath::quadCos(&result, v71);
        __asm
        {
          vmulss  xmm1, xmm0, xmm8
          vxorps  xmm2, xmm2, xmm2
          vinsertps xmm2, xmm2, xmm7, 0
          vinsertps xmm2, xmm2, xmm1, 10h
          vinsertps xmm2, xmm2, xmm11, 20h ; ' '
          vxorps  xmm3, xmm3, xmm3
          vinsertps xmm3, xmm3, xmm7, 0
          vinsertps xmm3, xmm3, xmm1, 10h
          vinsertps xmm3, xmm3, xmm9, 20h ; ' '
        }
        v78 = (int)v109++;
        _RAX = &array[16 * v78];
        __asm
        {
          vaddps  xmm0, xmm2, xmmword ptr [rsi]
          vmovups xmmword ptr [rax], xmm0
        }
        v81 = (int)v109++;
        _RAX = &array[16 * v81];
        __asm
        {
          vaddps  xmm0, xmm3, xmmword ptr [rsi]
          vmovups xmmword ptr [rax], xmm0
        }
        ++v59;
      }
      while ( v59 < v58 );
    }
    configInOrg.m_shrinkByRadius.m_bool = 0;
    __asm
    {
      vxorps  xmm1, xmm1, xmm1; convexRadius
      vmovss  [rsp+158h+configInOrg.m_simplificationTolerance], xmm1
    }
    result.m128_u64[0] = (unsigned __int64)array;
    result.m128_u64[1] = v109 | 0x1000000000i64;
    val = hknpConvexShape::createFromVertices((const hkStridedVertices *)&result, *(float *)&_XMM1, &configInOrg);
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15939, ASSERT_TYPE_ASSERT, "(cylinderShape)", (const char *)&queryFormat, "cylinderShape") )
      __debugbreak();
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v85 = (__int64)Value->m_heap->blockAlloc(Value->m_heap, 32i64);
    _RBX = (hkReferencedObject *)v85;
    v87 = 1;
    if ( v85 )
    {
      *(_QWORD *)(v85 + 8) = 0i64;
      *(_DWORD *)(v85 + 16) = 0x1FFFF;
      *(_QWORD *)v85 = &HavokPhysics_CylinderShapeStats::`vftable';
    }
    else
    {
      _RBX = NULL;
    }
    __asm
    {
      vmovss  dword ptr [rbx+18h], xmm8
      vmulss  xmm0, xmm9, cs:__real@40000000
      vmovss  dword ptr [rbx+1Ch], xmm0
    }
    hknpShape::setProperty(val, 1u, _RBX);
    hkReferencedObject::removeReference(_RBX);
    if ( v20 )
    {
      hkReferencedObject::addReference(val);
      v89 = (unsigned int)hkMemHeapAllocator();
      v90 = v22->m_map.m_hashMod;
      v91 = v90;
      if ( 2 * v22->m_map.m_numElems > v90 )
      {
        hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v22->m_map, &useCache, v89);
        v90 = v22->m_map.m_hashMod;
        v91 = v90;
      }
      v92 = _byteswap_ulong(-1640531535 * v21);
      v93 = _byteswap_ulong(0);
      v94 = v91 & (v93 ^ ((v92 >> 2) + v92 + (v93 << 6) - 1640531527));
      m_elem = v22->m_map.m_elem;
      v96 = v22->m_map.m_elem[v94].key;
      if ( v96 != -1i64 )
      {
        while ( v96 != v21 )
        {
          v94 = v90 & (v94 + 1);
          v96 = m_elem[v94].key;
          if ( v96 == -1i64 )
            goto LABEL_43;
        }
        v87 = 0;
      }
LABEL_43:
      v22->m_map.m_numElems += v87;
      v97 = (int)v94;
      m_elem[v97].key = v21;
      v22->m_map.m_elem[v97].val = (unsigned __int64)val;
    }
  }
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  v98 = hkMemHeapAllocator();
  v109 = 0;
  if ( v110 >= 0 )
    hkMemoryAllocator::bufFree2(v98, array, 16, v110 & 0x3FFFFFFF);
  v99 = val;
  _R11 = &v115;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
  return v99;
}

/*
==============
HavokPhysics_CreateShapeSphere
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeSphere(const hkVector4f *center, double radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  hknpShape *v9; 
  hknpSphereShape *v11; 
  hknpShape *v13; 
  bool v14; 
  bool v15; 
  hknpShape *result; 
  double v21; 
  double v22; 
  void *retaddr; 
  int shapeSizeOut; 
  char *v26; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmm6, xmm1
  }
  if ( optionalInplaceBuffer )
  {
    v26 = optionalInplaceBuffer;
    __asm { vmovaps xmm2, xmm1; radius }
    hknpSphereShape::hknpSphereShape((hknpSphereShape *)optionalInplaceBuffer, center, *(float *)&_XMM2);
    _RBX = v9;
    v9->m_memSizeAndFlags = 0;
  }
  else
  {
    v11 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
    v26 = (char *)v11;
    if ( v11 )
    {
      __asm { vmovaps xmm2, xmm6; radius }
      hknpSphereShape::hknpSphereShape(v11, center, *(float *)&_XMM2);
      _RBX = v13;
    }
    else
    {
      _RBX = NULL;
    }
    _RBX->m_memSizeAndFlags = shapeSizeOut;
  }
  v14 = _RBX == NULL;
  if ( !_RBX )
  {
    v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15558, ASSERT_TYPE_ASSERT, "(sphereShape)", (const char *)&queryFormat, "sphereShape");
    v14 = !v15;
    if ( v15 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+20h]
    vucomiss xmm1, xmm6
  }
  if ( !v14 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+98h+var_58], xmm0
      vmovsd  [rsp+98h+var_60], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v21, v22) )
      __debugbreak();
  }
  result = _RBX;
  __asm { vmovaps xmm6, [rsp+98h+var_18] }
  return result;
}

/*
==============
HavokPhysics_CreateWorld
==============
*/

void __fastcall HavokPhysics_CreateWorld(Physics_WorldId worldId, Physics_WorldCInfo *worldCInfo, double _XMM2_8, double _XMM3_8)
{
  unsigned __int64 v8; 
  hkMemoryRouter *Value; 
  hkFixedBlockStreamAllocator *v11; 
  hkFixedBlockStreamAllocator *v12; 
  hkMemoryRouter *v13; 
  HavokPhysicsCollisionFilter *v14; 
  HavokPhysicsCollisionFilter *v15; 
  hkMemoryRouter *v16; 
  HavokPhysicsCollisionFilter *v17; 
  HavokPhysicsCollisionFilter *v18; 
  hkMemoryRouter *v19; 
  __int64 v20; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *v21; 
  __int64 maxRagdolls; 
  hkMemoryAllocator *v23; 
  int v24; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v25; 
  unsigned int v26; 
  __int64 v27; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v28; 
  int v29; 
  hkDefaultTaskQueue *v30; 
  bool isMultithreaded; 
  hkMemoryRouter *v32; 
  hkDefaultTaskQueue *v33; 
  hknpCollisionFilter *simulationCollisionFilter; 
  hkMemoryRouter *v55; 
  hknpWorld *v56; 
  hknpWorld *v57; 
  hknpCollisionQueryDispatcher *m_object; 
  int v59; 
  __int64 v60; 
  const hknpShapeType::Enum *m_baseTypeMap; 
  hknpCollisionQueryDispatcher *v62; 
  int v63; 
  __int64 v64; 
  __int64 v65; 
  const hknpShapeType::Enum *v66; 
  __int64 v67; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  hknpModifier *v69; 
  __int64 v70; 
  __int64 v71; 
  hkMemoryRouter *v72; 
  HavokPhysics_CollisionQueryDispatcher *v73; 
  __int64 v74; 
  __int64 v75; 
  hkMemoryRouter *v76; 
  __int64 v77; 
  __int64 v78; 
  int v79; 
  hkMemoryAllocator *v80; 
  int v81; 
  int v82; 
  void *v83; 
  unsigned int v84; 
  hkMemoryRouter *v85; 
  __int64 v86; 
  __int64 v87; 
  int v88; 
  hkMemoryAllocator *v89; 
  int v90; 
  int v91; 
  void *v92; 
  unsigned int v93; 
  __int64 v94; 
  __int64 v95; 
  hkMemoryRouter *v96; 
  __int64 v97; 
  hkMemoryRouter *v98; 
  __int64 v99; 
  hkMemoryRouter *v100; 
  __int64 v101; 
  hkMemoryRouter *v102; 
  __int64 v103; 
  hkMemoryRouter *v104; 
  __int64 v105; 
  hkMemoryRouter *v106; 
  __int64 v107; 
  __int64 v108; 
  __int64 v109; 
  hkMemoryRouter *v110; 
  __int64 v111; 
  hkMemoryRouter *v112; 
  __int64 v113; 
  hkMemoryRouter *v114; 
  __int64 v115; 
  hkMemoryRouter *v116; 
  __int64 v117; 
  hkMemoryRouter *v118; 
  __int64 v119; 
  _DWORD *v120; 
  __int64 v121; 
  hkMemoryRouter *v122; 
  __int64 v123; 
  hkMemoryRouter *v124; 
  __int64 v125; 
  hkProcessContext *v126; 
  hkMemoryAllocator *v127; 
  int m_size; 
  hkMemoryRouter *v129; 
  hknpProcessContext *v130; 
  __int64 v131; 
  hkProcessFactory *m_ptr; 
  __int64 v133; 
  hkProcessContext *v134; 
  hkMemoryAllocator *v135; 
  int v136; 
  hkMemoryRouter *v137; 
  hclClothContext *v138; 
  __int64 v139; 
  __int64 v140; 
  hkProcessContext *v141; 
  hkMemoryAllocator *v142; 
  int v143; 
  hkMemoryRouter *v144; 
  hkVisualDebugger *v145; 
  __int64 v146; 
  hkMemoryRouter *v147; 
  __int64 v148; 
  __int64 v149; 
  hkMemoryRouter *v150; 
  hkServerObjectSerializer *v151; 
  __int64 v152; 
  hkMemoryRouter *v153; 
  hkServerObjectHandler *v154; 
  __int64 v155; 
  hkMemoryRouter *v156; 
  HavokPhysicsProcessHandler *v157; 
  __int64 v158; 
  hkMemoryRouter *v159; 
  __int64 v160; 
  hknpSphereShape *v162; 
  bool v164; 
  __int64 v166; 
  hknpSphereShape *v171; 
  bool v172; 
  __int64 v174; 
  unsigned int i; 
  hkMemoryRouter *v179; 
  __int64 v180; 
  __int64 v181; 
  unsigned __int8 *WeaponPriorityMap; 
  __int64 v183; 
  __int64 v184; 
  HavokPhysicsWorld *MutableWorld; 
  hknpEventSignal *EventSignal; 
  HavokPhysicsWorld *v187; 
  hkMemoryAllocator *v188; 
  __int64 levelA; 
  double v193; 
  double v194; 
  double v195; 
  double v196; 
  int listenPort[2]; 
  hkArray<hkProcessContext *,hkContainerHeapAllocator> array; 
  int numInOut; 
  int v200; 
  int v201; 
  int shapeSizeOut; 
  int v203; 
  HavokPhysicsWorld *v204; 
  Physics_WorldCInfo *v205; 
  hknpSphereShape *v206; 
  int v207; 
  LPCRITICAL_SECTION lpCriticalSection; 
  hkDefaultTaskQueue::Cinfo cinfo; 
  __int64 v210; 
  hkCriticalSection *p_critSection; 
  hknpWorldCinfo v212; 
  hkVector4f center; 
  char v214; 
  void *retaddr; 

  _RAX = &retaddr;
  v210 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R12 = worldCInfo;
  v205 = worldCInfo;
  v8 = worldId;
  shapeSizeOut = worldId;
  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3088, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to CreateWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_R12 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3089, ASSERT_TYPE_ASSERT, "(worldCInfo)", "%s\n\tHavokPhysics CreateWorld %i: WorldCInfo is NULL", "worldCInfo", levelA) )
      __debugbreak();
  }
  _RBX = HavokPhysics_GetMutableWorld((Physics_WorldId)v8);
  v204 = _RBX;
  lpCriticalSection = (LPCRITICAL_SECTION)&_RBX->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&_RBX->critSection);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v11 = (hkFixedBlockStreamAllocator *)Value->m_heap->blockAlloc(Value->m_heap, 112i64);
  *(_QWORD *)listenPort = v11;
  if ( v11 )
    hkFixedBlockStreamAllocator::hkFixedBlockStreamAllocator(v11, 0);
  else
    v12 = NULL;
  _RBX->persistentStreamAllocator = v12;
  if ( !v12 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3099, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics CreateWorld %i: persistent stream allocator failed to create", "havokPhysicsWorld->persistentStreamAllocator", levelA) )
      __debugbreak();
  }
  hkFixedBlockStreamAllocator::init(_RBX->persistentStreamAllocator, _R12->persistentBuffer, _R12->persistentBufferSize);
  v13 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v13 )
    v13 = hkMemoryRouter::s_fallbackRouter;
  v14 = (HavokPhysicsCollisionFilter *)v13->m_heap->blockAlloc(v13->m_heap, 56i64);
  *(_QWORD *)listenPort = v14;
  if ( v14 )
    HavokPhysicsCollisionFilter::HavokPhysicsCollisionFilter(v14, (Physics_WorldId)v8, COLLISIONFILTERTYPE_TRACE);
  else
    v15 = NULL;
  _RBX->traceCollisionFilter = v15;
  if ( !v15 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3105, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter)", "%s\n\tHavokPhysics CreateWorld %i: trace collision filter failed to create", "havokPhysicsWorld->traceCollisionFilter", levelA) )
      __debugbreak();
  }
  v16 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v16 )
    v16 = hkMemoryRouter::s_fallbackRouter;
  v17 = (HavokPhysicsCollisionFilter *)v16->m_heap->blockAlloc(v16->m_heap, 56i64);
  *(_QWORD *)listenPort = v17;
  if ( v17 )
    HavokPhysicsCollisionFilter::HavokPhysicsCollisionFilter(v17, (Physics_WorldId)v8, COLLISIONFILTERTYPE_SIMULATION);
  else
    v18 = NULL;
  _RBX->simulationCollisionFilter = v18;
  if ( !v18 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3107, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter)", "%s\n\tHavokPhysics CreateWorld %i: simulation collision filter failed to create", "havokPhysicsWorld->simulationCollisionFilter", levelA) )
      __debugbreak();
  }
  _RBX->isMultithreaded = _R12->isMultiThreaded;
  _RBX->hasFXSupport = _R12->hasFXSupport;
  if ( _R12->maxRagdolls <= 0 )
  {
    _RBX->m_ragdollConstraintGroupId = NULL;
  }
  else
  {
    v19 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v19 )
      v19 = hkMemoryRouter::s_fallbackRouter;
    v20 = (__int64)v19->m_heap->blockAlloc(v19->m_heap, 16i64);
    v21 = (hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *)v20;
    *(_QWORD *)listenPort = v20;
    if ( v20 )
    {
      v207 = 0x7FFFFFFF;
      maxRagdolls = _R12->maxRagdolls;
      *(_QWORD *)v20 = 0i64;
      *(_DWORD *)(v20 + 8) = 0;
      *(_DWORD *)(v20 + 12) = 0x80000000;
      numInOut = maxRagdolls;
      v23 = hkMemHeapAllocator();
      v24 = maxRagdolls;
      if ( (_DWORD)maxRagdolls )
      {
        v25 = (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *)hkMemoryAllocator::bufAlloc2(v23, 4, &numInOut);
        v24 = numInOut;
      }
      else
      {
        v25 = NULL;
      }
      v26 = 0x80000000;
      if ( v24 )
        v26 = v24;
      v21->m_data = v25;
      v21->m_size = maxRagdolls;
      v21->m_capacityAndFlags = v26;
      v27 = maxRagdolls;
      if ( (int)maxRagdolls > 0 )
      {
        v28 = v25;
        while ( v27 )
        {
          v28->m_value = 0x7FFFFFFF;
          ++v28;
          --v27;
        }
      }
    }
    else
    {
      v21 = NULL;
    }
    _RBX->m_ragdollConstraintGroupId = v21;
  }
  _RBX->defaultTimeStep = _R12->defaultTimeStep;
  _RBX->timeStepHistory[0] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[1] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[2] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[3] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[4] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[5] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[6] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[7] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[8] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[9] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[10] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[11] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[12] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[13] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[14] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[15] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[16] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[17] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[18] = _R12->defaultTimeStep;
  _RBX->timeStepHistory[19] = _R12->defaultTimeStep;
  _RBX->timeStepHistoryStart = 0;
  _RBX->timeStep = _R12->defaultTimeStep;
  v29 = 1;
  if ( _RBX->isMultithreaded )
    v29 = 4;
  _RBX->stepInput.m_numThreads = v29;
  *(_QWORD *)&cinfo.m_schedulingMode = 0i64;
  cinfo.m_maxNumThreads = 64;
  cinfo.m_asyncThreadPool = NULL;
  if ( _RBX->isMultithreaded || _RBX->hasFXSupport )
  {
    v32 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v32 )
      v32 = hkMemoryRouter::s_fallbackRouter;
    v33 = (hkDefaultTaskQueue *)v32->m_heap->blockAlloc(v32->m_heap, 912i64);
    *(_QWORD *)listenPort = v33;
    if ( v33 )
      hkDefaultTaskQueue::hkDefaultTaskQueue(v33, &cinfo);
    else
      v30 = NULL;
    isMultithreaded = _RBX->isMultithreaded;
  }
  else
  {
    v30 = NULL;
    isMultithreaded = 0;
  }
  _RBX->taskQueue = v30;
  if ( isMultithreaded && !v30 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3145, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics CreateWorld %i: task queue failed to create", "!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue", levelA) )
      __debugbreak();
  }
  if ( !_RBX->isMultithreaded && !_RBX->hasFXSupport )
  {
    if ( _RBX->taskQueue )
    {
      LODWORD(levelA) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3146, ASSERT_TYPE_ASSERT, "(( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics CreateWorld %i: task queue should be null here", "( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue", levelA) )
        __debugbreak();
    }
  }
  HavokPhysicsInstanceManager_Init(&_RBX->instanceManager, _R12->systemCountMax);
  hknpWorldCinfo::hknpWorldCinfo(&v212);
  v212.m_blockStreamAllocator = _RBX->persistentStreamAllocator;
  v212.m_bodyBufferCapacity = _R12->bodyCountMax;
  v212.m_userBodyBuffer = NULL;
  v212.m_motionBufferCapacity = _R12->motionCountMax;
  v212.m_userMotionBuffer = NULL;
  v212.m_constraintBufferCapacity = _R12->constraintCountMax;
  v212.m_userConstraintBuffer = NULL;
  v212.m_constraintGroupBufferCapacity = 1;
  v212.m_userConstraintGroupBuffer = NULL;
  v212.m_useBodyBacklinkBuffer.m_bool = 0;
  if ( v212.m_materialLibrary.m_ptr )
    hkReferencedObject::removeReference(v212.m_materialLibrary.m_ptr);
  v212.m_materialLibrary.m_ptr = NULL;
  if ( v212.m_motionPropertiesLibrary.m_ptr )
    hkReferencedObject::removeReference(v212.m_motionPropertiesLibrary.m_ptr);
  v212.m_motionPropertiesLibrary.m_ptr = NULL;
  if ( v212.m_qualityLibrary.m_ptr )
    hkReferencedObject::removeReference(v212.m_qualityLibrary.m_ptr);
  v212.m_qualityLibrary.m_ptr = NULL;
  v212.m_simulationType.m_storage = _RBX->isMultithreaded;
  v212.m_numSplitterCells = 32;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+2Ch]
    vmulss  xmm1, xmm0, cs:__real@bd000000
    vxorps  xmm2, xmm2, xmm2
    vinsertps xmm2, xmm2, xmm1, 20h ; ' '
    vmovups xmmword ptr [rbp+180h+var_1A0.m_gravity.m_quad], xmm2
  }
  *(_WORD *)&v212.m_enableContactCaching.m_bool = 257;
  v212.m_broadPhaseType.m_storage = 2;
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm1, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_min.m_quad], xmm1
    vmulss  xmm0, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+4; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_min.m_quad+4], xmm0
    vmulss  xmm2, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+8; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_min.m_quad+8], xmm2
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_min.m_quad+0Ch], xmm3
    vmulss  xmm1, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_max.m_quad], xmm1
    vmulss  xmm0, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+4; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_max.m_quad+4], xmm0
    vmulss  xmm2, xmm6, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+8; clipMap_t cm
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_max.m_quad+8], xmm2
    vmovss  dword ptr [rbp+180h+var_1A0.m_broadPhaseAabb.m_max.m_quad+0Ch], xmm3
  }
  if ( v212.m_broadPhaseConfig.m_ptr )
    hkReferencedObject::removeReference(v212.m_broadPhaseConfig.m_ptr);
  v212.m_broadPhaseConfig.m_ptr = NULL;
  simulationCollisionFilter = _RBX->simulationCollisionFilter;
  if ( simulationCollisionFilter )
    hkReferencedObject::addReference(_RBX->simulationCollisionFilter);
  if ( v212.m_collisionFilter.m_ptr )
    hkReferencedObject::removeReference(v212.m_collisionFilter.m_ptr);
  v212.m_collisionFilter.m_ptr = simulationCollisionFilter;
  if ( v212.m_shapeTagCodec.m_ptr )
    hkReferencedObject::removeReference(v212.m_shapeTagCodec.m_ptr);
  v212.m_shapeTagCodec.m_ptr = NULL;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [r12+1Ch]
    vmovss  [rbp+180h+var_1A0.m_collisionTolerance], xmm1
    vmovss  xmm2, dword ptr [r12+20h]
    vmovss  [rbp+180h+var_1A0.m_relativeCollisionAccuracy], xmm2
    vmulss  xmm1, xmm6, dword ptr [r12+24h]
    vmovss  [rbp+180h+var_1A0.m_aabbMargin], xmm1
  }
  *(_WORD *)&v212.m_enableWeldingForDefaultObjects.m_bool = 0;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [r12+28h]
    vmovss  [rbp+180h+var_1A0.m_weldingConfig.m_relativeGhostPlaneThreshold], xmm1
  }
  *(_WORD *)&v212.m_lodManagerCinfo.m_registerDefaultConfig.m_bool = 0;
  v212.m_lodManagerCinfo.m_autoBuildLodOnMeshBodyAdded.m_bool = 0;
  *(_WORD *)&v212.m_enableSdfEdgeCollisions.m_bool = 256;
  v212.m_particlesLandscapeQuadCacheSize = 4096;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+34h]
    vmovss  [rbp+180h+var_1A0.m_solverTau], xmm0
    vmovss  xmm1, dword ptr [r12+38h]
    vmovss  [rbp+180h+var_1A0.m_solverDamp], xmm1
  }
  v212.m_solverIterations = _R12->solverIterations;
  v212.m_solverMicrosteps = 1;
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rbp+180h+var_1A0.m_maxApproachSpeedForHighQualitySolver], xmm6
  }
  v212.m_enableDeactivation.m_bool = !Physics_IsQueryWorld((Physics_WorldId)v8);
  v212.m_enablePenetrationRecovery.m_bool = !Physics_IsQueryWorld((Physics_WorldId)v8);
  __asm { vmovss  [rbp+180h+var_1A0.m_maxApproachSpeedForHighQualitySolver], xmm6 }
  v212.m_adjustSolverSettingsBasedOnTimestep.m_bool = _R12->adjustSolverSettingsOnTimestep;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+2Ch]
    vmovss  [rbp+180h+var_1A0.m_expectedDeltaTime], xmm0
  }
  v212.m_minSolverIterations = 1;
  v212.m_maxSolverIterations = v212.m_solverIterations;
  v55 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v55 )
    v55 = hkMemoryRouter::s_fallbackRouter;
  v56 = (hknpWorld *)v55->m_heap->blockAlloc(v55->m_heap, 2992i64);
  *(_QWORD *)listenPort = v56;
  if ( v56 )
    hknpWorld::hknpWorld(v56, &v212);
  else
    v57 = NULL;
  _RBX->world = v57;
  if ( !v57 )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3242, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics CreateWorld %i: world failed to create", "havokPhysicsWorld->world", levelA) )
      __debugbreak();
  }
  _RBX->world->m_userData = v8;
  m_object = _RBX->world->m_particlesCollidersManager.m_object->m_particleQueryDispatcher.m_object;
  v59 = 0;
  v60 = 0i64;
  do
  {
    m_baseTypeMap = m_object->m_closestPointsDispatchTable.m_baseTypeMap;
    if ( m_baseTypeMap[v60] == NOP )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&m_object->m_closestPointsDispatchTable, (hknpShapeType::Enum)v59, USER_7|DISTANCE_FIELD, HavokPhysics_Particles_ConvexVsStaticModelTile, "HavokPhysics_Particles_ConvexVsStaticModelTile", 0xFFFFFFFF, 1);
      m_baseTypeMap = m_object->m_closestPointsDispatchTable.m_baseTypeMap;
    }
    if ( m_baseTypeMap[v60] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&m_object->m_closestPointsDispatchTable, NOP, (hknpShapeType::Enum)v59, HavokPhysics_Particles_ConvexVsStaticModelTile, "HavokPhysics_Particles_ConvexVsStaticModelTile", 0xFFFFFFFF, 1);
    ++v59;
    ++v60;
  }
  while ( v59 < 30 );
  m_object->m_closestPointsDispatchTable.m_dispatchTable[0][22] = HavokPhysics_Particles_ConvexVsStaticModelTile;
  v62 = v204->world->m_particlesCollidersManager.m_object->m_particleQueryDispatcher.m_object;
  v63 = 0;
  v64 = 0i64;
  v65 = (__int64)v205;
  do
  {
    v66 = v62->m_closestPointsDispatchTable.m_baseTypeMap;
    if ( v66[v64] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&v62->m_closestPointsDispatchTable, (hknpShapeType::Enum)v63, NOP, HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_, "HavokPhysics_Particles_Flip<HavokPhysics_Particles_ConvexVsStaticModelTile>", 0xFFFFFFFF, 1);
      v66 = v62->m_closestPointsDispatchTable.m_baseTypeMap;
    }
    if ( v66[v64] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&v62->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v63, HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_, "HavokPhysics_Particles_Flip<HavokPhysics_Particles_ConvexVsStaticModelTile>", 0xFFFFFFFF, 1);
    ++v63;
    ++v64;
  }
  while ( v63 < 30 );
  v62->m_closestPointsDispatchTable.m_dispatchTable[22][0] = HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_;
  v67 = (__int64)v204;
  hknpWorld::setIWProfileCallbacks(v204->world, HavokPhysics_ProfileStart, HavokPhysics_ProfileEnd);
  UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(*(const hknpWorld **)(v67 + 24));
  UndecoratedBroadPhase->m_world = *(hknpWorld **)(v67 + 24);
  UndecoratedBroadPhase->m_worldId = v8;
  if ( Physics_IsQueryWorld((Physics_WorldId)v8) )
  {
    *(_QWORD *)(v67 + 264) = 0i64;
  }
  else
  {
    v69 = PhysicsGravityModifier_Create((const Physics_WorldId)v8);
    *(_QWORD *)(v67 + 264) = v69;
    v70 = *(_QWORD *)(v67 + 24);
    LODWORD(v206) = 0x10000;
    hknpModifierManager::addModifier(*(hknpModifierManager **)(v70 + 1200), (hknpCollisionFlags)0x10000, v69, PRIORITY_LOWER);
  }
  if ( !*(_QWORD *)(*(_QWORD *)(v67 + 24) + 1568i64) )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3265, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->m_collisionQueryDispatcher)", "%s\n\tHavokPhysics CreateWorld %i: world default collision query dispatcher didn't exist", "havokPhysicsWorld->world->m_collisionQueryDispatcher", levelA) )
      __debugbreak();
  }
  v71 = *(_QWORD *)(*(_QWORD *)(v67 + 24) + 1568i64);
  if ( v71 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v71 + 8i64))(v71, 1i64);
  v72 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v72 )
    v72 = hkMemoryRouter::s_fallbackRouter;
  v73 = (HavokPhysics_CollisionQueryDispatcher *)v72->m_heap->blockAlloc(v72->m_heap, 15080i64);
  *(_QWORD *)listenPort = v73;
  if ( v73 )
  {
    HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(v73);
    v75 = v74;
  }
  else
  {
    v75 = 0i64;
  }
  *(_QWORD *)(*(_QWORD *)(v67 + 24) + 1568i64) = v75;
  if ( !*(_QWORD *)(*(_QWORD *)(v67 + 24) + 1568i64) )
  {
    LODWORD(levelA) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3268, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->m_collisionQueryDispatcher)", "%s\n\tHavokPhysics CreateWorld %i: world collision query dispatcher failed to create", "havokPhysicsWorld->world->m_collisionQueryDispatcher", levelA) )
      __debugbreak();
  }
  HavokPhysics_AddBodyQualityLibraryToWorld(&s_havokPhysicsBodyQualityLibrary, (Physics_WorldId)v8);
  HavokPhysics_AddMaterialLibraryToWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)v8);
  HavokPhysics_AddMotionPropertiesLibraryToWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)v8);
  if ( *(_QWORD *)(v67 + 248) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3277, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->bodySFXEventAssets)", (const char *)&queryFormat, "!havokPhysicsWorld->bodySFXEventAssets") )
    __debugbreak();
  v76 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v76 )
    v76 = hkMemoryRouter::s_fallbackRouter;
  v77 = (__int64)v76->m_heap->blockAlloc(v76->m_heap, 16i64);
  v78 = v77;
  *(_QWORD *)listenPort = v77;
  if ( v77 )
  {
    v79 = *(_DWORD *)(v65 + 4);
    *(_QWORD *)v77 = 0i64;
    *(_DWORD *)(v77 + 8) = 0;
    *(_DWORD *)(v77 + 12) = 0x80000000;
    v200 = v79;
    v80 = hkMemHeapAllocator();
    v81 = v200;
    v82 = v200;
    if ( v200 )
    {
      v83 = hkMemoryAllocator::bufAlloc2(v80, 8, &v200);
      v81 = v200;
    }
    else
    {
      v83 = NULL;
    }
    v84 = 0x80000000;
    if ( v81 )
      v84 = v81;
    *(_QWORD *)v78 = v83;
    *(_DWORD *)(v78 + 8) = v82;
    *(_DWORD *)(v78 + 12) = v84;
  }
  else
  {
    v78 = 0i64;
  }
  *(_QWORD *)(v67 + 248) = v78;
  if ( *(_QWORD *)(v67 + 256) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3279, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->bodyVFXEventAssets)", (const char *)&queryFormat, "!havokPhysicsWorld->bodyVFXEventAssets") )
    __debugbreak();
  v85 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v85 )
    v85 = hkMemoryRouter::s_fallbackRouter;
  v86 = (__int64)v85->m_heap->blockAlloc(v85->m_heap, 16i64);
  v87 = v86;
  *(_QWORD *)listenPort = v86;
  if ( v86 )
  {
    v88 = *(_DWORD *)(v65 + 4);
    *(_QWORD *)v86 = 0i64;
    *(_DWORD *)(v86 + 8) = 0;
    *(_DWORD *)(v86 + 12) = 0x80000000;
    v201 = v88;
    v89 = hkMemHeapAllocator();
    v90 = v201;
    v91 = v201;
    if ( v201 )
    {
      v92 = hkMemoryAllocator::bufAlloc2(v89, 8, &v201);
      v90 = v201;
    }
    else
    {
      v92 = NULL;
    }
    v93 = 0x80000000;
    if ( v90 )
      v93 = v90;
    *(_QWORD *)v87 = v92;
    *(_DWORD *)(v87 + 8) = v91;
    *(_DWORD *)(v87 + 12) = v93;
  }
  else
  {
    v87 = 0i64;
  }
  *(_QWORD *)(v67 + 256) = v87;
  *(_DWORD *)(v67 + 272) = 0;
  v94 = 296i64;
  v95 = 2i64;
  do
  {
    if ( *(_QWORD *)(v94 + v67 - 16) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3287, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx]") )
      __debugbreak();
    v96 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v96 )
      v96 = hkMemoryRouter::s_fallbackRouter;
    v97 = (__int64)v96->m_heap->blockAlloc(v96->m_heap, 16i64);
    if ( v97 )
    {
      *(_QWORD *)v97 = 0i64;
      *(_DWORD *)(v97 + 8) = 0;
      *(_DWORD *)(v97 + 12) = 0x80000000;
    }
    else
    {
      v97 = 0i64;
    }
    *(_QWORD *)(v94 + v67 - 16) = v97;
    if ( *(_QWORD *)(v94 + v67) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3290, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->aabbQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->aabbQueryRequestLists[bufferIdx]") )
      __debugbreak();
    v98 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v98 )
      v98 = hkMemoryRouter::s_fallbackRouter;
    v99 = (__int64)v98->m_heap->blockAlloc(v98->m_heap, 16i64);
    if ( v99 )
    {
      *(_QWORD *)v99 = 0i64;
      *(_DWORD *)(v99 + 8) = 0;
      *(_DWORD *)(v99 + 12) = 0x80000000;
    }
    else
    {
      v99 = 0i64;
    }
    *(_QWORD *)(v94 + v67) = v99;
    if ( *(_QWORD *)(v94 + v67 + 16) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3293, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->raycastRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->raycastRequestLists[bufferIdx]") )
      __debugbreak();
    v100 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v100 )
      v100 = hkMemoryRouter::s_fallbackRouter;
    v101 = (__int64)v100->m_heap->blockAlloc(v100->m_heap, 16i64);
    if ( v101 )
    {
      *(_QWORD *)v101 = 0i64;
      *(_DWORD *)(v101 + 8) = 0;
      *(_DWORD *)(v101 + 12) = 0x80000000;
    }
    else
    {
      v101 = 0i64;
    }
    *(_QWORD *)(v94 + v67 + 16) = v101;
    if ( *(_QWORD *)(v94 + v67 + 32) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3296, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->shapecastRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->shapecastRequestLists[bufferIdx]") )
      __debugbreak();
    v102 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v102 )
      v102 = hkMemoryRouter::s_fallbackRouter;
    v103 = (__int64)v102->m_heap->blockAlloc(v102->m_heap, 16i64);
    if ( v103 )
    {
      *(_QWORD *)v103 = 0i64;
      *(_DWORD *)(v103 + 8) = 0;
      *(_DWORD *)(v103 + 12) = 0x80000000;
    }
    else
    {
      v103 = 0i64;
    }
    *(_QWORD *)(v94 + v67 + 32) = v103;
    if ( *(_QWORD *)(v94 + v67 + 48) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3299, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->queryPointRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->queryPointRequestLists[bufferIdx]") )
      __debugbreak();
    v104 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v104 )
      v104 = hkMemoryRouter::s_fallbackRouter;
    v105 = (__int64)v104->m_heap->blockAlloc(v104->m_heap, 16i64);
    if ( v105 )
    {
      *(_QWORD *)v105 = 0i64;
      *(_DWORD *)(v105 + 8) = 0;
      *(_DWORD *)(v105 + 12) = 0x80000000;
    }
    else
    {
      v105 = 0i64;
    }
    *(_QWORD *)(v94 + v67 + 48) = v105;
    if ( *(_QWORD *)(v94 + v67 + 64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3302, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx]") )
      __debugbreak();
    v106 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v106 )
      v106 = hkMemoryRouter::s_fallbackRouter;
    v107 = (__int64)v106->m_heap->blockAlloc(v106->m_heap, 16i64);
    if ( v107 )
    {
      *(_QWORD *)v107 = 0i64;
      *(_DWORD *)(v107 + 8) = 0;
      *(_DWORD *)(v107 + 12) = 0x80000000;
    }
    else
    {
      v107 = 0i64;
    }
    *(_QWORD *)(v94 + v67 + 64) = v107;
    v94 += 8i64;
    --v95;
  }
  while ( v95 );
  v108 = shapeSizeOut;
  v109 = (__int64)v205;
  if ( *(_QWORD *)(v67 + 416) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3306, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->capsuleRadii)", (const char *)&queryFormat, "!havokPhysicsWorld->capsuleRadii") )
    __debugbreak();
  v110 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v110 )
    v110 = hkMemoryRouter::s_fallbackRouter;
  v111 = (__int64)v110->m_heap->blockAlloc(v110->m_heap, 16i64);
  *(_QWORD *)listenPort = v111;
  if ( v111 )
  {
    *(_QWORD *)v111 = 0i64;
    *(_DWORD *)(v111 + 8) = 0;
    *(_DWORD *)(v111 + 12) = -1;
  }
  else
  {
    v111 = 0i64;
  }
  *(_QWORD *)(v67 + 416) = v111;
  if ( *(_QWORD *)(v67 + 424) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3309, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  v112 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v112 )
    v112 = hkMemoryRouter::s_fallbackRouter;
  v113 = (__int64)v112->m_heap->blockAlloc(v112->m_heap, 16i64);
  if ( v113 )
  {
    *(_QWORD *)v113 = 0i64;
    *(_DWORD *)(v113 + 8) = 0;
    *(_DWORD *)(v113 + 12) = 0x80000000;
  }
  else
  {
    v113 = 0i64;
  }
  *(_QWORD *)(v67 + 424) = v113;
  if ( *(_QWORD *)(v67 + 432) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3312, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  v114 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v114 )
    v114 = hkMemoryRouter::s_fallbackRouter;
  v115 = (__int64)v114->m_heap->blockAlloc(v114->m_heap, 16i64);
  if ( v115 )
  {
    *(_QWORD *)v115 = 0i64;
    *(_DWORD *)(v115 + 8) = 0;
    *(_DWORD *)(v115 + 12) = 0x80000000;
  }
  else
  {
    v115 = 0i64;
  }
  *(_QWORD *)(v67 + 432) = v115;
  if ( *(_QWORD *)(v67 + 440) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3315, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  v116 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v116 )
    v116 = hkMemoryRouter::s_fallbackRouter;
  v117 = (__int64)v116->m_heap->blockAlloc(v116->m_heap, 16i64);
  if ( v117 )
  {
    *(_QWORD *)v117 = 0i64;
    *(_DWORD *)(v117 + 8) = 0;
    *(_DWORD *)(v117 + 12) = 0x80000000;
  }
  else
  {
    v117 = 0i64;
  }
  *(_QWORD *)(v67 + 440) = v117;
  if ( *(_QWORD *)(v67 + 448) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3318, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredBulletEffectEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredBulletEffectEntries") )
    __debugbreak();
  v118 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v118 )
    v118 = hkMemoryRouter::s_fallbackRouter;
  v119 = (__int64)v118->m_heap->blockAlloc(v118->m_heap, 16i64);
  if ( v119 )
  {
    *(_QWORD *)v119 = 0i64;
    *(_DWORD *)(v119 + 8) = 0;
    *(_DWORD *)(v119 + 12) = 0x80000000;
  }
  else
  {
    v119 = 0i64;
  }
  *(_QWORD *)(v67 + 448) = v119;
  *(_DWORD *)(v67 + 456) = 0;
  v120 = (_DWORD *)(v67 + 1704);
  v121 = 300i64;
  do
  {
    *(v120 - 300) = 0;
    *v120++ = 0;
    --v121;
  }
  while ( v121 );
  *(_DWORD *)(v67 + 2908) = 0;
  *(_QWORD *)(v67 + 2912) = 0i64;
  *(_QWORD *)(v67 + 2920) = 0i64;
  *(_QWORD *)(v67 + 2928) = 0i64;
  *(_QWORD *)(v67 + 2936) = 0i64;
  *(_QWORD *)(v67 + 2944) = 0i64;
  *(_QWORD *)(v67 + 2952) = 0i64;
  *(_DWORD *)(v67 + 2960) = 0;
  if ( *(_QWORD *)(v67 + 3192) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3336, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "!havokPhysicsWorld->debugLines") )
    __debugbreak();
  v122 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v122 )
    v122 = hkMemoryRouter::s_fallbackRouter;
  v123 = (__int64)v122->m_heap->blockAlloc(v122->m_heap, 16i64);
  if ( v123 )
  {
    *(_QWORD *)v123 = 0i64;
    *(_DWORD *)(v123 + 8) = 0;
    *(_DWORD *)(v123 + 12) = 0x80000000;
  }
  else
  {
    v123 = 0i64;
  }
  *(_QWORD *)(v67 + 3192) = v123;
  if ( !v123 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3338, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  v124 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v124 )
    v124 = hkMemoryRouter::s_fallbackRouter;
  v125 = (__int64)v124->m_heap->blockAlloc(v124->m_heap, 568i64);
  if ( v125 )
  {
    *(_DWORD *)(v125 + 20) = 0;
    memset_0((void *)(v125 + 48), 0, 0x208ui64);
    *(_QWORD *)(v125 + 8) = 0i64;
    *(_DWORD *)(v125 + 16) = 0x1FFFF;
    *(_QWORD *)(v125 + 32) = 0i64;
    *(_QWORD *)v125 = &hkCommonProcessContext::`vftable'{for `hkReferencedObject'};
    *(_QWORD *)(v125 + 24) = &hkCommonProcessContext::`vftable'{for `hkProcessContext'};
    *(_QWORD *)(v125 + 40) = v125 + 56;
    *(_DWORD *)(v125 + 48) = 0;
    *(_DWORD *)(v125 + 52) = -2147483616;
  }
  else
  {
    v125 = 0i64;
  }
  *(_QWORD *)(v67 + 480) = v125;
  v126 = (hkProcessContext *)(v125 + 24);
  if ( !v125 )
    v126 = NULL;
  v127 = hkMemHeapAllocator();
  m_size = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v127, &array, 8);
    m_size = array.m_size;
  }
  array.m_data[m_size] = v126;
  ++array.m_size;
  v129 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v129 )
    v129 = hkMemoryRouter::s_fallbackRouter;
  v130 = (hknpProcessContext *)v129->m_heap->blockAlloc(v129->m_heap, 128i64);
  *(_QWORD *)listenPort = v130;
  if ( v130 )
    hknpProcessContext::hknpProcessContext(v130);
  else
    v131 = 0i64;
  *(_QWORD *)(v67 + 472) = v131;
  if ( !v131 )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3346, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics CreateWorld %i: Visualization Context failed to create", "havokPhysicsWorld->visContext", levelA) )
      __debugbreak();
  }
  hknpProcessContext::registerAllProcesses();
  m_ptr = hkProcessFactory::singleton.m_ptr;
  hknpBodyIdViewer::registerViewer(hkProcessFactory::singleton.m_ptr);
  hknpMotionIdViewer::registerViewer(m_ptr);
  HavokPhysicsCollisionHeatmapViewer::registerViewer(m_ptr);
  HavokPhysicsDebugDrawViewer::registerViewer(m_ptr);
  HavokPhysicsCollisionTileViewer::registerViewer(m_ptr);
  HavokPhysicsShapeViewer::registerViewer(m_ptr);
  v133 = *(_QWORD *)(v67 + 472);
  v134 = (hkProcessContext *)(v133 + 24);
  if ( !v133 )
    v134 = NULL;
  v135 = hkMemHeapAllocator();
  v136 = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v135, &array, 8);
    v136 = array.m_size;
  }
  array.m_data[v136] = v134;
  ++array.m_size;
  if ( *(_BYTE *)(v109 + 71) )
  {
    v137 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v137 )
      v137 = hkMemoryRouter::s_fallbackRouter;
    v138 = (hclClothContext *)v137->m_heap->blockAlloc(v137->m_heap, 416i64);
    *(_QWORD *)listenPort = v138;
    if ( v138 )
      hclClothContext::hclClothContext(v138);
    else
      v139 = 0i64;
    *(_QWORD *)(v67 + 488) = v139;
    if ( !v139 )
    {
      LODWORD(levelA) = v108;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3360, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->clothVisContext)", "%s\n\tHavokPhysics CreateWorld %i: Cloth Visualization Context failed to create", "havokPhysicsWorld->clothVisContext", levelA) )
        __debugbreak();
    }
    hclClothContext::registerAllClothProcesses();
    v140 = *(_QWORD *)(v67 + 488);
    v141 = (hkProcessContext *)(v140 + 24);
    if ( !v140 )
      v141 = NULL;
    v142 = hkMemHeapAllocator();
    v143 = array.m_size;
    if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v142, &array, 8);
      v143 = array.m_size;
    }
    array.m_data[v143] = v141;
    ++array.m_size;
  }
  hknpProcessContext::addWorld(*(hknpProcessContext **)(v67 + 472), *(hknpWorld **)(v67 + 24));
  v144 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v144 )
    v144 = hkMemoryRouter::s_fallbackRouter;
  v145 = (hkVisualDebugger *)v144->m_heap->blockAlloc(v144->m_heap, 240i64);
  *(_QWORD *)listenPort = v145;
  if ( v145 )
    hkVisualDebugger::hkVisualDebugger(v145, &array, NULL);
  else
    v146 = 0i64;
  *(_QWORD *)(v67 + 496) = v146;
  if ( !v146 )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3370, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics CreateWorld %i: VDB Server failed to create", "havokPhysicsWorld->vdbServer", levelA) )
      __debugbreak();
  }
  hkVisualDebugger::clearDefaultAndRequiredProcesses(*(hkVisualDebugger **)(v67 + 496));
  hkVisualDebugger::addDefaultProcess(*(hkVisualDebugger **)(v67 + 496), "Physics/Rigid Bodies/Shapes");
  if ( ((unsigned __int8)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedIncrement(&s_errorPrintWarningOnly);
  hkVisualDebugger::serve(*(hkVisualDebugger **)(v67 + 496), (int)listenPort, v108 + 25001, (const char *)0x3A99, 0);
  if ( ((unsigned __int64)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedDecrement(&s_errorPrintWarningOnly);
  v147 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v147 )
    v147 = hkMemoryRouter::s_fallbackRouter;
  v148 = (__int64)v147->m_heap->blockAlloc(v147->m_heap, 16i64);
  if ( v148 )
  {
    *(_QWORD *)v148 = 0i64;
    *(_DWORD *)(v148 + 8) = 0;
    *(_DWORD *)(v148 + 12) = 0x80000000;
  }
  else
  {
    v148 = 0i64;
  }
  *(_QWORD *)(v67 + 2968) = v148;
  if ( !v148 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3379, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams") )
    __debugbreak();
  *(_QWORD *)listenPort = v67 + 2976;
  if ( v67 == -2976 )
    v149 = 0i64;
  else
    HavokPhysicsDisplayHandler::HavokPhysicsDisplayHandler((HavokPhysicsDisplayHandler *)(v67 + 2976), (Physics_WorldId)v108);
  *(_QWORD *)(v67 + 3144) = v149;
  v150 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v150 )
    v150 = hkMemoryRouter::s_fallbackRouter;
  v151 = (hkServerObjectSerializer *)v150->m_heap->blockAlloc(v150->m_heap, 192i64);
  *(_QWORD *)listenPort = v151;
  if ( v151 )
    hkServerObjectSerializer::hkServerObjectSerializer(v151, NULL, NULL, NULL);
  else
    v152 = 0i64;
  *(_QWORD *)(v67 + 3152) = v152;
  v153 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v153 )
    v153 = hkMemoryRouter::s_fallbackRouter;
  v154 = (hkServerObjectHandler *)v153->m_heap->blockAlloc(v153->m_heap, 112i64);
  *(_QWORD *)listenPort = v154;
  if ( v154 )
    hkServerObjectHandler::hkServerObjectHandler(v154, *(hkServerObjectSerializer **)(v67 + 3152));
  else
    v155 = 0i64;
  *(_QWORD *)(v67 + 3160) = v155;
  v156 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v156 )
    v156 = hkMemoryRouter::s_fallbackRouter;
  v157 = (HavokPhysicsProcessHandler *)v156->m_heap->blockAlloc(v156->m_heap, 48i64);
  *(_QWORD *)listenPort = v157;
  if ( v157 )
    HavokPhysicsProcessHandler::HavokPhysicsProcessHandler(v157, *(hclClothContext **)(v67 + 488), *(hkDebugDisplayHandler **)(v67 + 3144));
  else
    v158 = 0i64;
  *(_QWORD *)(v67 + 3168) = v158;
  v159 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v159 )
    v159 = hkMemoryRouter::s_fallbackRouter;
  v160 = (__int64)v159->m_heap->blockAlloc(v159->m_heap, 24i64);
  if ( v160 )
  {
    *(_QWORD *)v160 = 0i64;
    *(_DWORD *)(v160 + 8) = 0;
    *(_DWORD *)(v160 + 12) = 0x80000000;
    *(_DWORD *)(v160 + 16) = 0;
  }
  else
  {
    v160 = 0i64;
  }
  *(_QWORD *)(v67 + 3200) = v160;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+180h+center.m_quad], xmm0
  }
  *(_DWORD *)(v67 + 3208) = 0;
  *(_WORD *)(v67 + 3212) = 0;
  v162 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
  *(_QWORD *)listenPort = v162;
  v206 = v162;
  __asm { vmovss  xmm6, cs:__real@3ec00000 }
  v164 = v162 == NULL;
  if ( v162 )
  {
    __asm { vmovaps xmm2, xmm6; radius }
    hknpSphereShape::hknpSphereShape(v162, &center, *(float *)&_XMM2);
    _RDI = v166;
  }
  else
  {
    _RDI = 0i64;
  }
  *(_WORD *)(_RDI + 16) = shapeSizeOut;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+20h]
    vmovsd  xmm7, cs:__real@3fd8000000000000
    vucomiss xmm0, xmm6
  }
  if ( !v164 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+280h+var_240], xmm7
      vmovsd  [rsp+280h+var_248], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v193, v195) )
      __debugbreak();
  }
  *(_QWORD *)(v67 + 3416) = _RDI;
  v171 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &v203);
  *(_QWORD *)listenPort = v171;
  v206 = v171;
  v172 = v171 == NULL;
  if ( v171 )
  {
    __asm { vmovaps xmm2, xmm6; radius }
    hknpSphereShape::hknpSphereShape(v171, &center, *(float *)&_XMM2);
    _RDI = v174;
  }
  else
  {
    _RDI = 0i64;
  }
  *(_WORD *)(_RDI + 16) = v203;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+20h]
    vucomiss xmm0, xmm6
  }
  if ( !v172 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+280h+var_240], xmm7
      vmovsd  [rsp+280h+var_248], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v194, v196) )
      __debugbreak();
  }
  *(_QWORD *)(v67 + 3592) = _RDI;
  s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v108] = -1;
  s_havokPhysicsWorldAABBQueryActiveIndices[v108] = -1;
  s_havokPhysicsWorldRayActiveIndices[v108] = -1;
  s_havokPhysicsWorldRayDetailActiveIndices[v108] = -1;
  s_havokPhysicsWorldShapeCastActiveIndices[v108] = -1;
  s_havokPhysicsWorldQueryPointActiveIndices[v108] = -1;
  s_havokPhysicsWorldGetClosestPointsActiveIndices[v108] = -1;
  for ( i = 0; i < 2; ++i )
  {
    v179 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v179 )
      v179 = hkMemoryRouter::s_fallbackRouter;
    v180 = (__int64)v179->m_heap->blockAlloc(v179->m_heap, 48i64);
    v181 = v180;
    if ( v180 )
    {
      *(_QWORD *)(v180 + 8) = 0i64;
      *(_DWORD *)(v180 + 16) = 0x1FFFF;
      *(_QWORD *)v180 = &HavokPhysics_BroadphaseCollisionQueryResult::`vftable';
      *(_QWORD *)(v180 + 24) = 0i64;
      *(_DWORD *)(v180 + 32) = 0;
      *(_DWORD *)(v180 + 36) = 0x80000000;
    }
    else
    {
      v181 = 0i64;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13561, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
        __debugbreak();
    }
    *(_DWORD *)(v181 + 40) = v108;
    s_havokPhysicsWorldAABBBroadphaseQueryData[(int)(i + 2 * v108)].result = (HavokPhysics_BroadphaseCollisionQueryResult *)v181;
    s_havokPhysicsWorldAABBQueryData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldRayData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    s_havokPhysicsWorldRayDetailData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    WeaponPriorityMap = BG_GetWeaponPriorityMap(&NULL_WEAPON, 0);
    HavokPhysics_AddDetailTrace(s_havokPhysicsWorldRayDetailData[(int)(i + 2 * v108)].result, WeaponPriorityMap);
    s_havokPhysicsWorldShapeCastData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    s_havokPhysicsWorldShapeCastData[(int)(i + 2 * v108)].startResult = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldQueryPointData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldGetClosestPointsData[(int)(i + 2 * v108)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v108, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
  }
  v183 = (__int64)v204;
  v184 = (__int64)v205;
  if ( (unsigned int)v108 > 7 )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 0x4000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to SubscribeToEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", levelA) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v108);
  if ( !MutableWorld->world )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16388, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics SubscribeToEvent %i: world is NULL", "physicsWorld->world", levelA) )
      __debugbreak();
  }
  EventSignal = hknpWorld::getEventSignal(MutableWorld->world, BODY_EXITED_BROAD_PHASE, (hknpBodyId)0xFFFFFF);
  hkSignal2<hknpEventHandlerInput const &,hknpEvent const &>::subscribe<void (*)(hknpEventHandlerInput const &,hknpEvent const &)>(EventSignal, HavokPhysics_LeftBroadphase, "Left-Broadphase");
  if ( (unsigned int)v108 > 7 )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11240, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Setup codec with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", levelA) )
      __debugbreak();
  }
  v187 = HavokPhysics_GetMutableWorld((Physics_WorldId)v108);
  p_critSection = &v187->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&v187->critSection);
  if ( !v187->world )
  {
    LODWORD(levelA) = v108;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11246, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetupCodec %i: world is NULL", "havokPhysicsWorld->world", levelA) )
      __debugbreak();
  }
  v187->world->setShapeTagCodec(&v187->world->hknpWorldWriter, s_shapeTagCodec);
  LeaveCriticalSection((LPCRITICAL_SECTION)&v187->critSection);
  *(_QWORD *)(v183 + 3792) = *(int *)(v184 + 24);
  hknpWorldCinfo::~hknpWorldCinfo(&v212);
  LeaveCriticalSection(lpCriticalSection);
  v188 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v188, array.m_data, 8, array.m_capacityAndFlags & 0x3FFFFFFF);
  _R11 = &v214;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DeactivateBody
==============
*/
void HavokPhysics_DeactivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13195, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to deactivate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13196, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to deactivate a body with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationState)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
}

/*
==============
HavokPhysics_DebugSetVisualizeContents
==============
*/
void HavokPhysics_DebugSetVisualizeContents(int visualizeContents)
{
  HavokPhysicsShapeViewer::ms_contents = visualizeContents;
}

/*
==============
HavokPhysics_DebugSetVisualizeQuery
==============
*/
void HavokPhysics_DebugSetVisualizeQuery(bool showQueryBodies)
{
  HavokPhysicsShapeViewer::ms_ignoreQuery = !showQueryBodies;
}

/*
==============
HavokPhysics_DebugXModelGetIndex
==============
*/
__int64 HavokPhysics_DebugXModelGetIndex(XModel *xmodel)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v1; 
  __int64 m_size; 
  unsigned int v4; 
  XModel **m_data; 
  __int64 v6; 
  __int64 v7; 

  v1 = s_havokPhysicsXModels;
  if ( !s_havokPhysicsXModels )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7757, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
      __debugbreak();
    v1 = s_havokPhysicsXModels;
  }
  m_size = v1->m_size;
  v4 = 0;
  if ( (int)m_size <= 0 )
    return 0xFFFFFFFFi64;
  m_data = (XModel **)v1->m_data;
  v6 = m_size;
  v7 = 0i64;
  while ( *m_data != xmodel )
  {
    ++v4;
    ++v7;
    ++m_data;
    if ( v7 >= v6 )
      return 0xFFFFFFFFi64;
  }
  return v4;
}

/*
==============
HavokPhysics_DecodeShapeKeyIntoShapes
==============
*/
__int64 HavokPhysics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> key, const hknpShape **shapes)
{
  unsigned int v7; 
  const HavokPhysicsWorld *ConstWorld; 
  unsigned __int64 v11; 
  unsigned int v21; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  float zero; 
  __int64 v37; 
  hknpShapeCollector v38; 
  hknpInplaceTriangleShape v39; 
  unsigned int m_value; 

  m_value = key.m_value;
  v37 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16191, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DecodeShapeKeyIntoShapes with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  v7 = 0;
  if ( m_value == -1 )
    return 0i64;
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  _R14 = (hkMatrix3Impl<float> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v11 = _R14[2].m_col0.m_quad.m128_u64[0];
  __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v39, *(float *)&_XMM1);
  v38.m_internal.m_shapeBuffer.m_shape = NULL;
  v38.m_internal.m_shapeBuffer.m_buffer = v38.m_internal.m_shapeBuffer.m_storage;
  v38.m_internal.m_shapeBuffer.m_bufferSize = 2048;
  v38.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rsp+0DD0h+var_D80.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rsp+0DD0h+var_D80.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
    vmovups xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rbp+0CD0h+var_D80.m_internal.m_scale.m_quad], xmm2
  }
  v38.m_internal.m_shapeTags[0] = -1;
  v38.m_internal.m_shape = NULL;
  v38.m_parentShape = NULL;
  v38.m_shapeTagPath.m_size = 0;
  *(_QWORD *)&v38.m_internal.m_flags.m_storage = 8i64;
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rsp+0DD0h+var_D80.m_transform.m_rotation.baseclass_0.m_col0.m_quad], xmm0
    vmovups xmm1, xmmword ptr [r14+10h]
    vmovups xmmword ptr [rsp+0DD0h+var_D80.m_transform.m_rotation.baseclass_0.m_col1.m_quad], xmm1
    vmovups xmm0, xmmword ptr [r14+20h]
    vmovups xmmword ptr [rsp+0DD0h+var_D80.m_transform.m_rotation.baseclass_0.m_col2.m_quad], xmm0
    vmovups xmm1, xmmword ptr [r14+30h]
    vmovups xmmword ptr [rbp+0CD0h+var_D80.m_transform.m_translation.m_quad], xmm1
    vmovups xmmword ptr [rbp+0CD0h+var_D80.m_internal.m_scale.m_quad], xmm2
    vmovss  xmm0, cs:__real@34000000
    vmovss  [rsp+0DD0h+zero], xmm0
  }
  if ( hkMatrix3Impl<float>::isApproximatelyEqual(_R14, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], &zero) )
  {
    v21 = v38.m_internal.m_flags.m_storage | 4;
    v38.m_internal.m_flags.m_storage |= 4u;
    __asm
    {
      vmovups xmm0, xmmword ptr [r14+30h]
      vsubps  xmm2, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
      vmovups xmm1, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
      vandnps xmm3, xmm1, xmm2
      vcmpleps xmm4, xmm3, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
      vxorps  xmm2, xmm2, xmm2
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqd xmm1, xmm0, xmm0
      vblendps xmm2, xmm2, xmm1, 7
      vpand   xmm0, xmm4, xmm2
      vptest  xmm0, xmm2
    }
    if ( _CF )
      v38.m_internal.m_flags.m_storage = v21 | 1;
  }
  v38.m_internal.m_shapeTags[0] = -1;
  (*(void (__fastcall **)(unsigned __int64, unsigned int *, __int64, hknpShapeCollector *))(*(_QWORD *)v11 + 176i64))(v11, &m_value, 1i64, &v38);
  if ( (v38.m_internal.m_flags.m_storage & 0x10) != 0 )
    hknpShapeCollector::getTriangleShape(&v38, 0, (hknpTriangleShape *)&v39);
  if ( v38.m_shapeTagPath.m_size > 0 )
  {
    p_m_shape = &v38.m_shapeTagPath.m_data[0].m_shape;
    m_size = (unsigned int)v38.m_shapeTagPath.m_size;
    do
    {
      if ( v7 < 8 )
        shapes[v7++] = *p_m_shape;
      p_m_shape += 4;
      --m_size;
    }
    while ( m_size );
  }
  v38.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
  if ( v38.m_internal.m_shapeBuffer.m_shape )
    ((void (__fastcall *)(hknpShape *, _QWORD))v38.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v38.m_internal.m_shapeBuffer.m_shape, 0i64);
  return v7;
}

/*
==============
HavokPhysics_DecodeSubShapeKey
==============
*/
void HavokPhysics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *shapeInstanceId)
{
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *PhysicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hkHashMapDetail::Entry *Entry; 
  __int64 idx; 
  int m_1; 
  unsigned __int64 item; 

  item = key;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16158, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics EnableShapeInstance %i: world is NULL", "havokPhysicsWorld->world", worldId) )
    __debugbreak();
  *bodyIdx = -1;
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId);
  if ( PhysicsAsset )
  {
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
    if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16172, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
      __debugbreak();
    Entry = hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int>>::_findEntry(&HavokPhysicsAsset->m_mutableShapeLookup, &item);
    if ( Entry )
    {
      idx = Entry->idx;
      if ( (int)idx >= 0 )
      {
        m_1 = HavokPhysicsAsset->m_mutableShapeLookup.m_items.m_data[idx].m_1;
        *bodyIdx = m_1 >> 16;
        shapeInstanceId->m_value = m_1;
      }
    }
  }
}

/*
==============
HavokPhysics_DeferredAABBBroadphaseQuery
==============
*/
void HavokPhysics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBBroadphaseQueryRequest,hkContainerHeapAllocator> *v10; 
  hkMemoryAllocator *v11; 
  int m_size; 
  int v13; 
  HavokPhysics_AABBBroadphaseQueryRequest *m_data; 
  __int64 v15; 

  _RDI = extendedData;
  _RBP = aabb;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13721, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13722, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid data", "data") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13723, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v10 = MutableWorld->aabbBroadphaseQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v11 = hkMemHeapAllocator();
  m_size = v10->m_size;
  v13 = m_size;
  if ( m_size == (v10->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v11, v10, 64);
    m_size = v10->m_size;
    v13 = m_size;
  }
  m_data = v10->m_data;
  v15 = (__int64)&v10->m_data[(__int64)m_size];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 32) = -1;
    *(_QWORD *)(v15 + 40) = 0i64;
    *(_DWORD *)(v15 + 48) = 0;
    v13 = v10->m_size;
    m_data = v10->m_data;
  }
  _RDX = &m_data[(__int64)v13];
  v10->m_size = v13 + 1;
  __asm
  {
    vmovups xmm0, xmmword ptr [rbp+0]
    vmovups xmmword ptr [rdx], xmm0
    vmovups xmm1, xmmword ptr [rbp+10h]
    vmovups xmmword ptr [rdx+10h], xmm1
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rdx+20h], xmm0
    vmovsd  xmm1, qword ptr [rdi+10h]
    vmovsd  qword ptr [rdx+30h], xmm1
  }
  _RDX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/
void HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v11; 
  hkMemoryAllocator *v12; 
  int m_size; 
  int v14; 
  HavokPhysics_AABBQueryRequest *m_data; 
  __int64 v16; 
  __int64 v22; 

  _RSI = extendedData;
  _R15 = aabb;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14536, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14537, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid body id %i", "bodyId.isValid()", v22) )
      __debugbreak();
  }
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14538, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( _RSI->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14539, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( _RSI->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14540, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with simplify - not currently supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14541, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v11 = MutableWorld->aabbQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v12 = hkMemHeapAllocator();
  m_size = v11->m_size;
  v14 = m_size;
  if ( m_size == (v11->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v12, v11, 80);
    m_size = v11->m_size;
    v14 = m_size;
  }
  m_data = v11->m_data;
  v16 = (__int64)&v11->m_data[m_size];
  if ( v16 )
  {
    *(_DWORD *)(v16 + 48) = -1;
    *(_BYTE *)(v16 + 52) = 0;
    *(_QWORD *)(v16 + 56) = 0i64;
    *(_QWORD *)(v16 + 64) = 0i64;
    v14 = v11->m_size;
    m_data = v11->m_data;
  }
  _RDX = &m_data[v14];
  v11->m_size = v14 + 1;
  _RDX->bodyId = bodyId;
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovups xmm1, xmmword ptr [r15+10h]
    vmovups xmmword ptr [rdx+20h], xmm1
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rdx+30h], xmm0
    vmovsd  xmm1, qword ptr [rsi+10h]
    vmovsd  qword ptr [rdx+40h], xmm1
  }
  _RDX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/
void HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v10; 
  hkMemoryAllocator *v11; 
  int m_size; 
  int v13; 
  HavokPhysics_AABBQueryRequest *m_data; 
  __int64 v15; 

  _RSI = extendedData;
  _RBP = aabb;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13789, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13790, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13791, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v10 = MutableWorld->aabbQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v11 = hkMemHeapAllocator();
  m_size = v10->m_size;
  v13 = m_size;
  if ( m_size == (v10->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v11, v10, 80);
    m_size = v10->m_size;
    v13 = m_size;
  }
  m_data = v10->m_data;
  v15 = (__int64)&v10->m_data[m_size];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 48) = -1;
    *(_BYTE *)(v15 + 52) = 0;
    *(_QWORD *)(v15 + 56) = 0i64;
    *(_QWORD *)(v15 + 64) = 0i64;
    v13 = v10->m_size;
    m_data = v10->m_data;
  }
  _RDX = &m_data[v13];
  v10->m_size = v13 + 1;
  _RDX->bodyId.m_serialAndIndex = 0xFFFFFF;
  __asm
  {
    vmovups xmm0, xmmword ptr [rbp+0]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovups xmm1, xmmword ptr [rbp+10h]
    vmovups xmmword ptr [rdx+20h], xmm1
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rdx+30h], xmm0
    vmovsd  xmm1, qword ptr [rsi+10h]
    vmovsd  qword ptr [rdx+40h], xmm1
  }
  _RDX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/
void HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_GetClosestPointsRequest *m_data; 
  __int64 v18; 

  _R13 = rotation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14393, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14394, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid shape", "shape") )
    __debugbreak();
  _R14 = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14395, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14396, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->getClosestPointsRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 112);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 56) = -1;
    *(_BYTE *)(v18 + 60) = 0;
    *(_QWORD *)(v18 + 64) = 0i64;
    *(_DWORD *)(v18 + 72) = 0;
    *(_QWORD *)(v18 + 80) = 0i64;
    *(_DWORD *)(v18 + 88) = 0;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  _RBX = &m_data[v16];
  v13->m_size = v16 + 1;
  _RBX->bodyId.m_serialAndIndex = 0xFFFFFF;
  _RBX->shape = shape;
  hkReferencedObject::addReference(shape);
  _RAX = point;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbx+10h], xmm0
    vmovups xmm1, xmmword ptr [r13+0]
    vmovups xmmword ptr [rbx+20h], xmm1
    vmovss  xmm0, [rsp+78h+maxDistance]
    vmovss  dword ptr [rbx+30h], xmm0
    vmovups ymm0, ymmword ptr [r14]
    vmovups ymmword ptr [rbx+38h], ymm0
    vmovsd  xmm1, qword ptr [r14+20h]
    vmovsd  qword ptr [rbx+58h], xmm1
  }
  _RBX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/
void HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v14; 
  hkMemoryAllocator *v15; 
  int m_size; 
  int v17; 
  HavokPhysics_GetClosestPointsRequest *m_data; 
  __int64 v19; 
  __int64 v28; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15166, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred get closest points with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v28) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15167, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred getclosest points with body with invalid body id %i", "bodyId.isValid()", v28) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15168, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid shape", "shape") )
    __debugbreak();
  _RSI = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15169, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15170, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15171, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15172, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v14 = MutableWorld->getClosestPointsRequestLists[1 - MutableWorld->activeQueryRequestList];
  v15 = hkMemHeapAllocator();
  m_size = v14->m_size;
  v17 = m_size;
  if ( m_size == (v14->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v15, v14, 112);
    m_size = v14->m_size;
    v17 = m_size;
  }
  m_data = v14->m_data;
  v19 = (__int64)&v14->m_data[m_size];
  if ( v19 )
  {
    *(_DWORD *)(v19 + 56) = -1;
    *(_BYTE *)(v19 + 60) = 0;
    *(_QWORD *)(v19 + 64) = 0i64;
    *(_DWORD *)(v19 + 72) = 0;
    *(_QWORD *)(v19 + 80) = 0i64;
    *(_DWORD *)(v19 + 88) = 0;
    v17 = v14->m_size;
    m_data = v14->m_data;
  }
  _RDI = &m_data[v17];
  v14->m_size = v17 + 1;
  _RDI->bodyId = bodyId;
  _RDI->shape = shape;
  hkReferencedObject::addReference(shape);
  _RAX = point;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rdi+10h], xmm0
  }
  _RAX = rotation;
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups xmmword ptr [rdi+20h], xmm1
    vmovss  xmm0, [rsp+78h+maxDistance]
    vmovss  dword ptr [rdi+30h], xmm0
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdi+38h], ymm0
    vmovsd  xmm1, qword ptr [rsi+20h]
    vmovsd  qword ptr [rdi+58h], xmm1
  }
  _RDI->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, const hkVector4f *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_QueryPointRequest *m_data; 
  __int64 v18; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  _RSI = extendedData;
  __asm { vmovaps xmm6, xmm2 }
  _R15 = point;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14262, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14263, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->queryPointRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 80);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 40) = -1;
    *(_BYTE *)(v18 + 44) = 0;
    *(_QWORD *)(v18 + 48) = 0i64;
    *(_QWORD *)(v18 + 56) = 1i64;
    *(_DWORD *)(v18 + 64) = 0;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  _RDX = &m_data[v16];
  v13->m_size = v16 + 1;
  _RDX->bodyId.m_serialAndIndex = 0xFFFFFF;
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovss  dword ptr [rdx+20h], xmm6
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdx+28h], ymm0
  }
  _RDX->deferredData = data;
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v15; 
  hkMemoryAllocator *v16; 
  int m_size; 
  int v18; 
  HavokPhysics_QueryPointRequest *m_data; 
  __int64 v20; 
  __int64 v25; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmm6, xmm3
  }
  _R12 = point;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15047, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15048, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid body id %i", "bodyId.isValid()", v25) )
      __debugbreak();
  }
  _RSI = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15049, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15050, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15051, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15052, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v15 = MutableWorld->queryPointRequestLists[1 - MutableWorld->activeQueryRequestList];
  v16 = hkMemHeapAllocator();
  m_size = v15->m_size;
  v18 = m_size;
  if ( m_size == (v15->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v16, v15, 80);
    m_size = v15->m_size;
    v18 = m_size;
  }
  m_data = v15->m_data;
  v20 = (__int64)&v15->m_data[m_size];
  if ( v20 )
  {
    *(_DWORD *)(v20 + 40) = -1;
    *(_BYTE *)(v20 + 44) = 0;
    *(_QWORD *)(v20 + 48) = 0i64;
    *(_QWORD *)(v20 + 56) = 1i64;
    *(_DWORD *)(v20 + 64) = 0;
    v18 = v15->m_size;
    m_data = v15->m_data;
  }
  _RDX = &m_data[v18];
  v15->m_size = v18 + 1;
  _RDX->bodyId = bodyId;
  __asm
  {
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovss  dword ptr [rdx+20h], xmm6
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdx+28h], ymm0
  }
  _RDX->deferredData = data;
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/
void HavokPhysics_DeferredRaycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v11; 
  hkMemoryAllocator *v12; 
  int m_size; 
  int v14; 
  HavokPhysics_RaycastRequest *m_data; 
  __int64 v16; 

  _RSI = extendedData;
  _R15 = end;
  _R12 = start;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13916, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13917, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13918, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v11 = MutableWorld->raycastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v12 = hkMemHeapAllocator();
  m_size = v11->m_size;
  v14 = m_size;
  if ( m_size == (v11->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v12, v11, 96);
    m_size = v11->m_size;
    v14 = m_size;
  }
  m_data = v11->m_data;
  v16 = (__int64)&v11->m_data[m_size];
  if ( v16 )
  {
    *(_DWORD *)(v16 + 48) = -1;
    *(_QWORD *)(v16 + 56) = 0i64;
    *(_QWORD *)(v16 + 64) = 1i64;
    *(_DWORD *)(v16 + 72) = 0;
    *(_DWORD *)(v16 + 76) = 1;
    *(_WORD *)(v16 + 80) = 256;
    v14 = v11->m_size;
    m_data = v11->m_data;
  }
  _RDX = &m_data[v14];
  v11->m_size = v14 + 1;
  _RDX->bodyId.m_serialAndIndex = 0xFFFFFF;
  __asm
  {
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovups xmm1, xmmword ptr [r15]
    vmovups xmmword ptr [rdx+20h], xmm1
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdx+30h], ymm0
    vmovsd  xmm1, qword ptr [rsi+20h]
    vmovsd  qword ptr [rdx+50h], xmm1
  }
  _RDX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/
void HavokPhysics_DeferredRaycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_RaycastRequest *m_data; 
  __int64 v18; 
  __int64 v24; 

  _R12 = end;
  _R13 = start;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14648, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v24) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14649, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid body id %i", "bodyId.isValid()", v24) )
      __debugbreak();
  }
  _RSI = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14650, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14651, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14652, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->raycastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 96);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 48) = -1;
    *(_QWORD *)(v18 + 56) = 0i64;
    *(_QWORD *)(v18 + 64) = 1i64;
    *(_DWORD *)(v18 + 72) = 0;
    *(_DWORD *)(v18 + 76) = 1;
    *(_WORD *)(v18 + 80) = 256;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  _RDX = &m_data[v16];
  v13->m_size = v16 + 1;
  _RDX->bodyId = bodyId;
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups xmmword ptr [rdx+10h], xmm0
    vmovups xmm1, xmmword ptr [r12]
    vmovups xmmword ptr [rdx+20h], xmm1
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdx+30h], ymm0
    vmovsd  xmm1, qword ptr [rsi+20h]
    vmovsd  qword ptr [rdx+50h], xmm1
  }
  _RDX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/
void HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_ShapecastRequest *m_data; 
  __int64 v18; 

  _R13 = end;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14087, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _R14 = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14088, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14089, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->shapecastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 128);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[(__int64)m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 64) = -1;
    *(_DWORD *)(v18 + 68) = 0;
    *(_DWORD *)(v18 + 72) = 1015222895;
    *(_BYTE *)(v18 + 76) = 0;
    *(_QWORD *)(v18 + 80) = 0i64;
    *(_DWORD *)(v18 + 88) = 0;
    *(_QWORD *)(v18 + 96) = 0i64;
    *(_QWORD *)(v18 + 104) = 0i64;
    *(_DWORD *)(v18 + 112) = 0;
    *(_BYTE *)(v18 + 116) = 0;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  _RBX = &m_data[(__int64)v16];
  v13->m_size = v16 + 1;
  _RBX->bodyId.m_serialAndIndex = 0xFFFFFF;
  _RBX->shape = shape;
  hkReferencedObject::addReference(shape);
  _RAX = start;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbx+10h], xmm0
    vmovups xmm1, xmmword ptr [r13+0]
    vmovups xmmword ptr [rbx+20h], xmm1
  }
  _RAX = rotation;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbx+30h], xmm0
    vmovups ymm0, ymmword ptr [r14]
    vmovups ymmword ptr [rbx+40h], ymm0
    vmovups xmm1, xmmword ptr [r14+20h]
    vmovups xmmword ptr [rbx+60h], xmm1
    vmovsd  xmm0, qword ptr [r14+30h]
    vmovsd  qword ptr [rbx+70h], xmm0
  }
  _RBX->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/
void HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v14; 
  hkMemoryAllocator *v15; 
  int m_size; 
  int v17; 
  HavokPhysics_ShapecastRequest *m_data; 
  __int64 v19; 
  __int64 v30; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14783, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v30) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14784, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid body id %i", "bodyId.isValid()", v30) )
      __debugbreak();
  }
  _R15 = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14785, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid extendedData", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14786, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v14 = MutableWorld->shapecastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v15 = hkMemHeapAllocator();
  m_size = v14->m_size;
  v17 = m_size;
  if ( m_size == (v14->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v15, v14, 128);
    m_size = v14->m_size;
    v17 = m_size;
  }
  m_data = v14->m_data;
  v19 = (__int64)&v14->m_data[(__int64)m_size];
  if ( v19 )
  {
    *(_DWORD *)(v19 + 64) = -1;
    *(_DWORD *)(v19 + 68) = 0;
    *(_DWORD *)(v19 + 72) = 1015222895;
    *(_BYTE *)(v19 + 76) = 0;
    *(_QWORD *)(v19 + 80) = 0i64;
    *(_DWORD *)(v19 + 88) = 0;
    *(_QWORD *)(v19 + 96) = 0i64;
    *(_QWORD *)(v19 + 104) = 0i64;
    *(_DWORD *)(v19 + 112) = 0;
    *(_BYTE *)(v19 + 116) = 0;
    v17 = v14->m_size;
    m_data = v14->m_data;
  }
  _RDI = &m_data[(__int64)v17];
  v14->m_size = v17 + 1;
  _RDI->bodyId = bodyId;
  _RDI->shape = shape;
  hkReferencedObject::addReference(shape);
  _RAX = start;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rdi+10h], xmm0
  }
  _RAX = end;
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups xmmword ptr [rdi+20h], xmm1
  }
  _RAX = rotation;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rdi+30h], xmm0
    vmovups ymm0, ymmword ptr [r15]
    vmovups ymmword ptr [rdi+40h], ymm0
    vmovups xmm1, xmmword ptr [r15+20h]
    vmovups xmmword ptr [rdi+60h], xmm1
    vmovsd  xmm0, qword ptr [r15+30h]
    vmovsd  qword ptr [rdi+70h], xmm0
  }
  _RDI->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DestroyBody
==============
*/
void HavokPhysics_DestroyBody(Physics_WorldId worldId, HavokPhysicsWorld *world, hknpBodyId bodyId, bool activate)
{
  hknpWorld *v7; 
  __int64 v8; 
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *v10; 
  __int64 v11; 
  int v12; 
  Physics_RefSystem RefSystem; 
  __int64 v14; 
  unsigned int v15; 
  hknpUnaryAction *v16; 
  hknpUnaryAction *v17; 
  unsigned __int16 m_refCount; 
  hknpActionManager *ActionManager; 
  signed __int32 v20[8]; 
  __int64 v21; 
  __int64 v22; 
  unsigned int bodyIda; 
  __int64 v24; 

  bodyIda = bodyId.m_serialAndIndex;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8931, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8932, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( (bodyIda & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8933, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", (const char *)&queryFormat, "bodyId.isValid()") )
    __debugbreak();
  v7 = world->world;
  v8 = v7->m_bodyManager.m_scheduledBodyChangeIndices.m_data[bodyIda & 0xFFFFFF];
  if ( (_DWORD)v8 != -1 && v7->m_bodyManager.m_scheduledBodyChanges.m_data[v8].m_pendingAddIndex != -1 )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v22) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10905, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add Pending Bodies to invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v22) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world )
    {
      LODWORD(v22) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10909, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavok Physics: Trying to Add Pending Bodies where index %i doesn't have a world yet", "havokPhysicsWorld->world", v22) )
        __debugbreak();
    }
    v10 = MutableWorld->world;
    if ( v10->m_bodyManager.m_bodiesToAddAsActive.m_size || v10->m_bodyManager.m_bodiesToAddAsInactive.m_size )
    {
      v10->commitAddBodies(&v10->hknpWorldWriter);
      MutableWorld->world->updateBroadPhase(&MutableWorld->world->hknpWorldWriter);
    }
  }
  v11 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, bodyIda);
  v12 = truncate_cast<int,unsigned __int64>(*(unsigned int *)(v11 + 160));
  RefSystem = Physics_GetRefSystem(v12);
  v14 = RefSystem;
  if ( (unsigned int)RefSystem >= Physics_RefSystem_Count )
  {
    LODWORD(v22) = 13;
    LODWORD(v21) = RefSystem;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8948, ASSERT_TYPE_ASSERT, "(unsigned)( refSystem ) < (unsigned)( Physics_RefSystem_Count )", "refSystem doesn't index Physics_RefSystem_Count\n\t%i not in [0, %i)", v21, v22) )
      __debugbreak();
  }
  --world->refSystemCounts[v14];
  v15 = bodyIda;
  if ( !Physics_IsQueryWorld(worldId) && !Physics_IsPredictiveWorld(worldId) )
  {
    v16 = PhysicsForceAction_Get(worldId, v15);
    v17 = v16;
    if ( v16 )
    {
      _InterlockedOr(v20, 0);
      m_refCount = v16->m_refCount;
      _InterlockedOr(v20, 0);
      if ( m_refCount != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8960, ASSERT_TYPE_ASSERT, "(forceAction->getReferenceCount() == 2)", (const char *)&queryFormat, "forceAction->getReferenceCount() == 2") )
        __debugbreak();
      ActionManager = hknpWorld::getActionManager(world->world);
      hknpActionManager::removeAction(ActionManager, (hknpAction *)&v24);
      PhysicsForceAction_Destroy(v17);
    }
  }
  world->bodySFXEventAssets->m_data[bodyIda & 0xFFFFFF] = NULL;
  world->bodyVFXEventAssets->m_data[bodyIda & 0xFFFFFF] = NULL;
  Sys_EnterCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  world->world->destroyBodies(&world->world->hknpWorldWriter, (const hknpBodyId *)&bodyIda, 1, (hknpWorldWriter::ActivationMode)!activate);
  Sys_LeaveCriticalSection(CRITSECT_PHYS_BODY_CREATE);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/
void HavokPhysics_DestroyConstraint(HavokPhysicsWorld *world, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId)
{
  unsigned int m_value; 

  m_value = constraintId.m_value;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9031, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9032, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( m_value == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9033, ASSERT_TYPE_ASSERT, "(constraintId.isValid())", (const char *)&queryFormat, "constraintId.isValid()") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, unsigned int *, __int64))world->world->destroyConstraints)(&world->world->hknpWorldWriter, &m_value, 1i64);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/
void HavokPhysics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v8; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10867, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Destroy constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10868, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Destroy constraint in invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10873, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyInstance %i: world is NULL", "havokPhysicsWorld->world", v8) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_GetConstraintId(&result, &MutableWorld->instanceManager, instanceId, constraintIdx);
  HavokPhysics_DestroyConstraint(MutableWorld, result);
  HavokPhysicsInstanceManager_RemoveConstraint(&MutableWorld->instanceManager, instanceId, constraintIdx);
}

/*
==============
HavokPhysics_DestroyInstance
==============
*/
void HavokPhysics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v3; 
  bool v4; 
  Physics_WorldId v5; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  signed int v8; 
  __int64 v9; 
  signed int v10; 
  __int64 i; 
  __int64 v12; 

  v3 = instanceId;
  v4 = activate;
  v5 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10814, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Destroy Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v3 == -1 )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10815, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Destroy invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v12) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(v5);
  if ( !MutableWorld->world )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10822, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyInstance %i: world is NULL", "havokPhysicsWorld->world", v12) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  v8 = HavokPhysicsInstanceManager_GetConstraintCount(&MutableWorld->instanceManager, v3) - 1;
  v9 = v8;
  if ( v8 >= 0 )
  {
    do
    {
      if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 92, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 93, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      HavokPhysics_DestroyConstraint(MutableWorld, p_instanceManager->buffer[v3].constraints.m_data[v9--]);
    }
    while ( v9 >= 0 );
    v5 = worldId;
    v4 = activate;
  }
  HavokPhysicsInstanceManager_ClearConstraints(&MutableWorld->instanceManager, v3);
  v10 = HavokPhysicsInstanceManager_GetBodyCount(&MutableWorld->instanceManager, v3) - 1;
  for ( i = v10; i >= 0; HavokPhysics_DestroyBody(v5, MutableWorld, p_instanceManager->buffer[v3].bodies.m_data[i--], v4) )
  {
    if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_ClearBodies(&MutableWorld->instanceManager, v3);
  HavokPhysicsInstanceManager_DestroyInstance(&MutableWorld->instanceManager, v3);
}

/*
==============
HavokPhysics_DestroyWorld
==============
*/
void HavokPhysics_DestroyWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *m_ragdollConstraintGroupId; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *i; 
  hkMemoryAllocator *v5; 
  int m_capacityAndFlags; 
  hkMemoryRouter *Value; 
  hknpWorld *world; 
  hknpBodyManager *p_m_bodyManager; 
  unsigned int m_peakIndex; 
  const char *WorldName; 
  const char *v12; 
  hknpShape *debugGetClosestPointsShape; 
  hknpShape *debugShapecastShape; 
  int v15; 
  __int64 v16; 
  hkProcess *v17; 
  hkMemoryAllocator *v18; 
  int v19; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v21; 
  int v22; 
  hkMemoryRouter *v23; 
  hkSet<unsigned int,hkContainerHeapAllocator,hkMapOperations<unsigned int> > *detailDrawBodies; 
  __int64 m_size; 
  __int64 j; 
  hkSet<unsigned int,hkContainerHeapAllocator,hkMapOperations<unsigned int> > *v27; 
  hkMemoryAllocator *v28; 
  int v29; 
  hkMemoryRouter *v30; 
  HavokPhysicsProcessHandler *processHandler; 
  hkServerObjectHandler *serverObjectHandler; 
  hkServerObjectSerializer *vdbObjectSerializer; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMemoryAllocator *v35; 
  int v36; 
  hkMemoryRouter *v37; 
  hkVisualDebugger *vdbServer; 
  hkVisualDebugger *v39; 
  hclClothContext *clothVisContext; 
  unsigned __int16 m_refCount; 
  hclClothContext *v42; 
  hknpProcessContext *visContext; 
  hknpProcessContext *v44; 
  unsigned int k; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  HavokPhysics_BroadphaseCollisionQueryResult *v49; 
  unsigned __int16 v50; 
  __int64 v51; 
  HavokPhysicsWorld *v52; 
  hknpEventSignal *EventSignal; 
  HavokPhysicsWorld *v54; 
  __int64 v55; 
  hkMemoryAllocator *v56; 
  int v57; 
  hkMemoryRouter *v58; 
  __int64 v59; 
  hkMemoryAllocator *v60; 
  int v61; 
  hkMemoryRouter *v62; 
  __int64 v63; 
  hkMemoryAllocator *v64; 
  int v65; 
  hkMemoryRouter *v66; 
  __int64 v67; 
  hkMemoryAllocator *v68; 
  int v69; 
  hkMemoryRouter *v70; 
  __int64 v71; 
  hkMemoryAllocator *v72; 
  int v73; 
  hkMemoryRouter *v74; 
  __int64 v75; 
  hkMemoryAllocator *v76; 
  int v77; 
  hkMemoryRouter *v78; 
  void *v79; 
  hkMemoryRouter *v80; 
  __int64 *v81; 
  __int64 v82; 
  __int64 *v83; 
  __int64 v84; 
  hkReferencedObject *v85; 
  __int64 *v86; 
  __int64 v87; 
  hkReferencedObject *v88; 
  __int64 v89; 
  hkMemoryAllocator *v90; 
  int v91; 
  hkMemoryRouter *v92; 
  __int64 v93; 
  hkMemoryAllocator *v94; 
  int v95; 
  hkMemoryRouter *v96; 
  __int64 v97; 
  hkMemoryAllocator *v98; 
  int v99; 
  hkMemoryRouter *v100; 
  __int64 v101; 
  hkMemoryAllocator *v102; 
  int v103; 
  hkMemoryRouter *v104; 
  __int64 v105; 
  hkMemoryAllocator *v106; 
  int v107; 
  hkMemoryRouter *v108; 
  __int64 v109; 
  hkMemoryAllocator *v110; 
  int v111; 
  hkMemoryRouter *v112; 
  bool IsQueryWorld; 
  __int64 v114; 
  __int64 v115; 
  __int64 v116; 
  __int64 v117; 
  hkReferencedObject *v118; 
  hkReferencedObject *v119; 
  __int64 v120; 
  __int64 v121; 
  __int64 v122; 
  __int64 v123; 
  signed __int32 v124[8]; 
  __int64 v125; 
  __int64 v126; 
  LPCRITICAL_SECTION p_critSection; 
  __int64 v128; 
  hkCriticalSection *v129; 
  hkBool result; 
  HavokPhysicsWorld *v132; 
  void (__fastcall *method)(const hknpEventHandlerInput *, const hknpEvent *); 

  v128 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3463, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DestroyWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v132 = MutableWorld;
  p_critSection = (LPCRITICAL_SECTION)&MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  m_ragdollConstraintGroupId = MutableWorld->m_ragdollConstraintGroupId;
  if ( m_ragdollConstraintGroupId )
  {
    for ( i = m_ragdollConstraintGroupId->m_data; i != &m_ragdollConstraintGroupId->m_data[m_ragdollConstraintGroupId->m_size]; m_ragdollConstraintGroupId = MutableWorld->m_ragdollConstraintGroupId )
    {
      if ( i->m_value != 0x7FFFFFFF && hknpConstraintManager::isGroupValid(MutableWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)i->m_value) )
      {
        hknpConstraintManager::destroyConstraintGroup(MutableWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)i->m_value);
        i->m_value = 0x7FFFFFFF;
      }
      ++i;
    }
    if ( m_ragdollConstraintGroupId )
    {
      v5 = hkMemHeapAllocator();
      m_ragdollConstraintGroupId->m_size = 0;
      m_capacityAndFlags = m_ragdollConstraintGroupId->m_capacityAndFlags;
      if ( m_capacityAndFlags >= 0 )
        hkMemoryAllocator::bufFree2(v5, m_ragdollConstraintGroupId->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
      m_ragdollConstraintGroupId->m_data = NULL;
      m_ragdollConstraintGroupId->m_capacityAndFlags = 0x80000000;
      Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !Value )
        Value = hkMemoryRouter::s_fallbackRouter;
      Value->m_heap->blockFree(Value->m_heap, m_ragdollConstraintGroupId, 16);
    }
    MutableWorld->m_ragdollConstraintGroupId = NULL;
  }
  world = MutableWorld->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3489, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  p_m_bodyManager = &world->m_bodyManager;
  if ( !p_m_bodyManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3492, ASSERT_TYPE_ASSERT, "(havokBodyManager)", (const char *)&queryFormat, "havokBodyManager") )
    __debugbreak();
  m_peakIndex = p_m_bodyManager->m_bodies.m_peakIndex;
  WorldName = Physics_GetWorldName(worldId);
  Com_Printf(12, "Physics World '%s' Body Count Peak %i\n", WorldName, m_peakIndex);
  v12 = Physics_GetWorldName(worldId);
  HavokPhysicsInstanceManager_CheckEmpty(v12, worldId, &MutableWorld->instanceManager);
  debugGetClosestPointsShape = MutableWorld->debugGetClosestPointsShape;
  if ( debugGetClosestPointsShape )
  {
    HavokPhysics_ReleaseShape(worldId, debugGetClosestPointsShape, 1);
    MutableWorld->debugGetClosestPointsShape = NULL;
  }
  debugShapecastShape = MutableWorld->debugShapecastShape;
  if ( debugShapecastShape )
  {
    HavokPhysics_ReleaseShape(worldId, debugShapecastShape, 1);
    MutableWorld->debugShapecastShape = NULL;
  }
  if ( MutableWorld->visProcesses.m_size )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3512, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visProcesses.getSize() == 0)", "%s\n\tHavokPhysics DestroyWorld %i: visProcesses is not empty", "havokPhysicsWorld->visProcesses.getSize() == 0", v125) )
      __debugbreak();
  }
  v15 = 0;
  if ( MutableWorld->visProcesses.m_size > 0 )
  {
    v16 = 0i64;
    do
    {
      v17 = MutableWorld->visProcesses.m_data[v16];
      if ( v17 )
        ((void (__fastcall *)(hkProcess *, __int64))v17->~hkProcess)(v17, 1i64);
      ++v15;
      ++v16;
    }
    while ( v15 < MutableWorld->visProcesses.m_size );
  }
  v18 = hkMemHeapAllocator();
  MutableWorld->visProcesses.m_size = 0;
  v19 = MutableWorld->visProcesses.m_capacityAndFlags;
  if ( v19 >= 0 )
    hkMemoryAllocator::bufFree2(v18, MutableWorld->visProcesses.m_data, 8, v19 & 0x3FFFFFFF);
  MutableWorld->visProcesses.m_data = NULL;
  MutableWorld->visProcesses.m_capacityAndFlags = 0x80000000;
  if ( !MutableWorld->debugLines && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3522, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  debugLines = MutableWorld->debugLines;
  if ( debugLines )
  {
    v21 = hkMemHeapAllocator();
    debugLines->m_size = 0;
    v22 = debugLines->m_capacityAndFlags;
    if ( v22 >= 0 )
      hkMemoryAllocator::bufFree2(v21, debugLines->m_data, 48, v22 & 0x3FFFFFFF);
    debugLines->m_data = NULL;
    debugLines->m_capacityAndFlags = 0x80000000;
    v23 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v23 )
      v23 = hkMemoryRouter::s_fallbackRouter;
    v23->m_heap->blockFree(v23->m_heap, debugLines, 16);
  }
  MutableWorld->debugLines = NULL;
  detailDrawBodies = MutableWorld->detailDrawBodies;
  m_size = detailDrawBodies->m_elem.m_size;
  if ( m_size > 0 )
  {
    for ( j = 0i64; j < m_size; ++j )
      detailDrawBodies->m_elem.m_data[j] = -1;
  }
  detailDrawBodies->m_numElems = 0;
  v27 = MutableWorld->detailDrawBodies;
  if ( v27 )
  {
    v28 = hkMemHeapAllocator();
    v27->m_elem.m_size = 0;
    v29 = v27->m_elem.m_capacityAndFlags;
    if ( v29 >= 0 )
      hkMemoryAllocator::bufFree2(v28, v27->m_elem.m_data, 4, v29 & 0x3FFFFFFF);
    v27->m_elem.m_data = NULL;
    v27->m_elem.m_capacityAndFlags = 0x80000000;
    v30 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v30 )
      v30 = hkMemoryRouter::s_fallbackRouter;
    v30->m_heap->blockFree(v30->m_heap, v27, 24);
  }
  MutableWorld->detailDrawBodies = NULL;
  if ( !MutableWorld->processHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3531, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->processHandler)", (const char *)&queryFormat, "havokPhysicsWorld->processHandler") )
    __debugbreak();
  processHandler = MutableWorld->processHandler;
  if ( processHandler )
    ((void (__fastcall *)(HavokPhysicsProcessHandler *, __int64))processHandler->~hkProcessHandler)(processHandler, 1i64);
  MutableWorld->processHandler = NULL;
  serverObjectHandler = MutableWorld->serverObjectHandler;
  _InterlockedOr(v124, 0);
  LOWORD(serverObjectHandler) = serverObjectHandler->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)serverObjectHandler != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3534, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->serverObjectHandler->getReferenceCount() == 1)", (const char *)&queryFormat, "havokPhysicsWorld->serverObjectHandler->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(MutableWorld->serverObjectHandler);
  MutableWorld->serverObjectHandler = NULL;
  vdbObjectSerializer = MutableWorld->vdbObjectSerializer;
  _InterlockedOr(v124, 0);
  LOWORD(vdbObjectSerializer) = vdbObjectSerializer->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)vdbObjectSerializer != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3539, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbObjectSerializer->getReferenceCount() == 1)", (const char *)&queryFormat, "havokPhysicsWorld->vdbObjectSerializer->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(MutableWorld->vdbObjectSerializer);
  MutableWorld->vdbObjectSerializer = NULL;
  ((void (__fastcall *)(HavokPhysicsDisplayHandler *, _QWORD))MutableWorld->displayHandler->~hkBaseObject)(MutableWorld->displayHandler, 0i64);
  MutableWorld->displayHandler = NULL;
  if ( !MutableWorld->monitorStreams && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3550, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams") )
    __debugbreak();
  monitorStreams = MutableWorld->monitorStreams;
  if ( monitorStreams )
  {
    v35 = hkMemHeapAllocator();
    monitorStreams->m_size = 0;
    v36 = monitorStreams->m_capacityAndFlags;
    if ( v36 >= 0 )
      hkMemoryAllocator::bufFree2(v35, monitorStreams->m_data, 8, v36 & 0x3FFFFFFF);
    monitorStreams->m_data = NULL;
    monitorStreams->m_capacityAndFlags = 0x80000000;
    v37 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v37 )
      v37 = hkMemoryRouter::s_fallbackRouter;
    v37->m_heap->blockFree(v37->m_heap, monitorStreams, 16);
  }
  MutableWorld->monitorStreams = NULL;
  if ( !MutableWorld->vdbServer )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3555, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics DestroyWorld %i: vdbServer is NULL", "havokPhysicsWorld->vdbServer", v125) )
      __debugbreak();
  }
  hkVisualDebugger::shutdown(MutableWorld->vdbServer);
  hkVisualDebugger::clearDefaultAndRequiredProcesses(MutableWorld->vdbServer);
  vdbServer = MutableWorld->vdbServer;
  _InterlockedOr(v124, 0);
  LOWORD(vdbServer) = vdbServer->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)vdbServer != 1 )
  {
    v39 = MutableWorld->vdbServer;
    _InterlockedOr(v124, 0);
    LODWORD(v39) = v39->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v39;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3558, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: vdbServer has %i references - should be 1", "havokPhysicsWorld->vdbServer->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(MutableWorld->vdbServer);
  MutableWorld->vdbServer = NULL;
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
  {
    _InterlockedOr(v124, 0);
    m_refCount = clothVisContext->m_refCount;
    _InterlockedOr(v124, 0);
    if ( m_refCount != 1 )
    {
      v42 = MutableWorld->clothVisContext;
      _InterlockedOr(v124, 0);
      LODWORD(v42) = v42->m_refCount;
      _InterlockedOr(v124, 0);
      LODWORD(v126) = (_DWORD)v42;
      LODWORD(v125) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3565, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->clothVisContext->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: cloth visContext has %i references - should be 1", "havokPhysicsWorld->clothVisContext->getReferenceCount() == 1", v125, v126) )
        __debugbreak();
    }
    hkReferencedObject::removeReference(MutableWorld->clothVisContext);
    MutableWorld->clothVisContext = NULL;
  }
  if ( !MutableWorld->visContext )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3569, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics DestroyWorld %i: visContext is NULL", "havokPhysicsWorld->visContext", v125) )
      __debugbreak();
  }
  visContext = MutableWorld->visContext;
  _InterlockedOr(v124, 0);
  LOWORD(visContext) = visContext->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)visContext != 1 )
  {
    v44 = MutableWorld->visContext;
    _InterlockedOr(v124, 0);
    LODWORD(v44) = v44->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v44;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3570, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: visContext has %i references - should be 1", "havokPhysicsWorld->visContext->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(MutableWorld->visContext);
  MutableWorld->visContext = NULL;
  hkReferencedObject::removeReference(MutableWorld->comContext);
  MutableWorld->comContext = NULL;
  for ( k = 0; k < 2; ++k )
  {
    v46 = (int)(2 * worldId + k);
    v47 = v46;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldGetClosestPointsData[v46].result);
    s_havokPhysicsWorldGetClosestPointsData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldQueryPointData[v46].result);
    s_havokPhysicsWorldQueryPointData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldShapeCastData[v46].startResult);
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldShapeCastData[v46].result);
    s_havokPhysicsWorldShapeCastData[v47].startResult = NULL;
    s_havokPhysicsWorldShapeCastData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldRayDetailData[v46].result);
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldRayData[v46].result);
    s_havokPhysicsWorldRayDetailData[v47].result = NULL;
    s_havokPhysicsWorldRayData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldAABBQueryData[v46].result);
    s_havokPhysicsWorldAABBQueryData[v47].result = NULL;
    v48 = v46;
    v49 = s_havokPhysicsWorldAABBBroadphaseQueryData[v48].result;
    if ( !v49 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13575, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    _InterlockedOr(v124, 0);
    v50 = v49->m_refCount;
    _InterlockedOr(v124, 0);
    if ( v50 != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13578, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
      __debugbreak();
    hkReferencedObject::removeReference(v49);
    s_havokPhysicsWorldAABBBroadphaseQueryData[v48].result = NULL;
  }
  v51 = (__int64)v132;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16407, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to UnsubscribeFromEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  v52 = HavokPhysics_GetMutableWorld(worldId);
  if ( !v52->world )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16411, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics UnsubscribeFromEvent %i: world is NULL", "physicsWorld->world", v125) )
      __debugbreak();
  }
  EventSignal = hknpWorld::getEventSignal(v52->world, BODY_EXITED_BROAD_PHASE, (hknpBodyId)0xFFFFFF);
  method = HavokPhysics_LeftBroadphase;
  hkSignal::unsubscribeInternal(EventSignal, &result, NULL, &method, 8);
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11259, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Clear codec with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  v54 = HavokPhysics_GetMutableWorld(worldId);
  v129 = &v54->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&v54->critSection);
  if ( !v54->world )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11265, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics ClearCodec %i: world is NULL", "havokPhysicsWorld->world", v125) )
      __debugbreak();
  }
  if ( !s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11268, ASSERT_TYPE_ASSERT, "(s_shapeTagCodec)", (const char *)&queryFormat, "s_shapeTagCodec") )
    __debugbreak();
  v54->world->setShapeTagCodec(&v54->world->hknpWorldWriter, NULL);
  LeaveCriticalSection((LPCRITICAL_SECTION)&v54->critSection);
  if ( !*(_QWORD *)(v51 + 248) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3613, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->bodySFXEventAssets)", (const char *)&queryFormat, "havokPhysicsWorld->bodySFXEventAssets") )
    __debugbreak();
  v55 = *(_QWORD *)(v51 + 248);
  if ( v55 )
  {
    v56 = hkMemHeapAllocator();
    *(_DWORD *)(v55 + 8) = 0;
    v57 = *(_DWORD *)(v55 + 12);
    if ( v57 >= 0 )
      hkMemoryAllocator::bufFree2(v56, *(void **)v55, 8, v57 & 0x3FFFFFFF);
    *(_QWORD *)v55 = 0i64;
    *(_DWORD *)(v55 + 12) = 0x80000000;
    v58 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v58 )
      v58 = hkMemoryRouter::s_fallbackRouter;
    v58->m_heap->blockFree(v58->m_heap, (void *)v55, 16);
  }
  *(_QWORD *)(v51 + 248) = 0i64;
  if ( !*(_QWORD *)(v51 + 256) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3616, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->bodyVFXEventAssets)", (const char *)&queryFormat, "havokPhysicsWorld->bodyVFXEventAssets") )
    __debugbreak();
  v59 = *(_QWORD *)(v51 + 256);
  if ( v59 )
  {
    v60 = hkMemHeapAllocator();
    *(_DWORD *)(v59 + 8) = 0;
    v61 = *(_DWORD *)(v59 + 12);
    if ( v61 >= 0 )
      hkMemoryAllocator::bufFree2(v60, *(void **)v59, 8, v61 & 0x3FFFFFFF);
    *(_QWORD *)v59 = 0i64;
    *(_DWORD *)(v59 + 12) = 0x80000000;
    v62 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v62 )
      v62 = hkMemoryRouter::s_fallbackRouter;
    v62->m_heap->blockFree(v62->m_heap, (void *)v59, 16);
  }
  *(_QWORD *)(v51 + 256) = 0i64;
  if ( !*(_QWORD *)(v51 + 448) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3621, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletEffectEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletEffectEntries") )
    __debugbreak();
  v63 = *(_QWORD *)(v51 + 448);
  if ( v63 )
  {
    v64 = hkMemHeapAllocator();
    *(_DWORD *)(v63 + 8) = 0;
    v65 = *(_DWORD *)(v63 + 12);
    if ( v65 >= 0 )
      hkMemoryAllocator::bufFree2(v64, *(void **)v63, 136, v65 & 0x3FFFFFFF);
    *(_QWORD *)v63 = 0i64;
    *(_DWORD *)(v63 + 12) = 0x80000000;
    v66 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v66 )
      v66 = hkMemoryRouter::s_fallbackRouter;
    v66->m_heap->blockFree(v66->m_heap, (void *)v63, 16);
  }
  *(_QWORD *)(v51 + 448) = 0i64;
  if ( !*(_QWORD *)(v51 + 440) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3625, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  v67 = *(_QWORD *)(v51 + 440);
  if ( v67 )
  {
    v68 = hkMemHeapAllocator();
    *(_DWORD *)(v67 + 8) = 0;
    v69 = *(_DWORD *)(v67 + 12);
    if ( v69 >= 0 )
      hkMemoryAllocator::bufFree2(v68, *(void **)v67, 48, v69 & 0x3FFFFFFF);
    *(_QWORD *)v67 = 0i64;
    *(_DWORD *)(v67 + 12) = 0x80000000;
    v70 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v70 )
      v70 = hkMemoryRouter::s_fallbackRouter;
    v70->m_heap->blockFree(v70->m_heap, (void *)v67, 16);
  }
  *(_QWORD *)(v51 + 440) = 0i64;
  if ( !*(_QWORD *)(v51 + 432) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3629, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  v71 = *(_QWORD *)(v51 + 432);
  if ( v71 )
  {
    v72 = hkMemHeapAllocator();
    *(_DWORD *)(v71 + 8) = 0;
    v73 = *(_DWORD *)(v71 + 12);
    if ( v73 >= 0 )
      hkMemoryAllocator::bufFree2(v72, *(void **)v71, 104, v73 & 0x3FFFFFFF);
    *(_QWORD *)v71 = 0i64;
    *(_DWORD *)(v71 + 12) = 0x80000000;
    v74 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v74 )
      v74 = hkMemoryRouter::s_fallbackRouter;
    v74->m_heap->blockFree(v74->m_heap, (void *)v71, 16);
  }
  *(_QWORD *)(v51 + 432) = 0i64;
  if ( !*(_QWORD *)(v51 + 424) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3633, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  v75 = *(_QWORD *)(v51 + 424);
  if ( v75 )
  {
    v76 = hkMemHeapAllocator();
    *(_DWORD *)(v75 + 8) = 0;
    v77 = *(_DWORD *)(v75 + 12);
    if ( v77 >= 0 )
      hkMemoryAllocator::bufFree2(v76, *(void **)v75, 32, v77 & 0x3FFFFFFF);
    *(_QWORD *)v75 = 0i64;
    *(_DWORD *)(v75 + 12) = 0x80000000;
    v78 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v78 )
      v78 = hkMemoryRouter::s_fallbackRouter;
    v78->m_heap->blockFree(v78->m_heap, (void *)v75, 16);
  }
  *(_QWORD *)(v51 + 424) = 0i64;
  if ( !*(_QWORD *)(v51 + 416) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3637, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->capsuleRadii)", (const char *)&queryFormat, "havokPhysicsWorld->capsuleRadii") )
    __debugbreak();
  v79 = *(void **)(v51 + 416);
  if ( v79 )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(*(hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> **)(v51 + 416));
    v80 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v80 )
      v80 = hkMemoryRouter::s_fallbackRouter;
    v80->m_heap->blockFree(v80->m_heap, v79, 16);
  }
  *(_QWORD *)(v51 + 416) = 0i64;
  v81 = (__int64 *)(v51 + 296);
  v82 = 2i64;
  do
  {
    if ( !*(v81 - 2) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3643, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !*v81 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3644, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->aabbQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->aabbQueryRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3645, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->raycastRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->raycastRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3646, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->shapecastRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->shapecastRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3647, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->queryPointRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->queryPointRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3648, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx]") )
      __debugbreak();
    v83 = (__int64 *)v81[4];
    v84 = *v83;
    if ( *v83 != *v83 + ((__int64)*((int *)v83 + 2) << 7) )
    {
      do
      {
        v85 = *(hkReferencedObject **)(v84 + 8);
        if ( v85 )
        {
          hkReferencedObject::removeReference(v85);
          *(_QWORD *)(v84 + 8) = 0i64;
        }
        v84 += 128i64;
      }
      while ( v84 != *(_QWORD *)v81[4] + ((__int64)*(int *)(v81[4] + 8) << 7) );
    }
    v86 = (__int64 *)v81[8];
    v87 = *v86;
    if ( *v86 != *v86 + 112i64 * *((int *)v86 + 2) )
    {
      do
      {
        v88 = *(hkReferencedObject **)(v87 + 8);
        if ( v88 )
        {
          hkReferencedObject::removeReference(v88);
          *(_QWORD *)(v87 + 8) = 0i64;
        }
        v87 += 112i64;
      }
      while ( v87 != *(_QWORD *)v81[8] + 112i64 * *(int *)(v81[8] + 8) );
    }
    v89 = *(v81 - 2);
    if ( v89 )
    {
      v90 = hkMemHeapAllocator();
      *(_DWORD *)(v89 + 8) = 0;
      v91 = *(_DWORD *)(v89 + 12);
      if ( v91 >= 0 )
        hkMemoryAllocator::bufFree2(v90, *(void **)v89, 64, v91 & 0x3FFFFFFF);
      *(_QWORD *)v89 = 0i64;
      *(_DWORD *)(v89 + 12) = 0x80000000;
      v92 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v92 )
        v92 = hkMemoryRouter::s_fallbackRouter;
      v92->m_heap->blockFree(v92->m_heap, (void *)v89, 16);
    }
    *(v81 - 2) = 0i64;
    v93 = *v81;
    if ( *v81 )
    {
      v94 = hkMemHeapAllocator();
      *(_DWORD *)(v93 + 8) = 0;
      v95 = *(_DWORD *)(v93 + 12);
      if ( v95 >= 0 )
        hkMemoryAllocator::bufFree2(v94, *(void **)v93, 80, v95 & 0x3FFFFFFF);
      *(_QWORD *)v93 = 0i64;
      *(_DWORD *)(v93 + 12) = 0x80000000;
      v96 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v96 )
        v96 = hkMemoryRouter::s_fallbackRouter;
      v96->m_heap->blockFree(v96->m_heap, (void *)v93, 16);
    }
    *v81 = 0i64;
    v97 = v81[2];
    if ( v97 )
    {
      v98 = hkMemHeapAllocator();
      *(_DWORD *)(v97 + 8) = 0;
      v99 = *(_DWORD *)(v97 + 12);
      if ( v99 >= 0 )
        hkMemoryAllocator::bufFree2(v98, *(void **)v97, 96, v99 & 0x3FFFFFFF);
      *(_QWORD *)v97 = 0i64;
      *(_DWORD *)(v97 + 12) = 0x80000000;
      v100 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v100 )
        v100 = hkMemoryRouter::s_fallbackRouter;
      v100->m_heap->blockFree(v100->m_heap, (void *)v97, 16);
    }
    v81[2] = 0i64;
    v101 = v81[4];
    if ( v101 )
    {
      v102 = hkMemHeapAllocator();
      *(_DWORD *)(v101 + 8) = 0;
      v103 = *(_DWORD *)(v101 + 12);
      if ( v103 >= 0 )
        hkMemoryAllocator::bufFree2(v102, *(void **)v101, 128, v103 & 0x3FFFFFFF);
      *(_QWORD *)v101 = 0i64;
      *(_DWORD *)(v101 + 12) = 0x80000000;
      v104 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v104 )
        v104 = hkMemoryRouter::s_fallbackRouter;
      v104->m_heap->blockFree(v104->m_heap, (void *)v101, 16);
    }
    v81[4] = 0i64;
    v105 = v81[6];
    if ( v105 )
    {
      v106 = hkMemHeapAllocator();
      *(_DWORD *)(v105 + 8) = 0;
      v107 = *(_DWORD *)(v105 + 12);
      if ( v107 >= 0 )
        hkMemoryAllocator::bufFree2(v106, *(void **)v105, 80, v107 & 0x3FFFFFFF);
      *(_QWORD *)v105 = 0i64;
      *(_DWORD *)(v105 + 12) = 0x80000000;
      v108 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v108 )
        v108 = hkMemoryRouter::s_fallbackRouter;
      v108->m_heap->blockFree(v108->m_heap, (void *)v105, 16);
    }
    v81[6] = 0i64;
    v109 = v81[8];
    if ( v109 )
    {
      v110 = hkMemHeapAllocator();
      *(_DWORD *)(v109 + 8) = 0;
      v111 = *(_DWORD *)(v109 + 12);
      if ( v111 >= 0 )
        hkMemoryAllocator::bufFree2(v110, *(void **)v109, 112, v111 & 0x3FFFFFFF);
      *(_QWORD *)v109 = 0i64;
      *(_DWORD *)(v109 + 12) = 0x80000000;
      v112 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v112 )
        v112 = hkMemoryRouter::s_fallbackRouter;
      v112->m_heap->blockFree(v112->m_heap, (void *)v109, 16);
    }
    v81[8] = 0i64;
    ++v81;
    --v82;
  }
  while ( v82 );
  HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(&s_havokPhysicsMotionPropertiesLibrary, worldId);
  HavokPhysics_RemoveMaterialLibraryFromWorld(&s_havokPhysicsMaterialLibrary, worldId);
  IsQueryWorld = Physics_IsQueryWorld(worldId);
  v114 = (__int64)v132;
  if ( IsQueryWorld )
  {
    if ( v132->gravityModifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3699, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->gravityModifier == 0)", (const char *)&queryFormat, "havokPhysicsWorld->gravityModifier == NULL") )
      __debugbreak();
  }
  else
  {
    if ( !v132->gravityModifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3703, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->gravityModifier != 0)", (const char *)&queryFormat, "havokPhysicsWorld->gravityModifier != NULL") )
      __debugbreak();
    hknpModifierManager::removeModifier(*(hknpModifierManager **)(*(_QWORD *)(v114 + 24) + 1200i64), *(hknpModifier **)(v114 + 264));
    PhysicsGravityModifier_Destroy(*(hknpModifier **)(v114 + 264));
    *(_QWORD *)(v114 + 264) = 0i64;
  }
  if ( !*(_QWORD *)(v114 + 24) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3710, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyWorld %i: world is NULL", "havokPhysicsWorld->world", v125) )
      __debugbreak();
  }
  v115 = *(_QWORD *)(v114 + 24);
  _InterlockedOr(v124, 0);
  LOWORD(v115) = *(_WORD *)(v115 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v115 != 1 )
  {
    v116 = *(_QWORD *)(v114 + 24);
    _InterlockedOr(v124, 0);
    LODWORD(v116) = *(unsigned __int16 *)(v116 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v116;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3711, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: world has %i references - should be 1", "havokPhysicsWorld->world->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 24));
  *(_QWORD *)(v114 + 24) = 0i64;
  HavokPhysicsInstanceManager_Shutdown((HavokPhysicsInstanceManager *)(v114 + 192));
  if ( (*(_BYTE *)(v114 + 136) || *(_BYTE *)(v114 + 137)) && !*(_QWORD *)(v114 + 144) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3719, ASSERT_TYPE_ASSERT, "(!( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics DestroyWorld %i: task queue is NULL", "!( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || havokPhysicsWorld->taskQueue", v125) )
      __debugbreak();
  }
  if ( *(_BYTE *)(v114 + 136) )
    goto LABEL_265;
  if ( !*(_BYTE *)(v114 + 137) )
  {
    if ( *(_QWORD *)(v114 + 144) )
    {
      LODWORD(v125) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3720, ASSERT_TYPE_ASSERT, "(( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics DestroyWorld %i: task queue is not NULL", "( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue", v125) )
        __debugbreak();
    }
  }
  if ( *(_BYTE *)(v114 + 136) )
  {
LABEL_265:
    v117 = *(_QWORD *)(v114 + 144);
    if ( v117 )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v117 + 8i64))(v117, 1i64);
    *(_QWORD *)(v114 + 144) = 0i64;
  }
  if ( !*(_QWORD *)v114 )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3728, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter)", "%s\n\tHavokPhysics DestroyWorld %i: trace collision filter is NULL", "havokPhysicsWorld->traceCollisionFilter", v125) )
      __debugbreak();
  }
  v118 = *(hkReferencedObject **)v114;
  _InterlockedOr(v124, 0);
  LOWORD(v118) = v118->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)v118 != 1 )
  {
    v119 = *(hkReferencedObject **)v114;
    _InterlockedOr(v124, 0);
    LODWORD(v119) = v119->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v119;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3729, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: trace collision filter has %i references - should be 1", "havokPhysicsWorld->traceCollisionFilter->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)v114);
  *(_QWORD *)v114 = 0i64;
  if ( !*(_QWORD *)(v114 + 8) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3732, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter)", "%s\n\tHavokPhysics DestroyWorld %i: simulation collision filter is NULL", "havokPhysicsWorld->simulationCollisionFilter", v125) )
      __debugbreak();
  }
  v120 = *(_QWORD *)(v114 + 8);
  _InterlockedOr(v124, 0);
  LOWORD(v120) = *(_WORD *)(v120 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v120 != 1 )
  {
    v121 = *(_QWORD *)(v114 + 8);
    _InterlockedOr(v124, 0);
    LODWORD(v121) = *(unsigned __int16 *)(v121 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v121;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3733, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: simulation collision filter has %i references - should be 1", "havokPhysicsWorld->simulationCollisionFilter->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 8));
  *(_QWORD *)(v114 + 8) = 0i64;
  if ( !*(_QWORD *)(v114 + 16) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3738, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics DestroyWorld %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v125) )
      __debugbreak();
  }
  v122 = *(_QWORD *)(v114 + 16);
  _InterlockedOr(v124, 0);
  LOWORD(v122) = *(_WORD *)(v122 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v122 != 1 )
  {
    v123 = *(_QWORD *)(v114 + 16);
    _InterlockedOr(v124, 0);
    LODWORD(v123) = *(unsigned __int16 *)(v123 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v123;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3739, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: persistent stream allocator has %i references - should be 1", "havokPhysicsWorld->persistentStreamAllocator->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  if ( hkFixedBlockStreamAllocator::getCapacity(*(hkFixedBlockStreamAllocator **)(v114 + 16)) > 0 )
    hkFixedBlockStreamAllocator::clear(*(hkFixedBlockStreamAllocator **)(v114 + 16));
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 16));
  *(_QWORD *)(v114 + 16) = 0i64;
  LeaveCriticalSection(p_critSection);
}

/*
==============
HavokPhysics_DirtyBroadphase
==============
*/
void HavokPhysics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  HavokPhysicsWorld *MutableWorld; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  MutableWorld->world->m_broadPhase->markBodiesDirty(MutableWorld->world->m_broadPhase, array->m_data, array->m_size, 4);
}

/*
==============
HavokPhysics_DisableShapeCache
==============
*/
void HavokPhysics_DisableShapeCache(unsigned int threadId, bool disable)
{
  __int64 v2; 
  bool *v4; 

  v2 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15855, ASSERT_TYPE_ASSERT, "(threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS)", (const char *)&queryFormat, "threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS") )
    __debugbreak();
  v4 = &s_havokPhysicsShapeCachesDisabled[v2];
  if ( *v4 == disable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15856, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCachesDisabled[threadId] != disable)", (const char *)&queryFormat, "s_havokPhysicsShapeCachesDisabled[threadId] != disable") )
    __debugbreak();
  *v4 = disable;
}

/*
==============
HavokPhysics_DoDeferredQueries
==============
*/
void HavokPhysics_DoDeferredQueries(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 activeQueryRequestList; 
  hkArray<HavokPhysics_AABBBroadphaseQueryRequest,hkContainerHeapAllocator> *v7; 
  Physics_DeferredBroadphaseCollisionQueryData *deferredData; 
  HavokPhysics_BroadphaseCollisionQueryResult *v14; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 traceCollisionFilter; 
  hkMonitorStream *Value; 
  hkMonitorStream *v22; 
  Physics_DeferredBroadphaseCollisionQueryData *v23; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v26; 
  hknpBodyId *p_bodyId; 
  int v30; 
  _BYTE *v31; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v32; 
  hknpBodyId *v33; 
  hknpBodyId *v34; 
  _BYTE *v35; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v36; 
  hknpBodyId *v37; 
  hknpBodyId *v38; 
  __int64 v39; 
  hknpShape *v40; 
  HavokPhysics_CollisionQueryResult *startResult; 
  HavokPhysics_CollisionQueryResult *v42; 
  _BYTE *v43; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v44; 
  Physics_DeferredCollisionQueryData *v48; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v49; 
  hknpShape *shape; 
  Physics_DeferredCollisionQueryData *v53; 
  float fmt; 
  float result; 
  Physics_ShapecastExtendedData *extendedData; 
  hkAabb v57; 
  int v58; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v60; 
  Physics_QueryPhaseSelection phaseSelection; 
  HavokPhysicsShapeTagCodec *v63; 
  __int64 v64; 
  __int16 v65; 
  int contents; 
  int *v67; 
  int v68; 
  char v69; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DoDeferredQueries with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  activeQueryRequestList = (unsigned int)MutableWorld->activeQueryRequestList;
  v7 = MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList];
  _RBX = v7->m_data;
  if ( v7->m_data != &v7->m_data[(__int64)v7->m_size] )
  {
    __asm
    {
      vmovaps [rsp+148h+var_38], xmm6
      vpxor   xmm0, xmm0, xmm0
      vmovaps [rsp+148h+var_48], xmm7
      vpinsrw xmm0, xmm0, eax, 1
      vpshufd xmm6, xmm0, 0
      vxorps  xmm7, xmm7, xmm7
    }
    do
    {
      deferredData = _RBX->deferredData;
      ignoreBodies = NULL;
      v60 = 1;
      phaseSelection = All;
      v14 = deferredData->result;
      v65 = -1;
      contents = 0;
      v67 = NULL;
      v64 = 0i64;
      v63 = NULL;
      v68 = 2;
      v69 = -5;
      __asm
      {
        vmovups ymm0, ymmword ptr [rbx]
        vmovups [rsp+148h+var_F8], ymm0
        vpxor   xmm0, xmm0, xmm0
        vmovdqu [rsp+148h+var_C0], xmm0
        vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+240h; __m128 const near * const g_vectorfConstants
        vmovups xmmword ptr [rsp+148h+var_78], xmm0
        vxorps  xmm0, xmm0, xmm6
        vmovups xmmword ptr [rsp+148h+var_78+10h], xmm0
        vmovss  [rsp+148h+var_D8], xmm7
      }
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(extendedData) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13758, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", extendedData) )
          __debugbreak();
      }
      if ( _RBX == (HavokPhysics_AABBBroadphaseQueryRequest *)-32i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13759, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid extended data", "extendedData") )
        __debugbreak();
      if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13760, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid result", "result") )
        __debugbreak();
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      __asm { vmovups ymm0, [rsp+148h+var_F8] }
      ignoreBodies = _RBX->extendedData.ignoreBodies;
      phaseSelection = _RBX->extendedData.phaseSelection;
      v63 = s_shapeTagCodec;
      __asm { vmovups [rsp+148h+var_78], ymm0 }
      traceCollisionFilter = (__int64)ConstWorld->traceCollisionFilter;
      v65 = -1;
      contents = _RBX->extendedData.contents;
      v64 = traceCollisionFilter;
      v67 = &v58;
      v68 = 0;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      if ( Value )
        hkMonitorStream::timerBegin(Value, "TtQueryBroadphaseAABB_HK");
      ConstWorld->world->queryAabb(&ConstWorld->world->hknpWorldReader, (const hknpAabbQuery *)&v63, &v14->m_hits);
      v22 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      if ( v22 )
        hkMonitorStream::timerEnd(v22, "Et");
      v23 = _RBX->deferredData;
      ++_RBX;
      v23->isComplete = 1;
    }
    while ( _RBX != &MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_data[(__int64)MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_size] );
    __asm
    {
      vmovaps xmm7, [rsp+148h+var_48]
      vmovaps xmm6, [rsp+148h+var_38]
    }
  }
  v26 = MutableWorld->aabbQueryRequestLists[activeQueryRequestList];
  p_bodyId = &v26->m_data->bodyId;
  if ( v26->m_data != &v26->m_data[v26->m_size] )
  {
    _RBX = p_bodyId + 12;
    do
    {
      __asm { vmovups ymm0, ymmword ptr [rbx-20h] }
      v30 = p_bodyId->m_serialAndIndex & 0xFFFFFF;
      __asm { vmovups [rsp+148h+var_F8], ymm0 }
      if ( v30 == 0xFFFFFF )
        HavokPhysics_AABBQuery(worldId, &v57, (Physics_AABBQueryExtendedData *)_RBX, *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&_RBX[6].m_serialAndIndex + 8i64));
      else
        HavokPhysics_AABBQuery(worldId, (hknpBodyId)p_bodyId->m_serialAndIndex, &v57, (Physics_AABBQueryExtendedData *)_RBX, *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&_RBX[6].m_serialAndIndex + 8i64));
      v31 = *(_BYTE **)&_RBX[6].m_serialAndIndex;
      p_bodyId += 20;
      _RBX += 20;
      *v31 = 1;
    }
    while ( p_bodyId != &MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_data[MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v32 = MutableWorld->raycastRequestLists[activeQueryRequestList];
  v33 = &v32->m_data->bodyId;
  if ( v32->m_data != &v32->m_data[v32->m_size] )
  {
    v34 = v33 + 8;
    do
    {
      if ( (v33->m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_Raycast(worldId, (const hkVector4f *)&v34[-4], (const hkVector4f *)v34, (Physics_RaycastExtendedData *)&v34[4], *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v34[14].m_serialAndIndex + 8i64));
      else
        HavokPhysics_Raycast(worldId, (hknpBodyId)v33->m_serialAndIndex, (const hkVector4f *)&v34[-4], (const hkVector4f *)v34, (Physics_RaycastExtendedData *)&v34[4], *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v34[14].m_serialAndIndex + 8i64));
      v35 = *(_BYTE **)&v34[14].m_serialAndIndex;
      v33 += 24;
      v34 += 24;
      *v35 = 1;
    }
    while ( v33 != &MutableWorld->raycastRequestLists[activeQueryRequestList]->m_data[MutableWorld->raycastRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v36 = MutableWorld->shapecastRequestLists[activeQueryRequestList];
  v37 = &v36->m_data->bodyId;
  if ( v36->m_data != &v36->m_data[(__int64)v36->m_size] )
  {
    v38 = v37 + 12;
    do
    {
      v39 = *(_QWORD *)&v38[18].m_serialAndIndex;
      v40 = *(hknpShape **)&v38[-10].m_serialAndIndex;
      startResult = *(HavokPhysics_CollisionQueryResult **)(v39 + 16);
      v42 = *(HavokPhysics_CollisionQueryResult **)(v39 + 8);
      if ( (v37->m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_Shapecast(worldId, v40, (const hkVector4f *)&v38[-8], (const hkVector4f *)&v38[-4], (const hkQuaternionf *)v38, (Physics_ShapecastExtendedData *)&v38[4], v42, startResult);
      else
        HavokPhysics_Shapecast(worldId, (hknpBodyId)v37->m_serialAndIndex, v40, (const hkVector4f *)&v38[-8], (const hkVector4f *)&v38[-4], (const hkQuaternionf *)v38, (Physics_ShapecastExtendedData *)&v38[4], v42, startResult);
      if ( !*(_QWORD *)&v38[-10].m_serialAndIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15470, ASSERT_TYPE_ASSERT, "(request.shape)", (const char *)&queryFormat, "request.shape") )
        __debugbreak();
      hkReferencedObject::removeReference(*(hkReferencedObject **)&v38[-10].m_serialAndIndex);
      v43 = *(_BYTE **)&v38[18].m_serialAndIndex;
      v37 += 32;
      *(_QWORD *)&v38[-10].m_serialAndIndex = 0i64;
      v38 += 32;
      *v43 = 1;
    }
    while ( v37 != &MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_data[(__int64)MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v44 = MutableWorld->queryPointRequestLists[activeQueryRequestList];
  _RBX = v44->m_data;
  if ( v44->m_data != &v44->m_data[v44->m_size] )
  {
    do
    {
      __asm { vmovss  xmm2, dword ptr [rbx+20h]; maxDistance }
      if ( (_RBX->bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        HavokPhysics_QueryPoint(worldId, &_RBX->point, *(float *)&_XMM2, &_RBX->extendedData, _RBX->deferredData->result);
      }
      else
      {
        __asm { vmovaps xmm3, xmm2; maxDistance }
        HavokPhysics_QueryPoint(worldId, _RBX->bodyId, &_RBX->point, *(float *)&_XMM3, &_RBX->extendedData, _RBX->deferredData->result);
      }
      v48 = _RBX->deferredData;
      ++_RBX;
      v48->isComplete = 1;
    }
    while ( _RBX != &MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_data[MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_size] );
  }
  v49 = MutableWorld->getClosestPointsRequestLists[activeQueryRequestList];
  _RBX = v49->m_data;
  if ( v49->m_data != &v49->m_data[v49->m_size] )
  {
    do
    {
      __asm { vmovss  xmm0, dword ptr [rbx+30h] }
      shape = _RBX->shape;
      if ( (_RBX->bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        __asm { vmovss  dword ptr [rsp+148h+fmt], xmm0 }
        HavokPhysics_GetClosestPoints(worldId, shape, &_RBX->point, &_RBX->rotation, fmt, &_RBX->extendedData, _RBX->deferredData->result);
      }
      else
      {
        __asm { vmovss  dword ptr [rsp+148h+result], xmm0 }
        HavokPhysics_GetClosestPoints(worldId, _RBX->bodyId, shape, &_RBX->point, &_RBX->rotation, result, &_RBX->extendedData, _RBX->deferredData->result);
      }
      if ( !_RBX->shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15508, ASSERT_TYPE_ASSERT, "(request.shape)", (const char *)&queryFormat, "request.shape") )
        __debugbreak();
      hkReferencedObject::removeReference(_RBX->shape);
      v53 = _RBX->deferredData;
      _RBX->shape = NULL;
      ++_RBX;
      v53->isComplete = 1;
    }
    while ( _RBX != &MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_data[MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_size] );
  }
  MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->raycastRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_size = 0;
}

/*
==============
HavokPhysics_DoGarbageCollectionClient
==============
*/
void HavokPhysics_DoGarbageCollectionClient(void)
{
  unsigned int i; 

  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GarbageCollection Client");
  if ( s_memoryRouter )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  if ( s_threadMemoryRouters[Physics_GetRendererThreadId()] )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  for ( i = 0; i < 3; ++i )
  {
    if ( s_threadMemoryRouters[Physics_GetWorkerThreadId(i + 2)] )
      ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  }
  s_havokPhysicsMemorySystem->garbageCollectShared(s_havokPhysicsMemorySystem);
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_DoGarbageCollectionServer
==============
*/
void HavokPhysics_DoGarbageCollectionServer(void)
{
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GarbageCollection Server");
  if ( s_threadMemoryRouters[Physics_GetServerThreadId()] )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  s_havokPhysicsMemorySystem->garbageCollectShared(s_havokPhysicsMemorySystem);
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_DrawDebugAABBBroadphaseWorldQuery
==============
*/
void HavokPhysics_DrawDebugAABBBroadphaseWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v18; 
  unsigned int v20; 
  __int64 v21; 
  bool v25; 
  int v26; 
  int v35; 
  __int64 v36; 
  HavokPhysics_BroadphaseCollisionQueryResult *result; 
  __int64 m_size; 
  __int64 v83; 
  unsigned int m_serialAndIndex; 
  const char *v88; 
  int v118; 
  hkMemoryAllocator *v119; 
  int v120; 
  int v121; 
  hknpBodyId *v122; 
  float fmt; 
  char *fmta; 
  int forceColor; 
  __int64 forceColora; 
  __int64 shadow; 
  float charHeighta; 
  __int64 charHeightb; 
  float charHeightc; 
  float charHeightd; 
  float charHeighte; 
  unsigned int contentsa; 
  int numInOut[2]; 
  int v136[2]; 
  ScreenPlacement *scrPlacea; 
  __int64 v138; 
  __int128 v139; 
  __int64 v140; 
  vec3_t center; 
  vec3_t origin; 
  Bounds bounds; 
  char dest[256]; 
  char v145; 
  void *retaddr; 

  _RAX = &retaddr;
  v138 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
  }
  v18 = scrPlace;
  scrPlacea = (ScreenPlacement *)scrPlace;
  _R14 = aabb;
  v20 = collisionFilterInfo;
  v21 = worldId;
  _R12 = x;
  _R13 = y;
  LODWORD(v140) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22346, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugAABBBroadphaseWorldQuery with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RSI = HavokPhysics_GetMutableWorld((Physics_WorldId)v21);
  if ( dword_150D5FA4C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA4C);
    if ( dword_150D5FA4C == -1 )
    {
      numInOut[0] = 0;
      hkMemHeapAllocator();
      v118 = 0x80000000;
      ignoreBodies.m_ignoreEntities.m_data = NULL;
      ignoreBodies.m_ignoreEntities.m_size = 0;
      ignoreBodies.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies.m_ignoreBodies.m_data = NULL;
      ignoreBodies.m_ignoreBodies.m_size = 0;
      ignoreBodies.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      v136[0] = 0;
      v119 = hkMemHeapAllocator();
      v120 = v136[0];
      v121 = v136[0];
      if ( v136[0] )
      {
        v122 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v119, 4, v136);
        v120 = v136[0];
      }
      else
      {
        v122 = NULL;
      }
      if ( v120 )
        v118 = v120;
      ignoreBodies.m_ignoreBodies.m_data = v122;
      ignoreBodies.m_ignoreBodies.m_size = v121;
      ignoreBodies.m_ignoreBodies.m_capacityAndFlags = v118;
      *(_QWORD *)&ignoreBodies.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies.m_isClutter = 0;
      ignoreBodies.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugAABBBroadphaseWorldQuery_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA4C);
      v18 = scrPlacea;
      v20 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v25 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v25) )
    ignoreBodies.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  LODWORD(v139) = v20;
  *((_QWORD *)&v139 + 1) = &ignoreBodies;
  v26 = s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v21];
  if ( v26 == -1 )
  {
    if ( _RSI->requestDebugAABBBroadphaseQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22362, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugAABBBroadphaseQuery)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugAABBBroadphaseQuery") )
      __debugbreak();
    s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v21] = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups xmmword ptr [rsi+0C90h], xmm0
      vmovups xmm1, xmmword ptr [r14+10h]
      vmovups xmmword ptr [rsi+0CA0h], xmm1
      vmovups xmm0, [rsp+2A0h+var_230+8]
      vmovups xmmword ptr [rsi+0CB0h], xmm0
      vmovsd  xmm1, [rbp+1A0h+var_218]
      vmovsd  qword ptr [rsi+0CC0h], xmm1
    }
    _RSI->requestDebugAABBBroadphaseQuery = 1;
  }
  else
  {
    if ( !_RSI->requestDebugAABBBroadphaseQuery && s_havokPhysicsWorldAABBBroadphaseQueryData[2 * (int)v21 + v26].isComplete )
    {
      v26 = 1 - v26;
      s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v21] = v26;
      s_havokPhysicsWorldAABBBroadphaseQueryData[2 * (int)v21 + v26].result->m_hits.m_size = 0;
      __asm
      {
        vmovups xmm0, xmmword ptr [r14]
        vmovups xmmword ptr [rsi+0C90h], xmm0
        vmovups xmm1, xmmword ptr [r14+10h]
        vmovups xmmword ptr [rsi+0CA0h], xmm1
        vmovups xmm0, [rsp+2A0h+var_230+8]
        vmovups xmmword ptr [rsi+0CB0h], xmm0
        vmovsd  xmm1, [rbp+1A0h+var_218]
        vmovsd  qword ptr [rsi+0CC0h], xmm1
      }
      _RSI->requestDebugAABBBroadphaseQuery = 1;
    }
    v35 = 2 * v21 - v26;
    if ( v26 != -1 )
    {
      v36 = v35 + 1i64;
      if ( s_havokPhysicsWorldAABBBroadphaseQueryData[v36].isComplete )
      {
        Com_sprintf<256>((char (*)[256])dest, "AABB Broadphase Query");
        __asm
        {
          vmovss  xmm13, [rbp+1A0h+arg_38]
          vmovss  [rsp+2A0h+charHeight], xmm13
          vmovss  xmm2, dword ptr [r13+0]; y
          vmovss  xmm1, dword ptr [r12]; x
        }
        Physics_DrawDebugString(v18, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighta, 0);
        __asm
        {
          vaddss  xmm0, xmm13, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vmovss  xmm14, [rbp+1A0h+arg_30]
          vaddss  xmm0, xmm14, dword ptr [r12]
          vmovss  dword ptr [r12], xmm0
          vmovss  dword ptr [rsp+2A0h+forceColor], xmm13
          vmovss  dword ptr [rsp+2A0h+fmt], xmm14
        }
        HavokPhysics_DrawPhysicsContents(collisionFilterInfo, v18, x, y, fmt, *(float *)&forceColor);
        __asm
        {
          vmovss  xmm0, dword ptr [r12]
          vsubss  xmm1, xmm0, xmm14
          vmovss  dword ptr [r12], xmm1
          vmovss  xmm12, cs:__real@42000000
          vmulss  xmm9, xmm12, dword ptr [r14]
          vmulss  xmm10, xmm12, dword ptr [r14+4]
          vmulss  xmm11, xmm12, dword ptr [r14+8]
          vmulss  xmm6, xmm12, dword ptr [r14+10h]
          vmulss  xmm7, xmm12, dword ptr [r14+14h]
          vmulss  xmm8, xmm12, dword ptr [r14+18h]
          vcvttss2si eax, xmm8
          vcvttss2si ecx, xmm7
          vcvttss2si edx, xmm6
          vcvttss2si r10d, xmm11
          vcvttss2si r9d, xmm10
          vcvttss2si r8d, xmm9
        }
        LODWORD(charHeightb) = _EAX;
        LODWORD(shadow) = _ECX;
        LODWORD(forceColora) = _EDX;
        LODWORD(fmta) = _ER10;
        Com_sprintf<256>((char (*)[256])dest, "AABB min(%i %i %i) max(%i %i %i)", _R8, _R9, fmta, forceColora, shadow, charHeightb);
        __asm
        {
          vmovss  [rsp+2A0h+charHeight], xmm13
          vmovss  xmm2, dword ptr [r13+0]; y
          vmovss  xmm1, dword ptr [r12]; x
        }
        Physics_DrawDebugString(v18, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightc, 0);
        __asm
        {
          vaddss  xmm0, xmm13, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vxorps  xmm5, xmm5, xmm5
          vmovss  dword ptr [rbp+1A0h+origin], xmm5
          vmovss  dword ptr [rbp+1A0h+origin+4], xmm5
          vmovss  dword ptr [rbp+1A0h+origin+8], xmm5
          vaddss  xmm0, xmm6, xmm9
          vmovss  xmm4, cs:__real@3f000000
          vmulss  xmm0, xmm0, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.midPoint], xmm0
          vsubss  xmm1, xmm6, xmm9
          vmulss  xmm2, xmm1, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.halfSize], xmm2
          vaddss  xmm0, xmm7, xmm10
          vmulss  xmm1, xmm0, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.midPoint+4], xmm1
          vsubss  xmm3, xmm7, xmm10
          vmulss  xmm0, xmm3, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.halfSize+4], xmm0
          vaddss  xmm1, xmm8, xmm11
          vmulss  xmm3, xmm1, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.midPoint+8], xmm3
          vsubss  xmm0, xmm8, xmm11
          vmulss  xmm1, xmm0, xmm4
          vmovss  dword ptr [rbp+1A0h+bounds.halfSize+8], xmm1
          vxorps  xmm2, xmm2, xmm2; yaw
        }
        CG_DebugBox(&origin, &bounds, *(float *)&_XMM2, &colorYellow, 0, 0);
        result = s_havokPhysicsWorldAABBBroadphaseQueryData[v36].result;
        *(_QWORD *)numInOut = result;
        m_size = result->m_hits.m_size;
        Com_sprintf<256>((char (*)[256])dest, "Result %i Hits", (unsigned int)result->m_hits.m_size);
        __asm
        {
          vmovss  [rsp+2A0h+charHeight], xmm13
          vmovss  xmm2, dword ptr [r13+0]; y
          vmovss  xmm1, dword ptr [r12]; x
        }
        Physics_DrawDebugString(v18, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightd, 0);
        __asm
        {
          vaddss  xmm0, xmm13, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vaddss  xmm1, xmm14, dword ptr [r12]
          vmovss  dword ptr [r12], xmm1
        }
        contentsa = 0;
        *(_QWORD *)v136 = m_size;
        if ( (int)m_size > 0 )
        {
          v83 = 0i64;
          __asm
          {
            vmovss  xmm7, cs:__real@40a00000
            vmovss  xmm8, cs:__real@3f800000
          }
          do
          {
            m_serialAndIndex = result->m_hits.m_data[v83].m_serialAndIndex;
            _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))_RSI->world->getBody)(&_RSI->world->hknpWorldReader, m_serialAndIndex);
            v88 = (const char *)((unsigned __int64)_RSI->world->m_bodyManager.m_bodyNames.m_data[m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
            __asm { vmovups xmm6, xmmword ptr [rax+30h] }
            Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s", contentsa, m_serialAndIndex, v88);
            __asm
            {
              vmovss  [rsp+2A0h+charHeight], xmm13
              vmovss  xmm2, dword ptr [r13+0]; y
              vmovss  xmm1, dword ptr [r12]; x
            }
            Physics_DrawDebugString(scrPlacea, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighte, 0);
            __asm
            {
              vaddss  xmm0, xmm13, dword ptr [r13+0]
              vmovss  dword ptr [r13+0], xmm0
              vmaxps  xmm1, xmm6, xmmword ptr [r14]
              vminps  xmm2, xmm1, xmmword ptr [r14+10h]
              vmulss  xmm0, xmm6, xmm12
              vmovss  dword ptr [rsp+2A0h+var_230+8], xmm0
              vshufps xmm1, xmm6, xmm6, 55h ; 'U'
              vmulss  xmm0, xmm1, xmm12
              vmovss  dword ptr [rsp+2A0h+var_230+0Ch], xmm0
              vshufps xmm6, xmm6, xmm6, 0AAh ; ''
              vmulss  xmm0, xmm6, xmm12
              vmovss  dword ptr [rbp+1A0h+var_220], xmm0
              vmulss  xmm0, xmm2, xmm12
              vmovss  dword ptr [rbp+1A0h+center], xmm0
              vshufps xmm1, xmm2, xmm2, 55h ; 'U'
              vmulss  xmm0, xmm1, xmm12
              vmovss  dword ptr [rbp+1A0h+center+4], xmm0
              vshufps xmm2, xmm2, xmm2, 0AAh ; ''
              vmulss  xmm0, xmm2, xmm12
              vmovss  dword ptr [rbp+1A0h+center+8], xmm0
              vmovaps xmm1, xmm7; radius
            }
            CG_DebugSphere(&center, *(float *)&_XMM1, &colorYellow, 0, 0);
            CG_DebugLine((const vec3_t *)&v139, &center, &colorYellow, 0, 0);
            __asm { vmovaps xmm2, xmm8; scale }
            CL_AddDebugString((const vec3_t *)&v139, &colorYellow, *(float *)&_XMM2, v88, 0, 0);
            ++contentsa;
            ++v83;
            result = *(HavokPhysics_BroadphaseCollisionQueryResult **)numInOut;
          }
          while ( v83 < *(__int64 *)v136 );
          __asm { vmovss  xmm1, dword ptr [r12] }
        }
        __asm
        {
          vsubss  xmm0, xmm1, xmm14
          vmovss  dword ptr [r12], xmm0
        }
      }
    }
  }
  _R11 = &v145;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
HavokPhysics_DrawDebugAABBWorldQuery
==============
*/
void HavokPhysics_DrawDebugAABBWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v21; 
  __int64 v22; 
  bool v26; 
  int v27; 
  int v32; 
  __int64 v37; 
  int integer; 
  unsigned int v61; 
  HavokPhysics_CollisionQueryResult *v79; 
  unsigned int AABBQueryHitBodyId; 
  unsigned int m_collisionFilterInfo; 
  unsigned int AABBQueryHitSurfFlags; 
  hknpBodyId v94; 
  char *v95; 
  float fmt; 
  char *fmta; 
  int forceColora; 
  __int64 forceColorb; 
  __int64 forceColor; 
  __int64 shadowa; 
  __int64 shadow; 
  float charHeightb; 
  __int64 charHeightc; 
  float charHeightd; 
  float charHeighte; 
  __int64 charHeighta; 
  float charHeightf; 
  float charHeightg; 
  __int64 adjust; 
  __int64 v141; 
  int m_value; 
  int numInOut; 
  unsigned int contents[2]; 
  float *xa; 
  ScreenPlacement *scrPlacea; 
  char *text; 
  const hkAabb *v148; 
  __int64 v149; 
  __int128 v150; 
  __int64 v151; 
  vec3_t center; 
  vec3_t origin; 
  Bounds bounds; 
  char dest[256]; 
  char v156; 
  void *retaddr; 

  _RAX = &retaddr;
  v149 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  scrPlacea = (ScreenPlacement *)scrPlace;
  _RSI = aabb;
  v148 = aabb;
  v21 = collisionFilterInfo;
  contents[0] = collisionFilterInfo;
  v22 = worldId;
  contents[1] = worldId;
  xa = x;
  _R13 = y;
  __asm
  {
    vxorps  xmm14, xmm14, xmm14
    vmovss  dword ptr [rbp+1C0h+var_220], xmm14
  }
  HIDWORD(v151) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22477, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugAABBWorldQuery with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _R15 = HavokPhysics_GetMutableWorld((Physics_WorldId)v22);
  if ( dword_150D5FA50 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA50);
    if ( dword_150D5FA50 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_0.m_ignoreEntities.m_data = NULL;
      ignoreBodies_0.m_ignoreEntities.m_size = 0;
      ignoreBodies_0.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_0.m_ignoreBodies.m_data = NULL;
      ignoreBodies_0.m_ignoreBodies.m_size = 0;
      ignoreBodies_0.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      m_value = 0;
      hkMemHeapAllocator();
      ignoreBodies_0.m_ignoreBodies.m_data = NULL;
      ignoreBodies_0.m_ignoreBodies.m_size = 0;
      ignoreBodies_0.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_0.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_0.m_isClutter = 0;
      ignoreBodies_0.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugAABBWorldQuery_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA50);
      v21 = contents[0];
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v26 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_0.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v26) )
    ignoreBodies_0.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  LODWORD(v150) = v21;
  BYTE4(v150) = 1;
  *((_QWORD *)&v150 + 1) = &ignoreBodies_0;
  v27 = s_havokPhysicsWorldAABBQueryActiveIndices[v22];
  if ( v27 == -1 )
  {
    if ( _R15->requestDebugAABBQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22494, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugAABBQuery)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugAABBQuery") )
      __debugbreak();
    s_havokPhysicsWorldAABBQueryActiveIndices[v22] = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups xmmword ptr [r15+0CD0h], xmm0
      vmovups xmm1, xmmword ptr [rsi+10h]
      vmovups xmmword ptr [r15+0CE0h], xmm1
      vmovups xmm0, [rbp+1C0h+var_230]
      vmovups xmmword ptr [r15+0CF0h], xmm0
      vmovsd  xmm1, [rbp+1C0h+var_220]
      vmovsd  qword ptr [r15+0D00h], xmm1
    }
    _R15->requestDebugAABBQuery = 1;
  }
  else
  {
    v32 = s_havokPhysicsWorldAABBQueryActiveIndices[v22];
    if ( !_R15->requestDebugAABBQuery && s_havokPhysicsWorldAABBQueryData[2 * (int)v22 + v27].isComplete )
    {
      s_havokPhysicsWorldAABBQueryActiveIndices[v22] = 1 - v27;
      HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldAABBQueryData[2 * (int)v22 + 1 - v27].result, 1);
      __asm
      {
        vmovups xmm0, xmmword ptr [rsi]
        vmovups xmmword ptr [r15+0CD0h], xmm0
        vmovups xmm1, xmmword ptr [rsi+10h]
        vmovups xmmword ptr [r15+0CE0h], xmm1
        vmovups xmm0, [rbp+1C0h+var_230]
        vmovups xmmword ptr [r15+0CF0h], xmm0
        vmovsd  xmm1, [rbp+1C0h+var_220]
        vmovsd  qword ptr [r15+0D00h], xmm1
      }
      _R15->requestDebugAABBQuery = 1;
      v32 = s_havokPhysicsWorldAABBQueryActiveIndices[v22];
    }
    if ( v32 != -1 )
    {
      v37 = 3i64 * (2 * (int)v22 - v32) + 3;
      if ( *(&s_havokPhysicsWorldAABBQueryData[0].isComplete + 8 * v37) )
      {
        integer = physics_debugQueryBody->current.integer;
        if ( integer < 0 )
        {
          m_value = 0xFFFFFF;
          integer = 0xFFFFFF;
        }
        else
        {
          m_value = physics_debugQueryBody->current.integer;
        }
        if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_R15->world->isBodyValid)(&_R15->world->hknpWorldReader, (unsigned int)integer) )
          Com_sprintf<256>((char (*)[256])dest, "AABB  Query");
        else
          Com_sprintf<256>((char (*)[256])dest, "AABB  Query for Body Id %i %s", (unsigned int)integer, (const char *)((unsigned __int64)_R15->world->m_bodyManager.m_bodyNames.m_data[integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        __asm
        {
          vmovss  xmm12, [rbp+1C0h+arg_38]
          vmovss  [rsp+2C0h+charHeight], xmm12
          vmovss  xmm2, dword ptr [r13+0]; y
        }
        _RBX = xa;
        __asm { vmovss  xmm1, dword ptr [rbx]; x }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightb, 0);
        __asm
        {
          vaddss  xmm0, xmm12, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vmovss  xmm15, [rbp+1C0h+arg_30]
          vaddss  xmm0, xmm15, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm0
          vmovss  dword ptr [rsp+2C0h+forceColor], xmm12
          vmovss  dword ptr [rsp+2C0h+fmt], xmm15
        }
        HavokPhysics_DrawPhysicsContents(contents[0], scrPlace, _RBX, y, fmt, *(float *)&forceColora);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx]
          vsubss  xmm1, xmm0, xmm15
          vmovss  dword ptr [rbx], xmm1
          vmovss  xmm13, cs:__real@42000000
          vmulss  xmm9, xmm13, dword ptr [rsi]
          vmulss  xmm10, xmm13, dword ptr [rsi+4]
          vmulss  xmm11, xmm13, dword ptr [rsi+8]
          vmulss  xmm6, xmm13, dword ptr [rsi+10h]
          vmulss  xmm7, xmm13, dword ptr [rsi+14h]
          vmulss  xmm8, xmm13, dword ptr [rsi+18h]
          vcvttss2si eax, xmm8
          vcvttss2si ecx, xmm7
          vcvttss2si edx, xmm6
          vcvttss2si r10d, xmm11
          vcvttss2si r9d, xmm10
          vcvttss2si r8d, xmm9
        }
        LODWORD(charHeightc) = _EAX;
        LODWORD(shadowa) = _ECX;
        LODWORD(forceColorb) = _EDX;
        LODWORD(fmta) = _ER10;
        Com_sprintf<256>((char (*)[256])dest, "AABB min(%i %i %i) max(%i %i %i)", _R8, _R9, fmta, forceColorb, shadowa, charHeightc);
        v61 = 0;
        __asm
        {
          vmovss  [rsp+2C0h+charHeight], xmm12
          vmovss  xmm2, dword ptr [r13+0]; y
          vmovss  xmm1, dword ptr [rbx]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightd, 0);
        __asm
        {
          vaddss  xmm0, xmm12, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vmovss  dword ptr [rbp+1C0h+origin], xmm14
          vmovss  dword ptr [rbp+1C0h+origin+4], xmm14
          vmovss  dword ptr [rbp+1C0h+origin+8], xmm14
          vaddss  xmm0, xmm6, xmm9
          vmovss  xmm4, cs:__real@3f000000
          vmulss  xmm0, xmm0, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.midPoint], xmm0
          vsubss  xmm1, xmm6, xmm9
          vmulss  xmm2, xmm1, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.halfSize], xmm2
          vaddss  xmm0, xmm7, xmm10
          vmulss  xmm1, xmm0, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.midPoint+4], xmm1
          vsubss  xmm3, xmm7, xmm10
          vmulss  xmm0, xmm3, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.halfSize+4], xmm0
          vaddss  xmm1, xmm8, xmm11
          vmulss  xmm3, xmm1, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.midPoint+8], xmm3
          vsubss  xmm0, xmm8, xmm11
          vmulss  xmm1, xmm0, xmm4
          vmovss  dword ptr [rbp+1C0h+bounds.halfSize+8], xmm1
          vxorps  xmm2, xmm2, xmm2; yaw
        }
        CG_DebugBox(&origin, &bounds, *(float *)&_XMM2, &colorGreen, 0, 0);
        v79 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldAABBQueryData[0].result + v37);
        contents[0] = HavokPhysics_CollisionQueryResult::GetNumHits(v79);
        Com_sprintf<256>((char (*)[256])dest, "Result %i Hits", contents[0]);
        __asm
        {
          vmovss  [rsp+2C0h+charHeight], xmm12
          vmovss  xmm2, dword ptr [r13+0]; y
          vmovss  xmm1, dword ptr [rbx]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighte, 0);
        __asm
        {
          vaddss  xmm0, xmm12, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm0
          vaddss  xmm1, xmm15, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm1
        }
        if ( (int)contents[0] > 0 )
        {
          __asm
          {
            vmovss  xmm7, cs:__real@40a00000
            vmovss  xmm8, cs:__real@3f800000
          }
          do
          {
            AABBQueryHitBodyId = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(v79, v61);
            if ( Physics_IsRigidBodyValid((Physics_WorldId)v22, AABBQueryHitBodyId) )
            {
              _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))_R15->world->getBody)(&_R15->world->hknpWorldReader, AABBQueryHitBodyId);
              text = (char *)((unsigned __int64)_R15->world->m_bodyManager.m_bodyNames.m_data[AABBQueryHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
              __asm { vmovups xmm6, xmmword ptr [rax+30h] }
              if ( v61 >= HavokPhysics_CollisionQueryResult::GetNumHits(v79) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v79);
                LODWORD(forceColor) = v61;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 918, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              m_value = HavokPhysics_CollisionQueryResult::GetHit(v79, v61)->m_hitBodyInfo.m_shapeKey.m_value;
              if ( v61 >= HavokPhysics_CollisionQueryResult::GetNumHits(v79) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v79);
                LODWORD(forceColor) = v61;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 925, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              LOWORD(numInOut) = HavokPhysics_CollisionQueryResult::GetHit(v79, v61)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
              if ( v61 >= HavokPhysics_CollisionQueryResult::GetNumHits(v79) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v79);
                LODWORD(forceColor) = v61;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 932, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v79, v61)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
              AABBQueryHitSurfFlags = HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(v79, v61);
              v94.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(v79, v61);
              LODWORD(v141) = HavokPhysics_GetRef(v79->m_worldId, v94);
              LODWORD(adjust) = AABBQueryHitSurfFlags;
              LODWORD(charHeighta) = m_collisionFilterInfo;
              LODWORD(shadow) = (unsigned __int16)numInOut;
              LODWORD(forceColor) = m_value;
              v95 = text;
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v61, AABBQueryHitBodyId, text, forceColor, shadow, charHeighta, adjust, v141);
              __asm
              {
                vmovss  [rsp+2C0h+charHeight], xmm12
                vmovss  xmm2, dword ptr [r13+0]; y
              }
              _RAX = xa;
              __asm { vmovss  xmm1, dword ptr [rax]; x }
              Physics_DrawDebugString(scrPlacea, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightg, 0);
              __asm
              {
                vaddss  xmm0, xmm12, dword ptr [r13+0]
                vmovss  dword ptr [r13+0], xmm0
                vmaxps  xmm1, xmm6, xmmword ptr [rax]
                vminps  xmm2, xmm1, xmmword ptr [rax+10h]
                vmulss  xmm0, xmm6, xmm13
                vmovss  dword ptr [rbp+1C0h+var_230], xmm0
                vshufps xmm1, xmm6, xmm6, 55h ; 'U'
                vmulss  xmm0, xmm1, xmm13
                vmovss  dword ptr [rbp+1C0h+var_230+4], xmm0
                vshufps xmm6, xmm6, xmm6, 0AAh ; ''
                vmulss  xmm0, xmm6, xmm13
                vmovss  dword ptr [rbp+1C0h+var_230+8], xmm0
                vmulss  xmm0, xmm2, xmm13
                vmovss  dword ptr [rbp+1C0h+center], xmm0
                vshufps xmm1, xmm2, xmm2, 55h ; 'U'
                vmulss  xmm0, xmm1, xmm13
                vmovss  dword ptr [rbp+1C0h+center+4], xmm0
                vshufps xmm2, xmm2, xmm2, 0AAh ; ''
                vmulss  xmm0, xmm2, xmm13
                vmovss  dword ptr [rbp+1C0h+center+8], xmm0
                vmovaps xmm1, xmm7; radius
              }
              CG_DebugSphere(&center, *(float *)&_XMM1, &colorGreen, 0, 0);
              CG_DebugLine((const vec3_t *)&v150, &center, &colorGreen, 0, 0);
              __asm { vmovaps xmm2, xmm8; scale }
              CL_AddDebugString((const vec3_t *)&v150, &colorGreen, *(float *)&_XMM2, v95, 0, 0);
              LODWORD(v22) = contents[1];
              _RBX = xa;
            }
            else
            {
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v61, AABBQueryHitBodyId);
              __asm
              {
                vmovss  [rsp+2C0h+charHeight], xmm12
                vmovss  xmm2, dword ptr [r13+0]; y
                vmovss  xmm1, dword ptr [rbx]; x
              }
              Physics_DrawDebugString(scrPlacea, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightf, 0);
              __asm
              {
                vaddss  xmm0, xmm12, dword ptr [r13+0]
                vmovss  dword ptr [r13+0], xmm0
              }
            }
            ++v61;
          }
          while ( (int)v61 < (int)contents[0] );
          __asm { vmovss  xmm1, dword ptr [rbx] }
        }
        __asm
        {
          vsubss  xmm0, xmm1, xmm15
          vmovss  dword ptr [rbx], xmm0
        }
      }
    }
  }
  _R11 = &v156;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
HavokPhysics_DrawDebugBadColLods
==============
*/

void __fastcall HavokPhysics_DrawDebugBadColLods(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight)
{
  const ScreenPlacement *v11; 
  int v12; 
  __int64 v13; 
  const XModel *v14; 
  hkMemoryAllocator *v15; 
  int v16; 
  unsigned int v22; 
  int v23; 
  char *v24; 
  char *v25; 
  __int64 v26; 
  unsigned int v35; 
  char *v36; 
  char *v37; 
  int v38; 
  __int64 v39; 
  __int64 v40; 
  int v41; 
  unsigned int v42; 
  unsigned int v51; 
  int v52; 
  char *v53; 
  char *v54; 
  __int64 v55; 
  __int64 v56; 
  int v57; 
  unsigned int v58; 
  hkMemoryAllocator *v63; 
  char *fmt; 
  char *fmta; 
  __int64 forceColor; 
  float v70; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  char *array; 
  __int64 v77; 
  const ScreenPlacement *v78; 
  __int64 v79; 
  char dest[256]; 
  char v81; 
  void *retaddr; 

  _RAX = &retaddr;
  v79 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmm7, xmm3
  }
  _R15 = y;
  _R14 = x;
  v11 = scrPlace;
  v78 = scrPlace;
  array = NULL;
  v77 = 0x8000000000000000ui64;
  v12 = 0;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v13 = 0i64;
    do
    {
      v14 = s_havokPhysicsXModels->m_data[v13];
      if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23720, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( v14->physicsAsset && strncmp(v14->name, "vfx", 3ui64) && strncmp(v14->name, "fx", 2ui64) && strncmp(v14->name, "weapon", 6ui64) )
      {
        v15 = hkMemHeapAllocator();
        v16 = v77;
        if ( (_DWORD)v77 == (HIDWORD(v77) & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v15, &array, 8);
          v16 = v77;
        }
        *(_QWORD *)&array[8 * v16] = v14;
        LODWORD(v77) = v77 + 1;
      }
      ++v12;
      ++v13;
    }
    while ( v12 < s_havokPhysicsXModels->m_size );
    v11 = v78;
  }
  Com_sprintf<256>((char (*)[256])dest, "XModels with ColLod not set");
  __asm
  {
    vmovss  xmm6, [rbp+0D0h+charHeight]
    vmovss  [rsp+1D0h+var_198], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v70, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vaddss  xmm1, xmm7, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  v22 = 0;
  v23 = v77;
  if ( (int)v77 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)array, 0, v77 - 1, HavokPhysics_XModelsSortByName);
    __asm { vmovss  xmm1, dword ptr [r14] }
    v23 = v77;
  }
  v24 = array;
  v25 = array;
  if ( array != &array[8 * v23] )
  {
    do
    {
      v26 = *(_QWORD *)v25;
      if ( (*(_BYTE *)(*(_QWORD *)v25 + 15i64) & 0xFD) != 0 && *(_BYTE *)(v26 + 11) != 8 )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s unexpectedly has no collLod", v22, *(const char **)v26);
        __asm
        {
          vmovss  [rsp+1D0h+var_198], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v71, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        ++v22;
        v23 = v77;
        v24 = array;
      }
      v25 += 8;
    }
    while ( v25 != &v24[8 * v23] );
    __asm { vmovss  xmm1, dword ptr [r14] }
  }
  __asm
  {
    vsubss  xmm0, xmm1, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "XModels with collLod set to 0 - could be okay for very simple models, but usually should be a higher LOD");
  __asm
  {
    vmovss  [rsp+1D0h+var_198], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v72, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vaddss  xmm1, xmm7, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  v35 = 0;
  v36 = array;
  v37 = array;
  v38 = v77;
  if ( array != &array[8 * (int)v77] )
  {
    do
    {
      v39 = *(_QWORD *)v37;
      v40 = *(_QWORD *)(*(_QWORD *)v37 + 640i64);
      if ( v40 )
        v41 = *(_DWORD *)(v40 + 8);
      else
        v41 = 0;
      v42 = v41 + 12;
      if ( !*(_BYTE *)(v39 + 11) && v42 > 0x400 )
      {
        LODWORD(fmt) = v42;
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s has collLod set to 0 using %i bytes", v35, *(const char **)v39, fmt);
        __asm
        {
          vmovss  [rsp+1D0h+var_198], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v73, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        ++v35;
        v38 = v77;
        v36 = array;
      }
      v37 += 8;
    }
    while ( v37 != &v36[8 * v38] );
    __asm { vmovss  xmm1, dword ptr [r14] }
  }
  __asm
  {
    vsubss  xmm0, xmm1, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "XModels with expensive collLods - could be okay for vehicles or complex objects, but usually should be lower memory/triangle usage");
  __asm
  {
    vmovss  [rsp+1D0h+var_198], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v74, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vaddss  xmm1, xmm7, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  v51 = 0;
  v52 = v77;
  if ( (int)v77 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)array, 0, v77 - 1, HavokPhysics_XModelsSortByMemory);
    __asm { vmovss  xmm1, dword ptr [r14] }
    v52 = v77;
  }
  v53 = array;
  v54 = array;
  if ( array != &array[8 * v52] )
  {
    do
    {
      v55 = *(_QWORD *)v54;
      v56 = *(_QWORD *)(*(_QWORD *)v54 + 640i64);
      if ( v56 )
        v57 = *(_DWORD *)(v56 + 8);
      else
        v57 = 0;
      v58 = v57 + 12;
      if ( v58 >= 0x19000 )
      {
        LODWORD(forceColor) = v58;
        LODWORD(fmta) = *(unsigned __int8 *)(v55 + 11);
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s has collLod %u with very large memory usage %i", v51, *(const char **)v55, fmta, forceColor);
        __asm
        {
          vmovss  [rsp+1D0h+var_198], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v75, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        ++v51;
        v52 = v77;
        v53 = array;
      }
      v54 += 8;
    }
    while ( v54 != &v53[8 * v52] );
    __asm { vmovss  xmm1, dword ptr [r14] }
  }
  __asm
  {
    vsubss  xmm0, xmm1, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  v63 = hkMemHeapAllocator();
  LODWORD(v77) = 0;
  if ( v77 >= 0 )
    hkMemoryAllocator::bufFree2(v63, array, 8, HIDWORD(v77) & 0x3FFFFFFF);
  _R11 = &v81;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawDebugDetailModel
==============
*/
void HavokPhysics_DrawDebugDetailModel(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  XModel *adjust; 
  hkMemoryAllocator *v33; 
  void *v34; 
  int v35; 
  hkMemoryAllocator *v36; 
  int v37; 
  int v38; 
  void *v39; 
  unsigned int v40; 
  _BYTE *v41; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned __int8 *WeaponPriorityMap; 
  unsigned int RaycastHitBodyId; 
  const hknpCollisionResult *Hit; 
  Physics_RefSystem RefSystem; 
  const Physics_DetailHitData *DetailHitData; 
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 
  __int32 v68; 
  __int32 v69; 
  LocalClientNum_t LocalClientForWorld; 
  unsigned int RefId; 
  unsigned __int16 v72; 
  __int64 v73; 
  unsigned int v74; 
  char *v75; 
  DynEntityBasis v76; 
  __int64 v77; 
  unsigned __int16 v78; 
  unsigned __int16 v79; 
  DynEntityClient *v80; 
  const char *name; 
  const char **p_name; 
  int partGroup; 
  const char *v91; 
  hkMemoryAllocator *v98; 
  hkMemoryAllocator *v99; 
  __int64 forceColor; 
  __int64 forceColora; 
  __int64 shadow; 
  float v108; 
  float v109; 
  float v110; 
  float v111; 
  DynEntityBasis basisOut[2]; 
  int ref; 
  unsigned __int16 clientIdOut[2]; 
  int numInOut; 
  int v116; 
  __int64 v117; 
  void *v118; 
  int v119; 
  int v120; 
  void *p; 
  int v122; 
  int v123; 
  __int64 v124; 
  __int16 v125; 
  int v126; 
  Physics_RaycastExtendedData extendedData; 
  __int64 v128; 
  vec3_t center; 
  vec3_t outPos; 
  vec3_t v131; 
  hkVector4f end; 
  hkVector4f start; 
  Weapon weapon; 
  char dest[256]; 
  char v136; 
  void *retaddr; 

  _RAX = &retaddr;
  v128 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _RDI = y;
  _R12 = x;
  _RAX = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  __asm
  {
    vmovss  xmm6, dword ptr [rax+6944h]
    vmovss  xmm7, dword ptr [rax+6948h]
    vmovss  xmm8, dword ptr [rax+694Ch]
  }
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  __asm
  {
    vmovss  xmm2, cs:__real@453b8000
    vmulss  xmm0, xmm2, xmm6
    vaddss  xmm9, xmm0, dword ptr [rbp+1F0h+outPos]
    vmulss  xmm1, xmm2, xmm7
    vaddss  xmm7, xmm1, dword ptr [rbp+1F0h+outPos+4]
    vmulss  xmm0, xmm2, xmm8
    vaddss  xmm6, xmm0, dword ptr [rbp+1F0h+outPos+8]
    vmovss  xmm2, cs:__real@3d000000
    vmulss  xmm0, xmm2, dword ptr [rbp+1F0h+outPos]
    vmovss  dword ptr [rbp+1F0h+start.m_quad], xmm0
    vmulss  xmm1, xmm2, dword ptr [rbp+1F0h+outPos+4]
    vmovss  dword ptr [rbp+1F0h+start.m_quad+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rbp+1F0h+outPos+8]
    vmovss  dword ptr [rbp+1F0h+start.m_quad+8], xmm0
    vxorps  xmm8, xmm8, xmm8
    vmovss  dword ptr [rbp+1F0h+start.m_quad+0Ch], xmm8
    vmulss  xmm0, xmm9, xmm2
    vmovss  dword ptr [rbp+1F0h+end.m_quad], xmm0
    vmulss  xmm1, xmm7, xmm2
    vmovss  dword ptr [rbp+1F0h+end.m_quad+4], xmm1
    vmulss  xmm0, xmm6, xmm2
    vmovss  dword ptr [rbp+1F0h+end.m_quad+8], xmm0
    vmovss  dword ptr [rbp+1F0h+end.m_quad+0Ch], xmm8
  }
  adjust = NULL;
  LODWORD(v117) = 0;
  v118 = NULL;
  v119 = 0;
  v120 = 0x80000000;
  numInOut = 1;
  v33 = hkMemHeapAllocator();
  v34 = hkMemoryAllocator::bufAlloc2(v33, 8, &numInOut);
  v35 = 0x80000000;
  if ( numInOut )
    v35 = numInOut;
  v118 = v34;
  v119 = 1;
  v120 = v35;
  p = NULL;
  v122 = 0;
  v123 = 0x80000000;
  v116 = 0;
  v36 = hkMemHeapAllocator();
  v37 = v116;
  v38 = v116;
  if ( v116 )
  {
    v39 = hkMemoryAllocator::bufAlloc2(v36, 4, &v116);
    v37 = v116;
  }
  else
  {
    v39 = NULL;
  }
  v40 = 0x80000000;
  if ( v37 )
    v40 = v37;
  p = v39;
  v122 = v38;
  v123 = v40;
  v124 = 0i64;
  v125 = 0;
  v126 = 32;
  if ( !v119 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 801, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreEntities.getSize() )", "index doesn't index m_ignoreEntities.getSize()\n\t%i not in [0, %i)", 0, 0) )
    __debugbreak();
  v41 = v118;
  *(_DWORD *)v118 = 0;
  v41[4] |= 0x1Fu;
  __asm { vmovss  [rbp+1F0h+extendedData.collisionBuffer], xmm8 }
  extendedData.phaseSelection = All;
  extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  *(_WORD *)&extendedData.collectInsideHits = 256;
  extendedData.contents = -1;
  extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
  extendedData.ignoreBodies = (HavokPhysics_IgnoreBodies *)&v117;
  ClosestResult = PhysicsQuery_GetClosestResult(PHYSICS_WORLD_ID_CLIENT0_DETAIL);
  if ( !ClosestResult->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::Reset(ClosestResult->m_collector, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups ymmword ptr [rbp+1F0h+weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    vmovups xmmword ptr [rbp+1F0h+weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovsd  qword ptr [rbp+1F0h+weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  weapon.weaponIdx = 0;
  WeaponPriorityMap = BG_GetWeaponPriorityMap(&weapon, 0);
  HavokPhysics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
  HavokPhysics_Raycast(PHYSICS_WORLD_ID_CLIENT0_DETAIL, &start, &end, &extendedData, ClosestResult);
  if ( !HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) || (RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(ClosestResult, 0), !Physics_IsRigidBodyValid(PHYSICS_WORLD_ID_CLIENT0_DETAIL, RaycastHitBodyId)) )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Hits");
    goto LABEL_78;
  }
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1051, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rax]
    vmovss  dword ptr [rbp+1F0h+center], xmm0
    vmulss  xmm2, xmm3, dword ptr [rax+4]
    vmovss  dword ptr [rbp+1F0h+center+4], xmm2
    vmulss  xmm1, xmm3, dword ptr [rax+8]
    vmovss  dword ptr [rbp+1F0h+center+8], xmm1
  }
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1058, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  __asm
  {
    vmovss  xmm6, dword ptr [rax+10h]
    vmovss  xmm7, dword ptr [rax+14h]
    vmovss  xmm8, dword ptr [rax+18h]
  }
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  ref = HavokPhysics_GetRef(ClosestResult->m_worldId, Hit->m_hitBodyInfo.m_bodyId);
  RefSystem = Physics_GetRefSystem(ref);
  DetailHitData = NULL;
  if ( HavokPhysicsHitCollector::HasModifiers(ClosestResult->m_collector) )
  {
    Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(ClosestResult->m_collector, 0);
    if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23557, ASSERT_TYPE_ASSERT, "(dtModifier)", (const char *)&queryFormat, "dtModifier") )
      __debugbreak();
    DetailHitData = HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, 0);
  }
  __asm { vmovss  xmm1, cs:__real@40a00000; radius }
  CG_DebugSphere(&center, *(float *)&_XMM1, &colorGreen, 0, 0);
  __asm
  {
    vmovss  xmm3, cs:__real@41400000
    vmulss  xmm0, xmm6, xmm3
    vaddss  xmm1, xmm0, dword ptr [rbp+1F0h+center]
    vmovss  dword ptr [rbp+1F0h+var_1F8], xmm1
    vmulss  xmm2, xmm7, xmm3
    vaddss  xmm0, xmm2, dword ptr [rbp+1F0h+center+4]
    vmovss  dword ptr [rbp+1F0h+var_1F8+4], xmm0
    vmulss  xmm1, xmm8, xmm3
    vaddss  xmm2, xmm1, dword ptr [rbp+1F0h+center+8]
    vmovss  dword ptr [rbp+1F0h+var_1F8+8], xmm2
  }
  CG_DebugLine(&center, &v131, &colorGreen, 0, 0);
  if ( RefSystem == Physics_RefSystem_WorldGeo )
  {
    Com_sprintf<256>((char (*)[256])dest, "World Geo or Misc Model");
    adjust = NULL;
    __asm
    {
      vmovss  xmm6, [rbp+1F0h+charHeight]
      vmovss  [rsp+2F0h+var_2B8], xmm6
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r12]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v110, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
LABEL_76:
    Com_sprintf<256>((char (*)[256])dest, "No Model found");
    goto LABEL_79;
  }
  v68 = RefSystem - 1;
  if ( v68 )
  {
    v69 = v68 - 3;
    if ( v69 )
    {
      if ( v69 != 6 )
      {
        Com_sprintf<256>((char (*)[256])dest, "Model extraction failed");
        adjust = NULL;
LABEL_78:
        __asm { vmovss  xmm6, [rbp+1F0h+charHeight] }
        goto LABEL_79;
      }
      LocalClientForWorld = Physics_GetLocalClientForWorld(PHYSICS_WORLD_ID_CLIENT0_DETAIL);
      if ( LocalClientForWorld == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23644, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      RefId = Physics_GetRefId(ref);
      adjust = (XModel *)CG_ClientModel_GetModel(LocalClientForWorld, RefId, 0);
      Com_sprintf<256>((char (*)[256])dest, "Client Model %u", RefId);
    }
    else
    {
      v72 = Physics_GetRefId(ref);
      v73 = v72;
      if ( v72 >= 0x9E5u )
      {
        LODWORD(shadow) = v72;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", shadow) )
          __debugbreak();
      }
      if ( (unsigned int)v73 >= 0x13CA )
      {
        LODWORD(shadow) = v73;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", shadow) )
          __debugbreak();
      }
      v74 = clientObjMap[v73];
      if ( clientObjMap[v73] )
      {
        if ( v74 >= (unsigned int)s_objCount )
        {
          LODWORD(shadow) = clientObjMap[v73];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", shadow) )
            __debugbreak();
        }
        v75 = s_objBuf[v74];
        if ( v75 && v75[15] )
          adjust = (XModel *)**((_QWORD **)v75 + 30);
      }
      Com_sprintf<256>((char (*)[256])dest, "CEntity %u", (unsigned int)v73);
    }
  }
  else
  {
    DynEnt_GetBasisAndDynEntClientId(ref, basisOut, clientIdOut);
    v76 = basisOut[0];
    LOWORD(ref) = clientIdOut[0];
    if ( basisOut[0] >= DYNENT_BASIS_COUNT )
    {
      LODWORD(shadow) = 2;
      LODWORD(forceColor) = (unsigned __int8)basisOut[0];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 323, ASSERT_TYPE_ASSERT, "(unsigned)( basis ) < (unsigned)( DYNENT_BASIS_COUNT )", "basis doesn't index DYNENT_BASIS_COUNT\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    v77 = (unsigned __int8)v76;
    v78 = g_dynEntClientEntsAllocCount[0][(unsigned __int8)v76];
    v79 = ref;
    if ( (unsigned __int16)ref >= v78 )
    {
      LODWORD(shadow) = v78;
      LODWORD(forceColor) = (unsigned __int16)ref;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 324, ASSERT_TYPE_ASSERT, "(unsigned)( clientId ) < (unsigned)( g_dynEntClientEntsAllocCount[localClientNum][basis] )", "clientId doesn't index g_dynEntClientEntsAllocCount[localClientNum][basis]\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( !g_dynEntClientLists[0][v77] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 325, ASSERT_TYPE_ASSERT, "(g_dynEntClientLists[localClientNum][basis])", (const char *)&queryFormat, "g_dynEntClientLists[localClientNum][basis]") )
      __debugbreak();
    v80 = &g_dynEntClientLists[0][v77][v79];
    if ( !v80 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23613, ASSERT_TYPE_ASSERT, "(dynEntClient)", (const char *)&queryFormat, "dynEntClient") )
      __debugbreak();
    adjust = (XModel *)v80->activeModel;
    Com_sprintf<256>((char (*)[256])dest, "Dynent %i %u", (unsigned __int8)basisOut[0], v80->dynEntDefId);
  }
  __asm
  {
    vmovss  xmm6, [rbp+1F0h+charHeight]
    vmovss  [rsp+2F0h+var_2B8], xmm6
    vmovss  xmm2, dword ptr [rdi]; y
    vmovss  xmm1, dword ptr [r12]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v108, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  if ( !adjust )
    goto LABEL_76;
  name = adjust->name;
  if ( adjust->detailCollision )
  {
    Com_sprintf<256>((char (*)[256])dest, "XModel %s with colLod %i", name, adjust->collLod);
  }
  else
  {
    p_name = &adjust->physicsAsset->name;
    if ( p_name )
      Com_sprintf<256>((char (*)[256])dest, "XModel %s with physasset %s", name, *p_name);
    else
      Com_sprintf<256>((char (*)[256])dest, "XModel %s from unknown source", name);
  }
  adjust = NULL;
  __asm
  {
    vmovss  [rsp+2F0h+var_2B8], xmm6
    vmovss  xmm2, dword ptr [rdi]; y
    vmovss  xmm1, dword ptr [r12]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v109, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  if ( DetailHitData && DetailHitData->isValid )
  {
    partGroup = DetailHitData->partGroup;
    v91 = SL_ConvertToString(DetailHitData->partName);
    LODWORD(forceColora) = partGroup;
    Com_sprintf<256>((char (*)[256])dest, "ModelIndex %i, PartName %i %s, PartGroup %i", DetailHitData->modelIndex, (unsigned int)DetailHitData->partName, v91, forceColora);
LABEL_79:
    __asm
    {
      vmovss  [rsp+2F0h+var_2B8], xmm6
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r12]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, (int)adjust, 1, v111, (int)adjust);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  v98 = hkMemHeapAllocator();
  v122 = (int)adjust;
  if ( v123 >= 0 )
    hkMemoryAllocator::bufFree2(v98, p, 4, v123 & 0x3FFFFFFF);
  p = adjust;
  v123 = 0x80000000;
  v99 = hkMemHeapAllocator();
  v119 = (int)adjust;
  if ( v120 >= 0 )
    hkMemoryAllocator::bufFree2(v99, v118, 8, v120 & 0x3FFFFFFF);
  _R11 = &v136;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
HavokPhysics_DrawDebugGeneralCPU
==============
*/
void HavokPhysics_DrawDebugGeneralCPU(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float v14; 
  char dest[256]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RDI = x;
  _RSI = y;
  Com_sprintf<256>((char (*)[256])dest, "General:    No current data");
  __asm
  {
    vmovss  xmm6, [rsp+188h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rdi]; x
    vmovss  [rsp+188h+var_150], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v14, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vmovaps xmm6, [rsp+188h+var_28]
  }
}

/*
==============
HavokPhysics_DrawDebugGeneralMemory
==============
*/
void HavokPhysics_DrawDebugGeneralMemory(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v9; 
  unsigned int v10; 
  HavokPhysicsLargeBlockAllocator *v17; 
  unsigned int v18; 
  float v24; 
  float v25; 
  float v26; 
  char v27[32]; 
  char v28[32]; 
  char buffer[32]; 
  char dest[256]; 

  __asm { vmovaps [rsp+200h+var_40], xmm6 }
  _RSI = y;
  _R15 = x;
  if ( !s_havokPhysicsGeneralLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17002, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics DrawDebugGeneralMemory: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator") )
    __debugbreak();
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17003, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalLargeBlockAllocator)", "%s\n\tHavokPhysics DrawDebugGeneralMemory: map local memory allocator is NULL", "s_havokPhysicsMapLocalLargeBlockAllocator") )
    __debugbreak();
  v9 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  v10 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Physics_DebugIntToString(buffer, 32, v9);
  Physics_DebugIntToString(v28, 32, s_generalMemoryPeakInUse);
  Physics_DebugIntToString(v27, 32, s_generalMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "General:    Current:%10s Max:%10s Capacity:%10s", buffer, v28, v27);
  __asm
  {
    vmovss  xmm6, [rbp+100h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r15]; x
    vmovss  [rsp+200h+var_1C8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v24, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  Physics_DebugIntToString(buffer, 32, v10);
  Physics_DebugIntToString(v28, 32, s_mapLocalMemoryPeakInUse);
  Physics_DebugIntToString(v27, 32, s_mapLocalMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Map Local:  Current:%10s Max:%10s Capacity:%10s", buffer, v28, v27);
  __asm
  {
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r15]; x
    vmovss  [rsp+200h+var_1C8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v25, 0);
  v17 = s_havokPhysicsDebugMemoryAllocator;
  v18 = 0;
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  if ( v17 )
    v18 = v17->getApproxTotalAllocated(&v17->hkMemoryAllocator::ExtendedInterface);
  Physics_DebugIntToString(buffer, 32, v18);
  Physics_DebugIntToString(v28, 32, s_debugMemoryPeakInUse);
  Physics_DebugIntToString(v27, 32, s_debugMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Debug:      Current:%10s Max:%10s Capacity:%10s", buffer, v28, v27);
  __asm
  {
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r15]; x
    vmovss  [rsp+200h+var_1C8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v26, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vmovaps xmm6, [rsp+200h+var_40]
  }
}

/*
==============
HavokPhysics_DrawDebugGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DrawDebugGetClosestPoints(Physics_WorldId worldId, const hkVector4f *position, double maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v16; 
  __int64 v19; 
  const ScreenPlacement *v20; 
  bool v25; 
  int v26; 
  int v31; 
  __int64 v36; 
  int integer; 
  int v46; 
  unsigned int v61; 
  HavokPhysics_CollisionQueryResult *v70; 
  unsigned int ClosestPointHitBodyId; 
  const char *v82; 
  HavokPhysics_CollisionQueryResult *v83; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  hknpBodyId v88; 
  char *fmt; 
  char *fmta; 
  float fmtb; 
  char *fmtc; 
  double forceColora; 
  double forceColorb; 
  int forceColorc; 
  __int64 forceColor; 
  double shadowa; 
  double shadowb; 
  __int64 shadow; 
  double v112; 
  float v113; 
  float v114; 
  __int64 v115; 
  float v116; 
  float v117; 
  double adjusta; 
  __int64 adjust; 
  __int64 v120; 
  signed int contentsa; 
  HavokPhysics_CollisionQueryResult *v123; 
  int numInOut; 
  unsigned int v125; 
  Physics_WorldId v126; 
  ScreenPlacement *v127; 
  float *v128; 
  HavokPhysicsWorld *v129; 
  __m256i v130; 
  __int64 v131; 
  __int64 v132; 
  vec3_t center; 
  vec3_t pos; 
  vec3_t end; 
  char dest[256]; 
  char text[256]; 
  char v138; 
  void *retaddr; 

  _RAX = &retaddr;
  v132 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  v16 = collisionFilterInfo;
  __asm { vmovaps xmm6, xmm2 }
  _R12 = position;
  v19 = worldId;
  v126 = worldId;
  v20 = scrPlace;
  v127 = (ScreenPlacement *)scrPlace;
  _RDI = x;
  v128 = x;
  _R13 = y;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+388h+var_300+10h], xmm0
  }
  v130.m256i_i64[3] = 0i64;
  LODWORD(v131) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23353, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugGetClosestPoints with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RBX = HavokPhysics_GetMutableWorld((Physics_WorldId)v19);
  v129 = _RBX;
  if ( dword_150D5FA60 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA60);
    if ( dword_150D5FA60 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_4.m_ignoreEntities.m_data = NULL;
      ignoreBodies_4.m_ignoreEntities.m_size = 0;
      ignoreBodies_4.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_4.m_ignoreBodies.m_data = NULL;
      ignoreBodies_4.m_ignoreBodies.m_size = 0;
      ignoreBodies_4.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      LODWORD(v123) = 0;
      hkMemHeapAllocator();
      v125 = 0;
      ignoreBodies_4.m_ignoreBodies.m_data = NULL;
      ignoreBodies_4.m_ignoreBodies.m_size = 0;
      ignoreBodies_4.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_4.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_4.m_isClutter = 0;
      ignoreBodies_4.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugGetClosestPoints_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA60);
      v16 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v25 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_4.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v25) )
    ignoreBodies_4.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v130.m256i_i32[0] = v16;
  v130.m256i_i8[4] = 1;
  v130.m256i_i64[1] = (__int64)&ignoreBodies_4;
  v26 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v19];
  if ( v26 == -1 )
  {
    if ( _RBX->requestDebugGetClosestPoints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23370, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugGetClosestPoints)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugGetClosestPoints") )
      __debugbreak();
    s_havokPhysicsWorldGetClosestPointsActiveIndices[v19] = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups xmmword ptr [rbx+0E10h], xmm0
      vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rbx+0E20h], xmm1
      vmovss  dword ptr [rbx+0E30h], xmm6
      vmovups ymm0, [rsp+388h+var_300]
      vmovups ymmword ptr [rbx+0E38h], ymm0
      vmovsd  xmm1, [rsp+388h+var_2E0]
      vmovsd  qword ptr [rbx+0E58h], xmm1
    }
    _RBX->requestDebugGetClosestPoints = 1;
    goto LABEL_33;
  }
  v31 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v19];
  if ( !_RBX->requestDebugGetClosestPoints && s_havokPhysicsWorldGetClosestPointsData[2 * (int)v19 + v26].isComplete )
  {
    s_havokPhysicsWorldGetClosestPointsActiveIndices[v19] = 1 - v26;
    HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldGetClosestPointsData[2 * (int)v19 + 1 - v26].result, 1);
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups xmmword ptr [rbx+0E10h], xmm0
      vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rbx+0E20h], xmm1
      vmovss  dword ptr [rbx+0E30h], xmm6
      vmovups ymm0, [rsp+388h+var_300]
      vmovups ymmword ptr [rbx+0E38h], ymm0
      vmovsd  xmm1, [rsp+388h+var_2E0]
      vmovsd  qword ptr [rbx+0E58h], xmm1
    }
    _RBX->requestDebugGetClosestPoints = 1;
    v31 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v19];
  }
  if ( v31 != -1 )
  {
    v36 = 3i64 * (2 * (int)v19 - v31) + 3;
    if ( *(&s_havokPhysicsWorldGetClosestPointsData[0].isComplete + 8 * v36) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r12]
        vmovss  xmm2, cs:__real@42000000
        vmulss  xmm3, xmm0, xmm2
        vmovss  dword ptr [rsp+388h+center], xmm3
        vmovss  xmm0, dword ptr [r12+4]
        vmulss  xmm4, xmm0, xmm2
        vmovss  dword ptr [rsp+388h+center+4], xmm4
        vmovss  xmm1, dword ptr [r12+8]
        vmulss  xmm5, xmm1, xmm2
        vmovss  dword ptr [rsp+388h+center+8], xmm5
        vmulss  xmm9, xmm6, xmm2
      }
      integer = 0xFFFFFF;
      if ( physics_debugQueryBody->current.integer >= 0 )
        integer = physics_debugQueryBody->current.integer;
      if ( (integer & 0xFFFFFF) != 0xFFFFFF )
      {
        v46 = ((__int64 (__fastcall *)(hknpWorldReader *))_RBX->world->isBodyValid)(&_RBX->world->hknpWorldReader);
        __asm { vmovss  xmm3, dword ptr [rsp+388h+center] }
        if ( v46 )
        {
          __asm
          {
            vcvtss2sd xmm0, xmm6, xmm6
            vmovss  xmm1, dword ptr [rsp+388h+center+8]
            vcvtss2sd xmm1, xmm1, xmm1
            vmovss  xmm2, dword ptr [rsp+388h+center+4]
            vcvtss2sd xmm2, xmm2, xmm2
            vcvtss2sd xmm3, xmm3, xmm3
            vmovsd  qword ptr [rsp+388h+adjust], xmm0
            vmovsd  qword ptr [rsp+388h+var_350], xmm1
            vmovsd  qword ptr [rsp+388h+shadow], xmm2
            vmovsd  qword ptr [rsp+388h+forceColor], xmm3
            vmovsd  xmm0, cs:__real@4028000000000000
            vmovsd  [rsp+388h+fmt], xmm0
          }
          Com_sprintf<256>((char (*)[256])dest, "Get Closest Points in body %i %s against sphere of radius %.2f at (%.2f, %.2f, %.2f) with maxDistance %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)_RBX->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), *(double *)&fmt, forceColora, shadowa, v112, adjusta);
LABEL_25:
          v61 = 0;
          __asm
          {
            vmovss  xmm7, [rsp+388h+charHeight]
            vmovss  [rsp+388h+var_350], xmm7
            vmovss  xmm2, dword ptr [r13+0]; y
            vmovss  xmm1, dword ptr [rdi]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v113, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [r13+0]
            vmovss  dword ptr [r13+0], xmm0
            vmovss  xmm8, [rsp+388h+tabWidth]
            vaddss  xmm0, xmm8, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
            vmovss  [rsp+388h+forceColor], xmm7
            vmovss  dword ptr [rsp+388h+fmt], xmm8
          }
          HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, x, y, fmtb, *(float *)&forceColorc);
          __asm
          {
            vmovss  xmm0, dword ptr [rdi]
            vsubss  xmm1, xmm0, xmm8
            vmovss  dword ptr [rdi], xmm1
          }
          v70 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldGetClosestPointsData[0].result + v36);
          v123 = v70;
          __asm { vmovss  xmm1, cs:__real@41400000; radius }
          CG_DebugSphere(&center, *(float *)&_XMM1, &colorRed, 0, 0);
          __asm
          {
            vmovss  xmm10, cs:__real@40a00000
            vcomiss xmm9, cs:__real@3f000000
            vmovaps xmm1, xmm10; radius
          }
          CG_DebugSphere(&center, *(float *)&_XMM1, &colorYellow, 0, 0);
          contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v70);
          Com_sprintf<256>((char (*)[256])dest, "Results - %i hits", (unsigned int)contentsa);
          __asm
          {
            vmovss  [rsp+388h+var_350], xmm7
            vmovss  xmm2, dword ptr [r13+0]; y
            vmovss  xmm1, dword ptr [rdi]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v114, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [r13+0]
            vmovss  dword ptr [r13+0], xmm0
            vaddss  xmm1, xmm8, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm1
          }
          if ( contentsa > 0 )
          {
            __asm { vmovss  xmm9, cs:__real@3f800000 }
            do
            {
              ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v70, v61);
              v125 = ClosestPointHitBodyId;
              if ( Physics_IsRigidBodyValid((Physics_WorldId)v19, ClosestPointHitBodyId) )
              {
                v82 = (const char *)((unsigned __int64)_RBX->world->m_bodyManager.m_bodyNames.m_data[ClosestPointHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                v83 = v123;
                HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v123, v61, &pos);
                HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v83, v61, &end);
                *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v83, v61);
                __asm { vmovaps xmm6, xmm0 }
                ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v83, v61);
                ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v83, v61);
                ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v83, v61);
                LODWORD(v83) = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v83, v61);
                v88.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v123, v61);
                LODWORD(v120) = HavokPhysics_GetRef(v123->m_worldId, v88);
                LODWORD(adjust) = (_DWORD)v83;
                LODWORD(v115) = ClosestPointHitHitContents;
                LODWORD(shadow) = ClosestPointHitHitMaterialId;
                LODWORD(forceColor) = ClosestPointHitHitShapeKey;
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v61, v125, v82, forceColor, shadow, v115, adjust, v120);
                __asm
                {
                  vmovss  [rsp+388h+var_350], xmm7
                  vmovss  xmm2, dword ptr [r13+0]; y
                }
                _RDI = v128;
                __asm { vmovss  xmm1, dword ptr [rdi]; x }
                Physics_DrawDebugString(v127, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v117, 0);
                __asm
                {
                  vaddss  xmm0, xmm7, dword ptr [r13+0]
                  vmovss  dword ptr [r13+0], xmm0
                  vmovaps xmm1, xmm10; radius
                }
                CG_DebugSphere(&pos, *(float *)&_XMM1, &colorRed, 0, 0);
                CG_DebugLine(&pos, &end, &colorRed, 0, 0);
                __asm
                {
                  vcvtss2sd xmm0, xmm6, xmm6
                  vmovsd  [rsp+388h+fmt], xmm0
                }
                Com_sprintf(text, 0x100ui64, "%s %.2f", v82, *(double *)&fmtc);
                __asm { vmovaps xmm2, xmm9; scale }
                CL_AddDebugString(&pos, &colorRed, *(float *)&_XMM2, text, 0, 0);
                _RBX = v129;
                LODWORD(v19) = v126;
                v20 = v127;
              }
              else
              {
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v61, ClosestPointHitBodyId);
                __asm
                {
                  vmovss  [rsp+388h+var_350], xmm7
                  vmovss  xmm2, dword ptr [r13+0]; y
                  vmovss  xmm1, dword ptr [rdi]; x
                }
                Physics_DrawDebugString(v20, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v116, 0);
                __asm
                {
                  vaddss  xmm0, xmm7, dword ptr [r13+0]
                  vmovss  dword ptr [r13+0], xmm0
                }
              }
              ++v61;
              v70 = v123;
            }
            while ( (int)v61 < contentsa );
            __asm { vmovss  xmm1, dword ptr [rdi] }
          }
          __asm
          {
            vsubss  xmm0, xmm1, xmm8
            vmovss  dword ptr [rdi], xmm0
          }
          goto LABEL_33;
        }
        __asm
        {
          vmovss  xmm5, dword ptr [rsp+388h+center+8]
          vmovss  xmm4, dword ptr [rsp+388h+center+4]
        }
      }
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vcvtss2sd xmm1, xmm5, xmm5
        vcvtss2sd xmm2, xmm4, xmm4
        vcvtss2sd xmm3, xmm3, xmm3
        vmovsd  qword ptr [rsp+388h+shadow], xmm0
        vmovsd  qword ptr [rsp+388h+forceColor], xmm1
        vmovsd  [rsp+388h+fmt], xmm2
        vmovq   r9, xmm3
        vmovsd  xmm2, cs:__real@4028000000000000
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Get Closest Points against sphere of radius %.2f at (%.2f, %.2f, %.2f) with maxDistance %.2f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmta, forceColorb, shadowb);
      goto LABEL_25;
    }
  }
LABEL_33:
  _R11 = &v138;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
HavokPhysics_DrawDebugMutableShapesInWorld
==============
*/
void HavokPhysics_DrawDebugMutableShapesInWorld(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, Physics_WorldId worldId, float detailRange)
{
  Physics_WorldId v14; 
  unsigned int v17; 
  unsigned int v18; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  __int64 v25; 
  const char **p_name; 
  char v27; 
  unsigned int NumRigidBodys; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *v30; 
  unsigned int m_serialAndIndex; 
  _BYTE *v32; 
  bool v33; 
  const HavokPhysicsWorld *v34; 
  const HavokPhysicsInstanceManager *v35; 
  unsigned int v36; 
  char v48; 
  char v49; 
  const char *v50; 
  unsigned int v51; 
  const HavokPhysicsWorld *v52; 
  const HavokPhysicsInstanceManager *v53; 
  unsigned int v54; 
  __int64 v55; 
  const hkTransformf *v56; 
  __int64 v57; 
  __int64 v58; 
  hknpWorld *world; 
  const tmat34_t<vec4_t> *v60; 
  const char *v64; 
  int v66; 
  int v67; 
  unsigned __int16 v68; 
  unsigned int v72; 
  const vec4_t *v73; 
  const vec4_t *v74; 
  const hkStringPtr *m_data; 
  hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int> > *p_m_mutableShapeLookup; 
  const char *v77; 
  hkHashMapDetail::Entry *Entry; 
  int v79; 
  int v80; 
  int m_1; 
  int v83; 
  __int64 v84; 
  __int64 v93; 
  __int64 v94; 
  unsigned int i; 
  unsigned int v96; 
  unsigned int v97; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v99; 
  unsigned __int16 v100; 
  unsigned __int16 v101; 
  hknpBodyId result; 
  hknpBodyId bodyId; 
  hknpBodyId v104; 
  Physics_WorldId v105; 
  hkStringPtr v106; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const char *v108; 
  __int64 v109; 
  __int64 v110; 
  unsigned __int64 item; 
  const hkTransformf *v112; 
  __int64 v113; 
  vec3_t outPos; 
  vec3_t xyz; 
  vec3_t position; 
  vec4_t orientation; 
  vec4_t out; 
  hkTransformf v119; 
  hkTransformf transformOut; 
  char v121; 
  void *retaddr; 

  _RAX = &retaddr;
  v113 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
  }
  v14 = worldId;
  v105 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23804, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DrawDebugMutableShapesInWorld when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23805, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DrawDebugMutableShapesInWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v93) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23809, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DrawDebugMutableShapesInWorld %i: world is NULL", "havokPhysicsWorld->world", v93) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, [rbp+130h+detailRange]
    vmulss  xmm8, xmm0, xmm0
  }
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  v17 = 0;
  v18 = 0;
  v97 = 0;
  if ( MutableWorld->instanceManager.capacity )
  {
    p_instanceManager = &MutableWorld->instanceManager;
    __asm
    {
      vmovss  xmm9, dword ptr [rbp+130h+outPos+8]
      vmovss  xmm10, dword ptr [rbp+130h+outPos+4]
      vmovss  xmm11, dword ptr [rbp+130h+outPos]
      vmovss  xmm7, cs:__real@42000000
      vmovss  xmm6, cs:__real@3e800000
    }
    do
    {
      if ( HavokPhysicsInstanceManager_IsInstanceInUse(p_instanceManager, v18) )
      {
        v25 = v18;
        v109 = v25 * 80;
        p_name = &p_instanceManager->buffer[v25].physicsAsset->name;
        if ( p_name )
        {
          HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(p_instanceManager->buffer[v25].physicsAsset);
          if ( HavokPhysicsAsset )
          {
            v27 = 0;
            if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 71, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies when system is not initialized", "g_physicsInitialized") )
              __debugbreak();
            if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 72, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                __debugbreak();
            }
            if ( v18 == -1 )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 73, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v93) )
                __debugbreak();
            }
            if ( !g_physicsClientWorldsCreated && (unsigned int)(v14 - 2) <= 5 )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 74, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v93) )
                __debugbreak();
            }
            if ( !g_physicsServerWorldsCreated && (unsigned int)v14 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 75, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v93) )
                __debugbreak();
            }
            NumRigidBodys = HavokPhysics_GetNumRigidBodys(v14, v18);
            v96 = NumRigidBodys;
            do
            {
              if ( v17 >= NumRigidBodys )
              {
                v17 = 0;
                goto LABEL_173;
              }
              if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
              {
                LODWORD(v93) = v14;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                  __debugbreak();
              }
              if ( v18 == -1 )
              {
                LODWORD(v93) = v14;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v93) )
                  __debugbreak();
              }
              ConstWorld = HavokPhysics_GetConstWorld(v14);
              if ( !ConstWorld->world )
              {
                LODWORD(v93) = v14;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v93) )
                  __debugbreak();
              }
              v30 = &ConstWorld->instanceManager;
              if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                __debugbreak();
              if ( v18 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                __debugbreak();
              if ( v17 >= v30->buffer[v25].bodies.m_size )
              {
                LODWORD(v94) = v14;
                LODWORD(v93) = v17;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v93, v94) )
                  __debugbreak();
              }
              HavokPhysicsInstanceManager_GetBodyId(&result, v30, v18, v17);
              m_serialAndIndex = result.m_serialAndIndex;
              if ( !HavokPhysics_IsRigidBodyValid(v14, result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23843, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, bodyId ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, bodyId )") )
                __debugbreak();
              v32 = *(_BYTE **)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex) + 96);
              v33 = v32[26] == 18 && (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v32 + 24i64))(v32);
              ++v17;
              v27 |= v33;
              NumRigidBodys = v96;
            }
            while ( !v27 );
            if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                __debugbreak();
            }
            if ( v18 == -1 )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v93) )
                __debugbreak();
            }
            v34 = HavokPhysics_GetConstWorld(v14);
            if ( !v34->world )
            {
              LODWORD(v93) = v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v93) )
                __debugbreak();
            }
            v35 = &v34->instanceManager;
            if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
              __debugbreak();
            if ( v18 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
              __debugbreak();
            v17 = 0;
            if ( !v35->buffer[v25].bodies.m_size )
            {
              LODWORD(v94) = v14;
              LODWORD(v93) = 0;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v93, v94) )
                __debugbreak();
            }
            HavokPhysicsInstanceManager_GetBodyId(&bodyId, v35, v18, 0);
            v36 = bodyId.m_serialAndIndex;
            if ( !HavokPhysics_IsRigidBodyValid(v14, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23859, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, body0Id ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, body0Id )") )
              __debugbreak();
            Physics_GetRigidBodyTransform(v14, v36, &position, &orientation);
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+130h+position]
              vsubss  xmm3, xmm0, xmm11
              vmovss  xmm1, dword ptr [rbp+130h+position+4]
              vsubss  xmm2, xmm1, xmm10
              vmovss  xmm0, dword ptr [rbp+130h+position+8]
              vsubss  xmm4, xmm0, xmm9
              vmulss  xmm2, xmm2, xmm2
              vmulss  xmm1, xmm3, xmm3
              vaddss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm4, xmm4
              vaddss  xmm2, xmm3, xmm0
              vcomiss xmm8, xmm2
            }
            if ( v48 | v49 )
            {
              __asm { vmovaps xmm2, xmm6; scale }
              CL_AddDebugString(&position, &colorCyan, *(float *)&_XMM2, *p_name, 0, 0);
            }
            else
            {
              v50 = *p_name;
              v108 = v50;
              v51 = 0;
              for ( i = 0; v51 < v96; v18 = v97 )
              {
                if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                {
                  LODWORD(v93) = v14;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                    __debugbreak();
                }
                if ( v18 == -1 )
                {
                  LODWORD(v93) = v14;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v93) )
                    __debugbreak();
                }
                v52 = HavokPhysics_GetConstWorld(v14);
                if ( !v52->world )
                {
                  LODWORD(v93) = v14;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v93) )
                    __debugbreak();
                }
                v53 = &v52->instanceManager;
                if ( !v53 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                  __debugbreak();
                if ( v18 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                  __debugbreak();
                if ( v51 >= *(int *)((char *)&v53->buffer->bodies.m_size + v109) )
                {
                  LODWORD(v94) = v14;
                  LODWORD(v93) = v51;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v93, v94) )
                    __debugbreak();
                }
                HavokPhysicsInstanceManager_GetBodyId(&v104, v53, v18, v51);
                v54 = v104.m_serialAndIndex;
                if ( !HavokPhysics_IsRigidBodyValid(v14, v104) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23876, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, bodyId ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, bodyId )") )
                  __debugbreak();
                v55 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, v54);
                v56 = (const hkTransformf *)v55;
                v112 = (const hkTransformf *)v55;
                v57 = *(_QWORD *)(v55 + 96);
                if ( *(_BYTE *)(v57 + 26) == 18 && (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v57 + 24i64))(*(_QWORD *)(v55 + 96)) )
                {
                  v58 = *(_QWORD *)(v57 + 56);
                  v99 = v58;
                  if ( *(_BYTE *)(v58 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23890, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
                    __debugbreak();
                  v110 = *(_QWORD *)(v57 + 64);
                  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 260, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Transform when system is not initialized", "g_physicsInitialized") )
                    __debugbreak();
                  if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                      __debugbreak();
                  }
                  if ( (v54 & 0xFFFFFF) == 0xFFFFFF )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 262, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Transform with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v93) )
                      __debugbreak();
                  }
                  if ( !g_physicsClientWorldsCreated && (unsigned int)(v14 - 2) <= 5 )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 263, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v93) )
                      __debugbreak();
                  }
                  if ( !g_physicsServerWorldsCreated && (unsigned int)v14 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 264, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v93) )
                      __debugbreak();
                  }
                  if ( (unsigned int)v14 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 345, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v93) )
                      __debugbreak();
                  }
                  if ( (v54 & 0xFFFFFF) == 0xFFFFFF )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 346, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", v93) )
                      __debugbreak();
                  }
                  world = HavokPhysics_GetConstWorld(v14)->world;
                  if ( !world )
                  {
                    LODWORD(v93) = v14;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 350, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v93) )
                      __debugbreak();
                  }
                  v60 = (const tmat34_t<vec4_t> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, v54);
                  __asm
                  {
                    vmulss  xmm1, xmm7, dword ptr [rax+30h]
                    vmovss  dword ptr [rbp+130h+xyz], xmm1
                    vmulss  xmm0, xmm7, dword ptr [rax+34h]
                    vmovss  dword ptr [rbp+130h+xyz+4], xmm0
                    vmulss  xmm2, xmm7, dword ptr [rax+38h]
                    vmovss  dword ptr [rbp+130h+xyz+8], xmm2
                  }
                  Axis34ToQuat(v60, &out);
                  v64 = j_va("%s:%s", v50, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[v54 & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                  v17 = 0;
                  __asm { vmovaps xmm2, xmm6; scale }
                  CL_AddDebugString(&xyz, &colorWhite, *(float *)&_XMM2, v64, 0, 0);
                  if ( v51 )
                    CL_AddDebugLine(&xyz, &position, &colorWhite, 0, 0, 0);
                  v66 = *(_DWORD *)(v58 + 80);
                  v67 = 0;
                  v100 = 0;
                  if ( v66 <= 0 )
                  {
LABEL_142:
                    v67 = -1;
                    v68 = -1;
                  }
                  else
                  {
                    while ( 1 )
                    {
                      v68 = v100;
                      if ( !*(_BYTE *)(112i64 * v100 + *(_QWORD *)(v58 + 72) + 92) )
                        break;
                      v100 = ++v67;
                      if ( v67 >= v66 )
                        goto LABEL_142;
                    }
                  }
                  if ( v67 != -1 )
                  {
                    do
                    {
                      hknpShapeInstance::getFullTransform((hknpShapeInstance *)(*(_QWORD *)(v58 + 72) + 112i64 * v68), &transformOut);
                      hkTransformf::setMul(&v119, v56, &transformOut);
                      __asm
                      {
                        vmulss  xmm1, xmm7, dword ptr [rbp+130h+var_110.m_translation.m_quad]
                        vmovss  dword ptr [rbp+130h+outPos], xmm1
                        vmulss  xmm0, xmm7, dword ptr [rbp+130h+var_110.m_translation.m_quad+4]
                        vmovss  dword ptr [rbp+130h+outPos+4], xmm0
                        vmulss  xmm2, xmm7, dword ptr [rbp+130h+var_110.m_translation.m_quad+8]
                        vmovss  dword ptr [rbp+130h+outPos+8], xmm2
                      }
                      v72 = v68;
                      v73 = &colorRed;
                      v74 = &colorRedFaded;
                      if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v110 + 32i64))(v110, (0xFFFFFFFF >> *(_BYTE *)(v58 + 27)) | (v68 << (32 - *(_BYTE *)(v58 + 27)))) )
                      {
                        v73 = &colorGreen;
                        v74 = &colorGreenFaded;
                      }
                      m_data = HavokPhysicsAsset->m_mutableShapeNames.m_data;
                      if ( m_data == &m_data[HavokPhysicsAsset->m_mutableShapeNames.m_size] )
                        goto LABEL_156;
                      p_m_mutableShapeLookup = &HavokPhysicsAsset->m_mutableShapeLookup;
                      while ( 1 )
                      {
                        hkStringPtr::hkStringPtr(&v106, m_data);
                        v77 = (const char *)((unsigned __int64)v106.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                        item = hkHash::computeFNV1Hash32((const char *)((unsigned __int64)v106.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                        Entry = hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int>>::_findEntry(p_m_mutableShapeLookup, &item);
                        v79 = Entry ? Entry->idx : -1;
                        if ( v79 >= 0 )
                        {
                          v80 = p_m_mutableShapeLookup->m_items.m_data[v79].m_1 >> 16;
                          m_1 = (unsigned __int16)p_m_mutableShapeLookup->m_items.m_data[v79].m_1;
                          if ( v80 == i && m_1 == v72 )
                            break;
                        }
                        hkStringPtr::~hkStringPtr(&v106);
                        if ( ++m_data == &HavokPhysicsAsset->m_mutableShapeNames.m_data[HavokPhysicsAsset->m_mutableShapeNames.m_size] )
                          goto LABEL_155;
                      }
                      hkStringPtr::~hkStringPtr(&v106);
                      if ( !v77 )
                      {
LABEL_155:
                        v58 = v99;
                        goto LABEL_156;
                      }
                      v84 = -1i64;
                      do
                        ++v84;
                      while ( v77[v84] );
                      v58 = v99;
                      if ( !v84 )
LABEL_156:
                        v77 = j_va("%i", v72);
                      v17 = 0;
                      __asm { vmovaps xmm2, xmm6; scale }
                      CL_AddDebugString(&outPos, v73, *(float *)&_XMM2, v77, 0, 0);
                      CL_AddDebugLine(&outPos, &xyz, v74, 0, 0, 0);
                      v83 = *(_DWORD *)(v58 + 80);
                      v101 = ++v67;
                      if ( v67 >= v83 )
                      {
LABEL_160:
                        v67 = -1;
                        v68 = -1;
                      }
                      else
                      {
                        while ( 1 )
                        {
                          v68 = v101;
                          if ( !*(_BYTE *)(112i64 * v101 + *(_QWORD *)(v58 + 72) + 92) )
                            break;
                          v101 = ++v67;
                          if ( v67 >= v83 )
                            goto LABEL_160;
                        }
                      }
                      v56 = v112;
                    }
                    while ( v67 != -1 );
                    v14 = v105;
                    v51 = i;
                  }
                  v50 = v108;
                }
                else
                {
                  v17 = 0;
                }
                i = ++v51;
              }
            }
LABEL_173:
            p_instanceManager = &MutableWorld->instanceManager;
          }
        }
      }
      v97 = ++v18;
    }
    while ( v18 < MutableWorld->instanceManager.capacity );
  }
  _R11 = &v121;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
HavokPhysics_DrawDebugPhysicsRefSystemCounts
==============
*/
void HavokPhysics_DrawDebugPhysicsRefSystemCounts(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int *refSystemCounts; 
  const char **v18; 
  float v27; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  _RSI = y;
  _RBX = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17193, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DebugDrawPhysicsRefSystemCounts with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  __asm
  {
    vmovss  xmm7, [rsp+1C8h+tabWidth]
    vaddss  xmm0, xmm7, dword ptr [rbx]
    vmovss  xmm6, [rsp+1C8h+charHeight]
    vmovss  dword ptr [rbx], xmm0
  }
  refSystemCounts = (unsigned int *)MutableWorld->refSystemCounts;
  v18 = refSystemNames_0;
  do
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", *refSystemCounts, *v18);
    __asm
    {
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rbx]; x
      vmovss  [rsp+1C8h+var_190], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v27, 0);
    __asm { vaddss  xmm0, xmm6, dword ptr [rsi] }
    ++v18;
    ++refSystemCounts;
    __asm { vmovss  dword ptr [rsi], xmm0 }
  }
  while ( (__int64)v18 < (__int64)&unk_147F9A828 );
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rbx], xmm1
    vmovaps xmm6, [rsp+1C8h+var_58]
    vmovaps xmm7, [rsp+1C8h+var_68]
  }
}

/*
==============
HavokPhysics_DrawDebugQueryPoint
==============
*/

void __fastcall HavokPhysics_DrawDebugQueryPoint(Physics_WorldId worldId, const hkVector4f *position, double maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v16; 
  __int64 v19; 
  const ScreenPlacement *v20; 
  bool v25; 
  int v26; 
  int v29; 
  __int64 v32; 
  int integer; 
  unsigned int v55; 
  HavokPhysics_CollisionQueryResult *v64; 
  unsigned int ClosestPointHitBodyId; 
  const char *v75; 
  HavokPhysics_CollisionQueryResult *v76; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  hknpBodyId v81; 
  char *fmt; 
  char *fmta; 
  float fmtb; 
  char *fmtc; 
  double forceColora; 
  double forceColorb; 
  int forceColorc; 
  __int64 forceColor; 
  double shadowa; 
  __int64 shadow; 
  double v104; 
  float v105; 
  float v106; 
  __int64 v107; 
  float v108; 
  float v109; 
  __int64 adjust; 
  __int64 v111; 
  signed int contentsa; 
  HavokPhysics_CollisionQueryResult *v114; 
  int numInOut; 
  unsigned int v116; 
  Physics_WorldId v117; 
  ScreenPlacement *v118; 
  float *v119; 
  HavokPhysicsWorld *v120; 
  __m256i v121; 
  __int64 v122; 
  vec3_t center; 
  vec3_t pos; 
  vec3_t end; 
  char dest[256]; 
  char text[256]; 
  char v128; 
  void *retaddr; 

  _RAX = &retaddr;
  v122 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  v16 = collisionFilterInfo;
  __asm { vmovaps xmm6, xmm2 }
  _R12 = position;
  v19 = worldId;
  v117 = worldId;
  v20 = scrPlace;
  v118 = (ScreenPlacement *)scrPlace;
  _RBX = x;
  v119 = x;
  _R13 = y;
  v121.m256i_i32[4] = 1;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+378h+var_2F0+14h], xmm0
  }
  v121.m256i_i32[6] = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23203, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugQueryPoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RDI = HavokPhysics_GetMutableWorld((Physics_WorldId)v19);
  v120 = _RDI;
  if ( dword_150D5FA5C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA5C);
    if ( dword_150D5FA5C == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_3.m_ignoreEntities.m_data = NULL;
      ignoreBodies_3.m_ignoreEntities.m_size = 0;
      ignoreBodies_3.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_3.m_ignoreBodies.m_data = NULL;
      ignoreBodies_3.m_ignoreBodies.m_size = 0;
      ignoreBodies_3.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      LODWORD(v114) = 0;
      hkMemHeapAllocator();
      v116 = 0;
      ignoreBodies_3.m_ignoreBodies.m_data = NULL;
      ignoreBodies_3.m_ignoreBodies.m_size = 0;
      ignoreBodies_3.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_3.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_3.m_isClutter = 0;
      ignoreBodies_3.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugQueryPoint_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA5C);
      v16 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v25 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_3.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v25) )
    ignoreBodies_3.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v121.m256i_i32[0] = v16;
  v121.m256i_i8[4] = 1;
  v121.m256i_i64[1] = (__int64)&ignoreBodies_3;
  v26 = s_havokPhysicsWorldQueryPointActiveIndices[v19];
  if ( v26 == -1 )
  {
    if ( _RDI->requestDebugQueryPoint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23220, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugQueryPoint)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugQueryPoint") )
      __debugbreak();
    s_havokPhysicsWorldQueryPointActiveIndices[v19] = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups xmmword ptr [rdi+0DD0h], xmm0
      vmovss  dword ptr [rdi+0DE0h], xmm6
      vmovups ymm0, [rsp+378h+var_2F0]
      vmovups ymmword ptr [rdi+0DE8h], ymm0
    }
    _RDI->requestDebugQueryPoint = 1;
    goto LABEL_33;
  }
  v29 = s_havokPhysicsWorldQueryPointActiveIndices[v19];
  if ( !_RDI->requestDebugQueryPoint && s_havokPhysicsWorldQueryPointData[2 * (int)v19 + v26].isComplete )
  {
    s_havokPhysicsWorldQueryPointActiveIndices[v19] = 1 - v26;
    HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldQueryPointData[2 * (int)v19 + 1 - v26].result, 1);
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups xmmword ptr [rdi+0DD0h], xmm0
      vmovss  dword ptr [rdi+0DE0h], xmm6
      vmovups ymm0, [rsp+378h+var_2F0]
      vmovups ymmword ptr [rdi+0DE8h], ymm0
    }
    _RDI->requestDebugQueryPoint = 1;
    v29 = s_havokPhysicsWorldQueryPointActiveIndices[v19];
  }
  if ( v29 != -1 )
  {
    v32 = 3i64 * (2 * (int)v19 - v29) + 3;
    if ( *(&s_havokPhysicsWorldQueryPointData[0].isComplete + 8 * v32) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r12]
        vmovss  xmm2, cs:__real@42000000
        vmulss  xmm4, xmm0, xmm2
        vmovss  dword ptr [rsp+378h+center], xmm4
        vmovss  xmm0, dword ptr [r12+4]
        vmulss  xmm3, xmm0, xmm2
        vmovss  dword ptr [rsp+378h+center+4], xmm3
        vmovss  xmm1, dword ptr [r12+8]
        vmulss  xmm5, xmm1, xmm2
        vmovss  dword ptr [rsp+378h+center+8], xmm5
        vmulss  xmm9, xmm6, xmm2
      }
      integer = 0xFFFFFF;
      if ( physics_debugQueryBody->current.integer >= 0 )
        integer = physics_debugQueryBody->current.integer;
      if ( (integer & 0xFFFFFF) != 0xFFFFFF )
      {
        if ( ((unsigned int (__fastcall *)(hknpWorldReader *))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader) )
        {
          __asm
          {
            vcvtss2sd xmm0, xmm6, xmm6
            vmovss  xmm1, dword ptr [rsp+378h+center+8]
            vcvtss2sd xmm1, xmm1, xmm1
            vmovss  xmm2, dword ptr [rsp+378h+center+4]
            vcvtss2sd xmm2, xmm2, xmm2
            vmovss  xmm3, dword ptr [rsp+378h+center]
            vcvtss2sd xmm3, xmm3, xmm3
            vmovsd  qword ptr [rsp+378h+var_340], xmm0
            vmovsd  qword ptr [rsp+378h+shadow], xmm1
            vmovsd  qword ptr [rsp+378h+forceColor], xmm2
            vmovsd  [rsp+378h+fmt], xmm3
          }
          Com_sprintf<256>((char (*)[256])dest, "Query Point for Body %i %s at (%.2f, %.2f, %.2f) with maxDistance %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)_RDI->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), *(double *)&fmt, forceColora, shadowa, v104);
LABEL_25:
          v55 = 0;
          __asm
          {
            vmovss  xmm7, [rsp+378h+charHeight]
            vmovss  [rsp+378h+var_340], xmm7
            vmovss  xmm2, dword ptr [r13+0]; y
            vmovss  xmm1, dword ptr [rbx]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v105, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [r13+0]
            vmovss  dword ptr [r13+0], xmm0
            vmovss  xmm8, [rsp+378h+tabWidth]
            vaddss  xmm0, xmm8, dword ptr [rbx]
            vmovss  dword ptr [rbx], xmm0
            vmovss  [rsp+378h+forceColor], xmm7
            vmovss  dword ptr [rsp+378h+fmt], xmm8
          }
          HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, x, y, fmtb, *(float *)&forceColorc);
          __asm
          {
            vmovss  xmm0, dword ptr [rbx]
            vsubss  xmm2, xmm0, xmm8
            vmovss  dword ptr [rbx], xmm2
          }
          v64 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldQueryPointData[0].result + v32);
          v114 = v64;
          __asm
          {
            vmovss  xmm10, cs:__real@40a00000
            vcomiss xmm9, cs:__real@3f000000
            vmovaps xmm1, xmm10; radius
          }
          CG_DebugSphere(&center, *(float *)&_XMM1, &colorYellow, 0, 0);
          contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v64);
          Com_sprintf<256>((char (*)[256])dest, "Results - %i hits", (unsigned int)contentsa);
          __asm
          {
            vmovss  [rsp+378h+var_340], xmm7
            vmovss  xmm2, dword ptr [r13+0]; y
            vmovss  xmm1, dword ptr [rbx]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v106, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [r13+0]
            vmovss  dword ptr [r13+0], xmm0
            vaddss  xmm1, xmm8, dword ptr [rbx]
            vmovss  dword ptr [rbx], xmm1
          }
          if ( contentsa > 0 )
          {
            __asm { vmovss  xmm9, cs:__real@3f800000 }
            do
            {
              ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v64, v55);
              v116 = ClosestPointHitBodyId;
              if ( Physics_IsRigidBodyValid((Physics_WorldId)v19, ClosestPointHitBodyId) )
              {
                v75 = (const char *)((unsigned __int64)_RDI->world->m_bodyManager.m_bodyNames.m_data[ClosestPointHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                v76 = v114;
                HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v114, v55, &pos);
                HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v76, v55, &end);
                *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v76, v55);
                __asm { vmovaps xmm6, xmm0 }
                ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v76, v55);
                ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v76, v55);
                ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v76, v55);
                LODWORD(v76) = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v76, v55);
                v81.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v114, v55);
                LODWORD(v111) = HavokPhysics_GetRef(v114->m_worldId, v81);
                LODWORD(adjust) = (_DWORD)v76;
                LODWORD(v107) = ClosestPointHitHitContents;
                LODWORD(shadow) = ClosestPointHitHitMaterialId;
                LODWORD(forceColor) = ClosestPointHitHitShapeKey;
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v55, v116, v75, forceColor, shadow, v107, adjust, v111);
                __asm
                {
                  vmovss  [rsp+378h+var_340], xmm7
                  vmovss  xmm2, dword ptr [r13+0]; y
                }
                _RBX = v119;
                __asm { vmovss  xmm1, dword ptr [rbx]; x }
                Physics_DrawDebugString(v118, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v109, 0);
                __asm
                {
                  vaddss  xmm0, xmm7, dword ptr [r13+0]
                  vmovss  dword ptr [r13+0], xmm0
                  vmovaps xmm1, xmm10; radius
                }
                CG_DebugSphere(&pos, *(float *)&_XMM1, &colorRed, 0, 0);
                CG_DebugLine(&pos, &end, &colorRed, 0, 0);
                __asm
                {
                  vcvtss2sd xmm0, xmm6, xmm6
                  vmovsd  [rsp+378h+fmt], xmm0
                }
                Com_sprintf(text, 0x100ui64, "%s %.2f", v75, *(double *)&fmtc);
                __asm { vmovaps xmm2, xmm9; scale }
                CL_AddDebugString(&pos, &colorRed, *(float *)&_XMM2, text, 0, 0);
                _RDI = v120;
                LODWORD(v19) = v117;
                v20 = v118;
              }
              else
              {
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v55, ClosestPointHitBodyId);
                __asm
                {
                  vmovss  [rsp+378h+var_340], xmm7
                  vmovss  xmm2, dword ptr [r13+0]; y
                  vmovss  xmm1, dword ptr [rbx]; x
                }
                Physics_DrawDebugString(v20, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v108, 0);
                __asm
                {
                  vaddss  xmm0, xmm7, dword ptr [r13+0]
                  vmovss  dword ptr [r13+0], xmm0
                }
              }
              ++v55;
              v64 = v114;
            }
            while ( (int)v55 < contentsa );
            __asm { vmovss  xmm1, dword ptr [rbx] }
          }
          __asm
          {
            vsubss  xmm0, xmm1, xmm8
            vmovss  dword ptr [rbx], xmm0
          }
          goto LABEL_33;
        }
        __asm
        {
          vmovss  xmm5, dword ptr [rsp+378h+center+8]
          vmovss  xmm3, dword ptr [rsp+378h+center+4]
          vmovss  xmm4, dword ptr [rsp+378h+center]
        }
      }
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vcvtss2sd xmm1, xmm5, xmm5
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm4, xmm4
        vmovsd  qword ptr [rsp+378h+forceColor], xmm0
        vmovsd  [rsp+378h+fmt], xmm1
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Query Point at (%.2f, %.2f, %.2f) with maxDistance %.2f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmta, forceColorb);
      goto LABEL_25;
    }
  }
LABEL_33:
  _R11 = &v128;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
HavokPhysics_DrawDebugRaycast
==============
*/
void HavokPhysics_DrawDebugRaycast(Physics_WorldId worldId, unsigned int collisionFilterInfo, bool isClutter, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  bool v15; 
  unsigned int v16; 
  __int64 v17; 
  int v41; 
  __int64 v42; 
  int v43; 
  HavokPhysics_CollisionQueryResult *result; 
  int v49; 
  int v50; 
  int v51; 
  int integer; 
  HavokPhysics_CollisionQueryResult *v61; 
  unsigned int RaycastHitBodyId; 
  hknpBodyId v70; 
  unsigned __int16 GlassIdFromUserData; 
  const hknpCollisionResult *Hit; 
  const hknpCollisionResult *v73; 
  const hknpCollisionResult *v74; 
  const hknpCollisionResult *v75; 
  unsigned int v76; 
  unsigned int v77; 
  const Physics_DetailHitData *DetailHitData; 
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 
  const char *v109; 
  unsigned int v124; 
  const hknpTriangleShape *TriangleShape; 
  int v141; 
  const hknpShape **p_m_shape; 
  const char *v159; 
  const char *v163; 
  int v167; 
  int partGroup; 
  const char *v179; 
  int v196; 
  hkMemoryAllocator *v197; 
  int v198; 
  int v199; 
  hknpBodyId *v200; 
  float fmt; 
  char *fmta; 
  char *fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  int forceColora; 
  __int64 forceColor; 
  __int64 forceColorb; 
  int forceColorc; 
  int forceColord; 
  int forceColore; 
  int forceColorf; 
  int forceColorg; 
  __int64 forceColorh; 
  int forceColori; 
  __int64 shadow; 
  int shadowa; 
  float v222; 
  float v223; 
  float v224; 
  float v225; 
  float v226; 
  float v227; 
  float v228; 
  float v229; 
  float v230; 
  float v231; 
  float v232; 
  float v233; 
  float v234; 
  float v235; 
  float v236; 
  float v237; 
  float v238; 
  bool DecalTypeFromUserData; 
  bool BrushBasisFromUserData; 
  char v242; 
  int numInOut; 
  int v244; 
  unsigned int contents; 
  int surfFlags; 
  float zero[2]; 
  int Ref; 
  unsigned int v249; 
  Physics_WorldId v250; 
  unsigned int m_collisionFilterInfo; 
  const Physics_DetailHitData *v252; 
  __m256i v253; 
  __int64 v254; 
  hkMatrix3Impl<float> *v255; 
  __int64 v256; 
  vec3_t outPos; 
  __int128 v258; 
  __int128 v259; 
  hknpShapeCollector v260; 
  hknpInplaceTriangleShape v261; 
  char dest[256]; 
  char v263; 
  void *retaddr; 

  _RAX = &retaddr;
  v256 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  v15 = isClutter;
  v16 = collisionFilterInfo;
  contents = collisionFilterInfo;
  v17 = worldId;
  v250 = worldId;
  _RDI = x;
  _RSI = y;
  v253.m256i_i32[0] = -1;
  v253.m256i_i64[1] = 0i64;
  v253.m256i_i32[4] = 1;
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vmovss  dword ptr [rsp+0FE8h+var_F58+14h], xmm10
  }
  v253.m256i_i64[3] = 0x100000000i64;
  LOWORD(v254) = 256;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22631, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugRaycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (unsigned int)v17 <= 1 && !Physics_AreServerWorldsCreated() )
    goto LABEL_113;
  _R13 = HavokPhysics_GetMutableWorld((Physics_WorldId)v17);
  _RAX = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  __asm
  {
    vmovss  xmm6, dword ptr [rax+6944h]
    vmovss  xmm7, dword ptr [rax+6948h]
    vmovss  xmm8, dword ptr [rax+694Ch]
  }
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  __asm
  {
    vmovss  xmm2, cs:rayDist
    vmulss  xmm0, xmm2, xmm6
    vaddss  xmm9, xmm0, dword ptr [rsp+0FE8h+outPos]
    vmulss  xmm1, xmm2, xmm7
    vaddss  xmm7, xmm1, dword ptr [rsp+0FE8h+outPos+4]
    vmulss  xmm0, xmm2, xmm8
    vaddss  xmm6, xmm0, dword ptr [rsp+0FE8h+outPos+8]
    vmovss  xmm2, cs:__real@3d000000
    vmulss  xmm0, xmm2, dword ptr [rsp+0FE8h+outPos]
    vmovss  dword ptr [rsp+0FE8h+var_EF8], xmm0
    vmulss  xmm1, xmm2, dword ptr [rsp+0FE8h+outPos+4]
    vmovss  dword ptr [rsp+0FE8h+var_EF8+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rsp+0FE8h+outPos+8]
    vmovss  dword ptr [rsp+0FE8h+var_EF8+8], xmm0
    vmovss  dword ptr [rsp+0FE8h+var_EF8+0Ch], xmm10
    vmulss  xmm1, xmm9, xmm2
    vmovss  dword ptr [rsp+0FE8h+var_F08], xmm1
    vmulss  xmm0, xmm7, xmm2
    vmovss  dword ptr [rsp+0FE8h+var_F08+4], xmm0
    vmulss  xmm1, xmm6, xmm2
    vmovss  dword ptr [rsp+0FE8h+var_F08+8], xmm1
    vmovss  dword ptr [rsp+0FE8h+var_F08+0Ch], xmm10
  }
  if ( dword_150D5FA54 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA54);
    if ( dword_150D5FA54 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      v196 = 0x80000000;
      ignoreBodies_1.m_ignoreEntities.m_data = NULL;
      ignoreBodies_1.m_ignoreEntities.m_size = 0;
      ignoreBodies_1.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_1.m_ignoreBodies.m_data = NULL;
      ignoreBodies_1.m_ignoreBodies.m_size = 0;
      ignoreBodies_1.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      v244 = 0;
      v197 = hkMemHeapAllocator();
      v198 = v244;
      v199 = v244;
      if ( v244 )
      {
        v200 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v197, 4, &v244);
        v198 = v244;
      }
      else
      {
        v200 = NULL;
      }
      if ( v198 )
        v196 = v198;
      ignoreBodies_1.m_ignoreBodies.m_data = v200;
      ignoreBodies_1.m_ignoreBodies.m_size = v199;
      ignoreBodies_1.m_ignoreBodies.m_capacityAndFlags = v196;
      *(_QWORD *)&ignoreBodies_1.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_1.m_isClutter = 0;
      ignoreBodies_1.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugRaycast_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA54);
      v15 = isClutter;
      v16 = contents;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (_ZF = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_1.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, _ZF) )
    ignoreBodies_1.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  ignoreBodies_1.m_isClutter = v15;
  v253.m256i_i32[0] = v16;
  v253.m256i_i32[4] = !physics_debugRayDetail->current.enabled;
  v253.m256i_i64[1] = (__int64)&ignoreBodies_1;
  v41 = s_havokPhysicsWorldRayActiveIndices[v17];
  if ( v41 == -1 && s_havokPhysicsWorldRayDetailActiveIndices[v17] == -1 )
  {
    if ( _R13->requestDebugRaycast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22668, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugRaycast)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugRaycast") )
      __debugbreak();
    v41 = 0;
    s_havokPhysicsWorldRayActiveIndices[v17] = 0;
    s_havokPhysicsWorldRayDetailActiveIndices[v17] = 0;
    v42 = 2i64 * (_DWORD)v17;
    s_havokPhysicsWorldRayData[v42].isComplete = 1;
    s_havokPhysicsWorldRayDetailData[v42].isComplete = 1;
  }
  if ( !_R13->requestDebugRaycast )
  {
    if ( physics_debugRayDetail->current.enabled )
    {
      v43 = s_havokPhysicsWorldRayDetailActiveIndices[v17];
      if ( s_havokPhysicsWorldRayDetailData[2 * (int)v17 + v43].isComplete )
      {
        s_havokPhysicsWorldRayDetailActiveIndices[v17] = 1 - v43;
        result = s_havokPhysicsWorldRayDetailData[2 * (int)v17 + 1 - v43].result;
LABEL_22:
        HavokPhysics_CollisionQueryResult::Reset(result, 0);
        __asm
        {
          vmovups xmm0, [rsp+0FE8h+var_EF8]
          vmovups xmmword ptr [r13+0D10h], xmm0
          vmovups xmm1, [rsp+0FE8h+var_F08]
          vmovups ymm0, [rsp+0FE8h+var_F58]
          vmovups xmmword ptr [r13+0D20h], xmm1
          vmovups ymmword ptr [r13+0D30h], ymm0
          vmovsd  xmm1, [rsp+0FE8h+var_F38]
        }
        _R13->requestDebugRaycast = 1;
        __asm { vmovsd  qword ptr [r13+0D50h], xmm1 }
      }
    }
    else if ( s_havokPhysicsWorldRayData[2 * (int)v17 + v41].isComplete )
    {
      s_havokPhysicsWorldRayActiveIndices[v17] = 1 - v41;
      result = s_havokPhysicsWorldRayData[2 * (int)v17 + 1 - v41].result;
      goto LABEL_22;
    }
  }
  v49 = s_havokPhysicsWorldRayActiveIndices[v17];
  numInOut = 2 * v17 - v49;
  v50 = s_havokPhysicsWorldRayDetailActiveIndices[v17];
  v51 = 2 * v17 - v50;
  if ( physics_debugRayDetail->current.enabled )
  {
    if ( v50 == -1 || !s_havokPhysicsWorldRayDetailData[v51 + 1].isComplete )
      goto LABEL_113;
  }
  else if ( v49 == -1 || !s_havokPhysicsWorldRayData[2 * (int)v17 - v49 + 1].isComplete )
  {
    goto LABEL_113;
  }
  integer = physics_debugQueryBody->current.integer;
  if ( integer < 0 )
  {
    surfFlags = 0xFFFFFF;
    integer = 0xFFFFFF;
  }
  else
  {
    surfFlags = physics_debugQueryBody->current.integer;
  }
  if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *))_R13->world->isBodyValid)(&_R13->world->hknpWorldReader) )
    Com_sprintf<256>((char (*)[256])dest, "RayCast");
  else
    Com_sprintf<256>((char (*)[256])dest, "RayCast for body %i:%i %s", HIBYTE(physics_debugQueryBody->current.integer), physics_debugQueryBody->current.integer & 0xFFFFFF, (const char *)((unsigned __int64)_R13->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
  __asm
  {
    vmovss  xmm6, [rsp+0FE8h+charHeight]
    vmovss  [rsp+0FE8h+var_FB0], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rdi]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v222, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vmovss  xmm7, [rsp+0FE8h+tabWidth]
    vaddss  xmm0, xmm7, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
    vmovss  [rsp+0FE8h+forceColor], xmm6
    vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
  }
  HavokPhysics_DrawPhysicsContents(contents, scrPlace, x, y, fmt, *(float *)&forceColora);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rdi], xmm1
  }
  if ( physics_debugRayDetail->current.enabled )
    v61 = s_havokPhysicsWorldRayDetailData[v51 + 1].result;
  else
    v61 = s_havokPhysicsWorldRayData[numInOut + 1].result;
  Com_sprintf<256>((char (*)[256])dest, "Result");
  __asm
  {
    vmovss  [rsp+0FE8h+var_FB0], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rdi]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v223, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vaddss  xmm1, xmm7, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm1
  }
  Physics_LockWorld((Physics_WorldId)v17);
  if ( HavokPhysics_CollisionQueryResult::HasHit(v61) && (RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(v61, 0), Physics_IsRigidBodyValid((Physics_WorldId)v17, RaycastHitBodyId)) )
  {
    HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(v61, 0, &outPos);
    HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(v61, 0, (vec3_t *)&v258);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1068, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    _RAX = HavokPhysics_CollisionQueryResult::GetHit(v61, 0);
    __asm
    {
      vmovss  xmm8, dword ptr [rax+20h]
      vmulss  xmm9, xmm8, cs:rayDist
    }
    v70.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(v61, 0);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1082, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    contents = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_shapeKey.m_value;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1089, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    LOWORD(numInOut) = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1096, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
    surfFlags = HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(v61, 0);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1197, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      GlassIdFromUserData = 0;
    }
    else
    {
      Hit = HavokPhysics_CollisionQueryResult::GetHit(v61, 0);
      GlassIdFromUserData = Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
    }
    LOWORD(v244) = GlassIdFromUserData;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1214, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      BrushBasisFromUserData = 0;
    }
    else
    {
      v73 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0);
      BrushBasisFromUserData = Physics_GetBrushBasisFromUserData(v73->m_hitBodyInfo.m_filterData.m_userData);
    }
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1231, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      DecalTypeFromUserData = 0;
    }
    else
    {
      v74 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0);
      DecalTypeFromUserData = Physics_GetDecalTypeFromUserData(v74->m_hitBodyInfo.m_filterData.m_userData);
    }
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v61) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v61);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    v75 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0);
    Ref = HavokPhysics_GetRef(v61->m_worldId, v75->m_hitBodyInfo.m_bodyId);
    v255 = (hkMatrix3Impl<float> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))_R13->world->getBody)(&_R13->world->hknpWorldReader, v70.m_serialAndIndex);
    v76 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_rayCastResult.m_value >> 1;
    LOBYTE(v76) = v76 & 1;
    LODWORD(zero[0]) = v76;
    v242 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_rayCastResult.m_value & 1;
    v77 = HavokPhysics_CollisionQueryResult::GetHit(v61, 0)->m_rayCastResult.m_value >> 2;
    LOBYTE(v77) = v77 & 1;
    v249 = v77;
    DetailHitData = NULL;
    v252 = NULL;
    if ( physics_debugRayDetail->current.enabled && HavokPhysicsHitCollector::HasModifiers(v61->m_collector) )
    {
      Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(v61->m_collector, 0);
      if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22803, ASSERT_TYPE_ASSERT, "(dtModifier)", (const char *)&queryFormat, "dtModifier") )
        __debugbreak();
      DetailHitData = HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, 0);
      v252 = DetailHitData;
    }
    __asm { vmovss  xmm1, cs:__real@40a00000; radius }
    CG_DebugSphere(&outPos, *(float *)&_XMM1, &colorGreen, 0, 0);
    __asm
    {
      vmovss  xmm3, cs:__real@41400000
      vmulss  xmm1, xmm3, dword ptr [rsp+0FE8h+var_F08]
      vaddss  xmm2, xmm1, dword ptr [rsp+0FE8h+outPos]
      vmovss  dword ptr [rsp+0FE8h+var_EF8], xmm2
      vmulss  xmm1, xmm3, dword ptr [rsp+0FE8h+var_F08+4]
      vaddss  xmm2, xmm1, dword ptr [rsp+0FE8h+outPos+4]
      vmovss  dword ptr [rsp+0FE8h+var_EF8+4], xmm2
      vmulss  xmm1, xmm3, dword ptr [rsp+0FE8h+var_F08+8]
      vaddss  xmm2, xmm1, dword ptr [rsp+0FE8h+outPos+8]
      vmovss  dword ptr [rsp+0FE8h+var_EF8+8], xmm2
    }
    CG_DebugLine(&outPos, (const vec3_t *)&v259, &colorGreen, 0, 0);
    __asm
    {
      vcvtss2sd xmm3, xmm9, xmm9
      vcvtss2sd xmm2, xmm8, xmm8
      vmovq   r9, xmm3
      vmovq   r8, xmm2
    }
    Com_sprintf<256>((char (*)[256])dest, "Fraction:%f Distance %.2f", *(double *)&_XMM2, *(double *)&_XMM3);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v224, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm1, dword ptr [rsp+0FE8h+outPos+8]
      vcvtss2sd xmm1, xmm1, xmm1
      vmovss  xmm3, dword ptr [rsp+0FE8h+outPos+4]
      vcvtss2sd xmm3, xmm3, xmm3
      vmovss  xmm2, dword ptr [rsp+0FE8h+outPos]
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0FE8h+fmt], xmm1
      vmovq   r9, xmm3
      vmovq   r8, xmm2
    }
    Com_sprintf<256>((char (*)[256])dest, "Position:%.5f %.5f %.5f ", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmta);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v225, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    LODWORD(forceColorb) = Ref;
    LODWORD(fmtb) = contents;
    Com_sprintf<256>((char (*)[256])dest, "Body Id:%i:%i ShapeKey %x Ref %x", HIBYTE(v70.m_serialAndIndex), v70.m_serialAndIndex & 0xFFFFFF, fmtb, forceColorb);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v226, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    if ( (_BYTE)v249 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Internal Hit");
    }
    else if ( v242 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Backface Hit");
    }
    else
    {
      v109 = "Frontface Hit";
      if ( !LOBYTE(zero[0]) )
        v109 = "Unknown Hit Type";
      Com_sprintf<256>((char (*)[256])dest, v109);
    }
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v227, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  dword ptr [rsp+0FE8h+shadow], xmm7
    }
    HavokPhysics_DrawPhysicsBody((Physics_WorldId)v17, v70, 0, scrPlace, x, y, *(float *)&shadowa, v228);
    __asm { vmovss  xmm1, cs:__real@3c75c28f; radius }
    hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v261, *(float *)&_XMM1);
    v260.m_internal.m_shapeBuffer.m_shape = NULL;
    v260.m_internal.m_shapeBuffer.m_buffer = v260.m_internal.m_shapeBuffer.m_storage;
    v260.m_internal.m_shapeBuffer.m_bufferSize = 2048;
    v260.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rsp+0FE8h+var_EE8.m_transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rsp+0FE8h+var_EE8.m_transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
      vmovups xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_internal.m_scale.m_quad], xmm2
    }
    v260.m_internal.m_shapeTags[0] = -1;
    v260.m_internal.m_shape = NULL;
    v260.m_parentShape = NULL;
    v260.m_shapeTagPath.m_size = 0;
    *(_QWORD *)&v260.m_internal.m_flags.m_storage = 8i64;
    _RBX = v255;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_transform.m_rotation.baseclass_0.m_col0.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rbx+10h]
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_transform.m_rotation.baseclass_0.m_col1.m_quad], xmm1
      vmovups xmm0, xmmword ptr [rbx+20h]
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_transform.m_rotation.baseclass_0.m_col2.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rbx+30h]
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_transform.m_translation.m_quad], xmm1
      vmovups xmmword ptr [rsp+0FE8h+var_EE8.m_internal.m_scale.m_quad], xmm2
      vmovss  xmm0, cs:__real@34000000
      vmovss  [rsp+0FE8h+zero], xmm0
    }
    if ( hkMatrix3Impl<float>::isApproximatelyEqual(v255, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], zero) )
    {
      v124 = v260.m_internal.m_flags.m_storage | 4;
      v260.m_internal.m_flags.m_storage |= 4u;
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx+30h]
        vsubps  xmm2, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
        vmovups xmm1, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
        vandnps xmm3, xmm1, xmm2
        vcmpleps xmm4, xmm3, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
        vxorps  xmm2, xmm2, xmm2
        vpxor   xmm0, xmm0, xmm0
        vpcmpeqd xmm1, xmm0, xmm0
        vblendps xmm2, xmm2, xmm1, 7
        vpand   xmm0, xmm4, xmm2
        vptest  xmm0, xmm2
      }
      if ( _CF )
        v260.m_internal.m_flags.m_storage = v124 | 1;
    }
    v260.m_internal.m_shapeTags[0] = -1;
    if ( contents == -1 )
    {
      __asm { vmovss  xmm1, dword ptr [rdi] }
    }
    else
    {
      (*(void (__fastcall **)(unsigned __int64, unsigned int *, __int64, hknpShapeCollector *))(*(_QWORD *)_RBX[2].m_col0.m_quad.m128_u64[0] + 176i64))(_RBX[2].m_col0.m_quad.m128_u64[0], &contents, 1i64, &v260);
      if ( (v260.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v260, 0, (hknpTriangleShape *)&v261);
      else
        TriangleShape = (const hknpTriangleShape *)v260.m_internal.m_shape;
      *(_QWORD *)zero = TriangleShape;
      Com_sprintf<256>((char (*)[256])dest, "Sub-Shape Path:");
      __asm
      {
        vmovss  [rsp+0FE8h+var_FB0], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [rdi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v229, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm1
      }
      v141 = 0;
      if ( v260.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v260.m_shapeTagPath.m_data[0].m_shape;
        do
        {
          Com_sprintf<256>((char (*)[256])dest, "Entry %i:", (unsigned int)v141);
          __asm
          {
            vmovss  [rsp+0FE8h+var_FB0], xmm6
            vmovss  xmm2, dword ptr [rsi]; y
            vmovss  xmm1, dword ptr [rdi]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v230, 0);
          __asm
          {
            vaddss  xmm0, xmm6, dword ptr [rsi]
            vmovss  dword ptr [rsi], xmm0
            vaddss  xmm1, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm1
            vmovss  [rsp+0FE8h+forceColor], xmm6
            vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
          }
          HavokPhysics_DrawPhysicsShape(*p_m_shape, scrPlace, x, y, fmtc, *(float *)&forceColorc);
          __asm
          {
            vmovss  xmm0, dword ptr [rdi]
            vsubss  xmm1, xmm0, xmm7
            vmovss  dword ptr [rdi], xmm1
          }
          ++v141;
          p_m_shape += 4;
        }
        while ( v141 < v260.m_shapeTagPath.m_size );
        LODWORD(v17) = v250;
        DetailHitData = v252;
      }
      __asm
      {
        vsubss  xmm0, xmm1, xmm7
        vmovss  dword ptr [rdi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Leaf-Shape:");
      __asm
      {
        vmovss  [rsp+0FE8h+var_FB0], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [rdi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v231, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm1
        vmovss  [rsp+0FE8h+forceColor], xmm6
        vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
      }
      HavokPhysics_DrawPhysicsShape(*(const hknpShape **)zero, scrPlace, x, y, fmtd, *(float *)&forceColord);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vsubss  xmm1, xmm0, xmm7
      }
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vmovss  dword ptr [rdi], xmm0
      vmovss  [rsp+0FE8h+forceColor], xmm6
      vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlace, x, y, fmte, *(float *)&forceColore);
    __asm
    {
      vmovss  [rsp+0FE8h+forceColor], xmm6
      vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsSurfaceFlags(surfFlags, scrPlace, x, y, fmtf, *(float *)&forceColorf);
    if ( (_WORD)v244 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Glass ID:%i", (unsigned __int16)v244);
      __asm
      {
        vmovss  [rsp+0FE8h+var_FB0], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [rdi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v232, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
    }
    v159 = "Not Brush based";
    if ( BrushBasisFromUserData )
      v159 = "Brush based";
    Com_sprintf<256>((char (*)[256])dest, v159);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v233, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    v163 = "Base";
    if ( DecalTypeFromUserData )
      v163 = "Decal";
    Com_sprintf<256>((char (*)[256])dest, v163);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v234, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    v167 = (unsigned __int16)numInOut;
    Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", (unsigned __int16)numInOut);
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v235, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vaddss  xmm1, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm1
      vmovss  [rsp+0FE8h+forceColor], xmm6
      vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsLibraryMaterialId(v167, scrPlace, x, y, fmtg, *(float *)&forceColorg);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vsubss  xmm1, xmm0, xmm7
      vmovss  dword ptr [rdi], xmm1
    }
    if ( DetailHitData && DetailHitData->isValid )
    {
      Com_sprintf<256>((char (*)[256])dest, "Detail data");
      __asm
      {
        vmovss  [rsp+0FE8h+var_FB0], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [rdi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v236, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm1
      }
      partGroup = DetailHitData->partGroup;
      v179 = SL_ConvertToString(DetailHitData->partName);
      LODWORD(forceColorh) = partGroup;
      Com_sprintf<256>((char (*)[256])dest, "ModelIndex %i, PartName %i %s, PartGroup %i", DetailHitData->modelIndex, (unsigned int)DetailHitData->partName, v179, forceColorh);
      __asm
      {
        vmovss  [rsp+0FE8h+var_FB0], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [rdi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v237, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vmovss  [rsp+0FE8h+forceColor], xmm6
        vmovss  dword ptr [rsp+0FE8h+fmt], xmm7
      }
      HavokPhysics_DrawPhysicsSurfaceFlags(DetailHitData->surfaceflags, scrPlace, x, y, fmth, *(float *)&forceColori);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [rdi], xmm1
      }
    }
    v260.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
    if ( v260.m_internal.m_shapeBuffer.m_shape )
      ((void (__fastcall *)(hknpShape *, _QWORD))v260.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v260.m_internal.m_shapeBuffer.m_shape, 0i64);
    Physics_UnlockWorld((Physics_WorldId)v17);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vsubss  xmm1, xmm0, xmm7
      vmovss  dword ptr [rdi], xmm1
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Hits");
    __asm
    {
      vmovss  [rsp+0FE8h+var_FB0], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rdi]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v238, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    Physics_UnlockWorld((Physics_WorldId)v17);
  }
LABEL_113:
  _R11 = &v263;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
HavokPhysics_DrawDebugShapecast
==============
*/
void HavokPhysics_DrawDebugShapecast(Physics_WorldId worldId, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v20; 
  unsigned __int64 v21; 
  bool v62; 
  int v63; 
  int v69; 
  int v71; 
  __int64 v76; 
  int integer; 
  HavokPhysics_CollisionQueryResult *v91; 
  HavokPhysics_CollisionQueryResult *v92; 
  unsigned int v97; 
  unsigned int m_serialAndIndex; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  unsigned int ClosestPointHitHitSurfFlags; 
  hknpBodyId v108; 
  unsigned int ShapecastHitBodyId; 
  unsigned int m_collisionFilterInfo; 
  int ShapecastHitHitSurfFlags; 
  const hknpCollisionResult *Hit; 
  int Ref; 
  int v192; 
  hkMemoryAllocator *v214; 
  float v215; 
  int v216; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *v217; 
  int v218; 
  __int128 fmt; 
  float fmta; 
  char *fmtb; 
  char *fmtc; 
  char *fmtd; 
  char *fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmt_8b; 
  char *fmt_8; 
  char *fmt_8a; 
  float fmt_8c; 
  float fmt_8d; 
  float fmt_8e; 
  __int64 shadow; 
  __int64 shadowa; 
  int shadowb; 
  float v237; 
  float v238; 
  __int64 v239; 
  float v240; 
  float v241; 
  float v242; 
  float v243; 
  float v244; 
  float v245; 
  float v246; 
  float v247; 
  float v248; 
  float v249; 
  __int64 adjust; 
  __int64 v251; 
  unsigned int numInOut; 
  signed int contentsa; 
  unsigned int contentsb; 
  unsigned int m_value; 
  __m256i v259; 
  __int64 v260; 
  vec3_t start; 
  vec3_t outPos; 
  vec3_t v263; 
  vec3_t pos; 
  __int128 v265; 
  vec3_t center; 
  vec3_t v268; 
  char dest[256]; 
  char text[256]; 
  char v271; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-58h], xmm7
    vmovaps xmmword ptr [r11-68h], xmm8
    vmovaps xmmword ptr [r11-78h], xmm9
    vmovaps xmmword ptr [r11-88h], xmm10
    vmovaps xmmword ptr [r11-98h], xmm11
    vmovaps xmmword ptr [r11-0A8h], xmm12
    vmovaps xmmword ptr [r11-0B8h], xmm13
    vmovaps xmmword ptr [r11-0C8h], xmm14
    vmovaps xmmword ptr [r11-0D8h], xmm15
  }
  _R14 = x;
  *(_QWORD *)v263.v = x;
  v20 = collisionFilterInfo;
  v21 = worldId;
  _RDI = y;
  __asm
  {
    vxorps  xmm12, xmm12, xmm12
    vmovss  dword ptr [rsp+418h+var_3A8+4], xmm12
    vmovss  xmm0, cs:__real@3c83126f
    vmovss  dword ptr [rsp+418h+var_3A8+8], xmm0
    vmovss  dword ptr [r11-390h], xmm12
    vpxor   xmm14, xmm14, xmm14
  }
  LODWORD(v260) = 0;
  BYTE4(v260) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22967, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugShapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RSI = HavokPhysics_GetMutableWorld((Physics_WorldId)v21);
  *(_QWORD *)start.v = _RSI;
  _RAX = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  __asm
  {
    vmovss  xmm6, dword ptr [rax+6944h]
    vmovss  xmm7, dword ptr [rax+6948h]
    vmovss  xmm8, dword ptr [rax+694Ch]
  }
  _RAX = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  __asm
  {
    vmovss  xmm9, dword ptr [rax+6950h]
    vmovss  xmm10, dword ptr [rax+6954h]
    vmovss  xmm11, dword ptr [rax+6958h]
  }
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  __asm
  {
    vmovss  xmm13, cs:__real@43700000
    vmulss  xmm0, xmm13, xmm6
    vaddss  xmm2, xmm0, dword ptr [rsp+418h+outPos]
    vmulss  xmm1, xmm13, xmm7
    vaddss  xmm3, xmm1, dword ptr [rsp+418h+outPos+4]
    vmulss  xmm0, xmm13, xmm8
    vaddss  xmm5, xmm0, dword ptr [rsp+418h+outPos+8]
    vmovss  xmm4, cs:__real@42f00000
    vmulss  xmm1, xmm9, xmm4
    vaddss  xmm8, xmm1, xmm2
    vmovss  dword ptr [rsp+418h+center], xmm8
    vmulss  xmm0, xmm10, xmm4
    vaddss  xmm7, xmm0, xmm3
    vmovss  dword ptr [rsp+418h+center+4], xmm7
    vmulss  xmm0, xmm11, xmm4
    vaddss  xmm5, xmm0, xmm5
    vmovss  dword ptr [rsp+418h+center+8], xmm5
    vmulss  xmm1, xmm9, xmm13
    vsubss  xmm6, xmm8, xmm1
    vmovss  dword ptr [rsp+418h+var_2F8], xmm6
    vmulss  xmm0, xmm10, xmm13
    vsubss  xmm4, xmm7, xmm0
    vmovss  dword ptr [rsp+418h+var_2F8+4], xmm4
    vmulss  xmm1, xmm11, xmm13
    vsubss  xmm3, xmm5, xmm1
    vmovss  dword ptr [rsp+418h+var_2F8+8], xmm3
    vmovss  xmm2, cs:__real@3d000000
    vmulss  xmm0, xmm8, xmm2
    vmovss  dword ptr [rsp+418h+var_328], xmm0
    vmulss  xmm1, xmm7, xmm2
    vmovss  dword ptr [rsp+418h+var_328+4], xmm1
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rsp+418h+var_328+8], xmm0
    vmovss  dword ptr [rsp+418h+var_328+0Ch], xmm12
    vmulss  xmm1, xmm6, xmm2
    vmovss  dword ptr [rsp+418h+var_318], xmm1
    vmulss  xmm0, xmm4, xmm2
    vmovss  dword ptr [rsp+418h+var_318+4], xmm0
    vmulss  xmm1, xmm3, xmm2
    vmovss  dword ptr [rsp+418h+var_318+8], xmm1
    vmovss  dword ptr [rsp+418h+var_318+0Ch], xmm12
  }
  if ( dword_150D5FA58 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA58);
    if ( dword_150D5FA58 == -1 )
    {
      outPos.v[0] = 0.0;
      v214 = hkMemHeapAllocator();
      v215 = outPos.v[0];
      v216 = LODWORD(outPos.v[0]);
      if ( LODWORD(outPos.v[0]) )
      {
        v217 = (HavokPhysics_IgnoreBodies::IgnoreEntity *)hkMemoryAllocator::bufAlloc2(v214, 8, (int *)&outPos);
        v215 = outPos.v[0];
      }
      else
      {
        v217 = NULL;
      }
      v218 = 0x80000000;
      if ( v215 != 0.0 )
        v218 = LODWORD(v215);
      ignoreBodies_2.m_ignoreEntities.m_data = v217;
      ignoreBodies_2.m_ignoreEntities.m_size = v216;
      ignoreBodies_2.m_ignoreEntities.m_capacityAndFlags = v218;
      ignoreBodies_2.m_ignoreBodies.m_data = NULL;
      ignoreBodies_2.m_ignoreBodies.m_size = 0;
      ignoreBodies_2.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      hkMemHeapAllocator();
      ignoreBodies_2.m_ignoreBodies.m_data = NULL;
      ignoreBodies_2.m_ignoreBodies.m_size = 0;
      ignoreBodies_2.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_2.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_2.m_isClutter = 0;
      ignoreBodies_2.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugShapecast_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA58);
      v20 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v62 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_2.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v62) )
    ignoreBodies_2.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v259.m256i_i32[0] = v20;
  v259.m256i_i8[12] = 1;
  v259.m256i_i64[2] = (__int64)&ignoreBodies_2;
  v63 = s_havokPhysicsWorldShapeCastActiveIndices[v21];
  if ( v63 == -1 )
  {
    if ( _RSI->requestDebugShapecast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23001, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugShapecast)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugShapecast") )
      __debugbreak();
    s_havokPhysicsWorldShapeCastActiveIndices[v21] = 0;
    __asm
    {
      vmovups xmm0, [rsp+418h+var_328]
      vmovups xmmword ptr [rsi+0D60h], xmm0
      vmovups xmm1, [rsp+418h+var_318]
      vmovups xmmword ptr [rsi+0D70h], xmm1
      vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rsi+0D80h], xmm0
      vmovups ymm1, ymmword ptr [rsp+418h+var_3A8]
      vmovups ymmword ptr [rsi+0D90h], ymm1
      vmovups xmmword ptr [rsi+0DB0h], xmm14
      vmovsd  xmm0, [rsp+418h+var_378]
      vmovsd  qword ptr [rsi+0DC0h], xmm0
    }
    _RSI->requestDebugShapecast = 1;
  }
  else
  {
    v69 = s_havokPhysicsWorldShapeCastActiveIndices[v21];
    __asm { vmovups xmm11, [rsp+418h+var_328] }
    if ( !_RSI->requestDebugShapecast )
    {
      v71 = 2 * v21;
      if ( s_havokPhysicsWorldShapeCastData[2 * (int)v21 + v63].isComplete )
      {
        s_havokPhysicsWorldShapeCastActiveIndices[v21] = 1 - v63;
        HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldShapeCastData[v71 + 1 - v63].result, 1);
        HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldShapeCastData[v71 + s_havokPhysicsWorldShapeCastActiveIndices[v21]].startResult, 1);
        __asm
        {
          vmovups xmmword ptr [rsi+0D60h], xmm11
          vmovups xmm0, [rsp+418h+var_318]
          vmovups xmmword ptr [rsi+0D70h], xmm0
          vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
          vmovups xmmword ptr [rsi+0D80h], xmm0
          vmovups ymm1, ymmword ptr [rsp+418h+var_3A8]
          vmovups ymmword ptr [rsi+0D90h], ymm1
          vmovups xmmword ptr [rsi+0DB0h], xmm14
          vmovsd  xmm0, [rsp+418h+var_378]
          vmovsd  qword ptr [rsi+0DC0h], xmm0
        }
        _RSI->requestDebugShapecast = 1;
        v69 = s_havokPhysicsWorldShapeCastActiveIndices[v21];
      }
    }
    if ( v69 != -1 )
    {
      v76 = 3i64 * (2 * (int)v21 - v69) + 3;
      if ( *(&s_havokPhysicsWorldShapeCastData[0].isComplete + 8 * v76) )
      {
        integer = physics_debugQueryBody->current.integer;
        if ( integer < 0 )
          integer = 0xFFFFFF;
        if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *))_RSI->world->isBodyValid)(&_RSI->world->hknpWorldReader) )
        {
          __asm
          {
            vmovsd  xmm2, cs:__real@4028000000000000
            vmovaps xmm3, xmm2
            vmovq   r9, xmm3
            vmovq   r8, xmm2
          }
          Com_sprintf<256>((char (*)[256])dest, "ShapeCast of a sphere of radius %.2f with start tolerance of %.2f", *(double *)&_XMM2, *(double *)&_XMM3);
        }
        else
        {
          __asm
          {
            vmovaps xmm0, cs:__xmm@40280000000000004028000000000000
            vmovups xmmword ptr [rsp+418h+fmt], xmm0
          }
          Com_sprintf<256>((char (*)[256])dest, "ShapeCast for Body %i %s of a sphere of radius %.2f with start tolerance of %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)_RSI->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), *(double *)&fmt, *((double *)&fmt + 1));
        }
        __asm
        {
          vmovss  xmm7, [rsp+418h+charHeight]
          vmovss  [rsp+418h+var_3E0], xmm7
          vmovss  xmm2, dword ptr [rdi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v237, 0);
        __asm
        {
          vaddss  xmm0, xmm7, dword ptr [rdi]
          vmovss  dword ptr [rdi], xmm0
          vmovss  xmm8, [rsp+418h+tabWidth]
          vaddss  xmm0, xmm8, dword ptr [r14]
          vmovss  dword ptr [r14], xmm0
          vmovss  dword ptr [rsp+418h+fmt+8], xmm7
          vmovss  dword ptr [rsp+418h+fmt], xmm8
        }
        HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, _R14, y, fmta, fmt_8b);
        __asm
        {
          vmovss  xmm0, dword ptr [r14]
          vsubss  xmm1, xmm0, xmm8
          vmovss  dword ptr [r14], xmm1
        }
        v91 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldShapeCastData[0].result + v76);
        *(_QWORD *)outPos.v = v91;
        v92 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldShapeCastData[0].startResult + v76);
        contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v92);
        Com_sprintf<256>((char (*)[256])dest, "Start Results - %i hits", (unsigned int)contentsa);
        __asm
        {
          vmovss  [rsp+418h+var_3E0], xmm7
          vmovss  xmm2, dword ptr [rdi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v238, 0);
        __asm
        {
          vaddss  xmm0, xmm7, dword ptr [rdi]
          vmovss  dword ptr [rdi], xmm0
          vaddss  xmm1, xmm8, dword ptr [r14]
          vmovss  dword ptr [r14], xmm1
        }
        v97 = 0;
        __asm { vmovss  xmm10, cs:__real@40a00000 }
        if ( contentsa > 0 )
        {
          __asm { vmovss  xmm9, cs:__real@3f800000 }
          do
          {
            if ( v97 >= HavokPhysics_CollisionQueryResult::GetNumHits(v92) )
            {
              LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v92);
              LODWORD(fmt_8) = v97;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8, shadow) )
                __debugbreak();
            }
            m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetHit(v92, v97)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
            numInOut = m_serialAndIndex;
            if ( Physics_IsRigidBodyValid((Physics_WorldId)v21, m_serialAndIndex) )
            {
              v21 = (unsigned __int64)_RSI->world->m_bodyManager.m_bodyNames.m_data[m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64;
              HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v92, v97, &pos);
              HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v92, v97, (vec3_t *)&v265);
              *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v92, v97);
              __asm { vmovaps xmm6, xmm0 }
              ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v92, v97);
              ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v92, v97);
              ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v92, v97);
              ClosestPointHitHitSurfFlags = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v92, v97);
              v108.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v92, v97);
              LODWORD(v251) = HavokPhysics_GetRef(v92->m_worldId, v108);
              LODWORD(adjust) = ClosestPointHitHitSurfFlags;
              LODWORD(v239) = ClosestPointHitHitContents;
              LODWORD(shadow) = ClosestPointHitHitMaterialId;
              LODWORD(fmt_8) = ClosestPointHitHitShapeKey;
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v97, numInOut, (const char *)v21, fmt_8, shadow, v239, adjust, v251);
              __asm { vmovss  [rsp+418h+var_3E0], xmm7 }
              _RDI = y;
              __asm { vmovss  xmm2, dword ptr [rdi]; y }
              _R14 = *(float **)v263.v;
              __asm { vmovss  xmm1, dword ptr [r14]; x }
              Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v241, 0);
              __asm
              {
                vaddss  xmm0, xmm7, dword ptr [rdi]
                vmovss  dword ptr [rdi], xmm0
                vmovaps xmm1, xmm10; radius
              }
              CG_DebugSphere(&pos, *(float *)&_XMM1, &colorRed, 0, 0);
              CG_DebugLine(&pos, (const vec3_t *)&v265, &colorRed, 0, 0);
              __asm
              {
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+418h+fmt], xmm0
              }
              Com_sprintf(text, 0x100ui64, "%s %.2f", (const char *)v21, *(double *)&fmtb);
              __asm { vmovaps xmm2, xmm9; scale }
              CL_AddDebugString(&pos, &colorRed, *(float *)&_XMM2, text, 0, 0);
              _RSI = *(HavokPhysicsWorld **)start.v;
              LODWORD(v21) = worldId;
            }
            else
            {
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v97, m_serialAndIndex);
              __asm
              {
                vmovss  [rsp+418h+var_3E0], xmm7
                vmovss  xmm2, dword ptr [rdi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v240, 0);
              __asm
              {
                vaddss  xmm0, xmm7, dword ptr [rdi]
                vmovss  dword ptr [rdi], xmm0
              }
            }
            ++v97;
          }
          while ( (int)v97 < contentsa );
          __asm { vmovss  xmm1, dword ptr [r14] }
          v91 = *(HavokPhysics_CollisionQueryResult **)outPos.v;
        }
        __asm
        {
          vsubss  xmm0, xmm1, xmm8
          vmovss  dword ptr [r14], xmm0
          vmovss  xmm10, cs:__real@41400000
          vmovaps xmm1, xmm10; radius
        }
        CG_DebugSphere(&center, *(float *)&_XMM1, &colorGreen, 0, 0);
        __asm { vmovaps xmm1, xmm10; radius }
        CG_DebugSphere(&v268, *(float *)&_XMM1, &colorRed, 0, 0);
        Com_sprintf<256>((char (*)[256])dest, "Result");
        __asm
        {
          vmovss  [rsp+418h+var_3E0], xmm7
          vmovss  xmm2, dword ptr [rdi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v242, 0);
        __asm
        {
          vaddss  xmm0, xmm7, dword ptr [rdi]
          vmovss  dword ptr [rdi], xmm0
          vaddss  xmm1, xmm8, dword ptr [r14]
          vmovss  dword ptr [r14], xmm1
        }
        if ( HavokPhysics_CollisionQueryResult::HasHit(v91) && (ShapecastHitBodyId = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(v91, 0), Physics_IsRigidBodyValid((Physics_WorldId)v21, ShapecastHitBodyId)) )
        {
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1274, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          HavokPhysics_CollisionQueryResult::GetHit(v91, 0);
          __asm
          {
            vmovss  xmm6, cs:__real@42000000
            vmulss  xmm0, xmm6, dword ptr [rax]
            vmovss  dword ptr [rsp+418h+start], xmm0
            vmulss  xmm2, xmm6, dword ptr [rax+4]
            vmovss  dword ptr [rsp+418h+start+4], xmm2
            vmulss  xmm1, xmm6, dword ptr [rax+8]
            vmovss  dword ptr [rsp+418h+start+8], xmm1
          }
          if ( !v91->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1281, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
            __debugbreak();
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1282, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          _RAX = HavokPhysics_CollisionQueryResult::GetHit(v91, 0);
          __asm
          {
            vmovss  xmm12, dword ptr [rax+10h]
            vmovss  xmm14, dword ptr [rax+14h]
            vmovss  xmm15, dword ptr [rax+18h]
          }
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1445, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          _RAX = HavokPhysics_CollisionQueryResult::GetHit(v91, 0);
          __asm
          {
            vmovss  xmm9, dword ptr [rax+20h]
            vmulss  xmm13, xmm9, xmm13
            vmovups xmm0, [rsp+418h+var_318]
            vsubps  xmm1, xmm0, xmm11
            vmovaps xmm0, xmm9
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm1, xmm0
            vaddps  xmm2, xmm0, xmm11
            vmulss  xmm0, xmm2, xmm6
            vmovss  dword ptr [rsp+418h+var_348], xmm0
            vshufps xmm1, xmm2, xmm2, 55h ; 'U'
            vmulss  xmm0, xmm1, xmm6
            vmovss  dword ptr [rsp+418h+var_348+4], xmm0
            vshufps xmm2, xmm2, xmm2, 0AAh ; ''
            vmulss  xmm0, xmm2, xmm6
            vmovss  dword ptr [rsp+418h+var_348+8], xmm0
          }
          contentsb = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(v91, 0);
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1459, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          m_value = HavokPhysics_CollisionQueryResult::GetHit(v91, 0)->m_hitBodyInfo.m_shapeKey.m_value;
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1473, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          LOWORD(outPos.v[0]) = HavokPhysics_CollisionQueryResult::GetHit(v91, 0)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1487, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v91, 0)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
          ShapecastHitHitSurfFlags = HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(v91, 0);
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v91) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v91);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1452, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          Hit = HavokPhysics_CollisionQueryResult::GetHit(v91, 0);
          Ref = HavokPhysics_GetRef(v91->m_worldId, Hit->m_hitBodyInfo.m_bodyId);
          __asm { vmovaps xmm1, xmm10; radius }
          CG_DebugSphere(&v263, *(float *)&_XMM1, &colorYellow, 0, 0);
          __asm { vmovss  xmm1, cs:__real@40a00000; radius }
          CG_DebugSphere(&start, *(float *)&_XMM1, &colorBlue, 0, 0);
          __asm
          {
            vmulss  xmm0, xmm12, xmm10
            vaddss  xmm1, xmm0, dword ptr [rsp+418h+start]
            vmovss  dword ptr [rsp+418h+pos], xmm1
            vmulss  xmm2, xmm14, xmm10
            vaddss  xmm0, xmm2, dword ptr [rsp+418h+start+4]
            vmovss  dword ptr [rsp+418h+pos+4], xmm0
            vmulss  xmm1, xmm15, xmm10
            vaddss  xmm2, xmm1, dword ptr [rsp+418h+start+8]
            vmovss  dword ptr [rsp+418h+pos+8], xmm2
          }
          CG_DebugLine(&start, &pos, &colorBlue, 0, 0);
          __asm
          {
            vcvtss2sd xmm3, xmm13, xmm13
            vcvtss2sd xmm2, xmm9, xmm9
            vmovq   r9, xmm3
            vmovq   r8, xmm2
          }
          Com_sprintf<256>((char (*)[256])dest, "Fraction:%.4f Distance %.2f", *(double *)&_XMM2, *(double *)&_XMM3);
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v243, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
            vmovss  xmm1, dword ptr [rsp+418h+start+8]
            vcvtss2sd xmm1, xmm1, xmm1
            vmovss  xmm3, dword ptr [rsp+418h+start+4]
            vcvtss2sd xmm3, xmm3, xmm3
            vmovss  xmm2, dword ptr [rsp+418h+start]
            vcvtss2sd xmm2, xmm2, xmm2
            vmovsd  [rsp+418h+fmt], xmm1
            vmovq   r9, xmm3
            vmovq   r8, xmm2
          }
          Com_sprintf<256>((char (*)[256])dest, "Hit Position:  %.4f %.4f %.4f ", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtc);
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v244, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
            vmovss  xmm1, dword ptr [rsp+418h+var_348+8]
            vcvtss2sd xmm1, xmm1, xmm1
            vmovss  xmm3, dword ptr [rsp+418h+var_348+4]
            vcvtss2sd xmm3, xmm3, xmm3
            vmovss  xmm2, dword ptr [rsp+418h+var_348]
            vcvtss2sd xmm2, xmm2, xmm2
            vmovsd  [rsp+418h+fmt], xmm1
            vmovq   r9, xmm3
            vmovq   r8, xmm2
          }
          Com_sprintf<256>((char (*)[256])dest, "Shape Position:%.4f %.4f %.4f ", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtd);
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v245, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
          }
          LODWORD(fmte) = Ref;
          Com_sprintf<256>((char (*)[256])dest, "Body Id:%i ShapeKey %x Ref %x", contentsb, m_value, fmte);
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v246, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
            vaddss  xmm1, xmm8, dword ptr [r14]
            vmovss  dword ptr [r14], xmm1
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  dword ptr [rsp+418h+shadow], xmm8
          }
          HavokPhysics_DrawPhysicsBody((Physics_WorldId)v21, (hknpBodyId)contentsb, 0, scrPlace, _R14, _RDI, *(float *)&shadowb, v247);
          __asm
          {
            vmovss  xmm0, dword ptr [r14]
            vsubss  xmm1, xmm0, xmm8
            vmovss  dword ptr [r14], xmm1
            vmovss  dword ptr [rsp+418h+fmt+8], xmm7
            vmovss  dword ptr [rsp+418h+fmt], xmm8
          }
          HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlace, _R14, _RDI, fmtf, fmt_8c);
          __asm
          {
            vmovss  dword ptr [rsp+418h+fmt+8], xmm7
            vmovss  dword ptr [rsp+418h+fmt], xmm8
          }
          HavokPhysics_DrawPhysicsSurfaceFlags(ShapecastHitHitSurfFlags, scrPlace, _R14, _RDI, fmtg, fmt_8d);
          v192 = LOWORD(outPos.v[0]);
          Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", LOWORD(outPos.v[0]));
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v248, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
            vaddss  xmm1, xmm8, dword ptr [r14]
            vmovss  dword ptr [r14], xmm1
            vmovss  dword ptr [rsp+418h+fmt+8], xmm7
            vmovss  dword ptr [rsp+418h+fmt], xmm8
          }
          HavokPhysics_DrawPhysicsLibraryMaterialId(v192, scrPlace, _R14, _RDI, fmth, fmt_8e);
          __asm
          {
            vmovss  xmm0, dword ptr [r14]
            vsubss  xmm1, xmm0, xmm8
            vsubss  xmm2, xmm1, xmm8
            vmovss  dword ptr [r14], xmm2
          }
        }
        else
        {
          Com_sprintf<256>((char (*)[256])dest, "No Hits");
          __asm
          {
            vmovss  [rsp+418h+var_3E0], xmm7
            vmovss  xmm2, dword ptr [rdi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v249, 0);
          __asm
          {
            vaddss  xmm0, xmm7, dword ptr [rdi]
            vmovss  dword ptr [rdi], xmm0
          }
        }
      }
    }
  }
  _R11 = &v271;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
HavokPhysics_DrawDebugWorld
==============
*/
void HavokPhysics_DrawDebugWorld(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v14; 
  __int64 v15; 
  float fmt; 
  __int64 shadow; 
  float v32; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  _R12 = y;
  _R15 = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17414, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RDI = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&_RDI->critSection);
  if ( _RDI->world )
  {
    v14 = 0;
    if ( _RDI->visProcesses.m_size > 0 )
    {
      v15 = 0i64;
      do
      {
        __asm { vmovss  xmm1, dword ptr [rdi+2Ch] }
        ((void (__fastcall *)(hkProcess *))_RDI->visProcesses.m_data[v15]->step)(_RDI->visProcesses.m_data[v15]);
        ++v14;
        ++v15;
      }
      while ( v14 < _RDI->visProcesses.m_size );
    }
    __asm { vmovss  xmm1, dword ptr [rdi+2Ch]; deltaTime }
    HavokPhysicsProcessHandler::step(_RDI->processHandler, *(float *)&_XMM1);
    if ( physics_debugVisualizeWorldCollisionHeatmap->current.enabled )
    {
      Com_sprintf<256>((char (*)[256])dest, "Heatmap entries");
      __asm
      {
        vmovss  xmm7, [rsp+1D8h+charHeight]
        vmovss  [rsp+1D8h+var_1A0], xmm7
        vmovss  xmm2, dword ptr [r12]; y
        vmovss  xmm1, dword ptr [r15]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v32, 0);
      __asm
      {
        vaddss  xmm0, xmm7, dword ptr [r12]
        vmovss  dword ptr [r12], xmm0
        vmovss  xmm6, [rsp+1D8h+tabWidth]
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
        vmovss  dword ptr [rsp+1D8h+fmt], xmm7
        vmovaps xmm3, xmm6; tabWidth
      }
      HavokPhysicsCollisionHeatmapViewer::debugDraw(scrPlace, _R15, _R12, *(float *)&_XMM3, fmt);
      __asm
      {
        vmovss  xmm0, dword ptr [r15]
        vsubss  xmm1, xmm0, xmm6
        vmovss  dword ptr [r15], xmm1
      }
    }
    if ( !_RDI->displayHandler )
    {
      LODWORD(shadow) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17447, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->displayHandler)", "%s\n\tHavokPhysics: DrawDebugWorld has invalid display handler for world %i", "havokPhysicsWorld->displayHandler", shadow) )
        __debugbreak();
    }
    HavokPhysicsDisplayHandler::step(_RDI->displayHandler);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&_RDI->critSection);
  __asm
  {
    vmovaps xmm6, [rsp+1D8h+var_58]
    vmovaps xmm7, [rsp+1D8h+var_68]
  }
}

/*
==============
HavokPhysics_DrawDebugWorldCPU
==============
*/
void HavokPhysics_DrawDebugWorldCPU(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int stepCPUIndex; 
  char *fmt; 
  float fmta; 
  double forceColor; 
  int forceColora; 
  double shadowa; 
  double v57; 
  float v58; 
  double adjust; 
  double v60; 
  double v61; 
  char dest[256]; 
  char v63; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
  }
  _RSI = y;
  _R14 = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17110, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldMemory with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RBX = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&_RBX->critSection);
  stepCPUIndex = _RBX->stepCPUIndex;
  __asm { vxorps  xmm2, xmm2, xmm2 }
  if ( stepCPUIndex <= 0 )
    __asm { vxorps  xmm10, xmm10, xmm10 }
  else
    __asm { vmovss  xmm10, dword ptr [rbx+0ED8h] }
  if ( stepCPUIndex <= 1 )
    __asm { vxorps  xmm9, xmm9, xmm9 }
  else
    __asm { vmovss  xmm9, dword ptr [rbx+0EDCh] }
  if ( stepCPUIndex <= 2 )
    __asm { vxorps  xmm8, xmm8, xmm8 }
  else
    __asm { vmovss  xmm8, dword ptr [rbx+0EE0h] }
  if ( stepCPUIndex <= 3 )
    __asm { vxorps  xmm7, xmm7, xmm7 }
  else
    __asm { vmovss  xmm7, dword ptr [rbx+0EE4h] }
  if ( stepCPUIndex <= 4 )
    __asm { vxorps  xmm3, xmm3, xmm3 }
  else
    __asm { vmovss  xmm3, dword ptr [rbx+0EE8h] }
  if ( stepCPUIndex > 5 )
    __asm { vmovss  xmm2, dword ptr [rbx+0EECh] }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0EFCh]
    vcvtss2sd xmm0, xmm0, xmm0
    vmovss  xmm1, dword ptr [rbx+0EF4h]
    vcvtss2sd xmm1, xmm1, xmm1
    vmovss  xmm4, dword ptr [rbx+0EF8h]
    vcvtss2sd xmm4, xmm4, xmm4
    vcvtss2sd xmm5, xmm2, xmm2
    vcvtss2sd xmm6, xmm3, xmm3
    vcvtss2sd xmm7, xmm7, xmm7
    vcvtss2sd xmm8, xmm8, xmm8
    vcvtss2sd xmm3, xmm9, xmm9
    vcvtss2sd xmm2, xmm10, xmm10
    vmovsd  [rsp+1F8h+var_1A8], xmm0
    vmovsd  [rsp+1F8h+var_1B0], xmm1
    vmovsd  qword ptr [rsp+1F8h+adjust], xmm4
    vmovsd  [rsp+1F8h+var_1C0], xmm5
    vmovsd  qword ptr [rsp+1F8h+shadow], xmm6
    vmovsd  qword ptr [rsp+1F8h+forceColor], xmm7
    vmovsd  [rsp+1F8h+fmt], xmm8
    vmovq   r9, xmm3
    vmovq   r8, xmm2
  }
  Com_sprintf<256>((char (*)[256])dest, "Step:%5.2f %5.2f %5.2f %5.2f %5.2f %5.2f Frame:%5.2f MaxStep:%5.2f MaxFrame:%5.2f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmt, forceColor, shadowa, v57, adjust, v60, v61);
  __asm
  {
    vmovss  xmm6, [rsp+1F8h+charHeight]
    vmovss  dword ptr [rsp+1F8h+var_1C0], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v58, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  if ( g_havokPhysicsThreadPool )
  {
    __asm
    {
      vmovss  [rsp+1F8h+forceColor], xmm6
      vmovss  xmm0, [rsp+1F8h+tabWidth]
      vmovss  dword ptr [rsp+1F8h+fmt], xmm0
    }
    HavokPhysicsThreadPool::DrawDebug(g_havokPhysicsThreadPool, scrPlace, _R14, _RSI, fmta, *(float *)&forceColora);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&_RBX->critSection);
  _R11 = &v63;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
HavokPhysics_DrawDebugWorldMemory
==============
*/
void HavokPhysics_DrawDebugWorldMemory(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  float v18; 
  char v19[32]; 
  char v20[32]; 
  char buffer[32]; 
  char dest[256]; 

  __asm { vmovaps [rsp+208h+var_38], xmm6 }
  _RSI = y;
  _R14 = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17061, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldMemory with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  Physics_DebugIntToString(buffer, 32, MutableWorld->persistentMemoryStats.m_allocatorStats.m_inUse);
  Physics_DebugIntToString(v20, 32, MutableWorld->persistentMemoryStats.m_allocatorStats.m_peakInUse);
  Physics_DebugIntToString(v19, 32, MutableWorld->persistentMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Persistent: Current:%10s Max:%10s Capacity:%10s", buffer, v20, v19);
  __asm
  {
    vmovss  xmm6, [rsp+208h+charHeight]
    vmovss  [rsp+208h+var_1D0], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v18, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  __asm { vmovaps xmm6, [rsp+208h+var_38] }
}

/*
==============
HavokPhysics_DrawDebugWorldTimestep
==============
*/
void HavokPhysics_DrawDebugWorldTimestep(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool drawFrame)
{
  __int64 v15; 
  HavokPhysicsWorld *MutableWorld; 
  const vec4_t *color; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float yMin; 
  float yMina; 
  float yMinb; 
  float yMinc; 
  float yMaxa; 
  float yMaxb; 
  float yMaxc; 
  float yMaxd; 
  char v55; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  _RSI = y;
  _RBP = x;
  v15 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldTimestep with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v15);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  color = &s_havokPhysicsDebugWorldColors[v15];
  __asm
  {
    vmovss  xmm6, cs:__real@42c80000
    vaddss  xmm2, xmm6, dword ptr [rsi]; y
    vmovss  xmm7, cs:__real@3d4ccccd
    vmovss  [rsp+0C8h+yMax], xmm7
    vxorps  xmm8, xmm8, xmm8
    vmovss  [rsp+0C8h+yMin], xmm8
    vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    vmovss  xmm9, cs:__real@43480000
    vmovaps xmm3, xmm9; width
    vmovss  xmm1, dword ptr [rbp+0]; x
  }
  Physics_DebugDrawGraphLine(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, yMin, yMaxa, MutableWorld->timeStepDebugHistoryRaw, 300, MutableWorld->timeStepDebugHistoryStart, color);
  __asm
  {
    vaddss  xmm2, xmm6, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rbp+0]
    vaddss  xmm1, xmm1, cs:__real@43520000; x
    vmovss  [rsp+0C8h+yMax], xmm7
    vmovss  [rsp+0C8h+yMin], xmm8
    vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    vmovaps xmm3, xmm9; width
  }
  Physics_DebugDrawGraphLine(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmta, yMina, yMaxb, MutableWorld->timeStepDebugHistoryUsed, 300, MutableWorld->timeStepDebugHistoryStart, color);
  if ( drawFrame )
  {
    __asm
    {
      vaddss  xmm2, xmm6, dword ptr [rsi]; y
      vmovss  [rsp+0C8h+yMax], xmm7
      vmovss  [rsp+0C8h+yMin], xmm8
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
      vmovaps xmm3, xmm9; width
      vmovss  xmm1, dword ptr [rbp+0]; x
    }
    Physics_DebugDrawGraphAxes(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtb, yMinb, yMaxc);
    __asm
    {
      vaddss  xmm2, xmm6, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [rbp+0]
      vaddss  xmm1, xmm1, cs:__real@43520000; x
      vmovss  [rsp+0C8h+yMax], xmm7
      vmovss  [rsp+0C8h+yMin], xmm8
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
      vmovaps xmm3, xmm9; width
    }
    Physics_DebugDrawGraphAxes(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtc, yMinc, yMaxd);
    __asm
    {
      vaddss  xmm1, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm1
    }
  }
  _R11 = &v55;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_DrawPhysicsAssetId
==============
*/
void HavokPhysics_DrawPhysicsAssetId(bool sortByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v14; 
  __int64 v15; 
  bool v16; 
  int v18; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v19; 
  __int64 m_hashMod; 
  __int64 v21; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  hkMemoryAllocator *v24; 
  int v25; 
  __int64 v26; 
  __int64 v27; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v28; 
  hkBool *(__fastcall *v33)(hkBool *, const PhysicsAsset *, const PhysicsAsset *); 
  const PhysicsAsset *v34; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v41; 
  __int64 m_size; 
  unsigned int v47; 
  __int64 v50; 
  __int64 v51; 
  const char *v52; 
  unsigned __int16 m_value; 
  unsigned __int8 v70; 
  const char *v71; 
  unsigned __int16 v72; 
  HavokPhysicsMotionPropertiesList *list; 
  const char *v74; 
  __int64 v78; 
  unsigned __int64 m_userData_high; 
  char v113; 
  hkRefCountedProperties *m_ptr; 
  hkReferencedObject *v115; 
  __int64 v124; 
  int m_storage; 
  const char *v180; 
  const char *v184; 
  int v188; 
  int v189; 
  int v193; 
  __int64 v199; 
  char *v204; 
  const char *v207; 
  const char *v208; 
  unsigned int v209; 
  bool v210; 
  __int64 v211; 
  const char *v212; 
  __int64 v247; 
  __int64 v248; 
  unsigned int v257; 
  unsigned __int8 *v258; 
  unsigned __int8 v268; 
  bool v272; 
  const char *v393; 
  __int64 v395; 
  const char *v406; 
  const char *v432; 
  const char *v443; 
  const char *v449; 
  __int64 v457; 
  const char *v478; 
  const char *v500; 
  const char *v510; 
  const char *v518; 
  const char *v528; 
  unsigned __int8 *v534; 
  const char *v536; 
  __int64 v576; 
  __int64 v580; 
  __int64 v584; 
  const char *v626; 
  const char *v635; 
  const char *v845; 
  char v848; 
  hkMemoryAllocator *v871; 
  float fmta; 
  char *fmt; 
  char *fmtb; 
  char *fmtc; 
  char *fmtd; 
  char *fmte; 
  char *fmtf; 
  char *fmtg; 
  char *fmth; 
  char *fmti; 
  char *fmtj; 
  char *fmtk; 
  char *fmtl; 
  char *fmtm; 
  char *fmtn; 
  char *fmto; 
  char *fmtp; 
  char *fmtq; 
  char *fmtr; 
  char *fmts; 
  char *fmtt; 
  char *fmtu; 
  char *fmtv; 
  char *fmtw; 
  char *fmtx; 
  char *fmty; 
  char *fmtz; 
  char *fmtba; 
  char *fmtbb; 
  int forceColor; 
  double forceColora; 
  double forceColorb; 
  double forceColorc; 
  double forceColord; 
  double forceColore; 
  double forceColorf; 
  double forceColorg; 
  double forceColorh; 
  double forceColori; 
  double forceColorj; 
  double forceColork; 
  double forceColorl; 
  __int64 shadow; 
  float v921; 
  float v922; 
  float v923; 
  float v924; 
  float v925; 
  float v926; 
  float v927; 
  float v928; 
  float v929; 
  float v930; 
  float v931; 
  float v932; 
  float v933; 
  float v934; 
  float v935; 
  float v936; 
  float v937; 
  float v938; 
  float v939; 
  float v940; 
  float v941; 
  float v942; 
  float v943; 
  float v944; 
  float v945; 
  float v946; 
  float v947; 
  float v948; 
  float v949; 
  float v950; 
  float v951; 
  float v952; 
  float v953; 
  float v954; 
  float v955; 
  float v956; 
  float v957; 
  float v958; 
  float v959; 
  float v960; 
  float v961; 
  float v962; 
  float v963; 
  float v964; 
  float v965; 
  float v966; 
  float v967; 
  float v968; 
  float v969; 
  float v970; 
  float v971; 
  float v972; 
  float v973; 
  float v974; 
  float v975; 
  float v976; 
  float v977; 
  float v978; 
  float v979; 
  float v980; 
  float v981; 
  float v982; 
  float v983; 
  float v984; 
  float v985; 
  float v986; 
  float v987; 
  float v988; 
  float v989; 
  float v990; 
  float v991; 
  float v992; 
  float v993; 
  float v994; 
  float v995; 
  float v996; 
  float v997; 
  float v998; 
  float v999; 
  float v1000; 
  float v1001; 
  float v1002; 
  float v1003; 
  float v1004; 
  float v1005; 
  float v1006; 
  float v1007; 
  float v1008; 
  float v1009; 
  float v1010; 
  float v1011; 
  float v1012; 
  float v1013; 
  float v1014; 
  float v1015; 
  float v1016; 
  float v1017; 
  float v1018; 
  float v1019; 
  float v1020; 
  float v1021; 
  float v1022; 
  float v1023; 
  float v1024; 
  float v1025; 
  float v1026; 
  float v1027; 
  float v1028; 
  float v1029; 
  float v1030; 
  float v1031; 
  float v1032; 
  float v1033; 
  float v1034; 
  float v1035; 
  float v1036; 
  float v1037; 
  float v1038; 
  float v1039; 
  float v1040; 
  float v1041; 
  float v1042; 
  float v1043; 
  float v1044; 
  float v1045; 
  float v1046; 
  float v1047; 
  float v1048; 
  float v1049; 
  float v1050; 
  int v1052; 
  unsigned int v1053; 
  int v1054; 
  int v1055; 
  unsigned int v1057; 
  char *v1058; 
  PhysicsAsset **array; 
  int v1060; 
  int v1061; 
  int v1062; 
  const char *v1063; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  const ScreenPlacement *v1065; 
  const HavokPhysicsAsset *v1066; 
  __int64 v1067; 
  hkDiagonalizedMassProperties props; 
  char dest[256]; 
  char v1070; 
  void *retaddr; 

  _RAX = &retaddr;
  v1067 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  _R14 = x;
  v14 = scrPlace;
  v1065 = scrPlace;
  v15 = assetId;
  v16 = sortByName;
  _RSI = y;
  array = NULL;
  v1060 = 0;
  v1061 = 0x80000000;
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v18 = 0;
  v19 = s_havokPhysicsAssets;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    v21 = 0i64;
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v18;
      ++v21;
      ++m_elem;
    }
    while ( v21 <= m_hashMod );
  }
  if ( v18 <= (int)m_hashMod )
  {
    do
    {
      key = v19->m_map.m_elem[v18].key;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18340, ASSERT_TYPE_ASSERT, "(physAsset)", (const char *)&queryFormat, "physAsset") )
        __debugbreak();
      v24 = hkMemHeapAllocator();
      v25 = v1060;
      if ( v1060 == (v1061 & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v24, &array, 8);
        v25 = v1060;
      }
      array[v25] = (PhysicsAsset *)key;
      ++v1060;
      ++v18;
      v19 = s_havokPhysicsAssets;
      v26 = s_havokPhysicsAssets->m_map.m_hashMod;
      if ( v18 > (int)v26 )
        break;
      v27 = v18;
      v28 = &s_havokPhysicsAssets->m_map.m_elem[v18];
      do
      {
        if ( v28->key != -1i64 )
          break;
        ++v18;
        ++v27;
        ++v28;
      }
      while ( v27 <= v26 );
    }
    while ( v18 <= (int)v26 );
    v14 = v1065;
    v16 = sortByName;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  Com_sprintf<256>((char (*)[256])dest, "%i Assets found", (unsigned int)v1060);
  __asm
  {
    vmovss  xmm6, [rbp+180h+charHeight]
    vmovss  [rsp+280h+var_248], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v921, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  if ( (int)v15 < 0 || (int)v15 >= v1060 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i is invalid index", (unsigned int)v15);
    __asm
    {
      vmovss  [rsp+280h+var_248], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1050, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    goto LABEL_229;
  }
  if ( v16 )
  {
    if ( v1060 > 1 )
    {
      v33 = HavokPhysics_PhysicsAssetSortByName;
LABEL_24:
      hkAlgorithm::quickSortRecursive<PhysicsAsset *,hkBool (*)(PhysicsAsset const *,PhysicsAsset const *)>(array, 0, v1060 - 1, v33);
    }
  }
  else if ( v1060 > 1 )
  {
    v33 = HavokPhysics_PhysicsAssetSortByMemory;
    goto LABEL_24;
  }
  v34 = array[v15];
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(v34);
  v1066 = HavokPhysicsAsset;
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  Com_sprintf<256>((char (*)[256])dest, "Asset %s - %zu bytes", v34->name, v34->havokDataSize + 88i64);
  __asm
  {
    vmovss  [rsp+280h+var_248], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v922, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vmovss  xmm7, [rbp+180h+tabWidth]
    vaddss  xmm0, xmm7, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
  }
  v41 = (__int64)m_physicsSystemData;
  m_size = (unsigned int)m_physicsSystemData->m_bodyCinfos.m_size;
  if ( (int)m_size > 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i BodyCinfos", m_size);
    __asm
    {
      vmovss  [rsp+280h+var_248], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v923, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm0, dword ptr [r14]
    }
  }
  __asm
  {
    vaddss  xmm0, xmm0, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  v47 = 0;
  v1054 = 0;
  _RDI = *(hknpPhysicsSystemData::bodyCinfoWithAttachment **)(v41 + 56);
  __asm { vxorps  xmm10, xmm10, xmm10 }
  if ( _RDI != &_RDI[*(int *)(v41 + 64)] )
  {
    v50 = 0i64;
    do
    {
      v51 = v47;
      v52 = "BodyCinfo %i name:%s MUTABLE";
      if ( !HavokPhysicsAsset->m_mutable.m_data[v50] )
        v52 = "BodyCinfo %i name:%s";
      Com_sprintf<256>((char (*)[256])dest, v52, v51, (unsigned __int64)_RDI->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v924, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "SimulationCategory: %s", s_physicsAssetSimulationCategoryNames[HavokPhysicsAsset->m_simulationCategories.m_data[v50]]);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v925, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [r14]
        vmovss  dword ptr [r14], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "Shape:");
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v926, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [r14]
        vmovss  dword ptr [r14], xmm1
        vmovss  [rsp+280h+forceColor], xmm6
        vmovss  dword ptr [rsp+280h+fmt], xmm7
      }
      HavokPhysics_DrawPhysicsShape(_RDI->m_shape.m_ptr, v14, _R14, y, fmta, *(float *)&forceColor);
      __asm
      {
        vmovss  xmm0, dword ptr [r14]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r14], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "Collision Filter Info: %i", _RDI->m_collisionFilterInfo);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v927, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      m_value = _RDI->m_materialId.m_value;
      if ( m_value == 0xFFFF )
        v1057 = -1;
      else
        v1057 = m_value;
      if ( m_value == 0xFFFF )
        v1063 = "Invalid";
      else
        v1063 = (const char *)((unsigned __int64)s_havokPhysicsMaterialLibrary.list->m_materials.m_data[m_value - (unsigned __int64)s_havokPhysicsMaterialLibrary.firstId.m_value].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      v70 = _RDI->m_qualityId.m_value;
      if ( v70 == 0xFF )
        v1062 = -1;
      else
        v1062 = v70;
      if ( v70 == 0xFF )
        v71 = "Invalid";
      else
        v71 = (const char *)((unsigned __int64)s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data[v70 - 16].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      v72 = _RDI->m_motionPropertiesId.m_value;
      if ( v72 == 0xFFFF )
        v1052 = -1;
      else
        v1052 = v72;
      if ( v72 == 0xFFFF )
      {
        v74 = "Invalid";
      }
      else
      {
        list = s_havokPhysicsMotionPropertiesLibrary.list;
        v74 = (const char *)((unsigned __int64)list->m_motionPropertiesNames.m_data[HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(_RDI->m_motionPropertiesId)].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      }
      LODWORD(shadow) = v1052;
      LODWORD(fmt) = v1062;
      Com_sprintf<256>((char (*)[256])dest, "Material: %i %s Quality: %i %s MotionProperties: %i %s", v1057, v1063, fmt, v71, shadow, v74);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v928, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      v78 = _RDI->m_userData & 0x20;
      m_userData_high = HIDWORD(_RDI->m_userData);
      if ( m_userData_high > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)m_userData_high, "unsigned", HIDWORD(_RDI->m_userData)) )
        __debugbreak();
      Com_sprintf<256>((char (*)[256])dest, "UserData: %x %x", (unsigned int)m_userData_high, (unsigned int)v78);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v929, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "MotionType: %s", motionTypeNames[_RDI->m_motionType.m_storage]);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v930, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vmovss  xmm1, dword ptr [rdi+3Ch]
        vcvtss2sd xmm1, xmm1, xmm1
        vmovss  xmm4, dword ptr [rdi+38h]
        vcvtss2sd xmm4, xmm4, xmm4
        vmovss  xmm3, dword ptr [rdi+34h]
        vcvtss2sd xmm3, xmm3, xmm3
        vmovss  xmm2, dword ptr [rdi+30h]
        vcvtss2sd xmm2, xmm2, xmm2
        vmovsd  qword ptr [rsp+280h+forceColor], xmm1
        vmovsd  [rsp+280h+fmt], xmm4
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Position:    (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtb, forceColora);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v931, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vmovss  xmm1, dword ptr [rdi+4Ch]
        vcvtss2sd xmm1, xmm1, xmm1
        vmovss  xmm4, dword ptr [rdi+48h]
        vcvtss2sd xmm4, xmm4, xmm4
        vmovss  xmm3, dword ptr [rdi+44h]
        vcvtss2sd xmm3, xmm3, xmm3
        vmovss  xmm2, dword ptr [rdi+40h]
        vcvtss2sd xmm2, xmm2, xmm2
        vmovsd  qword ptr [rsp+280h+forceColor], xmm1
        vmovsd  [rsp+280h+fmt], xmm4
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Orientation: (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtc, forceColorb);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v932, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vmovss  xmm1, dword ptr [rdi+70h]
        vcomiss xmm1, xmm10
      }
      if ( v113 && _RDI->m_shape.m_ptr )
      {
        m_ptr = _RDI->m_shape.m_ptr->m_properties.m_ptr;
        if ( m_ptr )
        {
          v115 = hkRefCountedProperties::accessProperty(m_ptr, 0xF100u);
          if ( v115 )
            hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v115[1], &props);
        }
        __asm { vmovss  xmm1, [rbp+180h+props.m_mass] }
      }
      __asm
      {
        vcvtss2sd xmm2, xmm1, xmm1
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Mass: %.2f", *(double *)&_XMM2);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v933, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      if ( (_RDI->m_desiredBodyId.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF )
      {
        Com_sprintf<256>((char (*)[256])dest, "DesiredBodyId: %i", _RDI->m_desiredBodyId.m_serialAndIndex);
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v934, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      v124 = _RDI->m_motionId.m_value;
      if ( (_DWORD)v124 != 0x7FFFFFFF )
      {
        Com_sprintf<256>((char (*)[256])dest, "MotionCinfo Id: %i", v124);
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v935, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      Com_sprintf<256>((char (*)[256])dest, "Activation Priority %i", (unsigned int)_RDI->m_activationPriority);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v936, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Flags: %i CollisionControl: %i", (unsigned int)_RDI->m_flags.m_storage, _RDI->m_collisionCntrl.m_storage);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v937, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [r14]
        vmovss  dword ptr [r14], xmm1
      }
      m_storage = _RDI->m_flags.m_storage;
      if ( (m_storage & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_STATIC");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v938, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DYNAMIC");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v939, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_KEYFRAMED");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v940, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ACTIVE");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v941, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_TRIGGER_EVENTS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v942, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_MANIFOLD_EVENTS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v943, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x80u) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONTACT_IMPULSE_EVENTS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v944, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x100) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_COLLIDE");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v945, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x200) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_BUILD_CONTACT_JACOBIANS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v946, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x4000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_NON_RUNTIME");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v947, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x8000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_BREAKABLE");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v948, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        m_storage = _RDI->m_flags.m_storage;
      }
      if ( (m_storage & 0x10000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IW_MOTION_USES_GRAVITY");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v949, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r14]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r14], xmm1
        vmovss  xmm2, dword ptr [rdi+94h]
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Collision Look Ahead: %.3f", *(double *)&_XMM2);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v950, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      HavokPhysicsAsset = v1066;
      v180 = (const char *)((unsigned __int64)v1066->m_bodySFXAssetNames.m_data[v50].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( v180 && *v180 )
      {
        Com_sprintf<256>((char (*)[256])dest, "SFX Asset Name: %s", v180);
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v951, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      v184 = (const char *)((unsigned __int64)HavokPhysicsAsset->m_bodyVFXAssetNames.m_data[v50].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( v184 && *v184 )
      {
        Com_sprintf<256>((char (*)[256])dest, "VFX Asset Name: %s", v184);
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v952, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      v188 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v50];
      if ( v188 )
      {
        v189 = v188 - 1;
        if ( v189 )
        {
          if ( v189 == 1 )
            Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Force Client Dynamic");
          else
            Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Unknown - Error");
        }
        else
        {
          Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Force Server Dynamic");
        }
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Default");
      }
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v953, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      v193 = HavokPhysicsAsset->m_bodyDrivers.m_data[v50];
      if ( v193 )
      {
        if ( v193 == 1 )
          Com_sprintf<256>((char (*)[256])dest, "Body Driver: Animation");
        else
          Com_sprintf<256>((char (*)[256])dest, "Body Driver: Unknown - Error");
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "Body Driver: Fixed Offset");
      }
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v954, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vmovss  xmm1, dword ptr [r14]
        vsubss  xmm0, xmm1, xmm7
        vmovss  dword ptr [r14], xmm0
      }
      v47 = ++v1054;
      ++v50;
      ++_RDI;
      v41 = (__int64)m_physicsSystemData;
    }
    while ( _RDI != &m_physicsSystemData->m_bodyCinfos.m_data[m_physicsSystemData->m_bodyCinfos.m_size] );
  }
  __asm
  {
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [r14], xmm1
  }
  v199 = *(unsigned int *)(v41 + 80);
  if ( (int)v199 > 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i ConstraintCinfos", v199);
    __asm
    {
      vmovss  [rsp+280h+var_248], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v955, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm1, dword ptr [r14]
    }
  }
  __asm
  {
    vaddss  xmm0, xmm1, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  v1053 = 0;
  v204 = *(char **)(v41 + 72);
  v1058 = v204;
  if ( v204 != &v204[40 * *(int *)(v41 + 80)] )
  {
    __asm
    {
      vmovss  xmm8, cs:__real@7f7fffee
      vmovss  xmm9, cs:__real@5f7ffff0
    }
    do
    {
      props.m_centerOfMass.m_quad.m128_i32[3] = 0;
      (*(void (__fastcall **)(_QWORD, hkDiagonalizedMassProperties *))(**(_QWORD **)v204 + 32i64))(*(_QWORD *)v204, &props);
      v207 = (const char *)props.m_centerOfMass.m_quad.m128_u64[0];
      v208 = (const char *)(props.m_centerOfMass.m_quad.m128_u64[0] + props.m_centerOfMass.m_quad.m128_u32[2]);
      v1063 = v208;
      v209 = 0;
      if ( props.m_centerOfMass.m_quad.m128_u64[0] < (unsigned __int64)v208 )
      {
        do
        {
          switch ( *(_WORD *)v207 )
          {
            case 0:
              v207 = (const char *)((unsigned __int64)(v207 + 15) & 0xFFFFFFFFFFFFFFF0ui64);
              break;
            case 2:
              v207 += 144;
              break;
            case 3:
            case 0x1C:
              v207 += 48;
              break;
            case 4:
              v207 += 112;
              break;
            case 5:
            case 6:
            case 9:
            case 0xB:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x12:
              v207 += 32;
              break;
            case 7:
            case 0xA:
            case 0xC:
            case 0xD:
            case 0x11:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
              v207 += 16;
              break;
            case 0x13:
            case 0x19:
            case 0x1A:
              v207 += 96;
              break;
            case 0x14:
              v207 += 64;
              break;
            default:
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18802, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Constraint") )
                __debugbreak();
              break;
          }
          ++v209;
        }
        while ( v207 < v208 );
        v14 = v1065;
        v204 = v1058;
      }
      v210 = (*(int (__fastcall **)(_QWORD))(**(_QWORD **)v204 + 24i64))(*(_QWORD *)v204) < 100;
      v211 = (*(int (**)(void))(**(_QWORD **)v204 + 24i64))();
      if ( v210 )
        v212 = constraintTypeNames[v211];
      else
        v212 = shapeTypeNames_0[v211 + 2];
      Com_sprintf<256>((char (*)[256])dest, "ConstraintCinfo %i type:%s", v1053, v212);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v956, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm0, xmm7, dword ptr [r14]
        vmovss  dword ptr [r14], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Flags %x", *((unsigned __int16 *)v204 + 8));
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v957, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [r14]
        vmovss  dword ptr [r14], xmm1
      }
      if ( (v204[16] & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_EXPORTABLE");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v958, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_IMMEDIATE");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v959, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ADDED");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v960, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DESTRUCTION_INTERNAL");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v961, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "AUTO_REMOVE_ON_DESTRUCTION_RESET");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v962, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 0x20) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "AUTO_REMOVE_ON_DESTRUCTION");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v963, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( (v204[16] & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONSTRAINT_FORCE_EVENTS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v964, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      if ( v204[16] < 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONSTRAINT_FORCE_EXCEEDED_EVENTS");
        __asm
        {
          vmovss  [rsp+280h+var_248], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v965, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r14]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r14], xmm1
      }
      v247 = 0xFFFFFFFFi64;
      if ( (*((_DWORD *)v204 + 3) & 0xFFFFFF) != 0xFFFFFF )
        v247 = *((unsigned int *)v204 + 3);
      v248 = 0xFFFFFFFFi64;
      if ( (*((_DWORD *)v204 + 2) & 0xFFFFFF) != 0xFFFFFF )
        v248 = *((unsigned int *)v204 + 2);
      Com_sprintf<256>((char (*)[256])dest, "Bodies A: %i B: %i", v248, v247);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v966, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Atoms: %i", v209);
      __asm
      {
        vmovss  [rsp+280h+var_248], xmm6
        vmovss  xmm2, dword ptr [rsi]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v967, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
        vaddss  xmm1, xmm7, dword ptr [r14]
        vsubss  xmm0, xmm1, xmm7
        vmovss  dword ptr [r14], xmm0
      }
      v257 = 0;
      v258 = (unsigned __int8 *)props.m_centerOfMass.m_quad.m128_u64[0];
      if ( props.m_centerOfMass.m_quad.m128_u64[0] < (unsigned __int64)v1063 )
      {
        _EDI = 0;
        while ( 2 )
        {
          Com_sprintf<256>((char (*)[256])dest, "Atom: %i %s", v257, atomTypesNames[*(unsigned __int16 *)v258]);
          __asm
          {
            vmovss  [rsp+280h+var_248], xmm6
            vmovss  xmm2, dword ptr [rsi]; y
            vmovss  xmm1, dword ptr [r14]; x
          }
          Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v968, 0);
          __asm
          {
            vaddss  xmm0, xmm6, dword ptr [rsi]
            vmovss  dword ptr [rsi], xmm0
            vaddss  xmm1, xmm7, dword ptr [r14]
            vmovss  dword ptr [r14], xmm1
          }
          switch ( *(_WORD *)v258 )
          {
            case 0:
              v258 = (unsigned __int8 *)((unsigned __int64)(v258 + 15) & 0xFFFFFFFFFFFFFFF0ui64);
              goto LABEL_224;
            case 2:
              _RBX = v258;
              v258 += 144;
              Com_sprintf<256>((char (*)[256])dest, "Transform A");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1028, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+30h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+20h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtn);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1029, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+34h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+24h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+14h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmto);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1030, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+38h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+28h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+18h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtp);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1031, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+4Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+48h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+44h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+40h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtq, forceColorj);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1032, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Transform B");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1033, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+70h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+60h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+50h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtr);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1034, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+74h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+64h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+54h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmts);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1035, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+78h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+68h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+58h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtt);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1036, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+8Ch]
                vmovss  xmm4, dword ptr [rbx+88h]
                vmovss  xmm3, dword ptr [rbx+84h]
                vmovss  xmm2, dword ptr [rbx+80h]
              }
              goto LABEL_210;
            case 3:
              _RBX = v258;
              v258 += 48;
              Com_sprintf<256>((char (*)[256])dest, "Translation A");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1044, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+1Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+18h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+14h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtbb, forceColorl);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1045, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Translation B");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1046, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+2Ch]
                vmovss  xmm4, dword ptr [rbx+28h]
                vmovss  xmm3, dword ptr [rbx+24h]
                vmovss  xmm2, dword ptr [rbx+20h]
              }
LABEL_210:
              __asm
              {
                vcvtss2sd xmm3, xmm3, xmm3
                vcvtss2sd xmm4, xmm4, xmm4
                vcvtss2sd xmm1, xmm1, xmm1
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtu, forceColork);
              _EDI = 0;
              goto LABEL_157;
            case 4:
              _RBX = v258;
              _RDI = v258;
              v258 += 112;
              Com_sprintf<256>((char (*)[256])dest, "Rotation A");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1037, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+30h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+20h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtv);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1038, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+34h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+24h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rdi+14h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtw);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1039, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+38h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+28h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rdi+18h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtx);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1040, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Rotation B");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1041, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+60h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+50h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+40h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmty);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1042, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+64h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+54h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rdi+44h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtz);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1043, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rdi+68h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rdi+58h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rdi+48h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtba);
              _EDI = 0;
              goto LABEL_157;
            case 5:
              _RBX = v258;
              v258 += 32;
              Com_sprintf<256>((char (*)[256])dest, "Solving Method: %s", atomSolvingMethodsNames[_RBX[2]]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v969, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              v268 = _RBX[3];
              if ( v268 )
              {
                Com_sprintf<256>((char (*)[256])dest, "BodiesToNotify: %i", v268);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v970, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              v272 = _RBX[5] == 0;
              if ( _RBX[5] )
              {
                Com_sprintf<256>((char (*)[256])dest, "LinearImpulseLimit Enabled");
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v971, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+8]
                vucomiss xmm0, xmm8
              }
              if ( !v272 )
              {
                __asm
                {
                  vcvtss2sd xmm2, xmm0, xmm0
                  vmovq   r8, xmm2
                }
                Com_sprintf<256>((char (*)[256])dest, "Breach Impulse %.3f", *(double *)&_XMM2);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v972, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              __asm
              {
                vmovss  xmm2, dword ptr [rbx+0Ch]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v973, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v974, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm3, dword ptr [rbx+14h]
                vcvtss2sd xmm3, xmm3, xmm3
              }
              _ECX = hkUFloat8::s_encodedFloats[_RBX[4]];
              v1055 = (_ECX + 243712) << 12;
              __asm
              {
                vmovd   xmm1, edi
                vmovd   xmm0, ecx
                vpcmpeqd xmm2, xmm0, xmm1
                vmovss  xmm1, dword ptr [rsp+280h+var_228]
                vblendvps xmm0, xmm1, xmm10, xmm2
                vmovss  dword ptr [rsp+280h+var_228], xmm0
                vcvtss2sd xmm2, xmm0, xmm0
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Stabilization - Velocity:%.3f Inertia:%.3f", *(double *)&_XMM2, *(double *)&_XMM3);
              goto LABEL_157;
            case 6:
              _RBX = v258;
              v258 += 32;
              __asm
              {
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Length     %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v980, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+14h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Max Length %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v981, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+18h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Spring Constant %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v982, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+1Ch]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", *(double *)&_XMM2);
              goto LABEL_157;
            case 7:
              v393 = "Axis Index %i";
              goto LABEL_162;
            case 9:
              _RBX = v258;
              v258 += 32;
              Com_sprintf<256>((char (*)[256])dest, "Axis Index %i", _RBX[2]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v985, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm3, dword ptr [rbx+8]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+4]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Min %.3f Max %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v986, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+0Ch]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v987, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", *(double *)&_XMM2);
              goto LABEL_157;
            case 0xA:
              _RBX = v258;
              v258 += 16;
              v432 = "Disabled";
              if ( _RBX[2] )
                v432 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v432);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v988, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Friction Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v989, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+4]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Max Friction Force %.3f", *(double *)&_XMM2);
              goto LABEL_157;
            case 0xB:
              _RBX = v258;
              v258 += 32;
              v443 = "Disabled";
              if ( _RBX[2] )
                v443 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v443);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v990, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Motor Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v991, 0);
              v449 = "Target Position %.3f";
              goto LABEL_172;
            case 0xC:
              v393 = "Free Rotation Axis Index %i";
LABEL_162:
              _RBX = v258;
              v395 = v258[2];
              v258 += 16;
              Com_sprintf<256>((char (*)[256])dest, v393, v395);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v983, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+4]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v984, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+8]
              }
              goto LABEL_163;
            case 0xD:
              _RBX = v258;
              v258 += 16;
              Com_sprintf<256>((char (*)[256])dest, "First Axis Index %i", _RBX[2]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v993, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Second Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v994, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Third Axis Index %i", _RBX[4]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v995, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Number of Axes %i", _RBX[5]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v996, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+8]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v997, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+0Ch]
              }
              goto LABEL_163;
            case 0xE:
              _RBX = v258;
              v258 += 32;
              v478 = "Disabled";
              if ( _RBX[2] )
                v478 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v478);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v998, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Limit Axis Index %i", _RBX[3]);
              goto LABEL_180;
            case 0xF:
              _RBX = v258;
              v258 += 32;
              v510 = "Disabled";
              if ( _RBX[2] )
                v510 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v510);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1005, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Twist Axis in A - Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1006, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Ref Axis in B   - Index %i", _RBX[4]);
              goto LABEL_180;
            case 0x10:
              _RBX = v258;
              v258 += 32;
              v500 = "Disabled";
              if ( _RBX[2] )
                v500 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v500);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1002, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Twist Axis in A - Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1003, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Ref Axis in B   - Index %i", _RBX[4]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1004, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Angle Measurement: %s", coneLimitMeasurementModeNames[_RBX[5]]);
LABEL_180:
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v999, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm3, dword ptr [rbx+0Ch]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+8]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Angles Min:%.3f Max:%.3f", *(double *)&_XMM2, *(double *)&_XMM3);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1000, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1001, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+14h]
              }
LABEL_163:
              v406 = "Damping %.3f";
              goto LABEL_164;
            case 0x11:
              _RBX = v258;
              v258 += 16;
              v518 = "Disabled";
              if ( _RBX[2] )
                v518 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v518);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1007, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "First Friction Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1008, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Number of Friction Axes %i", _RBX[4]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1009, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+8]
              }
              v406 = "Max Friction Torque %.3f";
              goto LABEL_164;
            case 0x12:
              _RBX = v258;
              v258 += 32;
              v528 = "Disabled";
              if ( _RBX[2] )
                v528 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v528);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1010, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Motor Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1011, 0);
              v449 = "Target Angle %.3f";
LABEL_172:
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, v449, _R8);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v992, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              v457 = *((_QWORD *)_RBX + 1);
              if ( v457 )
                Com_sprintf<256>((char (*)[256])dest, "Motor Type %s", motorTypeNames[*(char *)(v457 + 24)]);
              else
                Com_sprintf<256>((char (*)[256])dest, "No Motor set");
              goto LABEL_157;
            case 0x13:
              v534 = v258;
              _RBX = v258;
              v258 += 96;
              v536 = "Disabled";
              if ( _RBX[2] )
                v536 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v536);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1012, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Target Matrix");
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1013, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+30h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+20h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmti);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1014, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+34h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+24h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+14h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtj);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1015, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+38h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+28h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+18h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtk);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1016, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              v576 = *((_QWORD *)v534 + 8);
              if ( v576 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Motor Type 0: %s", motorTypeNames[*(char *)(v576 + 24)]);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1017, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              v580 = *((_QWORD *)v534 + 9);
              if ( v580 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Motor Type 1: %s", motorTypeNames[*(char *)(v580 + 24)]);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1018, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              v584 = *((_QWORD *)v534 + 10);
              if ( v584 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Motor Type 2: %s", motorTypeNames[*(char *)(v584 + 24)]);
                _EDI = 0;
LABEL_157:
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v975, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              else
              {
                _EDI = 0;
              }
LABEL_224:
              __asm
              {
                vmovss  xmm0, dword ptr [r14]
                vsubss  xmm0, xmm0, xmm7
                vmovss  dword ptr [r14], xmm0
              }
              ++v257;
              if ( v258 < (unsigned __int8 *)v1063 )
                continue;
              v204 = v1058;
              break;
            case 0x14:
              _RDI = v258;
              _RBX = v258;
              v258 += 64;
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+1Ch]
                vcvtss2sd xmm0, xmm0, xmm0
                vmovss  xmm1, dword ptr [rbx+18h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+14h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm0
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "PivotA (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtl, forceColorh);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1019, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+2Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+28h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+24h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+20h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "PivotB (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtm, forceColori);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1020, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rdi+30h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Rope Length %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1021, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rdi+34h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Leverage on B %.3f", *(double *)&_XMM2);
              _EDI = 0;
              goto LABEL_157;
            case 0x15:
              _RAX = v258;
              v258 += 16;
              __asm
              {
                vmovss  xmm2, dword ptr [rax+4]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              v626 = "Screw Pitch %.3f";
              if ( !_RAX[8] )
                v626 = "Pinion Radius %.3f";
              Com_sprintf<256>((char (*)[256])dest, v626, _R8);
              goto LABEL_157;
            case 0x16:
              _RBX = v258;
              v258 += 16;
              __asm
              {
                vmovss  xmm2, dword ptr [rbx+4]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Wheel A Radius %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1022, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+8]
              }
              v406 = "Wheel B Radius %.3f";
              goto LABEL_164;
            case 0x17:
              _RBX = v258;
              v258 += 16;
              v845 = "Disabled";
              if ( _RBX[2] )
                v845 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v845);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1047, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+4]
                vucomiss xmm1, xmm8
              }
              if ( !v848 )
              {
                __asm
                {
                  vcvtss2sd xmm2, xmm1, xmm1
                  vmovq   r8, xmm2
                }
                Com_sprintf<256>((char (*)[256])dest, "Max Linear Impulse:%.3f", *(double *)&_XMM2);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1048, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+8]
                vucomiss xmm0, xmm8
              }
              if ( !v848 )
              {
                __asm
                {
                  vcvtss2sd xmm2, xmm0, xmm0
                  vmovq   r8, xmm2
                }
                Com_sprintf<256>((char (*)[256])dest, "Max Angular Impulse:%.3f", *(double *)&_XMM2);
                __asm
                {
                  vmovss  [rsp+280h+var_248], xmm6
                  vmovss  xmm2, dword ptr [rsi]; y
                  vmovss  xmm1, dword ptr [r14]; x
                }
                Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1049, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [rsi]
                  vmovss  dword ptr [rsi], xmm0
                }
              }
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+0Ch]
                vucomiss xmm0, xmm9
              }
              if ( v848 )
                goto LABEL_224;
              __asm
              {
                vcvtss2sd xmm2, xmm0, xmm0
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Max Angle: %.3f", *(double *)&_XMM2);
              goto LABEL_157;
            case 0x18:
              v258 += 16;
              goto LABEL_224;
            case 0x19:
            case 0x1A:
              _RBX = v258;
              v258 += 96;
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+1Ch]
                vcvtss2sd xmm0, xmm0, xmm0
                vmovss  xmm1, dword ptr [rbx+18h]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm3, dword ptr [rbx+14h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+10h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm0
                vmovsd  [rsp+280h+fmt], xmm1
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Offset (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtd, forceColorc);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v976, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+2Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+28h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+24h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+20h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Yield Strength Diag     (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmte, forceColord);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v977, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+3Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+38h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+34h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+30h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Yield Strength Off Diag (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtf, forceColore);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v978, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+4Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+48h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+44h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+40h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Ultimate Strength Diag     (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtg, forceColorf);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v979, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm1, dword ptr [rbx+5Ch]
                vcvtss2sd xmm1, xmm1, xmm1
                vmovss  xmm4, dword ptr [rbx+58h]
                vcvtss2sd xmm4, xmm4, xmm4
                vmovss  xmm3, dword ptr [rbx+54h]
                vcvtss2sd xmm3, xmm3, xmm3
                vmovss  xmm2, dword ptr [rbx+50h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovsd  qword ptr [rsp+280h+forceColor], xmm1
                vmovsd  [rsp+280h+fmt], xmm4
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Ultimate Strength Off Diag (%.3f, %.3f, %.3f, %.3f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmth, forceColorg);
              _EDI = 0;
              goto LABEL_157;
            case 0x1C:
              _RBX = v258;
              v258 += 48;
              v635 = "Disabled";
              if ( _RBX[2] )
                v635 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v635);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1023, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Forward Axis Index %i", _RBX[3]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1024, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
              }
              Com_sprintf<256>((char (*)[256])dest, "Side Axis Index %i", _RBX[4]);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1025, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+18h]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Max Friction Force %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1026, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+1Ch]
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, "Torque %.3f", *(double *)&_XMM2);
              __asm
              {
                vmovss  [rsp+280h+var_248], xmm6
                vmovss  xmm2, dword ptr [rsi]; y
                vmovss  xmm1, dword ptr [r14]; x
              }
              Physics_DrawDebugString(v14, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v1027, 0);
              __asm
              {
                vaddss  xmm0, xmm6, dword ptr [rsi]
                vmovss  dword ptr [rsi], xmm0
                vmovss  xmm2, dword ptr [rbx+8]
              }
              v406 = "Wheel Radius %.3f";
LABEL_164:
              __asm
              {
                vcvtss2sd xmm2, xmm2, xmm2
                vmovq   r8, xmm2
              }
              Com_sprintf<256>((char (*)[256])dest, v406, _R8);
              goto LABEL_157;
            default:
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19478, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Constraint") )
                __debugbreak();
              goto LABEL_224;
          }
          break;
        }
      }
      __asm
      {
        vsubss  xmm0, xmm0, xmm7
        vmovss  dword ptr [r14], xmm0
      }
      ++v1053;
      v204 += 40;
      v1058 = v204;
    }
    while ( v204 != (char *)&m_physicsSystemData->m_constraintCinfos.m_data[m_physicsSystemData->m_constraintCinfos.m_size] );
  }
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [r14], xmm1
  }
LABEL_229:
  v871 = hkMemHeapAllocator();
  v1060 = 0;
  if ( v1061 >= 0 )
    hkMemoryAllocator::bufFree2(v871, array, 8, v1061 & 0x3FFFFFFF);
  _R11 = &v1070;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
HavokPhysics_DrawPhysicsAssets
==============
*/
void HavokPhysics_DrawPhysicsAssets(bool sortByName, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v11; 
  bool v12; 
  unsigned int v13; 
  int v14; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v15; 
  __int64 m_hashMod; 
  __int64 v17; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  hkMemoryAllocator *v20; 
  int v21; 
  __int64 v22; 
  __int64 v23; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v24; 
  __int64 m_numElems; 
  int v30; 
  hkBool *(__fastcall *v31)(hkBool *, const PhysicsAsset *, const PhysicsAsset *); 
  unsigned int v34; 
  const char ***v35; 
  hkMemoryAllocator *v40; 
  float v44; 
  float v45; 
  PhysicsAsset **array; 
  __int64 v48; 
  const ScreenPlacement *v49; 
  __int64 v50; 
  char dest[256]; 
  char v52; 
  void *retaddr; 

  _RAX = &retaddr;
  v50 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R15 = y;
  _R14 = x;
  v11 = scrPlace;
  v49 = scrPlace;
  v12 = sortByName;
  array = NULL;
  v48 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18260, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tDebug rendering Havok Physics Assets, but the pointermap is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  v13 = 0;
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v14 = 0;
  v15 = s_havokPhysicsAssets;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    v17 = 0i64;
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v14;
      ++v17;
      ++m_elem;
    }
    while ( v17 <= m_hashMod );
  }
  if ( v14 <= (int)m_hashMod )
  {
    do
    {
      key = v15->m_map.m_elem[v14].key;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18269, ASSERT_TYPE_ASSERT, "(physAsset)", (const char *)&queryFormat, "physAsset") )
        __debugbreak();
      v13 += *(_DWORD *)(key + 16) + 88;
      v20 = hkMemHeapAllocator();
      v21 = v48;
      if ( (_DWORD)v48 == (HIDWORD(v48) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v20, &array, 8);
        v21 = v48;
      }
      array[v21] = (PhysicsAsset *)key;
      LODWORD(v48) = v48 + 1;
      ++v14;
      v15 = s_havokPhysicsAssets;
      v22 = s_havokPhysicsAssets->m_map.m_hashMod;
      if ( v14 > (int)v22 )
        break;
      v23 = v14;
      v24 = &s_havokPhysicsAssets->m_map.m_elem[v14];
      do
      {
        if ( v24->key != -1i64 )
          break;
        ++v14;
        ++v23;
        ++v24;
      }
      while ( v23 <= v22 );
    }
    while ( v14 <= (int)v22 );
    v11 = v49;
    v12 = sortByName;
  }
  m_numElems = (unsigned int)v15->m_map.m_numElems;
  LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
  Com_sprintf<256>((char (*)[256])dest, "%i Assets - %i bytes", m_numElems, v13);
  __asm
  {
    vmovss  xmm6, [rbp+0E0h+charHeight]
    vmovss  [rsp+1E0h+var_1A8], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v44, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  v30 = v48;
  if ( v12 )
  {
    if ( (int)v48 <= 1 )
      goto LABEL_26;
    v31 = HavokPhysics_PhysicsAssetSortByName;
  }
  else
  {
    if ( (int)v48 <= 1 )
      goto LABEL_26;
    v31 = HavokPhysics_PhysicsAssetSortByMemory;
  }
  hkAlgorithm::quickSortRecursive<PhysicsAsset *,hkBool (*)(PhysicsAsset const *,PhysicsAsset const *)>(array, 0, v48 - 1, v31);
  v30 = v48;
LABEL_26:
  __asm
  {
    vmovss  xmm7, [rbp+0E0h+tabWidth]
    vaddss  xmm0, xmm7, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
  }
  v34 = 0;
  v35 = (const char ***)array;
  if ( array != &array[v30] )
  {
    do
    {
      Com_sprintf<256>((char (*)[256])dest, "%i: size:%6i name:%s", v34, *((unsigned int *)*v35 + 4), **v35);
      __asm
      {
        vmovss  [rsp+1E0h+var_1A8], xmm6
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r14]; x
      }
      Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v45, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
      ++v34;
      ++v35;
    }
    while ( v35 != (const char ***)&array[(int)v48] );
    __asm { vmovss  xmm0, dword ptr [r14] }
  }
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vmovss  dword ptr [r14], xmm0
  }
  v40 = hkMemHeapAllocator();
  LODWORD(v48) = 0;
  if ( v48 >= 0 )
    hkMemoryAllocator::bufFree2(v40, array, 8, HIDWORD(v48) & 0x3FFFFFFF);
  _R11 = &v52;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawPhysicsBody
==============
*/
void HavokPhysics_DrawPhysicsBody(Physics_WorldId worldId, hknpBodyId bodyId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  hknpWorld *world; 
  unsigned int v19; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v20; 
  __int64 v21; 
  int v22; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v23; 
  unsigned int m_value; 
  hknpShape *m_shape; 
  unsigned int m_storage; 
  unsigned __int8 v28; 
  hkStringPtr *m_data; 
  const char **p_name; 
  const char **v64; 
  __int64 v204; 
  __int64 v205; 
  __int64 v210; 
  float fmt; 
  float fmta; 
  char *fmtb; 
  char *fmtc; 
  char *fmtd; 
  float fmte; 
  float fmtf; 
  int forceColor; 
  int forceColora; 
  int forceColorb; 
  double forceColorc; 
  double forceColord; 
  double forceColore; 
  int forceColorf; 
  int forceColorg; 
  int forceColorh; 
  int shadow; 
  int shadowa; 
  float v243; 
  float v244; 
  float v245; 
  float v246; 
  float v247; 
  float v248; 
  float v249; 
  float v250; 
  float v251; 
  float v252; 
  float v253; 
  float v254; 
  float v255; 
  float v256; 
  float v257; 
  float v258; 
  float v259; 
  float v260; 
  float v261; 
  float v262; 
  float v263; 
  float v264; 
  float v265; 
  float v266; 
  float v267; 
  float v268; 
  float v269; 
  float v270; 
  float v271; 
  float v272; 
  float v273; 
  float v274; 
  float v275; 
  float v276; 
  float v277; 
  float v278; 
  float v279; 
  float v280; 
  float v281; 
  unsigned __int16 v283; 
  unsigned int m_activationPriority; 
  unsigned int contents; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v289; 
  unsigned __int64 userData; 
  hknpShape *shape; 
  char v292; 
  unsigned __int16 v294; 
  char dest[256]; 

  _R13 = x;
  _R15 = y;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22051, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawPhysicsBody with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm { vmovaps [rsp+290h+var_40], xmm6 }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  world = MutableWorld->world;
  if ( world && (v19 = bodyId.m_serialAndIndex & 0xFFFFFF, (bodyId.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF) && v19 < world->m_bodyManager.m_bodies.m_objects.m_size && (v20 = world->m_bodyManager.m_bodies.m_objects.m_data, v21 = v19, (v20[v21].m_pod.m_flags.m_storage & 3) != 0) && v20[v21].m_pod.m_id.m_serialAndIndex == bodyId.m_serialAndIndex )
  {
    __asm { vmovaps [rsp+290h+var_60], xmm8 }
    v22 = 8;
    v23 = &v20[bodyId.m_serialAndIndex & 0xFFFFFF];
    _RDX = &v292;
    m_value = v23->m_pod.m_motionId.m_value;
    m_shape = (hknpShape *)v23->m_pod.m_shape;
    m_storage = v23->m_pod.m_flags.m_storage;
    v28 = v23->m_pod.m_qualityId.m_value;
    userData = v23->m_pod.m_userData;
    _RAX = (unsigned __int64)&world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)m_value];
    shape = m_shape;
    do
    {
      __asm { vmovups xmm0, xmmword ptr [rax] }
      --v22;
      _RAX += 16i64;
      __asm { vmovups xmmword ptr [rdx], xmm0 }
      _RDX += 16;
    }
    while ( v22 > 0 );
    contents = v23->m_pod.m_collisionFilterInfo;
    v283 = v23->m_pod.m_materialId.m_value;
    m_activationPriority = v23->m_pod.m_activationPriority;
    __asm
    {
      vmovsd  xmm2, [rbp+190h+var_1E0]
      vmovups xmm4, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
      vpxor   xmm1, xmm1, xmm1
      vpunpcklwd xmm5, xmm1, xmm2
      vshufps xmm0, xmm5, xmm5, 0FFh
      vrcpps  xmm1, xmm0
      vxorps  xmm3, xmm3, xmm3
      vcmpeqps xmm2, xmm3, xmm0
      vmulps  xmm0, xmm1, xmm0
      vsubps  xmm0, xmm4, xmm0
      vmulps  xmm1, xmm0, xmm1
      vandnps xmm8, xmm2, xmm1
      vrcpps  xmm2, xmm5
      vmulps  xmm0, xmm2, xmm5
      vsubps  xmm1, xmm4, xmm0
      vmulps  xmm2, xmm1, xmm2
      vcmpeqps xmm3, xmm3, xmm5
      vandnps xmm3, xmm3, xmm2
      vmovups [rbp+190h+var_180], xmm3
    }
    if ( m_shape )
    {
      m_data = world->m_bodyManager.m_bodyNames.m_data;
      __asm { vmovaps [rsp+290h+var_50], xmm7 }
      v289 = bodyId.m_serialAndIndex & 0xFFFFFF;
      Com_sprintf<256>((char (*)[256])dest, "Name: %s", (const char *)((unsigned __int64)m_data[v289].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
      __asm
      {
        vmovss  xmm6, [rbp+190h+charHeight]
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v244, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
      p_name = &MutableWorld->bodySFXEventAssets->m_data[v289]->name;
      if ( p_name )
      {
        Com_sprintf<256>((char (*)[256])dest, "SFX Event Asset: %s", *p_name);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v245, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      v64 = &MutableWorld->bodyVFXEventAssets->m_data[v289]->name;
      if ( v64 )
      {
        Com_sprintf<256>((char (*)[256])dest, "VFX Event Asset: %s", *v64);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v246, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      Com_sprintf<256>((char (*)[256])dest, "UserData:");
      __asm
      {
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v247, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  xmm7, [rbp+190h+tabWidth]
        vmovss  dword ptr [r15], xmm0
        vaddss  xmm1, xmm7, dword ptr [r13+0]
        vmovss  [rsp+290h+shadow], xmm6
        vmovss  [rsp+290h+forceColor], xmm7
        vmovss  dword ptr [r13+0], xmm1
      }
      HavokPhysics_DrawPhysicsBodyUserData(worldId, userData, scrPlace, x, y, *(float *)&forceColor, *(float *)&shadow);
      __asm
      {
        vmovss  xmm0, dword ptr [r13+0]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r13+0], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "Shape:");
      __asm
      {
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v248, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
        vaddss  xmm1, xmm7, dword ptr [r13+0]
        vmovss  [rsp+290h+forceColor], xmm6
        vmovss  dword ptr [r13+0], xmm1
        vmovss  dword ptr [rsp+290h+fmt], xmm7
      }
      HavokPhysics_DrawPhysicsShape(shape, scrPlace, x, y, fmt, *(float *)&forceColora);
      __asm
      {
        vmovss  xmm0, dword ptr [r13+0]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r13+0], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "Flags: %x", m_storage);
      __asm
      {
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v249, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
        vaddss  xmm1, xmm7, dword ptr [r13+0]
        vmovss  dword ptr [r13+0], xmm1
      }
      if ( (m_storage & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_STATIC");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v250, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DYNAMIC");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v251, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_KEYFRAMED");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v252, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ACTIVE");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v253, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x100) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_COLLIDE");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v254, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x200) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_BUILD_CONTACT_JACOBIANS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v255, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_TRIGGER_EVENTS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v256, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_MANIFOLD_STATUS_EVENTS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v257, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x80u) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONTACT_IMPULSE_EVENTS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v258, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x100000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_RESTITUTION");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v259, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x200000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIGGER_MODIFIER");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v260, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x400000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_IMPULSE_CLIPPING");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v261, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x800000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_MASS_CHANGER");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v262, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x1000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_SOFT_CONTACTS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v263, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x2000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_SURFACE_VELOCITY");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v264, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x4000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TIME_FACTOR");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v265, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x8000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_ANIMATED_SHAPE_VELOCITY");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v266, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x10000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DISABLE_PENETRATION_RECOVERY");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v267, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x2000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "FLIP_BACKFACE_COLLISIONS");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v268, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x4000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_NON_RUNTIME");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v269, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x8000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_BREAKABLE");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v270, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      if ( (m_storage & 0x10000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IW_MOTION_USES_GRAVITY");
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v271, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r13+0]
        vsubss  xmm1, xmm0, xmm7
        vmovss  dword ptr [r13+0], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "Body Quality id %i:", v28);
      __asm
      {
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v272, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
      if ( fullDisplay )
      {
        __asm
        {
          vaddss  xmm0, xmm7, dword ptr [r13+0]
          vmovss  [rsp+290h+forceColor], xmm6
          vmovss  dword ptr [r13+0], xmm0
          vmovss  dword ptr [rsp+290h+fmt], xmm7
        }
        HavokPhysics_DrawPhysicsLibraryBodyQualityId(v28, scrPlace, x, y, fmta, *(float *)&forceColorb);
        __asm
        {
          vmovss  xmm0, dword ptr [r13+0]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [r13+0], xmm1
        }
      }
      Com_sprintf<256>((char (*)[256])dest, "Motion id %i:", m_value);
      __asm
      {
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v273, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
      if ( m_value )
      {
        __asm
        {
          vaddss  xmm0, xmm7, dword ptr [r13+0]
          vcvtss2sd xmm2, xmm8, xmm8
          vmovq   r8, xmm2
          vmovss  dword ptr [r13+0], xmm0
        }
        Com_sprintf<256>((char (*)[256])dest, "Mass %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v274, 0);
        __asm
        {
          vmovss  xmm1, dword ptr [rbp+190h+var_180+0Ch]
          vmovss  xmm3, dword ptr [rbp+190h+var_180+4]
          vmovss  xmm2, dword ptr [rbp+190h+var_180]
          vmovss  xmm4, dword ptr [rbp+190h+var_180+8]
          vaddss  xmm0, xmm6, dword ptr [r15]
          vcvtss2sd xmm1, xmm1, xmm1
          vcvtss2sd xmm3, xmm3, xmm3
          vcvtss2sd xmm2, xmm2, xmm2
          vcvtss2sd xmm4, xmm4, xmm4
          vmovsd  qword ptr [rsp+290h+forceColor], xmm1
          vmovq   r9, xmm3
          vmovq   r8, xmm2
          vmovsd  [rsp+290h+fmt], xmm4
          vmovss  dword ptr [r15], xmm0
        }
        Com_sprintf<256>((char (*)[256])dest, "Inertia Tensor Local (%.2f %.2f %.2f %.2f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtb, forceColorc);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v275, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        Com_sprintf<256>((char (*)[256])dest, "Activation Priority %i", m_activationPriority);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v276, 0);
        __asm
        {
          vmovss  xmm1, [rbp+190h+var_1B8]
          vmovss  xmm3, [rbp+190h+var_1C0]
          vmovss  xmm2, [rbp+190h+var_1BC]
          vaddss  xmm0, xmm6, dword ptr [r15]
          vcvtss2sd xmm1, xmm1, xmm1
          vcvtss2sd xmm3, xmm3, xmm3
          vcvtss2sd xmm2, xmm2, xmm2
          vmovsd  qword ptr [rsp+290h+forceColor], xmm1
          vmovq   r9, xmm3
          vmovsd  [rsp+290h+fmt], xmm2
          vmovss  dword ptr [r15], xmm0
        }
        Com_sprintf(dest, 0x100ui64, "LinVel (%.2f %.2f %.2f)", *(double *)&_XMM3, *(double *)&fmtc, forceColord);
        __asm
        {
          vmovss  [rsp+290h+var_258], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v277, 0);
        __asm
        {
          vmovss  xmm1, [rbp+190h+var_1A8]
          vmovss  xmm3, [rbp+190h+var_1B0]
          vmovss  xmm2, [rbp+190h+var_1AC]
          vaddss  xmm0, xmm6, dword ptr [r15]
          vcvtss2sd xmm1, xmm1, xmm1
          vcvtss2sd xmm3, xmm3, xmm3
          vcvtss2sd xmm2, xmm2, xmm2
          vmovsd  qword ptr [rsp+290h+forceColor], xmm1
          vmovq   r9, xmm3
          vmovsd  [rsp+290h+fmt], xmm2
          vmovss  dword ptr [r15], xmm0
        }
        Com_sprintf(dest, 0x100ui64, "AngVel (%.2f %.2f %.2f)", *(double *)&_XMM3, *(double *)&fmtd, forceColore);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v278, 0);
        __asm { vaddss  xmm0, xmm6, dword ptr [r15] }
        v204 = v294;
        v205 = v294;
        __asm { vmovss  dword ptr [r15], xmm0 }
        Com_sprintf<256>((char (*)[256])dest, "Motion Properties Id %i", v205);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v279, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
          vaddss  xmm1, xmm7, dword ptr [r13+0]
          vmovss  dword ptr [r13+0], xmm1
        }
        v210 = (__int64)MutableWorld->world->getMotionPropertiesLibrary(&MutableWorld->world->hknpWorldReader);
        __asm
        {
          vmovss  [rsp+290h+shadow], xmm6
          vmovss  [rsp+290h+forceColor], xmm7
        }
        HavokPhysics_DrawPhysicsLibraryMotionPropertiesId((const hknpMotionProperties *)(*(_QWORD *)(v210 + 64) + 112 * v204), v204, scrPlace, x, y, *(float *)&forceColorf, *(float *)&shadowa);
        __asm
        {
          vmovss  xmm0, dword ptr [r13+0]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [r13+0], xmm1
        }
      }
      __asm
      {
        vmovss  [rsp+290h+forceColor], xmm6
        vmovss  dword ptr [rsp+290h+fmt], xmm7
      }
      HavokPhysics_DrawPhysicsContents(contents, scrPlace, x, y, fmte, *(float *)&forceColorg);
      if ( fullDisplay )
      {
        Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", v283);
        __asm
        {
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r13+0]; x
          vmovss  [rsp+290h+var_258], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v280, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
          vaddss  xmm1, xmm7, dword ptr [r13+0]
          vmovss  [rsp+290h+forceColor], xmm6
          vmovss  dword ptr [r13+0], xmm1
          vmovss  dword ptr [rsp+290h+fmt], xmm7
        }
        HavokPhysics_DrawPhysicsLibraryMaterialId(v283, scrPlace, x, y, fmtf, *(float *)&forceColorh);
        __asm
        {
          vmovss  xmm0, dword ptr [r13+0]
          vsubss  xmm1, xmm0, xmm7
        }
      }
      else
      {
        __asm { vmovss  xmm1, dword ptr [r13+0] }
      }
      __asm
      {
        vsubss  xmm0, xmm1, xmm7
        vmovaps xmm7, [rsp+290h+var_50]
        vmovss  dword ptr [r13+0], xmm0
      }
    }
    else
    {
      Com_sprintf<256>((char (*)[256])dest, "Not-yet setup body %i in world %i", bodyId.m_serialAndIndex, (unsigned int)worldId);
      __asm
      {
        vmovss  xmm6, [rbp+190h+charHeight]
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r13+0]; x
        vmovss  [rsp+290h+var_258], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v243, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
    }
    __asm { vmovaps xmm8, [rsp+290h+var_60] }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Couldn't find body %i in world %i", bodyId.m_serialAndIndex, (unsigned int)worldId);
    __asm
    {
      vmovss  xmm6, [rbp+190h+charHeight]
      vmovss  xmm2, dword ptr [r15]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  [rsp+290h+var_258], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v281, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r15]
      vmovss  dword ptr [r15], xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+290h+var_40] }
}

/*
==============
HavokPhysics_DrawPhysicsBodyUserData
==============
*/
void HavokPhysics_DrawPhysicsBodyUserData(Physics_WorldId worldId, unsigned __int64 userData, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v11; 
  bool RefDetailFlag; 
  unsigned __int8 RefSubSystem; 
  __int64 v14; 
  const char *v15; 
  unsigned int v19; 
  const char *WorldTransientName; 
  unsigned int v25; 
  LocalClientNum_t LocalClientForWorld; 
  __int64 v33; 
  DObj *ServerDObjForEntnum; 
  const char **v44; 
  LocalClientNum_t v45; 
  __int64 v46; 
  CgEntitySystem *v47; 
  __int64 v48; 
  int v49; 
  const char *v50; 
  const char *v51; 
  LocalClientNum_t v55; 
  const XModel *Model; 
  unsigned __int64 v57; 
  char FilterSubGroupIdFromUserData; 
  char FilterSubGroupIdNoCollideIdFromUserData; 
  bool IsClutterFromUserData; 
  bool DontCollideWithClutterFromUserData; 
  vec4_t *setColor; 
  __int64 forceColor; 
  __int64 shadow; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 
  float v83; 
  float v84; 
  float v85; 
  DynEntityBasis basisOut[4]; 
  unsigned int dynEntIdOut; 
  Physics_WorldId worldIda; 
  unsigned __int64 userDataa; 
  char dest[256]; 

  __asm { vmovaps [rsp+1D0h+var_50], xmm6 }
  _RDI = y;
  _R14 = x;
  worldIda = worldId;
  userDataa = userData;
  v11 = truncate_cast<int,unsigned __int64>((unsigned int)userData);
  RefDetailFlag = Physics_GetRefDetailFlag(v11);
  dynEntIdOut = Physics_GetRefSystem(v11);
  RefSubSystem = Physics_GetRefSubSystem(v11);
  LOWORD(v14) = Physics_GetRefId(v11);
  v15 = (char *)&queryFormat.fmt + 3;
  if ( RefDetailFlag )
    v15 = "Detail ";
  Com_sprintf<256>((char (*)[256])dest, "%s%s", v15, refSystemNames[dynEntIdOut]);
  __asm
  {
    vmovss  xmm6, [rbp+0D0h+charHeight]
    vmovss  xmm2, dword ptr [rdi]; y
    vmovss  xmm1, dword ptr [r14]; x
    vmovss  [rsp+1D0h+var_198], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v75, 0);
  v19 = dynEntIdOut;
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  switch ( v19 )
  {
    case 0u:
      switch ( RefSubSystem )
      {
        case 0u:
          if ( (_WORD)v14 )
            Com_sprintf<256>((char (*)[256])dest, "General World Geometry, Terrain, Patches and Entity 0 brushes in collision tile %i", (unsigned int)(unsigned __int16)v14 - 1);
          else
            Com_sprintf<256>((char (*)[256])dest, "General World Geometry, Terrain, Patches and Entity 0 brushes");
          goto LABEL_8;
        case 1u:
          if ( (unsigned __int16)v14 >= 0x20u )
          {
            v25 = (unsigned __int16)v14 - 32;
            if ( v25 >= 0x400 )
            {
              LODWORD(shadow) = 1024;
              LODWORD(forceColor) = (unsigned __int16)v14 - 32;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16560, ASSERT_TYPE_ASSERT, "(unsigned)( tileIdx ) < (unsigned)( COLLISION_TILE_MAX_TILES )", "tileIdx doesn't index COLLISION_TILE_MAX_TILES\n\t%i not in [0, %i)", forceColor, shadow) )
                __debugbreak();
            }
            LODWORD(setColor) = v25 >> 5;
            Com_sprintf<256>((char (*)[256])dest, "Static Model Shape Geometry for tile %i grid %i,%i", v25, v25 & 0x1F, setColor);
          }
          else
          {
            if ( (unsigned __int16)v14 >= 0x20u )
            {
              LODWORD(shadow) = 32;
              LODWORD(forceColor) = (unsigned __int16)v14;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16475, ASSERT_TYPE_ASSERT, "(unsigned)( havokZoneIdx ) < (unsigned)( HAVOK_PHYSICS_MAX_ZONES )", "havokZoneIdx doesn't index HAVOK_PHYSICS_MAX_ZONES\n\t%i not in [0, %i)", forceColor, shadow) )
                __debugbreak();
            }
            if ( (_WORD)v14 )
              WorldTransientName = DB_Transients_GetWorldTransientName((unsigned __int16)v14);
            else
              WorldTransientName = "main";
            Com_sprintf<256>((char (*)[256])dest, "Static Model Shape Geometry for zone %i %s", (unsigned __int16)v14, WorldTransientName);
          }
          goto LABEL_28;
        case 2u:
          Com_sprintf<256>((char (*)[256])dest, "Patch Collision Shape Geometry");
          goto LABEL_8;
      }
      break;
    case 1u:
      LocalClientForWorld = Physics_GetLocalClientForWorld(worldIda);
      if ( LocalClientForWorld == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16607, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      DynEnt_GetBasisAndDynEntId(v11, LocalClientForWorld, basisOut, &dynEntIdOut);
      Com_sprintf<256>((char (*)[256])dest, "Basis:%s", dynEntityBasisNames[(unsigned __int8)basisOut[0]]);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v77, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Type: %s", dynEntityTypeNames[RefSubSystem >> 1]);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v78, 0);
      __asm { vaddss  xmm0, xmm6, dword ptr [rdi] }
      v33 = dynEntIdOut;
      __asm { vmovss  dword ptr [rdi], xmm0 }
      Com_sprintf<256>((char (*)[256])dest, "Id: %i", v33);
      goto LABEL_28;
    case 2u:
    case 9u:
      Com_sprintf<256>((char (*)[256])dest, "Model Type: %s", modelTypeNames[RefSubSystem]);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v80, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Entity Id: %i", (unsigned __int16)v14);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v81, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      ServerDObjForEntnum = Com_GetServerDObjForEntnum((unsigned __int16)v14);
      if ( !ServerDObjForEntnum )
        break;
      if ( !ServerDObjForEntnum->numModels )
        break;
      v44 = (const char **)*ServerDObjForEntnum->models;
      if ( !v44 )
        break;
      Com_sprintf<256>((char (*)[256])dest, "Using Model: %s", *v44);
LABEL_28:
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v79, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      break;
    case 3u:
    case 5u:
      Com_sprintf<256>((char (*)[256])dest, "Character Proxy - Entity Id: %i", (unsigned __int16)v14);
      goto LABEL_8;
    case 4u:
      v45 = Physics_GetLocalClientForWorld(worldIda);
      v46 = v45;
      if ( v45 == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16667, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      v14 = (unsigned __int16)v14;
      if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
      {
        LODWORD(shadow) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", shadow) )
          __debugbreak();
      }
      if ( (unsigned int)v46 >= CgEntitySystem::ms_allocatedCount )
      {
        LODWORD(shadow) = CgEntitySystem::ms_allocatedCount;
        LODWORD(forceColor) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      if ( !CgEntitySystem::ms_entitySystemArray[v46] )
      {
        LODWORD(shadow) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", shadow) )
          __debugbreak();
      }
      v47 = CgEntitySystem::ms_entitySystemArray[v46];
      if ( (unsigned int)v14 >= 0x800 )
      {
        LODWORD(shadow) = 2048;
        LODWORD(forceColor) = v14;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v48 = (__int64)&v47->m_entities[v14];
      if ( !v48 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16670, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
        __debugbreak();
      v49 = *(_DWORD *)(v48 + 292);
      if ( v49 == 11 )
      {
        v50 = "Client Auth";
      }
      else
      {
        v50 = "Server Auth";
        if ( v49 != 12 )
          v50 = "Server General";
      }
      v51 = "Normal";
      if ( RefSubSystem != 1 )
        v51 = "Solid Brush Model";
      Com_sprintf<256>((char (*)[256])dest, v51);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v82, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Entity Id: %i %s", (unsigned int)v14, v50);
      goto LABEL_28;
    case 6u:
      Com_sprintf<256>((char (*)[256])dest, "Ragdoll %i body %i", RefSubSystem, (unsigned __int16)v14);
      goto LABEL_8;
    case 7u:
      if ( RefSubSystem >> 6 )
      {
        if ( RefSubSystem >> 6 == 1 )
          Com_sprintf<256>((char (*)[256])dest, "Func Glass Piece %i", (unsigned __int16)v14 | ((unsigned __int8)(RefSubSystem & 0x3F) << 16));
        else
          Com_sprintf<256>((char (*)[256])dest, "Unknown particle subsystem %i %i", RefSubSystem, (unsigned __int16)v14);
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "FX Particle Element %i", (unsigned __int16)v14 | ((unsigned __int8)(RefSubSystem & 0x3F) << 16));
      }
      goto LABEL_8;
    case 8u:
      Com_sprintf<256>((char (*)[256])dest, "Scriptable Collision for Scriptable %i", v11 & 0x3FFFFF);
      goto LABEL_8;
    case 0xAu:
      v55 = Physics_GetLocalClientForWorld(worldIda);
      if ( v55 == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16761, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      Model = CG_ClientModel_GetModel(v55, (unsigned __int16)v14, 0);
      if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16764, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      Com_sprintf<256>((char (*)[256])dest, "Client Model %i %s", (unsigned __int16)v14, Model->name);
      goto LABEL_28;
    case 0xBu:
      Com_sprintf<256>((char (*)[256])dest, "Cloth Proxy %i:%i", (unsigned __int16)v14, RefSubSystem);
      goto LABEL_8;
    case 0xCu:
      Com_sprintf<256>((char (*)[256])dest, "Lightweight particle proxy %i:%i", (unsigned __int16)v14, RefSubSystem);
LABEL_8:
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [r14]; x
        vmovss  [rsp+1D0h+var_198], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v76, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      break;
    default:
      break;
  }
  v57 = userDataa;
  FilterSubGroupIdFromUserData = Physics_GetFilterSubGroupIdFromUserData(userDataa);
  FilterSubGroupIdNoCollideIdFromUserData = Physics_GetFilterSubGroupIdNoCollideIdFromUserData(v57);
  if ( FilterSubGroupIdFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "SubGroup %i flagged as not colliding with SubGroup %i", (unsigned int)FilterSubGroupIdFromUserData, (unsigned int)FilterSubGroupIdNoCollideIdFromUserData);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r14]; x
      vmovss  [rsp+1D0h+var_198], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v83, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  IsClutterFromUserData = Physics_GetIsClutterFromUserData(v57);
  DontCollideWithClutterFromUserData = Physics_GetDontCollideWithClutterFromUserData(v57);
  if ( IsClutterFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "Flagged as Clutter");
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r14]; x
      vmovss  [rsp+1D0h+var_198], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v84, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  if ( DontCollideWithClutterFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "Doesn't collide with bodies flagged as Clutter");
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r14]; x
      vmovss  [rsp+1D0h+var_198], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v85, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+1D0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsContents
==============
*/
void HavokPhysics_DrawPhysicsContents(unsigned int contents, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float v104; 
  float v105; 
  float v106; 
  float v107; 
  float v108; 
  float v109; 
  float v110; 
  float v111; 
  float v112; 
  float v113; 
  float v114; 
  float v115; 
  float v116; 
  float v117; 
  float v118; 
  float v119; 
  float v120; 
  float v121; 
  float v122; 
  float v123; 
  float v124; 
  float v125; 
  float v126; 
  float v127; 
  float v128; 
  float v129; 
  float v130; 
  float v131; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RSI = x;
  _RBX = y;
  Com_sprintf<256>((char (*)[256])dest, "Contents %x", contents);
  __asm
  {
    vmovss  xmm6, [rbp+0B0h+charHeight]
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1B0h+var_178], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v104, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  xmm7, [rbp+0B0h+tabWidth]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm0, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  if ( (contents & 1) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOLID");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v105, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_FOLIAGE");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v106, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLETRIGGER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v107, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x10) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_GLASS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v108, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x20) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_WATER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v109, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_NOSHOOT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v110, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_MISSILECLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v111, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ITEM");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v112, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLECLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v113, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ITEMCLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v114, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SKY");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v115, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_NOSIGHT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v116, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_CLIPSHOT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v117, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ACTOR");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v118, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYERCLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v119, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYER_NOSIGHT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v120, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_CLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v121, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x40000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SENTIENTTRIGGER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v122, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x100000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_EXPLOSIONCLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v123, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x200000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOUNDCLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v124, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x4000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOUND_REFLECT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v125, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x400000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_NONSENTIENTTRIGGER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v126, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x800000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLE");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v127, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x1000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_MANTLE");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v128, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v129, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x20000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_USECLIP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v130, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (contents & 0x40000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYERTRIGGER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v131, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rsi], xmm1
    vmovaps xmm6, [rsp+1B0h+var_40]
    vmovaps xmm7, [rsp+1B0h+var_50]
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualityId
==============
*/
void HavokPhysics_DrawPhysicsLibraryBodyQualityId(int bodyQualityId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  hkStringPtr *m_data; 
  int v27; 
  int v82; 
  float v153; 
  float v154; 
  float v155; 
  float v156; 
  float v157; 
  float v158; 
  float v159; 
  float v160; 
  float v161; 
  float v162; 
  float v163; 
  float v164; 
  float v165; 
  float v166; 
  float v167; 
  float v168; 
  float v169; 
  float v170; 
  float v171; 
  float v172; 
  float v173; 
  float v174; 
  float v175; 
  float v176; 
  float v177; 
  float v178; 
  float v179; 
  float v180; 
  float v181; 
  float v182; 
  float v183; 
  float v184; 
  float v185; 
  float v186; 
  float v187; 
  float v188; 
  float v189; 
  float v190; 
  float v191; 
  float v192; 
  char dest[256]; 

  __asm { vmovaps [rsp+1C0h+var_50], xmm6 }
  _RBX = y;
  _RSI = x;
  if ( !s_havokPhysicsBodyQualityLibrary.asset )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Body Quality Library Loaded");
LABEL_71:
    __asm
    {
      vmovss  xmm6, [rbp+0C0h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v192, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    goto LABEL_72;
  }
  if ( bodyQualityId < 16 || bodyQualityId >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size + 16 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Body Quality Id");
    goto LABEL_71;
  }
  m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data;
  _R13 = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_data;
  __asm { vmovaps [rsp+1C0h+var_60], xmm7 }
  _R12 = 2 * (3i64 * bodyQualityId - 48);
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)m_data[bodyQualityId - 16].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  __asm
  {
    vmovss  xmm6, [rbp+0C0h+charHeight]
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v153, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  xmm7, [rbp+0C0h+tabWidth]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm0, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Priority: %i", *((unsigned int *)&_R13->m_priority + 2 * _R12));
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v154, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Supported Flags: %x", *(&_R13->m_supportedFlags.m_storage + 2 * _R12));
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v155, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  if ( (v27 & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_EXECUTION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v156, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_SINGLE_POINT_MANIFOLD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v157, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ALLOW_INTERIOR_TRIANGLE_COLLISIONS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v158, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_HIGHER_QUALITY_CONTACT_SOLVING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v159, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_NEIGHBOR_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v160, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MOTION_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v161, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIANGLE_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v162, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_CONTACT_CACHING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v163, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "REQUEST_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v164, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v165, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_FRICTION_ESTIMATION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v166, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "MERGE_FRICTION_JACOBIANS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v167, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CLIP_ANGULAR_VELOCITY");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v168, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_DISCRETE_AABB_EXPANSION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v169, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "DO_ONE_INACTIVE_COLLIDE_STEP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v170, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v27 = *(&_R13->m_supportedFlags.m_storage + 2 * _R12);
  }
  if ( (v27 & 0x80000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "POST_SOLVE_LINEAR_CAST");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v171, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rsi], xmm1
  }
  Com_sprintf<256>((char (*)[256])dest, "Requested Flags: %x", *(&_R13->m_requestedFlags.m_storage + 2 * _R12));
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v172, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  if ( (v82 & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_EXECUTION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v173, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_SINGLE_POINT_MANIFOLD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v174, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ALLOW_INTERIOR_TRIANGLE_COLLISIONS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v175, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_HIGHER_QUALITY_CONTACT_SOLVING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v176, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_NEIGHBOR_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v177, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MOTION_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v178, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIANGLE_WELDING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v179, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_CONTACT_CACHING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v180, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "REQUEST_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v181, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v182, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_FRICTION_ESTIMATION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v183, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "MERGE_FRICTION_JACOBIANS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v184, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CLIP_ANGULAR_VELOCITY");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v185, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_DISCRETE_AABB_EXPANSION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v186, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "DO_ONE_INACTIVE_COLLIDE_STEP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v187, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    v82 = *(&_R13->m_requestedFlags.m_storage + 2 * _R12);
  }
  if ( (v82 & 0x80000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "POST_SOLVE_LINEAR_CAST");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v188, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rsi], xmm1
    vmovss  xmm2, dword ptr [r13+r12*8+24h]
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r8, xmm2
  }
  Com_sprintf<256>((char (*)[256])dest, "Contact Caching Relative Movement Threshold:%.3f", *(double *)&_XMM2);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v189, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "MotionRangeBreachPolicy: %s", motionRangeBreachPolicies[*((int *)&_R13->m_motionRangeBreachPolicy + 2 * _R12)]);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v190, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "MotionWeldBreachPolicy: %s", motionRangeBreachPolicies[*((int *)&_R13->m_motionWeldBreachPolicy + 2 * _R12)]);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1C0h+var_188], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v191, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm1, dword ptr [rsi]
    vsubss  xmm2, xmm1, xmm7
    vmovaps xmm7, [rsp+1C0h+var_60]
    vmovss  dword ptr [rsi], xmm2
  }
LABEL_72:
  __asm { vmovaps xmm6, [rsp+1C0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualitys
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryBodyQualitys(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight)
{
  unsigned int v21; 
  hkStringPtr *m_data; 
  __int64 v23; 
  unsigned __int8 *v24; 
  unsigned int v25; 
  __int64 v26; 
  int setColora; 
  vec4_t *setColor; 
  float v35; 
  float v36; 
  float v37; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RBX = y;
  _RDI = x;
  __asm { vmovaps xmm7, xmm3 }
  if ( s_havokPhysicsBodyQualityLibrary.asset )
  {
    setColora = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Body Quality Library: %s - %zu bytes - %i materials", s_havokPhysicsBodyQualityLibrary.asset->name, s_havokPhysicsBodyQualityLibrary.asset->havokDataSize + 24i64, setColora);
    __asm
    {
      vmovss  xmm6, [rsp+1B8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1B8h+var_180], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v36, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
      vaddss  xmm1, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm1
    }
    v21 = 0;
    m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data;
    if ( m_data != &m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_size] )
    {
      do
      {
        v23 = -1i64;
        v24 = (unsigned __int8 *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        v25 = -1;
        do
          ++v23;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v23) );
        for ( ; v23; --v23 )
        {
          v26 = *v24++;
          v25 = (v25 >> 8) ^ g_crc32Table[v26 ^ (unsigned __int8)v25];
        }
        LODWORD(setColor) = ~v25;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i crc:%x name:%s", v21, v21 + 16, setColor, (const char *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        __asm
        {
          vmovss  xmm2, dword ptr [rbx]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+1B8h+var_180], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v37, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm0
        }
        ++v21;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_size] );
      __asm { vmovss  xmm1, dword ptr [rdi] }
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vmovss  dword ptr [rdi], xmm0
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Body Quality Library Loaded");
    __asm
    {
      vmovss  xmm6, [rsp+1B8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1B8h+var_180], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v35, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+1B8h+var_48]
    vmovaps xmm7, [rsp+1B8h+var_58]
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterialId
==============
*/
void HavokPhysics_DrawPhysicsLibraryMaterialId(int materialId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int m_storage; 
  unsigned __int8 v46; 
  unsigned __int8 v88; 
  __int64 m_value; 
  const char *v111; 
  vec4_t *setColor; 
  vec4_t *setColora; 
  double forceColor; 
  double shadow; 
  float v137; 
  float v138; 
  float v139; 
  float v140; 
  float v141; 
  float v142; 
  float v143; 
  float v144; 
  float v145; 
  float v146; 
  float v147; 
  float v148; 
  float v149; 
  float v150; 
  float v151; 
  float v152; 
  float v153; 
  float v154; 
  float v155; 
  int v157; 
  int v158; 
  int v159; 
  int v160; 
  int v161; 
  int v162; 
  int v163; 
  int v164; 
  int v165; 
  char dest[256]; 

  __asm { vmovaps [rsp+1E0h+var_50], xmm6 }
  _RBX = y;
  _RSI = x;
  if ( !s_havokPhysicsMaterialLibrary.asset )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Material Library Loaded");
LABEL_27:
    __asm
    {
      vmovss  xmm6, [rbp+0E0h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v155, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    goto LABEL_28;
  }
  if ( materialId < s_havokPhysicsMaterialLibrary.firstId.m_value || materialId > s_havokPhysicsMaterialLibrary.lastId.m_value )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Material Id");
    goto LABEL_27;
  }
  _R15 = materialId - s_havokPhysicsMaterialLibrary.firstId.m_value;
  __asm
  {
    vmovaps [rsp+1E0h+var_60], xmm7
    vmovaps [rsp+1E0h+var_70], xmm8
  }
  _R12 = s_havokPhysicsMaterialLibrary.list->m_materials.m_data;
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)s_havokPhysicsMaterialLibrary.list->m_materials.m_data[_R15].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  __asm
  {
    vmovss  xmm6, [rbp+0E0h+charHeight]
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
  }
  _EDI = 0;
  __asm { vmovss  [rsp+1E0h+var_1A8], xmm6 }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v137, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  xmm7, [rbp+0E0h+tabWidth]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm0, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Flags: %x", (unsigned int)_R12[_R15].m_flags.m_storage);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v138, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  m_storage = _R12[_R15].m_flags.m_storage;
  if ( (m_storage & 0x100000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_RESTITUTION");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v139, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    m_storage = _R12[_R15].m_flags.m_storage;
  }
  if ( (m_storage & 0x200000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIGGER_MODIFIER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v140, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    m_storage = _R12[_R15].m_flags.m_storage;
  }
  if ( (m_storage & 0x400000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_IMPULSE_CLIPPING");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v141, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    m_storage = _R12[_R15].m_flags.m_storage;
  }
  if ( (m_storage & 0x800000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MASS_CHANGER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v142, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    m_storage = _R12[_R15].m_flags.m_storage;
  }
  if ( (m_storage & 0x1000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_SOFT_CONTACTS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v143, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    m_storage = _R12[_R15].m_flags.m_storage;
  }
  if ( (m_storage & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_SURFACE_VELOCITY");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1E0h+var_1A8], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v144, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rsi], xmm1
  }
  v46 = _R12[_R15].m_triggerType.m_storage;
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( (unsigned __int8)(v46 - 2) <= 1u )
  {
    __asm { vmovd   xmm1, edi }
    _ECX = hkUFloat8::s_encodedFloats[_R12[_R15].m_triggerManifoldTolerance.m_value];
    __asm
    {
      vmovd   xmm0, ecx
      vpcmpeqd xmm2, xmm0, xmm1
    }
    v163 = (_ECX + 243712) << 12;
    __asm
    {
      vmovss  xmm1, [rsp+1E0h+var_18C]
      vblendvps xmm0, xmm1, xmm8, xmm2
      vcvtss2sd xmm3, xmm0, xmm0
      vmovq   r9, xmm3
      vmovss  [rsp+1E0h+var_190], xmm0
    }
    Com_sprintf<256>((char (*)[256])dest, "Trigger Type: %s Manifold Tolerance: %.3f", triggerTypes[v46], *(double *)&_XMM3);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Trigger Type: %s", triggerTypes[v46]);
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v145, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  v164 = _R12[_R15].m_staticFriction.m_value << 16;
  __asm { vmovss  xmm0, [rsp+1E0h+var_18C] }
  v157 = _R12[_R15].m_dynamicFriction.m_value << 16;
  __asm
  {
    vmovss  xmm3, [rsp+1E0h+var_190]
    vcvtss2sd xmm3, xmm3, xmm3
    vcvtss2sd xmm0, xmm0, xmm0
    vmovq   r9, xmm3
    vmovsd  [rsp+1E0h+setColor], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Dynamic/Static Friction: %s %.3f %.3f", combinePolicys[_R12[_R15].m_frictionCombinePolicy.m_storage], *(double *)&_XMM3, *(double *)&setColor);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v146, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  v158 = _R12[_R15].m_restitution.m_value << 16;
  __asm
  {
    vmovss  xmm3, [rsp+1E0h+var_190]
    vcvtss2sd xmm3, xmm3, xmm3
    vmovq   r9, xmm3
  }
  Com_sprintf<256>((char (*)[256])dest, "Restitution: %s %.3f", combinePolicys[_R12[_R15].m_restitutionCombinePolicy.m_storage], *(double *)&_XMM3);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v147, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm2, dword ptr [r15+r12+3Ch]
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r8, xmm2
  }
  Com_sprintf<256>((char (*)[256])dest, "Welding Tolerance: %.3f", *(double *)&_XMM2);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v148, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm3, dword ptr [r15+r12+44h]
    vmovss  xmm2, dword ptr [r15+r12+40h]
    vcvtss2sd xmm3, xmm3, xmm3
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r9, xmm3
    vmovq   r8, xmm2
  }
  Com_sprintf<256>((char (*)[256])dest, "Max Contact Impulse: %.3f Fraction to Apply:%.3f", *(double *)&_XMM2, *(double *)&_XMM3);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v149, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  v88 = _R12[_R15].m_massChangerCategory.m_storage;
  if ( v88 == 2 )
  {
    v159 = _R12[_R15].m_massChangerHeavyObjectFactor.m_value << 16;
    __asm
    {
      vmovss  xmm3, [rsp+1E0h+var_190]
      vcvtss2sd xmm3, xmm3, xmm3
      vmovq   r9, xmm3
    }
    Com_sprintf<256>((char (*)[256])dest, "Mass changer category: %s Factor:%.3f", massChangerCategorys[2], *(double *)&_XMM3);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Mass changer category: %s", massChangerCategorys[v88]);
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v150, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  m_value = (unsigned int)_R12[_R15].m_softContactDampFactor.m_value;
  __asm { vmovd   xmm1, edi }
  _ECX = hkUFloat8::s_encodedFloats[_R12[_R15].m_softContactSeparationVelocity.m_value];
  __asm
  {
    vmovd   xmm0, ecx
    vpcmpeqd xmm2, xmm0, xmm1
  }
  v160 = (_ECX + 243712) << 12;
  __asm
  {
    vmovss  xmm1, [rsp+1E0h+var_190]
    vblendvps xmm0, xmm1, xmm8, xmm2
  }
  v161 = (_DWORD)m_value << 16;
  __asm { vmovss  xmm1, [rsp+1E0h+var_190] }
  v165 = (_DWORD)m_value << 16;
  __asm
  {
    vmovss  xmm3, [rsp+1E0h+var_18C]
    vmovss  [rsp+1E0h+var_188], xmm0
    vcvtss2sd xmm0, xmm0, xmm0
    vmovsd  qword ptr [rsp+1E0h+shadow], xmm0
    vcvtss2sd xmm1, xmm1, xmm1
    vcvtss2sd xmm3, xmm3, xmm3
    vmovsd  qword ptr [rsp+1E0h+forceColor], xmm1
    vmovq   r9, xmm3
  }
  LODWORD(setColora) = _R12[_R15].m_softContactDampFactor.m_value;
  Com_sprintf<256>((char (*)[256])dest, "SoftContact Force: %i %.3f Damp: %i %.3f Separation %.3f", m_value, *(double *)&_XMM3, setColora, forceColor, shadow);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v151, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  v111 = "Surface Velocity is set";
  if ( !_R12[_R15].m_surfaceVelocity )
    v111 = "Surface Velocity not set";
  Com_sprintf<256>((char (*)[256])dest, v111);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v152, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  v162 = _R12[_R15].m_disablingCollisionsBetweenCvxCvxDynamicObjectsDistance.m_value << 16;
  __asm
  {
    vmovss  xmm3, [rsp+1E0h+var_190]
    vcvtss2sd xmm3, xmm3, xmm3
    vmovq   r9, xmm3
  }
  Com_sprintf<256>((char (*)[256])dest, "Disable Distance: %i %.3f", (unsigned int)_R12[_R15].m_disablingCollisionsBetweenCvxCvxDynamicObjectsDistance.m_value, *(double *)&_XMM3);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v153, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "User Data: %llu", _R12[_R15].m_userData);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1E0h+var_1A8], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v154, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovaps xmm8, [rsp+1E0h+var_70]
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm1, dword ptr [rsi]
    vsubss  xmm2, xmm1, xmm7
    vmovaps xmm7, [rsp+1E0h+var_60]
    vmovss  dword ptr [rsi], xmm2
  }
LABEL_28:
  __asm { vmovaps xmm6, [rsp+1E0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterials
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMaterials(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight)
{
  unsigned int v21; 
  hknpMaterial *m_data; 
  __int64 v23; 
  __int64 v24; 
  unsigned int v25; 
  unsigned __int8 *v26; 
  __int64 v27; 
  int setColora; 
  vec4_t *setColor; 
  float v36; 
  float v37; 
  float v38; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RBX = y;
  _RDI = x;
  __asm { vmovaps xmm7, xmm3 }
  if ( s_havokPhysicsMaterialLibrary.asset )
  {
    setColora = s_havokPhysicsMaterialLibrary.list->m_materials.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Material Library: %s - %zu bytes - %i materials", s_havokPhysicsMaterialLibrary.asset->name, s_havokPhysicsMaterialLibrary.asset->havokDataSize + 24i64, setColora);
    __asm
    {
      vmovss  xmm6, [rsp+1B8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1B8h+var_180], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v37, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
      vaddss  xmm1, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm1
    }
    v21 = 0;
    m_data = s_havokPhysicsMaterialLibrary.list->m_materials.m_data;
    if ( s_havokPhysicsMaterialLibrary.list->m_materials.m_data != &s_havokPhysicsMaterialLibrary.list->m_materials.m_data[s_havokPhysicsMaterialLibrary.list->m_materials.m_size] )
    {
      do
      {
        if ( s_havokPhysicsMaterialLibrary.firstId.m_value == 0xFFFF )
          v23 = 0xFFFFFFFFi64;
        else
          v23 = v21 + s_havokPhysicsMaterialLibrary.firstId.m_value;
        v24 = -1i64;
        v25 = -1;
        v26 = (unsigned __int8 *)((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        do
          ++v24;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v24) );
        for ( ; v24; --v24 )
        {
          v27 = *v26++;
          v25 = (v25 >> 8) ^ g_crc32Table[v27 ^ (unsigned __int8)v25];
        }
        LODWORD(setColor) = ~v25;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i CRC:%x name:%s", v21, v23, setColor, (const char *)((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        __asm
        {
          vmovss  xmm2, dword ptr [rbx]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+1B8h+var_180], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v38, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm0
        }
        ++v21;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsMaterialLibrary.list->m_materials.m_data[s_havokPhysicsMaterialLibrary.list->m_materials.m_size] );
      __asm { vmovss  xmm1, dword ptr [rdi] }
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vmovss  dword ptr [rdi], xmm0
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Material Library Loaded");
    __asm
    {
      vmovss  xmm6, [rsp+1B8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1B8h+var_180], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v36, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+1B8h+var_48]
    vmovaps xmm7, [rsp+1B8h+var_58]
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionProperties
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMotionProperties(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight)
{
  unsigned int v21; 
  hkStringPtr *m_data; 
  __int64 m_value; 
  __int64 v24; 
  unsigned int v25; 
  unsigned __int8 *v26; 
  __int64 v27; 
  int setColora; 
  vec4_t *setColor; 
  float v36; 
  float v37; 
  float v38; 
  hknpMotionPropertiesId result; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RBX = y;
  _RDI = x;
  __asm { vmovaps xmm7, xmm3 }
  if ( s_havokPhysicsMotionPropertiesLibrary.asset )
  {
    setColora = s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Motion Properties Library: %s - %zu bytes - %i materials", s_havokPhysicsMotionPropertiesLibrary.asset->name, s_havokPhysicsMotionPropertiesLibrary.asset->havokDataSize + 24i64, setColora);
    __asm
    {
      vmovss  xmm6, [rsp+1C8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1C8h+var_190], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v37, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
      vaddss  xmm1, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm1
    }
    v21 = 0;
    m_data = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data;
    if ( m_data != &m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_size] )
    {
      do
      {
        if ( s_havokPhysicsMotionPropertiesLibrary.firstId.m_value == 0xFFFF )
          m_value = 0xFFFFFFFFi64;
        else
          m_value = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v21)->m_value;
        v24 = -1i64;
        v25 = -1;
        v26 = (unsigned __int8 *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        do
          ++v24;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v24) );
        for ( ; v24; --v24 )
        {
          v27 = *v26++;
          v25 = (v25 >> 8) ^ g_crc32Table[v27 ^ (unsigned __int8)v25];
        }
        LODWORD(setColor) = ~v25;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i crc:%x name:%s", v21, m_value, setColor, (const char *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        __asm
        {
          vmovss  xmm2, dword ptr [rbx]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+1C8h+var_190], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v38, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm0
        }
        ++v21;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_size] );
      __asm { vmovss  xmm1, dword ptr [rdi] }
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vmovss  dword ptr [rdi], xmm0
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Motion Properties Library Loaded");
    __asm
    {
      vmovss  xmm6, [rsp+1C8h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1C8h+var_190], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v36, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+1C8h+var_48]
    vmovaps xmm7, [rsp+1C8h+var_58]
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionPropertiesId
==============
*/
void HavokPhysics_DrawPhysicsLibraryMotionPropertiesId(const hknpMotionProperties *worldMotionProperties, int motionPropertiesId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 MotionPropertiesListIndexFromMotionPropertiesId; 
  vec4_t *setColor; 
  vec4_t *setColora; 
  vec4_t *setColorb; 
  double forceColor; 
  float v164; 
  float v165; 
  float v166; 
  float v167; 
  float v168; 
  float v169; 
  float v170; 
  float v171; 
  float v172; 
  float v173; 
  float v174; 
  float v175; 
  float v176; 
  float v177; 
  float v178; 
  float v179; 
  float v180; 
  float v181; 
  float v182; 
  float v183; 
  float v184; 
  char dest[256]; 

  __asm { vmovaps [rsp+1C0h+var_50], xmm6 }
  _RSI = x;
  _RBX = y;
  _R15 = worldMotionProperties;
  if ( s_havokPhysicsMotionPropertiesLibrary.asset )
  {
    if ( motionPropertiesId >= s_havokPhysicsMotionPropertiesLibrary.firstId.m_value )
    {
      __asm { vmovaps [rsp+1C0h+var_60], xmm7 }
      MotionPropertiesListIndexFromMotionPropertiesId = (int)HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)motionPropertiesId);
      Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data[MotionPropertiesListIndexFromMotionPropertiesId].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      __asm
      {
        vmovss  xmm6, [rbp+0C0h+charHeight]
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v166, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      if ( !_R15 )
        _R15 = &s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_data[MotionPropertiesListIndexFromMotionPropertiesId];
      __asm
      {
        vmovss  xmm7, [rbp+0C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Flags: %x", (unsigned int)_R15->m_flags.m_storage);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v167, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vaddss  xmm1, xmm7, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm1
      }
      if ( (_R15->m_flags.m_storage & 0x4000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TIME_FACTOR");
        __asm
        {
          vmovss  xmm2, dword ptr [rbx]; y
          vmovss  xmm1, dword ptr [rsi]; x
          vmovss  [rsp+1C0h+var_188], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v168, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rbx]
          vmovss  dword ptr [rbx], xmm0
          vmovss  xmm1, dword ptr [rsi]
        }
      }
      __asm
      {
        vsubss  xmm0, xmm1, xmm7
        vmovss  dword ptr [rsi], xmm0
        vmovss  xmm3, dword ptr [r15+0Ch]
        vmovss  xmm2, dword ptr [r15+8]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Factors - Gravity: %.3f Time: %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v169, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+14h]
        vmovss  xmm2, dword ptr [r15+10h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Max Speeds - Linear: %.3f Angular: %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v170, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+1Ch]
        vmovss  xmm2, dword ptr [r15+18h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Damping - Linear: %.3f Angular: %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v171, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+24h]
        vmovss  xmm2, dword ptr [r15+20h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Solver Stabilization - Threshold: %.3f Reduction: %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  [rsp+1C0h+var_188], xmm6
        vmovss  xmm1, dword ptr [rsi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v172, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Deactivation");
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v173, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vaddss  xmm1, xmm7, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm1
        vmovss  xmm3, dword ptr [r15+2Ch]
        vmovss  xmm2, dword ptr [r15+28h]
        vmovss  xmm0, dword ptr [r15+30h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vcvtss2sd xmm0, xmm0, xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovsd  [rsp+1C0h+setColor], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "DistSqr: %.3f RotSqr: %.3f InvBlockSize: %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&setColor);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v174, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm0, xmm0, cs:__real@38000100
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, r8d
        vmulss  xmm2, xmm1, cs:__real@38000100
        vcvtss2sd xmm4, xmm0, xmm0
        vcvtss2sd xmm3, xmm2, xmm2
        vmovsd  qword ptr [rsp+1C0h+forceColor], xmm4
        vmovq   r9, xmm3
      }
      LODWORD(setColora) = _R15->m_deactivationSettings.m_pathingLowerThreshold;
      Com_sprintf<256>((char (*)[256])dest, "Pathing Thresholds - Upper: %i %.3f Lower: %i %.3f", (unsigned int)_R15->m_deactivationSettings.m_pathingUpperThreshold, *(double *)&_XMM3, setColora, forceColor);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v175, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Num Deactivation FrequencyPasses: %i", _R15->m_deactivationSettings.m_numDeactivationFrequencyPasses);
      __asm
      {
        vmovss  [rsp+1C0h+var_188], xmm6
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v176, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Deactivation Velocity Scale Squares - Intermediate: %i Final: %i", _R15->m_deactivationSettings.m_deactivationVelocityScaleSquare, _R15->m_deactivationSettings.m_minimumPathingVelocityScaleSquare);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v177, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Spiking - Threshold: %i Minimum Velocity Scale Squared: %i", _R15->m_deactivationSettings.m_spikingVelocityScaleThresholdSquared, _R15->m_deactivationSettings.m_minimumSpikingVelocityScaleSquared);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v178, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm1, dword ptr [rsi]
        vsubss  xmm2, xmm1, xmm7
        vmovss  dword ptr [rsi], xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "FullCast");
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v179, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vaddss  xmm1, xmm7, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm1
        vmovss  xmm3, dword ptr [r15+44h]
        vmovss  xmm2, dword ptr [r15+40h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Min Separation: %.3f Extra: %.3f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v180, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+4Ch]
        vmovss  xmm2, dword ptr [r15+48h]
        vmovss  xmm1, dword ptr [r15+50h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vcvtss2sd xmm1, xmm1, xmm1
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovsd  [rsp+1C0h+setColor], xmm1
      }
      Com_sprintf<256>((char (*)[256])dest, "TOI Separation: %.3f Extra: %.3f Accuracy: %.3f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&setColorb);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v181, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+58h]
        vmovss  xmm2, dword ptr [r15+54h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Safe Delta Relative: %.3f Absolute: %.6f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v182, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm3, dword ptr [r15+60h]
        vmovss  xmm2, dword ptr [r15+5Ch]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<256>((char (*)[256])dest, "Keep Time: %.3f Distance: %.6f", *(double *)&_XMM2, *(double *)&_XMM3);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v183, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
      Com_sprintf<256>((char (*)[256])dest, "Max Iterations: %i", (unsigned int)_R15->m_fullCastSettings.m_maxIterations);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v184, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm1, dword ptr [rsi]
        vsubss  xmm2, xmm1, xmm7
        vsubss  xmm0, xmm2, xmm7
        vmovaps xmm7, [rsp+1C0h+var_60]
        vmovss  dword ptr [rsi], xmm0
      }
    }
    else
    {
      Com_sprintf<256>((char (*)[256])dest, "Invalid Motion Properties Id");
      __asm
      {
        vmovss  xmm6, [rbp+0C0h+charHeight]
        vmovss  xmm2, dword ptr [rbx]; y
        vmovss  xmm1, dword ptr [rsi]; x
        vmovss  [rsp+1C0h+var_188], xmm6
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v165, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
      }
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Motion Properties Library Loaded");
    __asm
    {
      vmovss  xmm6, [rbp+0C0h+charHeight]
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1C0h+var_188], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v164, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+1C0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetId
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v15; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  int v19; 
  int v20; 
  int v21; 
  __int64 v22; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v23; 
  PhysicsSFXEventAsset *val; 
  float setColor; 
  int forceColor; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  char dest[256]; 

  __asm { vmovaps [rsp+1A8h+var_48], xmm6 }
  _RSI = y;
  _R15 = x;
  if ( !g_physicsSFXEventAssets )
  {
    Com_sprintf<256>((char (*)[256])dest, "No SFX Event Array");
LABEL_3:
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v41, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    goto LABEL_21;
  }
  if ( assetId < 0 || assetId >= (g_physicsSFXEventAssets->m_numElems & 0x7FFFFFFF) )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Entry %i", (unsigned int)assetId);
    goto LABEL_3;
  }
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v15 = 0;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsSFXEventAssets->m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1 )
        break;
      ++v15;
      ++m_elem;
    }
  }
  v19 = v15;
  v20 = 0;
  if ( assetId > 0 )
  {
    while ( v19 <= (int)m_hashMod )
    {
      v21 = v19 + 1;
      if ( v19 + 1 <= (int)m_hashMod )
      {
        v22 = v21;
        v23 = &g_physicsSFXEventAssets->m_elem[v21];
        do
        {
          if ( v23->key != -1 )
            break;
          ++v21;
          ++v22;
          ++v23;
        }
        while ( v22 <= m_hashMod );
      }
      ++v20;
      v19 = v21;
      if ( v20 >= assetId )
        goto LABEL_17;
    }
    goto LABEL_18;
  }
LABEL_17:
  if ( v19 > (int)m_hashMod )
  {
LABEL_18:
    Com_sprintf<256>((char (*)[256])dest, "Invalid SFX Asset Id");
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v42, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    goto LABEL_21;
  }
  val = g_physicsSFXEventAssets->m_elem[v19].val;
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( val )
  {
    Com_sprintf<256>((char (*)[256])dest, "SFXEventAsset %i Name %s Priority %i", (unsigned int)assetId, val->name, val->priority);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v44, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm0, [rsp+1A8h+tabWidth]
      vmovss  [rsp+1A8h+forceColor], xmm6
      vmovss  dword ptr [rsp+1A8h+setColor], xmm0
    }
    HavokPhysics_DrawPhysicsSFXEventAssetIdRules(&val->rules, scrPlace, _R15, _RSI, setColor, *(float *)&forceColor);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Missing Entry %i", (unsigned int)assetId);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v43, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
  }
LABEL_21:
  __asm { vmovaps xmm6, [rsp+1A8h+var_48] }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetIdRule
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetIdRule(PhysicsSFXEventAssetRule *rule, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v16; 
  const char *hitSoundAlias; 
  const char *scrapeSoundAlias; 
  __int64 numentries; 
  int v40; 
  __int64 v41; 
  char *v42; 
  __int64 v46; 
  int v51; 
  __int64 v60; 
  int v65; 
  __int64 v74; 
  int v79; 
  __int64 v88; 
  int v93; 
  __int64 v94; 
  char *v95; 
  const char *v96; 
  __int64 v100; 
  int v105; 
  __int64 v106; 
  char *v107; 
  const char *v108; 
  __int64 v112; 
  int v117; 
  __int64 v126; 
  int v131; 
  __int64 v132; 
  char *v133; 
  float setColor; 
  float setColora; 
  float setColorb; 
  float setColorc; 
  float setColord; 
  float setColore; 
  float setColorf; 
  float setColorg; 
  int forceColor; 
  int forceColora; 
  int forceColorb; 
  int forceColorc; 
  int forceColord; 
  int forceColore; 
  int forceColorf; 
  int forceColorg; 
  float v156; 
  float v157; 
  float v158; 
  float v159; 
  float v160; 
  float v161; 
  float v162; 
  float v163; 
  float v164; 
  float v165; 
  float v166; 
  float v167; 
  float v168; 
  float v169; 
  float v170; 
  float v171; 
  float v172; 
  float v173; 
  float v174; 
  float v175; 
  char v176[256]; 
  char v177[256]; 
  char dest[256]; 

  __asm { vmovaps [rsp+3C0h+var_50], xmm6 }
  _RDI = x;
  _R14 = rule;
  _RSI = y;
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, ruleNames[rule->type]);
  __asm
  {
    vmovss  xmm6, [rbp+2C0h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rdi]; x
    vmovss  [rsp+3C0h+var_388], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v156, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  v16 = _R14->type - 1;
  __asm { vmovaps [rsp+3C0h+var_60], xmm7 }
  switch ( v16 )
  {
    case 0:
      hitSoundAlias = _R14->u.soundRule.hitSoundAlias;
      if ( hitSoundAlias )
      {
        Com_sprintf<256>((char (*)[256])v176, "HitSound: %s", hitSoundAlias);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v157, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      scrapeSoundAlias = _R14->u.soundRule.scrapeSoundAlias;
      if ( scrapeSoundAlias )
      {
        Com_sprintf<256>((char (*)[256])v176, "ScrapeSound: %s", scrapeSoundAlias);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v158, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
          vmovss  xmm3, dword ptr [r14+1Ch]
          vmovss  xmm2, dword ptr [r14+18h]
          vcvtss2sd xmm3, xmm3, xmm3
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r9, xmm3
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v176, "Scrape Volume Threshold: %.2f %.2f", *(double *)&_XMM2, *(double *)&_XMM3);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v159, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      goto LABEL_59;
    case 1:
      numentries = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)numentries > 1 )
      {
        Com_sprintf<256>((char (*)[256])v176, "%i %s", numentries, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v160, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v40 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v41 = 0i64;
      do
      {
        v42 = _R14->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v177, "Surface: %s", off_147F9ABD0[*(int *)&v42[v41]]);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v161, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v42[v41 + 8], scrPlace, _RDI, _RSI, setColor, *(float *)&forceColor);
        ++v40;
        v41 += 24i64;
      }
      while ( v40 < _R14->u.materialRule.numentries );
      break;
    case 2:
      v46 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v46 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v46, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v162, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v51 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = _R14->u.soundRule.scrapeSoundAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v176, "Angle from Perpendicular: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v163, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&_RBX[_R12 + 24], scrPlace, _RDI, _RSI, setColora, *(float *)&forceColora);
        ++v51;
        _R12 += 40i64;
      }
      while ( v51 < _R14->u.materialRule.numentries );
      break;
    case 3:
      v60 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v60 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v60, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v164, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v65 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = _R14->u.soundRule.scrapeSoundAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v176, "Above Speed: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v165, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&_RBX[_R12 + 24], scrPlace, _RDI, _RSI, setColorb, *(float *)&forceColorb);
        ++v65;
        _R12 += 40i64;
      }
      while ( v65 < _R14->u.materialRule.numentries );
      break;
    case 4:
      v74 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v74 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v74, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v166, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v79 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = _R14->u.soundRule.scrapeSoundAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v176, "Above Mass: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v167, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&_RBX[_R12 + 24], scrPlace, _RDI, _RSI, setColorc, *(float *)&forceColorc);
        ++v79;
        _R12 += 40i64;
      }
      while ( v79 < _R14->u.materialRule.numentries );
      break;
    case 5:
      v88 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v88 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v88, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v168, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v93 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v94 = 0i64;
      do
      {
        v95 = _R14->u.soundRule.scrapeSoundAlias;
        v96 = "Off";
        if ( v95[v94] )
          v96 = "On";
        Com_sprintf<256>((char (*)[256])v176, "Gravity: %s", v96);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v169, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v95[v94 + 8], scrPlace, _RDI, _RSI, setColord, *(float *)&forceColord);
        ++v93;
        v94 += 24i64;
      }
      while ( v93 < _R14->u.materialRule.numentries );
      break;
    case 6:
      v100 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v100 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v100, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v170, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v105 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v106 = 0i64;
      do
      {
        v107 = _R14->u.soundRule.scrapeSoundAlias;
        v108 = "Vacuum";
        if ( v107[v106] )
          v108 = "Air";
        Com_sprintf<256>((char (*)[256])v176, "Atmosphere: %s", v108);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v171, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v107[v106 + 8], scrPlace, _RDI, _RSI, setColore, *(float *)&forceColore);
        ++v105;
        v106 += 24i64;
      }
      while ( v105 < _R14->u.materialRule.numentries );
      break;
    case 7:
      v112 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v112 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v112, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v172, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v117 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = _R14->u.soundRule.scrapeSoundAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v176, "CameraDistance: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v173, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&_RBX[_R12 + 8], scrPlace, _RDI, _RSI, setColorf, *(float *)&forceColorf);
        ++v117;
        _R12 += 24i64;
      }
      while ( v117 < _R14->u.materialRule.numentries );
      break;
    case 8:
      v126 = (unsigned int)_R14->u.materialRule.numentries;
      if ( (int)v126 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v177, "%i %s", v126, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v177, &colorWhite, 0, 1, v174, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v131 = 0;
      if ( _R14->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v132 = 0i64;
      do
      {
        v133 = _R14->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v176, "Max Events: %i", *(unsigned int *)&v133[v132]);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v176, &colorWhite, 0, 1, v175, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v133[v132 + 8], scrPlace, _RDI, _RSI, setColorg, *(float *)&forceColorg);
        ++v131;
        v132 += 24i64;
      }
      while ( v131 < _R14->u.materialRule.numentries );
      break;
    default:
      goto LABEL_60;
  }
  __asm { vmovss  xmm0, dword ptr [rdi] }
LABEL_58:
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vmovss  dword ptr [rdi], xmm0
  }
LABEL_59:
  __asm { vmovaps xmm7, [rsp+3C0h+var_60] }
LABEL_60:
  __asm { vmovaps xmm6, [rsp+3C0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetIdRules
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetIdRules(PhysicsSFXEventAssetRules *rules, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v11; 
  __int64 numrules; 
  float setColor; 
  int forceColor; 
  float v26; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovss  xmm7, [rsp+1A8h+charHeight]
  }
  _RDI = x;
  v11 = 0;
  numrules = (unsigned int)rules->numrules;
  _RBP = y;
  if ( (int)numrules > 1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", numrules, "Rules");
    __asm
    {
      vmovss  xmm2, dword ptr [rbp+0]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1A8h+var_170], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v26, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rbp+0]
      vmovss  dword ptr [rbp+0], xmm0
    }
  }
  __asm
  {
    vmovss  xmm6, [rsp+1A8h+tabWidth]
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  if ( rules->numrules > 0 )
  {
    do
    {
      __asm
      {
        vmovss  [rsp+1A8h+forceColor], xmm7
        vmovss  dword ptr [rsp+1A8h+setColor], xmm6
      }
      HavokPhysics_DrawPhysicsSFXEventAssetIdRule(&rules->rules[v11++], scrPlace, _RDI, _RBP, setColor, *(float *)&forceColor);
    }
    while ( v11 < rules->numrules );
    __asm { vmovss  xmm0, dword ptr [rdi] }
  }
  __asm
  {
    vsubss  xmm1, xmm0, xmm6
    vmovss  dword ptr [rdi], xmm1
    vmovaps xmm6, [rsp+1A8h+var_38]
    vmovaps xmm7, [rsp+1A8h+var_48]
  }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssets
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 m_numElems; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v18; 
  unsigned int v19; 
  int v20; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  const char **p_name; 
  __int64 v28; 
  __int64 v29; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v30; 
  float v32; 
  float v33; 
  float v34; 
  char dest[256]; 

  __asm { vmovaps [rsp+1A8h+var_48], xmm6 }
  _RDI = y;
  _R15 = x;
  if ( g_physicsSFXEventAssets )
  {
    Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
    AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    m_numElems = (unsigned int)g_physicsSFXEventAssets->m_numElems;
    LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
    Com_sprintf<256>((char (*)[256])dest, "%i SFX Events", m_numElems);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v33, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
    v18 = g_physicsSFXEventAssets;
    v19 = 0;
    v20 = 0;
    m_hashMod = g_physicsSFXEventAssets->m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = g_physicsSFXEventAssets->m_elem;
      for ( i = 0i64; i <= m_hashMod; ++i )
      {
        if ( m_elem->key != -1 )
          break;
        ++v20;
        ++m_elem;
      }
    }
    if ( v20 <= (int)m_hashMod )
    {
      do
      {
        p_name = &v18->m_elem[v20].val->name;
        if ( p_name )
          Com_sprintf<256>((char (*)[256])dest, "%i: %s", v19, *p_name);
        else
          Com_sprintf<256>((char (*)[256])dest, "%i: No Asset Found", v19);
        __asm
        {
          vmovss  xmm2, dword ptr [rdi]; y
          vmovss  xmm1, dword ptr [r15]; x
          vmovss  [rsp+1A8h+var_170], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v34, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rdi]
          vmovss  dword ptr [rdi], xmm0
        }
        v18 = g_physicsSFXEventAssets;
        ++v19;
        ++v20;
        v28 = g_physicsSFXEventAssets->m_hashMod;
        if ( v20 > (int)v28 )
          break;
        v29 = v20;
        v30 = &g_physicsSFXEventAssets->m_elem[v20];
        do
        {
          if ( v30->key != -1 )
            break;
          ++v20;
          ++v29;
          ++v30;
        }
        while ( v29 <= v28 );
      }
      while ( v20 <= (int)v28 );
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No SFX Event Array");
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v32, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+1A8h+var_48] }
}

/*
==============
HavokPhysics_DrawPhysicsShape
==============
*/
void HavokPhysics_DrawPhysicsShape(const hknpShape *shape, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 v13; 
  const char *v14; 
  unsigned __int8 m_storage; 
  const hknpShape *v21; 
  unsigned int v49; 
  unsigned int v50; 
  signed int i; 
  const char *MapEntsShapeName; 
  const char *NameForShape; 
  const char *v63; 
  char *fmt; 
  float fmta; 
  int forceColor; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  char dest[256]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-58h], xmm7 }
  _RDI = y;
  _RSI = shape;
  _RBP = x;
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16830, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  v13 = (__int64)_RSI->getMutationSignals(_RSI);
  v14 = "Type:%s MUTABLE";
  if ( !v13 )
    v14 = "Type:%s";
  Com_sprintf<256>((char (*)[256])dest, v14, shapeTypeNames_0[_RSI->m_type.m_storage]);
  __asm
  {
    vmovss  xmm7, [rsp+1B8h+charHeight]
    vmovss  xmm2, dword ptr [rdi]; y
    vmovss  xmm1, dword ptr [rbp+0]; x
    vmovss  [rsp+1B8h+var_180], xmm7
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v71, 0);
  __asm
  {
    vaddss  xmm0, xmm7, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  m_storage = _RSI->m_type.m_storage;
  if ( m_storage <= 1u )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rsi+20h]
      vcvtss2sd xmm2, xmm2, xmm2
      vmovq   r8, xmm2
    }
    Com_sprintf<256>((char (*)[256])dest, "Radius:%.2f", *(double *)&_XMM2);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v74, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
    v49 = _RSI->getNumberOfFaces((hknpShape *)_RSI);
    v50 = _RSI->getNumberOfSupportSpheres((hknpShape *)_RSI);
    Com_sprintf<256>((char (*)[256])dest, "Spheres:%i Faces:%i", v50, v49);
    goto LABEL_12;
  }
  if ( m_storage <= 3u )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rsi+20h]
      vcvtss2sd xmm2, xmm2, xmm2
      vmovq   r8, xmm2
    }
    Com_sprintf<256>((char (*)[256])dest, "Radius:%.2f", *(double *)&_XMM2);
LABEL_12:
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v75, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
    goto LABEL_13;
  }
  if ( m_storage == 17 )
  {
    __asm { vmovups xmm2, xmmword ptr [rsi+40h] }
    v21 = (const hknpShape *)_RSI[1].__vftable;
    __asm
    {
      vshufps xmm1, xmm2, xmm2, 55h ; 'U'
      vshufps xmm0, xmm2, xmm2, 0AAh ; ''
      vcvtss2sd xmm3, xmm1, xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm4, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovaps [rsp+1B8h+var_48], xmm6
      vmovsd  [rsp+1B8h+fmt], xmm4
    }
    Com_sprintf<256>((char (*)[256])dest, "Scale:%.2f %.2f %.2f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmt);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v72, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
    Com_sprintf<256>((char (*)[256])dest, "Core Shape:");
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v73, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  xmm6, [rsp+1B8h+tabWidth]
      vmovss  dword ptr [rdi], xmm0
      vaddss  xmm0, xmm6, dword ptr [rbp+0]
      vmovss  [rsp+1B8h+forceColor], xmm7
      vmovss  dword ptr [rbp+0], xmm0
      vmovss  dword ptr [rsp+1B8h+fmt], xmm6
    }
    HavokPhysics_DrawPhysicsShape(v21, scrPlace, _RBP, _RDI, fmta, *(float *)&forceColor);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0]
      vsubss  xmm1, xmm0, xmm6
      vmovaps xmm6, [rsp+1B8h+var_48]
      vmovss  dword ptr [rbp+0], xmm1
    }
  }
LABEL_13:
  for ( i = 0; i < WorldCollision_GetMapEntsShapeCount(); ++i )
  {
    if ( WorldCollision_GetMapEntsShape(i) == _RSI )
    {
      MapEntsShapeName = WorldCollision_GetMapEntsShapeName(i);
      Com_sprintf<256>((char (*)[256])dest, "MapEnts Shape: %s", MapEntsShapeName);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi]; y
        vmovss  xmm1, dword ptr [rbp+0]; x
        vmovss  [rsp+1B8h+var_180], xmm7
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v76, 0);
      __asm
      {
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
    }
  }
  NameForShape = StaticModels_Debug_GetNameForShape(_RSI);
  if ( NameForShape )
  {
    Com_sprintf<256>((char (*)[256])dest, "Static Model: %s", NameForShape);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v77, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  v63 = PatchCollision_Debug_GetNameForShape(_RSI);
  if ( v63 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Patch Collision: %s", v63);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [rbp+0]; x
      vmovss  [rsp+1B8h+var_180], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v78, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  __asm { vmovaps xmm7, [rsp+1B8h+var_58] }
}

/*
==============
HavokPhysics_DrawPhysicsSurfaceFlags
==============
*/
void HavokPhysics_DrawPhysicsSurfaceFlags(int surfFlags, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char v89; 
  float v98; 
  float v99; 
  float v100; 
  float v101; 
  float v102; 
  float v103; 
  float v104; 
  float v105; 
  float v106; 
  float v107; 
  float v108; 
  float v109; 
  float v110; 
  float v111; 
  float v112; 
  float v113; 
  float v114; 
  float v115; 
  float v116; 
  float v117; 
  float v118; 
  float v119; 
  float v120; 
  float v121; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RSI = x;
  _RBX = y;
  Com_sprintf<256>((char (*)[256])dest, "Surface Flags %x", (unsigned int)surfFlags);
  __asm
  {
    vmovss  xmm6, [rbp+0B0h+charHeight]
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1B0h+var_178], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v98, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  xmm7, [rbp+0B0h+tabWidth]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm0, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Flags");
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1B0h+var_178], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v99, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  if ( !surfFlags )
  {
    Com_sprintf<256>((char (*)[256])dest, "Default");
LABEL_45:
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v119, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
    goto LABEL_46;
  }
  if ( surfFlags == -1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid");
    goto LABEL_45;
  }
  if ( (surfFlags & 1) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODAMAGE");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v100, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SLICK");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v101, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SKY");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v102, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_LADDER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v103, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x10) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOIMPACT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v104, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x20) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOMARKS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v105, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_HDR_PORTAL");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v106, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODRAW");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v107, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NO_PENETRATE");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v108, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_STAIRS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v109, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOLIGHTMAP");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v110, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_GLASS_EXPOSED");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v111, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SOFT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v112, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOSTEPS");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v113, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NONSOLID");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v114, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODLIGHT");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v115, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x40000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOCASTSHADOW");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v116, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_MANTLE_ON");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v117, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( (surfFlags & 0x4000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_MANTLE_OVER");
    __asm
    {
      vmovss  xmm2, dword ptr [rbx]; y
      vmovss  xmm1, dword ptr [rsi]; x
      vmovss  [rsp+1B0h+var_178], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v118, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
    }
  }
  if ( surfFlags < 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_PORTAL");
    goto LABEL_45;
  }
LABEL_46:
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rsi], xmm1
  }
  Com_sprintf<256>((char (*)[256])dest, "Types");
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1B0h+var_178], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v120, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm7, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  v89 = (surfFlags >> 19) & 0x3F;
  if ( v89 )
  {
    switch ( v89 )
    {
      case 1:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BARK");
        break;
      case 2:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BRICK");
        break;
      case 3:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_SOLID");
        break;
      case 4:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CLOTH");
        break;
      case 5:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CONCRETE_DRY");
        break;
      case 6:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DIRT");
        break;
      case 7:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FLESH");
        break;
      case 8:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FOLIAGE_DRY");
        break;
      case 9:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_PANE");
        break;
      case 10:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRASS_SHORT");
        break;
      case 11:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRAVEL");
        break;
      case 12:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ICE_SOLID");
        break;
      case 13:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_THICK");
        break;
      case 14:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_GRATE");
        break;
      case 15:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_MUD");
        break;
      case 16:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PAPER");
        break;
      case 17:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PLASTER");
        break;
      case 18:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ROCK");
        break;
      case 19:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SAND");
        break;
      case 20:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SNOW");
        break;
      case 21:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER");
        break;
      case 22:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WOOD_SOLID");
        break;
      case 23:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ASPHALT_DRY");
        break;
      case 24:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CERAMIC");
        break;
      case 25:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PLASTIC");
        break;
      case 26:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_RUBBER");
        break;
      case 27:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FRUIT");
        break;
      case 28:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_CAR");
        break;
      case 29:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_RIOTSHIELD");
        break;
      case 30:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SLUSH");
        break;
      case 31:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ASPHALT_WET");
        break;
      case 32:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_WOOD");
        break;
      case 33:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_METAL");
        break;
      case 34:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CONCRETE_WET");
        break;
      case 35:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CUSHION");
        break;
      case 36:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DEFAULT");
        break;
      case 37:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FOLIAGE_WET");
        break;
      case 38:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_BROKEN");
        break;
      case 39:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_SOLID");
        break;
      case 40:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_VEHICLE");
        break;
      case 41:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRASS_TALL");
        break;
      case 42:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ICE_THIN");
        break;
      case 43:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_THIN");
        break;
      case 44:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_HELICOPTER");
        break;
      case 45:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_TILE");
        break;
      case 46:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_TANK");
        break;
      case 47:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BODY_ARMOR");
        break;
      case 48:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DRYWALL");
        break;
      case 49:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_MUD_RIVERBED");
        break;
      case 50:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER_KNEE");
        break;
      case 51:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER_WAIST");
        break;
      case 52:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WOOD_FLOOR");
        break;
      case 53:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN1");
        break;
      case 54:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN2");
        break;
      case 55:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN3");
        break;
      case 56:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN4");
        break;
      case 57:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN5");
        break;
      case 58:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN6");
        break;
      case 59:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN7");
        break;
      case 60:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN8");
        break;
      case 61:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN9");
        break;
      case 62:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CINDERBLOCK");
        break;
      default:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CODE_RESERVED");
        break;
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_NONE");
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbx]; y
    vmovss  xmm1, dword ptr [rsi]; x
    vmovss  [rsp+1B0h+var_178], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v121, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm0, dword ptr [rsi]
    vsubss  xmm1, xmm0, xmm7
    vsubss  xmm2, xmm1, xmm7
    vmovss  dword ptr [rsi], xmm2
    vmovaps xmm6, [rsp+1B0h+var_40]
    vmovaps xmm7, [rsp+1B0h+var_50]
  }
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetId
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v15; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  int v19; 
  int v20; 
  int v21; 
  __int64 v22; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v23; 
  PhysicsVFXEventAsset *val; 
  float setColor; 
  int forceColor; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  char dest[256]; 

  __asm { vmovaps [rsp+1A8h+var_48], xmm6 }
  _RSI = y;
  _R15 = x;
  if ( !g_physicsVFXEventAssets )
  {
    Com_sprintf<256>((char (*)[256])dest, "No VFX Event Array");
LABEL_3:
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v41, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    goto LABEL_21;
  }
  if ( assetId < 0 || assetId >= (g_physicsVFXEventAssets->m_numElems & 0x7FFFFFFF) )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Entry %i", (unsigned int)assetId);
    goto LABEL_3;
  }
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v15 = 0;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsVFXEventAssets->m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1 )
        break;
      ++v15;
      ++m_elem;
    }
  }
  v19 = v15;
  v20 = 0;
  if ( assetId > 0 )
  {
    while ( v19 <= (int)m_hashMod )
    {
      v21 = v19 + 1;
      if ( v19 + 1 <= (int)m_hashMod )
      {
        v22 = v21;
        v23 = &g_physicsVFXEventAssets->m_elem[v21];
        do
        {
          if ( v23->key != -1 )
            break;
          ++v21;
          ++v22;
          ++v23;
        }
        while ( v22 <= m_hashMod );
      }
      ++v20;
      v19 = v21;
      if ( v20 >= assetId )
        goto LABEL_17;
    }
    goto LABEL_18;
  }
LABEL_17:
  if ( v19 > (int)m_hashMod )
  {
LABEL_18:
    Com_sprintf<256>((char (*)[256])dest, "Invalid VFX Asset Id");
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v42, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    goto LABEL_21;
  }
  val = g_physicsVFXEventAssets->m_elem[v19].val;
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( val )
  {
    Com_sprintf<256>((char (*)[256])dest, "VFXEventAsset %i Name %s Priority %i", (unsigned int)assetId, val->name, val->priority);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v44, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm0, [rsp+1A8h+tabWidth]
      vmovss  [rsp+1A8h+forceColor], xmm6
      vmovss  dword ptr [rsp+1A8h+setColor], xmm0
    }
    HavokPhysics_DrawPhysicsVFXEventAssetIdRules(&val->rules, scrPlace, _R15, _RSI, setColor, *(float *)&forceColor);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Missing Entry %i", (unsigned int)assetId);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v43, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
  }
LABEL_21:
  __asm { vmovaps xmm6, [rsp+1A8h+var_48] }
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetIdRule
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetIdRule(PhysicsVFXEventAssetRule *rule, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int32 v16; 
  char *hitParticleEffectAlias; 
  char *scrapeParticleEffectAlias; 
  __int64 numentries; 
  int v31; 
  __int64 v32; 
  char *v33; 
  __int64 v37; 
  int v42; 
  __int64 v51; 
  int v56; 
  __int64 v65; 
  int v70; 
  __int64 v79; 
  int v84; 
  __int64 v85; 
  char *v86; 
  const char *v87; 
  __int64 v91; 
  int v96; 
  __int64 v97; 
  char *v98; 
  const char *v99; 
  __int64 v103; 
  int v108; 
  __int64 v117; 
  int v122; 
  __int64 v123; 
  char *v124; 
  float setColor; 
  float setColora; 
  float setColorb; 
  float setColorc; 
  float setColord; 
  float setColore; 
  float setColorf; 
  float setColorg; 
  int forceColor; 
  int forceColora; 
  int forceColorb; 
  int forceColorc; 
  int forceColord; 
  int forceColore; 
  int forceColorf; 
  int forceColorg; 
  float v147; 
  float v148; 
  float v149; 
  float v150; 
  float v151; 
  float v152; 
  float v153; 
  float v154; 
  float v155; 
  float v156; 
  float v157; 
  float v158; 
  float v159; 
  float v160; 
  float v161; 
  float v162; 
  float v163; 
  float v164; 
  float v165; 
  char v166[256]; 
  char v167[256]; 
  char dest[256]; 

  __asm { vmovaps [rsp+3C0h+var_50], xmm6 }
  _RDI = x;
  _RSI = y;
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, ruleNames_0[rule->type]);
  __asm
  {
    vmovss  xmm6, [rbp+2C0h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rdi]; x
    vmovss  [rsp+3C0h+var_388], xmm6
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v147, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  v16 = rule->type - 1;
  __asm { vmovaps [rsp+3C0h+var_60], xmm7 }
  switch ( v16 )
  {
    case 0:
      hitParticleEffectAlias = rule->u.particleEffectRule.hitParticleEffectAlias;
      if ( hitParticleEffectAlias )
      {
        Com_sprintf<256>((char (*)[256])v166, "Hit Particle Effect: %s", hitParticleEffectAlias);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v148, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      scrapeParticleEffectAlias = rule->u.particleEffectRule.scrapeParticleEffectAlias;
      if ( scrapeParticleEffectAlias )
      {
        Com_sprintf<256>((char (*)[256])v166, "Scrape Particle Effect: %s", scrapeParticleEffectAlias);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v149, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      goto LABEL_59;
    case 1:
      numentries = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)numentries > 1 )
      {
        Com_sprintf<256>((char (*)[256])v166, "%i %s", numentries, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v150, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v31 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v32 = 0i64;
      do
      {
        v33 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v167, "Surface: %s", off_147F9AEA0[*(int *)&v33[v32]]);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v151, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v33[v32 + 8], scrPlace, _RDI, _RSI, setColor, *(float *)&forceColor);
        ++v31;
        v32 += 24i64;
      }
      while ( v31 < rule->u.materialRule.numentries );
      break;
    case 2:
      v37 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v37 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v37, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v152, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v42 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v166, "Angle from Perpendicular: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v153, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&_RBX[_R12 + 8], scrPlace, _RDI, _RSI, setColora, *(float *)&forceColora);
        ++v42;
        _R12 += 24i64;
      }
      while ( v42 < rule->u.materialRule.numentries );
      break;
    case 3:
      v51 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v51 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v51, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v154, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v56 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v166, "Above Speed: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v155, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&_RBX[_R12 + 8], scrPlace, _RDI, _RSI, setColorb, *(float *)&forceColorb);
        ++v56;
        _R12 += 24i64;
      }
      while ( v56 < rule->u.materialRule.numentries );
      break;
    case 4:
      v65 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v65 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v65, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v156, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v70 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v166, "Above Mass: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v157, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&_RBX[_R12 + 8], scrPlace, _RDI, _RSI, setColorc, *(float *)&forceColorc);
        ++v70;
        _R12 += 24i64;
      }
      while ( v70 < rule->u.materialRule.numentries );
      break;
    case 5:
      v79 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v79 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v79, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v158, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v84 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v85 = 0i64;
      do
      {
        v86 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        v87 = "Off";
        if ( v86[v85] )
          v87 = "On";
        Com_sprintf<256>((char (*)[256])v166, "Gravity: %s", v87);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v159, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v86[v85 + 8], scrPlace, _RDI, _RSI, setColord, *(float *)&forceColord);
        ++v84;
        v85 += 24i64;
      }
      while ( v84 < rule->u.materialRule.numentries );
      break;
    case 6:
      v91 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v91 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v91, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v160, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v96 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v97 = 0i64;
      do
      {
        v98 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        v99 = "Vacuum";
        if ( v98[v97] )
          v99 = "Air";
        Com_sprintf<256>((char (*)[256])v166, "Atmosphere: %s", v99);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v161, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v98[v97 + 8], scrPlace, _RDI, _RSI, setColore, *(float *)&forceColore);
        ++v96;
        v97 += 24i64;
      }
      while ( v96 < rule->u.materialRule.numentries );
      break;
    case 7:
      v103 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v103 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v103, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v162, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v108 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      _R12 = 0i64;
      do
      {
        _RBX = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        __asm
        {
          vmovss  xmm2, dword ptr [r12+rbx]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_sprintf<256>((char (*)[256])v166, "CameraDistance: %.2f", *(double *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v163, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&_RBX[_R12 + 8], scrPlace, _RDI, _RSI, setColorf, *(float *)&forceColorf);
        ++v108;
        _R12 += 24i64;
      }
      while ( v108 < rule->u.materialRule.numentries );
      break;
    case 8:
      v117 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v117 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v167, "%i %s", v117, "Entries");
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v167, &colorWhite, 0, 1, v164, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rbp+2C0h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v122 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v123 = 0i64;
      do
      {
        v124 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v166, "Max Events: %i", *(unsigned int *)&v124[v123]);
        __asm
        {
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [rdi]; x
          vmovss  [rsp+3C0h+var_388], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, v166, &colorWhite, 0, 1, v165, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  [rsp+3C0h+forceColor], xmm6
          vmovss  dword ptr [rsi], xmm0
          vmovss  dword ptr [rsp+3C0h+setColor], xmm7
        }
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v124[v123 + 8], scrPlace, _RDI, _RSI, setColorg, *(float *)&forceColorg);
        ++v122;
        v123 += 24i64;
      }
      while ( v122 < rule->u.materialRule.numentries );
      break;
    default:
      goto LABEL_60;
  }
  __asm { vmovss  xmm0, dword ptr [rdi] }
LABEL_58:
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vmovss  dword ptr [rdi], xmm0
  }
LABEL_59:
  __asm { vmovaps xmm7, [rsp+3C0h+var_60] }
LABEL_60:
  __asm { vmovaps xmm6, [rsp+3C0h+var_50] }
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetIdRules
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetIdRules(PhysicsVFXEventAssetRules *rules, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v11; 
  __int64 numrules; 
  float setColor; 
  int forceColor; 
  float v26; 
  char dest[256]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovss  xmm7, [rsp+1A8h+charHeight]
  }
  _RDI = x;
  v11 = 0;
  numrules = (unsigned int)rules->numrules;
  _RBP = y;
  if ( (int)numrules > 1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", numrules, "Rules");
    __asm
    {
      vmovss  xmm2, dword ptr [rbp+0]; y
      vmovss  xmm1, dword ptr [rdi]; x
      vmovss  [rsp+1A8h+var_170], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v26, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rbp+0]
      vmovss  dword ptr [rbp+0], xmm0
    }
  }
  __asm
  {
    vmovss  xmm6, [rsp+1A8h+tabWidth]
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
  }
  if ( rules->numrules > 0 )
  {
    do
    {
      __asm
      {
        vmovss  [rsp+1A8h+forceColor], xmm7
        vmovss  dword ptr [rsp+1A8h+setColor], xmm6
      }
      HavokPhysics_DrawPhysicsVFXEventAssetIdRule(&rules->rules[v11++], scrPlace, _RDI, _RBP, setColor, *(float *)&forceColor);
    }
    while ( v11 < rules->numrules );
    __asm { vmovss  xmm0, dword ptr [rdi] }
  }
  __asm
  {
    vsubss  xmm1, xmm0, xmm6
    vmovss  dword ptr [rdi], xmm1
    vmovaps xmm6, [rsp+1A8h+var_38]
    vmovaps xmm7, [rsp+1A8h+var_48]
  }
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssets
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 m_numElems; 
  unsigned int v18; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v19; 
  int v20; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  const char **p_name; 
  __int64 v28; 
  __int64 v29; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v30; 
  float v32; 
  float v33; 
  float v34; 
  char dest[256]; 

  __asm { vmovaps [rsp+1A8h+var_48], xmm6 }
  _RDI = y;
  _R15 = x;
  if ( g_physicsVFXEventAssets )
  {
    m_numElems = (unsigned int)g_physicsVFXEventAssets->m_numElems;
    LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
    Com_sprintf<256>((char (*)[256])dest, "%i VFX Events", m_numElems);
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v33, 0);
    __asm { vaddss  xmm0, xmm6, dword ptr [rdi] }
    v18 = 0;
    __asm { vmovss  dword ptr [rdi], xmm0 }
    Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
    AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    v19 = g_physicsVFXEventAssets;
    v20 = 0;
    m_hashMod = g_physicsVFXEventAssets->m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = g_physicsVFXEventAssets->m_elem;
      for ( i = 0i64; i <= m_hashMod; ++i )
      {
        if ( m_elem->key != -1 )
          break;
        ++v20;
        ++m_elem;
      }
    }
    if ( v20 <= (int)m_hashMod )
    {
      do
      {
        p_name = &v19->m_elem[v20].val->name;
        if ( p_name )
          Com_sprintf<256>((char (*)[256])dest, "%i: %s", v18, *p_name);
        else
          Com_sprintf<256>((char (*)[256])dest, "%i: No Asset Found", v18);
        __asm
        {
          vmovss  xmm2, dword ptr [rdi]; y
          vmovss  xmm1, dword ptr [r15]; x
          vmovss  [rsp+1A8h+var_170], xmm6
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v34, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rdi]
          vmovss  dword ptr [rdi], xmm0
        }
        v19 = g_physicsVFXEventAssets;
        ++v18;
        ++v20;
        v28 = g_physicsVFXEventAssets->m_hashMod;
        if ( v20 > (int)v28 )
          break;
        v29 = v20;
        v30 = &g_physicsVFXEventAssets->m_elem[v20];
        do
        {
          if ( v30->key != -1 )
            break;
          ++v20;
          ++v29;
          ++v30;
        }
        while ( v29 <= v28 );
      }
      while ( v20 <= (int)v28 );
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No VFX Event Array");
    __asm
    {
      vmovss  xmm6, [rsp+1A8h+charHeight]
      vmovss  xmm2, dword ptr [rdi]; y
      vmovss  xmm1, dword ptr [r15]; x
      vmovss  [rsp+1A8h+var_170], xmm6
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v32, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rdi]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+1A8h+var_48] }
}

/*
==============
HavokPhysics_DrawPhysicsXModelId
==============
*/
void HavokPhysics_DrawPhysicsXModelId(bool indexByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v11; 
  int v12; 
  bool v13; 
  __int64 v15; 
  int v16; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v17; 
  __int64 v18; 
  const XModel *v19; 
  hkMemoryAllocator *v20; 
  int v21; 
  hkBool *(__fastcall *v26)(hkBool *, const XModel *, const XModel *); 
  const XModel *v27; 
  XModelDetailCollision *detailCollision; 
  unsigned int physicsLODDataSize; 
  __int64 v30; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  const HavokPhysicsXModelLOD *v35; 
  int v42; 
  hknpShape *v43; 
  int v52; 
  __int64 v53; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *m_data; 
  int m_surfaceFlags; 
  unsigned int m_collisionFilterInfo; 
  hkMemoryAllocator *v69; 
  char *fmt; 
  const vec4_t *fmta; 
  char *fmtb; 
  float fmtc; 
  float fmtd; 
  __int64 forceColor; 
  int forceColora; 
  int forceColorb; 
  float v81; 
  float v82; 
  float v83; 
  float v84; 
  float v85; 
  float v86; 
  float v87; 
  const XModel **array; 
  __int64 v90; 
  ScreenPlacement *scrPlacea; 
  __int64 v92; 
  __int64 v93; 
  char dest[256]; 
  char v95; 
  void *retaddr; 

  _RAX = &retaddr;
  v93 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R14 = x;
  v11 = scrPlace;
  scrPlacea = (ScreenPlacement *)scrPlace;
  v12 = assetId;
  LODWORD(v92) = assetId;
  v13 = indexByName;
  _RSI = y;
  v15 = 0i64;
  array = NULL;
  v90 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19854, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tDebug rendering Havok Physics XModel LOD ID, but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v16 = 0;
  v17 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v18 = 0i64;
    do
    {
      v19 = v17->m_data[v18];
      if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19860, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      v20 = hkMemHeapAllocator();
      v21 = v90;
      if ( (_DWORD)v90 == (HIDWORD(v90) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v20, &array, 8);
        v21 = v90;
      }
      array[v21] = v19;
      LODWORD(v90) = v90 + 1;
      ++v16;
      ++v18;
      v17 = s_havokPhysicsXModels;
    }
    while ( v16 < s_havokPhysicsXModels->m_size );
    v12 = v92;
    v11 = scrPlacea;
    v13 = indexByName;
    v15 = 0i64;
  }
  Com_sprintf<256>((char (*)[256])dest, "%i Assets found", (unsigned int)v90);
  __asm
  {
    vmovss  xmm6, [rbp+0E0h+charHeight]
    vmovss  [rsp+1E0h+var_1A8], xmm6
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v81, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  if ( v12 < 0 || v12 >= (int)v90 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i is invalid index", (unsigned int)v12);
    __asm
    {
      vmovss  [rsp+1E0h+var_1A8], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v87, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
    goto LABEL_43;
  }
  if ( v13 )
  {
    if ( (int)v90 <= 1 )
      goto LABEL_21;
    v26 = HavokPhysics_XModelsSortByName;
  }
  else
  {
    if ( (int)v90 <= 1 )
      goto LABEL_21;
    v26 = HavokPhysics_XModelsSortByMemory;
  }
  hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v90 - 1, v26);
LABEL_21:
  v27 = array[v12];
  if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19888, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
    __debugbreak();
  detailCollision = v27->detailCollision;
  if ( detailCollision )
    physicsLODDataSize = detailCollision->physicsLODDataSize;
  else
    physicsLODDataSize = 0;
  v30 = physicsLODDataSize + 12;
  LODWORD(forceColor) = v27->collLod;
  fmt = (char *)v27->name;
  if ( v27->physicsAsset )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i: size:%6i name:%s collLod:%i", (unsigned int)v12, v30, fmt, forceColor);
    __asm { vmovss  [rsp+1E0h+var_1A8], xmm6 }
    fmta = &colorWhite;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset without physics asset %i: size:%6i name:%s collLod:%i", (unsigned int)v12, v30, fmt, forceColor);
    __asm { vmovss  [rsp+1E0h+var_1A8], xmm6 }
    fmta = &colorRed;
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [r14]; x
  }
  Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, fmta, 0, 1, v82, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
  }
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v27->detailCollision);
  v35 = HavokPhysicsXModelLODFromDetailCol;
  __asm { vmovss  xmm7, [rbp+0E0h+tabWidth] }
  if ( HavokPhysicsXModelLODFromDetailCol )
  {
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
    }
    Com_sprintf<256>((char (*)[256])dest, "%i Shapes", (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size);
    __asm
    {
      vmovss  [rsp+1E0h+var_1A8], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v83, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vaddss  xmm1, xmm7, dword ptr [r14]
      vmovss  dword ptr [r14], xmm1
    }
    v42 = 0;
    if ( v35->m_shapes.m_size > 0 )
    {
      do
      {
        v43 = v35->m_shapes.m_data[v15];
        if ( !v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19916, ASSERT_TYPE_ASSERT, "(compressedMeshShape)", (const char *)&queryFormat, "compressedMeshShape") )
          __debugbreak();
        LODWORD(fmtb) = v43[1].m_properties.m_ptr;
        Com_sprintf<256>((char (*)[256])dest, "Shape %i: Bone:%s Tris:%i", (unsigned int)v42, (const char *)((unsigned __int64)v35->m_bodyNames.m_data[v15].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), fmtb);
        __asm
        {
          vmovss  [rsp+1E0h+var_1A8], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v84, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
        }
        ++v42;
        ++v15;
      }
      while ( v42 < v35->m_shapes.m_size );
      __asm { vmovss  xmm1, dword ptr [r14] }
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vmovss  dword ptr [r14], xmm0
    }
    Com_sprintf<256>((char (*)[256])dest, "%i Shape Tag Datas", (unsigned int)v35->m_shapeTagData.m_size);
    __asm
    {
      vmovss  [rsp+1E0h+var_1A8], xmm6
      vmovss  xmm2, dword ptr [rsi]; y
      vmovss  xmm1, dword ptr [r14]; x
    }
    Physics_DrawDebugString(v11, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v85, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
      vaddss  xmm1, xmm7, dword ptr [r14]
      vmovss  dword ptr [r14], xmm1
    }
    v52 = 0;
    if ( v35->m_shapeTagData.m_size > 0 )
    {
      v53 = 0i64;
      do
      {
        m_data = v35->m_shapeTagData.m_data;
        m_surfaceFlags = m_data[v53].m_surfaceFlags;
        m_collisionFilterInfo = m_data[v53].m_collisionFilterInfo;
        Com_sprintf<256>((char (*)[256])dest, "Shape Tag %i", (unsigned int)v52);
        __asm
        {
          vmovss  [rsp+1E0h+var_1A8], xmm6
          vmovss  xmm2, dword ptr [rsi]; y
          vmovss  xmm1, dword ptr [r14]; x
        }
        Physics_DrawDebugString(scrPlacea, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v86, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rsi]
          vmovss  dword ptr [rsi], xmm0
          vaddss  xmm1, xmm7, dword ptr [r14]
          vmovss  dword ptr [r14], xmm1
          vmovss  dword ptr [rsp+1E0h+forceColor], xmm6
          vmovss  dword ptr [rsp+1E0h+fmt], xmm7
        }
        HavokPhysics_DrawPhysicsSurfaceFlags(m_surfaceFlags, scrPlacea, _R14, y, fmtc, *(float *)&forceColora);
        __asm
        {
          vmovss  dword ptr [rsp+1E0h+forceColor], xmm6
          vmovss  dword ptr [rsp+1E0h+fmt], xmm7
        }
        HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlacea, _R14, y, fmtd, *(float *)&forceColorb);
        __asm
        {
          vmovss  xmm0, dword ptr [r14]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [r14], xmm1
        }
        ++v52;
        ++v53;
      }
      while ( v52 < v35->m_shapeTagData.m_size );
    }
    __asm
    {
      vsubss  xmm0, xmm1, xmm7
      vsubss  xmm0, xmm0, xmm7
      vmovss  dword ptr [r14], xmm0
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r14]
      vsubss  xmm0, xmm0, xmm7
      vmovss  dword ptr [r14], xmm0
    }
  }
LABEL_43:
  v69 = hkMemHeapAllocator();
  LODWORD(v90) = 0;
  if ( v90 >= 0 )
    hkMemoryAllocator::bufFree2(v69, array, 8, HIDWORD(v90) & 0x3FFFFFFF);
  _R11 = &v95;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawPhysicsXModels
==============
*/
void HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType sortType, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v11; 
  int v12; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v13; 
  __int64 v14; 
  const XModel *v15; 
  XModelDetailCollision *detailCollision; 
  unsigned int physicsLODDataSize; 
  hkMemoryAllocator *v18; 
  int v19; 
  __int64 m_numElems; 
  ScreenPlacement *v24; 
  Physics_DebugXModelSortType v29; 
  int v30; 
  hkBool *(__fastcall *v31)(hkBool *, const XModel *, const XModel *); 
  unsigned int v34; 
  const char ***v35; 
  const char **v36; 
  char v37; 
  bool v38; 
  const XModelDetailCollision *v39; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  const char *v41; 
  const vec4_t *v42; 
  const PhysicsAsset *v43; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsXModelLOD *v48; 
  hkMemoryAllocator *v50; 
  char *fmt; 
  __int64 forceColor; 
  __int64 shadow; 
  float v57; 
  float v58; 
  float v59; 
  const XModel **array; 
  __int64 v62; 
  ScreenPlacement *scrPlacea; 
  float *v64; 
  __int64 v65; 
  char dest[256]; 
  char v67; 
  void *retaddr; 

  _RAX = &retaddr;
  v65 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R15 = y;
  _R13 = x;
  v64 = x;
  scrPlacea = (ScreenPlacement *)scrPlace;
  array = NULL;
  v62 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19739, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tDebug rendering Havok Physics XModel LODs, but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v11 = 0;
  v12 = 0;
  v13 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v14 = 0i64;
    do
    {
      v15 = v13->m_data[v14];
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19746, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      detailCollision = v15->detailCollision;
      if ( detailCollision )
        physicsLODDataSize = detailCollision->physicsLODDataSize;
      else
        physicsLODDataSize = 0;
      v11 += physicsLODDataSize + 12;
      v18 = hkMemHeapAllocator();
      v19 = v62;
      if ( (_DWORD)v62 == (HIDWORD(v62) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v18, &array, 8);
        v19 = v62;
      }
      array[v19] = v15;
      LODWORD(v62) = v62 + 1;
      ++v12;
      ++v14;
      v13 = s_havokPhysicsXModels;
    }
    while ( v12 < s_havokPhysicsXModels->m_size );
    _R13 = v64;
  }
  m_numElems = (unsigned int)s_havokPhysicsXModelLODs->m_map.m_numElems;
  LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
  Com_sprintf<256>((char (*)[256])dest, "%i Assets - %i bytes of colLod data", m_numElems, v11);
  __asm
  {
    vmovss  xmm6, [rbp+0E0h+charHeight]
    vmovss  [rsp+1E0h+var_1A8], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r13+0]; x
  }
  v24 = scrPlacea;
  Physics_DrawDebugString(scrPlacea, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v57, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
  }
  Com_sprintf<256>((char (*)[256])dest, "Red text if there is no PhysicsAsset and not marked as ShouldNotHavePhysics");
  __asm
  {
    vmovss  [rsp+1E0h+var_1A8], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r13+0]; x
  }
  Physics_DrawDebugString(v24, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v58, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
  }
  v29 = sortType;
  switch ( sortType )
  {
    case Physics_DebugXModelSortType_ByName:
      v30 = v62;
      if ( (int)v62 <= 1 )
        break;
      v31 = HavokPhysics_XModelsSortByName;
      goto LABEL_25;
    case Physics_DebugXModelSortType_ByMemory:
      v30 = v62;
      if ( (int)v62 <= 1 )
        break;
      v31 = HavokPhysics_XModelsSortByMemory;
      goto LABEL_25;
    case Physics_DebugXModelSortType_ByDetailBodyCount:
      v30 = v62;
      if ( (int)v62 > 1 )
      {
        v31 = HavokPhysics_XModelsSortByDetailBodyCount;
LABEL_25:
        hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v30 - 1, v31);
        v29 = sortType;
      }
      break;
  }
  __asm
  {
    vmovss  xmm7, [rbp+0E0h+tabWidth]
    vaddss  xmm0, xmm7, dword ptr [r13+0]
    vmovss  dword ptr [r13+0], xmm0
  }
  v34 = 0;
  v35 = (const char ***)array;
  if ( array == &array[(int)v62] )
    goto LABEL_59;
  do
  {
    v36 = *v35;
    v37 = *((_BYTE *)*v35 + 15);
    v38 = !v37 || v37 == 3;
    v39 = (const XModelDetailCollision *)v36[80];
    if ( v29 == Physics_DebugXModelSortType_ByDetailBodyCount )
    {
      if ( v39 )
      {
        HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v39);
        if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19788, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
          __debugbreak();
        v41 = *v36;
        if ( HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size == 1 )
        {
          LODWORD(fmt) = *((unsigned __int8 *)v36 + 11);
          Com_sprintf<256>((char (*)[256])dest, "%4i: %s with collod %i with single body", v34, v41, fmt);
        }
        else
        {
          LODWORD(forceColor) = HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size;
          LODWORD(fmt) = *((unsigned __int8 *)v36 + 11);
          Com_sprintf<256>((char (*)[256])dest, "%4i: %s with collod %i with %i bodies + 1 bounding body", v34, v41, fmt, forceColor);
        }
LABEL_38:
        if ( v36[78] || (v42 = &colorRed, v38) )
          v42 = &colorWhite;
        v24 = scrPlacea;
        goto LABEL_52;
      }
      v43 = (const PhysicsAsset *)v36[78];
      if ( !v43 )
        goto LABEL_57;
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(v43);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19806, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      LODWORD(fmt) = HavokPhysicsAsset->m_bodyServerUsage.m_size;
      Com_sprintf<256>((char (*)[256])dest, "%4i: %s with no collod with %i bodies", v34, *v36, fmt);
LABEL_51:
      v42 = &colorWhite;
      goto LABEL_52;
    }
    if ( v39 )
    {
      v48 = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v39);
      if ( !v48 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19826, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
        __debugbreak();
      LODWORD(shadow) = v48->m_shapes.m_size;
      LODWORD(fmt) = *((_DWORD *)v36[80] + 2) + 12;
      Com_sprintf<256>((char (*)[256])dest, "%4i:\t colLod \t%i\t size:\t%6i \tname:\t%s\t numBodies:\t%i ", v34, *((unsigned __int8 *)v36 + 11), fmt, *v36, shadow);
      goto LABEL_38;
    }
    Com_sprintf<256>((char (*)[256])dest, "%4i:\t no colLod\t\t size:\t%6i \tname:\t%s", v34, 12i64, *v36);
    if ( v36[78] )
      goto LABEL_51;
    v42 = &colorRed;
    if ( v38 )
      goto LABEL_51;
LABEL_52:
    __asm
    {
      vmovss  [rsp+1E0h+var_1A8], xmm6
      vmovss  xmm2, dword ptr [r15]; y
      vmovss  xmm1, dword ptr [r13+0]; x
    }
    Physics_DrawDebugString(v24, *(float *)&_XMM1, *(float *)&_XMM2, dest, v42, 0, 1, v59, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r15]
      vmovss  dword ptr [r15], xmm0
    }
    v29 = sortType;
LABEL_57:
    ++v34;
    ++v35;
  }
  while ( v35 != (const char ***)&array[(int)v62] );
  __asm { vmovss  xmm0, dword ptr [r13+0] }
LABEL_59:
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vmovss  dword ptr [r13+0], xmm0
  }
  v50 = hkMemHeapAllocator();
  LODWORD(v62) = 0;
  if ( v62 >= 0 )
    hkMemoryAllocator::bufFree2(v50, array, 8, HIDWORD(v62) & 0x3FFFFFFF);
  _R11 = &v67;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithColLods
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithColLods(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight, bool excludeDoNotUse)
{
  const ScreenPlacement *v12; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v13; 
  int v14; 
  __int64 v15; 
  __int64 v16; 
  unsigned int numsurfs; 
  const XModelLodInfo *LodInfo; 
  unsigned __int16 surfIndex; 
  unsigned __int16 v20; 
  const char ***v21; 
  unsigned int v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  hkMemoryAllocator *v25; 
  int v26; 
  hkMemoryAllocator *v27; 
  int v28; 
  unsigned int v34; 
  XModel **i; 
  const char ***v39; 
  XModel **j; 
  hkMemoryAllocator *v49; 
  hkMemoryAllocator *v50; 
  hkMemoryAllocator *v51; 
  char *fmt; 
  __int64 forceColor; 
  __int64 shadow; 
  float v58; 
  float v59; 
  float v60; 
  float v61; 
  XModel **v62; 
  __int64 v63; 
  XModel **pArr; 
  __int64 v65; 
  const XModel **array; 
  int v67; 
  int v68; 
  __int64 v69; 
  float *v70; 
  float *v71; 
  const ScreenPlacement *v72; 
  __int64 v73; 
  char dest[256]; 
  char v75; 
  void *retaddr; 

  _RAX = &retaddr;
  v73 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmm7, xmm3
  }
  _R15 = y;
  v70 = y;
  _R12 = x;
  v71 = x;
  v12 = scrPlace;
  v72 = scrPlace;
  array = NULL;
  v67 = 0;
  v68 = 0x80000000;
  pArr = NULL;
  v65 = 0x8000000000000000ui64;
  v62 = NULL;
  v63 = 0x8000000000000000ui64;
  v13 = s_havokPhysicsXModels;
  if ( !s_havokPhysicsXModels )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19624, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tDebug rendering Havok Physics XModels, but the array is NULL", "s_havokPhysicsXModels") )
      __debugbreak();
    v13 = s_havokPhysicsXModels;
  }
  v14 = 0;
  if ( v13->m_size > 0 )
  {
    v15 = 0i64;
    v69 = 0i64;
    do
    {
      v16 = *(__int64 *)((char *)v13->m_data + v15);
      if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19630, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( !excludeDoNotUse )
        goto LABEL_26;
      if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 247, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      numsurfs = XModelGetLodInfo((const XModel *)v16, 0)->numsurfs;
      if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 257, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      LodInfo = XModelGetLodInfo((const XModel *)v16, 0);
      surfIndex = LodInfo->surfIndex;
      v20 = *(_WORD *)(v16 + 8);
      if ( surfIndex >= v20 )
      {
        LODWORD(shadow) = v20;
        LODWORD(forceColor) = surfIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 261, ASSERT_TYPE_ASSERT, "(unsigned)( lodInfo->surfIndex ) < (unsigned)( model->numsurfs )", "lodInfo->surfIndex doesn't index model->numsurfs\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v21 = (const char ***)(*(_QWORD *)(v16 + 216) + 8i64 * LodInfo->surfIndex);
      if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19637, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
        __debugbreak();
      v22 = 0;
      if ( numsurfs )
      {
        while ( !I_stristr(**v21, "do_not_use") )
        {
          ++v22;
          ++v21;
          if ( v22 >= numsurfs )
            goto LABEL_26;
        }
      }
      else
      {
LABEL_26:
        if ( (*(_BYTE *)(v16 + 15) & 0xFD) != 0 )
        {
          if ( *(_BYTE *)(v16 + 11) == 8 )
          {
            v25 = hkMemHeapAllocator();
            v26 = v65;
            if ( (_DWORD)v65 == (HIDWORD(v65) & 0x3FFFFFFF) )
            {
              hkArrayUtil::_reserveMore(v25, &pArr, 8);
              v26 = v65;
            }
            pArr[v26] = (XModel *)v16;
            LODWORD(v65) = v65 + 1;
          }
          else
          {
            v27 = hkMemHeapAllocator();
            v28 = v63;
            if ( (_DWORD)v63 == (HIDWORD(v63) & 0x3FFFFFFF) )
            {
              hkArrayUtil::_reserveMore(v27, &v62, 8);
              v28 = v63;
            }
            v62[v28] = (XModel *)v16;
            LODWORD(v63) = v63 + 1;
          }
        }
        else
        {
          v23 = hkMemHeapAllocator();
          v24 = v67;
          if ( v67 == (v68 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v23, &array, 8);
            v24 = v67;
          }
          array[v24] = (const XModel *)v16;
          ++v67;
        }
      }
      ++v14;
      v15 = v69 + 8;
      v69 += 8i64;
      v13 = s_havokPhysicsXModels;
    }
    while ( v14 < s_havokPhysicsXModels->m_size );
    _R15 = v70;
    _R12 = v71;
    v12 = v72;
  }
  if ( v67 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v67 - 1, HavokPhysics_XModelsSortByName);
  if ( (int)v65 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)pArr, 0, v65 - 1, HavokPhysics_XModelsSortByName);
  if ( (int)v63 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)v62, 0, v63 - 1, HavokPhysics_XModelsSortByName);
  Com_sprintf<256>((char (*)[256])dest, "Red text if we expect a ColLod and don't find one, white otherwise.");
  __asm
  {
    vmovss  xmm6, [rbp+110h+charHeight]
    vmovss  [rsp+210h+var_1D8], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r12]; x
  }
  Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v58, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vaddss  xmm1, xmm7, dword ptr [r12]
    vmovss  dword ptr [r12], xmm1
  }
  v34 = 0;
  for ( i = pArr; i != &pArr[(int)v65]; ++i )
  {
    Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s has no collod, but isn't flagged to expect that.", v34, (*i)->name);
    __asm
    {
      vmovss  [rsp+210h+var_1D8], xmm6
      vmovss  xmm2, dword ptr [r15]; y
      vmovss  xmm1, dword ptr [r12]; x
    }
    Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorRed, 0, 1, v59, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r15]
      vmovss  dword ptr [r15], xmm0
    }
    ++v34;
  }
  v39 = (const char ***)array;
  if ( array != &array[v67] )
  {
    do
    {
      Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s has no collod, but this is expected.", v34, **v39);
      __asm
      {
        vmovss  [rsp+210h+var_1D8], xmm6
        vmovss  xmm2, dword ptr [r15]; y
        vmovss  xmm1, dword ptr [r12]; x
      }
      Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorRed, 0, 1, v60, 0);
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [r15]
        vmovss  dword ptr [r15], xmm0
      }
      ++v34;
      ++v39;
    }
    while ( v39 != (const char ***)&array[v67] );
  }
  for ( j = v62; j != &v62[(int)v63]; ++j )
  {
    LODWORD(fmt) = (*j)->detailCollision->physicsLODDataSize + 12;
    Com_sprintf<256>((char (*)[256])dest, "%4i: colLod:%i colLod size:%i name:%s", v34, (*j)->collLod, fmt, (*j)->name);
    __asm
    {
      vmovss  [rsp+210h+var_1D8], xmm6
      vmovss  xmm2, dword ptr [r15]; y
      vmovss  xmm1, dword ptr [r12]; x
    }
    Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v61, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r15]
      vmovss  dword ptr [r15], xmm0
    }
    ++v34;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r12]
    vsubss  xmm1, xmm0, xmm7
    vmovss  dword ptr [r12], xmm1
  }
  v49 = hkMemHeapAllocator();
  LODWORD(v63) = 0;
  if ( v63 >= 0 )
    hkMemoryAllocator::bufFree2(v49, v62, 8, HIDWORD(v63) & 0x3FFFFFFF);
  v62 = NULL;
  HIDWORD(v63) = 0x80000000;
  v50 = hkMemHeapAllocator();
  LODWORD(v65) = 0;
  if ( v65 >= 0 )
    hkMemoryAllocator::bufFree2(v50, pArr, 8, HIDWORD(v65) & 0x3FFFFFFF);
  pArr = NULL;
  HIDWORD(v65) = 0x80000000;
  v51 = hkMemHeapAllocator();
  v67 = 0;
  if ( v68 >= 0 )
    hkMemoryAllocator::bufFree2(v51, array, 8, v68 & 0x3FFFFFFF);
  _R11 = &v75;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets(const ScreenPlacement *scrPlace, float *x, float *y, double tabWidth, float charHeight, bool excludeDoNotUse)
{
  const ScreenPlacement *v12; 
  int v13; 
  __int64 v14; 
  __int64 v15; 
  unsigned int numsurfs; 
  const XModelLodInfo *LodInfo; 
  unsigned __int16 surfIndex; 
  unsigned __int16 v19; 
  const char ***v20; 
  unsigned int v21; 
  char v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  hkMemoryAllocator *v25; 
  int v26; 
  int v31; 
  unsigned int v33; 
  const XModel **v34; 
  const char ***v35; 
  XModel **v39; 
  XModel **v40; 
  hkMemoryAllocator *v45; 
  hkMemoryAllocator *v46; 
  __int64 forceColor; 
  __int64 shadow; 
  float v52; 
  float v53; 
  float v54; 
  const XModel **array; 
  __int64 v56; 
  XModel **pArr; 
  __int64 v58; 
  __int64 v59; 
  float *v60; 
  float *v61; 
  const ScreenPlacement *v62; 
  __int64 v63; 
  char dest[256]; 
  char v65; 
  void *retaddr; 

  _RAX = &retaddr;
  v63 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmm7, xmm3
  }
  _R15 = y;
  v60 = y;
  _R12 = x;
  v61 = x;
  v12 = scrPlace;
  v62 = scrPlace;
  pArr = NULL;
  v58 = 0x8000000000000000ui64;
  array = NULL;
  v56 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19515, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tDebug rendering Havok Physics XModels, but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  v13 = 0;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v14 = 0i64;
    v59 = 0i64;
    do
    {
      v15 = *(__int64 *)((char *)s_havokPhysicsXModels->m_data + v14);
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19521, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( !excludeDoNotUse )
        goto LABEL_25;
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 247, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      numsurfs = XModelGetLodInfo((const XModel *)v15, 0)->numsurfs;
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 257, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      LodInfo = XModelGetLodInfo((const XModel *)v15, 0);
      surfIndex = LodInfo->surfIndex;
      v19 = *(_WORD *)(v15 + 8);
      if ( surfIndex >= v19 )
      {
        LODWORD(shadow) = v19;
        LODWORD(forceColor) = surfIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 261, ASSERT_TYPE_ASSERT, "(unsigned)( lodInfo->surfIndex ) < (unsigned)( model->numsurfs )", "lodInfo->surfIndex doesn't index model->numsurfs\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v20 = (const char ***)(*(_QWORD *)(v15 + 216) + 8i64 * LodInfo->surfIndex);
      if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19528, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
        __debugbreak();
      v21 = 0;
      if ( numsurfs )
      {
        while ( !I_stristr(**v20, "do_not_use") )
        {
          ++v21;
          ++v20;
          if ( v21 >= numsurfs )
            goto LABEL_25;
        }
      }
      else
      {
LABEL_25:
        v22 = *(_BYTE *)(v15 + 15);
        if ( !v22 || v22 == 3 )
        {
          v25 = hkMemHeapAllocator();
          v26 = v58;
          if ( (_DWORD)v58 == (HIDWORD(v58) & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v25, &pArr, 8);
            v26 = v58;
          }
          pArr[v26] = (XModel *)v15;
          LODWORD(v58) = v58 + 1;
        }
        else if ( !*(_QWORD *)(v15 + 624) )
        {
          v23 = hkMemHeapAllocator();
          v24 = v56;
          if ( (_DWORD)v56 == (HIDWORD(v56) & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v23, &array, 8);
            v24 = v56;
          }
          array[v24] = (const XModel *)v15;
          LODWORD(v56) = v56 + 1;
        }
      }
      ++v13;
      v14 = v59 + 8;
      v59 += 8i64;
    }
    while ( v13 < s_havokPhysicsXModels->m_size );
    _R15 = v60;
    _R12 = v61;
    v12 = v62;
  }
  Com_sprintf<256>((char (*)[256])dest, "Red text if we expect a PhysicsAsset and don't find one, white if physicsUseCategory implies there shouldn't be one");
  __asm
  {
    vmovss  xmm6, [rbp+100h+charHeight]
    vmovss  [rsp+200h+var_1C8], xmm6
    vmovss  xmm2, dword ptr [r15]; y
    vmovss  xmm1, dword ptr [r12]; x
  }
  Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v52, 0);
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
  }
  if ( (int)v58 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)pArr, 0, v58 - 1, HavokPhysics_XModelsSortByName);
  v31 = v56;
  if ( (int)v56 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v56 - 1, HavokPhysics_XModelsSortByName);
    v31 = v56;
  }
  __asm
  {
    vaddss  xmm0, xmm7, dword ptr [r12]
    vmovss  dword ptr [r12], xmm0
  }
  v33 = 0;
  v34 = array;
  v35 = (const char ***)array;
  if ( array != &array[v31] )
  {
    do
    {
      if ( !(*v35)[78] )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s", v33, **v35);
        __asm
        {
          vmovss  [rsp+200h+var_1C8], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r12]; x
        }
        Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorRed, 0, 1, v53, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        v31 = v56;
        v34 = array;
      }
      ++v33;
      ++v35;
    }
    while ( v35 != (const char ***)&v34[v31] );
    __asm { vmovss  xmm0, dword ptr [r12] }
  }
  v39 = pArr;
  v40 = pArr;
  if ( pArr != &pArr[(int)v58] )
  {
    do
    {
      if ( !(*v40)->physicsAsset )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s", v33, (*v40)->name);
        __asm
        {
          vmovss  [rsp+200h+var_1C8], xmm6
          vmovss  xmm2, dword ptr [r15]; y
          vmovss  xmm1, dword ptr [r12]; x
        }
        Physics_DrawDebugString(v12, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v54, 0);
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [r15]
          vmovss  dword ptr [r15], xmm0
        }
        v39 = pArr;
      }
      ++v33;
      ++v40;
    }
    while ( v40 != &v39[(int)v58] );
    __asm { vmovss  xmm0, dword ptr [r12] }
  }
  __asm
  {
    vsubss  xmm0, xmm0, xmm7
    vmovss  dword ptr [r12], xmm0
  }
  v45 = hkMemHeapAllocator();
  LODWORD(v56) = 0;
  if ( v56 >= 0 )
    hkMemoryAllocator::bufFree2(v45, array, 8, HIDWORD(v56) & 0x3FFFFFFF);
  array = NULL;
  HIDWORD(v56) = 0x80000000;
  v46 = hkMemHeapAllocator();
  LODWORD(v58) = 0;
  if ( v58 >= 0 )
    hkMemoryAllocator::bufFree2(v46, pArr, 8, HIDWORD(v58) & 0x3FFFFFFF);
  _R11 = &v65;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_DrawWorld
==============
*/
void HavokPhysics_DrawWorld(Physics_WorldId worldId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v17; 
  hknpWorld *world; 
  unsigned int *m_constraintManager; 
  hknpWorldReader_vtbl *v25; 
  hknpWorld *v53; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  unsigned int v58; 
  unsigned int v59; 
  __int64 v60; 
  int v61; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v65; 
  unsigned int v66; 
  unsigned int v67; 
  unsigned int v71; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v72; 
  unsigned int v73; 
  int v77; 
  int v115; 
  Physics_RefSystem RefSystem; 
  unsigned __int16 RefId; 
  DObj *ServerDObjForEntnum; 
  __int64 v122; 
  __int64 v132; 
  int v133; 
  unsigned int v134; 
  int v135; 
  char *fmtb; 
  char *fmtc; 
  char *fmt; 
  char *fmta; 
  char *fmtd; 
  char *fmte; 
  char *fmtf; 
  double forceColor; 
  double shadow; 
  float v148; 
  double v149; 
  float v150; 
  float v151; 
  float v152; 
  float v153; 
  float v154; 
  float v155; 
  float v156; 
  float v157; 
  float v158; 
  float v159; 
  float v160; 
  float v161; 
  char v162; 
  char v163; 
  __int16 i; 
  hknpWorld *v165; 
  __int64 v168; 
  unsigned int *v169; 
  char dest[256]; 

  _R14 = y;
  _R13 = x;
  v17 = scrPlace;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 21176, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm { vmovaps [rsp+240h+var_40], xmm6 }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  v165 = world;
  if ( world )
  {
    m_constraintManager = (unsigned int *)world->m_constraintManager;
    __asm
    {
      vmovaps [rsp+240h+var_60], xmm8
      vmovaps [rsp+240h+var_70], xmm9
      vmovaps [rsp+240h+var_80], xmm10
    }
    v169 = m_constraintManager;
    v25 = world->hknpWorldReader::__vftable;
    __asm
    {
      vmovaps [rsp+240h+var_90], xmm11
      vmovaps [rsp+240h+var_A0], xmm12
      vmovaps [rsp+240h+var_B0], xmm13
    }
    _RAX = (__int64)v25->getGravity(&world->hknpWorldReader);
    __asm
    {
      vmovss  xmm0, cs:__real@42000000
      vmovss  xmm1, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+4; clipMap_t cm
      vmovss  xmm4, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax; clipMap_t cm
      vmovups xmm8, xmmword ptr [rax]
      vmovss  xmm3, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+4; clipMap_t cm
      vmovss  xmm2, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin; clipMap_t cm
      vmovss  xmm5, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+8; clipMap_t cm
      vmulss  xmm11, xmm8, xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vcvtss2sd xmm4, xmm4, xmm4
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm5, xmm5, xmm5
      vshufps xmm9, xmm8, xmm8, 55h ; 'U'
      vmulss  xmm12, xmm9, xmm0
      vshufps xmm10, xmm8, xmm8, 0AAh ; ''
      vmulss  xmm13, xmm10, xmm0
      vmovss  xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+8; clipMap_t cm
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+240h+var_208], xmm0
      vmovsd  qword ptr [rsp+240h+shadow], xmm1
      vmovsd  qword ptr [rsp+240h+forceColor], xmm4
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+240h+fmt], xmm5
    }
    Com_sprintf<256>((char (*)[256])dest, "Broadphase (%.2f, %.2f, %.2f) (%.2f, %.2f, %.2f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtb, forceColor, shadow, v149);
    __asm
    {
      vmovss  xmm6, [rbp+140h+charHeight]
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v150, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
    }
    LODWORD(fmtc) = world->m_bodyManager.m_bodies.m_peakIndex;
    Com_sprintf<256>((char (*)[256])dest, "%i bodies allocated - max %i - peak %i", world->m_bodyManager.m_bodies.m_numAllocated, (unsigned int)world->m_bodyManager.m_bodies.m_objects.m_size, fmtc);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v151, 0);
    v53 = world;
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
    }
    if ( fullDisplay )
    {
      __asm
      {
        vmovaps [rsp+240h+var_50], xmm7
        vmovss  xmm7, [rbp+140h+tabWidth]
        vaddss  xmm0, xmm7, dword ptr [r13+0]
        vmovss  dword ptr [r13+0], xmm0
      }
      m_data = world->m_bodyManager.m_bodies.m_objects.m_data;
      v58 = world->m_bodyManager.m_bodies.m_peakIndex + 1;
      v59 = 0;
      if ( v53->m_bodyManager.m_bodies.m_numAllocated )
      {
        if ( (m_data->m_pod.m_flags.m_storage & 0xF) != 0 )
          goto LABEL_72;
        v59 = 1;
        if ( v58 > 1 )
        {
          while ( (m_data[v59].m_pod.m_flags.m_storage & 0xF) == 0 )
          {
            if ( ++v59 >= v58 )
              goto LABEL_22;
          }
          if ( v59 != -1 )
          {
LABEL_72:
            do
            {
              v60 = v59;
              v61 = truncate_cast<int,unsigned __int64>(LODWORD(v53->m_bodyManager.m_bodies.m_objects.m_data[m_data[v60].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
              if ( Physics_GetRefSystem(v61) == Physics_RefSystem_WorldGeo )
              {
                Com_sprintf<256>((char (*)[256])dest, "World Geo Body %x %s", m_data[v60].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v165->m_bodyManager.m_bodyNames.m_data[m_data[v60].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                __asm
                {
                  vmovss  xmm2, dword ptr [r14]; y
                  vmovss  xmm1, dword ptr [r13+0]; x
                  vmovss  dword ptr [rsp+240h+var_208], xmm6
                }
                Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v152, 0);
                __asm
                {
                  vaddss  xmm0, xmm6, dword ptr [r14]
                  vmovss  dword ptr [r14], xmm0
                }
              }
              if ( ++v59 >= v58 )
                break;
              while ( (m_data[v59].m_pod.m_flags.m_storage & 0xF) == 0 )
              {
                if ( ++v59 >= v58 )
                  goto LABEL_21;
              }
              v53 = v165;
            }
            while ( v59 != -1 );
LABEL_21:
            v53 = v165;
          }
        }
      }
LABEL_22:
      for ( i = 0; i < 2048; ++i )
      {
        v65 = v53->m_bodyManager.m_bodies.m_objects.m_data;
        v66 = v53->m_bodyManager.m_bodies.m_peakIndex + 1;
        v67 = 0;
        v162 = 0;
        v163 = 0;
        if ( v53->m_bodyManager.m_bodies.m_numAllocated )
        {
          if ( (v65->m_pod.m_flags.m_storage & 0xF) != 0 )
            goto LABEL_73;
          v67 = 1;
          if ( v66 > 1 )
          {
            while ( (v65[v67].m_pod.m_flags.m_storage & 0xF) == 0 )
            {
              if ( ++v67 >= v66 )
                goto LABEL_28;
            }
            if ( v67 != -1 )
            {
LABEL_73:
              do
              {
                v168 = v67;
                v115 = truncate_cast<int,unsigned __int64>(LODWORD(v53->m_bodyManager.m_bodies.m_objects.m_data[v65[v168].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
                RefSystem = Physics_GetRefSystem(v115);
                RefId = Physics_GetRefId(v115);
                if ( (RefSystem == Physics_RefSystem_GEntities || RefSystem == Physics_RefSystem_GItems) && RefId == i )
                {
                  if ( v162 )
                  {
                    _RBX = x;
                    v122 = v67;
                  }
                  else
                  {
                    ServerDObjForEntnum = Com_GetServerDObjForEntnum(i);
                    if ( ServerDObjForEntnum && ServerDObjForEntnum->numModels )
                    {
                      Com_sprintf<256>((char (*)[256])dest, "Server Entity %i with model %s", (unsigned int)i, **(const char ***)ServerDObjForEntnum->models);
                      _RBX = x;
                      __asm
                      {
                        vmovss  xmm2, dword ptr [r14]; y
                        vmovss  xmm1, dword ptr [rbx]; x
                        vmovss  dword ptr [rsp+240h+var_208], xmm6
                      }
                      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v158, 0);
                      v122 = v67;
                      v163 = 1;
                    }
                    else
                    {
                      v122 = v67;
                      Com_sprintf<256>((char (*)[256])dest, "Server Entity %i with body %x %s", (unsigned int)i, v65[v168].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v165->m_bodyManager.m_bodyNames.m_data[v65[v168].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                      _RBX = x;
                      __asm
                      {
                        vmovss  xmm2, dword ptr [r14]; y
                        vmovss  xmm1, dword ptr [rbx]; x
                        vmovss  dword ptr [rsp+240h+var_208], xmm6
                      }
                      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v159, 0);
                    }
                    __asm
                    {
                      vaddss  xmm0, xmm6, dword ptr [r14]
                      vmovss  dword ptr [r14], xmm0
                      vaddss  xmm0, xmm7, dword ptr [rbx]
                      vmovss  dword ptr [rbx], xmm0
                    }
                    v162 = 1;
                  }
                  if ( v163 )
                  {
                    Com_sprintf<256>((char (*)[256])dest, "%x %s", v65[v122].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v165->m_bodyManager.m_bodyNames.m_data[v65[v122].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                    __asm
                    {
                      vmovss  xmm2, dword ptr [r14]; y
                      vmovss  xmm1, dword ptr [rbx]; x
                      vmovss  dword ptr [rsp+240h+var_208], xmm6
                    }
                    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v160, 0);
                    __asm
                    {
                      vaddss  xmm0, xmm6, dword ptr [r14]
                      vmovss  dword ptr [r14], xmm0
                    }
                  }
                }
                if ( ++v67 >= v66 )
                  break;
                while ( (v65[v67].m_pod.m_flags.m_storage & 0xF) == 0 )
                {
                  if ( ++v67 >= v66 )
                    goto LABEL_57;
                }
                v53 = v165;
              }
              while ( v67 != -1 );
LABEL_57:
              _R13 = x;
              v53 = v165;
              if ( v162 )
              {
                __asm
                {
                  vmovss  xmm0, dword ptr [r13+0]
                  vsubss  xmm1, xmm0, xmm7
                  vmovss  dword ptr [r13+0], xmm1
                }
              }
            }
          }
        }
LABEL_28:
        ;
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r13+0]
        vsubss  xmm1, xmm0, xmm7
        vmovaps xmm7, [rsp+240h+var_50]
      }
      v71 = 0;
      __asm { vmovss  dword ptr [r13+0], xmm1 }
      v72 = v53->m_bodyManager.m_bodies.m_objects.m_data;
      v73 = v53->m_bodyManager.m_bodies.m_peakIndex + 1;
      if ( !v53->m_bodyManager.m_bodies.m_numAllocated )
        goto LABEL_34;
      if ( (v72->m_pod.m_flags.m_storage & 0xF) != 0 )
        goto LABEL_74;
      v71 = 1;
      if ( v73 <= 1 )
        goto LABEL_34;
      while ( (v72[v71].m_pod.m_flags.m_storage & 0xF) == 0 )
      {
        if ( ++v71 >= v73 )
          goto LABEL_34;
      }
      if ( v71 != -1 )
      {
LABEL_74:
        do
        {
          v132 = v71;
          v133 = truncate_cast<int,unsigned __int64>(LODWORD(v53->m_bodyManager.m_bodies.m_objects.m_data[v72[v132].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
          v134 = Physics_GetRefSystem(v133);
          if ( v134 <= 9 && (v135 = 517, _bittest(&v135, v134)) )
          {
            v17 = scrPlace;
          }
          else
          {
            Com_sprintf<256>((char (*)[256])dest, "General Body %x %s", v72[v132].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v165->m_bodyManager.m_bodyNames.m_data[v72[v132].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
            v17 = scrPlace;
            __asm
            {
              vmovss  xmm2, dword ptr [r14]; y
              vmovss  xmm1, dword ptr [r13+0]; x
              vmovss  dword ptr [rsp+240h+var_208], xmm6
            }
            Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v161, 0);
            __asm
            {
              vaddss  xmm0, xmm6, dword ptr [r14]
              vmovss  dword ptr [r14], xmm0
            }
          }
          if ( ++v71 >= v73 )
            break;
          while ( (v72[v71].m_pod.m_flags.m_storage & 0xF) == 0 )
          {
            if ( ++v71 >= v73 )
            {
              v53 = v165;
              goto LABEL_35;
            }
          }
          v53 = v165;
        }
        while ( v71 != -1 );
        v53 = v165;
      }
      else
      {
LABEL_34:
        v17 = scrPlace;
      }
    }
LABEL_35:
    LODWORD(fmt) = v53->m_motionManager.m_motions.m_peakIndex;
    Com_sprintf<256>((char (*)[256])dest, "%i motions allocated - max %i - peak %i", v53->m_motionManager.m_motions.m_numAllocated, (unsigned int)v53->m_motionManager.m_motions.m_objects.m_size, fmt);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v153, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
    }
    v77 = 0x7FFFFFFF;
    if ( v169[8] != -1 )
      v77 = v169[8];
    LODWORD(fmta) = v77;
    Com_sprintf<256>((char (*)[256])dest, "%i constraints - max %i - peak %i", v169[7], v169[4], fmta);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v154, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vcvtss2sd xmm3, xmm9, xmm9
      vcvtss2sd xmm2, xmm8, xmm8
      vcvtss2sd xmm1, xmm10, xmm10
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovss  dword ptr [r14], xmm0
      vmovsd  [rsp+240h+fmt], xmm1
    }
    Com_sprintf<256>((char (*)[256])dest, "hkGravity (%.2f, %.2f, %.2f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtd);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v155, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vcvtss2sd xmm3, xmm12, xmm12
      vcvtss2sd xmm2, xmm11, xmm11
      vcvtss2sd xmm1, xmm13, xmm13
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovss  dword ptr [r14], xmm0
      vmovsd  [rsp+240h+fmt], xmm1
    }
    Com_sprintf<256>((char (*)[256])dest, "iwGravity (%.2f, %.2f, %.2f)", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmte);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v156, 0);
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
      vmovss  xmm3, cs:?g_physicsClientWorldGravityScalars@@3PAY01MA+8; float (near * g_physicsClientWorldGravityScalars)[2]
      vmovss  xmm2, cs:?g_physicsClientWorldGravityScalars@@3PAY01MA+30h; float (near * g_physicsClientWorldGravityScalars)[2]
      vmovss  xmm1, cs:?g_physicsClientWorldGravityScalars@@3PAY01MA+38h; float (near * g_physicsClientWorldGravityScalars)[2]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm1, xmm1, xmm1
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+240h+fmt], xmm1
    }
    Com_sprintf<256>((char (*)[256])dest, "gravity scalars: ragdoll:%.2f dynent:%.2f particle:%.2f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmtf);
    __asm
    {
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v157, 0);
    __asm
    {
      vmovaps xmm13, [rsp+240h+var_B0]
      vmovaps xmm12, [rsp+240h+var_A0]
      vmovaps xmm11, [rsp+240h+var_90]
      vmovaps xmm10, [rsp+240h+var_80]
      vmovaps xmm9, [rsp+240h+var_70]
      vmovaps xmm8, [rsp+240h+var_60]
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Couldn't find world %i", (unsigned int)worldId);
    __asm
    {
      vmovss  xmm6, [rbp+140h+charHeight]
      vmovss  xmm2, dword ptr [r14]; y
      vmovss  xmm1, dword ptr [r13+0]; x
      vmovss  dword ptr [rsp+240h+var_208], xmm6
    }
    Physics_DrawDebugString(v17, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, v148, 0);
  }
  __asm
  {
    vaddss  xmm0, xmm6, dword ptr [r14]
    vmovaps xmm6, [rsp+240h+var_40]
    vmovss  dword ptr [r14], xmm0
  }
}

/*
==============
HavokPhysics_EnableDeactivationForBody
==============
*/
void HavokPhysics_EnableDeactivationForBody(Physics_WorldId worldId, hknpBodyId bodyId, bool enableDeactivation)
{
  hknpWorld *world; 
  __int64 v7; 
  hknpWorld *v8; 
  hknpDeactivationManager *m_deactivationManager; 
  __int64 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13214, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to enable deactivation for a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13215, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to enable deactivation for a body with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 181, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Motion ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 182, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Motion ID with invalid body id in world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 186, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get Motion Id %i: world is NULL", "world", v11) )
      __debugbreak();
  }
  v7 = *(unsigned int *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex) + 64);
  if ( (_DWORD)v7 == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13219, ASSERT_TYPE_ASSERT, "(motionId.isValid())", (const char *)&queryFormat, "motionId.isValid()") )
    __debugbreak();
  v8 = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13223, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
    __debugbreak();
  m_deactivationManager = v8->m_deactivationManager;
  if ( !m_deactivationManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13227, ASSERT_TYPE_ASSERT, "(deactivationManager)", (const char *)&queryFormat, "deactivationManager") )
    __debugbreak();
  v10 = (__int64)&m_deactivationManager->m_deactivationStates.m_data[v7];
  if ( enableDeactivation )
  {
    if ( *(_BYTE *)(v10 + 11) == 0xFF )
      *(_BYTE *)(v10 + 11) = 0;
  }
  else
  {
    *(_BYTE *)(v10 + 11) = -1;
  }
}

/*
==============
HavokPhysics_EnableShapeInstance
==============
*/
void HavokPhysics_EnableShapeInstance(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> shapeInstanceId, bool enabled)
{
  hknpWorld *world; 
  const hknpShape *m_shape; 
  hknpShape_vtbl *v10; 

  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16120, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics EnableShapeInstance %i: world is NULL", "world", worldId) )
    __debugbreak();
  m_shape = world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_shape;
  if ( !m_shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16127, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  if ( (m_shape->m_type.m_storage != 18 || !m_shape->getMutationSignals(m_shape)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16131, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::MASKED && shape->isMutable())", (const char *)&queryFormat, "shape->getType() == hknpShapeType::MASKED && shape->isMutable()") )
    __debugbreak();
  v10 = m_shape[1].__vftable;
  if ( BYTE2(v10->getMutationSignals) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16140, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
    __debugbreak();
  (*(void (__fastcall **)(unsigned __int16 *, _QWORD, bool))(*(_QWORD *)&m_shape[1].m_memSizeAndFlags + 16i64))(&m_shape[1].m_memSizeAndFlags, (0xFFFFFFFF >> BYTE3(v10->getMutationSignals)) | (shapeInstanceId.m_value << (32 - BYTE3(v10->getMutationSignals))), enabled);
  m_shape->__vftable[1].deleteThisReferencedObject(&m_shape->hkReferencedObject);
}

/*
==============
HavokPhysics_FindMaterialId
==============
*/
hknpMaterialId *HavokPhysics_FindMaterialId(hknpMaterialId *result, const char *physicsMaterial)
{
  const char *v2; 
  __int64 v4; 
  unsigned int v5; 
  __int64 v6; 
  int v7; 
  int v8; 
  int m_size; 

  v2 = physicsMaterial;
  if ( !physicsMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8644, ASSERT_TYPE_ASSERT, "(physicsMaterial)", (const char *)&queryFormat, "physicsMaterial") )
    __debugbreak();
  v4 = -1i64;
  v5 = -1;
  do
    ++v4;
  while ( v2[v4] );
  for ( ; v4; --v4 )
  {
    v6 = *(unsigned __int8 *)v2++;
    v5 = (v5 >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)v5];
  }
  v7 = 0;
  v8 = ~v5;
  m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
  if ( m_size > 0 )
  {
    do
    {
      if ( v8 == s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v7] )
        break;
      ++v7;
    }
    while ( v7 < m_size );
  }
  if ( v7 >= m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8660, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
    __debugbreak();
  result->m_value = v7 + s_havokPhysicsMaterialLibrary.firstId.m_value;
  return result;
}

/*
==============
HavokPhysics_FindShapeTag
==============
*/
unsigned __int16 HavokPhysics_FindShapeTag(HavokPhysicsShapeList::ShapeTagData *shapeTagData)
{
  return HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, shapeTagData);
}

/*
==============
HavokPhysics_FlushMovedStatics
==============
*/
void HavokPhysics_FlushMovedStatics(Physics_WorldId worldId)
{
  hknpWorld *world; 
  hkMemoryAllocator *v4; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  __int64 m_size; 
  __int64 v7; 
  hknpBodyManager::ScheduledBodyChange *v8; 
  __int64 m_bodyIndex; 
  unsigned int m_serialAndIndex; 
  hkMemoryAllocator *v11; 
  int v12; 
  __int64 v13; 
  signed int v14; 
  __int64 v15; 
  __int64 v20; 
  signed int v21; 
  __int64 v22; 
  hkMemoryAllocator *v27; 
  __int64 v28; 
  __int128 v29; 
  __int128 v30; 
  __int128 v31; 
  hknpBroadPhase *m_broadPhase; 
  hknpBodyId *array; 
  unsigned int v34; 
  int v35; 

  v28 = -2i64;
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  *(_QWORD *)&v29 = world->m_bodyManager.m_previousAabbs.m_data;
  *((_QWORD *)&v29 + 1) = v29 + 16i64 * world->m_bodyManager.m_previousAabbs.m_size;
  __asm
  {
    vmovups xmm0, [rbp+var_48]
    vmovups [rbp+var_38], xmm0
  }
  *(_QWORD *)&v29 = world->m_bodyManager.m_bodies.m_objects.m_data;
  *((_QWORD *)&v29 + 1) = 176i64 * (unsigned int)world->m_bodyManager.m_bodies.m_objects.m_size + v29;
  __asm
  {
    vmovups xmm0, [rbp+var_48]
    vmovups [rbp+var_28], xmm0
  }
  m_broadPhase = world->m_broadPhase;
  array = NULL;
  v34 = 0;
  v35 = 0x80000000;
  v4 = hkMemHeapAllocator();
  hkArrayUtil::_reserve(v4, &array, 256, 4);
  m_data = world->m_bodyManager.m_bodies.m_objects.m_data;
  m_size = world->m_bodyManager.m_scheduledBodyChanges.m_size;
  if ( m_size > 0 )
  {
    v7 = 0i64;
    do
    {
      v8 = world->m_bodyManager.m_scheduledBodyChanges.m_data;
      if ( (v8[v7].m_scheduledBodyFlags.m_storage & 4) != 0 )
      {
        m_bodyIndex = v8[v7].m_bodyIndex;
        if ( (unsigned int)m_bodyIndex < world->m_bodyManager.m_bodies.m_objects.m_size && (m_data[m_bodyIndex].m_pod.m_flags.m_storage & 3) != 0 && (m_data[m_bodyIndex].m_pod.m_flags.m_storage & 1) != 0 )
        {
          m_serialAndIndex = m_data[m_bodyIndex].m_pod.m_id.m_serialAndIndex;
          v11 = hkMemHeapAllocator();
          v12 = v34;
          if ( v34 == (v35 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v11, &array, 4);
            v12 = v34;
          }
          array[v12].m_serialAndIndex = m_serialAndIndex;
          v13 = v34 + 1;
          v34 = v13;
          if ( (_DWORD)v13 == (v35 & 0x3FFFFFFF) )
          {
            v14 = 0;
            if ( (int)v13 > 0 )
            {
              v15 = 0i64;
              do
              {
                _RCX = array[v15].m_serialAndIndex & 0xFFFFFF;
                _RAX = v31 + 176 * _RCX;
                *(_QWORD *)(_RAX + 72) = 0i64;
                __asm { vmovups xmm0, xmmword ptr [rax+50h] }
                _RCX *= 2i64;
                _RAX = v30;
                __asm { vmovups xmmword ptr [rax+rcx*8], xmm0 }
                ++v14;
                ++v15;
                v13 = v34;
              }
              while ( v14 < (int)v34 );
            }
            ((void (__fastcall *)(hknpBroadPhase *, hknpBodyId *, __int64, __int64, __int64))m_broadPhase->markBodiesDirty)(m_broadPhase, array, v13, 4i64, v28);
            hkMemHeapAllocator();
            v34 = 0;
          }
        }
      }
      ++v7;
      --m_size;
    }
    while ( m_size );
  }
  hknpBodyManager::clearAllScheduledBodyChanges(&world->m_bodyManager);
  v20 = v34;
  if ( v34 )
  {
    v21 = 0;
    if ( (int)v34 > 0 )
    {
      v22 = 0i64;
      do
      {
        _RCX = array[v22].m_serialAndIndex & 0xFFFFFF;
        _RAX = v31 + 176 * _RCX;
        *(_QWORD *)(_RAX + 72) = 0i64;
        __asm { vmovups xmm0, xmmword ptr [rax+50h] }
        _RCX *= 2i64;
        _RAX = v30;
        __asm { vmovups xmmword ptr [rax+rcx*8], xmm0 }
        ++v21;
        ++v22;
        v20 = v34;
      }
      while ( v21 < (int)v34 );
    }
    m_broadPhase->markBodiesDirty(m_broadPhase, array, v20, 4);
    hkMemHeapAllocator();
    v34 = 0;
  }
  v27 = hkMemHeapAllocator();
  v34 = 0;
  if ( v35 >= 0 )
    hkMemoryAllocator::bufFree2(v27, array, 4, v35 & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_FreeBroadphaseCollisionQueryResult
==============
*/
void HavokPhysics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  unsigned __int16 m_refCount; 
  signed __int32 v3[8]; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13575, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  _InterlockedOr(v3, 0);
  m_refCount = result->m_refCount;
  _InterlockedOr(v3, 0);
  if ( m_refCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13578, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(result);
}

/*
==============
HavokPhysics_FreeCollisionQueryResult
==============
*/
void HavokPhysics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  HavokPhysicsHitCollector *m_collector; 
  unsigned __int16 m_refCount; 
  signed __int32 v4[8]; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13674, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13677, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  m_collector = result->m_collector;
  if ( m_collector )
    ((void (__fastcall *)(HavokPhysicsHitCollector *, __int64))m_collector->~HavokPhysicsHitCollectorDummy)(m_collector, 1i64);
  result->m_collector = NULL;
  _InterlockedOr(v4, 0);
  m_refCount = result->m_refCount;
  _InterlockedOr(v4, 0);
  if ( m_refCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13682, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(result);
}

/*
==============
HavokPhysics_FreeIgnoreBodies
==============
*/
void HavokPhysics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  hkMemoryRouter *Value; 

  if ( ignoreBodies )
  {
    HavokPhysics_IgnoreBodies::~HavokPhysics_IgnoreBodies(ignoreBodies);
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, ignoreBodies, 56);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13705, ASSERT_TYPE_ASSERT, "(ignoreBodies)", (const char *)&queryFormat, "ignoreBodies", -2i64) )
  {
    __debugbreak();
  }
}

/*
==============
HavokPhysics_GetAssetByName
==============
*/
const PhysicsAsset *HavokPhysics_GetAssetByName(const char *name)
{
  int v2; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  __int64 i; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v6; 
  const char **key; 
  int v8; 
  __int64 v9; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v10; 

  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v2 = 0;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v2;
      ++m_elem;
    }
  }
  if ( v2 > (int)m_hashMod )
  {
LABEL_13:
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11051, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_GetAssetByName couldn't find asset %s", name) )
      __debugbreak();
    return 0i64;
  }
  else
  {
    v6 = s_havokPhysicsAssets->m_map.m_elem;
    while ( 1 )
    {
      key = (const char **)v6[v2].key;
      if ( !strcmp(name, *key) )
        break;
      v8 = v2 + 1;
      if ( v2 + 1 <= (int)m_hashMod )
      {
        v9 = v8;
        v10 = &v6[v8];
        do
        {
          if ( v10->key != -1i64 )
            break;
          ++v8;
          ++v9;
          ++v10;
        }
        while ( v9 <= m_hashMod );
      }
      v2 = v8;
      if ( v8 > (int)m_hashMod )
        goto LABEL_13;
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    return (const PhysicsAsset *)key;
  }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v16; 
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *v33; 
  __int64 v34; 
  const hknpBody *v35; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v38; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  hknpCollisionQueryContext queryContext; 
  hkQuaternionf *qi; 
  const HavokPhysicsWorld *ConstWorld; 
  __int16 v44; 
  int contents; 
  int *v46; 
  int v47; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v49; 
  __int128 v50; 
  Physics_QueryPhaseSelection phaseSelection; 
  hknpClosestPointsQuery queryIn; 
  __int64 v53; 
  hknpShapeQueryInfo queryShapeInfo; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v56[64]; 
  hknpInplaceTriangleShape v57; 
  void *retaddr; 

  _RAX = &retaddr;
  v53 = -2i64;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  v16 = numBodies;
  qi = (hkQuaternionf *)rotation;
  _RBX = extendedData;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v57, *(float *)&_XMM1);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v57;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v57;
  __asm { vmovss  [rsp+360h+queryContext.m_initialCastFractionHint], xmm6 }
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfo.m_shapeKeyPath.m_size = 0;
  queryShapeInfo.m_body = NULL;
  queryShapeInfo.m_parentShape = NULL;
  queryShapeInfo.m_shapeKeyMask = NULL;
  queryShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm
  {
    vmovups xmm3, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rbp+260h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], xmm3
  }
  queryShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rbp+260h+queryShapeInfo.m_scalingInternals.m_offset.m_quad], xmm2
    vmovss  [rbp+260h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+260h+var_1F0.m_body], xmm0
  }
  targetShapeInfo.m_parentShape = NULL;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu xmmword ptr [rbp+260h+var_1F0.m_shapeToWorld], xmm1
  }
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm { vmovups xmmword ptr [rbp+260h+var_1F0.m_scalingInternals.m_scale.m_quad], xmm3 }
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vmovups xmmword ptr [rbp+260h+var_1F0.m_scalingInternals.m_offset.m_quad], xmm2
    vmovss  [rbp+260h+var_1F0.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  __asm { vmovss  [rbp+260h+var_2D0], xmm6 }
  ignoreBodies = NULL;
  v49 = 1;
  __asm { vmovdqu [rbp+260h+var_2B8], xmm0 }
  phaseSelection = All;
  queryIn.m_broadPhaseFilterMask = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15321, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15322, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15323, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15324, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15325, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15326, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15327, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15330, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+10h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+260h+var_2D0], xmm1
  }
  *(_QWORD *)&v50 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  ignoreBodies = extendedData->ignoreBodies;
  v44 = -1;
  contents = extendedData->contents;
  v46 = &v47;
  queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rbp+260h+var_190], ymm0
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rbp+260h+var_190+20h], ymm0
  }
  hkRotationImpl<float>::set((hkRotationImpl<float> *)v56, qi);
  _RAX = point;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbp+260h+var_190+30h], xmm0
  }
  queryShapeInfo.m_rootShape = shape;
  queryShapeInfo.m_shapeToWorld = (const hkTransformf *)v56;
  queryIn.m_shape = shape;
  __asm
  {
    vmovss  xmm0, [rbp+260h+maxDistance]
    vmovss  [rbp+260h+queryIn.m_maxDistance], xmm0
  }
  queryIn.m_body = NULL;
  queryIn.m_shapeTagCodec = s_shapeTagCodec;
  v33 = ConstWorld;
  queryIn.m_filter = ConstWorld->traceCollisionFilter;
  queryIn.m_filterData.m_materialId.m_value = -1;
  queryIn.m_filterData.m_collisionFilterInfo = extendedData->contents;
  queryIn.m_filterData.m_userData = (unsigned __int64)&v47;
  *(_DWORD *)queryIn.m_levelOfDetail = 0;
  if ( (_DWORD)v16 )
  {
    v34 = v16;
    do
    {
      if ( (*bodyIds & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15371, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] )") )
        __debugbreak();
      v35 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v33->world->getBody)(&v33->world->hknpWorldReader, *bodyIds);
      m_shape = v35->m_shape;
      if ( v33->traceCollisionFilter->isCollisionEnabled(v33->traceCollisionFilter, GET_CLOSEST_POINTS, (const hknpQueryFilterData *)&v44, v35) )
      {
        targetShapeInfo.m_body = v35;
        targetShapeInfo.m_rootShape = v35->m_shape;
        targetShapeInfo.m_parentShape = NULL;
        targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
        targetShapeInfo.m_shapeKeyPath.m_size = 0;
        targetShapeInfo.m_shapeToWorld = &v35->m_transform;
        targetShapeInfo.m_shapeKeyMask = NULL;
        targetShapeFilterDataIn.m_materialId.m_value = v35->m_materialId.m_value;
        targetShapeFilterDataIn.m_collisionFilterInfo = v35->m_collisionFilterInfo;
        targetShapeFilterDataIn.m_userData = v35->m_userData;
        s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, v35, m_shape, &targetShapeFilterDataIn);
        Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( Value )
          hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_Body_HK");
        hknpShapeQueryInterface::getClosestPoints(&queryContext, &queryIn, &queryShapeInfo, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, Collector);
        v38 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( v38 )
          hkMonitorStream::timerEnd(v38, "Et");
      }
      ++bodyIds;
      --v34;
    }
    while ( v34 );
  }
  if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
  __asm { vmovaps xmm6, xmmword ptr [rsp+360h+var_48+8] }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v21; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v24; 
  int v25; 
  int v26; 
  hknpCollisionResult *v27; 
  __int64 v29; 
  hknpBodyId *v35; 
  int Ref; 
  int v37; 
  unsigned int v38; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v40; 
  __int64 v41; 
  __int64 v42; 
  hknpCollisionResult *array; 
  int v44; 
  int v45; 
  int v46; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v48; 
  __int128 v49; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v51[2]; 
  __int16 v52; 
  int contents; 
  int *v54; 
  int v55; 
  char v56; 
  hknpShape *v57; 
  __int64 v59; 
  __int64 v60; 
  hkRotationImpl<float> v61; 

  v60 = -2i64;
  _R15 = point;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+168h+var_110], xmm0
  }
  ignoreBodies = NULL;
  v48 = 1;
  __asm { vmovdqu [rsp+168h+var_F8], xmm0 }
  phaseSelection = All;
  v56 = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14441, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14442, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid shape", "shape") )
    __debugbreak();
  _RBX = extendedData;
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14443, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid result", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14444, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = extendedData->ignoreBodies;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+10h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rsp+168h+var_110], xmm1
  }
  *(_QWORD *)&v49 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  v57 = shape;
  __asm
  {
    vmovss  xmm0, [rsp+168h+maxDistance]
    vmovss  [rsp+168h+var_A8], xmm0
  }
  v59 = 0i64;
  v51[0] = (__int64)s_shapeTagCodec;
  v51[1] = *ConstWorld;
  v52 = -1;
  contents = extendedData->contents;
  v54 = &v46;
  v55 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14466, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14469, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  hkRotationImpl<float>::set(&v61, rotation);
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups [rsp+168h+var_58], xmm0
  }
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_HK");
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GetClosestPoints");
  (*(void (__fastcall **)(__int64, __int64 *, hkRotationImpl<float> *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 344i64))(ConstWorld[3] + 32, v51, &v61, Collector);
  Sys_ProfEndNamedEvent();
  v21 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v21 )
    hkMonitorStream::timerEnd(v21, "Et");
  if ( extendedData->simplify )
  {
    array = NULL;
    v44 = 0;
    v45 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v24 = hkMemHeapAllocator();
    v25 = 0;
    if ( (int)NumHits > 0 )
    {
      v26 = NumHits;
      if ( (int)NumHits < 0 )
        v26 = 0;
      hkArrayUtil::_reserve(v24, &array, v26, 112);
      v25 = v44;
    }
    v27 = array;
    _RCX = (char *)&array[v25];
    v29 = NumHits;
    if ( (int)NumHits > 0 )
    {
      _RBX = (char *)Hits - _RCX;
      do
      {
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbx+rcx]
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr [rbx+rcx+20h]
            vmovups ymmword ptr [rcx+20h], ymm1
            vmovups ymm0, ymmword ptr [rbx+rcx+40h]
            vmovups ymmword ptr [rcx+40h], ymm0
            vmovups xmm1, xmmword ptr [rbx+rcx+60h]
            vmovups xmmword ptr [rcx+60h], xmm1
          }
        }
        _RCX += 112;
        --v29;
      }
      while ( v29 );
      v27 = array;
    }
    v44 = NumHits;
    if ( (int)NumHits > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v27, 0, NumHits - 1, HavokPhysics_QueryHitSort);
    Collector->reset(Collector);
    v35 = (hknpBodyId *)array;
    if ( array != &array[v44] )
    {
      do
      {
        Ref = HavokPhysics_GetRef(result->m_worldId, v35[18]);
        v37 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
        v38 = 0;
        if ( v37 <= 0 )
        {
LABEL_43:
          Collector->addHit(Collector, (const hknpCollisionResult *)v35);
        }
        else
        {
          while ( 1 )
          {
            if ( v38 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
            {
              LODWORD(v42) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
              LODWORD(v41) = v38;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v41, v42) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v38);
            if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v38 >= v37 )
              goto LABEL_43;
          }
        }
        v35 += 28;
      }
      while ( v35 != (hknpBodyId *)&array[v44] );
    }
    v40 = hkMemHeapAllocator();
    v44 = 0;
    if ( v45 >= 0 )
      hkMemoryAllocator::bufFree2(v40, array, 112, v45 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpBody *v26; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v35; 
  __int64 v37; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  __int16 v39; 
  int contents; 
  int *v41; 
  hknpCollisionQueryContext queryContext; 
  hknpClosestPointsQuery queryIn; 
  hkQuaternionf *qi; 
  int v45; 
  __int64 v46; 
  int v47; 
  __int128 v48; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v50; 
  hknpShapeQueryInfo queryShapeInfo; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v53[64]; 
  hknpInplaceTriangleShape v54; 
  void *retaddr; 

  _RAX = &retaddr;
  v50 = -2i64;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  _R13 = point;
  qi = (hkQuaternionf *)rotation;
  _RDI = extendedData;
  v39 = -1;
  contents = 0;
  v41 = NULL;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v54, *(float *)&_XMM1);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v54;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v54;
  __asm { vmovss  [rsp+350h+queryContext.m_initialCastFractionHint], xmm6 }
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+250h+queryShapeInfo.m_body], xmm0
  }
  queryShapeInfo.m_parentShape = NULL;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu xmmword ptr [rbp+250h+queryShapeInfo.m_shapeToWorld], xmm1
  }
  queryShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm
  {
    vmovups xmm3, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rbp+250h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], xmm3
  }
  queryShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rbp+250h+queryShapeInfo.m_scalingInternals.m_offset.m_quad], xmm2
    vmovss  [rbp+250h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm { vmovdqu xmmword ptr [rbp+250h+var_1F0.m_body], xmm0 }
  targetShapeInfo.m_parentShape = NULL;
  __asm { vmovdqu xmmword ptr [rbp+250h+var_1F0.m_shapeToWorld], xmm1 }
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm { vmovups xmmword ptr [rbp+250h+var_1F0.m_scalingInternals.m_scale.m_quad], xmm3 }
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vmovups xmmword ptr [rbp+250h+var_1F0.m_scalingInternals.m_offset.m_quad], xmm2
    vmovss  [rbp+250h+var_1F0.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  __asm { vmovss  [rbp+250h+var_288], xmm6 }
  v46 = 0i64;
  v47 = 1;
  __asm { vmovdqu [rbp+250h+var_270], xmm0 }
  phaseSelection = All;
  queryIn.m_filterData.m_materialId.m_value = -1;
  queryIn.m_filterData.m_collisionFilterInfo = 0;
  queryIn.m_filterData.m_userData = 0i64;
  queryIn.m_filter = NULL;
  queryIn.m_shapeTagCodec = NULL;
  *(_DWORD *)queryIn.m_levelOfDetail = 2;
  queryIn.m_broadPhaseFilterMask = -5;
  queryIn.m_shape = NULL;
  __asm { vmovss  [rbp+250h+queryIn.m_maxDistance], xmm6 }
  queryIn.m_body = NULL;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15227, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15228, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire getclosest points with body with invalid body id %i", "bodyId.isValid()", v37) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15229, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15230, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15231, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire get closest points with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15232, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire get closest points with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15233, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15234, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15237, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v26 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = v26->m_shape;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+10h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+250h+var_288], xmm1
  }
  *(_QWORD *)&v48 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  v39 = -1;
  contents = extendedData->contents;
  v41 = &v45;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, GET_CLOSEST_POINTS, (const hknpQueryFilterData *)&v39, v26) )
  {
    queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rbp+250h+var_190], ymm0
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rbp+250h+var_190+20h], ymm0
    }
    hkRotationImpl<float>::set((hkRotationImpl<float> *)v53, qi);
    __asm
    {
      vmovups xmm0, xmmword ptr [r13+0]
      vmovups xmmword ptr [rbp+250h+var_190+30h], xmm0
    }
    queryShapeInfo.m_rootShape = shape;
    queryShapeInfo.m_shapeToWorld = (const hkTransformf *)v53;
    targetShapeInfo.m_body = v26;
    targetShapeInfo.m_rootShape = v26->m_shape;
    targetShapeInfo.m_shapeToWorld = &v26->m_transform;
    targetShapeFilterDataIn.m_materialId.m_value = v26->m_materialId.m_value;
    targetShapeFilterDataIn.m_collisionFilterInfo = v26->m_collisionFilterInfo;
    targetShapeFilterDataIn.m_userData = v26->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, v26, m_shape, &targetShapeFilterDataIn);
    queryIn.m_shape = shape;
    __asm
    {
      vmovss  xmm0, [rbp+250h+maxDistance]
      vmovss  [rbp+250h+queryIn.m_maxDistance], xmm0
    }
    queryIn.m_shapeTagCodec = s_shapeTagCodec;
    queryIn.m_filter = ConstWorld->traceCollisionFilter;
    queryIn.m_filterData.m_collisionFilterInfo = extendedData->contents;
    queryIn.m_filterData.m_userData = (unsigned __int64)&v45;
    *(_DWORD *)queryIn.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_Body_HK");
    hknpShapeQueryInterface::getClosestPoints(&queryContext, &queryIn, &queryShapeInfo, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, Collector);
    v35 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v35 )
      hkMonitorStream::timerEnd(v35, "Et");
    if ( !queryContext.m_externallyAllocatedTriangles )
    {
      hkReferencedObject::removeReference(queryContext.m_queryTriangle);
      hkReferencedObject::removeReference(queryContext.m_targetTriangle);
    }
  }
  else if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
  __asm { vmovaps xmm6, xmmword ptr [rsp+350h+var_48+8] }
}

/*
==============
HavokPhysics_GetClothVisContexts
==============
*/
void HavokPhysics_GetClothVisContexts(const unsigned int clothIdx, unsigned int *numContexts, hclClothContext **clothContexts)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v7; 
  hclClothContext *clothVisContext; 
  hclClothContext *v9; 

  if ( !numContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3833, ASSERT_TYPE_ASSERT, "(numContexts)", (const char *)&queryFormat, "numContexts") )
    __debugbreak();
  if ( !clothContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3834, ASSERT_TYPE_ASSERT, "(clothContexts)", (const char *)&queryFormat, "clothContexts") )
    __debugbreak();
  *numContexts = 0;
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)(3 * clothIdx + 3));
  v7 = HavokPhysics_GetMutableWorld((Physics_WorldId)(3 * clothIdx + 4));
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
    clothContexts[(*numContexts)++] = clothVisContext;
  v9 = v7->clothVisContext;
  if ( v9 )
    clothContexts[(*numContexts)++] = v9;
}

/*
==============
HavokPhysics_GetConstraintBodyIds
==============
*/
void HavokPhysics_GetConstraintBodyIds(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, hknpBodyId *bodyIdA, hknpBodyId *bodyIdB)
{
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int *v9; 
  __int64 v10; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11522, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get ConstraintBodyIds with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId.m_value == 0x7FFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11523, ASSERT_TYPE_ASSERT, "(constraintId.isValid())", "%s\n\tHavok Physics: Trying to Get ConstraintBodyIds with invalid constraint id for world %i", "constraintId.isValid()", v10) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11528, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetConstraintBodyIds %i: world is NULL", "havokPhysicsWorld->world", v10) )
      __debugbreak();
  }
  v9 = (unsigned int *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getConstraint)(&ConstWorld->world->hknpWorldReader, constraintId.m_value);
  bodyIdA->m_serialAndIndex = *v9;
  bodyIdB->m_serialAndIndex = v9[1];
}

/*
==============
HavokPhysics_GetContentsFromShapeList
==============
*/
__int64 HavokPhysics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_shapeContents.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetDebugLines
==============
*/
hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *HavokPhysics_GetDebugLines(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v2; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v2 = MutableWorld;
  if ( MutableWorld->debugLines )
    return MutableWorld->debugLines;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24033, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  return v2->debugLines;
}

/*
==============
HavokPhysics_GetDebugWorldPersistantMemoryPeak
==============
*/
__int64 HavokPhysics_GetDebugWorldPersistantMemoryPeak(Physics_WorldId worldId)
{
  return LODWORD(HavokPhysics_GetMutableWorld(worldId)->persistentMemoryStats.m_allocatorStats.m_peakInUse);
}

/*
==============
HavokPhysics_GetDetailBoundingSphereMax
==============
*/
float HavokPhysics_GetDetailBoundingSphereMax(Physics_WorldId worldId)
{
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11093, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get bounding sphere max with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RAX = HavokPhysics_GetConstWorld(worldId);
  _RBX = _RAX;
  if ( _RAX->world )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1C8h] }
  }
  else
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11097, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailBoundingSphereMax %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
    __asm { vmovss  xmm0, dword ptr [rbx+1C8h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_GetDetailCollisionContents
==============
*/
__int64 HavokPhysics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *m_data; 
  __int64 result; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *i; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8268, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision contents with invalid detail collision", "detailCollision") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8272, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionContents %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  m_data = HavokPhysicsXModelLODFromDetailCol->m_shapeTagData.m_data;
  result = 0i64;
  for ( i = &m_data[HavokPhysicsXModelLODFromDetailCol->m_shapeTagData.m_size]; m_data != i; ++m_data )
    result = m_data->m_collisionFilterInfo | (unsigned int)result;
  return result;
}

/*
==============
HavokPhysics_GetDetailCollisionShape
==============
*/
hknpShape *HavokPhysics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  __int64 v2; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 

  v2 = shapeIdx;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8455, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision shape with invalid detail collision", "detailCollision") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetDetailCollisionShapeCount(detailCollision)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8456, ASSERT_TYPE_ASSERT, "(shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision ))", "%s\n\tHavokPhysics: Trying to get detail collision shape with invalid shape index", "shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision )") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8460, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShape %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  return HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v2];
}

/*
==============
HavokPhysics_GetDetailCollisionShapeCount
==============
*/
__int64 HavokPhysics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8307, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision shape count with invalid detail collision", "detailCollision") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( HavokPhysicsXModelLODFromDetailCol )
    return (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8311, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShapeCount %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  return MEMORY[8];
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTag
==============
*/
__int64 HavokPhysics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return 0i64;
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTransform
==============
*/
void HavokPhysics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, hkVector4f *shapePosition, hkQuaternionf *shapeOrientationAsQuat)
{
  __int64 v4; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 

  v4 = shapeIdx;
  _R14 = shapePosition;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8362, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get DetailCollisionShapeTransform with invalid physics asset", "detailCollision") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetDetailCollisionShapeCount(detailCollision)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8363, ASSERT_TYPE_ASSERT, "(shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision ))", "%s\n\tHavokPhysics: Trying to get DetailCollisionShapeTransform with invalid shape index", "shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision )") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8367, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShapeTransform %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  _RDX = &HavokPhysicsXModelLODFromDetailCol->m_bodyBindPoses.m_data[v4].m_rotation;
  __asm
  {
    vmovups xmm0, xmmword ptr [rdx+30h]
    vmovups xmmword ptr [r14], xmm0
  }
  hkQuaternionf::setAndNormalize(shapeOrientationAsQuat, _RDX);
}

/*
==============
HavokPhysics_GetDetailHitData
==============
*/
const Physics_DetailHitData *HavokPhysics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13653, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13654, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(result->m_collector, modifierIndex);
  if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13657, ASSERT_TYPE_ASSERT, "(modifier)", (const char *)&queryFormat, "modifier") )
    __debugbreak();
  if ( hitIndex < HavokPhysicsHitCollector_DetailTraceModifier::GetNumDetailHitDatas(Modifier) )
    return HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, hitIndex);
  else
    return 0i64;
}

/*
==============
HavokPhysics_GetErrorString
==============
*/
const char *HavokPhysics_GetErrorString()
{
  return s_errorExtraString;
}

/*
==============
HavokPhysics_GetFixedMemoryPoolUsage
==============
*/
float HavokPhysics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16459, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to GetFixedMemoryPoolUsage with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  ConstWorld->persistentStreamAllocator->getBytesUsed(ConstWorld->persistentStreamAllocator);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, eax
  }
  hkFixedBlockStreamAllocator::getCapacity(ConstWorld->persistentStreamAllocator);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vdivss  xmm0, xmm6, xmm0
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_GetHavokPhysicsAsset
==============
*/
const HavokPhysicsAsset *HavokPhysics_GetHavokPhysicsAsset(const PhysicsAsset *physicsAsset)
{
  int m_hashMod; 
  unsigned __int32 v3; 
  unsigned __int32 v4; 
  int v5; 
  int v6; 
  const PhysicsAsset *key; 
  __int64 v8; 
  int v9; 
  unsigned __int64 val; 
  unsigned __int64 v12; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8031, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Get Havok Physics Asset from NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8034, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", (const char *)&queryFormat, "s_havokPhysicsAssets") )
    __debugbreak();
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v3 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v4 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v5 = m_hashMod & (v3 ^ ((v4 >> 2) + v4 + (v3 << 6) - 1640531527)), v6 = v5, key = (const PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v5].key, key == (const PhysicsAsset *)-1i64) )
  {
LABEL_11:
    v6 = m_hashMod + 1;
  }
  else
  {
    while ( key != physicsAsset )
    {
      v5 = m_hashMod & (v5 + 1);
      v6 = v5;
      key = (const PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v5].key;
      if ( key == (const PhysicsAsset *)-1i64 )
        goto LABEL_11;
    }
  }
  v8 = 0i64;
  if ( v6 > m_hashMod )
  {
    val = v12;
    v9 = -2147220992;
  }
  else
  {
    v9 = 0;
    val = s_havokPhysicsAssets->m_map.m_elem[v6].val;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( v9 >= 0 )
    return (const HavokPhysicsAsset *)val;
  return (const HavokPhysicsAsset *)v8;
}

/*
==============
HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol
==============
*/
const HavokPhysicsXModelLOD *HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(const XModelDetailCollision *const detailCollision)
{
  int m_hashMod; 
  unsigned __int32 v3; 
  unsigned __int32 v4; 
  int v5; 
  int v6; 
  const XModelDetailCollision *key; 
  __int64 v8; 
  int v9; 
  unsigned __int64 val; 
  unsigned __int64 v12; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8068, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavok Physics: Trying to Get Havok Physics XModel LOD from NULL XModelDetailCollision", "detailCollision") )
    __debugbreak();
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v3 = _byteswap_ulong(-1640531535 * HIDWORD(detailCollision)), v4 = _byteswap_ulong(-1640531535 * (_DWORD)detailCollision), v5 = m_hashMod & (v3 ^ ((v4 >> 2) + v4 + (v3 << 6) - 1640531527)), v6 = v5, key = (const XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v5].key, key == (const XModelDetailCollision *)-1i64) )
  {
LABEL_8:
    v6 = m_hashMod + 1;
  }
  else
  {
    while ( key != detailCollision )
    {
      v5 = m_hashMod & (v5 + 1);
      v6 = v5;
      key = (const XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v5].key;
      if ( key == (const XModelDetailCollision *)-1i64 )
        goto LABEL_8;
    }
  }
  v8 = 0i64;
  if ( v6 > m_hashMod )
  {
    val = v12;
    v9 = -2147220992;
  }
  else
  {
    v9 = 0;
    val = s_havokPhysicsXModelLODs->m_map.m_elem[v6].val;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( v9 >= 0 )
    return (const HavokPhysicsXModelLOD *)val;
  return (const HavokPhysicsXModelLOD *)v8;
}

/*
==============
HavokPhysics_GetInstanceAsset
==============
*/
const PhysicsAsset *HavokPhysics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10931, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10932, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Instance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10937, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetInstanceAsset %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstanceDetailModel
==============
*/
const XModel *HavokPhysics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10954, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance detail Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10955, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get detailInstance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10960, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailModel %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetDetailModel(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstanceXModel
==============
*/
const XModel *HavokPhysics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10977, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10978, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10983, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetXModel %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetXModel(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstantiatiationPenetrationDepthForAsset
==============
*/
float HavokPhysics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const hkVector4f *position, const hkQuaternionf *orientation, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  int v24; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  hknpShape **m_data; 
  hknpShape *customShape; 
  hknpShape *v34; 
  hkMemoryAllocator *v70; 
  hkMemoryAllocator *v71; 
  float fmt; 
  HavokPhysics_CollisionQueryResult *result; 
  int v83; 
  int numInOut; 
  Physics_WorldId worldIda; 
  int v86; 
  void *v87; 
  int v88; 
  int v89; 
  void *p; 
  int v91; 
  int v92; 
  __int64 v93; 
  __int16 v94; 
  int v95; 
  hkQuaternionf *quat; 
  const hkVector4f *v97; 
  const PhysicsAsset *v98; 
  Physics_GetClosestPointsExtendedData extendedData; 
  __int64 v100; 
  hkVector4f point; 
  hkQuaternionf rotation; 
  char v103; 
  void *retaddr; 

  _RAX = &retaddr;
  v100 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  _RDI = orientation;
  quat = (hkQuaternionf *)orientation;
  _R14 = position;
  v97 = position;
  v98 = physicsAsset;
  worldIda = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9953, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(result) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9954, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for NULL Physics Asset in world %i", "physicsAsset", result) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
  {
LABEL_64:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9955, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for PhysicsAsset with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v83 & 0x7F800000) == 2139095040 )
  {
LABEL_65:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9956, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for PhysicsAsset with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9957, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  if ( shapeOverride->shapeOverride != -1 && shapeOverride->customShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9958, ASSERT_TYPE_ASSERT, "(shapeOverride->shapeOverride == -1 || !shapeOverride->customShape)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with shape override and custom shape - pick one", "shapeOverride->shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || !shapeOverride->customShape") )
    __debugbreak();
  if ( !shapeOverride->physicsAssetAddendum && shapeOverride->shapeAddendum != -1 )
  {
    LODWORD(result) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9959, ASSERT_TYPE_ASSERT, "(shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == -1)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with addendum shape but no addendumasset - world index %i", "shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == PHYSICSSHAPE_OVERRIDEID_INVALID", result) )
      __debugbreak();
  }
  v24 = shapeOverride->shapeOverride;
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9965, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetInstantiatiationPenetrationDepthForAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vxorps  xmm9, xmm9, xmm9
  }
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( v24 != -1 )
  {
    if ( m_physicsSystemData->m_bodyCinfos.m_size > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9974, ASSERT_TYPE_ASSERT, "(localShapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "localShapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
      __debugbreak();
    if ( v24 >= WorldCollision_GetMapEntsShapeCount() )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 146i64);
  }
  v86 = 0;
  numInOut = 0;
  hkMemHeapAllocator();
  v87 = NULL;
  v88 = 0;
  v89 = 0x80000000;
  p = NULL;
  v91 = 0;
  v92 = 0x80000000;
  v83 = 0;
  hkMemHeapAllocator();
  p = NULL;
  v91 = 0;
  v92 = 0x80000000;
  v93 = 0i64;
  v94 = 0;
  v95 = 32;
  v86 = ignoreSystems;
  extendedData.simplify = 0;
  __asm { vmovss  [rbp+0A0h+var_F8.collisionBuffer], xmm10 }
  extendedData.nonBrushShape = NULL;
  extendedData.phaseSelection = All;
  extendedData.contents = 8389905;
  extendedData.ignoreBodies = (HavokPhysics_IgnoreBodies *)&v86;
  ClosestResult = PhysicsQuery_GetClosestResult(worldId);
  m_data = (hknpShape **)m_physicsSystemData->m_bodyCinfos.m_data;
  if ( m_data != &m_data[24 * m_physicsSystemData->m_bodyCinfos.m_size] )
  {
    _R13 = m_data + 8;
    __asm { vmovss  xmm11, dword ptr cs:__xmm@80000000800000008000000080000000 }
    while ( 1 )
    {
      customShape = *m_data;
      if ( v24 == -1 || !WorldCollision_GetMapEntsShape(v24) )
      {
        if ( shapeOverride->customShape )
          customShape = shapeOverride->customShape;
      }
      else
      {
        customShape = WorldCollision_GetMapEntsShape(v24);
      }
      v34 = customShape;
      if ( (customShape->m_flags.m_storage & 1) == 0 )
        v34 = NULL;
      if ( !v34 )
        break;
      hkVector4f::setRotatedDir(&point, quat, (const hkVector4f *)_R13 - 1);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbp+0A0h+point.m_quad]
        vaddps  xmm1, xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rbp+0A0h+point.m_quad], xmm1
        vmovups xmm8, xmmword ptr [r13+0]
      }
      _RAX = quat;
      __asm
      {
        vmovups xmm7, xmmword ptr [rax]
        vbroadcastss xmm6, dword ptr [r13+0Ch]
        vbroadcastss xmm5, dword ptr [rax+0Ch]
        vshufps xmm0, xmm7, xmm7, 0C9h ; ''
        vmulps  xmm2, xmm8, xmm0
        vshufps xmm1, xmm8, xmm8, 0C9h ; ''
        vmulps  xmm0, xmm7, xmm1
        vsubps  xmm3, xmm2, xmm0
        vmulps  xmm1, xmm7, xmm6
        vmulps  xmm2, xmm8, xmm5
        vshufps xmm0, xmm3, xmm3, 0C9h ; ''
        vaddps  xmm1, xmm0, xmm1
        vaddps  xmm4, xmm1, xmm2
        vmulps  xmm3, xmm5, xmm6
        vmovups xmmword ptr [rbp+0A0h+rotation.m_vec.m_quad], xmm3
        vdpps   xmm0, xmm8, xmm7, 7Fh
        vsubps  xmm1, xmm3, xmm0
        vblendps xmm5, xmm4, xmm1, 8
        vdpps   xmm3, xmm5, xmm5, 0FFh
        vmovups xmmword ptr [rbp+0A0h+rotation.m_vec.m_quad], xmm3
        vrsqrtps xmm2, xmm3
        vmulps  xmm4, xmm2, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
        vmulps  xmm1, xmm2, xmm3
        vmulps  xmm2, xmm1, xmm2
        vmovups xmm0, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
        vsubps  xmm1, xmm0, xmm2
        vmulps  xmm2, xmm1, xmm4
        vmulps  xmm0, xmm5, xmm2
        vmovups xmmword ptr [rbp+0A0h+rotation.m_vec.m_quad], xmm0
      }
      if ( !ClosestResult->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
        __debugbreak();
      HavokPhysicsHitCollector::Reset(ClosestResult->m_collector, 1);
      __asm { vmovss  dword ptr [rsp+1A0h+fmt], xmm10 }
      HavokPhysics_GetClosestPoints(worldIda, customShape, &point, &rotation, fmt, &extendedData, ClosestResult);
      if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
      {
        _RAX = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
        __asm
        {
          vmovss  xmm0, dword ptr [rax+20h]
          vxorps  xmm1, xmm0, xmm11
          vmaxss  xmm9, xmm1, xmm9
        }
      }
      m_data += 24;
      _R13 += 24;
      if ( m_data == (hknpShape **)&m_physicsSystemData->m_bodyCinfos.m_data[m_physicsSystemData->m_bodyCinfos.m_size] )
        goto LABEL_56;
    }
    Com_PrintWarning(20, "Physics: Havok shape from asset %s is not a simple convex, which may lead to the object not spawning/rendering", v98->name);
    __asm { vmovss  xmm9, cs:__real@bf800000 }
  }
LABEL_56:
  v70 = hkMemHeapAllocator();
  v91 = 0;
  if ( v92 >= 0 )
    hkMemoryAllocator::bufFree2(v70, p, 4, v92 & 0x3FFFFFFF);
  p = NULL;
  v92 = 0x80000000;
  v71 = hkMemHeapAllocator();
  v88 = 0;
  if ( v89 >= 0 )
    hkMemoryAllocator::bufFree2(v71, v87, 8, v89 & 0x3FFFFFFF);
  __asm { vmovaps xmm0, xmm9 }
  _R11 = &v103;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_GetLandscapeShapeHelper
==============
*/
void HavokPhysics_GetLandscapeShapeHelper(const hknpShape **shape, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *meshShapeKey, int *shapeKeyPathSizeOut, hknpShapeCollector *shapeCollector)
{
  if ( (*shape)->m_type.m_storage != 22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 734, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::USER_0)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::USER_0") )
    __debugbreak();
  StaticModels_HavokShape_GetLandscapeShapeHelper(shape, meshShapeKey, shapeKeyPathSizeOut, shapeCollector);
}

/*
==============
HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex
==============
*/
hknpMotionPropertiesId *HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(hknpMotionPropertiesId *result, const unsigned int gravityPropertyIndex, const unsigned int motionPropertiesNameCRC32Index)
{
  unsigned int v6; 
  __int64 v8; 
  int m_size; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  int v13; 

  if ( !s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5538, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMotionPropertiesLibrary.list") )
    __debugbreak();
  if ( motionPropertiesNameCRC32Index >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size )
  {
    m_size = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    LODWORD(v8) = motionPropertiesNameCRC32Index;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5539, ASSERT_TYPE_ASSERT, "(unsigned)( motionPropertiesNameCRC32Index ) < (unsigned)( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() )", "motionPropertiesNameCRC32Index doesn't index s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()\n\t%i not in [0, %i)", v8, m_size) )
      __debugbreak();
  }
  if ( gravityPropertyIndex > 4 )
  {
    v13 = 4;
    v11 = gravityPropertyIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5540, ASSERT_TYPE_ASSERT, "( gravityPropertyIndex ) <= ( Physics_GravityType_Count )", "%s <= %s\n\t%u, %u", "gravityPropertyIndex", "Physics_GravityType_Count", v11, v13) )
      __debugbreak();
  }
  if ( !s_motionPropertiesAreReorderedForSPGold )
  {
    v6 = gravityPropertyIndex * s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    goto LABEL_18;
  }
  if ( motionPropertiesNameCRC32Index < 0xB )
  {
    LOWORD(v6) = 11 * gravityPropertyIndex;
LABEL_18:
    LOWORD(v6) = motionPropertiesNameCRC32Index + v6;
    goto LABEL_19;
  }
  if ( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size < 0xBu )
  {
    LODWORD(v12) = 11;
    LODWORD(v10) = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5553, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() ) >= ( SP_GOLD_MOTION_PROPERTIES_LIST_COUNT )", "%s >= %s\n\t%u, %u", "s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()", "SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", v10, v12) )
      __debugbreak();
  }
  v6 = gravityPropertyIndex * (s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size - 11) + motionPropertiesNameCRC32Index + 44;
LABEL_19:
  result->m_value = v6 + s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  return result;
}

/*
==============
HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId
==============
*/
__int64 HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(const hknpMotionPropertiesId id)
{
  unsigned __int16 m_value; 
  unsigned int v3; 
  int v5; 
  int v6; 

  if ( !s_motionPropertiesAreReorderedForSPGold )
    return (unsigned int)((id.m_value - s_havokPhysicsMotionPropertiesLibrary.firstId.m_value) % s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size);
  m_value = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  if ( id.m_value < s_havokPhysicsMotionPropertiesLibrary.firstId.m_value )
  {
    v6 = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
    v5 = id.m_value;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5573, ASSERT_TYPE_ASSERT, "( id.value() ) >= ( s_havokPhysicsMotionPropertiesLibrary.firstId.value() )", "%s >= %s\n\t%u, %u", "id.value()", "s_havokPhysicsMotionPropertiesLibrary.firstId.value()", v5, v6) )
      __debugbreak();
    m_value = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  }
  v3 = id.m_value - m_value;
  if ( v3 >= 0x37 )
    return (v3 - 55) % (s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size - 11) + 11;
  else
    return v3 % 0xB;
}

/*
==============
HavokPhysics_GetNumContentsInShapeList
==============
*/
__int64 HavokPhysics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapeContents.m_size;
}

/*
==============
HavokPhysics_GetNumConvexCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_convexCounts.m_size;
}

/*
==============
HavokPhysics_GetNumServerRigidBodysInAsset
==============
*/
__int64 HavokPhysics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  int *m_data; 
  unsigned int v4; 
  int *i; 
  int v6; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8504, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset server body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8508, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetNumServerRigidBodysInAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8509, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetNumServerRigidBodysInAsset %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_data = HavokPhysicsAsset->m_bodyServerUsage.m_data;
  v4 = 0;
  for ( i = &m_data[HavokPhysicsAsset->m_bodyServerUsage.m_size]; m_data != i; ++m_data )
  {
    v6 = v4++;
    if ( (unsigned int)*m_data > 1 )
      v4 = v6;
  }
  return v4;
}

/*
==============
HavokPhysics_GetNumShapeNamesInShapeList
==============
*/
__int64 HavokPhysics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapeNames.m_size;
}

/*
==============
HavokPhysics_GetNumShapesInShapeList
==============
*/
__int64 HavokPhysics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapes.m_size;
}

/*
==============
HavokPhysics_GetNumTriCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_triCounts.m_size;
}

/*
==============
HavokPhysics_GetNumVertCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_vertCounts.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyBounds
==============
*/
void HavokPhysics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, hkTransformf *transform, hkAabb *aabb)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const hknpShape *m_ptr; 

  v4 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8419, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body bounds with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8420, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset body bounds with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8424, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8425, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_ptr = HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v4].m_shape.m_ptr;
  m_ptr->calcAabb((hknpShape *)m_ptr, transform, aabb);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyCount
==============
*/
__int64 HavokPhysics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8291, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8295, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyCount %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8296, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyCount %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (unsigned int)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyName
==============
*/
const char *HavokPhysics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8322, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8323, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8327, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8328, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (const char *)((unsigned __int64)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyTransform
==============
*/
void HavokPhysics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, hkVector4f *bodyPosition, hkQuaternionf *bodyOrientationAsQuat)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v4 = bodyIdx;
  _RBP = bodyOrientationAsQuat;
  _R14 = bodyPosition;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8342, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get PhysicsAssetBodyTransform with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8343, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get PhysicsAssetBodyTransform with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8347, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyTransform %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  _RCX = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v4];
  __asm
  {
    vmovups xmm0, xmmword ptr [rcx+30h]
    vmovups xmmword ptr [r14], xmm0
    vmovups xmm1, xmmword ptr [rcx+40h]
    vmovups xmmword ptr [rbp+0], xmm1
  }
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintBodyIds
==============
*/
void HavokPhysics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo *m_data; 

  v4 = constraintIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8398, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset constraint body ids with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8399, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset constraint body ids with invalid constraint index", "constraintIdx >= 0 && constraintIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8403, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintBodyIds %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8404, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintBodyIds %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_data = HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data;
  *bodyId1 = m_data[v4].m_bodyA.m_serialAndIndex;
  *bodyId2 = m_data[v4].m_bodyB.m_serialAndIndex;
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintCount
==============
*/
__int64 HavokPhysics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8382, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset constraint count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8386, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintCount %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8387, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintCount %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (unsigned int)HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetContents
==============
*/
__int64 HavokPhysics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned int v4; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *m_data; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *i; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8235, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset contents with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8239, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetContents %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8240, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetContents %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  v4 = 0;
  m_data = m_physicsSystemData->m_bodyCinfos.m_data;
  for ( i = &m_data[m_physicsSystemData->m_bodyCinfos.m_size]; m_data != i; ++m_data )
    v4 |= m_data->m_collisionFilterInfo;
  return v4;
}

/*
==============
HavokPhysics_GetPhysicsAssetShape
==============
*/
const hknpShape *HavokPhysics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8439, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset shape with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8440, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset shape with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8444, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetShape %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8445, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetShape %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2].m_shape.m_ptr;
}

/*
==============
HavokPhysics_GetPhysicsAssetShapeTag
==============
*/
unsigned __int16 HavokPhysics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v5; 
  unsigned int v6; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8470, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset shapeTag with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8471, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset shapeTag with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8475, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetShapeTag %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8476, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetShapeTag %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  v5 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2];
  v6 = *(_DWORD *)(v5 + 16);
  shapeTagData.m_materialCRC = 0;
  shapeTagData.m_collisionFilterInfo = v6;
  LOWORD(v6) = *(_WORD *)(v5 + 20);
  shapeTagData.m_userData = 0i64;
  shapeTagData.m_materialId.m_value = v6;
  return HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
}

/*
==============
HavokPhysics_GetRef
==============
*/
int HavokPhysics_GetRef(const hknpBody *body)
{
  return truncate_cast<int,unsigned __int64>(LODWORD(body->m_userData));
}

/*
==============
HavokPhysics_GetRef
==============
*/
int HavokPhysics_GetRef(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v5; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11075, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get ref with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11076, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Ref with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11080, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRef %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  v5 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  return truncate_cast<int,unsigned __int64>(*(unsigned int *)(v5 + 160));
}

/*
==============
HavokPhysics_GetRigidBodyAABB
==============
*/
void HavokPhysics_GetRigidBodyAABB(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb, bool worldSpace)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v30; 
  __int64 v32; 
  _BYTE v33[64]; 

  _RBP = aabb;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11678, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11679, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid body id for world %i", "bodyId.isValid()", v32) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11684, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v32) )
      __debugbreak();
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( worldSpace )
  {
    _RCX = ConstWorld->world;
    __asm
    {
      vmovdqu xmm3, xmmword ptr [rax+50h]
      vmovaps [rsp+0B8h+var_28], xmm6
      vmovdqu xmm4, xmmword ptr [rcx+5B0h]
      vpshufb xmm0, xmm3, xmmword ptr [rcx+590h]
      vpand   xmm1, xmm0, xmm4
      vpaddd  xmm2, xmm1, xmmword ptr [rcx+600h]
      vpshufb xmm0, xmm3, xmmword ptr [rcx+5A0h]
      vmovups xmm3, xmmword ptr [rcx+560h]
      vpand   xmm1, xmm0, xmm4
      vmovups xmm4, xmmword ptr [rcx+540h]
      vcvtdq2ps xmm6, xmm2
      vpaddd  xmm2, xmm1, xmmword ptr [rcx+5F0h]
      vmulps  xmm0, xmm3, xmm6
      vmovaps xmm6, [rsp+0B8h+var_28]
      vsubps  xmm1, xmm0, xmm4
      vcvtdq2ps xmm5, xmm2
      vmulps  xmm2, xmm3, xmm5
      vsubps  xmm0, xmm2, xmm4
      vmovups xmmword ptr [rbp+10h], xmm0
      vmovups xmmword ptr [rbp+0], xmm1
    }
  }
  else
  {
    __asm { vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants }
    v30 = *(_QWORD *)(_RAX + 96);
    __asm
    {
      vmovups [rsp+0B8h+var_78], ymm0
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
      vmovups [rsp+0B8h+var_58], ymm0
    }
    (*(void (__fastcall **)(__int64, _BYTE *, hkAabb *))(*(_QWORD *)v30 + 32i64))(v30, v33, _RBP);
  }
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMass
==============
*/
void HavokPhysics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 
  __int64 v10; 

  _RBP = centerOfMass;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11632, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11633, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid body id for world %i", "bodyId.isValid()", v10) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11638, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyCenterOfMass %i: world is NULL", "havokPhysicsWorld->world", v10) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v7 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11644, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v7 + 64));
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbp+0], xmm0
  }
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMassLocal
==============
*/
void HavokPhysics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMassLocal)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v14; 

  _RBP = centerOfMassLocal;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11657, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass (Local) with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11658, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass (Local) with invalid body id for world %i", "bodyId.isValid()", v14) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11663, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyCenterOfMassLocal %i: world is NULL", "havokPhysicsWorld->world", v14) )
      __debugbreak();
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  __asm
  {
    vbroadcastss xmm0, dword ptr [rax+1Ch]
    vbroadcastss xmm4, dword ptr [rax+2Ch]
    vbroadcastss xmm2, dword ptr [rax+0Ch]
    vunpcklps xmm3, xmm2, xmm0
    vunpcklps xmm1, xmm4, xmm4
    vmovlhps xmm0, xmm3, xmm1
    vmovups xmmword ptr [rbp+0], xmm0
  }
}

/*
==============
HavokPhysics_GetRigidBodyContents
==============
*/
__int64 HavokPhysics_GetRigidBodyContents(const Physics_WorldId worldId, const hknpBodyId bodyId)
{
  hknpWorld *world; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11910, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11911, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11916, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics GetRigidBodyContents %i: world is NULL", "world", v6) )
      __debugbreak();
  }
  return world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_GetRigidBodyDefaultMass
==============
*/
float HavokPhysics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11572, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Default Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11576, ASSERT_TYPE_ASSERT, "(havokAsset)", (const char *)&queryFormat, "havokAsset") )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11577, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData") )
    __debugbreak();
  if ( HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11578, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData->m_bodyCinfos.getSize() > 0)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData->m_bodyCinfos.getSize() > 0") )
    __debugbreak();
  __asm { vxorps  xmm0, xmm0, xmm0 }
  _RAX = HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data;
  __asm
  {
    vmovss  xmm1, dword ptr [rax+70h]
    vcomiss xmm1, xmm0
    vmovaps xmm0, xmm1
  }
  return *(float *)&_XMM0;
}

/*
==============
HavokPhysics_GetRigidBodyDynamicMass
==============
*/
void HavokPhysics_GetRigidBodyDynamicMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v9; 
  __int64 v23; 

  _R14 = mass;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11599, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11600, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid body id for world %i", "bodyId.isValid()", v23) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11605, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v23) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v9 = v8;
  if ( (*(_BYTE *)(v8 + 68) & 5) != 0 )
  {
    if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF )
    {
      *_R14 = 0.0;
      return;
    }
  }
  else if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11618, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
  {
    __debugbreak();
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovsd  xmm2, qword ptr [rax+20h]
    vpunpcklwd xmm0, xmm1, xmm2
    vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
    vshufps xmm4, xmm0, xmm0, 0FFh
    vrcpps  xmm5, xmm4
    vxorps  xmm0, xmm0, xmm0
    vmulps  xmm2, xmm5, xmm4
    vcmpeqps xmm3, xmm4, xmm0
    vsubps  xmm0, xmm1, xmm2
    vmulps  xmm2, xmm0, xmm5
    vandnps xmm3, xmm3, xmm2
    vmovss  dword ptr [r14], xmm3
  }
}

/*
==============
HavokPhysics_GetRigidBodyInverseInertiaLocal
==============
*/
void HavokPhysics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *invInertia)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v13; 

  _RBP = invInertia;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11752, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Inverse Inertia matrix with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11753, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Inverse Inertia matrix  with invalid body id for world %i", "bodyId.isValid()", v13) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11758, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyInverseInertiaWorld %i: world is NULL", "havokPhysicsWorld->world", v13) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11761, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v8 + 64));
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovsd  xmm2, qword ptr [rax+20h]
    vpunpcklwd xmm0, xmm1, xmm2
    vmovdqu xmmword ptr [rbp+0], xmm0
  }
}

/*
==============
HavokPhysics_GetRigidBodyMass
==============
*/
void HavokPhysics_GetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v9; 
  __int64 v23; 

  _R14 = mass;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11543, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11544, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid body id for world %i", "bodyId.isValid()", v23) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11549, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v23) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v9 = v8;
  if ( (*(_BYTE *)(v8 + 68) & 5) != 0 )
  {
    *_R14 = 0.0;
  }
  else
  {
    if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11562, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
      __debugbreak();
    _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
    __asm
    {
      vpxor   xmm1, xmm1, xmm1
      vmovsd  xmm2, qword ptr [rax+20h]
      vpunpcklwd xmm0, xmm1, xmm2
      vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
      vshufps xmm4, xmm0, xmm0, 0FFh
      vrcpps  xmm5, xmm4
      vxorps  xmm0, xmm0, xmm0
      vmulps  xmm2, xmm5, xmm4
      vcmpeqps xmm3, xmm4, xmm0
      vsubps  xmm0, xmm1, xmm2
      vmulps  xmm2, xmm0, xmm5
      vandnps xmm3, xmm3, xmm2
      vmovss  dword ptr [r14], xmm3
    }
  }
}

/*
==============
HavokPhysics_GetRigidBodyMaxAngSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxAngSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  hknpWorld *world; 
  __int64 v11; 

  _RBP = maxAngSpeed;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11449, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxAngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11450, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxAngSpeed with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11455, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  world = ConstWorld->world;
  _RAX = world->m_motionManager.m_motions.m_objects.m_data;
  _RDX = (unsigned __int64)world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_motionId.m_value << 7;
  __asm
  {
    vmovss  xmm1, dword ptr [rdx+rax+5Ch]
    vmovss  dword ptr [rbp+0], xmm1
  }
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinAngSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11474, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinAngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11475, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinAngSpeed with invalid body id for world %i", "bodyId.isValid()", v12) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11480, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v12) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
  v11 = (__int64)&ConstWorld->world->getMotionPropertiesLibrary(&ConstWorld->world->hknpWorldReader)->m_motionProperties.m_objects.m_data[*(unsigned __int16 *)(v10 + 56)];
  *maxLinSpeed = *(float *)(v11 + 16);
  *maxAngSpeed = *(float *)(v11 + 20);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  hknpWorld *world; 
  __int64 v11; 

  _RBP = maxLinSpeed;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11424, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11425, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11430, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  world = ConstWorld->world;
  _RAX = world->m_motionManager.m_motions.m_objects.m_data;
  _RDX = (unsigned __int64)world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_motionId.m_value << 7;
  __asm
  {
    vmovss  xmm1, dword ptr [rdx+rax+4Ch]
    vmovss  dword ptr [rbp+0], xmm1
  }
}

/*
==============
HavokPhysics_GetRigidBodyName
==============
*/
const char *HavokPhysics_GetRigidBodyName(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11503, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Name with invalid body id for world %i", "bodyId.isValid()", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11508, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (const char *)((unsigned __int64)ConstWorld->world->m_bodyManager.m_bodyNames.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/
void HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, hknpBodyId bodyId, const hkVector4f *hkInstancePosition, const hkQuaternionf *hkInstanceOrientation, hkVector4f *hkBodyPosition, hkQuaternionf *hkBodyOrientation)
{
  unsigned int m_serialAndIndex; 
  hknpWorld *v18; 
  hkTransformf *p_bTc; 
  __int64 v30; 
  hknpBodyId result; 
  const hkQuaternionf *v32; 
  hknpWorld *world; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v36; 
  hkTransformf v37; 
  hkTransformf aTb; 
  hkTransformf v39; 

  _R13 = hkInstancePosition;
  _R14 = hkBodyPosition;
  _R15 = hkBodyOrientation;
  v32 = hkInstanceOrientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12704, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v30) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12705, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v30) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v30) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12710, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics Get Rigid Body Transform After Warp Instance %i: world is NULL", "hkWorld", v30) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v36.m_rotation, hkInstanceOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups [rsp+228h+var_108], xmm0
  }
  HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, 0);
  m_serialAndIndex = result.m_serialAndIndex;
  if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12717, ASSERT_TYPE_ASSERT, "(body0Id.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid body id for body %i in instance %i world %i", "body0Id.isValid()", 0i64, instanceId, worldId) )
    __debugbreak();
  if ( m_serialAndIndex == bodyId.m_serialAndIndex )
  {
    __asm { vmovups xmm0, xmmword ptr [r13+0] }
    _RAX = v32;
    __asm
    {
      vmovups xmmword ptr [r14], xmm0
      vmovups xmm1, xmmword ptr [rax]
      vmovups xmmword ptr [r15], xmm1
    }
  }
  else
  {
    v18 = world;
    _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rsp+228h+t.m_rotation.baseclass_0.m_col0.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rax+10h]
      vmovups xmmword ptr [rsp+228h+t.m_rotation.baseclass_0.m_col1.m_quad], xmm1
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rsp+228h+t.m_rotation.baseclass_0.m_col2.m_quad], xmm0
      vmovups xmm1, xmmword ptr [rax+30h]
      vmovups xmmword ptr [rsp+228h+t.m_translation.m_quad], xmm1
    }
    hkTransformf::setInverse(&aTb, &t);
    _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v18->getBodyTransform)(&v18->hknpWorldReader, bodyId.m_serialAndIndex);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+228h+bTc.m_rotation.baseclass_0.m_col0.m_quad], ymm0
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovss  xmm0, cs:__real@3a83126f
      vmovss  [rsp+228h+result.m_serialAndIndex], xmm0
      vmovups ymmword ptr [rsp+228h+bTc.m_rotation.baseclass_0.m_col2.m_quad], ymm1
    }
    if ( hkTransformf::isApproximatelyEqual(&t, &v36, (const float *)&result.m_serialAndIndex) )
    {
      __asm { vmovups xmm0, xmmword ptr [rsp+228h+bTc.m_translation.m_quad] }
      p_bTc = &bTc;
    }
    else
    {
      hkTransformf::setMul(&v39, &aTb, &bTc);
      hkTransformf::setMul(&v37, &v36, &v39);
      __asm { vmovups xmm0, xmmword ptr [rsp+228h+var_F8.m_translation.m_quad] }
      p_bTc = &v37;
    }
    __asm { vmovups xmmword ptr [r14], xmm0 }
    hkQuaternionf::set(hkBodyOrientation, &p_bTc->m_rotation);
  }
}

/*
==============
HavokPhysics_GetSFXEventAsset
==============
*/
_BOOL8 HavokPhysics_GetSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsSFXEventAsset **asset)
{
  hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator> *bodySFXEventAssets; 
  PhysicsSFXEventAsset *v9; 
  PhysicsSFXEventAsset *v10; 
  _BOOL8 result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8558, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetSFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  bodySFXEventAssets = HavokPhysics_GetMutableWorld(worldId)->bodySFXEventAssets;
  v9 = bodySFXEventAssets->m_data[bodyId0.m_serialAndIndex & 0xFFFFFF];
  v10 = bodySFXEventAssets->m_data[bodyId1.m_serialAndIndex & 0xFFFFFF];
  result = v9 && v10 || v9 == NULL;
  if ( !result )
    v10 = v9;
  *asset = v10;
  return result;
}

/*
==============
HavokPhysics_GetShape
==============
*/
hknpShape *HavokPhysics_GetShape(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15532, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to GetShape with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15533, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavokPhysics: Trying to GetShape with invalid body index in world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15537, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetShape %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return *(hknpShape **)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 96);
}

/*
==============
HavokPhysics_GetShapeConvexCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_convexCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeFromShapeList
==============
*/
hknpShape *HavokPhysics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return shapeList->m_shapes.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeNameFromShapeList
==============
*/
const char *HavokPhysics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (const char *)((unsigned __int64)shapeList->m_shapeNames.m_data[shapeIdx].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetShapeOverrideContents
==============
*/
int HavokPhysics_GetShapeOverrideContents(int shapeOverride)
{
  if ( shapeOverride == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9042, ASSERT_TYPE_ASSERT, "(shapeOverride != -1)", "%s\n\tHavok Physics: Trying to GetShapeOverrideContents with unsupported shape override", "shapeOverride != PHYSICSSHAPE_OVERRIDEID_INVALID") )
    __debugbreak();
  if ( shapeOverride >= WorldCollision_GetMapEntsShapeCount() )
    return -33570817;
  else
    return WorldCollision_GetMapEntsShapeContents(shapeOverride);
}

/*
==============
HavokPhysics_GetShapeTriCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_triCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeTypeName
==============
*/
const char *HavokPhysics_GetShapeTypeName(const hknpShape *shape)
{
  return shapeTypeNames[shape->m_type.m_storage];
}

/*
==============
HavokPhysics_GetShapeUserData
==============
*/
unsigned __int64 HavokPhysics_GetShapeUserData(hknpShape *inShape)
{
  return inShape->m_userData;
}

/*
==============
HavokPhysics_GetShapeVertCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_vertCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetStepInput
==============
*/
hknpStepInput *HavokPhysics_GetStepInput(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3822, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get step input with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return &HavokPhysics_GetMutableWorld(worldId)->stepInput;
}

/*
==============
HavokPhysics_GetTaskQueue
==============
*/
hkDefaultTaskQueue *HavokPhysics_GetTaskQueue(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3807, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get task queue with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->taskQueue;
}

/*
==============
HavokPhysics_GetThreadId
==============
*/
LPVOID HavokPhysics_GetThreadId()
{
  return TlsGetValue(hkThreadNumber.m_slotID);
}

/*
==============
HavokPhysics_GetThreadPool
==============
*/
HavokPhysicsThreadPool *HavokPhysics_GetThreadPool()
{
  return g_havokPhysicsThreadPool;
}

/*
==============
HavokPhysics_GetVFXEventAsset
==============
*/
_BOOL8 HavokPhysics_GetVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsVFXEventAsset **asset)
{
  hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator> *bodyVFXEventAssets; 
  PhysicsVFXEventAsset *v9; 
  PhysicsVFXEventAsset *v10; 
  _BOOL8 result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8591, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  bodyVFXEventAssets = HavokPhysics_GetMutableWorld(worldId)->bodyVFXEventAssets;
  v9 = bodyVFXEventAssets->m_data[bodyId0.m_serialAndIndex & 0xFFFFFF];
  v10 = bodyVFXEventAssets->m_data[bodyId1.m_serialAndIndex & 0xFFFFFF];
  result = v9 && v10 || v9 == NULL;
  if ( !result )
    v10 = v9;
  *asset = v10;
  return result;
}

/*
==============
HavokPhysics_GetWireframeGeometry
==============
*/
void HavokPhysics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  __int64 v7; 
  int v9; 
  hkReferencedObject **v10; 
  __int64 v11; 
  hkReferencedObject *v13; 
  void (__fastcall *v14)(hkBaseObject *); 
  hkMemoryAllocator *v15; 
  char *v16; 
  char *v17; 
  hkMemoryAllocator *v22; 
  hkMemoryAllocator *v23; 
  void *p; 
  int v26; 
  int v27; 
  _QWORD v28[5]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  v7 = pointArraySize;
  v9 = 0;
  v28[0] = 0i64;
  v28[1] = 0x8000000000000000ui64;
  hknpShapeUtil::buildShapeDisplayGeometries(shape, CONVEX_RADIUS_DISPLAY_PLANAR, (hkArray<hkDisplayGeometry *,hkContainerHeapAllocator> *)v28, 0);
  v10 = (hkReferencedObject **)v28[0];
  if ( v28[0] != v28[0] + 8i64 * SLODWORD(v28[1]) )
  {
    v11 = 0i64;
    __asm { vmovss  xmm6, cs:__real@42000000 }
    do
    {
      p = NULL;
      v26 = 0;
      v27 = 0x80000000;
      v13 = *v10;
      v14 = (*v10)->__vftable[1].~hkBaseObject;
      v15 = hkMemHeapAllocator();
      ((void (__fastcall *)(hkReferencedObject *, void **, hkMemoryAllocator *))v14)(v13, &p, v15);
      v16 = (char *)p;
      v17 = (char *)p + 16 * v26;
      if ( p != v17 )
      {
        _RDX = &pointArray[v11].v[2];
        do
        {
          if ( v11 < v7 )
          {
            __asm
            {
              vmulss  xmm1, xmm6, dword ptr [rcx]
              vmovss  dword ptr [rdx-8], xmm1
              vmulss  xmm1, xmm6, dword ptr [rcx+4]
              vmovss  dword ptr [rdx-4], xmm1
              vmulss  xmm0, xmm6, dword ptr [rcx+8]
              vmovss  dword ptr [rdx], xmm0
            }
            ++v9;
            ++v11;
            _RDX += 3;
          }
          v16 += 16;
        }
        while ( v16 != v17 );
      }
      hkReferencedObject::removeReference(*v10);
      v22 = hkMemHeapAllocator();
      v26 = 0;
      if ( v27 >= 0 )
        hkMemoryAllocator::bufFree2(v22, p, 16, v27 & 0x3FFFFFFF);
      p = NULL;
      v27 = 0x80000000;
      ++v10;
    }
    while ( v10 != (hkReferencedObject **)(v28[0] + 8i64 * SLODWORD(v28[1])) );
  }
  *numLines = v9 / 2;
  v23 = hkMemHeapAllocator();
  LODWORD(v28[1]) = 0;
  if ( v28[1] >= 0 )
    hkMemoryAllocator::bufFree2(v23, (void *)v28[0], 8, HIDWORD(v28[1]) & 0x3FFFFFFF);
  __asm { vmovaps xmm6, [rsp+88h+var_38] }
}

/*
==============
HavokPhysics_GetWorld
==============
*/
hknpWorld *HavokPhysics_GetWorld(Physics_WorldId worldId)
{
  return HavokPhysics_GetMutableWorld(worldId)->world;
}

/*
==============
HavokPhysics_GetWorldId
==============
*/
__int64 HavokPhysics_GetWorldId(const hknpWorld *world)
{
  __int64 result; 
  hknpWorld **i; 

  result = 0i64;
  for ( i = &g_havokPhysicsWorlds[0].world; *i != world; i += 480 )
  {
    result = (unsigned int)(result + 1);
    if ( (unsigned int)result >= 8 )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
HavokPhysics_GroupRagdollConstraint
==============
*/
void HavokPhysics_GroupRagdollConstraint(HavokPhysicsWorld *havokPhysicsWorld, const PhysicsAsset *physicsAsset, int ref, hknpConstraintCinfo *cInfo)
{
  __int64 RefSubSystem; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *m_ragdollConstraintGroupId; 
  bool v10; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v11; 
  unsigned int m_value; 
  __int64 v13; 
  __int64 v14; 
  Physics_RefSystem RefSystem; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> result; 

  if ( !havokPhysicsWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9350, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld)", (const char *)&queryFormat, "havokPhysicsWorld") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9351, ASSERT_TYPE_ASSERT, "(physicsAsset)", (const char *)&queryFormat, "physicsAsset") )
    __debugbreak();
  if ( !cInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9352, ASSERT_TYPE_ASSERT, "(cInfo)", (const char *)&queryFormat, "cInfo") )
    __debugbreak();
  if ( Physics_IsAssetRagdoll(physicsAsset) )
  {
    if ( !havokPhysicsWorld->m_ragdollConstraintGroupId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9356, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_ragdollConstraintGroupId)", (const char *)&queryFormat, "havokPhysicsWorld->m_ragdollConstraintGroupId") )
      __debugbreak();
    if ( Physics_GetRefSystem(ref) != Physics_RefSystem_Ragdoll )
    {
      RefSystem = Physics_GetRefSystem(ref);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9357, ASSERT_TYPE_ASSERT, "( Physics_GetRefSystem( ref ) ) == ( Physics_RefSystem_Ragdoll )", "%s == %s\n\t%i, %i", "Physics_GetRefSystem( ref )", "Physics_RefSystem_Ragdoll", RefSystem, 6) )
        __debugbreak();
    }
    RefSubSystem = Physics_GetRefSubSystem(ref);
    if ( (unsigned int)RefSubSystem >= havokPhysicsWorld->m_ragdollConstraintGroupId->m_size )
    {
      LODWORD(v14) = havokPhysicsWorld->m_ragdollConstraintGroupId->m_size;
      LODWORD(v13) = RefSubSystem;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9359, ASSERT_TYPE_ASSERT, "(unsigned)( ragdollId ) < (unsigned)( havokPhysicsWorld->m_ragdollConstraintGroupId->getSize() )", "ragdollId doesn't index havokPhysicsWorld->m_ragdollConstraintGroupId->getSize()\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    m_ragdollConstraintGroupId = havokPhysicsWorld->m_ragdollConstraintGroupId;
    v10 = m_ragdollConstraintGroupId->m_data[RefSubSystem].m_value == 0x7FFFFFFF;
    v11 = &m_ragdollConstraintGroupId->m_data[RefSubSystem];
    if ( v10 || !hknpConstraintManager::isGroupValid(havokPhysicsWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)v11->m_value) )
    {
      m_value = hknpConstraintManager::allocateConstraintGroup(havokPhysicsWorld->world->m_constraintManager, &result, 8u, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)0x7FFFFFFF)->m_value;
      v11->m_value = m_value;
    }
    else
    {
      m_value = v11->m_value;
    }
    cInfo->m_constraintGroupId.m_value = m_value;
  }
}

/*
==============
HavokPhysics_HasSFXEventAsset
==============
*/
bool HavokPhysics_HasSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8623, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->bodySFXEventAssets->m_data[bodyId.m_serialAndIndex & 0xFFFFFF] != NULL;
}

/*
==============
HavokPhysics_HasTriggerEvent
==============
*/
bool HavokPhysics_HasTriggerEvent(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11357, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11358, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11363, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics HasTriggerEvent %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (*(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 0x10) != 0;
}

/*
==============
HavokPhysics_HasVFXEventAsset
==============
*/
bool HavokPhysics_HasVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8633, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->bodyVFXEventAssets->m_data[bodyId.m_serialAndIndex & 0xFFFFFF] != NULL;
}

/*
==============
HavokPhysics_Init
==============
*/
void HavokPhysics_Init(char *generalMemoryBuffer, int generalMemoryBufferSize, int generalMemoryBufferWarningThreshold, char *debugMemoryBuffer, int debugMemoryBufferSize)
{
  __int64 v5; 
  signed int MainThreadId; 
  int v9; 
  HavokPhysicsLargeBlockAllocator *v10; 
  HavokPhysicsLargeBlockAllocator *v11; 
  HavokPhysicsLargeBlockAllocator *v12; 
  hkMemoryAllocator::ExtendedInterface *v13; 
  HavokPhysicsFreeListAllocator *v14; 
  hkMemoryAllocator::ExtendedInterface *v15; 
  HavokPhysicsFreeListAllocator *v16; 
  hkMemoryAllocator::ExtendedInterface *mapLocalHeapExtended; 
  hkMemoryAllocator::ExtendedInterface *v18; 
  HavokPhysicsFreeListMemorySystem *v19; 
  hkBaseSystem::InitNode *v20; 
  hkBaseSystem::InitNode *m_next; 
  int *v22; 
  int *v23; 
  int *v24; 
  int *v25; 
  int *v26; 
  int *v27; 
  hkMemoryRouter *Value; 
  IWHavokError *v29; 
  hkError *v30; 
  hkError *v31; 
  hkError *m_ptr; 
  hkMonitorStream *v33; 
  hkMemoryRouter *v34; 
  HavokPhysicsThreadPool *v35; 
  HavokPhysicsThreadPool *v36; 
  hkMemoryRouter *v37; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v38; 
  __int64 v39; 
  hkMemoryRouter *v40; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v41; 
  hkMemoryRouter *v42; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v43; 
  hkMemoryRouter *v44; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v45; 
  hkMemoryRouter *v46; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v47; 
  hkMemoryRouter *v48; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v49; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v50; 
  hkMemoryRouter *v51; 
  __int64 v52; 
  const char *v53; 
  __int64 v54; 
  unsigned int v55; 
  unsigned int i; 
  const char *v57; 
  __int64 v58; 
  unsigned int j; 
  const char *v60; 
  __int64 v61; 
  unsigned int k; 
  const char *v63; 
  __int64 v64; 
  unsigned int m; 
  const char *v66; 
  hkMemoryRouter *v67; 
  HavokPhysicsShapeTagCodec *v68; 
  HavokPhysicsShapeTagCodec *v69; 
  hkMemoryRouter *v70; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v71; 
  hkMemorySystem::FrameInfo v72; 
  __int64 v73; 

  v73 = -2i64;
  v5 = generalMemoryBufferWarningThreshold;
  InitializeSRWLock((PSRWLOCK)&s_havokPhysicsAssetLock);
  s_havokPhysicsAssetLock.initialized = -1412623820;
  s_havokPhysicsAssetLock.acquireLock = 0;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  MainThreadId = Physics_GetMainThreadId();
  TlsSetValue(hkThreadNumber.m_slotID, (LPVOID)MainThreadId);
  v9 = debugMemoryBufferSize + generalMemoryBufferSize;
  HavokPhysicsLargeBlockAllocator::HavokPhysicsLargeBlockAllocator(&s_havokPhysicsGeneralLargeBlockAllocatorBuffer, generalMemoryBuffer, v9);
  s_havokPhysicsGeneralLargeBlockAllocator = v10;
  HavokPhysicsLargeBlockAllocator::HavokPhysicsLargeBlockAllocator(&s_havokPhysicsMapLocalLargeBlockAllocatorBuffer, v10);
  s_havokPhysicsMapLocalLargeBlockAllocator = v11;
  v12 = s_havokPhysicsGeneralLargeBlockAllocator;
  s_havokPhysicsGeneralLargeBlockAllocator->m_limitedListener = &s_havokPhysicsLimitedMemoryListener;
  if ( !v11 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2479, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalLargeBlockAllocator)", "%s\n\tHavokPhysics Init: failed to create map local memory allocator", "s_havokPhysicsMapLocalLargeBlockAllocator") )
      __debugbreak();
    v12 = s_havokPhysicsGeneralLargeBlockAllocator;
  }
  v13 = &v12->hkMemoryAllocator::ExtendedInterface;
  if ( !v12 )
    v13 = NULL;
  HavokPhysicsFreeListAllocator::HavokPhysicsFreeListAllocator(&s_havokPhysicsGeneralFreeListAllocatorBuffer, v12, v13, NULL);
  s_havokPhysicsGeneralFreeListAllocator = v14;
  v15 = &s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface;
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator )
    v15 = NULL;
  HavokPhysicsFreeListAllocator::HavokPhysicsFreeListAllocator(&s_havokPhysicsMapLocalFreeListAllocatorBuffer, s_havokPhysicsMapLocalLargeBlockAllocator, v15, NULL);
  s_havokPhysicsMapLocalFreeListAllocator = v16;
  if ( !s_havokPhysicsGeneralFreeListAllocator )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2486, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralFreeListAllocator)", "%s\n\tHavokPhysics Init: failed to create general free list allocator", "s_havokPhysicsGeneralFreeListAllocator") )
      __debugbreak();
    v16 = s_havokPhysicsMapLocalFreeListAllocator;
  }
  if ( !v16 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2487, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalFreeListAllocator)", "%s\n\tHavokPhysics Init: failed to create map local free list allocator", "s_havokPhysicsMapLocalFreeListAllocator") )
      __debugbreak();
    v16 = s_havokPhysicsMapLocalFreeListAllocator;
  }
  mapLocalHeapExtended = &v16->hkMemoryAllocator::ExtendedInterface;
  if ( !v16 )
    mapLocalHeapExtended = NULL;
  v18 = &s_havokPhysicsGeneralFreeListAllocator->hkMemoryAllocator::ExtendedInterface;
  if ( !s_havokPhysicsGeneralFreeListAllocator )
    v18 = NULL;
  HavokPhysicsFreeListMemorySystem::HavokPhysicsFreeListMemorySystem(&s_havokPhysicsMemorySystemBuffer, s_havokPhysicsGeneralLargeBlockAllocator, s_havokPhysicsGeneralFreeListAllocator, v18, v16, mapLocalHeapExtended, DEFAULT_SETUP_FLAGS);
  s_havokPhysicsMemorySystem = v19;
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2489, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMemorySystem)", "%s\n\tHavokPhysics Init: failed to create memory system allocator", "s_havokPhysicsMemorySystem") )
    __debugbreak();
  hkMemorySystem::replaceInstance(s_havokPhysicsMemorySystem);
  hkMemorySystem::FrameInfo::FrameInfo(&v72, 0, 0x8000);
  s_memoryRouter = (hkMemoryRouter *)((__int64 (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemorySystem::FrameInfo *, __int64))s_havokPhysicsMemorySystem->mainInit)(s_havokPhysicsMemorySystem, &v72, 3i64);
  hknpThreadSafetyCheck::s_enableCriticalSection = 1;
  s_memoryDebugRouter = NULL;
  HavokPhysicsDisplayHandler::setDebugMemoryRouter(s_memoryRouter);
  *(_QWORD *)&s_generalMemoryCapacity = v9;
  s_generalMemoryThreshold = v5;
  *(_QWORD *)&s_generalMemoryPeakInUse = 0i64;
  *(_QWORD *)&s_mapLocalMemoryCapacity = 0i64;
  *(_QWORD *)&s_mapLocalMemoryPeakInUse = 0i64;
  *(_QWORD *)&s_debugMemoryCapacity = debugMemoryBufferSize;
  *(_QWORD *)&s_debugMemoryPeakInUse = 0i64;
  if ( ((unsigned __int8)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedIncrement(&s_errorPrintWarningOnly);
  v20 = hkBaseSystem::InitNode::s_listHead;
  if ( hkBaseSystem::InitNode::s_listHead != &hknpGlobals::singletonEntry && hkBaseSystem::InitNode::s_listHead )
  {
    while ( 1 )
    {
      m_next = v20->m_next;
      if ( m_next == &hknpGlobals::singletonEntry )
        break;
      v20 = v20->m_next;
      if ( !m_next )
        goto LABEL_33;
    }
    v20->m_next = m_next->m_next;
    hknpGlobals::singletonEntry.m_next = hkBaseSystem::InitNode::s_listHead;
    hkBaseSystem::InitNode::s_listHead = &hknpGlobals::singletonEntry;
  }
LABEL_33:
  hkBaseSystem::init(s_memoryRouter, HavokPhysics_InitialErrorReportFunction, NULL);
  if ( ((unsigned __int64)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedDecrement(&s_errorPrintWarningOnly);
  LODWORD(v22) = hkOptionalComponent::request(&hkProductFeatures::Common::Patcher::s_optionalComponent);
  if ( *v22 >= 0 )
  {
    LODWORD(v23) = hkOptionalComponent::request(&hkProductFeatures::Common::ReadFormatBinaryTagfile::s_optionalComponent);
    if ( *v23 >= 0 )
    {
      LODWORD(v24) = hkOptionalComponent::request(&hkProductFeatures::Common::WriteFormatBinaryTagfile::s_optionalComponent);
      if ( *v24 >= 0 )
      {
        LODWORD(v25) = hkOptionalComponent::request(&hkProductFeatures::Common::ReadFormatXmlTagfile::s_optionalComponent);
        if ( *v25 >= 0 )
        {
          LODWORD(v26) = hkOptionalComponent::request(&hkProductFeatures::Common::WriteFormatXmlTagfile::s_optionalComponent);
          if ( *v26 >= 0 )
          {
            LODWORD(v27) = hkOptionalComponent::request(&hkProductFeatures::Physics::SimdTreeBroadPhase::s_optionalComponent);
            if ( *v27 >= 0 )
              hkOptionalComponent::request(&hkProductFeatures::Physics::HybridBroadPhase::s_optionalComponent);
          }
        }
      }
    }
  }
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v29 = (IWHavokError *)Value->m_heap->blockAlloc(Value->m_heap, 120i64);
  if ( v29 )
  {
    IWHavokError::IWHavokError(v29, NULL, NULL);
    v31 = v30;
  }
  else
  {
    v31 = NULL;
  }
  m_ptr = hkError::singleton.m_ptr;
  if ( v31 != hkError::singleton.m_ptr )
  {
    if ( hkError::singleton.m_ptr )
      hkReferencedObject::removeReference(hkError::singleton.m_ptr);
    m_ptr = v31;
    hkError::singleton.m_ptr = v31;
  }
  ((void (__fastcall *)(hkError *, __int64, _QWORD))m_ptr->setEnabled)(m_ptr, 4043243525i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1976984315i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1468004382i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2950766898i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2950766897i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4029997037i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 311668207i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 311668200i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2173329443i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1115809886i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1115809887i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806834473i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1280117224i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4010873767i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2654475628i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2967172809i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 3646206815i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1513100751i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806855191i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4033798112i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 361947194i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806844336i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2951401808i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2937381426i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2937381427i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1726877882i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2672362952i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1641175483i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1862252909i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4029953228i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1140510869i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1273485998i64, 0i64);
  v33 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  hkMonitorStream::resize(v33, 102400);
  if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2581, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
    __debugbreak();
  if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2582, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
    __debugbreak();
  if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2583, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
    __debugbreak();
  v34 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v34 )
    v34 = hkMemoryRouter::s_fallbackRouter;
  v35 = (HavokPhysicsThreadPool *)v34->m_heap->blockAlloc(v34->m_heap, 2664i64);
  if ( v35 )
    HavokPhysicsThreadPool::HavokPhysicsThreadPool(v35);
  else
    v36 = NULL;
  g_havokPhysicsThreadPool = v36;
  if ( s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2590, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics assets should be NULL", "s_havokPhysicsAssets == HK_NULL") )
    __debugbreak();
  v37 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v37 )
    v37 = hkMemoryRouter::s_fallbackRouter;
  v38 = (hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *)v37->m_heap->blockAlloc(v37->m_heap, 16i64);
  v39 = -1i64;
  if ( v38 )
  {
    v38->m_map.m_elem = NULL;
    v38->m_map.m_numElems = 0;
    v38->m_map.m_hashMod = -1;
  }
  else
  {
    v38 = NULL;
  }
  s_havokPhysicsAssets = v38;
  if ( s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2593, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs == nullptr)", "%s\n\tHavokPhysics Init: havok physics lods should be NULL", "s_havokPhysicsXModelLODs == HK_NULL") )
    __debugbreak();
  v40 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v40 )
    v40 = hkMemoryRouter::s_fallbackRouter;
  v41 = (hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *)v40->m_heap->blockAlloc(v40->m_heap, 16i64);
  if ( v41 )
  {
    v41->m_map.m_elem = NULL;
    v41->m_map.m_numElems = 0;
    v41->m_map.m_hashMod = -1;
  }
  else
  {
    v41 = NULL;
  }
  s_havokPhysicsXModelLODs = v41;
  if ( s_havokPhysicsXModelLODShapeTagLookup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2600, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODShapeTagLookup == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel lod shape tag lookup should be NULL", "s_havokPhysicsXModelLODShapeTagLookup == HK_NULL") )
    __debugbreak();
  v42 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v42 )
    v42 = hkMemoryRouter::s_fallbackRouter;
  v43 = (hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *)v42->m_heap->blockAlloc(v42->m_heap, 16i64);
  if ( v43 )
  {
    v43->m_map.m_elem = NULL;
    v43->m_map.m_numElems = 0;
    v43->m_map.m_hashMod = -1;
  }
  else
  {
    v43 = NULL;
  }
  s_havokPhysicsXModelLODShapeTagLookup = v43;
  if ( g_havokPhysicsXModelLODShapeTagDatas && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2603, ASSERT_TYPE_ASSERT, "(g_havokPhysicsXModelLODShapeTagDatas == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel lod shape tag datas should be NULL", "g_havokPhysicsXModelLODShapeTagDatas == HK_NULL") )
    __debugbreak();
  v44 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v44 )
    v44 = hkMemoryRouter::s_fallbackRouter;
  v45 = (hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *)v44->m_heap->blockAlloc(v44->m_heap, 16i64);
  if ( v45 )
  {
    v45->m_data = NULL;
    v45->m_size = 0;
    v45->m_capacityAndFlags = 0x80000000;
  }
  else
  {
    v45 = NULL;
  }
  g_havokPhysicsXModelLODShapeTagDatas = v45;
  if ( g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2608, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics sfx event assets should be NULL", "g_physicsSFXEventAssets == HK_NULL") )
    __debugbreak();
  v46 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v46 )
    v46 = hkMemoryRouter::s_fallbackRouter;
  v47 = (hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *)v46->m_heap->blockAlloc(v46->m_heap, 16i64);
  if ( v47 )
  {
    v47->m_elem = NULL;
    v47->m_numElems = 0;
    v47->m_hashMod = -1;
  }
  else
  {
    v47 = NULL;
  }
  g_physicsSFXEventAssets = v47;
  if ( g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2611, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics vfx event assets should be NULL", "g_physicsVFXEventAssets == HK_NULL") )
    __debugbreak();
  v48 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v48 )
    v48 = hkMemoryRouter::s_fallbackRouter;
  v49 = (hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *)v48->m_heap->blockAlloc(v48->m_heap, 16i64);
  if ( v49 )
  {
    v49->m_elem = NULL;
    v49->m_numElems = 0;
    v49->m_hashMod = -1;
  }
  else
  {
    v49 = NULL;
  }
  g_physicsVFXEventAssets = v49;
  v50 = s_havokPhysicsShapeCaches;
  do
  {
    if ( *v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2618, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId] == nullptr)", "%s\n\tHavokPhysics Init: havok physics shape caches should be NULL", "s_havokPhysicsShapeCaches[threadId] == HK_NULL") )
      __debugbreak();
    v51 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v51 )
      v51 = hkMemoryRouter::s_fallbackRouter;
    v52 = (__int64)v51->m_heap->blockAlloc(v51->m_heap, 16i64);
    if ( v52 )
    {
      *(_QWORD *)v52 = 0i64;
      *(_DWORD *)(v52 + 8) = 0;
      *(_DWORD *)(v52 + 12) = -1;
    }
    else
    {
      v52 = 0i64;
    }
    *v50++ = (hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *)v52;
  }
  while ( (__int64)v50 < (__int64)s_havokPhysicsShapeCachesDisabled );
  v53 = s_staticBodyQualityName;
  v54 = -1i64;
  do
    ++v54;
  while ( s_staticBodyQualityName[v54] );
  v55 = -1;
  for ( i = -1; v54; --v54 )
    i = (i >> 8) ^ g_crc32Table[*(unsigned __int8 *)v53++ ^ (unsigned __int64)(unsigned __int8)i];
  s_staticBodyQualityCRC = ~i;
  v57 = s_dynamicBodyQualityName;
  v58 = -1i64;
  do
    ++v58;
  while ( s_dynamicBodyQualityName[v58] );
  for ( j = -1; v58; --v58 )
    j = (j >> 8) ^ g_crc32Table[*(unsigned __int8 *)v57++ ^ (unsigned __int64)(unsigned __int8)j];
  s_dynamicBodyQualityCRC = ~j;
  v60 = s_vehicleBodyQualityName;
  v61 = -1i64;
  do
    ++v61;
  while ( s_vehicleBodyQualityName[v61] );
  for ( k = -1; v61; --v61 )
    k = (k >> 8) ^ g_crc32Table[*(unsigned __int8 *)v60++ ^ (unsigned __int64)(unsigned __int8)k];
  s_vehicleBodyQualityCRC = ~k;
  v63 = s_staticMotionPropertiesName;
  v64 = -1i64;
  do
    ++v64;
  while ( s_staticMotionPropertiesName[v64] );
  for ( m = -1; v64; --v64 )
    m = (m >> 8) ^ g_crc32Table[*(unsigned __int8 *)v63++ ^ (unsigned __int64)(unsigned __int8)m];
  s_staticMotionPropertiesCRC = ~m;
  v66 = s_keyframedMotionPropertiesName;
  do
    ++v39;
  while ( s_keyframedMotionPropertiesName[v39] );
  for ( ; v39; --v39 )
    v55 = (v55 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v66++ ^ (unsigned __int64)(unsigned __int8)v55];
  s_keyframedMotionPropertiesCRC = ~v55;
  hknpBroadPhase::ms_iwBroadphaseBodiesChangedCallback = HavokPhysics_BroadphaseBodiesChanged;
  SetIwIsMeshShape(HavokPhysics_IsMeshShape);
  SetIwGetLandscapeShapeHelperCallback(HavokPhysics_GetLandscapeShapeHelper);
  if ( s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2640, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", s_shapeTagCodec, NULL) )
    __debugbreak();
  v67 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v67 )
    v67 = hkMemoryRouter::s_fallbackRouter;
  v68 = (HavokPhysicsShapeTagCodec *)v67->m_heap->blockAlloc(v67->m_heap, 56i64);
  if ( v68 )
    HavokPhysicsShapeTagCodec::HavokPhysicsShapeTagCodec(v68);
  else
    v69 = NULL;
  s_shapeTagCodec = v69;
  if ( !v69 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2642, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", NULL, NULL) )
    __debugbreak();
  if ( s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2646, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel array should be NULL", "s_havokPhysicsXModels == HK_NULL") )
    __debugbreak();
  v70 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v70 )
    v70 = hkMemoryRouter::s_fallbackRouter;
  v71 = (hkArray<XModel const *,hkContainerHeapAllocator> *)v70->m_heap->blockAlloc(v70->m_heap, 16i64);
  v72 = (hkMemorySystem::FrameInfo)v71;
  if ( v71 )
  {
    v71->m_data = NULL;
    v71->m_size = 0;
    v71->m_capacityAndFlags = 0x80000000;
    s_havokPhysicsXModels = v71;
  }
  else
  {
    s_havokPhysicsXModels = NULL;
  }
}

/*
==============
HavokPhysics_InitialErrorReportFunction
==============
*/
void HavokPhysics_InitialErrorReportFunction(const char *msg, void *__formal)
{
  if ( s_errorPrintWarningOnly )
    Com_PrintWarning(20, "HavokPhysics: Initial Error as warning: %s (%s)", msg, s_errorExtraString);
  else
    Com_Error_impl(ERR_FATAL, (const ObfuscateErrorText)&stru_1442436B8, 143i64, msg, s_errorExtraString);
}

/*
==============
HavokPhysics_InplaceUnload
==============
*/
void HavokPhysics_InplaceUnload(void *buffer, const unsigned __int64 size)
{
  ;
}

/*
==============
HavokPhysics_InstantiateAsset
==============
*/
__int64 HavokPhysics_InstantiateAsset(Physics_WorldId worldId, const XModel *xModel, const PhysicsAsset *physicsAsset, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  Physics_WorldId v15; 
  Physics_InstantiationForceType v16; 
  Physics_InstantiateShapeOverride *v17; 
  int v27; 
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *physicsAssetAddendum; 
  const HavokPhysicsAsset *v30; 
  const PhysicsAsset *v31; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int Instance; 
  __int64 m_physicsSystemData; 
  __int64 v36; 
  Physics_InstantiationFilterType v37; 
  hkMemoryAllocator *v38; 
  int v39; 
  hkReferencedObject *v43; 
  hkReferencedObject *v44; 
  hkReferencedObject *v46; 
  hknpShape *MapEntsShape; 
  const hknpShape *v48; 
  const char *MapEntsShapeName; 
  char *v50; 
  int i; 
  const hknpShape *customShape; 
  char v53; 
  __int64 v54; 
  const hknpShape *v55; 
  int shapeAddendum; 
  int ShapeOverrideContents; 
  unsigned __int16 ShapeTag; 
  unsigned __int16 v59; 
  hkMemoryAllocator *v60; 
  int v61; 
  int v62; 
  int v64; 
  hkMemoryRouter *Value; 
  hknpCompoundShape *v73; 
  hknpShape *v74; 
  hknpShape *v75; 
  hkMemoryAllocator *v76; 
  __int64 v77; 
  hkReferencedObject **p_m_shape; 
  Physics_RefSystem RefSystem; 
  HavokPhysicsWorld *v80; 
  unsigned int v81; 
  unsigned int m_serialAndIndex; 
  unsigned int v87; 
  hkMemoryAllocator *v88; 
  int v89; 
  __int64 v90; 
  __int64 v91; 
  unsigned int v92; 
  const HavokPhysicsAsset *v93; 
  __int64 v94; 
  __int64 v95; 
  HavokPhysicsWorld *v96; 
  unsigned int m_value; 
  hkMemoryAllocator *v98; 
  __int64 v100; 
  int v101; 
  int v102; 
  int v103; 
  int v104; 
  int v105; 
  int v106; 
  int v107; 
  int v108; 
  bool v109; 
  char v110; 
  int *array; 
  int v112; 
  int v113; 
  int numInOut; 
  int v115; 
  unsigned int instanceId; 
  int refa; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo shapeTagData; 
  Physics_WorldId v120; 
  PhysicsAsset *physicsAsseta; 
  __int64 v122; 
  HavokPhysicsWorld *havokPhysicsWorld; 
  __int64 v124; 
  int v125; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> result; 
  const HavokPhysicsAsset *v127; 
  HavokPhysicsInstanceManager *manager; 
  hkQuaternionf *v129; 
  hkVector4f *v130; 
  hknpShapeInstance *v131; 
  int v132; 
  int v133; 
  hkVector4f v134; 
  hkQuaternionf v135; 
  Physics_InstantiateShapeOverride *v136; 
  __int64 v137; 
  hknpCompoundShapeCinfo cinfo; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v139; 
  char dest[512]; 

  v137 = -2i64;
  refa = ref;
  physicsAsseta = (PhysicsAsset *)physicsAsset;
  v15 = worldId;
  v120 = worldId;
  v16 = forceType;
  v17 = shapeOverride;
  v136 = shapeOverride;
  _R15 = position;
  v130 = (hkVector4f *)position;
  _RDI = orientation;
  v129 = (hkQuaternionf *)orientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9425, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(v100) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9426, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset in world %i", "physicsAsset", v100) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v101 & 0x7F800000) == 2139095040 )
    goto LABEL_253;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v102 & 0x7F800000) == 2139095040 )
    goto LABEL_253;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v103 & 0x7F800000) == 2139095040 )
  {
LABEL_253:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9427, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v104 & 0x7F800000) == 2139095040 )
    goto LABEL_254;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v105 & 0x7F800000) == 2139095040 )
    goto LABEL_254;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v106 & 0x7F800000) == 2139095040 )
    goto LABEL_254;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+488h+var_428], xmm0
  }
  if ( (v107 & 0x7F800000) == 2139095040 )
  {
LABEL_254:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9428, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
      __debugbreak();
  }
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9429, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  if ( shapeOverride->shapeOverride != -1 && shapeOverride->customShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9430, ASSERT_TYPE_ASSERT, "(shapeOverride->shapeOverride == -1 || !shapeOverride->customShape)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with shape override and custom shape - pick one", "shapeOverride->shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || !shapeOverride->customShape") )
    __debugbreak();
  if ( !shapeOverride->physicsAssetAddendum && shapeOverride->shapeAddendum != -1 )
  {
    LODWORD(v100) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9431, ASSERT_TYPE_ASSERT, "(shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == -1)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with addendum shape but no addendumasset - world index %i", "shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == PHYSICSSHAPE_OVERRIDEID_INVALID", v100) )
      __debugbreak();
  }
  v27 = shapeOverride->shapeOverride;
  v125 = v27;
  MutableWorld = HavokPhysics_GetMutableWorld(v15);
  havokPhysicsWorld = MutableWorld;
  if ( !MutableWorld->world )
  {
    LODWORD(v100) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9439, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v100) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9444, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  physicsAssetAddendum = shapeOverride->physicsAssetAddendum;
  if ( physicsAssetAddendum )
  {
    v30 = HavokPhysics_GetHavokPhysicsAsset(physicsAssetAddendum);
    v127 = v30;
    v31 = shapeOverride->physicsAssetAddendum;
    if ( v31 && !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9446, ASSERT_TYPE_ASSERT, "(!shapeOverride->physicsAssetAddendum || havokPhysicsAddendumAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok addendum asset", "!shapeOverride->physicsAssetAddendum || havokPhysicsAddendumAsset", v31->name) )
      __debugbreak();
  }
  else
  {
    v127 = NULL;
  }
  p_instanceManager = &MutableWorld->instanceManager;
  manager = &MutableWorld->instanceManager;
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  instanceId = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9451, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID", physicsAsseta->name) )
    __debugbreak();
  HavokPhysicsInstanceManager_SetXModel(p_instanceManager, Instance, xModel);
  HavokPhysicsInstanceManager_SetPhysicsAsset(p_instanceManager, Instance, physicsAsseta);
  HavokPhysicsInstanceManager_SetPhysicsAssetAddendum(p_instanceManager, Instance, shapeOverride->physicsAssetAddendum);
  m_physicsSystemData = (__int64)HavokPhysicsAsset->m_physicsSystemData;
  v124 = m_physicsSystemData;
  if ( v27 != -1 && *(int *)(m_physicsSystemData + 64) > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9463, ASSERT_TYPE_ASSERT, "(localShapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "localShapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
    __debugbreak();
  if ( Physics_IsQueryWorld(v15) || Physics_IsPredictiveWorld(v15) || *(int *)(m_physicsSystemData + 80) <= 0 )
  {
    v110 = 0;
    if ( !add || !forceAddImmediate )
    {
      v109 = 0;
      goto LABEL_58;
    }
  }
  else
  {
    v110 = 1;
  }
  v109 = 1;
  if ( !add && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9470, ASSERT_TYPE_ASSERT, "(!immediateAdd || add)", "%s\n\tHavok Physics: 
    __debugbreak();
LABEL_58:
  if ( v27 != -1 && v27 >= WorldCollision_GetMapEntsShapeCount() )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 144i64);
  v108 = 0;
  v115 = 0;
  array = NULL;
  v112 = 0;
  v113 = 0x80000000;
  _RDI = *(_QWORD *)(m_physicsSystemData + 56);
  v135.m_vec.m_quad.m128_u64[0] = _RDI;
  if ( _RDI != _RDI + 192i64 * *(int *)(m_physicsSystemData + 64) )
  {
    v36 = 0i64;
    v122 = 0i64;
    v37 = filterType;
    while ( 1 )
    {
      hknpBodyCinfo::hknpBodyCinfo(&v139);
      v139.m_attachedBody = -1;
      if ( v37 != Physics_InstantiationFilterTypeServer && v37 != Physics_InstantiationFilterTypeClientReplication )
        break;
      if ( HavokPhysicsAsset->m_bodyServerUsage.m_data[v36] <= 1u )
        break;
      v38 = hkMemHeapAllocator();
      v39 = v112;
      if ( v112 == (v113 & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v38, &array, 4);
        v39 = v112;
      }
      array[v39] = -1;
      ++v112;
      if ( v139.m_localFrame.m_ptr )
        hkReferencedObject::removeReference(v139.m_localFrame.m_ptr);
      if ( v139.m_dragProperties.m_ptr )
        hkReferencedObject::removeReference(v139.m_dragProperties.m_ptr);
      if ( v139.m_massDistribution.m_ptr )
        hkReferencedObject::removeReference(v139.m_massDistribution.m_ptr);
      hkStringPtr::~hkStringPtr(&v139.m_name);
      if ( v139.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
LABEL_192:
      _RDI += 192i64;
      v135.m_vec.m_quad.m128_u64[0] = _RDI;
      ++v115;
      v122 = ++v36;
      if ( _RDI == *(_QWORD *)(v124 + 56) + 192i64 * *(int *)(v124 + 64) )
      {
        p_instanceManager = manager;
        m_physicsSystemData = v124;
        goto LABEL_194;
      }
    }
    if ( *(_QWORD *)_RDI )
      hkReferencedObject::addReference(*(hkReferencedObject **)_RDI);
    if ( v139.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
    v139.m_shape.m_ptr = *(const hknpShape **)_RDI;
    v139.m_flags.m_storage = *(_DWORD *)(_RDI + 8);
    v139.m_collisionCntrl.m_storage = *(_WORD *)(_RDI + 12);
    v139.m_collisionFilterInfo = *(_DWORD *)(_RDI + 16);
    v139.m_materialId.m_value = *(_WORD *)(_RDI + 20);
    v139.m_qualityId.m_value = *(_BYTE *)(_RDI + 22);
    hkStringPtr::operator=(&v139.m_name, (const hkStringPtr *)(_RDI + 24));
    v139.m_userData = *(_QWORD *)(_RDI + 32);
    v139.m_motionType.m_storage = *(_BYTE *)(_RDI + 40);
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+30h]
      vmovups ymmword ptr [rsp+488h+var_308.m_position.m_quad], ymm0
      vmovups ymm0, ymmword ptr [rdi+50h]
      vmovups ymmword ptr [rsp+488h+var_308.m_linearVelocity.m_quad], ymm0
      vmovss  xmm0, dword ptr [rdi+70h]
      vmovss  [rsp+488h+var_308.m_mass], xmm0
    }
    v43 = *(hkReferencedObject **)(_RDI + 120);
    if ( v43 )
      hkReferencedObject::addReference(v43);
    if ( v139.m_massDistribution.m_ptr )
      hkReferencedObject::removeReference(v139.m_massDistribution.m_ptr);
    v139.m_massDistribution.m_ptr = *(hknpRefMassDistribution **)(_RDI + 120);
    v44 = *(hkReferencedObject **)(_RDI + 128);
    if ( v44 )
      hkReferencedObject::addReference(v44);
    if ( v139.m_dragProperties.m_ptr )
      hkReferencedObject::removeReference(v139.m_dragProperties.m_ptr);
    v139.m_dragProperties.m_ptr = *(hknpRefDragProperties **)(_RDI + 128);
    v139.m_motionPropertiesId.m_value = *(_WORD *)(_RDI + 136);
    v139.m_desiredBodyId.m_serialAndIndex = *(_DWORD *)(_RDI + 140);
    v139.m_motionId.m_value = *(_DWORD *)(_RDI + 144);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+94h]
      vmovss  [rsp+488h+var_308.m_collisionLookAheadDistance], xmm0
    }
    v46 = *(hkReferencedObject **)(_RDI + 152);
    if ( v46 )
      hkReferencedObject::addReference(v46);
    if ( v139.m_localFrame.m_ptr )
      hkReferencedObject::removeReference(v139.m_localFrame.m_ptr);
    v139.m_localFrame.m_ptr = *(hkLocalFrame **)(_RDI + 152);
    v139.m_activationPriority = *(_BYTE *)(_RDI + 160);
    v139.m_attachedBody = *(_DWORD *)(_RDI + 176);
    if ( v27 == -1 || !WorldCollision_GetMapEntsShape(v27) )
    {
      customShape = v17->customShape;
      if ( v17->customShape )
      {
        hkReferencedObject::addReference(v17->customShape);
        if ( v139.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
        v139.m_shape.m_ptr = customShape;
      }
    }
    else
    {
      MapEntsShape = WorldCollision_GetMapEntsShape(v27);
      v48 = MapEntsShape;
      if ( MapEntsShape )
        hkReferencedObject::addReference(MapEntsShape);
      if ( v139.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
      v139.m_shape.m_ptr = v48;
      MapEntsShapeName = WorldCollision_GetMapEntsShapeName(v27);
      Com_sprintf<512>((char (*)[512])dest, "%s:%s", (const char *)((unsigned __int64)v139.m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), MapEntsShapeName);
      v50 = dest;
      for ( i = dest[0]; *v50; i = *v50 )
        *v50++ = i + ((unsigned int)(i - 65) < 0x1A ? 0x20 : 0);
      hkStringPtr::set(&v139.m_name, dest, -1);
    }
    if ( Physics_IsQueryWorld(v15) )
    {
      v139.m_motionId.m_value = 0x7FFFFFFF;
      v139.m_motionType.m_storage = 0;
    }
    v53 = 0;
    if ( _RDI == *(_QWORD *)(v124 + 56) )
    {
      v54 = (__int64)v127;
      if ( v127 )
      {
        if ( v127->m_physicsSystemData->m_bodyCinfos.m_size != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9523, ASSERT_TYPE_ASSERT, "(havokPhysicsAddendumAsset->m_physicsSystemData->m_bodyCinfos.getSize() == 1)", "%s\n\tHavokPhysics InstantiateAsset %s: havok addendum assets only support 1 body at the minute", "havokPhysicsAddendumAsset->m_physicsSystemData->m_bodyCinfos.getSize() == 1", v17->physicsAssetAddendum->name) )
          __debugbreak();
        v55 = **(const hknpShape ***)(*(_QWORD *)(v54 + 8) + 56i64);
        shapeAddendum = v17->shapeAddendum;
        ShapeOverrideContents = 0;
        if ( shapeAddendum != -1 )
        {
          if ( shapeAddendum >= WorldCollision_GetMapEntsShapeCount() )
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 145i64);
          if ( WorldCollision_GetMapEntsShape(shapeAddendum) )
          {
            v55 = WorldCollision_GetMapEntsShape(shapeAddendum);
            ShapeOverrideContents = HavokPhysics_GetShapeOverrideContents(shapeAddendum);
          }
        }
        shapeTagData.m_constraintData.m_ptr = (hkpConstraintData *)v139.m_collisionFilterInfo;
        LOWORD(shapeTagData.m_bodyA.m_serialAndIndex) = v139.m_materialId.m_value;
        *(_QWORD *)&shapeTagData.m_flags.m_storage = v139.m_userData;
        ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, (HavokPhysicsShapeList::ShapeTagData *)&shapeTagData);
        LODWORD(shapeTagData.m_constraintData.m_ptr) = ShapeOverrideContents;
        v59 = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, (HavokPhysicsShapeList::ShapeTagData *)&shapeTagData);
        v139.m_collisionFilterInfo |= ShapeOverrideContents;
        numInOut = 2;
        v60 = hkMemHeapAllocator();
        v61 = numInOut;
        v62 = numInOut;
        if ( numInOut )
        {
          _RSI = (hknpShapeInstance *)hkMemoryAllocator::bufAlloc2(v60, 112, &numInOut);
          v61 = numInOut;
        }
        else
        {
          _RSI = NULL;
        }
        v64 = 0x80000000;
        if ( v61 )
          v64 = v61;
        v131 = _RSI;
        v132 = v62;
        v133 = v64;
        if ( _RSI )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rsi], ymm0
            vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rsi+20h], ymm1
            vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
            vmovups xmmword ptr [rsi+40h], xmm0
          }
          _RSI->m_shape.m_ptr = NULL;
          *(_DWORD *)&_RSI->m_shapeTag = -1;
          _RSI->m_isEmpty = 0;
          _RSI->m_nextEmptyElement = 0;
          _RSI->m_instanceId.m_value = -1;
          _RSI->m_parentShape = NULL;
          v134.m_quad.m128_i32[0] = 64;
          _RSI->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
        }
        _RBX = _RSI + 1;
        if ( _RSI != (hknpShapeInstance *)-112i64 )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rbx], ymm0
            vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rbx+20h], ymm1
            vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
            vmovups xmmword ptr [rbx+40h], xmm0
          }
          _RSI[1].m_shape.m_ptr = NULL;
          *(_DWORD *)&_RSI[1].m_shapeTag = -1;
          _RSI[1].m_isEmpty = 0;
          _RSI[1].m_nextEmptyElement = 0;
          _RSI[1].m_instanceId.m_value = -1;
          _RSI[1].m_parentShape = NULL;
          v134.m_quad.m128_i32[0] = 64;
          _RSI[1].m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
        }
        hknpShapeInstance::setShape(_RSI, v139.m_shape.m_ptr);
        hknpShapeInstance::setShape(_RSI + 1, v55);
        _RSI->m_shapeTag = ShapeTag;
        _RSI[1].m_shapeTag = v59;
        hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
        cinfo.m_instances = _RSI;
        cinfo.m_numInstances = v62;
        Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
        if ( !Value )
          Value = hkMemoryRouter::s_fallbackRouter;
        v73 = (hknpCompoundShape *)Value->m_heap->blockAlloc(Value->m_heap, 288i64);
        v134.m_quad.m128_u64[0] = (unsigned __int64)v73;
        if ( v73 )
        {
          hknpCompoundShape::hknpCompoundShape(v73, &cinfo);
          v75 = v74;
        }
        else
        {
          v75 = NULL;
        }
        if ( v75 )
          hkReferencedObject::addReference(v75);
        if ( v139.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
        v139.m_shape.m_ptr = v75;
        v53 = 1;
        v76 = hkMemHeapAllocator();
        v77 = v62 - 1;
        if ( v62 - 1 >= 0 )
        {
          p_m_shape = (hkReferencedObject **)&_RSI[v77].m_shape;
          do
          {
            if ( *p_m_shape )
              hkReferencedObject::removeReference(*p_m_shape);
            p_m_shape -= 14;
            --v77;
          }
          while ( v77 >= 0 );
        }
        v132 = 0;
        if ( v64 >= 0 )
          hkMemoryAllocator::bufFree2(v76, _RSI, 112, v64 & 0x3FFFFFFF);
        v131 = NULL;
        v133 = 0x80000000;
        _RDI = v135.m_vec.m_quad.m128_u64[0];
        v15 = v120;
        v17 = v136;
        v16 = forceType;
        v37 = filterType;
      }
    }
    v139.m_flags.m_storage |= forQueryOnly << 8;
    RefSystem = Physics_GetRefSystem(refa);
    v80 = havokPhysicsWorld;
    HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(v15, havokPhysicsWorld, RefSystem, &v139);
    if ( Physics_IsQueryWorld(v15) )
      goto LABEL_149;
    v81 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v122];
    if ( v37 == Physics_InstantiationFilterTypeServer )
    {
      if ( v81 )
        goto LABEL_149;
    }
    else if ( (v37 == Physics_InstantiationFilterTypeClientReplication || v37 == Physics_InstantiationFilterTypeClientSimulation) && v81 > 1 )
    {
      goto LABEL_149;
    }
    if ( v16 == Physics_InstantiationForceTypeKeyframed )
      goto LABEL_164;
    if ( v16 != Physics_InstantiationForceTypeKeyframedAtMost )
    {
      if ( v16 == Physics_InstantiationForceTypeStatic )
      {
        v139.m_flags.m_storage &= 0xFFFFFFF8;
        v139.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
        v139.m_motionType.m_storage = 0;
        goto LABEL_152;
      }
      goto LABEL_149;
    }
    if ( v139.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
    {
LABEL_164:
      v139.m_flags.m_storage &= 0xFFFFFFF8;
      v139.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
      v139.m_motionType.m_storage = 1;
      goto LABEL_152;
    }
LABEL_149:
    if ( v139.m_motionType.m_storage >= 2u && v16 != Physics_InstantiationForceTypeStatic )
      v139.m_flags.m_storage |= 0x10u;
LABEL_152:
    _RAX = v129;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+488h+var_358], xmm0
    }
    _RAX = v130;
    __asm
    {
      vmovups xmm1, xmmword ptr [rax]
      vmovups [rsp+488h+var_368], xmm1
    }
    m_serialAndIndex = HavokPhysics_CreateRigidBody((hknpBodyId *)&result, v15, v80, physicsAsseta, v115, &v139, refa, &v134, &v135, 0, tryStartDeactivated, 1)->m_serialAndIndex;
    if ( Physics_IsQueryWorld(v15) )
      goto LABEL_175;
    v87 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v122];
    if ( v37 == Physics_InstantiationFilterTypeServer )
    {
      if ( v87 )
        goto LABEL_173;
    }
    else if ( (v37 == Physics_InstantiationFilterTypeClientReplication || v37 == Physics_InstantiationFilterTypeClientSimulation) && v87 > 1 )
    {
LABEL_173:
      if ( v139.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
        HavokPhysics_SetRigidBodyKeyframed(v15, (hknpBodyId)m_serialAndIndex);
      goto LABEL_175;
    }
    if ( v16 != Physics_InstantiationForceTypeKeyframed )
    {
      if ( v16 != Physics_InstantiationForceTypeKeyframedAtMost )
      {
        if ( v16 == Physics_InstantiationForceTypeStatic )
          HavokPhysics_SetRigidBodyStatic(v15, (hknpBodyId)m_serialAndIndex);
LABEL_172:
        if ( v16 == Physics_InstantiationForceTypeNone )
          goto LABEL_173;
LABEL_175:
        if ( v53 )
          hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
        HavokPhysicsInstanceManager_AddBody(manager, instanceId, (hknpBodyId)m_serialAndIndex);
        v88 = hkMemHeapAllocator();
        v89 = v112;
        if ( v112 == (v113 & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v88, &array, 4);
          v89 = v112;
        }
        array[v89] = v108;
        ++v112;
        if ( HavokPhysics_HasTriggerEvent(v15, (hknpBodyId)m_serialAndIndex) && HavokPhysics_IsRigidBodyStatic(v15, (hknpBodyId)m_serialAndIndex) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9695, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
          __debugbreak();
        ++v108;
        if ( v139.m_localFrame.m_ptr )
          hkReferencedObject::removeReference(v139.m_localFrame.m_ptr);
        if ( v139.m_dragProperties.m_ptr )
          hkReferencedObject::removeReference(v139.m_dragProperties.m_ptr);
        if ( v139.m_massDistribution.m_ptr )
          hkReferencedObject::removeReference(v139.m_massDistribution.m_ptr);
        hkStringPtr::~hkStringPtr(&v139.m_name);
        if ( v139.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v139.m_shape.m_ptr->hkReferencedObject);
        v27 = v125;
        v36 = v122;
        goto LABEL_192;
      }
      if ( (*(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))havokPhysicsWorld->world->getBody)(&havokPhysicsWorld->world->hknpWorldReader, m_serialAndIndex) + 68) & 5) != 0 )
        goto LABEL_172;
    }
    HavokPhysics_SetRigidBodyKeyframed(v15, (hknpBodyId)m_serialAndIndex);
    goto LABEL_172;
  }
LABEL_194:
  if ( add )
  {
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    v90 = instanceId;
    if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(havokPhysicsWorld, p_instanceManager->buffer[v90].bodies.m_data, p_instanceManager->buffer[v90].bodies.m_size, v109, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(v15, p_instanceManager, v90, v109, !v109);
  }
  else
  {
    LODWORD(v90) = instanceId;
  }
  if ( v110 )
  {
    v91 = *(_QWORD *)(m_physicsSystemData + 72);
    v92 = 0;
    if ( v91 != v91 + 40i64 * *(int *)(m_physicsSystemData + 80) )
    {
      do
      {
        shapeTagData.m_constraintData.m_ptr = NULL;
        shapeTagData.m_bodyA.m_serialAndIndex = 0xFFFFFF;
        shapeTagData.m_bodyB.m_serialAndIndex = 0xFFFFFF;
        shapeTagData.m_flags.m_storage = 0;
        shapeTagData.m_name.m_stringAndFlag = NULL;
        shapeTagData.m_desiredConstraintId.m_value = 0x7FFFFFFF;
        shapeTagData.m_constraintGroupId.m_value = 0x7FFFFFFF;
        if ( *(_QWORD *)v91 )
        {
          hkReferencedObject::addReference(*(hkReferencedObject **)v91);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        shapeTagData.m_constraintData.m_ptr = *(hkpConstraintData **)v91;
        shapeTagData.m_bodyA.m_serialAndIndex = *(_DWORD *)(v91 + 8);
        shapeTagData.m_bodyB.m_serialAndIndex = *(_DWORD *)(v91 + 12);
        shapeTagData.m_flags.m_storage = *(_WORD *)(v91 + 16);
        hkStringPtr::operator=(&shapeTagData.m_name, (const hkStringPtr *)(v91 + 24));
        shapeTagData.m_desiredConstraintId.m_value = *(_DWORD *)(v91 + 32);
        shapeTagData.m_constraintGroupId.m_value = *(_DWORD *)(v91 + 36);
        if ( (shapeTagData.m_bodyA.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9732, ASSERT_TYPE_ASSERT, "(cInfo.m_bodyA.isValid())", "%s\n\tHavokPhysics InstantiateAsset %s: constraint bodyA is invalid - implies we are trying to use the world as a child", "cInfo.m_bodyA.isValid()", physicsAsseta->name) )
          __debugbreak();
        if ( array[shapeTagData.m_bodyA.m_serialAndIndex] == -1 )
        {
          hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        else if ( (shapeTagData.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF || array[shapeTagData.m_bodyB.m_serialAndIndex] != -1 )
        {
          v93 = HavokPhysicsAsset;
          if ( v92 >= HavokPhysicsAsset->m_constraintServerUsage.m_size )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9746, ASSERT_TYPE_ASSERT, "(index < (uint)havokPhysicsAsset->m_constraintServerUsage.getSize())", (const char *)&queryFormat, "index < (uint)havokPhysicsAsset->m_constraintServerUsage.getSize()") )
              __debugbreak();
            v93 = HavokPhysicsAsset;
          }
          if ( (unsigned int)v15 > PHYSICS_WORLD_ID_SERVER_DETAIL || v93->m_constraintServerUsage.m_data[v92] )
          {
            v94 = array[shapeTagData.m_bodyA.m_serialAndIndex];
            if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
              __debugbreak();
            if ( (_DWORD)v90 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
              __debugbreak();
            shapeTagData.m_bodyA.m_serialAndIndex = p_instanceManager->buffer[(unsigned int)v90].bodies.m_data[v94].m_serialAndIndex;
            if ( (shapeTagData.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
            {
              shapeTagData.m_bodyB.m_serialAndIndex = 0xFFFFFF;
            }
            else
            {
              v95 = array[shapeTagData.m_bodyB.m_serialAndIndex];
              if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                __debugbreak();
              if ( (_DWORD)v90 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                __debugbreak();
              shapeTagData.m_bodyB.m_serialAndIndex = p_instanceManager->buffer[(unsigned int)v90].bodies.m_data[v95].m_serialAndIndex;
            }
            v96 = havokPhysicsWorld;
            HavokPhysics_GroupRagdollConstraint(havokPhysicsWorld, physicsAsseta, refa, &shapeTagData);
            m_value = HavokPhysics_CreateConstraint(&result, v96, &shapeTagData, v130, v129)->m_value;
            *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v96->world->getConstraint)(&v96->world->hknpWorldReader, m_value) + 64) = (unsigned int)v90 | ((unsigned __int64)v92 << 32);
            HavokPhysicsInstanceManager_AddConstraint(p_instanceManager, v90, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
            hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
            if ( shapeTagData.m_constraintData.m_ptr )
              hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
            v15 = v120;
            m_physicsSystemData = v124;
          }
          else
          {
            hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
            if ( shapeTagData.m_constraintData.m_ptr )
              hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
          }
        }
        else
        {
          hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        v91 += 40i64;
        ++v92;
      }
      while ( v91 != *(_QWORD *)(m_physicsSystemData + 72) + 40i64 * *(int *)(m_physicsSystemData + 80) );
    }
  }
  v98 = hkMemHeapAllocator();
  v112 = 0;
  if ( v113 >= 0 )
    hkMemoryAllocator::bufFree2(v98, array, 4, v113 & 0x3FFFFFFF);
  return (unsigned int)v90;
}

/*
==============
HavokPhysics_InstantiateAssetBody
==============
*/
__int64 HavokPhysics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned __int8 v30; 
  hknpShape *MapEntsShape; 
  const hknpShape *v32; 
  Physics_RefSystem RefSystem; 
  unsigned int v34; 
  Physics_InstantiationForceType v35; 
  unsigned int v40; 
  int v41; 
  unsigned int v42; 
  __int64 v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  hknpBodyId bodyId; 
  int v53; 
  int v54; 
  unsigned int instanceIda; 
  hkQuaternionf v56; 
  hkVector4f v57; 
  const PhysicsAsset *v58; 
  __int64 v59; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v60; 

  v59 = -2i64;
  v53 = bodyIdx;
  v58 = physicsAsset;
  instanceIda = instanceId;
  v54 = ref;
  _R13 = position;
  v57.m_quad.m128_u64[0] = (unsigned __int64)position;
  _RDI = orientation;
  v56.m_vec.m_quad.m128_u64[0] = (unsigned __int64)orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v60);
  v60.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10049, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v44) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10050, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v44) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v44) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10051, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body in world %i", "physicsAsset", v44) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v44) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10052, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v44, bodyIdx) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r13+0]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_114;
  __asm
  {
    vmovss  xmm0, dword ptr [r13+4]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
    goto LABEL_114;
  __asm
  {
    vmovss  xmm0, dword ptr [r13+8]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
  {
LABEL_114:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10053, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+1C0h+var_160], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
  {
LABEL_115:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10054, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v44) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10058, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v44) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10063, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10067, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10068, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( shapeOverride != -1 && m_physicsSystemData->m_bodyCinfos.m_size > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10074, ASSERT_TYPE_ASSERT, "(shapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
    __debugbreak();
  if ( (filterType == Physics_InstantiationFilterTypeServer || filterType == Physics_InstantiationFilterTypeClientReplication) && HavokPhysicsAsset->m_bodyServerUsage.m_data[v53] > 1u )
  {
    v30 = 0;
    goto LABEL_103;
  }
  if ( shapeOverride != -1 && shapeOverride >= WorldCollision_GetMapEntsShapeCount() )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 147i64);
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v60, &m_physicsSystemData->m_bodyCinfos.m_data[v53]);
  if ( shapeOverride != -1 && WorldCollision_GetMapEntsShape(shapeOverride) )
  {
    MapEntsShape = WorldCollision_GetMapEntsShape(shapeOverride);
    v32 = MapEntsShape;
    if ( MapEntsShape )
      hkReferencedObject::addReference(MapEntsShape);
    if ( v60.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v60.m_shape.m_ptr->hkReferencedObject);
    v60.m_shape.m_ptr = v32;
  }
  if ( Physics_IsQueryWorld(worldId) )
  {
    v60.m_motionId.m_value = 0x7FFFFFFF;
    v60.m_motionType.m_storage = 0;
  }
  v60.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(v54);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v60);
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_63;
  v34 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v53];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v34 )
    {
LABEL_63:
      v35 = forceType;
      goto LABEL_64;
    }
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v34 > 1 )
  {
    goto LABEL_63;
  }
  v35 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_79;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v60.m_flags.m_storage &= 0xFFFFFFF8;
      v60.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v60.m_motionType.m_storage = 0;
      goto LABEL_67;
    }
    goto LABEL_64;
  }
  if ( v60.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_79:
    v60.m_flags.m_storage &= 0xFFFFFFF8;
    v60.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v60.m_motionType.m_storage = 1;
    goto LABEL_67;
  }
LABEL_64:
  if ( v60.m_motionType.m_storage >= 2u && v35 != Physics_InstantiationForceTypeStatic )
    v60.m_flags.m_storage |= 0x10u;
LABEL_67:
  _RAX = v56.m_vec.m_quad.m128_u64[0];
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups [rbp+0C0h+var_140], xmm0
  }
  _RAX = v57.m_quad.m128_u64[0];
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups [rbp+0C0h+var_130], xmm1
  }
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody((hknpBodyId *)&v54, worldId, MutableWorld, v58, v53, &v60, v54, &v57, &v56, 0, tryStartDeactivated, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_91;
  v40 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v53];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v40 )
      goto LABEL_89;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v40 > 1 )
  {
LABEL_89:
    if ( v60.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_91;
  }
  switch ( v35 )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_87;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v41 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v41 & 1) != 0 || (v41 & 4) != 0 )
        break;
LABEL_87:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( v35 == Physics_InstantiationForceTypeNone )
    goto LABEL_89;
LABEL_91:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v42 = instanceIda;
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda, bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10224, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v42, 1, 0);
  }
  v30 = 1;
LABEL_103:
  if ( v60.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v60.m_localFrame.m_ptr);
  if ( v60.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v60.m_dragProperties.m_ptr);
  if ( v60.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v60.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v60.m_name);
  if ( v60.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v60.m_shape.m_ptr->hkReferencedObject);
  return v30;
}

/*
==============
HavokPhysics_InstantiateAssetBodyCylinder
==============
*/
__int64 HavokPhysics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned int v34; 
  bool v35; 
  unsigned __int8 v36; 
  bool v38; 
  hknpShape *v43; 
  hknpShape *v44; 
  Physics_RefSystem RefSystem; 
  int v46; 
  unsigned int v47; 
  Physics_InstantiationForceType v48; 
  unsigned int v53; 
  int v54; 
  unsigned int v55; 
  __int64 result; 
  __int64 v61; 
  hknpBodyId v62; 
  BOOL v63; 
  hknpBodyId bodyId; 
  int v65; 
  unsigned int instanceIda[2]; 
  const hkQuaternionf *v67; 
  hkVector4f v68; 
  __int64 v69; 
  hkVector4f center; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v71; 
  char v72; 
  void *retaddr; 

  _RAX = &retaddr;
  v69 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
  }
  v65 = bodyIdx;
  instanceIda[1] = instanceId;
  LOBYTE(v63) = tryStartDeactivated;
  instanceIda[0] = ref;
  _R15 = position;
  v68.m_quad.m128_u64[0] = (unsigned __int64)position;
  _RDI = orientation;
  v67 = orientation;
  __asm
  {
    vmovss  xmm7, [rbp+0F0h+radius]
    vmovss  xmm8, [rbp+0F0h+height]
  }
  hknpBodyCinfo::hknpBodyCinfo(&v71);
  v71.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10468, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v61) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10469, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v61) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v61) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10470, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body cylinder in world %i", "physicsAsset", v61) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v61) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10471, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v61, bodyIdx) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_114;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_114;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_114:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10472, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body cylinder with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_115;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+1F0h+var_190], xmm0
  }
  if ( (v62.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_115:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10473, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body cylinder with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v61) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10477, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v61) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10482, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10486, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10487, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  v34 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v65];
  if ( filterType == Physics_InstantiationFilterTypeServer || (v35 = (unsigned int)(filterType - 1) <= 1, filterType == Physics_InstantiationFilterTypeClientReplication) )
  {
    v35 = v34 <= 1;
    if ( v34 > 1 )
    {
      v36 = 0;
      goto LABEL_103;
    }
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm7, xmm6
  }
  if ( v35 )
  {
    v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10500, ASSERT_TYPE_ASSERT, "(radius > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid radius", "radius > 0");
    v35 = !v38;
    if ( v38 )
      __debugbreak();
  }
  __asm { vcomiss xmm8, xmm6 }
  if ( v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10501, ASSERT_TYPE_ASSERT, "(height > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid height", "height > 0") )
    __debugbreak();
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v71, &m_physicsSystemData->m_bodyCinfos.m_data[v65]);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+0F0h+center.m_quad], xmm0
    vmulss  xmm1, xmm8, cs:__real@3f000000; halfHeight
    vaddss  xmm0, xmm0, xmm1
    vmovss  dword ptr [rbp+0F0h+center.m_quad+8], xmm0
    vmovaps xmm2, xmm7; radius
  }
  v43 = HavokPhysics_CreateShapeCylinder(&center, *(float *)&_XMM1, *(float *)&_XMM2, 32, 0);
  v44 = v43;
  if ( v43 )
  {
    hkReferencedObject::addReference(v43);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10509, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
  {
    __debugbreak();
  }
  if ( v71.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v71.m_shape.m_ptr->hkReferencedObject);
  v71.m_shape.m_ptr = v44;
  if ( Physics_IsQueryWorld(worldId) )
  {
    v71.m_motionId.m_value = 0x7FFFFFFF;
    v71.m_motionType.m_storage = 0;
  }
  v71.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(instanceIda[0]);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v71);
  if ( Physics_IsQueryWorld(worldId) )
  {
    v46 = v65;
    goto LABEL_70;
  }
  v46 = v65;
  v47 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v65];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( !v47 )
      goto LABEL_63;
LABEL_70:
    v48 = forceType;
    goto LABEL_71;
  }
  if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v47 > 1 )
    goto LABEL_70;
LABEL_63:
  v48 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_68;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v71.m_flags.m_storage &= 0xFFFFFFF8;
      v71.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v71.m_motionType.m_storage = 0;
      goto LABEL_74;
    }
    goto LABEL_71;
  }
  if ( v71.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_68:
    v71.m_flags.m_storage &= 0xFFFFFFF8;
    v71.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v71.m_motionType.m_storage = 1;
    goto LABEL_74;
  }
LABEL_71:
  if ( v71.m_motionType.m_storage >= 2u && v48 != Physics_InstantiationForceTypeStatic )
    v71.m_flags.m_storage |= 0x10u;
LABEL_74:
  _RAX = v67;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbp+0F0h+center.m_quad], xmm0
  }
  _RAX = v68.m_quad.m128_u64[0];
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups [rbp+0F0h+var_170], xmm1
  }
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody(&v62, worldId, MutableWorld, physicsAsset, v46, &v71, instanceIda[0], &v68, (hkQuaternionf *)&center, 0, v63, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_91;
  v53 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v65];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v53 )
      goto LABEL_89;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v53 > 1 )
  {
LABEL_89:
    if ( v71.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_91;
  }
  switch ( forceType )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_87;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v54 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v54 & 1) != 0 || (v54 & 4) != 0 )
        break;
LABEL_87:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( forceType == Physics_InstantiationForceTypeNone )
    goto LABEL_89;
LABEL_91:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v55 = instanceIda[1];
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda[1], bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10641, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v55, 1, 0);
  }
  hkReferencedObject::removeReference(v44);
  v36 = 1;
LABEL_103:
  if ( v71.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v71.m_localFrame.m_ptr);
  if ( v71.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v71.m_dragProperties.m_ptr);
  if ( v71.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v71.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v71.m_name);
  if ( v71.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v71.m_shape.m_ptr->hkReferencedObject);
  result = v36;
  _R11 = &v72;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
  }
  return result;
}

/*
==============
HavokPhysics_InstantiateAssetBodySphere
==============
*/
__int64 HavokPhysics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v15; 
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned int v29; 
  bool v30; 
  unsigned __int8 v31; 
  hknpSphereShape *v34; 
  hknpShape *v36; 
  hknpShape *v37; 
  Physics_RefSystem RefSystem; 
  unsigned int v39; 
  Physics_InstantiationForceType v40; 
  unsigned int v45; 
  int v46; 
  unsigned int v47; 
  __int64 result; 
  __int64 v50; 
  int shapeSizeOut; 
  bool v52; 
  hknpBodyId bodyId; 
  int v54; 
  hknpBodyId v55; 
  unsigned int instanceIda; 
  const hkQuaternionf *v57; 
  const hkVector4f *v58; 
  hkVector4f v59; 
  hkQuaternionf v60; 
  __int64 v61; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v62; 
  hkVector4f center; 

  v61 = -2i64;
  __asm { vmovaps [rsp+1F0h+var_50], xmm6 }
  v15 = bodyIdx;
  v55.m_serialAndIndex = bodyIdx;
  instanceIda = instanceId;
  v52 = tryStartDeactivated;
  v54 = ref;
  _R14 = position;
  v58 = position;
  _RDI = orientation;
  v57 = orientation;
  __asm { vmovss  xmm6, [rbp+0F0h+radius] }
  hknpBodyCinfo::hknpBodyCinfo(&v62);
  v62.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10260, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v50) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10262, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body sphere in world %i", "physicsAsset", v50) )
      __debugbreak();
  }
  if ( (int)v15 < 0 || (int)v15 >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10263, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v50, v15) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
    goto LABEL_108;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
    goto LABEL_108;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
  {
LABEL_108:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10264, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body sphere with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
    goto LABEL_109;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
    goto LABEL_109;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
    goto LABEL_109;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+1F0h+shapeSizeOut], xmm0
  }
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 )
  {
LABEL_109:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10265, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body sphere with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10269, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v50) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10274, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10278, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10279, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  v29 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v15];
  if ( filterType == Physics_InstantiationFilterTypeServer || (v30 = (unsigned int)(filterType - 1) <= 1, filterType == Physics_InstantiationFilterTypeClientReplication) )
  {
    v30 = v29 <= 1;
    if ( v29 > 1 )
    {
      v31 = 0;
      goto LABEL_97;
    }
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10292, ASSERT_TYPE_ASSERT, "(radius > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid radius", "radius > 0") )
    __debugbreak();
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v62, &m_physicsSystemData->m_bodyCinfos.m_data[v15]);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+0F0h+center.m_quad], xmm0
  }
  v34 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
  v59.m_quad.m128_u64[0] = (unsigned __int64)v34;
  v60.m_vec.m_quad.m128_u64[0] = (unsigned __int64)v34;
  if ( v34 )
  {
    __asm { vmovaps xmm2, xmm6; radius }
    hknpSphereShape::hknpSphereShape(v34, &center, *(float *)&_XMM2);
    v37 = v36;
  }
  else
  {
    v37 = NULL;
  }
  v37->m_memSizeAndFlags = shapeSizeOut;
  hkReferencedObject::addReference(v37);
  if ( v62.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v62.m_shape.m_ptr->hkReferencedObject);
  v62.m_shape.m_ptr = v37;
  if ( Physics_IsQueryWorld(worldId) )
  {
    v62.m_motionId.m_value = 0x7FFFFFFF;
    v62.m_motionType.m_storage = 0;
  }
  v62.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(v54);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v62);
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_57;
  v39 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v15];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v39 )
    {
LABEL_57:
      v40 = forceType;
      goto LABEL_58;
    }
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v39 > 1 )
  {
    goto LABEL_57;
  }
  v40 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_73;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v62.m_flags.m_storage &= 0xFFFFFFF8;
      v62.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v62.m_motionType.m_storage = 0;
      goto LABEL_61;
    }
    goto LABEL_58;
  }
  if ( v62.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_73:
    v62.m_flags.m_storage &= 0xFFFFFFF8;
    v62.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v62.m_motionType.m_storage = 1;
    goto LABEL_61;
  }
LABEL_58:
  if ( v62.m_motionType.m_storage >= 2u && v40 != Physics_InstantiationForceTypeStatic )
    v62.m_flags.m_storage |= 0x10u;
LABEL_61:
  _RAX = v57;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups [rbp+0F0h+var_150], xmm0
  }
  _RAX = v58;
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups [rbp+0F0h+var_160], xmm1
  }
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody(&v55, worldId, MutableWorld, physicsAsset, v55.m_serialAndIndex, &v62, v54, &v59, &v60, 0, v52, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_85;
  v45 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v15];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v45 )
      goto LABEL_83;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v45 > 1 )
  {
LABEL_83:
    if ( v62.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_85;
  }
  switch ( forceType )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_81;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v46 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v46 & 1) != 0 || (v46 & 4) != 0 )
        break;
LABEL_81:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( forceType == Physics_InstantiationForceTypeNone )
    goto LABEL_83;
LABEL_85:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v47 = instanceIda;
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda, bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10431, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v47, 1, 0);
  }
  hkReferencedObject::removeReference(v37);
  v31 = 1;
LABEL_97:
  if ( v62.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v62.m_localFrame.m_ptr);
  if ( v62.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v62.m_dragProperties.m_ptr);
  if ( v62.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v62.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v62.m_name);
  if ( v62.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v62.m_shape.m_ptr->hkReferencedObject);
  result = v31;
  __asm { vmovaps xmm6, [rsp+1F0h+var_50] }
  return result;
}

/*
==============
HavokPhysics_InstantiateAssetConstraint
==============
*/
char HavokPhysics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  __int64 v7; 
  __int64 v10; 
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v13; 
  hkpConstraintData *v14; 
  hkpConstraintData *v15; 
  unsigned int m_value; 
  __int64 v20; 
  hknpBodyId result; 
  hknpConstraintCinfo cInfo; 
  __int64 v23; 
  hkVector4f position; 
  hkQuaternionf orientation; 

  v23 = -2i64;
  v7 = constraintIdx;
  v10 = instanceId;
  cInfo.m_constraintData.m_ptr = NULL;
  cInfo.m_bodyA.m_serialAndIndex = 0xFFFFFF;
  cInfo.m_bodyB.m_serialAndIndex = 0xFFFFFF;
  cInfo.m_flags.m_storage = 0;
  cInfo.m_name.m_stringAndFlag = NULL;
  cInfo.m_desiredConstraintId.m_value = 0x7FFFFFFF;
  cInfo.m_constraintGroupId.m_value = 0x7FFFFFFF;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10679, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10680, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v20) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10681, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset constraint in world %i", "physicsAsset", v20) )
      __debugbreak();
  }
  if ( (int)v7 < 0 || (int)v7 >= Physics_GetPhysicsAssetConstraintCount(physicsAsset) )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10682, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint in world %i with invalid constraint index %i", "constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset )", v20, v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10686, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAssetConstraint %i: world is NULL", "havokPhysicsWorld->world", v20) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10691, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAssetConstraint %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, v10) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10695, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, v10) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10696, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  v13 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data[v7];
  if ( *(_QWORD *)v13 )
    hkReferencedObject::addReference(*(hkReferencedObject **)v13);
  cInfo.m_constraintData.m_ptr = *(hkpConstraintData **)v13;
  cInfo.m_bodyA.m_serialAndIndex = *(_DWORD *)(v13 + 8);
  cInfo.m_bodyB.m_serialAndIndex = *(_DWORD *)(v13 + 12);
  cInfo.m_flags.m_storage = *(_WORD *)(v13 + 16);
  hkStringPtr::operator=(&cInfo.m_name, (const hkStringPtr *)(v13 + 24));
  cInfo.m_desiredConstraintId.m_value = *(_DWORD *)(v13 + 32);
  cInfo.m_constraintGroupId.m_value = *(_DWORD *)(v13 + 36);
  if ( (cInfo.m_bodyA.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10706, ASSERT_TYPE_ASSERT, "(cInfo.m_bodyA.isValid())", "%s\n\tHavokPhysics InstantiateAsset %s: constraint bodyA is invalid - implies we are trying to use the world as a child", "cInfo.m_bodyA.isValid()", physicsAsset->name) )
    __debugbreak();
  HavokPhysics_GroupRagdollConstraint(MutableWorld, physicsAsset, instanceRef, &cInfo);
  cInfo.m_bodyA = (hknpBodyId)HavokPhysicsInstanceManager_GetBodyId(&result, &MutableWorld->instanceManager, v10, cInfo.m_bodyA.m_serialAndIndex)->m_serialAndIndex;
  if ( (cInfo.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    cInfo.m_bodyB.m_serialAndIndex = 0xFFFFFF;
  else
    cInfo.m_bodyB = (hknpBodyId)HavokPhysicsInstanceManager_GetBodyId(&result, &MutableWorld->instanceManager, v10, cInfo.m_bodyB.m_serialAndIndex)->m_serialAndIndex;
  if ( deepCloneConstraintData )
  {
    v14 = hkpConstraintDataUtils::cloneIfCanHaveMotors(cInfo.m_constraintData.m_ptr);
    v15 = v14;
    if ( v14 )
      hkReferencedObject::addReference(v14);
    if ( cInfo.m_constraintData.m_ptr )
      hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
    cInfo.m_constraintData.m_ptr = v15;
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10727, ASSERT_TYPE_ASSERT, "(cInfo.m_constraintData.val())", "%s\n\tTrying to clone a non-motorized constraint - this could be caused by unexpected data, or by code", "cInfo.m_constraintData.val()") )
      __debugbreak();
    hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+47h+position.m_quad], xmm0
    vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rbp+47h+orientation.m_vec.m_quad], xmm1
  }
  m_value = HavokPhysics_CreateConstraint((hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *)&result, MutableWorld, &cInfo, &position, &orientation)->m_value;
  *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, m_value) + 64) = v10 | (v7 << 32);
  HavokPhysicsInstanceManager_AddConstraint(&MutableWorld->instanceManager, v10, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
  hkStringPtr::~hkStringPtr(&cInfo.m_name);
  if ( cInfo.m_constraintData.m_ptr )
    hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
  return 1;
}

/*
==============
HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId
==============
*/
void HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(const Physics_WorldId worldId, const HavokPhysicsWorld *havokPhysicsWorld, const Physics_RefSystem refSystem, hknpPhysicsSystemData::bodyCinfoWithAttachment *bodyCInfo)
{
  __int64 v5; 
  Physics_GravityType v8; 
  unsigned int v9; 
  const hknpMotionPropertiesLibrary *v10; 
  char v11; 
  unsigned int MotionPropertiesListIndexFromMotionPropertiesId; 
  __int64 v16; 
  hknpMotionPropertiesId result; 

  v5 = refSystem;
  if ( !havokPhysicsWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9376, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld)", (const char *)&queryFormat, "havokPhysicsWorld") )
    __debugbreak();
  v8 = s_physicsGravityTypes[v5];
  if ( (unsigned int)v8 <= Physics_GravityType_Item )
  {
    v9 = v8 + 1;
    v10 = havokPhysicsWorld->world->getMotionPropertiesLibrary(&havokPhysicsWorld->world->hknpWorldReader);
    _RDX = 112i64 * bodyCInfo->m_motionPropertiesId.m_value;
    _RAX = v10->m_motionProperties.m_objects.m_data;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vucomiss xmm0, dword ptr [rdx+rax+8]
    }
    if ( !v11 )
    {
      MotionPropertiesListIndexFromMotionPropertiesId = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(bodyCInfo->m_motionPropertiesId);
      if ( MotionPropertiesListIndexFromMotionPropertiesId >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size )
      {
        LODWORD(v16) = MotionPropertiesListIndexFromMotionPropertiesId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9386, ASSERT_TYPE_ASSERT, "(unsigned)( motionIndex ) < (unsigned)( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() )", "motionIndex doesn't index s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()\n\t%i not in [0, %i)", v16, s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size) )
          __debugbreak();
      }
      bodyCInfo->m_motionPropertiesId = (hknpMotionPropertiesId)HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v9, MotionPropertiesListIndexFromMotionPropertiesId)->m_value;
    }
  }
}

/*
==============
HavokPhysics_InstantiateDetailModel
==============
*/
__int64 HavokPhysics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  unsigned int Instance; 
  __int64 m_size; 
  int v23; 
  __int64 v25; 
  const char *v26; 
  scr_string_t String; 
  unsigned int v28; 
  const hknpShape *v31; 
  int v32; 
  hknpBodyId *v46; 
  hknpSphereShape *ConvexShape; 
  char v54; 
  hknpShape *v55; 
  hknpBodyId *p_bodyId; 
  __int64 result; 
  __int64 v67; 
  double v68; 
  double v69; 
  hknpBodyId v70; 
  char v71; 
  unsigned __int8 index[3]; 
  int v73; 
  unsigned int instanceId; 
  int v75; 
  hknpBodyId bodyId; 
  const hkQuaternionf *v77; 
  int v78; 
  const HavokPhysicsXModelLOD *v79; 
  const hkVector4f *v80; 
  __int64 v81; 
  hkVector4f v82; 
  hkVector4f v83; 
  hknpBodyId v84; 
  hknpBodyId v85; 
  __int64 v86; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v87; 
  hkVector4f center; 
  char dest[256]; 

  v86 = -2i64;
  __asm { vmovaps [rsp+310h+var_50], xmm6 }
  _RBX = position;
  v80 = position;
  v73 = ref;
  _RDI = detailModel;
  _R12 = orientation;
  v77 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v87);
  v87.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9827, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RDI )
  {
    LODWORD(v67) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9828, ASSERT_TYPE_ASSERT, "(detailModel)", "%s\n\tHavok Physics: Trying to Instantiate NULL Detail Model in world %i", "detailModel", v67) )
      __debugbreak();
  }
  if ( !_RDI->detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9829, ASSERT_TYPE_ASSERT, "(detailModel->detailCollision)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model %s with no detail physics data in world %i", "detailModel->detailCollision", _RDI->name, worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_93;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_93;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_93:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9830, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r12]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_94;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+4]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_94;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+8]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_94;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+0Ch]
    vmovss  [rsp+310h+var_2AC], xmm0
  }
  if ( (v70.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_94:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9831, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
      __debugbreak();
  }
  if ( !Physics_IsDetailWorld(worldId) && add )
  {
    LODWORD(v67) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9833, ASSERT_TYPE_ASSERT, "(Physics_IsDetailWorld( worldId ) || !add)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model in non detail world %i", "Physics_IsDetailWorld( worldId ) || !add", v67) )
      __debugbreak();
  }
  _R13 = HavokPhysics_GetMutableWorld(worldId);
  if ( !_R13->world )
  {
    LODWORD(v67) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9837, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v67) )
      __debugbreak();
  }
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(_RDI->detailCollision);
  v79 = HavokPhysicsXModelLODFromDetailCol;
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9842, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", "%s\n\tHavokPhysics InstantiateDetailModel %s: couldn't find havok XModel LOD", "havokPhysicsXModelLOD", _RDI->name) )
    __debugbreak();
  if ( HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9843, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD->m_shapes.getSize() > 0)", "%s\n\tHavokPhysics InstantiateDetailModel %s: no shapes in the collLod - is this model soft skinned or otherwise missing rigid geo?", "havokPhysicsXModelLOD->m_shapes.getSize() > 0", _RDI->name) )
    __debugbreak();
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&_R13->instanceManager);
  instanceId = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9848, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics InstantiateDetailModel %s: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID", _RDI->name) )
    __debugbreak();
  HavokPhysicsInstanceManager_SetDetailModel(&_R13->instanceManager, Instance, _RDI);
  v87.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
  v87.m_collisionFilterInfo = 1;
  m_size = HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  if ( (_DWORD)m_size != 1 || (v71 = 1, !allowSingleBodyAddToWorld) )
    v71 = 0;
  v23 = 0;
  v75 = 0;
  v81 = m_size;
  __asm { vmovss  xmm6, cs:__real@3d000000 }
  if ( m_size <= 0 )
  {
LABEL_63:
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rbp+210h+center.m_quad], xmm0
      vmovss  xmm1, dword ptr [rdi+28h]
      vmulss  xmm6, xmm1, xmm6
      vmovss  xmm0, dword ptr [r13+1C8h]
      vmaxss  xmm1, xmm0, xmm6
      vmovss  dword ptr [r13+1C8h], xmm1
    }
    ConvexShape = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, (int *)&instanceId);
    v81 = (__int64)ConvexShape;
    v77 = (const hkQuaternionf *)ConvexShape;
    if ( ConvexShape )
    {
      __asm { vmovaps xmm2, xmm6; radius }
      hknpSphereShape::hknpSphereShape(ConvexShape, &center, *(float *)&_XMM2);
      _R14 = v55;
    }
    else
    {
      v54 = 1;
      _R14 = NULL;
    }
    _R14->m_memSizeAndFlags = instanceId;
    __asm
    {
      vmovss  xmm1, dword ptr [r14+20h]
      vucomiss xmm1, xmm6
    }
    if ( !v54 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vcvtss2sd xmm1, xmm1, xmm1
        vmovsd  [rsp+310h+var_2D0], xmm0
        vmovsd  [rsp+310h+var_2D8], xmm1
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v68, v69) )
        __debugbreak();
    }
    hkReferencedObject::addReference(_R14);
    if ( v87.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v87.m_shape.m_ptr->hkReferencedObject);
    v87.m_shape.m_ptr = _R14;
    v87.m_flags.m_storage = forQueryOnly << 8;
    hkStringPtr::operator=(&v87.m_name, _RDI->name);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rbp+210h+var_230.m_position.m_quad], xmm0
      vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
      vmovups xmmword ptr [rbp+210h+var_230.m_orientation.m_vec.m_quad], xmm1
    }
    v87.m_motionType.m_storage = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups [rbp+210h+var_250], xmm0
    }
    _RAX = v80;
    __asm
    {
      vmovups xmm1, xmmword ptr [rax]
      vmovups [rbp+210h+var_260], xmm1
    }
    HavokPhysics_CreateRigidBody(&bodyId, worldId, _R13, NULL, v23, &v87, v73 | 0x40000000, &v82, (hkQuaternionf *)&v83, 0, tryStartDeactivated, 0);
    HavokPhysicsInstanceManager_AddBody(&_R13->instanceManager, Instance, bodyId);
    hkReferencedObject::removeReference(&v87.m_shape.m_ptr->hkReferencedObject);
    if ( add )
    {
      if ( !_R13->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
        __debugbreak();
      p_bodyId = &bodyId;
LABEL_81:
      ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))_R13->world->addBodies)(&_R13->world->hknpWorldWriter, p_bodyId, 1i64);
      HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &_R13->instanceManager, Instance, 0, 1);
    }
  }
  else
  {
    v25 = 0i64;
    v78 = forQueryOnly << 8;
    while ( 1 )
    {
      v26 = (const char *)((unsigned __int64)HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_data[v25].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9787, ASSERT_TYPE_ASSERT, "(boneName)", (const char *)&queryFormat, "boneName") )
        __debugbreak();
      Core_strcpy(dest, 0x100ui64, v26);
      I_strlwr(dest);
      String = SL_FindString(dest);
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9797, ASSERT_TYPE_ASSERT, "(scrName != ( static_cast< scr_string_t >( 0 ) ))", "%s\n\tCouldn't find script string for bone %s in model %s", "scrName != NULL_SCR_STRING", v26, _RDI->name) )
        __debugbreak();
      index[0] = 0;
      if ( XModelGetBoneIndex(_RDI, String, 0, index) )
      {
        v28 = index[0];
      }
      else
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9801, ASSERT_TYPE_ASSERT, "(success)", "%s\n\tCouldn't find bone %s in detail model %s.  Any chance this is a client bone?", "success", v26, _RDI->name) )
          __debugbreak();
        v28 = 255;
      }
      _RBX = 32i64 * v28;
      _R14 = _RDI->baseMat;
      v31 = v79->m_shapes.m_data[v25];
      if ( v31 )
        hkReferencedObject::addReference(v79->m_shapes.m_data[v25]);
      if ( v87.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v87.m_shape.m_ptr->hkReferencedObject);
      v87.m_shape.m_ptr = v31;
      v87.m_flags.m_storage = v78;
      v32 = v75;
      hkStringPtr::operator=(&v87.m_name, &v79->m_bodyNames.m_data[v75]);
      __asm
      {
        vmulss  xmm4, xmm6, dword ptr [rbx+r14+18h]
        vmulss  xmm3, xmm6, dword ptr [rbx+r14+14h]
        vmulss  xmm2, xmm6, dword ptr [rbx+r14+10h]
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, xmm2, 0
        vinsertps xmm1, xmm1, xmm3, 10h
        vinsertps xmm1, xmm1, xmm4, 20h ; ' '
        vmovups xmmword ptr [rbp+210h+var_230.m_position.m_quad], xmm1
        vmovss  xmm1, dword ptr [rbx+r14]
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+4], 10h
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+8], 20h ; ' '
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+0Ch], 30h ; '0'
        vmovups xmmword ptr [rbp+210h+var_230.m_orientation.m_vec.m_quad], xmm1
      }
      v87.m_motionType.m_storage = 0;
      _RAX = v77;
      __asm { vmovups xmm0, xmmword ptr [rax] }
      _RAX = v80;
      __asm { vmovups xmm1, xmmword ptr [rax] }
      if ( v71 )
      {
        __asm
        {
          vmovups [rbp+210h+var_260], xmm0
          vmovups [rbp+210h+var_250], xmm1
        }
        v46 = HavokPhysics_CreateRigidBody(&v84, worldId, _R13, NULL, v32, &v87, v73, &v83, (hkQuaternionf *)&v82, 0, tryStartDeactivated, 0);
      }
      else
      {
        __asm
        {
          vmovups [rbp+210h+var_250], xmm0
          vmovups [rbp+210h+var_260], xmm1
        }
        v46 = HavokPhysics_CreateRigidBody(&v85, worldId, _R13, NULL, v32, &v87, v73, &v82, (hkQuaternionf *)&v83, 0, tryStartDeactivated, 0);
      }
      v70.m_serialAndIndex = v46->m_serialAndIndex;
      Instance = instanceId;
      HavokPhysicsInstanceManager_AddBody(&_R13->instanceManager, instanceId, v70);
      if ( v71 )
        break;
      v23 = v32 + 1;
      v75 = v23;
      ++v25;
      HavokPhysicsXModelLODFromDetailCol = v79;
      if ( v25 >= v81 )
      {
        _R12 = v77;
        goto LABEL_63;
      }
    }
    if ( add )
    {
      if ( !_R13->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
        __debugbreak();
      p_bodyId = &v70;
      goto LABEL_81;
    }
  }
  if ( v87.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v87.m_localFrame.m_ptr);
  if ( v87.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v87.m_dragProperties.m_ptr);
  if ( v87.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v87.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v87.m_name);
  if ( v87.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v87.m_shape.m_ptr->hkReferencedObject);
  result = Instance;
  __asm { vmovaps xmm6, [rsp+310h+var_50] }
  return result;
}

/*
==============
HavokPhysics_InstantiateHingeConstraint
==============
*/
bool HavokPhysics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIndex, hkVector4f *pos, hkVector4f *dir, float friction, float minAngle, float maxAngle, float breakingThreshold, unsigned int *outConstraintId)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  const hkTransformf *v18; 
  hkMemoryRouter *Value; 
  hkpLimitedHingeConstraintData *v20; 
  hkReferencedObject *v21; 
  hkpLimitedHingeConstraintData *v22; 
  char v26; 
  hkMemoryRouter *v30; 
  hknpBreakableConstraintData *v31; 
  hkpLimitedHingeConstraintData *v32; 
  unsigned int m_value; 
  bool v35; 
  __int64 v37; 
  hkReferencedObject *v38; 
  unsigned int v39; 
  int v40; 
  __int16 v41; 
  hkStringPtr v42; 
  int v43; 
  int v44; 
  void *retaddr; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId; 
  hknpBodyId result; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10752, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Hinge constraint with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10753, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Hinge constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v37) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10757, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateHingeConstraint %i: world is NULL", "havokPhysicsWorld->world", v37) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, bodyIndex);
  m_serialAndIndex = result.m_serialAndIndex;
  if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10761, ASSERT_TYPE_ASSERT, "(childBodyId.isValid())", (const char *)&queryFormat, "childBodyId.isValid()") )
    __debugbreak();
  v18 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v20 = (hkpLimitedHingeConstraintData *)Value->m_heap->blockAlloc(Value->m_heap, 320i64);
  v21 = NULL;
  if ( v20 )
  {
    hkpLimitedHingeConstraintData::hkpLimitedHingeConstraintData(v20);
    _RDI = v22;
  }
  else
  {
    _RDI = NULL;
  }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10765, ASSERT_TYPE_ASSERT, "(ctDataHinge)", (const char *)&queryFormat, "ctDataHinge") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, [rsp+0C8h+minAngle]
    vmovss  dword ptr [rdi+0F8h], xmm0
    vmovss  xmm1, [rsp+0C8h+maxAngle]
    vmovss  dword ptr [rdi+0FCh], xmm1
  }
  hkpLimitedHingeConstraintData::setInWorldSpace(_RDI, v18, (const hkTransformf *)&g_vectorfConstants[32], pos, dir);
  __asm
  {
    vmovss  xmm0, [rsp+0C8h+friction]
    vmovss  dword ptr [rdi+0E8h], xmm0
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm6, [rsp+0C8h+breakingThreshold]
    vcomiss xmm6, xmm1
  }
  if ( !v26 )
  {
    __asm { vcomiss xmm6, cs:__real@7f7fffff }
    if ( v26 )
    {
      v30 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v30 )
        v30 = hkMemoryRouter::s_fallbackRouter;
      v31 = (hknpBreakableConstraintData *)v30->m_heap->blockAlloc(v30->m_heap, 48i64);
      if ( v31 )
      {
        hknpBreakableConstraintData::hknpBreakableConstraintData(v31, _RDI);
        _RDI = v32;
      }
      else
      {
        _RDI = NULL;
      }
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10775, ASSERT_TYPE_ASSERT, "(ctDataBreakableHinge)", (const char *)&queryFormat, "ctDataBreakableHinge") )
        __debugbreak();
      __asm { vmovaps xmm1, xmm6; value }
      hknpBreakableConstraintData::setBreakingThreshold((hknpBreakableConstraintData *)_RDI, *(float *)&_XMM1);
    }
  }
  v41 = 0;
  v42.m_stringAndFlag = NULL;
  v43 = 0x7FFFFFFF;
  v44 = 0x7FFFFFFF;
  if ( _RDI )
    v21 = _RDI;
  v38 = v21;
  v39 = m_serialAndIndex;
  v40 = 0xFFFFFF;
  hkStringPtr::operator=(&v42, "Code Created Hinge");
  MutableWorld->world->allocateConstraint(&MutableWorld->world->hknpWorldWriter, &constraintId, (const hknpConstraintCinfo *)&v38);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->addConstraint)(&MutableWorld->world->hknpWorldWriter, constraintId.m_value, 1i64);
  m_value = constraintId.m_value;
  if ( outConstraintId )
    *outConstraintId = constraintId.m_value;
  HavokPhysicsInstanceManager_AddConstraint(&MutableWorld->instanceManager, instanceId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
  hkStringPtr::~hkStringPtr(&v42);
  if ( v38 )
    hkReferencedObject::removeReference(v38);
  v35 = 1;
  __asm { vmovaps xmm6, [rsp+0C8h+var_48] }
  return v35;
}

/*
==============
HavokPhysics_InstantiateKeyframedBody
==============
*/
__int64 HavokPhysics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v16; 
  const char *v17; 
  HavokPhysicsWorld *MutableWorld; 
  unsigned int v23; 
  int v24; 
  int v25; 
  int m_size; 
  unsigned int Instance; 
  __int64 v28; 
  hknpBodyId *v35; 
  __int64 v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  hknpBodyId v45; 
  char *string[2]; 
  hkVector4f v47; 
  __int64 v48; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v49; 

  v48 = -2i64;
  string[0] = (char *)name;
  v45.m_serialAndIndex = ref;
  _R14 = position;
  v47.m_quad.m128_u64[0] = (unsigned __int64)position;
  _R15 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v49);
  v16 = -1i64;
  v49.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9093, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9094, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Shape in world %i", "shape", v37) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9095, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Name in world %i", (const char *)&stru_143C9A1A4, v37) )
      __debugbreak();
  }
  v17 = physicsMaterial;
  if ( !physicsMaterial )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9096, ASSERT_TYPE_ASSERT, "(physicsMaterial)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Physics Material in world %i", "physicsMaterial", v37) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_64:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9097, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+0Ch]
    vmovss  [rsp+1B0h+var_150], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
  {
LABEL_65:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9098, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v37) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9105, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Instantiate Keyframed Body %i: world is NULL", "havokPhysicsWorld->world", v37) )
      __debugbreak();
  }
  v23 = -1;
  do
    ++v16;
  while ( physicsMaterial[v16] );
  for ( ; v16; --v16 )
    v23 = (v23 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v17++ ^ (unsigned __int64)(unsigned __int8)v23];
  v24 = ~v23;
  v25 = 0;
  m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
  if ( m_size <= 0 )
    goto LABEL_36;
  while ( v24 != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v25] )
  {
    if ( ++v25 >= m_size )
      goto LABEL_36;
  }
  if ( v25 >= m_size )
  {
LABEL_36:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9120, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
      __debugbreak();
  }
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  v28 = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9125, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Keyframed Body: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  if ( shape )
    hkReferencedObject::addReference(&shape->hkReferencedObject);
  if ( v49.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v49.m_shape.m_ptr->hkReferencedObject);
  v49.m_shape.m_ptr = shape;
  v49.m_desiredBodyId.m_serialAndIndex = 0xFFFFFF;
  v49.m_motionId.m_value = 0x7FFFFFFF;
  v49.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
  v49.m_materialId.m_value = s_havokPhysicsMaterialLibrary.firstId.m_value + v25;
  v49.m_collisionFilterInfo = collisionFilterInfo;
  v49.m_flags.m_storage = forQueryOnly << 8;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rbp+0B0h+var_110.m_collisionLookAheadDistance], xmm0
  }
  hkStringPtr::operator=(&v49.m_name, string[0]);
  v49.m_motionType.m_storage = !Physics_IsQueryWorld(worldId);
  v49.m_userData = 0i64;
  v49.m_activationPriority = s_havokPhysicsDefaultActivationPriority;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+0B0h+var_110.m_position.m_quad], xmm0
    vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rbp+0B0h+var_110.m_orientation.m_vec.m_quad], xmm1
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+1B0h+string], xmm0
  }
  _RAX = v47.m_quad.m128_u64[0];
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups [rbp+0B0h+var_130], xmm1
  }
  v35 = HavokPhysics_CreateRigidBody(&v45, worldId, MutableWorld, NULL, 0, &v49, v45.m_serialAndIndex, &v47, (hkQuaternionf *)string, 0, tryStartDeactivated, 0);
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, v28, (hknpBodyId)v35->m_serialAndIndex);
  if ( add )
  {
    if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v28 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(MutableWorld, MutableWorld->instanceManager.buffer[v28].bodies.m_data, MutableWorld->instanceManager.buffer[v28].bodies.m_size, 0, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v28, 0, 1);
  }
  if ( v49.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v49.m_localFrame.m_ptr);
  if ( v49.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v49.m_dragProperties.m_ptr);
  if ( v49.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v49.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v49.m_name);
  if ( v49.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v49.m_shape.m_ptr->hkReferencedObject);
  return (unsigned int)v28;
}

/*
==============
HavokPhysics_InstantiateStaticBody
==============
*/
__int64 HavokPhysics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v16; 
  HavokPhysicsWorld *MutableWorld; 
  int v22; 
  const char *v23; 
  unsigned int v24; 
  int v25; 
  int m_size; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int Instance; 
  __int64 v29; 
  hknpBodyId *v36; 
  __int64 v38; 
  int worlda; 
  int worldb; 
  int worldc; 
  int worldd; 
  int worlde; 
  int worldf; 
  int worldg; 
  HavokPhysicsWorld *world; 
  hknpBodyId v47; 
  char *string[2]; 
  hkVector4f v49; 
  __int64 v50; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v51; 

  v50 = -2i64;
  string[0] = (char *)name;
  v47.m_serialAndIndex = ref;
  _RBX = position;
  v49.m_quad.m128_u64[0] = (unsigned __int64)position;
  _R12 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v51);
  v16 = -1i64;
  v51.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9196, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v38) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9197, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to Instantiate Static Body with NULL Shape in world %i", "shape", v38) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v38) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9198, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tHavok Physics: Trying to Instantiate Static Body with NULL Name in world %i", (const char *)&stru_143C9A1A4, v38) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worlda & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worldb & 0x7F800000) == 2139095040 )
    goto LABEL_64;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worldc & 0x7F800000) == 2139095040 )
  {
LABEL_64:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9199, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r12]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worldd & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+4]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worlde & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+8]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worldf & 0x7F800000) == 2139095040 )
    goto LABEL_65;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+0Ch]
    vmovss  dword ptr [rsp+1C0h+world], xmm0
  }
  if ( (worldg & 0x7F800000) == 2139095040 )
  {
LABEL_65:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9200, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  world = MutableWorld;
  if ( !MutableWorld->world )
  {
    LODWORD(v38) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9207, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Instantiate Static Body %i: world is NULL", "havokPhysicsWorld->world", v38) )
      __debugbreak();
  }
  v22 = 0;
  if ( physicsMaterial )
  {
    v23 = physicsMaterial;
    v24 = -1;
    do
      ++v16;
    while ( physicsMaterial[v16] );
    for ( ; v16; --v16 )
      v24 = (v24 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v23++ ^ (unsigned __int64)(unsigned __int8)v24];
    v25 = ~v24;
    m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
    if ( m_size <= 0 )
      goto LABEL_34;
    while ( v25 != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v22] )
    {
      if ( ++v22 >= m_size )
        goto LABEL_34;
    }
    if ( v22 >= m_size )
    {
LABEL_34:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9225, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
        __debugbreak();
    }
  }
  p_instanceManager = &MutableWorld->instanceManager;
  Instance = HavokPhysicsInstanceManager_AllocateInstance(p_instanceManager);
  v29 = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9231, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Static Body: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  if ( shape )
    hkReferencedObject::addReference(&shape->hkReferencedObject);
  if ( v51.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v51.m_shape.m_ptr->hkReferencedObject);
  v51.m_shape.m_ptr = shape;
  v51.m_desiredBodyId.m_serialAndIndex = 0xFFFFFF;
  v51.m_motionId.m_value = 0x7FFFFFFF;
  v51.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
  if ( physicsMaterial )
    v51.m_materialId.m_value = s_havokPhysicsMaterialLibrary.firstId.m_value + v22;
  v51.m_collisionFilterInfo = collisionFilterInfo;
  v51.m_flags.m_storage = forQueryOnly << 8;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rbp+0C0h+var_110.m_collisionLookAheadDistance], xmm0
  }
  hkStringPtr::operator=(&v51.m_name, string[0]);
  v51.m_motionType.m_storage = 0;
  v51.m_userData = 0i64;
  v51.m_activationPriority = s_havokPhysicsDefaultActivationPriority;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+0C0h+var_110.m_position.m_quad], xmm0
    vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+230h; __m128 const near * const g_vectorfConstants
    vmovups xmmword ptr [rbp+0C0h+var_110.m_orientation.m_vec.m_quad], xmm1
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmmword ptr [rbp+0C0h+string], xmm0
  }
  _RAX = v49.m_quad.m128_u64[0];
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovups [rbp+0C0h+var_130], xmm1
  }
  v36 = HavokPhysics_CreateRigidBody(&v47, worldId, world, NULL, 0, &v51, v47.m_serialAndIndex, &v49, (hkQuaternionf *)string, 0, tryStartDeactivated, 0);
  HavokPhysicsInstanceManager_AddBody(p_instanceManager, v29, (hknpBodyId)v36->m_serialAndIndex);
  if ( add )
  {
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v29 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(world, p_instanceManager->buffer[v29].bodies.m_data, p_instanceManager->buffer[v29].bodies.m_size, 0, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, p_instanceManager, v29, 0, 1);
  }
  if ( v51.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v51.m_localFrame.m_ptr);
  if ( v51.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v51.m_dragProperties.m_ptr);
  if ( v51.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v51.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v51.m_name);
  if ( v51.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v51.m_shape.m_ptr->hkReferencedObject);
  return (unsigned int)v29;
}

/*
==============
HavokPhysics_IsAssetBodyAnimationDriven
==============
*/
bool HavokPhysics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8541, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to check if physics asset is a ragdollwith invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8545, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsAssetBodyAnimationDriven %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysicsAsset->m_bodyDrivers.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8547, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_bodyDrivers.getSize())", "%s\n\tHavokPhysics IsAssetBodyAnimationDriven %s: bodyIdx out of range", "bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_bodyDrivers.getSize()", physicsAsset->name) )
    __debugbreak();
  return HavokPhysicsAsset->m_bodyDrivers.m_data[v2] == 1;
}

/*
==============
HavokPhysics_IsChildOfShape
==============
*/
char HavokPhysics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  unsigned __int8 m_storage; 
  int v5; 
  int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  const hknpShape *v10; 
  int v11; 
  unsigned int v12; 
  int v13; 
  const hknpShape *CollisionTileModelShape; 
  unsigned __int16 v15; 
  unsigned __int16 v16; 

  m_storage = possibleParent->m_type.m_storage;
  if ( m_storage != 12 )
  {
    if ( m_storage == 22 )
    {
      v12 = *(_DWORD *)&possibleParent[1].m_memSizeAndFlags;
      v13 = 0;
      if ( SLODWORD(possibleParent[1].m_convexRadius) > 0 )
      {
        while ( 1 )
        {
          CollisionTileModelShape = (const hknpShape *)StaticModels_GetCollisionTileModelShape((*(_WORD *)(*(_QWORD *)&possibleParent[1].m_flags.m_storage + 4i64 * (unsigned __int16)v13) & 0x4000) != 0, v12, *(_WORD *)(*(_QWORD *)&possibleParent[1].m_flags.m_storage + 4i64 * (unsigned __int16)v13) & 0x3FFF);
          if ( CollisionTileModelShape == possibleChild || HavokPhysics_IsChildOfShape(CollisionTileModelShape, possibleChild) )
            break;
          if ( ++v13 >= SLODWORD(possibleParent[1].m_convexRadius) )
            return 0;
        }
        return 1;
      }
    }
    return 0;
  }
  v5 = *(_DWORD *)&possibleParent[1].m_flags.m_storage;
  v6 = 0;
  v15 = 0;
  if ( v5 <= 0 )
    return 0;
  v7 = *(_QWORD *)&possibleParent[1].m_memSizeAndFlags;
  while ( 1 )
  {
    v8 = v15;
    if ( !*(_BYTE *)(112i64 * v15 + v7 + 92) )
      break;
    v15 = ++v6;
    if ( v6 >= v5 )
      return 0;
  }
  if ( v6 == -1 )
    return 0;
  while ( 1 )
  {
    v10 = *(const hknpShape **)(112i64 * v8 + v7 + 80);
    if ( v10 == possibleChild || HavokPhysics_IsChildOfShape(v10, possibleChild) )
      break;
    v11 = *(_DWORD *)&possibleParent[1].m_flags.m_storage;
    v16 = ++v6;
    if ( v6 < v11 )
    {
      v7 = *(_QWORD *)&possibleParent[1].m_memSizeAndFlags;
      while ( 1 )
      {
        v8 = v16;
        if ( !*(_BYTE *)(112i64 * v16 + v7 + 92) )
          break;
        v16 = ++v6;
        if ( v6 >= v11 )
          return 0;
      }
      if ( v6 != -1 )
        continue;
    }
    return 0;
  }
  return 1;
}

/*
==============
HavokPhysics_IsInstanceDeactivated
==============
*/
char HavokPhysics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v2; 
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int v5; 
  int NumRigidBodys; 
  const HavokPhysicsWorld *v7; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  __int64 v10; 
  __int64 v11; 
  hknpBodyId result; 

  v2 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11284, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to check if instance is deactvated with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v2 == -1 )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11285, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to check if instance is deactvated with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v10) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11290, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsInstanceDeactivated %i: world is NULL", "havokPhysicsWorld->world", v10) )
      __debugbreak();
  }
  v5 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v2);
  if ( NumRigidBodys <= 0 )
    return 1;
  while ( 1 )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
        __debugbreak();
    }
    if ( (_DWORD)v2 == -1 )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v10) )
        __debugbreak();
    }
    v7 = HavokPhysics_GetConstWorld(worldId);
    if ( !v7->world )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v10) )
        __debugbreak();
    }
    p_instanceManager = &v7->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v2 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v5 >= p_instanceManager->buffer[v2].bodies.m_size )
    {
      LODWORD(v11) = worldId;
      LODWORD(v10) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v10, v11) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v2, v5);
    if ( (*(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, result.m_serialAndIndex) + 68) & 8) != 0 )
      break;
    if ( (int)++v5 >= NumRigidBodys )
      return 1;
  }
  return 0;
}

/*
==============
HavokPhysics_IsInstanceInUse
==============
*/
bool HavokPhysics_IsInstanceInUse(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10889, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to test instance in use with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10890, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to test instance in use with invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  return HavokPhysicsInstanceManager_IsInstanceInUse(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_IsInstanceInWorld
==============
*/
bool HavokPhysics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11110, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to test if instance is in world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11111, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to test if instance is in world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11115, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsInstanceInWorld %i: world is NULL", "havokPhysicsWorld->world", v8) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_IsAddedToWorld(&ConstWorld->instanceManager, instanceId, checkPending);
}

/*
==============
HavokPhysics_IsMeshShape
==============
*/
bool HavokPhysics_IsMeshShape(const hknpShape *shape)
{
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 725, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  if ( shape->m_type.m_storage != 22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 726, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::USER_0)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::USER_0") )
    __debugbreak();
  return StaticModels_HavokShape_IsMeshShape(shape);
}

/*
==============
HavokPhysics_IsPhysicsAssetBodyDynamic
==============
*/
bool HavokPhysics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  unsigned int v7; 
  bool v8; 
  hkRefCountedProperties *v11; 
  hkReferencedObject *v12; 
  hkDiagonalizedMassProperties props; 

  v4 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8181, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to test if a physics asset's body is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8185, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsPhysicsAssetBodyDynamic %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8186, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics IsPhysicsAssetBodyDynamic %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8189, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.getSize())", (const char *)&queryFormat, "bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.getSize()") )
    __debugbreak();
  _RCX = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v4];
  if ( *(_BYTE *)(_RCX + 40) < 2u )
    return 0;
  if ( (*(_BYTE *)(_RCX + 8) & 5) != 0 )
    return 0;
  v7 = *(unsigned __int16 *)(_RCX + 136);
  if ( v7 == s_staticMotionPropertiesIdx + 5 )
    return 0;
  v8 = v7 == s_keyframedMotionPropertiesIdx + 5;
  if ( v7 == s_keyframedMotionPropertiesIdx + 5 )
    return 0;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+70h]
    vmovaps [rsp+0B8h+var_28], xmm6
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
  }
  if ( v7 < s_keyframedMotionPropertiesIdx + 5 )
  {
    v11 = *(hkRefCountedProperties **)(*(_QWORD *)_RCX + 48i64);
    v8 = v11 == NULL;
    if ( v11 )
    {
      v12 = hkRefCountedProperties::accessProperty(v11, 0xF100u);
      v8 = v12 == NULL;
      if ( v12 )
        hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v12[1], &props);
    }
    __asm { vmovss  xmm0, [rsp+0B8h+props.m_mass] }
  }
  __asm
  {
    vucomiss xmm0, xmm6
    vmovaps xmm6, [rsp+0B8h+var_28]
  }
  return !v8;
}

/*
==============
HavokPhysics_IsPhysicsAssetDynamic
==============
*/
bool HavokPhysics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  unsigned int m_value; 
  bool v6; 
  hkRefCountedProperties *m_ptr; 
  hkReferencedObject *v10; 
  hkDiagonalizedMassProperties props; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8127, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to test if a physics asset is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8131, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsPhysicsAssetDynamic %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8132, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics IsPhysicsAssetDynamic %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  _RCX = HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data;
  if ( _RCX->m_motionType.m_storage < 2u )
    return 0;
  if ( (_RCX->m_flags.m_storage & 5) != 0 )
    return 0;
  m_value = _RCX->m_motionPropertiesId.m_value;
  if ( m_value == s_staticMotionPropertiesIdx + 5 )
    return 0;
  v6 = m_value == s_keyframedMotionPropertiesIdx + 5;
  if ( m_value == s_keyframedMotionPropertiesIdx + 5 )
    return 0;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+70h]
    vmovaps [rsp+0A8h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
  }
  if ( m_value < s_keyframedMotionPropertiesIdx + 5 )
  {
    m_ptr = _RCX->m_shape.m_ptr->m_properties.m_ptr;
    v6 = m_ptr == NULL;
    if ( m_ptr )
    {
      v10 = hkRefCountedProperties::accessProperty(m_ptr, 0xF100u);
      v6 = v10 == NULL;
      if ( v10 )
        hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v10[1], &props);
    }
    __asm { vmovss  xmm0, [rsp+0A8h+props.m_mass] }
  }
  __asm
  {
    vucomiss xmm0, xmm6
    vmovaps xmm6, [rsp+0A8h+var_18]
  }
  return !v6;
}

/*
==============
HavokPhysics_IsRigidBodyActive
==============
*/
bool HavokPhysics_IsRigidBodyActive(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11733, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body active state with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11734, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body active state with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11739, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyActive %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (*(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 8) != 0;
}

/*
==============
HavokPhysics_IsRigidBodyDynamic
==============
*/
bool HavokPhysics_IsRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11402, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11403, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11408, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 6) == 2;
}

/*
==============
HavokPhysics_IsRigidBodyKeyframed
==============
*/
bool HavokPhysics_IsRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11379, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11380, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Keyframed with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11385, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 4) != 0;
}

/*
==============
HavokPhysics_IsRigidBodyStatic
==============
*/
bool HavokPhysics_IsRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11335, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11336, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11341, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyStatic %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return *(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 1;
}

/*
==============
HavokPhysics_IsRigidBodyValid
==============
*/
bool HavokPhysics_IsRigidBodyValid(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11316, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is valid with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11320, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyValid %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return ((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->isBodyValid)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) != 0;
}

/*
==============
HavokPhysics_IsShapeCacheDisabled
==============
*/
_BOOL8 HavokPhysics_IsShapeCacheDisabled(unsigned int threadId)
{
  __int64 v1; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15863, ASSERT_TYPE_ASSERT, "(threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS)", (const char *)&queryFormat, "threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS") )
    __debugbreak();
  return s_havokPhysicsShapeCachesDisabled[v1];
}

/*
==============
HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled
==============
*/
bool HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled(const Physics_WorldId worldId)
{
  const dvar_t *v2; 

  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x100) )
  {
    if ( Physics_IsAuthoritativeWorld(worldId) )
    {
      v2 = DVARBOOL_physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix;
      if ( !DVARBOOL_physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix") )
        __debugbreak();
LABEL_6:
      Dvar_CheckFrontendServerThread(v2);
      return v2->current.enabled;
    }
    if ( Physics_IsPredictiveWorld(worldId) )
    {
      v2 = DVARBOOL_physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix;
      if ( !DVARBOOL_physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix") )
        __debugbreak();
      goto LABEL_6;
    }
  }
  return 0;
}

/*
==============
HavokPhysics_IsWorldMultithreaded
==============
*/
_BOOL8 HavokPhysics_IsWorldMultithreaded(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3785, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to test if a world is multithreaded with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetConstWorld(worldId)->isMultithreaded;
}

/*
==============
HavokPhysics_KeyframeInstanceTo
==============
*/
__int64 HavokPhysics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  Physics_MovementType v11; 
  __int64 v12; 
  int NumRigidBodys; 
  unsigned int v18; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  hkTransformf *v25; 
  hkTransformf *p_r; 
  Physics_MovementType v27; 
  __int64 v29; 
  float fmt; 
  __int64 v33; 
  __int64 v34; 
  __int64 v35; 
  float v36; 
  __int64 v37; 
  hknpBodyId result; 
  float zero; 
  HavokPhysicsWorld *MutableWorld; 
  hkQuaternionf hkOrientationa; 
  hkTransformf r; 
  hkTransformf aTb; 
  hkTransformf bTc; 
  hkTransformf v45; 

  v11 = Physics_MovementType_NoMove;
  v12 = instanceId;
  _RBX = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12625, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v12 == -1 )
  {
    LODWORD(v34) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12626, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Keyframe Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v34) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v34) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12630, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Keyframe Instance %i: world is NULL", "havokPhysicsWorld->world", v34) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&r.m_rotation, hkOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rsp+1E8h+var_148], xmm0
  }
  if ( !hkTransformf::isOk(&r) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12634, ASSERT_TYPE_ASSERT, "(body0NewTransform.isOk())", (const char *)&queryFormat, "body0NewTransform.isOk()") )
    __debugbreak();
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v12);
  v18 = 0;
  if ( NumRigidBodys <= 0 )
    return 0i64;
  __asm
  {
    vmovaps [rsp+1E8h+var_48], xmm6
    vmovss  xmm6, cs:__real@3a83126f
    vmovaps [rsp+1E8h+var_58], xmm7
    vmovss  xmm7, [rsp+1E8h+stepTimeOverride]
    vmovaps [rsp+1E8h+var_68], xmm8
    vmovss  xmm8, [rsp+1E8h+velocityScale]
  }
  do
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v34) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v34) )
        __debugbreak();
    }
    if ( (_DWORD)v12 == -1 )
    {
      LODWORD(v34) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v34) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v34) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v34) )
        __debugbreak();
    }
    p_instanceManager = &ConstWorld->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v12 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v18 >= p_instanceManager->buffer[v12].bodies.m_size )
    {
      LODWORD(v35) = worldId;
      LODWORD(v34) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v34, v35) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v12, v18);
    m_serialAndIndex = result.m_serialAndIndex;
    if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v37) = worldId;
      LODWORD(v35) = v12;
      LODWORD(v34) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12645, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v34, v35, v37) )
        __debugbreak();
    }
    v25 = (hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex);
    if ( !hkTransformf::isOk(v25) )
    {
      LODWORD(v33) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12649, ASSERT_TYPE_ASSERT, "( ( oldTransform.isOk() ) )", "( bodyIt ) = %i", v33) )
        __debugbreak();
    }
    if ( v18 )
    {
      hkTransformf::setMul(&bTc, &aTb, v25);
      hkTransformf::setMul(&v45, &r, &bTc);
      p_r = &v45;
    }
    else
    {
      __asm { vmovss  [rsp+1E8h+zero], xmm6 }
      if ( hkTransformf::isApproximatelyEqual(v25, &r, &zero) )
        break;
      hkTransformf::setInverse(&aTb, v25);
      p_r = &r;
    }
    hkQuaternionf::setAndNormalize(&hkOrientationa, &p_r->m_rotation);
    __asm
    {
      vmovss  [rsp+1E8h+var_1B0], xmm7
      vmovss  dword ptr [rsp+1E8h+fmt], xmm8
    }
    v27 = HavokPhysics_KeyframeRigidBodyTo(worldId, (hknpBodyId)m_serialAndIndex, &p_r->m_translation, &hkOrientationa, fmt, canWarp, updateBroadphaseIfWarping, v36);
    if ( v11 == Physics_MovementType_NoMove || v27 == Physics_MovementType_Warped )
      v11 = v27;
    ++v18;
  }
  while ( (int)v18 < NumRigidBodys );
  __asm { vmovaps xmm7, [rsp+1E8h+var_58] }
  v29 = (unsigned int)v11;
  __asm
  {
    vmovaps xmm6, [rsp+1E8h+var_48]
    vmovaps xmm8, [rsp+1E8h+var_68]
  }
  return v29;
}

/*
==============
HavokPhysics_KeyframeRigidBodyTo
==============
*/
Physics_MovementType HavokPhysics_KeyframeRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  hknpWorld *world; 
  int v57; 
  int v58; 
  int v61; 
  __int64 v64; 
  Physics_MovementType result; 
  hkVector4f *angularVelocityOut; 
  hkVector4f v75; 
  hkQuaternionf v76; 
  char v78; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
  }
  _R14 = (hkQuaternionf *)hkOrientation;
  _R15 = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12437, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12438, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  __asm { vmovss  xmm1, cs:__real@3a83126f; epsilon }
  if ( !hkQuaternionf::isOk(_R14, *(const float *)&_XMM1) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12446, ASSERT_TYPE_ASSERT, "(hkOrientation.isOk())", (const char *)&queryFormat, "hkOrientation.isOk()") )
    __debugbreak();
  _RSI = HavokPhysics_GetMutableWorld(worldId);
  if ( !_RSI->world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12450, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics KeyframeRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", angularVelocityOut) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 363, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", angularVelocityOut) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 364, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 368, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", angularVelocityOut) )
      __debugbreak();
  }
  _RDX = &world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_transform.m_rotation;
  __asm { vmovups xmm11, xmmword ptr [rdx+30h] }
  hkQuaternionf::set(&v76, _RDX);
  __asm
  {
    vmovups xmm6, xmmword ptr [rsp+148h+var_D8.m_vec.m_quad]
    vmovups xmm7, xmmword ptr [r14]
    vmovups xmm9, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
    vmovups xmm12, xmmword ptr [r15]
    vdpps   xmm5, xmm7, xmm6, 0FFh
    vshufps xmm0, xmm6, xmm6, 0C9h ; ''
    vmulps  xmm3, xmm0, xmm7
    vbroadcastss xmm0, dword ptr [r14+0Ch]
    vshufps xmm1, xmm7, xmm7, 0C9h ; ''
    vmulps  xmm2, xmm1, xmm6
    vsubps  xmm4, xmm2, xmm3
    vmulps  xmm2, xmm0, xmm6
    vshufps xmm1, xmm4, xmm4, 0C9h ; ''
    vsubps  xmm3, xmm1, xmm2
    vshufps xmm0, xmm6, xmm6, 0FFh
    vmovss  xmm6, [rsp+148h+stepTimeOverride]
    vmulps  xmm2, xmm0, xmm7
    vaddps  xmm1, xmm3, xmm2
    vblendps xmm4, xmm1, xmm5, 8
    vpxor   xmm1, xmm1, xmm1
    vsubps  xmm0, xmm11, xmm12
    vandnps xmm0, xmm9, xmm0
    vcmpleps xmm5, xmm0, cs:__xmm@38d1b71738d1b71738d1b71738d1b717
    vpcmpeqd xmm0, xmm1, xmm1
    vxorps  xmm10, xmm10, xmm10
    vblendps xmm3, xmm10, xmm0, 7
    vsubps  xmm0, xmm4, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
    vandnps xmm1, xmm9, xmm0
    vcmpleps xmm2, xmm1, cs:__xmm@38d1b71738d1b71738d1b71738d1b717
    vpand   xmm0, xmm2, xmm3
    vptest  xmm0, xmm3
  }
  v57 = 0;
  v58 = 0;
  if ( _CF )
    v57 = 1;
  __asm
  {
    vpand   xmm0, xmm5, xmm3
    vptest  xmm0, xmm3
    vxorps  xmm7, xmm7, xmm7
  }
  if ( _CF )
    v58 = 1;
  v61 = v58 & v57 & 1;
  __asm { vcomiss xmm6, xmm7 }
  if ( !v61 )
    __asm { vmovss  xmm6, dword ptr [rsi+84h] }
  __asm { vmovaps [rsp+148h+var_68], xmm8 }
  if ( !v61 )
  {
    __asm
    {
      vmovss  xmm8, [rsp+148h+velocityScale]
      vucomiss xmm8, xmm7
    }
  }
  v64 = (__int64)&_RSI->world->hknpWorldWriter;
  __asm { vmovups xmmword ptr [rsp+148h+var_E8.m_quad], xmm10 }
  (*(void (__fastcall **)(__int64, _QWORD, hkVector4f *, _QWORD))(*(_QWORD *)v64 + 160i64))(v64, bodyId.m_serialAndIndex, &v75, 0i64);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, hkVector4f *, _QWORD))_RSI->world->setBodyAngularVelocity)(&_RSI->world->hknpWorldWriter, bodyId.m_serialAndIndex, &v75, 0i64);
  result = Physics_MovementType_NoMove;
  __asm { vmovaps xmm8, [rsp+148h+var_68] }
  _R11 = &v78;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
  return result;
}

/*
==============
HavokPhysics_KeyframeRigidBodyToFast
==============
*/
__int64 HavokPhysics_KeyframeRigidBodyToFast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  __int64 v19; 
  __int64 v20; 
  hknpWorld *world; 
  __int64 result; 
  const hknpWorldReader *v77; 
  float fmt; 
  hkVector4f *angularVelocityOut; 
  hkVector4f linearVelocityOut; 
  hkQuaternionf v115; 
  hkVector4f angVelocityWorld; 
  char v117; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
  }
  _RBP = hkOrientation;
  _R14 = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12539, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12540, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  _RSI = HavokPhysics_GetMutableWorld(worldId);
  if ( !_RSI->world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12544, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics KeyframeRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", angularVelocityOut) )
      __debugbreak();
  }
  v19 = bodyId.m_serialAndIndex & 0xFFFFFF;
  v20 = v19;
  _RDX = &_RSI->world->m_bodyManager.m_bodies.m_objects.m_data[v19].m_pod.m_transform.m_rotation;
  __asm { vmovups xmm9, xmmword ptr [rdx+30h] }
  hkQuaternionf::set(&v115, _RDX);
  __asm
  {
    vmovups xmm6, xmmword ptr [rsp+108h+var_A8.m_vec.m_quad]
    vmovups xmm7, xmmword ptr [rbp+0]
    vmovups xmm10, xmmword ptr [r14]
    vdpps   xmm5, xmm7, xmm6, 0FFh
    vshufps xmm0, xmm6, xmm6, 0C9h ; ''
    vmulps  xmm3, xmm0, xmm7
    vbroadcastss xmm0, dword ptr [rbp+0Ch]
    vshufps xmm1, xmm7, xmm7, 0C9h ; ''
    vmulps  xmm2, xmm1, xmm6
    vsubps  xmm4, xmm2, xmm3
    vmulps  xmm2, xmm0, xmm6
    vshufps xmm1, xmm4, xmm4, 0C9h ; ''
    vsubps  xmm3, xmm1, xmm2
    vshufps xmm0, xmm6, xmm6, 0FFh
    vmovups xmm6, cs:__xmm@38d1b71738d1b71738d1b71738d1b717
    vmulps  xmm2, xmm0, xmm7
    vmovups xmm7, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
    vaddps  xmm1, xmm3, xmm2
    vblendps xmm8, xmm1, xmm5, 8
    vmovups xmm5, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
    vsubps  xmm0, xmm9, xmm10
    vandnps xmm0, xmm7, xmm0
    vcmpleps xmm3, xmm0, xmm6
    vxorps  xmm0, xmm0, xmm0
    vpxor   xmm1, xmm1, xmm1
    vpcmpeqd xmm2, xmm1, xmm1
    vblendps xmm4, xmm0, xmm2, 7
    vpand   xmm0, xmm3, xmm4
    vptest  xmm0, xmm4
  }
  if ( _CF )
  {
    __asm
    {
      vsubps  xmm0, xmm8, xmm5
      vandnps xmm1, xmm7, xmm0
      vcmpleps xmm2, xmm1, xmm6
      vpand   xmm0, xmm2, xmm4
      vptest  xmm0, xmm4
    }
    if ( _CF )
      goto LABEL_26;
  }
  __asm
  {
    vmovss  xmm6, [rsp+108h+velocityScale]
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm6, xmm0
  }
  if ( _ZF )
  {
LABEL_26:
    _RDX = (unsigned __int64)&_RSI->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)_RSI->world->m_bodyManager.m_bodies.m_objects.m_data[v20].m_pod.m_motionId.m_value];
    result = 0i64;
    __asm
    {
      vblendps xmm0, xmm5, xmmword ptr [rdx+40h], 8
      vmovups xmmword ptr [rdx+40h], xmm0
      vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
      vblendps xmm0, xmm1, xmmword ptr [rdx+50h], 8
      vmovups xmmword ptr [rdx+50h], xmm0
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm5, [rsp+108h+stepTimeOverride]
      vcomiss xmm5, xmm0
    }
    if ( _CF | _ZF )
      __asm { vmovss  xmm5, dword ptr [rsi+84h] }
    world = _RSI->world;
    if ( !canWarp )
      goto LABEL_18;
    __asm
    {
      vsubps  xmm0, xmm10, xmm9
      vandnps xmm4, xmm7, xmm0
      vmovups xmmword ptr [rsp+108h+var_B8.m_quad], xmm0
      vpshufd xmm1, xmm4, 55h ; 'U'
      vpshufd xmm0, xmm4, 0
      vpmaxsd xmm2, xmm0, xmm1
      vpshufd xmm1, xmm4, 0AAh ; ''
      vpmaxsd xmm3, xmm1, xmm2
      vcmpleps xmm0, xmm3, xmm4
      vmovmskps eax, xmm0
    }
    _RAX = hkVector4Comparison_maskToLastIndexElseZero[_EAX & 7];
    __asm
    {
      vmovss  xmm1, dword ptr [rsp+rax*4+108h+var_B8.m_quad]
      vandnps xmm3, xmm7, xmm1
      vdivss  xmm1, xmm5, xmm6
      vdivss  xmm0, xmm3, xmm1
    }
    _RCX = world->m_bodyManager.m_bodies.m_objects.m_data[v20].m_pod.m_motionId.m_value;
    _RAX = world->m_motionManager.m_motions.m_objects.m_data;
    _CF = __CFSHL__(_RCX, 7);
    _RCX <<= 7;
    __asm { vcomiss xmm0, dword ptr [rcx+rax+4Ch] }
    if ( _CF || _RCX == 0 )
    {
LABEL_18:
      v77 = &world->hknpWorldReader;
      __asm { vdivss  xmm0, xmm6, xmm5 }
      if ( !world )
        v77 = NULL;
      __asm { vmovss  dword ptr [rsp+108h+fmt], xmm0 }
      hknpKeyFrameUtil::calcRequiredVelocity(v77, bodyId, _R14, _RBP, fmt, &linearVelocityOut, &angVelocityWorld);
      __asm
      {
        vmovups xmm6, xmmword ptr [rsp+108h+var_B8.m_quad]
        vdpps   xmm2, xmm6, xmm6, 7Fh
      }
      _RCX = &_RSI->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)_RSI->world->m_bodyManager.m_bodies.m_objects.m_data[v19].m_pod.m_motionId.m_value].m_pod;
      __asm
      {
        vmovups xmm7, xmmword ptr [rcx+40h]
        vshufps xmm8, xmm7, xmm7, 0FFh
        vmulps  xmm0, xmm8, xmm8
        vcmpleps xmm1, xmm2, xmm0
        vmovmskps eax, xmm1
      }
      if ( _EAX )
      {
        __asm
        {
          vblendps xmm0, xmm6, xmm7, 8
          vmovups xmmword ptr [rcx+40h], xmm0
        }
        hknpMotion::setAngularVelocity(_RCX, &angVelocityWorld);
        result = 1i64;
      }
      else
      {
        __asm
        {
          vcmpordps xmm0, xmm2, xmm2
          vmovmskps eax, xmm0
        }
        if ( _EAX )
        {
          __asm
          {
            vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
            vrsqrtps xmm4, xmm2
            vmulps  xmm0, xmm4, xmm2
            vmulps  xmm2, xmm0, xmm4
            vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
            vsubps  xmm3, xmm1, xmm2
            vmulps  xmm5, xmm3, xmm0
            vcmpordps xmm1, xmm5, xmm5
            vmovmskps eax, xmm1
          }
          if ( _EAX )
          {
            __asm
            {
              vmulps  xmm0, xmm5, xmm8
              vmulps  xmm1, xmm0, xmm6
              vblendps xmm2, xmm1, xmm7, 8
              vmovups xmmword ptr [rcx+40h], xmm2
            }
          }
        }
        hknpMotion::setAngularVelocity(_RCX, &angVelocityWorld);
        result = 1i64;
      }
    }
    else
    {
      result = 3i64;
    }
  }
  _R11 = &v117;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
  return result;
}

/*
==============
HavokPhysics_LeftBroadphase
==============
*/
void HavokPhysics_LeftBroadphase(const hknpEventHandlerInput *input, const hknpEvent *event)
{
  __int64 v7; 
  hknpWorldReader *v9; 
  const dvar_t *v12; 
  __int64 v13; 
  __int64 v20; 
  unsigned int v21; 
  Physics_RefSystem RefSystem; 
  hknpWorld **p_world; 
  Physics_RefSystem v24; 
  Physics_WorldId v25; 
  char *MapEntsShapeName; 
  gentity_s *v27; 
  unsigned __int8 modelType; 
  const TriggerModel *TriggerModel; 
  unsigned __int16 model; 
  XModel *v31; 
  gentity_s *v32; 
  GWeaponMap *Instance; 
  const Weapon *Weapon; 
  int v37; 
  hknpConstraintManager *m_constraintManager; 
  hknpThreadSafeObjectPoolElement<hknpConstraint> *m_data; 
  unsigned int v43; 
  __int64 v45; 
  hknpWorldWriter *v46; 
  int v49; 
  unsigned __int8 RefSubSystem; 
  double v52; 
  double v53; 
  double v54; 
  __int128 v55; 
  char string[256]; 
  char output[512]; 
  void *retaddr; 

  _R11 = &retaddr;
  v7 = *(unsigned int *)&event[1].m_filterBits;
  v9 = &input->m_world->hknpWorldReader;
  __asm
  {
    vmovaps xmmword ptr [r11-38h], xmm6
    vmovaps xmmword ptr [r11-48h], xmm7
    vmovaps xmmword ptr [r11-58h], xmm8
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, __int64))v9->getBody)(v9, v7);
  __asm { vmovss  xmm1, cs:__real@42000000 }
  v12 = DVARBOOL_physics_disableSpammyWarnings;
  v13 = _RAX;
  __asm
  {
    vmovups xmm2, xmmword ptr [rax+30h]
    vshufps xmm0, xmm2, xmm2, 55h ; 'U'
    vmulss  xmm6, xmm2, xmm1
    vshufps xmm2, xmm2, xmm2, 0AAh ; ''
    vmulss  xmm8, xmm2, xmm1
    vmulss  xmm7, xmm0, xmm1
  }
  if ( !DVARBOOL_physics_disableSpammyWarnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_disableSpammyWarnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  if ( !v12->current.enabled )
  {
    v21 = *(_DWORD *)(v13 + 160);
    RefSystem = Physics_GetRefSystem(v21);
    p_world = &g_havokPhysicsWorlds[0].world;
    v24 = RefSystem;
    v25 = PHYSICS_WORLD_ID_FIRST;
    while ( *p_world != input->m_world )
    {
      ++v25;
      p_world += 480;
      if ( (unsigned int)v25 >= PHYSICS_WORLD_ID_COUNT )
      {
        v25 = PHYSICS_WORLD_ID_INVALID;
        break;
      }
    }
    Physics_ConvertRefSystemToString(v21, v25, string, 256);
    MapEntsShapeName = (char *)&queryFormat.fmt + 3;
    if ( v24 == Physics_RefSystem_GEntities )
    {
      v27 = &g_entities[Physics_GetRefId(v21)];
      modelType = v27->r.modelType;
      if ( modelType == 4 )
      {
        TriggerModel = CM_GetTriggerModel(v27->s.index.brushModel);
        MapEntsShapeName = (char *)WorldCollision_GetMapEntsShapeName(TriggerModel->physicsShapeOverrideIdx);
      }
      else
      {
        model = v27->model;
        if ( model )
        {
          v31 = G_Utils_GetModel(model);
          if ( v31 )
            MapEntsShapeName = (char *)v31->name;
        }
        else if ( modelType == 5 )
        {
          MapEntsShapeName = (char *)WorldCollision_GetMapEntsShapeName(cm.mapEnts->cmodels[v27->s.index.brushModel].physicsShapeOverrideIdx);
        }
      }
    }
    else if ( v24 == Physics_RefSystem_GItems )
    {
      v32 = &g_entities[Physics_GetRefId(v21)];
      if ( v32->s.weaponHandle.m_mapEntryId )
      {
        Instance = GWeaponMap::GetInstance();
        if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        Weapon = BgWeaponMap::GetWeapon(Instance, v32->s.weaponHandle);
        BG_GetWeaponName(Weapon, output, 0x200u);
        MapEntsShapeName = output;
      }
      else
      {
        MapEntsShapeName = "<null weapon>";
      }
    }
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+3C8h+var_388], xmm0
      vcvtss2sd xmm1, xmm7, xmm7
      vmovsd  [rsp+3C8h+var_390], xmm1
      vcvtss2sd xmm2, xmm6, xmm6
      vmovsd  [rsp+3C8h+var_398], xmm2
    }
    Com_PrintWarning(1, "Physics body (ref:%x %s:%s) left the broadphase (fallen out of the world) - %s (%2.f, %.2f, %.2f).  Turn this message off with dvar physics_disableSpammyWarnings\n", v21, string, MapEntsShapeName, (const char *)((unsigned __int64)input->m_world->m_bodyManager.m_bodyNames.m_data[*(_DWORD *)&event[1].m_filterBits & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), v52, v53, v54);
  }
  v37 = *(_DWORD *)&event[1].m_filterBits;
  __asm
  {
    vmovaps xmm8, [rsp+3C8h+var_58]
    vmovaps xmm7, [rsp+3C8h+var_48]
  }
  m_constraintManager = input->m_world->m_constraintManager;
  __asm { vmovaps xmm6, [rsp+3C8h+var_38] }
  m_data = m_constraintManager->m_constraints.m_objects.m_data;
  if ( (v37 & 0xFFFFFFu) >= m_constraintManager->m_bodyIdToConstraintIdsMap.m_bodyIndexToFirstAttachedConstraintId.m_size )
    goto LABEL_34;
  v43 = m_constraintManager->m_bodyIdToConstraintIdsMap.m_bodyIndexToFirstAttachedConstraintId.m_data[v37 & 0xFFFFFF].m_serialAndIndex & 0xFFFFFF;
  if ( v43 == 0xFFFFFF )
    goto LABEL_34;
  while ( 1 )
  {
    v20 = 9i64 * v43;
    if ( m_data[v43].m_pod.m_bodyIdA.m_serialAndIndex == v37 || m_data[v43].m_pod.m_bodyIdB.m_serialAndIndex == v37 )
      break;
    v20 = (__int64)&m_constraintManager->m_bodyIdToConstraintIdsMap.m_constraintLinks.m_data[v43];
    if ( (m_data[v43].m_pod.m_bodyIdA.m_serialAndIndex & 0xFFFFFF) != (v37 & 0xFFFFFF) )
      v20 += 4i64;
    v43 = *(_DWORD *)v20;
    if ( *(_DWORD *)v20 == 0x7FFFFFFF )
      goto LABEL_34;
  }
  if ( v43 == 0x7FFFFFFF )
  {
LABEL_34:
    _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD, __int64, hknpThreadSafeObjectPoolElement<hknpConstraint> *))input->m_world->getBodyTransform)(&input->m_world->hknpWorldReader, *(unsigned int *)&event[1].m_filterBits, v20, m_data);
    v45 = *(unsigned int *)&event[1].m_filterBits;
    v46 = &input->m_world->hknpWorldWriter;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax+30h]
      vmulps  xmm0, xmm0, cs:__xmm@3f7eb8523f7eb8523f7eb8523f7eb852
      vmovups [rsp+3C8h+var_378], xmm0
    }
    ((void (__fastcall *)(hknpWorldWriter *, __int64, __int128 *, _QWORD))v46->setBodyPosition)(v46, v45, &v55, 0i64);
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const __m128 *, const __m128 *, _DWORD))input->m_world->setBodyVelocity)(&input->m_world->hknpWorldWriter, *(unsigned int *)&event[1].m_filterBits, &g_vectorfConstants[5], &g_vectorfConstants[5], 0);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))input->m_world->setBodyMotionType)(&input->m_world->hknpWorldWriter, *(unsigned int *)&event[1].m_filterBits, 1i64);
  v49 = *(_DWORD *)(v13 + 160);
  if ( Physics_GetRefSystem(v49) == Physics_RefSystem_Ragdoll )
  {
    RefSubSystem = Physics_GetRefSubSystem(v49);
    __asm { vxorps  xmm1, xmm1, xmm1; blendOutTime }
    Ragdoll_DisablePoseController(RefSubSystem + 1, *(float *)&_XMM1);
  }
}

/*
==============
HavokPhysics_Load
==============
*/
void HavokPhysics_Load(SaveGame *save)
{
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  if ( !g_havokPhysicsWorlds[0].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5249, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld main is NULL", "world->world") )
    __debugbreak();
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  HavokPhysicsInstanceManager_Clear(&g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysicsInstanceManager_Load(save, &g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysics_LoadSnapshot(save, PHYSICS_WORLD_ID_FIRST);
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  if ( !g_havokPhysicsWorlds[1].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5259, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld detail is NULL", "world->world") )
    __debugbreak();
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  HavokPhysicsInstanceManager_Clear(&g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysicsInstanceManager_Load(save, &g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysics_LoadSnapshot(save, PHYSICS_WORLD_ID_SERVER_DETAIL);
}

/*
==============
HavokPhysics_LoadInstance
==============
*/
void HavokPhysics_LoadInstance(SaveGame *save, Physics_WorldId worldId, unsigned int instanceId, HavokPhysics_SnapshotFixup *snapshotFixup)
{
  const char *CString; 
  const char *v22; 
  const PhysicsAsset *AssetByName; 
  const PhysicsAsset *v24; 
  const char *v25; 
  const char *v26; 
  const PhysicsAsset *v27; 
  const char *v28; 
  XModel *physicsLibrary; 
  XAssetHeader v30; 
  const char *v31; 
  const XModel *model; 
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *v34; 
  unsigned int v35; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  MemoryFile *v37; 
  int v38; 
  __int64 v39; 
  __int64 v40; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> > *p_bodyData; 
  unsigned __int64 m_serialAndIndex; 
  const char *v46; 
  hknpShape *v48; 
  hkReferencedObject *v53; 
  hkReferencedObject *v54; 
  hkReferencedObject *v55; 
  hknpShape *v56; 
  hkMemoryRouter *Value; 
  hknpMaskedShape *v58; 
  __int64 v59; 
  __int64 v60; 
  __int64 v61; 
  int v62; 
  int v63; 
  __int64 v64; 
  unsigned __int16 v65; 
  unsigned int v66; 
  int v67; 
  __int64 v68; 
  char v70; 
  char v71; 
  hknpShape *MapEntsShape; 
  hknpSphereShape *v74; 
  hknpShape *v75; 
  hknpShape *v76; 
  unsigned int v77; 
  const hknpShape *m_ptr; 
  unsigned int v79; 
  unsigned __int16 ShapeTag; 
  hkMemoryAllocator *v81; 
  int v82; 
  int v83; 
  int v85; 
  hkMemoryRouter *v91; 
  hknpCompoundShape *v92; 
  hknpShape *v93; 
  hkMemoryAllocator *v94; 
  __int64 v95; 
  hkReferencedObject **p_m_shape; 
  hknpShape *v97; 
  hknpShape *ShapeData_PlayerClip; 
  bool v126; 
  unsigned __int16 m_refCount; 
  hkMemoryAllocator *v128; 
  __int64 EmptyPositionInternal; 
  __int64 v132; 
  __int64 v140; 
  unsigned int v141; 
  signed __int32 v152[8]; 
  XModel *detailModel; 
  XModel *xModel; 
  __int64 v155; 
  hknpShape *v156; 
  char v157; 
  char v158[3]; 
  Physics_WorldId worldIda; 
  unsigned __int16 v160; 
  int numInOut; 
  unsigned int instanceIda; 
  int v163; 
  int p; 
  hknpBodyId bodyId; 
  int shapeSizeOut; 
  unsigned int index; 
  unsigned int v168; 
  int v169; 
  int v170; 
  int v171; 
  int v172; 
  int v173; 
  unsigned int v174; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId; 
  __int64 v176; 
  hknpShapeInstance *v177; 
  int v178; 
  int v179; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsAsset *v181; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  HavokPhysicsInstanceManager *manager; 
  int v184; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 
  unsigned int wasNewKeyOut; 
  __int64 v187; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> > *v188; 
  unsigned __int64 key; 
  __int64 v190; 
  MemoryFile *p_memFile; 
  __int64 v192; 
  hknpSphereShape *v193; 
  hknpCompoundShapeCinfo cinfo; 
  __int64 v195[2]; 
  char dest[256]; 
  hkVector4f center; 
  hknpShape *shape; 
  int v199; 
  __int16 v200; 
  unsigned int v201; 
  unsigned __int16 v202; 
  char v203; 
  hkStringPtr v204; 
  unsigned __int64 v205; 
  char v206; 
  hkReferencedObject *v212; 
  hkReferencedObject *v213; 
  __int16 v214; 
  int v215; 
  int v216; 
  hkReferencedObject *v218; 
  char v219; 
  int v220; 
  hkVector4f v221; 
  hkVector4f v222; 
  hkVector4f v223; 
  hkVector4f v224; 
  hkVector4f a; 
  hkVector4f b; 
  char v227; 
  void *retaddr; 

  _RAX = &retaddr;
  v192 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
  }
  instanceIda = instanceId;
  worldIda = worldId;
  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4530, ASSERT_TYPE_ASSERT, "(save)", "%s\n\tHavokPhysics: LoadInstance has NULL save", "save") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(xModel) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4531, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to LoadInstance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", xModel) )
      __debugbreak();
  }
  if ( instanceId == -1 )
  {
    LODWORD(xModel) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4532, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics: Trying to LoadInstance with invalid instance id %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", xModel) )
      __debugbreak();
  }
  p_memFile = &save->memFile;
  CString = MemFile_ReadCString(&save->memFile);
  v22 = CString;
  if ( CString && *CString )
  {
    AssetByName = Physics_GetAssetByName(CString);
    v24 = AssetByName;
    if ( AssetByName )
    {
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(AssetByName);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4539, ASSERT_TYPE_ASSERT, "(!physicsAsset || havokPhysicsAsset)", (const char *)&queryFormat, "!physicsAsset || havokPhysicsAsset") )
        __debugbreak();
      goto LABEL_21;
    }
  }
  else
  {
    v24 = NULL;
  }
  if ( !I_strempty(v22) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4537, ASSERT_TYPE_ASSERT, "(physicsAsset || I_strempty( physicsAssetName ))", (const char *)&queryFormat, "physicsAsset || I_strempty( physicsAssetName )") )
    __debugbreak();
  HavokPhysicsAsset = NULL;
LABEL_21:
  v25 = MemFile_ReadCString(&save->memFile);
  v26 = v25;
  if ( v25 && *v25 )
    v27 = Physics_GetAssetByName(v25);
  else
    v27 = NULL;
  if ( !v26 && !I_strempty(NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4542, ASSERT_TYPE_ASSERT, "(physicsAssetAddendumName || I_strempty( physicsAssetAddendumName ))", (const char *)&queryFormat, "physicsAssetAddendumName || I_strempty( physicsAssetAddendumName )") )
    __debugbreak();
  if ( v27 )
  {
    v181 = HavokPhysics_GetHavokPhysicsAsset(v27);
    if ( !v181 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4544, ASSERT_TYPE_ASSERT, "(!physicsAssetAddendum || havokPhysicsAssetAddendum)", (const char *)&queryFormat, "!physicsAssetAddendum || havokPhysicsAssetAddendum") )
      __debugbreak();
  }
  else
  {
    v181 = NULL;
  }
  v28 = MemFile_ReadCString(&save->memFile);
  physicsLibrary = NULL;
  HavokPhysicsXModelLODFromDetailCol = NULL;
  if ( v28 && *v28 )
  {
    v30.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_XMODEL, v28, 0).physicsLibrary;
    physicsLibrary = (XModel *)v30.physicsLibrary;
    if ( (!v30.physicsLibrary || (HIDWORD(v30.physicsLibrary[1].name) & 0x8000) != 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4554, ASSERT_TYPE_ASSERT, "(detailModel && !XModelIsDefaultAsset( detailModel ))", (const char *)&queryFormat, "detailModel && !XModelIsDefaultAsset( detailModel )") )
      __debugbreak();
    if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8083, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tHavok Physics: Trying to Get Havok Physics XModel LOD from NULL XModel", "xmodel") )
      __debugbreak();
    HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(physicsLibrary->detailCollision);
  }
  v31 = MemFile_ReadCString(&save->memFile);
  model = NULL;
  if ( v31 )
  {
    if ( *v31 )
    {
      model = DB_FindXAssetHeader(ASSET_TYPE_XMODEL, v31, 0).model;
      if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4565, ASSERT_TYPE_ASSERT, "(xModel)", (const char *)&queryFormat, "xModel") )
        __debugbreak();
    }
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(xModel) = worldIda;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4570, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics LoadInstance %i: world is NULL", "physicsWorld->world", xModel) )
      __debugbreak();
  }
  manager = &MutableWorld->instanceManager;
  detailModel = physicsLibrary;
  v34 = v24;
  v35 = instanceIda;
  p_instanceManager = &MutableWorld->instanceManager;
  HavokPhysicsInstanceManager_Load(save, &MutableWorld->instanceManager, instanceIda, v34, v27, detailModel, model);
  v37 = &save->memFile;
  MemFile_ReadData(&save->memFile, 4ui64, &p);
  v170 = p;
  v38 = 0;
  v163 = 0;
  v39 = p;
  v187 = p;
  if ( p > 0 )
  {
    v40 = 0i64;
    v176 = 0i64;
    p_bodyData = &snapshotFixup->bodyData;
    v188 = p_bodyData;
    __asm
    {
      vxorps  xmm12, xmm12, xmm12
      vmovss  xmm14, cs:__real@3f000000
      vmovss  xmm13, cs:__real@38d1b717
    }
    while ( 1 )
    {
      MemFile_ReadData(v37, 4ui64, &bodyId);
      m_serialAndIndex = bodyId.m_serialAndIndex;
      MemFile_ReadData(v37, 8ui64, &v190);
      v195[1] = v190;
      v46 = MemFile_ReadCString(v37);
      Core_strcpy(dest, 0x100ui64, v46);
      HavokPhysicsInstanceManager_AddBody(manager, v35, (hknpBodyId)m_serialAndIndex);
      v156 = NULL;
      if ( HavokPhysicsAsset )
        break;
      if ( !HavokPhysicsXModelLODFromDetailCol )
      {
        MemFile_ReadData(v37, 4ui64, &v171);
        switch ( v171 )
        {
          case 1:
            MemFile_ReadData(v37, 4ui64, &v173);
            if ( v173 != 1 )
            {
              v126 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4816, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported convex shape");
              goto LABEL_164;
            }
            ShapeData_PlayerClip = PhysicsCoverWall_ReadShapeData_PlayerClip(v37);
            goto LABEL_160;
          case 2:
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm8, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm7, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm6, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm
            {
              vxorps  xmm1, xmm1, xmm1
              vinsertps xmm1, xmm1, xmm7, 0
              vinsertps xmm1, xmm1, xmm6, 10h
              vinsertps xmm1, xmm1, xmm0, 20h ; ' '
              vmovups xmmword ptr [rsp+478h+var_108.m_quad], xmm1
              vmovaps xmm1, xmm8; radius
            }
            ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v224, *(float *)&_XMM1, NULL, 0);
            goto LABEL_160;
          case 3:
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm11, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm10, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm9, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm7, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm8, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm { vmovaps xmm6, xmm0 }
            *(double *)&_XMM0 = MemFile_ReadFloat(v37);
            __asm
            {
              vxorps  xmm1, xmm1, xmm1
              vinsertps xmm1, xmm1, xmm10, 0
              vinsertps xmm1, xmm1, xmm9, 10h
              vinsertps xmm1, xmm1, xmm7, 20h ; ' '
              vmovups xmmword ptr [rsp+478h+a.m_quad], xmm1
              vxorps  xmm2, xmm2, xmm2
              vinsertps xmm2, xmm2, xmm8, 0
              vinsertps xmm2, xmm2, xmm6, 10h
              vinsertps xmm2, xmm2, xmm0, 20h ; ' '
              vmovups xmmword ptr [rsp+478h+b.m_quad], xmm2
              vmovaps xmm3, xmm11; radius
            }
            ShapeData_PlayerClip = HavokPhysics_CreateShapeCapsulePoints(worldIda, &a, &b, *(float *)&_XMM3, NULL, 0, Permanent);
            goto LABEL_160;
          case 9:
            ShapeData_PlayerClip = (hknpShape *)WorldCollision_GetShapeForLoad(worldIda, v35);
            goto LABEL_160;
          case 12:
          case 22:
            MemFile_ReadData(v37, 4ui64, &v172);
            switch ( v172 )
            {
              case 0:
                ShapeData_PlayerClip = (hknpShape *)StaticModels_GetShapeForLoad(worldIda, v35);
                goto LABEL_160;
              case 1:
                ShapeData_PlayerClip = PhysicsCoverWall_ReadShapeData(v37);
                goto LABEL_160;
              case 2:
                ShapeData_PlayerClip = (hknpShape *)PatchCollision_GetShapeForLoad(worldIda, v35);
                goto LABEL_160;
            }
            v126 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4801, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported compound/User_0 shape");
LABEL_164:
            if ( v126 )
              __debugbreak();
            v97 = v156;
            break;
          default:
            v126 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4830, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported shape");
            goto LABEL_164;
        }
LABEL_167:
        LODWORD(xModel) = m_serialAndIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4834, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tInvalid shape for body %d", "shape", xModel) )
          __debugbreak();
        goto LABEL_169;
      }
      if ( v38 == v170 - 1 && v39 > 1 )
      {
        *(double *)&_XMM0 = MemFile_ReadFloat(v37);
        __asm { vmovaps xmm8, xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(v37);
        __asm { vmovaps xmm7, xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(v37);
        __asm { vmovaps xmm6, xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(v37);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vinsertps xmm1, xmm1, xmm7, 0
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm0, 20h ; ' '
          vmovups xmmword ptr [rsp+478h+var_128.m_quad], xmm1
          vmovaps xmm1, xmm8; radius
        }
        ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v222, *(float *)&_XMM1, NULL, 0);
      }
      else
      {
        if ( v38 < HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size )
        {
          v97 = HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v40];
          goto LABEL_161;
        }
        Com_PrintWarning(20, "Savegame was expecting more rigid bodies than it found - creating a placeholder sphere\n");
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovups xmmword ptr [rsp+478h+var_118.m_quad], xmm0
          vmovaps xmm1, xmm13; radius
        }
        ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v223, *(float *)&_XMM1, NULL, 0);
      }
LABEL_160:
      v97 = ShapeData_PlayerClip;
LABEL_161:
      if ( !v97 )
        goto LABEL_167;
LABEL_169:
      v195[0] = (__int64)v97;
      _InterlockedOr(v152, 0);
      m_refCount = v97->m_refCount;
      _InterlockedOr(v152, 0);
      if ( !m_refCount )
      {
        if ( *(_WORD *)(v195[0] + 16) )
        {
          LODWORD(v155) = m_serialAndIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4837, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %d", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", dest, v155) )
            __debugbreak();
        }
      }
      key = m_serialAndIndex;
      v128 = hkMemHeapAllocator();
      EmptyPositionInternal = hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64>>::_findEmptyPositionInternal(p_bodyData, v128, &key, &wasNewKeyOut);
      p_bodyData->m_elem[EmptyPositionInternal].key = m_serialAndIndex;
      _RCX = (__int64)&p_bodyData->m_elem[EmptyPositionInternal].val;
      if ( &p_bodyData->m_elem[EmptyPositionInternal] != (hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *)-8i64 )
      {
        _RAX = v195;
        v132 = 2i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 128i64;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 16;
          --v132;
        }
        while ( v132 );
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovups xmmword ptr [rcx], xmm0
        }
      }
      v163 = ++v38;
      v176 = ++v40;
      v35 = instanceIda;
      if ( v40 >= v39 )
      {
        p_instanceManager = manager;
        goto LABEL_179;
      }
    }
    _RBX = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v40];
    v48 = *(hknpShape **)_RBX;
    shape = v48;
    if ( v48 )
      hkReferencedObject::addReference(v48);
    v199 = *(_DWORD *)(_RBX + 8);
    v200 = *(_WORD *)(_RBX + 12);
    v201 = *(_DWORD *)(_RBX + 16);
    v202 = *(_WORD *)(_RBX + 20);
    v203 = *(_BYTE *)(_RBX + 22);
    hkStringPtr::hkStringPtr(&v204, (const hkStringPtr *)(_RBX + 24));
    v205 = *(_QWORD *)(_RBX + 32);
    v206 = *(_BYTE *)(_RBX + 40);
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx+30h]
      vmovups [rsp+478h+var_1C8], xmm0
      vmovups xmm1, xmmword ptr [rbx+40h]
      vmovups [rsp+478h+var_1B8], xmm1
      vmovups xmm0, xmmword ptr [rbx+50h]
      vmovups [rsp+478h+var_1A8], xmm0
      vmovups xmm1, xmmword ptr [rbx+60h]
      vmovups [rsp+478h+var_198], xmm1
      vmovss  xmm0, dword ptr [rbx+70h]
      vmovss  [rsp+478h+var_188], xmm0
    }
    v53 = *(hkReferencedObject **)(_RBX + 120);
    v212 = v53;
    if ( v53 )
      hkReferencedObject::addReference(v53);
    v54 = *(hkReferencedObject **)(_RBX + 128);
    v213 = v54;
    if ( v54 )
      hkReferencedObject::addReference(v54);
    v214 = *(_WORD *)(_RBX + 136);
    v215 = *(_DWORD *)(_RBX + 140);
    v216 = *(_DWORD *)(_RBX + 144);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+94h]
      vmovss  [rsp+478h+var_164], xmm0
    }
    v55 = *(hkReferencedObject **)(_RBX + 152);
    v218 = v55;
    if ( v55 )
      hkReferencedObject::addReference(v55);
    v219 = *(_BYTE *)(_RBX + 160);
    v220 = *(_DWORD *)(_RBX + 176);
    v56 = shape;
    v156 = shape;
    MemFile_ReadData(v37, 1ui64, &v157);
    if ( v157 )
    {
      if ( (v56->m_type.m_storage != 12 || !v56->getMutationSignals(v56)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4605, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND && shape->isMutable())", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND && shape->isMutable()") )
        __debugbreak();
      Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !Value )
        Value = hkMemoryRouter::s_fallbackRouter;
      v58 = (hknpMaskedShape *)Value->m_heap->blockAlloc(Value->m_heap, 104i64);
      v156 = v58;
      if ( v58 )
      {
        hknpMaskedShape::hknpMaskedShape(v58, v56);
        v60 = v59;
      }
      else
      {
        v60 = 0i64;
      }
      v156 = (hknpShape *)v60;
      if ( !v60 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4611, ASSERT_TYPE_ASSERT, "(maskedShape)", (const char *)&queryFormat, "maskedShape") )
        __debugbreak();
      v61 = *(_QWORD *)(v60 + 56);
      if ( *(_BYTE *)(v61 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4615, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
        __debugbreak();
      v62 = *(_DWORD *)(v61 + 80);
      v63 = 0;
      v184 = 0;
      if ( v62 > 0 )
      {
        v64 = *(_QWORD *)(v61 + 72);
        while ( 1 )
        {
          v65 = v184;
          if ( !*(_BYTE *)(112i64 * (unsigned __int16)v184 + v64 + 92) )
            break;
          v184 = ++v63;
          if ( v63 >= v62 )
            goto LABEL_91;
        }
        while ( v63 != -1 )
        {
          v66 = (0xFFFFFFFF >> *(_BYTE *)(v61 + 27)) | (v65 << (32 - *(_BYTE *)(v61 + 27)));
          MemFile_ReadData(v37, 1ui64, v158);
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v60 + 72) + 16i64))(v60 + 72, v66, (unsigned __int8)v158[0]);
          v67 = *(_DWORD *)(v61 + 80);
          v184 = ++v63;
          if ( v63 >= v67 )
            break;
          v68 = *(_QWORD *)(v61 + 72);
          while ( 1 )
          {
            v65 = v184;
            if ( !*(_BYTE *)(112i64 * (unsigned __int16)v184 + v68 + 92) )
              break;
            v184 = ++v63;
            if ( v63 >= v67 )
              goto LABEL_91;
          }
        }
      }
LABEL_91:
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 264i64))(v60);
      v40 = v176;
      goto LABEL_103;
    }
    MemFile_ReadData(v37, 4ui64, &index);
    *(double *)&_XMM0 = MemFile_ReadFloat(v37);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = MemFile_ReadFloat(v37);
    __asm { vcomiss xmm6, xmm12 }
    if ( v71 | v70 )
    {
      v77 = index;
      if ( index == -1 || !WorldCollision_GetMapEntsShape(index) )
        goto LABEL_103;
      MapEntsShape = WorldCollision_GetMapEntsShape(v77);
    }
    else
    {
      __asm { vucomiss xmm0, xmm12 }
      if ( v70 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovups xmmword ptr [rsp+478h+var_138.m_quad], xmm0
        }
        v74 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
        v193 = v74;
        v156 = v74;
        if ( v74 )
        {
          __asm { vmovaps xmm2, xmm6; radius }
          hknpSphereShape::hknpSphereShape(v74, &v221, *(float *)&_XMM2);
          v76 = v75;
        }
        else
        {
          v76 = NULL;
        }
        v156 = v76;
        v76->m_memSizeAndFlags = shapeSizeOut;
        goto LABEL_103;
      }
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vmovups xmmword ptr [rsp+478h+center.m_quad], xmm2
        vmulss  xmm1, xmm0, xmm14; halfHeight
        vaddss  xmm0, xmm2, xmm1
        vmovss  dword ptr [rsp+478h+center.m_quad+8], xmm0
        vmovaps xmm2, xmm6; radius
      }
      MapEntsShape = HavokPhysics_CreateShapeCylinder(&center, *(float *)&_XMM1, *(float *)&_XMM2, 32, 0);
    }
    v156 = MapEntsShape;
LABEL_103:
    MemFile_ReadData(v37, 4ui64, &v168);
    if ( !v40 && v181 )
    {
      m_ptr = v181->m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr;
      v79 = v168;
      if ( v168 != -1 && WorldCollision_GetMapEntsShape(v168) )
      {
        m_ptr = WorldCollision_GetMapEntsShape(v79);
        LODWORD(v40) = HavokPhysics_GetShapeOverrideContents(v79);
      }
      shapeTagData.m_collisionFilterInfo = v201;
      shapeTagData.m_materialCRC = 0;
      shapeTagData.m_materialId.m_value = v202;
      shapeTagData.m_userData = v205;
      ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
      shapeTagData.m_collisionFilterInfo = v40;
      v160 = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
      v201 |= v40;
      numInOut = 2;
      v81 = hkMemHeapAllocator();
      v82 = numInOut;
      v83 = numInOut;
      if ( numInOut )
      {
        _R14 = (hknpShapeInstance *)hkMemoryAllocator::bufAlloc2(v81, 112, &numInOut);
        v82 = numInOut;
      }
      else
      {
        _R14 = NULL;
      }
      v85 = 0x80000000;
      if ( v82 )
        v85 = v82;
      v177 = _R14;
      v178 = v83;
      v179 = v85;
      if ( _R14 )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [r14], ymm0
          vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [r14+20h], ymm1
          vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
          vmovups xmmword ptr [r14+40h], xmm0
        }
        _R14->m_shape.m_ptr = NULL;
        *(_DWORD *)&_R14->m_shapeTag = -1;
        _R14->m_isEmpty = 0;
        _R14->m_nextEmptyElement = 0;
        _R14->m_instanceId.m_value = -1;
        _R14->m_parentShape = NULL;
        v169 = 64;
        _R14->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
      }
      _RBX = _R14 + 1;
      if ( _R14 != (hknpShapeInstance *)-112i64 )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rbx], ymm0
          vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
          vmovups ymmword ptr [rbx+20h], ymm1
          vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
          vmovups xmmword ptr [rbx+40h], xmm0
        }
        _R14[1].m_shape.m_ptr = NULL;
        *(_DWORD *)&_R14[1].m_shapeTag = -1;
        _R14[1].m_isEmpty = 0;
        _R14[1].m_nextEmptyElement = 0;
        _R14[1].m_instanceId.m_value = -1;
        _R14[1].m_parentShape = NULL;
        v169 = 64;
        _R14[1].m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
      }
      hknpShapeInstance::setShape(_R14, v156);
      hknpShapeInstance::setShape(_R14 + 1, m_ptr);
      _R14->m_shapeTag = ShapeTag;
      _R14[1].m_shapeTag = v160;
      hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
      cinfo.m_instances = _R14;
      cinfo.m_numInstances = v83;
      v91 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v91 )
        v91 = hkMemoryRouter::s_fallbackRouter;
      v92 = (hknpCompoundShape *)v91->m_heap->blockAlloc(v91->m_heap, 288i64);
      v156 = v92;
      if ( v92 )
      {
        hknpCompoundShape::hknpCompoundShape(v92, &cinfo);
        v156 = v93;
      }
      else
      {
        v156 = NULL;
      }
      v94 = hkMemHeapAllocator();
      v95 = v83 - 1;
      if ( v83 - 1 >= 0 )
      {
        p_m_shape = (hkReferencedObject **)&_R14[v95].m_shape;
        do
        {
          if ( *p_m_shape )
            hkReferencedObject::removeReference(*p_m_shape);
          p_m_shape -= 14;
          --v95;
        }
        while ( v95 >= 0 );
      }
      v178 = 0;
      if ( v85 >= 0 )
        hkMemoryAllocator::bufFree2(v94, _R14, 112, v85 & 0x3FFFFFFF);
      v177 = NULL;
      v179 = 0x80000000;
      v37 = p_memFile;
      v40 = v176;
    }
    if ( v218 )
      hkReferencedObject::removeReference(v218);
    if ( v213 )
      hkReferencedObject::removeReference(v213);
    if ( v212 )
      hkReferencedObject::removeReference(v212);
    hkStringPtr::~hkStringPtr(&v204);
    if ( shape )
      hkReferencedObject::removeReference(shape);
    v97 = v156;
    v38 = v163;
    v39 = v187;
    p_bodyData = v188;
    goto LABEL_161;
  }
LABEL_179:
  MemFile_ReadData(v37, 4ui64, &v174);
  if ( (int)v174 > 0 )
  {
    v140 = v174;
    v141 = instanceIda;
    do
    {
      MemFile_ReadData(v37, 4ui64, &constraintId);
      HavokPhysicsInstanceManager_AddConstraint(p_instanceManager, v141, constraintId);
      --v140;
    }
    while ( v140 );
  }
  _R11 = &v227;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
HavokPhysics_LoadSnapshot
==============
*/
void HavokPhysics_LoadSnapshot(SaveGame *save, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 
  unsigned __int64 v6; 
  hkMemoryAllocator *v7; 
  int EmptyPositionInternal; 
  __int64 v9; 
  hkMemoryRouter *Value; 
  unsigned __int64 v11; 
  void *v12; 
  hkMemoryRouter *v13; 
  hknpWorld *world; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  unsigned int v16; 
  unsigned int v17; 
  __int64 v18; 
  __int64 m_serialAndIndex; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  int v23; 
  unsigned __int64 v24; 
  __int64 v27; 
  hkMemoryAllocator *v37; 
  int m_hashMod; 
  __int64 v39; 
  __int64 v40; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  signed int v42; 
  hkMemoryAllocator *v43; 
  int v44; 
  __int64 v45; 
  __int64 v46; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v47; 
  signed int v48; 
  unsigned int instanceId; 
  unsigned int p; 
  HavokPhysics_SnapshotFixup snapshotFixup; 
  unsigned int v52; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint v53; 
  unsigned int wasNewKeyOut; 
  unsigned __int64 key[2]; 
  hkMemoryStreamReader v56; 
  char v57; 
  unsigned __int64 v58; 
  char string[256]; 

  key[1] = -2i64;
  snapshotFixup.__vftable = (HavokPhysics_SnapshotFixup_vtbl *)&HavokPhysics_SnapshotFixup::`vftable';
  snapshotFixup.bodyData.m_elem = NULL;
  snapshotFixup.bodyData.m_numElems = 0;
  snapshotFixup.bodyData.m_hashMod = -1;
  snapshotFixup.constraintData.m_elem = NULL;
  snapshotFixup.constraintData.m_numElems = 0;
  snapshotFixup.constraintData.m_hashMod = -1;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5077, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld main is NULL", "world->world") )
    __debugbreak();
  hknpWorld::checkConsistency(MutableWorld->world);
  snapshotFixup.worldId = worldId;
  HavokPhysics_ReadWorld(save, worldId, &snapshotFixup);
  if ( !HavokPhysics_GetMutableWorld(worldId)->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4918, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Read serverworld main is NULL", "world->world") )
    __debugbreak();
  MemFile_ReadData(&save->memFile, 4ui64, &p);
  if ( (int)p > 0 )
  {
    v5 = p;
    do
    {
      MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
      MemFile_ReadData(&save->memFile, 4ui64, &p);
      v53.instanceId = p;
      MemFile_ReadData(&save->memFile, 4ui64, &v52);
      v53.constraintIdx = v52;
      v6 = (int)instanceId;
      key[0] = (int)instanceId;
      v7 = hkMemHeapAllocator();
      EmptyPositionInternal = hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64>>::_findEmptyPositionInternal(&snapshotFixup.constraintData, v7, key, &wasNewKeyOut);
      snapshotFixup.constraintData.m_elem[EmptyPositionInternal].key = v6;
      if ( &snapshotFixup.constraintData.m_elem[EmptyPositionInternal] != (hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *)-8i64 )
        snapshotFixup.constraintData.m_elem[EmptyPositionInternal].val = v53;
      --v5;
    }
    while ( v5 );
  }
  MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
  if ( instanceId )
  {
    v9 = instanceId;
    do
    {
      MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
      HavokPhysics_LoadInstance(save, worldId, instanceId, &snapshotFixup);
      --v9;
    }
    while ( v9 );
  }
  HavokPhysics_SnapshotFixup::Validate(&snapshotFixup, MutableWorld);
  MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v11 = (int)instanceId;
  v12 = Value->m_heap->blockAlloc(Value->m_heap, instanceId);
  MemFile_ReadData(&save->memFile, v11, v12);
  hkMemoryStreamReader::hkMemoryStreamReader(&v56, v12, v11, MEMORY_INPLACE, 0i64);
  NpSimulationSnapshot::importSimulationState(MutableWorld->world, &v56, &snapshotFixup);
  v13 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v13 )
    v13 = hkMemoryRouter::s_fallbackRouter;
  v13->m_heap->blockFree(v13->m_heap, v12, v11);
  world = MutableWorld->world;
  m_data = world->m_bodyManager.m_bodies.m_objects.m_data;
  v16 = world->m_bodyManager.m_bodies.m_peakIndex + 1;
  v17 = 0;
  if ( world->m_bodyManager.m_bodies.m_numAllocated )
  {
    if ( (m_data->m_pod.m_flags.m_storage & 0xF) != 0 )
      goto LABEL_37;
    v17 = 1;
    if ( v16 > 1 )
    {
      while ( (m_data[v17].m_pod.m_flags.m_storage & 0xF) == 0 )
      {
        if ( ++v17 >= v16 )
          goto LABEL_38;
      }
      if ( v17 != -1 )
      {
LABEL_37:
        do
        {
          v18 = v17;
          m_serialAndIndex = m_data[v18].m_pod.m_id.m_serialAndIndex;
          if ( snapshotFixup.bodyData.m_hashMod <= 0 || (v20 = _byteswap_ulong(-1640531535 * m_serialAndIndex), v21 = _byteswap_ulong(0), v22 = snapshotFixup.bodyData.m_hashMod & (v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527)), v23 = v22, v24 = snapshotFixup.bodyData.m_elem[v22].key, v24 == -1i64) )
          {
LABEL_30:
            v23 = snapshotFixup.bodyData.m_hashMod + 1;
          }
          else
          {
            while ( v24 != m_serialAndIndex )
            {
              v22 = snapshotFixup.bodyData.m_hashMod & (v22 + 1);
              v23 = v22;
              v24 = snapshotFixup.bodyData.m_elem[v22].key;
              if ( v24 == -1i64 )
                goto LABEL_30;
            }
          }
          _RDX = &snapshotFixup.bodyData.m_elem[v23].val;
          _RAX = &v57;
          v27 = 2i64;
          do
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [rdx]
              vmovups xmmword ptr [rax], xmm0
              vmovups xmm1, xmmword ptr [rdx+10h]
              vmovups xmmword ptr [rax+10h], xmm1
              vmovups xmm0, xmmword ptr [rdx+20h]
              vmovups xmmword ptr [rax+20h], xmm0
              vmovups xmm1, xmmword ptr [rdx+30h]
              vmovups xmmword ptr [rax+30h], xmm1
              vmovups xmm0, xmmword ptr [rdx+40h]
              vmovups xmmword ptr [rax+40h], xmm0
              vmovups xmm1, xmmword ptr [rdx+50h]
              vmovups xmmword ptr [rax+50h], xmm1
              vmovups xmm0, xmmword ptr [rdx+60h]
              vmovups xmmword ptr [rax+60h], xmm0
            }
            _RAX += 128;
            __asm
            {
              vmovups xmm1, xmmword ptr [rdx+70h]
              vmovups xmmword ptr [rax-10h], xmm1
            }
            _RDX = (HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *)((char *)_RDX + 128);
            --v27;
          }
          while ( v27 );
          __asm
          {
            vmovups xmm0, xmmword ptr [rdx]
            vmovups xmmword ptr [rax], xmm0
          }
          m_data[v18].m_pod.m_userData = v58;
          hkStringPtr::operator=(&MutableWorld->world->m_bodyManager.m_bodyNames.m_data[m_data[v18].m_pod.m_id.m_serialAndIndex & 0xFFFFFF], string);
          if ( ++v17 >= v16 )
          {
LABEL_36:
            v17 = -1;
          }
          else
          {
            while ( (m_data[v17].m_pod.m_flags.m_storage & 0xF) == 0 )
            {
              if ( ++v17 >= v16 )
                goto LABEL_36;
            }
          }
        }
        while ( v17 != -1 );
      }
    }
  }
LABEL_38:
  v37 = hkMemHeapAllocator();
  m_hashMod = snapshotFixup.bodyData.m_hashMod;
  if ( snapshotFixup.bodyData.m_hashMod && (v39 = snapshotFixup.bodyData.m_hashMod + 1, snapshotFixup.bodyData.m_hashMod + 1 > 0) )
  {
    v40 = 0i64;
    m_elem = snapshotFixup.bodyData.m_elem;
    do
    {
      if ( m_elem[v40].key != -1i64 )
      {
        m_elem[v40].key = -1i64;
        m_elem = snapshotFixup.bodyData.m_elem;
      }
      ++v40;
      --v39;
    }
    while ( v39 );
    m_hashMod = snapshotFixup.bodyData.m_hashMod;
  }
  else
  {
    m_elem = snapshotFixup.bodyData.m_elem;
  }
  v42 = snapshotFixup.bodyData.m_numElems & 0x80000000;
  snapshotFixup.bodyData.m_numElems &= 0x80000000;
  if ( m_elem && v42 >= 0 )
    v37->blockFree(v37, m_elem, 280 * (m_hashMod + 1));
  snapshotFixup.bodyData.m_elem = NULL;
  snapshotFixup.bodyData.m_numElems = 0;
  snapshotFixup.bodyData.m_hashMod = -1;
  v43 = hkMemHeapAllocator();
  v44 = snapshotFixup.constraintData.m_hashMod;
  if ( snapshotFixup.constraintData.m_hashMod && (v45 = snapshotFixup.constraintData.m_hashMod + 1, snapshotFixup.constraintData.m_hashMod + 1 > 0) )
  {
    v46 = 0i64;
    v47 = snapshotFixup.constraintData.m_elem;
    do
    {
      if ( v47[v46].key != -1i64 )
      {
        v47[v46].key = -1i64;
        v47 = snapshotFixup.constraintData.m_elem;
      }
      ++v46;
      --v45;
    }
    while ( v45 );
    v44 = snapshotFixup.constraintData.m_hashMod;
  }
  else
  {
    v47 = snapshotFixup.constraintData.m_elem;
  }
  v48 = snapshotFixup.constraintData.m_numElems & 0x80000000;
  snapshotFixup.constraintData.m_numElems &= 0x80000000;
  if ( v47 && v48 >= 0 )
    v43->blockFree(v43, v47, 16 * (v44 + 1));
  snapshotFixup.constraintData.m_elem = NULL;
  snapshotFixup.constraintData.m_numElems = 0;
  snapshotFixup.constraintData.m_hashMod = -1;
  hkMemoryStreamReader::~hkMemoryStreamReader(&v56);
}

/*
==============
HavokPhysics_LockAssetRead
==============
*/
void HavokPhysics_LockAssetRead(void)
{
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_LockAssetWrite
==============
*/
void HavokPhysics_LockAssetWrite(void)
{
  int v0; 

  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  s_havokPhysicsAssetLock.writeThreadId = Sys_GetCurrentThreadId();
  if ( !s_havokPhysicsAssetLock.writeThreadId )
  {
    v0 = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 177, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) != ( INVALID_THREAD_ID )", "%s != %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", v0, 0i64) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_LockWorld
==============
*/
void HavokPhysics_LockWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6423, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_LoosenConstraint
==============
*/
char HavokPhysics_LoosenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *result)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int *v6; 
  __int64 v7; 
  unsigned int v8; 
  const hkTransformf *v9; 
  __int64 v10; 
  const hkTransformf *v11; 
  int v12; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = (unsigned int *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value);
  v7 = *((_QWORD *)v6 + 1);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13458, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  v8 = v6[1];
  v9 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, *v6);
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, v8);
  *(_DWORD *)&result->coneChanged = 0;
  v11 = (const hkTransformf *)v10;
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
  if ( v12 == 2 )
  {
    if ( result == (PhysicsConstraintLooseningResult *)-4i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13260, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result->before.ragdoll.cone = *(float *)(v7 + 248);
    result->before.ragdoll.planeMin = *(float *)(v7 + 252);
    HavokPhysics_LoosenHingeConstraint((hkpLimitedHingeConstraintData::Atoms *)(v7 + 32), v9, v11, result);
  }
  else
  {
    if ( v12 != 7 )
      return 0;
    if ( result == (PhysicsConstraintLooseningResult *)-4i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13249, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result->before.ragdoll.cone = *(float *)(v7 + 348);
    result->before.ragdoll.planeMin = *(float *)(v7 + 376);
    result->before.ragdoll.planeMax = *(float *)(v7 + 380);
    result->before.ragdoll.twistMin = *(float *)(v7 + 312);
    result->before.ragdoll.twistMax = *(float *)(v7 + 316);
    HavokPhysics_LoosenRagdollConstraint((hkpRagdollConstraintData::Atoms *)(v7 + 32), v9, v11, result);
  }
  return 1;
}

/*
==============
HavokPhysics_LoosenHingeConstraint
==============
*/
void HavokPhysics_LoosenHingeConstraint(hkpLimitedHingeConstraintData::Atoms *atoms, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  char v46; 
  char v65; 
  char v73; 
  __m128 resulta; 
  char v86; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovaps [rsp+0F8h+var_88], xmm12
    vmovaps [rsp+0F8h+var_98], xmm13
  }
  _RBX = result;
  _RSI = bodyBTransform;
  _RDI = atoms;
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13354, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  __asm
  {
    vmovups xmm5, xmmword ptr [rdi+20h]
    vmovups xmm7, xmmword ptr [rsi]
    vmovups xmm8, xmmword ptr [rsi+10h]
    vmovups xmm9, xmmword ptr [rsi+20h]
    vmovups xmm10, xmmword ptr [rdi+70h]
    vmovss  xmm12, dword ptr [rbx+4]
    vmovss  xmm13, dword ptr [rbx+8]
    vshufps xmm0, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm3, xmm0, xmmword ptr [rbp+10h]
    vshufps xmm1, xmm5, xmm5, 0
    vmulps  xmm2, xmm1, xmmword ptr [rbp+0]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rbp+20h]
    vmovups xmm5, xmmword ptr [rdi+60h]
    vaddps  xmm11, xmm4, xmm1
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmm7
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmm8
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmm9
    vaddps  xmm2, xmm4, xmm1
    vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vdpps   xmm3, xmm11, xmm2, 7Fh
    vcmpltps xmm0, xmm3, xmm1
    vblendvps xmm2, xmm1, xmm3, xmm0
    vmovups xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+40h; __m128 const near * const g_vectorfConstants
    vmaxps  xmm2, xmm1, xmm2
    vmovups xmmword ptr [rsp+0F8h+result], xmm2
  }
  hkMath::quadAsin(&resulta, &bodyATransform->m_rotation.m_col0.m_quad);
  __asm
  {
    vmovups xmm6, xmm0
    vshufps xmm1, xmm10, xmm10, 0
    vmulps  xmm4, xmm1, xmm7
    vshufps xmm2, xmm10, xmm10, 55h ; 'U'
    vmulps  xmm3, xmm2, xmm8
    vaddps  xmm5, xmm4, xmm3
    vshufps xmm1, xmm10, xmm10, 0AAh ; ''
    vmulps  xmm2, xmm1, xmm9
    vaddps  xmm3, xmm5, xmm2
    vdpps   xmm4, xmm11, xmm3, 7Fh
    vxorps  xmm1, xmm1, xmm1
    vcmpltps xmm2, xmm4, xmm1
    vmovups xmm1, xmmword ptr cs:?hkSse_piOver2@hkMath@@3QBIB; uint const near * const hkMath::hkSse_piOver2
    vpsrld  xmm0, xmm2, 1Fh
    vpslld  xmm3, xmm0, 1Fh
    vsubps  xmm0, xmm1, xmm6
    vxorps  xmm2, xmm0, xmm3
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
  }
  if ( v65 )
  {
    __asm
    {
      vsubss  xmm1, xmm2, cs:__real@3c23d70a
      vmovss  xmm1, xmm0, xmm1
      vminss  xmm3, xmm12, xmm1
      vmovss  dword ptr [rdi+0D8h], xmm3
    }
  }
  else
  {
    __asm
    {
      vaddss  xmm1, xmm2, cs:__real@3c23d70a
      vmovss  xmm3, dword ptr [rdi+0D8h]
      vmovss  xmm1, xmm0, xmm1
      vmaxss  xmm2, xmm13, xmm1
      vmovss  dword ptr [rdi+0DCh], xmm2
    }
  }
  __asm
  {
    vucomiss xmm3, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+18h], xmm3
    vmovss  xmm0, dword ptr [rdi+0DCh]
    vmovss  dword ptr [rbx+1Ch], xmm0
  }
  if ( v46 )
    v73 = 0;
  else
    v73 = 1;
  __asm { vucomiss xmm0, dword ptr [rbx+8] }
  _RBX->angChanged |= (((unsigned __int8)v73 | _RBX->angChanged) != 0) | v73;
  _R11 = &v86;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
HavokPhysics_LoosenRagdollConstraint
==============
*/
void HavokPhysics_LoosenRagdollConstraint(hkpRagdollConstraintData::Atoms *atoms, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  char v62; 
  char v63; 
  char v72; 
  char v84; 
  char v123; 
  char v133; 
  float twistAxisBinWorld; 
  hkVector4f twistAxisBinWorld_8; 
  hkVector4f twistAxisAinWorld_8; 
  __m128 result_8; 
  hkVector4f planeAxisBinWorld; 
  hkVector4f planeAxisAinWorld; 
  hkVector4f axisOut; 
  char v152; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovaps xmmword ptr [rax-88h], xmm12
    vmovaps xmmword ptr [rax-98h], xmm13
    vmovaps xmmword ptr [rax-0A8h], xmm14
  }
  _RBX = result;
  _RDI = (unsigned __int8 *)atoms;
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13269, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  _RAX = 2i64 * _RDI[307];
  __asm
  {
    vmovups xmm5, xmmword ptr [rdi+rax*8+10h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [r14]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [r14+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [r14+20h]
    vaddps  xmm11, xmm4, xmm1
  }
  _RAX = 2i64 * _RDI[308];
  __asm
  {
    vmovups xmmword ptr [rsp+160h+twistAxisAinWorld.m_quad+8], xmm11
    vmovups xmm5, xmmword ptr [rdi+rax*8+50h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [rsi]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [rsi+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rsi+20h]
    vaddps  xmm10, xmm4, xmm1
  }
  _RAX = 2i64 * _RDI[340];
  __asm
  {
    vmovups xmmword ptr [rsp+160h+twistAxisBinWorld.m_quad+8], xmm10
    vmovups xmm5, xmmword ptr [rdi+rax*8+50h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [rsi]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [rsi+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rsi+20h]
    vaddps  xmm5, xmm4, xmm1
  }
  _RAX = 16i64 * _RDI[339];
  __asm
  {
    vmovups xmm6, xmmword ptr [rax+rdi+10h]
    vshufps xmm2, xmm6, xmm6, 0
    vmulps  xmm3, xmm2, xmmword ptr [r14]
    vshufps xmm2, xmm6, xmm6, 0AAh ; ''
    vshufps xmm0, xmm6, xmm6, 55h ; 'U'
    vmulps  xmm1, xmm0, xmmword ptr [r14+10h]
    vmulps  xmm0, xmm2, xmmword ptr [r14+20h]
    vaddps  xmm4, xmm3, xmm1
    vaddps  xmm1, xmm4, xmm0
    vdpps   xmm3, xmm1, xmm5, 7Fh
    vdpps   xmm0, xmm11, xmm10, 7Fh
    vunpcklps xmm2, xmm0, xmm3
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+50h; __m128 const near * const g_vectorfConstants
    vunpcklps xmm1, xmm0, xmm0
    vmovlhps xmm0, xmm2, xmm1
    vmovups xmmword ptr [rsp+160h+result+8], xmm0
  }
  hkMath::quadAsin(&result_8, &bodyATransform->m_rotation.m_col0.m_quad);
  __asm
  {
    vmovups xmm1, xmmword ptr cs:?hkSse_piOver2@hkMath@@3QBIB; uint const near * const hkMath::hkSse_piOver2
    vmovss  xmm12, cs:__real@3c23d70a
    vsubps  xmm2, xmm1, xmm0
    vaddss  xmm3, xmm2, xmm12
    vmovups xmmword ptr [rsp+160h+var_F8+8], xmm2
    vmovss  xmm2, dword ptr [rbx+4]
    vxorps  xmm0, xmm0, xmm0
    vmovss  xmm1, xmm0, xmm3
    vmaxss  xmm2, xmm2, xmm1
    vmovss  dword ptr [rdi+13Ch], xmm2
    vucomiss xmm2, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+18h], xmm2
  }
  if ( v63 )
  {
    v72 = 0;
    v62 = 0;
    v63 = 1;
  }
  else
  {
    v72 = 1;
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsp+160h+var_F8+0Ch]
    vmovss  xmm0, cs:__real@3fc90fdb
    vcomiss xmm1, xmm0
    vmovss  xmm2, dword ptr [rbx+8]
  }
  _RBX->coneChanged = v72;
  if ( v62 | v63 )
  {
    __asm
    {
      vsubss  xmm0, xmm0, xmm1
      vmovss  xmm1, dword ptr [rbx+0Ch]
      vaddss  xmm2, xmm0, xmm12
      vmaxss  xmm3, xmm1, xmm2
      vmovss  dword ptr [rdi+15Ch], xmm3
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3fc7c82d
      vmovss  xmm3, dword ptr [rdi+15Ch]
      vsubss  xmm1, xmm0, xmm1
      vminss  xmm2, xmm2, xmm1
      vmovss  dword ptr [rdi+158h], xmm2
    }
  }
  __asm
  {
    vucomiss xmm3, dword ptr [rbx+0Ch]
    vmovss  dword ptr [rbx+20h], xmm3
    vmovss  xmm0, dword ptr [rdi+158h]
    vmovss  dword ptr [rbx+1Ch], xmm0
  }
  if ( v63 )
    v84 = 0;
  else
    v84 = 1;
  __asm { vucomiss xmm0, dword ptr [rbx+8] }
  _RBX->planeChanged |= (((unsigned __int8)v84 | _RBX->planeChanged) != 0) | v84;
  _RAX = 2i64 * _RDI[275];
  __asm
  {
    vmovups xmm5, xmmword ptr [rdi+rax*8+10h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [r14]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [r14+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [r14+20h]
    vaddps  xmm2, xmm4, xmm1
    vmovups xmmword ptr [rsp+160h+twistAxisAinWorld.m_quad+8], xmm2
    vmovups xmm5, xmmword ptr [rdi+rax*8+50h]
  }
  _RAX = _RDI[276];
  __asm
  {
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [rsi]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [rsi+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rsi+20h]
    vaddps  xmm2, xmm4, xmm1
    vmovups xmmword ptr [rsp+160h+twistAxisBinWorld.m_quad+8], xmm2
  }
  _RAX *= 2i64;
  __asm
  {
    vmovups xmm5, xmmword ptr [rdi+rax*8+10h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [r14]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [r14+10h]
    vaddps  xmm4, xmm3, xmm2
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [r14+20h]
    vaddps  xmm2, xmm4, xmm1
    vmovups xmmword ptr [rbp+60h+planeAxisAinWorld.m_quad], xmm2
    vmovups xmm5, xmmword ptr [rdi+rax*8+50h]
    vshufps xmm0, xmm5, xmm5, 0
    vmulps  xmm3, xmm0, xmmword ptr [rsi]
    vshufps xmm1, xmm5, xmm5, 55h ; 'U'
    vmulps  xmm2, xmm1, xmmword ptr [rsi+10h]
    vshufps xmm0, xmm5, xmm5, 0AAh ; ''
    vmulps  xmm1, xmm0, xmmword ptr [rsi+20h]
    vaddps  xmm4, xmm3, xmm2
    vaddps  xmm2, xmm4, xmm1
    vmovups xmmword ptr [rbp+60h+planeAxisBinWorld.m_quad], xmm2
  }
  j_hkInternalConstraintUtils_calcRelativeAngle(&twistAxisAinWorld_8, &twistAxisBinWorld_8, &planeAxisAinWorld, &planeAxisBinWorld, &axisOut, &twistAxisBinWorld);
  __asm
  {
    vmovss  xmm1, dword ptr [rsp+160h+twistAxisBinWorld.m_quad]
    vmovss  xmm2, dword ptr [rbx+10h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
  }
  if ( v62 )
  {
    __asm
    {
      vsubss  xmm1, xmm1, xmm12
      vminss  xmm3, xmm2, xmm1
      vmovss  dword ptr [rdi+118h], xmm3
    }
  }
  else
  {
    __asm
    {
      vaddss  xmm3, xmm1, xmm12
      vmovss  xmm1, dword ptr [rbx+14h]
      vmaxss  xmm2, xmm1, xmm3
      vmovss  xmm3, dword ptr [rdi+118h]
      vmovss  dword ptr [rdi+11Ch], xmm2
    }
  }
  __asm
  {
    vucomiss xmm3, dword ptr [rbx+10h]
    vmovss  dword ptr [rbx+24h], xmm3
    vmovss  xmm0, dword ptr [rdi+11Ch]
    vmovss  dword ptr [rbx+28h], xmm0
  }
  if ( v123 )
    v133 = 0;
  else
    v133 = 1;
  __asm { vucomiss xmm0, dword ptr [rbx+14h] }
  _RBX->twistChanged |= v133 | (((unsigned __int8)v133 | _RBX->twistChanged) != 0);
  _R11 = &v152;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
HavokPhysics_MovePhysicsAsset
==============
*/
void HavokPhysics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  Dummy *v9; 
  PhysicsAsset *key; 
  unsigned __int64 val; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  unsigned __int64 v18; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v20; 
  int v24; 
  int v25; 
  int v26; 
  unsigned __int32 v27; 
  unsigned __int32 v28; 
  unsigned int v29; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  PhysicsAsset *v31; 
  __int64 v32; 
  hkMemoryAllocator alloc; 

  _RDI = to;
  _RSI = from;
  HavokPhysics_LockAssetWrite();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7534, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7535, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7536, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)_RSI), v7 = _byteswap_ulong(-1640531535 * HIDWORD(_RSI)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = (Dummy *)v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != _RSI )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = (Dummy *)v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( (int)v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7539, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( fromIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( fromIt )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[(int)v9].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v4->m_map, v9);
  v12 = s_havokPhysicsAssets;
  v13 = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * (_DWORD)_RDI), v15 = _byteswap_ulong(-1640531535 * HIDWORD(_RDI)), v16 = v13 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = s_havokPhysicsAssets->m_map.m_elem[v16].key, v18 == -1i64) )
  {
LABEL_24:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( (PhysicsAsset *)v18 != _RDI )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = s_havokPhysicsAssets->m_map.m_elem[v16].key;
      if ( v18 == -1i64 )
        goto LABEL_24;
    }
  }
  if ( (int)v17 > v13 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7544, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( toIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( toIt )") )
      __debugbreak();
    v12 = s_havokPhysicsAssets;
  }
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v12->m_map, v17);
  __asm { vmovups ymm0, ymmword ptr [rsi] }
  v20 = s_havokPhysicsAssets;
  __asm
  {
    vmovups ymmword ptr [rdi], ymm0
    vmovups ymm1, ymmword ptr [rsi+20h]
    vmovups ymmword ptr [rdi+20h], ymm1
    vmovups xmm0, xmmword ptr [rsi+40h]
    vmovups xmmword ptr [rdi+40h], xmm0
    vmovsd  xmm1, qword ptr [rsi+50h]
    vmovsd  qword ptr [rdi+50h], xmm1
  }
  v24 = (unsigned int)hkMemHeapAllocator();
  v25 = v20->m_map.m_hashMod;
  if ( 2 * v20->m_map.m_numElems > v25 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v20->m_map, &alloc, v24);
    v25 = v20->m_map.m_hashMod;
  }
  v26 = 1;
  v27 = _byteswap_ulong(-1640531535 * (_DWORD)_RDI);
  v28 = _byteswap_ulong(-1640531535 * HIDWORD(_RDI));
  v29 = v25 & (v28 ^ ((v27 >> 2) + v27 + (v28 << 6) - 1640531527));
  m_elem = v20->m_map.m_elem;
  v31 = (PhysicsAsset *)v20->m_map.m_elem[v29].key;
  if ( v31 != (PhysicsAsset *)-1i64 )
  {
    while ( v31 != _RDI )
    {
      v29 = v20->m_map.m_hashMod & (v29 + 1);
      v31 = (PhysicsAsset *)m_elem[v29].key;
      if ( v31 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v26 = 0;
  }
LABEL_36:
  v20->m_map.m_numElems += v26;
  v32 = (int)v29;
  m_elem[v32].key = (unsigned __int64)_RDI;
  v20->m_map.m_elem[v32].val = val;
  if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7550, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->insert( to, assetPtr ))", (const char *)&queryFormat, "s_havokPhysicsAssets->insert( to, assetPtr )") )
    __debugbreak();
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MovePhysicsSFXEventAsset
==============
*/
void HavokPhysics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  int v4; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  hkMemoryAllocator *v8; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 

  val = to;
  _RDI = to;
  _RSI = from;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7116, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7117, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7118, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)_RSI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7121, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)_RDI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7122, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsSFXAssetInternal(_RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdi], ymm0
  }
  v6 = v4;
  HavokPhysics_LockAssetWrite();
  key = v6;
  v7 = g_physicsSFXEventAssets;
  v8 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::insert(v7, v8, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MovePhysicsVFXEventAsset
==============
*/
void HavokPhysics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  int v4; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  hkMemoryAllocator *v8; 
  unsigned int key; 
  PhysicsVFXEventAsset *val; 

  val = to;
  _RDI = to;
  _RSI = from;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7280, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7281, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7282, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)_RSI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7285, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)_RDI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7286, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsVFXAssetInternal(_RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rdi], ymm0
  }
  v6 = v4;
  HavokPhysics_LockAssetWrite();
  key = v6;
  v7 = g_physicsVFXEventAssets;
  v8 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::insert(v7, v8, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MoveXModelAsset
==============
*/
void HavokPhysics_MoveXModelAsset(XModel *from, XModel *to)
{
  int Index; 
  __int64 v5; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v6; 
  __int64 m_size; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  int v10; 

  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7936, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  Index = HavokPhysics_DebugXModelGetIndex(from);
  v5 = Index;
  if ( Index < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7938, ASSERT_TYPE_ASSERT, "(xModelId >= 0)", "%s\n\txmodel doesn't exist in debug list", "xModelId >= 0") )
    __debugbreak();
  v6 = s_havokPhysicsXModels;
  m_size = s_havokPhysicsXModels->m_size;
  s_havokPhysicsXModels->m_size = m_size - 1;
  if ( (_DWORD)m_size - 1 != (_DWORD)v5 )
    v6->m_data[v5] = v6->m_data[m_size - 1];
  if ( (int)HavokPhysics_DebugXModelGetIndex(to) > 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7940, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( to ) <= 0)", "%s\n\tdest xmodel already exists", "HavokPhysics_DebugXModelGetIndex( to ) <= 0") )
    __debugbreak();
  v8 = s_havokPhysicsXModels;
  v9 = hkMemHeapAllocator();
  v10 = v8->m_size;
  if ( v10 == (v8->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v9, v8, 8);
    v10 = v8->m_size;
  }
  v8->m_data[v10] = to;
  ++v8->m_size;
}

/*
==============
HavokPhysics_MoveXModelDetailCollisionAsset
==============
*/
void HavokPhysics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v5; 
  int m_hashMod; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  unsigned int v9; 
  Dummy *v10; 
  XModelDetailCollision *key; 
  int v12; 
  unsigned __int32 v13; 
  unsigned __int32 v14; 
  unsigned int v15; 
  int v16; 
  XModelDetailCollision *v17; 
  int v18; 
  int v19; 
  int v20; 
  unsigned __int32 v21; 
  unsigned __int32 v22; 
  int v23; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v25; 
  XModelDetailCollision *v26; 
  __int64 v27; 
  hkMemoryAllocator alloc; 

  val = 0i64;
  HavokPhysics_LockAssetWrite();
  v5 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = _byteswap_ulong(-1640531535 * (_DWORD)from), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = (Dummy *)v9, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v10 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = (Dummy *)v9;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( (int)v10 <= m_hashMod )
  {
    val = s_havokPhysicsXModelLODs->m_map.m_elem[(int)v10].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&s_havokPhysicsXModelLODs->m_map, v10);
    v5 = s_havokPhysicsXModelLODs;
  }
  v12 = v5->m_map.m_hashMod;
  if ( v12 <= 0 || (v13 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v14 = _byteswap_ulong(-1640531535 * (_DWORD)to), v15 = v12 & (v13 ^ ((v14 >> 2) + v14 + (v13 << 6) - 1640531527)), v16 = v15, v17 = (XModelDetailCollision *)v5->m_map.m_elem[v15].key, v17 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v16 = v12 + 1;
  }
  else
  {
    while ( v17 != to )
    {
      v15 = v12 & (v15 + 1);
      v16 = v15;
      v17 = (XModelDetailCollision *)v5->m_map.m_elem[v15].key;
      if ( v17 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( v16 <= v12 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7968, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsXModelLODs->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsXModelLODs->hasKey( to )") )
      __debugbreak();
    v5 = s_havokPhysicsXModelLODs;
  }
  if ( val )
  {
    v18 = (unsigned int)hkMemHeapAllocator();
    v19 = v5->m_map.m_hashMod;
    if ( 2 * v5->m_map.m_numElems > v19 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v5->m_map, &alloc, v18);
      v19 = v5->m_map.m_hashMod;
    }
    v20 = 1;
    v21 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v22 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v23 = v22 ^ ((v21 >> 2) + v21 + (v22 << 6) - 1640531527);
    m_elem = v5->m_map.m_elem;
    v25 = v19 & v23;
    v26 = (XModelDetailCollision *)v5->m_map.m_elem[v25].key;
    if ( v26 != (XModelDetailCollision *)-1i64 )
    {
      while ( v26 != to )
      {
        v25 = v5->m_map.m_hashMod & (v25 + 1);
        v26 = (XModelDetailCollision *)m_elem[v25].key;
        if ( v26 == (XModelDetailCollision *)-1i64 )
          goto LABEL_25;
      }
      v20 = 0;
    }
LABEL_25:
    v5->m_map.m_numElems += v20;
    v27 = (int)v25;
    m_elem[v27].key = (unsigned __int64)to;
    v5->m_map.m_elem[v27].val = val;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MyChangesInitAndLoad
==============
*/
void HavokPhysics_MyChangesInitAndLoad(void)
{
  ;
}

/*
==============
HavokPhysics_MyChangesSaveAndShutdown
==============
*/
void HavokPhysics_MyChangesSaveAndShutdown(void)
{
  ;
}

/*
==============
HavokPhysics_OnThreadInit
==============
*/
void HavokPhysics_OnThreadInit(unsigned int threadId)
{
  void *v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 
  hkMemoryRouter *v4; 
  hkMonitorStream *Value; 

  v1 = (void *)(int)threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2812, ASSERT_TYPE_ASSERT, "(threadId < s_threadIdMax)", "%s\n\tHavokPhysics ThreadInit - we only support %u threads - increase the size of s_threadIdMax to support more", "threadId < s_threadIdMax", 28) )
    __debugbreak();
  if ( !TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID) )
  {
    v2 = (hkMemoryRouter *)&s_threadMemoryRouterBuffer[120 * (unsigned int)v1];
    if ( v2 )
    {
      hkMemoryRouter::hkMemoryRouter(v2);
      v4 = v3;
    }
    else
    {
      v4 = NULL;
    }
    s_threadMemoryRouters[(unsigned int)v1] = v4;
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryRouter *, const char *, __int64))s_havokPhysicsMemorySystem->threadInit)(s_havokPhysicsMemorySystem, v4, "hkWorkerThreadContext", 3i64);
    hkBaseSystem::initThread(v4);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::resize(Value, 102400);
    TlsSetValue(hkThreadNumber.m_slotID, v1);
  }
}

/*
==============
HavokPhysics_OnThreadShutdown
==============
*/
void HavokPhysics_OnThreadShutdown(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryAllocator **v2; 
  hkMemoryAllocator *v3; 

  v1 = threadId;
  hkBaseSystem::quitThread();
  v2 = (hkMemoryAllocator **)&s_threadMemoryRouters[v1];
  v3 = *v2;
  if ( !*v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2847, ASSERT_TYPE_ASSERT, "(memoryRouter)", "%s\n\tHavokPhysics: Thread memory router is NULL", "memoryRouter") )
    __debugbreak();
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryAllocator *, __int64))s_havokPhysicsMemorySystem->threadQuit)(s_havokPhysicsMemorySystem, v3, 3i64);
  *v2 = NULL;
  hkMemoryAllocator::~hkMemoryAllocator(v3);
}

/*
==============
HavokPhysics_Particles_ConvexVsStaticModelTile
==============
*/
void HavokPhysics_Particles_ConvexVsStaticModelTile(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  StaticModels_HavokShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const StaticModels_HavokShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_PhysicsAssetSortByMemory
==============
*/
hkBool *HavokPhysics_PhysicsAssetSortByMemory(hkBool *result, const PhysicsAsset *a, const PhysicsAsset *b)
{
  result->m_bool = a->havokDataSize > b->havokDataSize;
  return result;
}

/*
==============
HavokPhysics_PhysicsAssetSortByName
==============
*/
hkBool *HavokPhysics_PhysicsAssetSortByName(hkBool *result, const PhysicsAsset *a, const PhysicsAsset *b)
{
  result->m_bool = I_stricmp(a->name, b->name) < 0;
  return result;
}

/*
==============
HavokPhysics_PreStepWorld
==============
*/

void __fastcall HavokPhysics_PreStepWorld(Physics_WorldId worldId, double timeStep)
{
  __int64 v3; 
  __int64 timeStepDebugHistoryStart; 
  int v7; 
  unsigned int unsignedInt; 
  Physics_DeferredBroadphaseCollisionQueryData *v11; 
  int v12; 
  int v13; 
  __int64 v16; 
  Physics_DeferredCollisionQueryData *v17; 
  Physics_DeferredCollisionQueryData *v18; 
  int v19; 
  int v20; 
  int v23; 
  float fmt; 
  float data; 
  hkAabb v30; 

  v3 = worldId;
  __asm
  {
    vmovaps [rsp+88h+var_28], xmm6
    vmovaps xmm6, xmm1
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5693, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to PreStepWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RDI = HavokPhysics_GetMutableWorld((Physics_WorldId)v3);
  EnterCriticalSection((LPCRITICAL_SECTION)&_RDI->deferredQueryCritSection);
  _RDI->activeQueryRequestList = 1 - _RDI->activeQueryRequestList;
  LeaveCriticalSection((LPCRITICAL_SECTION)&_RDI->deferredQueryCritSection);
  timeStepDebugHistoryStart = _RDI->timeStepDebugHistoryStart;
  v7 = 2 * v3;
  _RDI->stepCPUIndex = 0;
  unsignedInt = 0xFFFFFF;
  _RDI->lastFrameCPUTime = 0.0;
  _RDI->timeStepDebugHistoryRaw[timeStepDebugHistoryStart] = _RDI->timeStepDebugLastRawTimeStep;
  _RAX = _RDI->timeStepDebugHistoryStart;
  __asm { vmovss  dword ptr [rdi+rax*4+6A8h], xmm6 }
  _RDI->timeStepDebugHistoryStart = (_RDI->timeStepDebugHistoryStart + 1) % 300;
  if ( physics_debugQueryBody->current.integer >= 0 )
    unsignedInt = physics_debugQueryBody->current.unsignedInt;
  if ( _RDI->requestDebugAABBBroadphaseQuery )
  {
    __asm { vmovups ymm0, ymmword ptr [rdi+0C90h] }
    v11 = &s_havokPhysicsWorldAABBBroadphaseQueryData[v7 + s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v3]];
    __asm { vmovups [rsp+88h+var_48], ymm0 }
    HavokPhysics_DeferredAABBBroadphaseQuery((Physics_WorldId)v3, &v30, &_RDI->debugAABBBroadphaseQueryExtendedData, v11);
    _RDI->requestDebugAABBBroadphaseQuery = 0;
  }
  v12 = unsignedInt & 0xFFFFFF;
  if ( _RDI->requestDebugAABBQuery )
  {
    if ( v12 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader, unsignedInt) )
    {
      __asm { vmovups ymm0, ymmword ptr [rdi+0CD0h] }
      v16 = v7 + s_havokPhysicsWorldAABBQueryActiveIndices[v3];
      __asm { vmovups [rsp+88h+var_48], ymm0 }
      HavokPhysics_DeferredAABBQuery((Physics_WorldId)v3, &v30, &_RDI->debugAABBQueryExtendedData, &s_havokPhysicsWorldAABBQueryData[v16]);
    }
    else
    {
      v13 = s_havokPhysicsWorldAABBQueryActiveIndices[v3];
      __asm { vmovups ymm0, ymmword ptr [rdi+0CD0h] }
      _RDI->debugAABBQueryExtendedData.simplify = 0;
      __asm { vmovups [rsp+88h+var_48], ymm0 }
      HavokPhysics_DeferredAABBQuery((Physics_WorldId)v3, (hknpBodyId)unsignedInt, &v30, &_RDI->debugAABBQueryExtendedData, &s_havokPhysicsWorldAABBQueryData[v7 + v13]);
    }
    _RDI->requestDebugAABBQuery = 0;
  }
  if ( _RDI->requestDebugRaycast )
  {
    if ( v12 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader, unsignedInt) )
    {
      if ( physics_debugRayDetail->current.enabled )
        v18 = &s_havokPhysicsWorldRayDetailData[v7 + s_havokPhysicsWorldRayDetailActiveIndices[v3]];
      else
        v18 = &s_havokPhysicsWorldRayData[v7 + s_havokPhysicsWorldRayActiveIndices[v3]];
      v18->isComplete = 0;
      HavokPhysics_DeferredRaycast((Physics_WorldId)v3, &_RDI->debugRaycastStart, &_RDI->debugRaycastEnd, &_RDI->debugRaycastExtendedData, v18);
    }
    else
    {
      if ( physics_debugRayDetail->current.enabled )
        v17 = &s_havokPhysicsWorldRayDetailData[v7 + s_havokPhysicsWorldRayDetailActiveIndices[v3]];
      else
        v17 = &s_havokPhysicsWorldRayData[v7 + s_havokPhysicsWorldRayActiveIndices[v3]];
      v17->isComplete = 0;
      HavokPhysics_DeferredRaycast((Physics_WorldId)v3, (hknpBodyId)unsignedInt, &_RDI->debugRaycastStart, &_RDI->debugRaycastEnd, &_RDI->debugRaycastExtendedData, v17);
    }
    _RDI->requestDebugRaycast = 0;
  }
  if ( _RDI->requestDebugShapecast )
  {
    if ( v12 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader, unsignedInt) )
    {
      HavokPhysics_DeferredShapecast((Physics_WorldId)v3, _RDI->debugShapecastShape, &_RDI->debugShapecastStart, &_RDI->debugShapecastEnd, &_RDI->debugShapecastRotation, &_RDI->debugShapecastExtendedData, &s_havokPhysicsWorldShapeCastData[v7 + s_havokPhysicsWorldShapeCastActiveIndices[v3]]);
    }
    else
    {
      v19 = s_havokPhysicsWorldShapeCastActiveIndices[v3];
      _RDI->debugShapecastExtendedData.simplifyStart = 0;
      HavokPhysics_DeferredShapecast((Physics_WorldId)v3, (hknpBodyId)unsignedInt, _RDI->debugShapecastShape, &_RDI->debugShapecastStart, &_RDI->debugShapecastEnd, &_RDI->debugShapecastRotation, &_RDI->debugShapecastExtendedData, &s_havokPhysicsWorldShapeCastData[v7 + v19]);
    }
    _RDI->requestDebugShapecast = 0;
  }
  if ( _RDI->requestDebugQueryPoint )
  {
    if ( v12 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader, unsignedInt) )
    {
      __asm { vmovss  xmm2, dword ptr [rdi+0DE0h]; maxDistance }
      HavokPhysics_DeferredQueryPoint((Physics_WorldId)v3, &_RDI->debugQueryPointPoint, *(float *)&_XMM2, &_RDI->debugQueryPointExtendedData, &s_havokPhysicsWorldQueryPointData[v7 + s_havokPhysicsWorldQueryPointActiveIndices[v3]]);
    }
    else
    {
      v20 = s_havokPhysicsWorldQueryPointActiveIndices[v3];
      __asm { vmovss  xmm3, dword ptr [rdi+0DE0h]; maxDistance }
      _RDI->debugQueryPointExtendedData.simplify = 0;
      HavokPhysics_DeferredQueryPoint((Physics_WorldId)v3, (hknpBodyId)unsignedInt, &_RDI->debugQueryPointPoint, *(float *)&_XMM3, &_RDI->debugQueryPointExtendedData, &s_havokPhysicsWorldQueryPointData[v7 + v20]);
    }
    _RDI->requestDebugQueryPoint = 0;
  }
  if ( _RDI->requestDebugGetClosestPoints )
  {
    if ( v12 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))_RDI->world->isBodyValid)(&_RDI->world->hknpWorldReader, unsignedInt) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+0E30h]
        vmovss  dword ptr [rsp+88h+fmt], xmm0
      }
      HavokPhysics_DeferredGetClosestPoints((Physics_WorldId)v3, _RDI->debugGetClosestPointsShape, &_RDI->debugGetClosestPointsPoint, &_RDI->debugGetClosestPointsRotation, fmt, &_RDI->debugGetClosestPointsExtendedData, &s_havokPhysicsWorldGetClosestPointsData[v7 + s_havokPhysicsWorldGetClosestPointsActiveIndices[v3]]);
    }
    else
    {
      v23 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v3];
      __asm { vmovss  xmm0, dword ptr [rdi+0E30h] }
      _RDI->debugGetClosestPointsExtendedData.simplify = 0;
      __asm { vmovss  dword ptr [rsp+88h+data], xmm0 }
      HavokPhysics_DeferredGetClosestPoints((Physics_WorldId)v3, (hknpBodyId)unsignedInt, _RDI->debugGetClosestPointsShape, &_RDI->debugGetClosestPointsPoint, &_RDI->debugGetClosestPointsRotation, data, &_RDI->debugGetClosestPointsExtendedData, &s_havokPhysicsWorldGetClosestPointsData[v7 + v23]);
    }
    _RDI->requestDebugGetClosestPoints = 0;
  }
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
}

/*
==============
HavokPhysics_ProcessDeferredForce
==============
*/
void HavokPhysics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletForce,hkContainerHeapAllocator> *m_deferredBulletForceEntries; 
  HavokPhysicsDeferredBulletForce *i; 
  hkArray<HavokPhysicsDeferredRadiusForce,hkContainerHeapAllocator> *m_deferredRadiusForceEntries; 
  float fmt; 
  float weapon; 
  Physics_WorldId isAlternate; 
  float effectCallback; 

  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForce");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    isAlternate = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13038, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", isAlternate) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  for ( i = m_deferredBulletForceEntries->m_data; i != &m_deferredBulletForceEntries->m_data[m_deferredBulletForceEntries->m_size]; ++i )
  {
    Physics_ApplyBulletForce(worldId, &i->start, &i->end, i->inflictorEntNum, i->isMelee, &i->weapon, i->isAlternate, i->mod, i->effectCallback);
    m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  }
  m_deferredRadiusForceEntries = MutableWorld->m_deferredRadiusForceEntries;
  _RBX = m_deferredRadiusForceEntries->m_data;
  if ( m_deferredRadiusForceEntries->m_data != &m_deferredRadiusForceEntries->m_data[m_deferredRadiusForceEntries->m_size] )
  {
    do
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+2Ch]
        vmovss  xmm1, dword ptr [rbx+14h]
        vmovss  xmm3, dword ptr [rbx+10h]; innerDamage
        vmovss  xmm2, dword ptr [rbx+0Ch]; radius
        vmovss  [rsp+58h+effectCallback], xmm0
        vmovss  xmm0, dword ptr [rbx+18h]
        vmovss  dword ptr [rsp+58h+weapon], xmm0
        vmovss  dword ptr [rsp+58h+fmt], xmm1
      }
      Physics_ApplyRadiusForce(worldId, &_RBX->position, *(const float *)&_XMM2, *(const float *)&_XMM3, fmt, weapon, &_RBX->impulseVecOverride, _RBX->randSeed, effectCallback);
      ++_RBX;
    }
    while ( _RBX != &MutableWorld->m_deferredRadiusForceEntries->m_data[MutableWorld->m_deferredRadiusForceEntries->m_size] );
    m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  }
  m_deferredBulletForceEntries->m_size = 0;
  MutableWorld->m_deferredRadiusForceEntries->m_size = 0;
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProcessDeferredForceCallbacks
==============
*/
void HavokPhysics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletEffectCallback,hkContainerHeapAllocator> *m_deferredBulletEffectEntries; 
  __int64 v16; 
  Physics_WorldId v17; 
  BOOL v18; 
  int v19; 
  int v20; 
  int v21; 
  int v22; 
  int v23; 
  int v24; 
  int v25; 
  int v26; 
  int v27; 

  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForceCallbacks");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v17 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13076, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred force callbackswith invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v17) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  for ( _RBX = m_deferredBulletEffectEntries->m_data; _RBX != &m_deferredBulletEffectEntries->m_data[m_deferredBulletEffectEntries->m_size]; ++_RBX )
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForceCallback");
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+14h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v19 & 0x7F800000) == 2139095040 )
      goto LABEL_27;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+18h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v20 & 0x7F800000) == 2139095040 )
      goto LABEL_27;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+1Ch]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v21 & 0x7F800000) == 2139095040 )
    {
LABEL_27:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13089, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.start[0] ) && !IS_NAN( entry.start[1] ) && !IS_NAN( entry.start[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.start[0] ) && !IS_NAN( entry.start[1] ) && !IS_NAN( entry.start[2] )") )
        __debugbreak();
    }
    _RSI = &_RBX->hitPos;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v22 & 0x7F800000) == 2139095040 )
      goto LABEL_28;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+24h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v23 & 0x7F800000) == 2139095040 )
      goto LABEL_28;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v24 & 0x7F800000) == 2139095040 )
    {
LABEL_28:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13090, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.hitPos[0] ) && !IS_NAN( entry.hitPos[1] ) && !IS_NAN( entry.hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.hitPos[0] ) && !IS_NAN( entry.hitPos[1] ) && !IS_NAN( entry.hitPos[2] )") )
        __debugbreak();
    }
    _RDI = &_RBX->hitNormal;
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v25 & 0x7F800000) == 2139095040 )
      goto LABEL_29;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+34h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v26 & 0x7F800000) == 2139095040 )
      goto LABEL_29;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+38h]
      vmovss  [rsp+88h+arg_0], xmm0
    }
    if ( (v27 & 0x7F800000) == 2139095040 )
    {
LABEL_29:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13091, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.hitNormal[0] ) && !IS_NAN( entry.hitNormal[1] ) && !IS_NAN( entry.hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.hitNormal[0] ) && !IS_NAN( entry.hitNormal[1] ) && !IS_NAN( entry.hitNormal[2] )") )
        __debugbreak();
    }
    if ( !_RBX->effectCallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13093, ASSERT_TYPE_ASSERT, "(entry.effectCallback)", (const char *)&queryFormat, "entry.effectCallback") )
      __debugbreak();
    LOBYTE(v18) = _RBX->isAlternate;
    LODWORD(v16) = _RBX->hitSurfaceFlags;
    _RBX->effectCallback((const LocalClientNum_t)_RBX->localClientNum, _RBX->hitBodyId.m_serialAndIndex, _RBX->shapeKey, &_RBX->start, &_RBX->hitPos, v16, &_RBX->hitNormal, &_RBX->partName, _RBX->inflictorEntNum, &_RBX->weapon, v18, _RBX->mod);
    Sys_ProfEndNamedEvent();
    m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  }
  m_deferredBulletEffectEntries->m_size = 0;
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProcessDeferredKeyframe
==============
*/

void __fastcall HavokPhysics_ProcessDeferredKeyframe(const Physics_WorldId worldId, double velocityScale)
{
  char v7; 
  char v8; 
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredKeyframeInstance,hkContainerHeapAllocator> *m_deferredKeyframeInstanceEntries; 
  HavokPhysicsDeferredKeyframeInstance *i; 
  float fmt; 
  Physics_WorldId updateBroadphaseIfWarping; 
  float v16; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps xmm6, xmm1
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredKeyframe");
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm6, xmm7
  }
  if ( v7 | v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13009, ASSERT_TYPE_ASSERT, "(velocityScale > 0.0f)", "%s\n\tHavok Physics: Trying to process deferred keyframe with invalid velocityScale", "velocityScale > 0.0f") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    updateBroadphaseIfWarping = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13010, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred keyframe with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", updateBroadphaseIfWarping) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  for ( i = m_deferredKeyframeInstanceEntries->m_data; i != &m_deferredKeyframeInstanceEntries->m_data[m_deferredKeyframeInstanceEntries->m_size]; ++i )
  {
    __asm
    {
      vmovss  [rsp+68h+var_30], xmm7
      vmovss  dword ptr [rsp+68h+fmt], xmm6
    }
    Physics_KeyframeInstanceTo(worldId, i->instanceId, &i->origin, &i->orientationAsQuat, fmt, 1, 0, v16);
    m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  }
  m_deferredKeyframeInstanceEntries->m_size = 0;
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProfileEnd
==============
*/
void HavokPhysics_ProfileEnd()
{
  ;
}

/*
==============
HavokPhysics_ProfileStart
==============
*/
void HavokPhysics_ProfileStart(const char *name)
{
  ;
}

/*
==============
HavokPhysics_QueryHitSort
==============
*/
hkBool *HavokPhysics_QueryHitSort(hkBool *result, hknpCollisionResult *a, hknpCollisionResult *b)
{
  char v3; 

  __asm
  {
    vmovss  xmm0, dword ptr [rdx+20h]
    vcomiss xmm0, dword ptr [r8+20h]
  }
  result->m_bool = v3;
  return result;
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, const hkVector4f *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v19; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v22; 
  int v23; 
  int v24; 
  hknpCollisionResult *v25; 
  __int64 v27; 
  hknpBodyId *v33; 
  int Ref; 
  int v35; 
  unsigned int v36; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v38; 
  __int64 v41; 
  __int64 v42; 
  hknpCollisionResult *array; 
  int v44; 
  int v45; 
  int v46; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v51; 
  __int64 v52[2]; 
  __int16 v53; 
  int contents; 
  int *v55; 
  int v56; 
  char v57; 
  char v60; 
  void *retaddr; 

  _R11 = &retaddr;
  v51 = -2i64;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  _RBX = extendedData;
  __asm { vmovaps xmm6, xmm2 }
  _R14 = point;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+128h+var_D0], xmm0
  }
  ignoreBodies = NULL;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm { vmovdqu [rsp+128h+var_B8], xmm0 }
  phaseSelection = All;
  v57 = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14303, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire point query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14304, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire point query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14305, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire point query with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = _RBX->ignoreBodies;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+14h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rsp+128h+var_D0], xmm1
  }
  characterProxyType = _RBX->characterProxyType;
  phaseSelection = _RBX->phaseSelection;
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups [rsp+128h+var_68], xmm0
    vmovss  [rsp+128h+var_58], xmm6
  }
  v52[0] = (__int64)s_shapeTagCodec;
  v52[1] = *ConstWorld;
  v53 = -1;
  contents = _RBX->contents;
  v55 = &v46;
  v56 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14326, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14329, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryPoint_HK");
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok QueryPoint");
  (*(void (__fastcall **)(__int64, __int64 *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 336i64))(ConstWorld[3] + 32, v52, Collector);
  Sys_ProfEndNamedEvent();
  v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v19 )
    hkMonitorStream::timerEnd(v19, "Et");
  if ( _RBX->simplify )
  {
    array = NULL;
    v44 = 0;
    v45 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v22 = hkMemHeapAllocator();
    v23 = 0;
    if ( (int)NumHits > 0 )
    {
      v24 = NumHits;
      if ( (int)NumHits < 0 )
        v24 = 0;
      hkArrayUtil::_reserve(v22, &array, v24, 112);
      v23 = v44;
    }
    v25 = array;
    _RCX = (char *)&array[v23];
    v27 = NumHits;
    if ( (int)NumHits > 0 )
    {
      _RBX = (char *)Hits - _RCX;
      do
      {
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbx+rcx]
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr [rbx+rcx+20h]
            vmovups ymmword ptr [rcx+20h], ymm1
            vmovups ymm0, ymmword ptr [rbx+rcx+40h]
            vmovups ymmword ptr [rcx+40h], ymm0
            vmovups xmm1, xmmword ptr [rbx+rcx+60h]
            vmovups xmmword ptr [rcx+60h], xmm1
          }
        }
        _RCX += 112;
        --v27;
      }
      while ( v27 );
      v25 = array;
    }
    v44 = NumHits;
    if ( (int)NumHits > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v25, 0, NumHits - 1, HavokPhysics_QueryHitSort);
    Collector->reset(Collector);
    v33 = (hknpBodyId *)array;
    if ( array != &array[v44] )
    {
      do
      {
        Ref = HavokPhysics_GetRef(result->m_worldId, v33[18]);
        v35 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
        v36 = 0;
        if ( v35 <= 0 )
        {
LABEL_40:
          Collector->addHit(Collector, (const hknpCollisionResult *)v33);
        }
        else
        {
          while ( 1 )
          {
            if ( v36 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
            {
              LODWORD(v42) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
              LODWORD(v41) = v36;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v41, v42) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v36);
            if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v36 >= v35 )
              goto LABEL_40;
          }
        }
        v33 += 28;
      }
      while ( v33 != (hknpBodyId *)&array[v44] );
    }
    v38 = hkMemHeapAllocator();
    v44 = 0;
    if ( v45 >= 0 )
      hkMemoryAllocator::bufFree2(v38, array, 112, v45 & 0x3FFFFFFF);
  }
  _R11 = &v60;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  const hknpBody *v24; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v30; 
  hkMonitorStream *v31; 
  hkMonitorStream *v36; 
  __int64 v40; 
  __int128 v41; 
  __int16 v42; 
  int contents; 
  int *v44; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v46; 
  hkReferencedObject *v47; 
  int v49; 
  int v50; 
  __int64 v51; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int128 v55; 
  __int64 v56; 
  hkMonitorStream *v57; 
  HavokPhysicsShapeTagCodec *v58; 
  HavokPhysicsCollisionFilter *traceCollisionFilter; 
  __int16 v60; 
  int v61; 
  int *v62; 
  int v63; 
  char v64; 
  __int128 v67; 
  __int64 v68; 
  int v69; 
  int v70; 
  __int128 v71; 
  char v72; 
  int v73; 
  hknpInplaceTriangleShape v77; 
  char v78; 
  void *retaddr; 

  _RAX = &retaddr;
  v56 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmm7, xmm3
  }
  _R12 = point;
  _RSI = extendedData;
  v42 = -1;
  contents = 0;
  v44 = NULL;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v77, *(float *)&_XMM1);
  m_collisionQueryDispatcher = NULL;
  v46 = (hkReferencedObject *)&v77;
  v47 = (hkReferencedObject *)&v77;
  __asm { vmovss  [rsp+2E0h+var_268], xmm6 }
  v49 = 1;
  v69 = -1;
  v70 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+1E0h+var_1C0], xmm0
  }
  v68 = 0i64;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu [rbp+1E0h+var_1A0], xmm1
  }
  v72 = 0;
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups [rbp+1E0h+var_180], xmm0
  }
  v73 = 0;
  __asm
  {
    vmovups [rbp+1E0h+var_170], xmm1
    vmovss  [rbp+1E0h+var_188], xmm6
  }
  LOWORD(v41) = -1;
  DWORD1(v41) = 0;
  *((_QWORD *)&v41 + 1) = 0i64;
  __asm { vmovss  [rbp+1E0h+var_260], xmm6 }
  v51 = 0i64;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+1E0h+var_248], xmm0
  }
  phaseSelection = All;
  v60 = -1;
  v61 = 0;
  v62 = NULL;
  traceCollisionFilter = NULL;
  v58 = NULL;
  v63 = 2;
  v64 = -5;
  __asm
  {
    vmovups [rbp+1E0h+var_1E0], xmm1
    vmovss  [rbp+1E0h+var_1D0], xmm6
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15103, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v40) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15104, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire querypoint with body with invalid body id %i", "bodyId.isValid()", v40) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15105, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15106, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire point query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15107, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire point query with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15108, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15109, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid collector", "result->m_collector") )
    __debugbreak();
  _RDI = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15112, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v24 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = v24->m_shape;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+14h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+1E0h+var_260], xmm1
  }
  characterProxyType = extendedData->characterProxyType;
  phaseSelection = extendedData->phaseSelection;
  v42 = -1;
  contents = extendedData->contents;
  v44 = &v50;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, POINT_QUERY, (const hknpQueryFilterData *)&v42, v24) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(_QWORD *)&v67 = v24;
    *((_QWORD *)&v67 + 1) = v24->m_shape;
    *(_QWORD *)&v71 = v24;
    LOWORD(v41) = v24->m_materialId.m_value;
    DWORD1(v41) = v24->m_collisionFilterInfo;
    *((_QWORD *)&v41 + 1) = v24->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, POINT_QUERY, v24, m_shape, (hknpQueryFilterData *)&v41);
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups [rbp+1E0h+var_1E0], xmm0
      vmovss  [rbp+1E0h+var_1D0], xmm7
    }
    v58 = s_shapeTagCodec;
    traceCollisionFilter = ConstWorld->traceCollisionFilter;
    v61 = extendedData->contents;
    v62 = &v50;
    v63 = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtQueryPoint_Body_HK");
    v30 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v31 = v30;
    if ( v30 )
      hkMonitorStream::timerBegin(v30, "TtQueryPoint");
    v57 = v31;
    __asm
    {
      vmovups xmm0, [rsp+2E0h+var_2A8+8]
      vmovdqa [rbp+1E0h+var_230], xmm0
    }
    if ( v58 && (v58->m_hints.m_storage & 1) != 0 )
      v58->overrideInitialFilterData(v58, POINT_QUERY, (const hknpBody *)v67, m_shape, (hknpQueryFilterData *)&v55);
    __asm
    {
      vbroadcastss xmm3, [rbp+1E0h+var_1D0]
      vmovups xmm0, xmmword ptr [rdi+10h]
      vminps  xmm1, xmm0, xmm3
      vmovups xmmword ptr [rdi+10h], xmm1
    }
    m_shape->queryPointImpl((hknpShape *)m_shape, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, (const hknpPointQuery *)&v58, (const hknpQueryFilterData *)&v55, (const hknpShapeQueryInfo *)&v67, _RDI);
    if ( v31 )
      hkMonitorStream::timerEnd(v31, "Et");
    v36 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v36 )
      hkMonitorStream::timerEnd(v36, "Et");
    if ( !v49 )
    {
      hkReferencedObject::removeReference(v46);
      hkReferencedObject::removeReference(v47);
    }
  }
  else if ( !v49 )
  {
    hkReferencedObject::removeReference(v46);
    hkReferencedObject::removeReference(v47);
  }
  _R11 = &v78;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
HavokPhysics_Raycast
==============
*/
void HavokPhysics_Raycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 ignoreBodies; 
  const HavokPhysicsWorld *v17; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v33; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v36; 
  int v37; 
  __int64 v38; 
  int v39; 
  Physics_QueryPhaseSelection phaseSelection; 
  hknpRayCastQuery query; 

  query.m_broadPhaseFilterMask = -5;
  _RDI = extendedData;
  query.m_flags.m_storage = 0;
  _R12 = end;
  _R15 = start;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rsp+128h+var_D0], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13958, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13959, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire raycast with invalid result", "result") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13960, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire raycast with invalid extended data", "extendedData") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+14h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmm5, xmmword ptr [r15]
  }
  ignoreBodies = (__int64)_RDI->ignoreBodies;
  v17 = ConstWorld;
  __asm
  {
    vmovss  [rsp+128h+var_E8], xmm1
    vsubps  xmm1, xmm0, xmm5
    vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
    vxorps  xmm4, xmm4, xmm4
    vcmpeqps xmm0, xmm4, xmm2
    vandnps xmm1, xmm0, xmm2
    vrcpps  xmm3, xmm1
    vmulps  xmm2, xmm3, xmm1
    vcmpeqps xmm0, xmm4, xmm1
    vmovups xmm4, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
  }
  v38 = ignoreBodies;
  LODWORD(ignoreBodies) = _RDI->characterProxyType;
  __asm
  {
    vmovups xmmword ptr [rsp+128h+query.m_ray.m_direction.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
    vsubps  xmm2, xmm1, xmm2
  }
  v39 = ignoreBodies;
  __asm { vmulps  xmm3, xmm2, xmm3 }
  phaseSelection = _RDI->phaseSelection;
  insideHitType = _RDI->insideHitType;
  __asm
  {
    vblendvps xmm1, xmm3, xmm4, xmm0
    vmovups xmmword ptr [rsp+128h+query.m_ray.m_invDirection.m_quad], xmm1
    vmovups xmmword ptr [rsp+128h+query.m_ray.m_origin.m_quad], xmm5
  }
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v33 = 4;
  }
  else
  {
    v33 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v33 = 8;
  }
  query.m_flags.m_storage = v33;
  if ( _RDI->disableBackFacingTriangleHits )
    query.m_flags.m_storage = v33 | 1;
  HavokPhysicsHitCollector::EnableInsideHits(result->m_collector, _RDI->collectInsideHits);
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = v17->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = _RDI->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v37;
  *(_DWORD *)query.m_levelOfDetail = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13994, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(result->m_collector, _R15, _R12, &query);
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14000, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtRaytrace_HK");
  v17->world->castRay(&v17->world->hknpWorldReader, &query, Collector);
  v36 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v36 )
    hkMonitorStream::timerEnd(v36, "Et");
}

/*
==============
HavokPhysics_Raycast
==============
*/
void HavokPhysics_Raycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  const hknpShape *m_shape; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v61; 
  hkMonitorStream *Value; 
  __int128 *v67; 
  hkMonitorStream *v68; 
  __int64 v73; 
  __int128 v74; 
  __int16 v75; 
  int contents; 
  int *v77; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v79; 
  hkReferencedObject *v80; 
  int v82; 
  __int128 v83; 
  int v84; 
  __int64 v85; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v89; 
  hknpRayCastQuery query; 
  __int128 v91; 
  __int64 v92; 
  int v93; 
  int v94; 
  __int128 v95; 
  char v96; 
  int v97; 
  hknpInplaceTriangleShape v101; 
  char v102; 
  void *retaddr; 

  _RAX = &retaddr;
  v89 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  *(_QWORD *)&v83 = end;
  _R12 = start;
  _RDI = extendedData;
  v75 = -1;
  contents = 0;
  v77 = NULL;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v101, *(float *)&_XMM1);
  m_collisionQueryDispatcher = NULL;
  v79 = (hkReferencedObject *)&v101;
  v80 = (hkReferencedObject *)&v101;
  __asm { vmovss  [rsp+310h+var_298], xmm6 }
  v82 = 1;
  v93 = -1;
  v94 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+210h+var_1D0], xmm0
  }
  v92 = 0i64;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu [rbp+210h+var_1B0], xmm1
  }
  v96 = 0;
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups [rbp+210h+var_190], xmm0
  }
  v97 = 0;
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vmovups [rbp+210h+var_180], xmm8
    vmovss  [rbp+210h+var_198], xmm6
  }
  LOWORD(v74) = -1;
  DWORD1(v74) = 0;
  *((_QWORD *)&v74 + 1) = 0i64;
  __asm { vmovss  [rbp+210h+var_280], xmm6 }
  v85 = 0i64;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+210h+var_268], xmm0
  }
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_flags.m_storage = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14702, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v73) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14703, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid body id %i", "bodyId.isValid()", v73) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14704, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14705, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire raycast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14706, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14707, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(result->m_collector, _R12, end, &query);
  _RSI = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14713, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  _R13 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = _R13->m_shape;
  characterProxyType = extendedData->characterProxyType;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+14h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rbp+210h+var_280], xmm1
  }
  phaseSelection = extendedData->phaseSelection;
  v75 = -1;
  contents = extendedData->contents;
  v77 = &v84;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, RAY_CAST, (const hknpQueryFilterData *)&v75, _R13) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(_QWORD *)&v91 = _R13;
    *((_QWORD *)&v91 + 1) = _R13->m_shape;
    *(_QWORD *)&v95 = _R13;
    LOWORD(v74) = _R13->m_materialId.m_value;
    DWORD1(v74) = _R13->m_collisionFilterInfo;
    *((_QWORD *)&v74 + 1) = _R13->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, RAY_CAST, _R13, m_shape, (hknpQueryFilterData *)&v74);
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vsubps  xmm1, xmm0, xmmword ptr [r13+30h]
      vmovups xmm3, xmmword ptr [r13+0]
      vmovups xmm4, xmmword ptr [r13+10h]
      vmovups xmm6, xmmword ptr [r13+20h]
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
      vorps   xmm0, xmm0, xmm2
      vorps   xmm7, xmm1, xmm0
    }
    _RAX = v83;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vsubps  xmm1, xmm0, xmmword ptr [r13+30h]
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
      vorps   xmm0, xmm0, xmm2
      vorps   xmm1, xmm1, xmm0
      vsubps  xmm2, xmm1, xmm7
      vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
      vcmpeqps xmm0, xmm3, xmm8
      vandnps xmm4, xmm0, xmm3
      vcmpeqps xmm0, xmm4, xmm8
      vrcpps  xmm3, xmm4
      vmulps  xmm2, xmm3, xmm4
      vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
      vsubps  xmm2, xmm1, xmm2
      vmulps  xmm3, xmm2, xmm3
      vmovups xmm1, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
      vblendvps xmm2, xmm3, xmm1, xmm0
      vmovups xmmword ptr [rbp+210h+query.m_ray.m_direction.m_quad], xmm4
      vmovups xmmword ptr [rbp+210h+query.m_ray.m_invDirection.m_quad], xmm2
      vmovups xmmword ptr [rbp+210h+query.m_ray.m_origin.m_quad], xmm7
    }
    insideHitType = extendedData->insideHitType;
    if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
    {
      v61 = 4;
    }
    else
    {
      v61 = 0;
      if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
        v61 = 8;
    }
    query.m_flags.m_storage = v61;
    if ( extendedData->disableBackFacingTriangleHits )
      query.m_flags.m_storage = v61 | 1;
    HavokPhysicsHitCollector::EnableInsideHits(result->m_collector, extendedData->collectInsideHits);
    query.m_shapeTagCodec = s_shapeTagCodec;
    query.m_filter = ConstWorld->traceCollisionFilter;
    query.m_filterData.m_materialId.m_value = -1;
    query.m_filterData.m_collisionFilterInfo = extendedData->contents;
    query.m_filterData.m_userData = (unsigned __int64)&v84;
    *(_DWORD *)query.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtRaycast_Body_HK");
    __asm
    {
      vbroadcastss xmm1, dword ptr [rbp+210h+query.m_ray.m_direction.m_quad+0Ch]
      vmovups xmm0, xmmword ptr [rsi+10h]
      vminps  xmm1, xmm0, xmm1
      vmovups xmmword ptr [rsi+10h], xmm1
    }
    if ( query.m_shapeTagCodec && (query.m_shapeTagCodec->m_hints.m_storage & 1) != 0 )
    {
      __asm
      {
        vmovups xmm0, [rsp+310h+var_2D8+8]
        vmovdqa [rbp+210h+var_290], xmm0
      }
      query.m_shapeTagCodec->overrideInitialFilterData((hknpShapeTagCodec *)query.m_shapeTagCodec, RAY_CAST, (const hknpBody *)v91, m_shape, (hknpQueryFilterData *)&v83);
      v67 = &v83;
    }
    else
    {
      v67 = &v74;
    }
    m_shape->castRayImpl((hknpShape *)m_shape, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, &query, (const hknpQueryFilterData *)v67, (const hknpShapeQueryInfo *)&v91, _RSI);
    v68 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v68 )
      hkMonitorStream::timerEnd(v68, "Et");
    if ( !v82 )
    {
      hkReferencedObject::removeReference(v79);
      hkReferencedObject::removeReference(v80);
    }
  }
  else if ( !v82 )
  {
    hkReferencedObject::removeReference(v79);
    hkReferencedObject::removeReference(v80);
  }
  _R11 = &v102;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
HavokPhysics_ReadWorld
==============
*/
void HavokPhysics_ReadWorld(SaveGame *save, Physics_WorldId worldId, HavokPhysics_SnapshotFixup *snapshotFixup)
{
  unsigned int v5; 
  unsigned int v6; 
  unsigned int WorldTransientCount; 
  char v8; 
  MemoryFile *p_memFile; 
  const char *WorldTransientName; 
  const char *v11; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  int v15; 
  __int64 v16; 
  int v17; 
  int v18; 
  int v19; 
  __int64 v20; 
  __int64 v21; 
  char v22[16]; 
  bool p; 
  char v24; 
  bool v25; 

  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4148, ASSERT_TYPE_ASSERT, "(save)", "%s\n\tHavokPhysics: ReadWorld has NULL save", "save") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4149, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to ReadWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !HavokPhysics_GetMutableWorld(worldId)->world )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4153, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteWorld %i: world is NULL", "physicsWorld->world", v20) )
      __debugbreak();
  }
  v5 = 0;
  v6 = 0;
  WorldTransientCount = 1;
  v8 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END|0x80);
  v24 = v8;
  if ( v8 )
  {
    v6 = 32;
    WorldTransientCount = DB_Transients_GetWorldTransientCount();
    v8 = v24;
  }
  if ( v6 )
  {
    p_memFile = &save->memFile;
    do
    {
      if ( v8 && v5 < WorldTransientCount )
      {
        WorldTransientName = DB_Transients_GetWorldTransientName(v5);
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4184, ASSERT_TYPE_ASSERT, "(zoneName)", (const char *)&queryFormat, "zoneName") )
          __debugbreak();
        MemFile_ReadData(p_memFile, 1ui64, &p);
        flag = p;
        if ( !p )
        {
          LODWORD(v20) = v5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4188, ASSERT_TYPE_ASSERT, "(flag)", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is valid, but wasn't at save time", "flag", v20) )
            __debugbreak();
        }
        name = MemFile_ReadCString(p_memFile);
        v11 = name;
        v12 = 0x7FFFFFFFi64;
        v13 = WorldTransientName;
        if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v14 = v11 - WorldTransientName;
        do
        {
          v15 = (unsigned __int8)v13[v14];
          v16 = v12;
          v17 = *(unsigned __int8 *)v13++;
          --v12;
          if ( !v16 )
            break;
          if ( v15 != v17 )
          {
            v18 = v15 + 32;
            if ( (unsigned int)(v15 - 65) > 0x19 )
              v18 = v15;
            v15 = v18;
            v19 = v17 + 32;
            if ( (unsigned int)(v17 - 65) > 0x19 )
              v19 = v17;
            if ( v15 != v19 )
            {
              LODWORD(v20) = v5;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4190, ASSERT_TYPE_ASSERT, "(!I_stricmp( name, zoneName ))", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is %s, but was %s at save time", "!I_stricmp( name, zoneName )", v20, WorldTransientName, name) )
                __debugbreak();
              break;
            }
          }
        }
        while ( v15 );
        MemFile_ReadData(p_memFile, 1ui64, &v25);
        gameLoaded = v25;
        if ( gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded(v5) )
          goto LABEL_43;
        LODWORD(v21) = gameLoaded;
        LODWORD(v20) = v5;
        if ( !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4192, ASSERT_TYPE_ASSERT, "(gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded( zoneIt ))", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i gameloaded state is %i, but was different at save time", "gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded( zoneIt )", v20, v21) )
          goto LABEL_43;
      }
      else
      {
        MemFile_ReadData(p_memFile, 1ui64, v22);
        flag = v22[0];
        if ( !v22[0] )
          goto LABEL_43;
        LODWORD(v20) = v5;
        if ( !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4197, ASSERT_TYPE_ASSERT, "(!flag)", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is invalid, but was valid at save time", "!flag", v20) )
          goto LABEL_43;
      }
      __debugbreak();
LABEL_43:
      v8 = v24;
      ++v5;
    }
    while ( v5 < v6 );
  }
}

/*
==============
HavokPhysics_ReleaseMapLocalAllocatorBuffer
==============
*/
void HavokPhysics_ReleaseMapLocalAllocatorBuffer(void)
{
  if ( !s_havokPhysicsMemorySystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2906, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMemorySystem ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMemorySystem", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2907, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMapLocalLargeBlockAllocator ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMapLocalLargeBlockAllocator", "nullptr", NULL, NULL) )
    __debugbreak();
  *(_QWORD *)&s_mapLocalMemoryCapacity = 0i64;
  HavokPhysicsFreeListMemorySystem::garbageCollectMapLocal(s_havokPhysicsMemorySystem, 1);
  HavokPhysicsLargeBlockAllocator::releaseBuffer(s_havokPhysicsMapLocalLargeBlockAllocator);
}

/*
==============
HavokPhysics_ReleasePhysicsAsset
==============
*/
void HavokPhysics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v3; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  unsigned int v7; 
  Dummy *v8; 
  PhysicsAsset *key; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7471, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tTrying to remove a NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7472, ASSERT_TYPE_ASSERT, "(physicsAsset->havokData)", "%s\n\tTrying to remove a Physics Asset with NULL data", "physicsAsset->havokData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7473, ASSERT_TYPE_ASSERT, "(physicsAsset->havokDataSize > 0)", "%s\n\tTrying to remove a Physics Asset with 0 data size", "physicsAsset->havokDataSize > 0") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  v3 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7478, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Release a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v3 = s_havokPhysicsAssets;
  }
  m_hashMod = v3->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v6 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v7 = m_hashMod & (v5 ^ ((v6 >> 2) + v6 + (v5 << 6) - 1640531527)), v8 = (Dummy *)v7, key = (PhysicsAsset *)v3->m_map.m_elem[v7].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_18:
    v8 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != physicsAsset )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = (Dummy *)v7;
      key = (PhysicsAsset *)v3->m_map.m_elem[v7].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_18;
    }
  }
  if ( (int)v8 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7479, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->remove( physicsAsset ).isSuccess())", (const char *)&queryFormat, "s_havokPhysicsAssets->remove( physicsAsset ).isSuccess()") )
      __debugbreak();
  }
  else
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v3->m_map, v8);
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_ReleasePhysicsLibrary
==============
*/
void HavokPhysics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  int i; 
  int j; 
  hkArray<char,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  int m_capacityAndFlags; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "HavokPhysics_ReleasePhysicsLibrary");
  if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6907, ASSERT_TYPE_ASSERT, "(physicsLibrary)", "%s\n\tTrying to release a NULL Physics Library", "physicsLibrary") )
    __debugbreak();
  if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6908, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokData)", "%s\n\tTrying to release a Physics Library with NULL data", "physicsLibrary->havokData") )
    __debugbreak();
  if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6909, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokDataSize > 0)", "%s\n\tTrying to release a Physics Library with 0 data size", "physicsLibrary->havokDataSize > 0") )
    __debugbreak();
  if ( physicsLibrary->isBodyQualityList )
  {
    if ( !s_havokPhysicsBodyQualityLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6914, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list != nullptr)", "%s\n\tExpecting a Havok Body Quality library", "s_havokPhysicsBodyQualityLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsBodyQualityLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6915, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Body Quality library asset", "s_havokPhysicsBodyQualityLibrary.asset == physicsLibrary") )
      __debugbreak();
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr cs:s_havokPhysicsBodyQualityLibrary.asset, xmm0
    }
  }
  else if ( physicsLibrary->isMaterialList )
  {
    if ( !s_havokPhysicsMaterialLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6927, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list != nullptr)", "%s\n\tExpecting a Havok Material library", "s_havokPhysicsMaterialLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsMaterialLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6928, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Material library asset", "s_havokPhysicsMaterialLibrary.asset == physicsLibrary") )
      __debugbreak();
    for ( i = 7; i >= 0; --i )
      HavokPhysics_RemoveMaterialLibraryFromWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)i);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr cs:s_havokPhysicsMaterialLibrary.asset, xmm0
    }
    *(_DWORD *)&s_havokPhysicsMaterialLibrary.firstId.m_value = -1;
  }
  else if ( physicsLibrary->isMotionPropertiesList )
  {
    if ( !s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6942, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list != nullptr)", "%s\n\tExpecting a Havok Motion Properties library", "s_havokPhysicsMotionPropertiesLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsMotionPropertiesLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6943, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Motion Properties library asset", "s_havokPhysicsMotionPropertiesLibrary.asset == physicsLibrary") )
      __debugbreak();
    for ( j = 7; j >= 0; --j )
      HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)j);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr cs:s_havokPhysicsMotionPropertiesLibrary.asset, xmm0
    }
    *(_DWORD *)&s_havokPhysicsMotionPropertiesLibrary.firstId.m_value = -1;
  }
  else if ( physicsLibrary->isGlobalTypeCompendium )
  {
    if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6958, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
      __debugbreak();
    hkSerialize::InplaceLoad::~InplaceLoad(s_havokPhysicsInPlaceLoad);
    s_havokPhysicsInPlaceLoad = NULL;
    if ( !s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6964, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", NULL, NULL) )
      __debugbreak();
    s_havokPhysicsGlobalTypeCompendiumTypes = NULL;
    if ( !s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6969, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", NULL, NULL) )
      __debugbreak();
    v8 = s_havokPhysicsGlobalTypeCompendiumData;
    v9 = hkMemHeapAllocator();
    v8->m_size = 0;
    m_capacityAndFlags = v8->m_capacityAndFlags;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v9, v8->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
    v8->m_data = NULL;
    v8->m_capacityAndFlags = 0x80000000;
    s_havokPhysicsGlobalTypeCompendiumData = NULL;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6976, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Library - type unknown") )
  {
    __debugbreak();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ReleasePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  HavokPhysics_RemovePhysicsSFXAssetInternal(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_ReleasePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  HavokPhysics_RemovePhysicsVFXAssetInternal(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_ReleaseShape
==============
*/
void HavokPhysics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  unsigned __int16 m_refCount; 
  int v7; 
  HavokPhysicsWorld *MutableWorld; 
  hkPointerMap<hknpShape const *,float,hkContainerHeapAllocator> *capsuleRadii; 
  int m_hashMod; 
  unsigned __int32 v11; 
  unsigned __int32 v12; 
  unsigned int v13; 
  Dummy *v14; 
  hknpShape *key; 
  signed __int32 v16[8]; 
  __int64 v17; 

  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16093, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  _InterlockedOr(v16, 0);
  m_refCount = shape->m_refCount;
  _InterlockedOr(v16, 0);
  if ( finalReference )
  {
    if ( m_refCount == 1 )
      goto LABEL_10;
  }
  else if ( m_refCount > 1u )
  {
    goto LABEL_22;
  }
  _InterlockedOr(v16, 0);
  v7 = shape->m_refCount;
  _InterlockedOr(v16, 0);
  LODWORD(v17) = v7;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16094, ASSERT_TYPE_ASSERT, "((finalReference && shape->getReferenceCount() == 1) || (!finalReference && shape->getReferenceCount() > 1))", "%s\n\tAttempting to release final reference for shape with bad refcount %i (0 - already released, >1 - still in use, corrupt - released and reused", "(finalReference && shape->getReferenceCount() == 1) || (!finalReference && shape->getReferenceCount() > 1)", v17) )
    __debugbreak();
LABEL_10:
  if ( finalReference && shape->m_type.m_storage == 3 )
  {
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world )
    {
      LODWORD(v17) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16100, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics ReleaseShape %i: world is NULL", "physicsWorld->world", v17) )
        __debugbreak();
    }
    capsuleRadii = MutableWorld->capsuleRadii;
    m_hashMod = capsuleRadii->m_map.m_hashMod;
    if ( m_hashMod <= 0 || (v11 = _byteswap_ulong(-1640531535 * HIDWORD(shape)), v12 = _byteswap_ulong(-1640531535 * (_DWORD)shape), v13 = m_hashMod & (v11 ^ ((v12 >> 2) + v12 + (v11 << 6) - 1640531527)), v14 = (Dummy *)v13, key = (hknpShape *)capsuleRadii->m_map.m_elem[v13].key, key == (hknpShape *)-1i64) )
    {
LABEL_19:
      v14 = (Dummy *)(m_hashMod + 1);
    }
    else
    {
      while ( key != shape )
      {
        v13 = m_hashMod & (v13 + 1);
        v14 = (Dummy *)v13;
        key = (hknpShape *)capsuleRadii->m_map.m_elem[v13].key;
        if ( key == (hknpShape *)-1i64 )
          goto LABEL_19;
      }
    }
    if ( (int)v14 <= m_hashMod )
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&MutableWorld->capsuleRadii->m_map, v14);
  }
LABEL_22:
  hkReferencedObject::removeReference(shape);
}

/*
==============
HavokPhysics_ReleaseXModelAsset
==============
*/
void HavokPhysics_ReleaseXModelAsset(XModel *xmodel)
{
  int Index; 
  __int64 v3; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v4; 
  __int64 m_size; 

  if ( !xmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7858, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tTrying to remove a NULL XModel Asset", "xmodel") )
    __debugbreak();
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7861, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  Index = HavokPhysics_DebugXModelGetIndex(xmodel);
  v3 = Index;
  if ( Index < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7863, ASSERT_TYPE_ASSERT, "(xModelId >= 0)", "%s\n\txmodel doesn't exist in debug list", "xModelId >= 0") )
    __debugbreak();
  v4 = s_havokPhysicsXModels;
  m_size = s_havokPhysicsXModels->m_size;
  s_havokPhysicsXModels->m_size = m_size - 1;
  if ( (_DWORD)m_size - 1 != (_DWORD)v3 )
    v4->m_data[v3] = v4->m_data[m_size - 1];
}

/*
==============
HavokPhysics_ReleaseXModelDetailCollisionAsset
==============
*/
void HavokPhysics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v3; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  unsigned int v7; 
  Dummy *v8; 
  XModelDetailCollision *key; 

  HavokPhysics_LockAssetWrite();
  v3 = s_havokPhysicsXModelLODs;
  if ( !s_havokPhysicsXModelLODs )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7873, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tTrying to Release an detailCollision asset but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
      __debugbreak();
    v3 = s_havokPhysicsXModelLODs;
  }
  m_hashMod = v3->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * HIDWORD(detailCollision)), v6 = _byteswap_ulong(-1640531535 * (_DWORD)detailCollision), v7 = m_hashMod & (v5 ^ ((v6 >> 2) + v6 + (v5 << 6) - 1640531527)), v8 = (Dummy *)v7, key = (XModelDetailCollision *)v3->m_map.m_elem[v7].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_9:
    v8 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != detailCollision )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = (Dummy *)v7;
      key = (XModelDetailCollision *)v3->m_map.m_elem[v7].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_9;
    }
  }
  if ( (int)v8 <= m_hashMod )
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v3->m_map, v8);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_RemoveClipMap
==============
*/
void HavokPhysics_RemoveClipMap(clipMap_t *clipMap)
{
  ;
}

/*
==============
HavokPhysics_RemoveInstanceFromWorld
==============
*/
void HavokPhysics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v3; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  hknpBodyId *m_data; 
  int m_size; 
  int v10; 
  __int64 v11; 

  v3 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11183, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to remove instance from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v3 == -1 )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11184, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to remove instance from world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11189, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics RemoveInstanceFromWorld %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  m_data = p_instanceManager->buffer[v3].bodies.m_data;
  m_size = p_instanceManager->buffer[v3].bodies.m_size;
  if ( HavokPhysics_IsInstanceDetailBounded(worldId, v3) )
  {
    v10 = m_size - 1;
    m_size = 1;
    m_data += v10;
  }
  HavokPhysics_RemoveRigidBodiesFromWorld(worldId, m_data, m_size, activate);
  HavokPhysicsInstanceManager_SetAddedToWorld(worldId, p_instanceManager, v3, 0, 0);
}

/*
==============
HavokPhysics_RemoveMaterialLibraryFromWorld
==============
*/
void HavokPhysics_RemoveMaterialLibraryFromWorld(HavokPhysicsMaterialLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  unsigned __int16 i; 
  __int64 v7; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6826, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Remove Material Library from world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v7) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6834, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Remove Material Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMaterialLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v7) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6846, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMaterialLibrary())", "%s\n\tHavokPhysics: Trying to Remove Material Library with world index %i, but can't find world library to remove from", "havokPhysicsWorld->world->getMaterialLibrary()", v7) )
          __debugbreak();
      }
      for ( i = library->lastId.m_value; i != 0xFFFF; hknpMaterialLibrary::removeEntry(MutableWorld->world->m_materialLibrary.m_ptr, (hknpMaterialId)i--) )
      {
        if ( i < library->firstId.m_value )
          break;
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_RemoveModifier
==============
*/
void HavokPhysics_RemoveModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16446, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to RemoveModifier with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16450, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics RemoveModifier %i: world is NULL", "physicsWorld->world", v5) )
      __debugbreak();
  }
  hknpModifierManager::removeModifier(MutableWorld->world->m_modifierManager, modifier);
}

/*
==============
HavokPhysics_RemoveMotionPropertiesLibraryFromWorld
==============
*/
void HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(HavokPhysicsMotionPropertiesLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  unsigned __int16 i; 
  __int64 v7; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6868, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library from world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v7) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6876, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMotionPropertiesLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v7) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6888, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMotionPropertiesLibrary())", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library with world index %i, but can't find world library to remove from", "havokPhysicsWorld->world->getMotionPropertiesLibrary()", v7) )
          __debugbreak();
      }
      for ( i = library->lastId.m_value; i != 0xFFFF; hknpMotionPropertiesLibrary::removeEntry(MutableWorld->world->m_motionPropertiesLibrary.m_ptr, (hknpMotionPropertiesId)i--) )
      {
        if ( i < library->firstId.m_value )
          break;
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_RemovePhysicsSFXAssetInternal
==============
*/
__int64 HavokPhysics_RemovePhysicsSFXAssetInternal(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  const char *v4; 
  unsigned int i; 
  __int64 v6; 
  unsigned int v7; 
  int m_hashMod; 
  unsigned __int32 v9; 
  unsigned int v10; 
  unsigned int key; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  char v15; 
  __int64 v16; 
  char v17; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v18; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  int v20; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  __int64 v25; 
  unsigned __int32 v26; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v27; 

  if ( !physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7048, ASSERT_TYPE_ASSERT, "(physicsSFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsSFXEventAsset", "physicsSFXEventAsset") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7049, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tTrying to add a physics SFXevent asset but the container is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  name = physicsSFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  v4 = physicsSFXEventAsset->name;
  for ( i = -1; v3; --v3 )
  {
    v6 = *(unsigned __int8 *)v4++;
    i = (i >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)i];
  }
  v7 = ~i;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( m_hashMod <= 0 || (v9 = m_hashMod & _byteswap_ulong(-1640531535 * v7), v10 = v9, key = g_physicsSFXEventAssets->m_elem[v9].key, key == -1) )
  {
LABEL_15:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != v7 )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = g_physicsSFXEventAssets->m_elem[v9].key;
      if ( key == -1 )
        goto LABEL_15;
    }
  }
  if ( (signed int)v10 > g_physicsSFXEventAssets->m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7066, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "SFX event asset %s not found", name) )
      __debugbreak();
  }
  else
  {
    v12 = 0x7FFFFFFFi64;
    v13 = g_physicsSFXEventAssets->m_elem[v10].val->name;
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v14 = v13 - name;
    do
    {
      v15 = name[v14];
      v16 = v12;
      v17 = *name++;
      --v12;
      if ( !v16 )
        break;
      if ( v15 != v17 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7060, ASSERT_TYPE_ASSERT, "(I_strcmp( g_physicsSFXEventAssets->getValue( it )->name, physicsSFXEventAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( g_physicsSFXEventAssets->getValue( it )->name, physicsSFXEventAsset->name ) == 0", g_physicsSFXEventAssets->m_elem[v10].val->name, physicsSFXEventAsset->name) )
          __debugbreak();
        break;
      }
    }
    while ( v15 );
    if ( g_physicsSFXEventAssets->m_elem[v10].val != physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7061, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->getValue( it ) == physicsSFXEventAsset)", (const char *)&queryFormat, "g_physicsSFXEventAssets->getValue( it ) == physicsSFXEventAsset") )
      __debugbreak();
    v18 = g_physicsSFXEventAssets;
    m_elem = g_physicsSFXEventAssets->m_elem;
    --g_physicsSFXEventAssets->m_numElems;
    m_elem[v10].key = -1;
    v20 = v18->m_hashMod;
    v21 = v18->m_elem;
    v22 = v20 & (v20 + v10);
    if ( v18->m_elem[v22].key != -1 )
    {
      do
        v22 = v20 & (v20 + v22);
      while ( v21[v22].key != -1 );
    }
    v23 = v20 & (v10 + 1);
    v24 = v20 & (v22 + 1);
    v25 = v23;
    if ( v21[v25].key != -1 )
    {
      do
      {
        v26 = v20 & _byteswap_ulong(-1640531535 * v21[v25].key);
        if ( v23 < v24 || (v27 = v21, v26 <= v10) )
        {
          if ( v23 >= v10 || v26 <= v10 && v26 > v23 )
          {
            if ( v26 <= v10 || (v27 = v21, v26 >= v24) )
            {
              hkMemUtil::memCpy(&v21[v10], &v21[v25], 16i64);
              v10 = v23;
              v18->m_elem[v25].key = -1;
              v20 = v18->m_hashMod;
              v27 = v18->m_elem;
            }
          }
          else
          {
            v27 = v21;
          }
        }
        v21 = v27;
        v23 = v20 & (v23 + 1);
        v25 = v23;
      }
      while ( v27[v25].key != -1 );
    }
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v7;
}

/*
==============
HavokPhysics_RemovePhysicsVFXAssetInternal
==============
*/
__int64 HavokPhysics_RemovePhysicsVFXAssetInternal(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  const char *v4; 
  unsigned int i; 
  __int64 v6; 
  unsigned int v7; 
  int m_hashMod; 
  unsigned __int32 v9; 
  unsigned int v10; 
  unsigned int key; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  char v15; 
  __int64 v16; 
  char v17; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v18; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  int v20; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  __int64 v25; 
  unsigned __int32 v26; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v27; 

  if ( !physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7212, ASSERT_TYPE_ASSERT, "(physicsVFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsVFXEventAsset", "physicsVFXEventAsset") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7213, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tTrying to Add a physics VFXevent asset but the container is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  name = physicsVFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  v4 = physicsVFXEventAsset->name;
  for ( i = -1; v3; --v3 )
  {
    v6 = *(unsigned __int8 *)v4++;
    i = (i >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)i];
  }
  v7 = ~i;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( m_hashMod <= 0 || (v9 = m_hashMod & _byteswap_ulong(-1640531535 * v7), v10 = v9, key = g_physicsVFXEventAssets->m_elem[v9].key, key == -1) )
  {
LABEL_15:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != v7 )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = g_physicsVFXEventAssets->m_elem[v9].key;
      if ( key == -1 )
        goto LABEL_15;
    }
  }
  if ( (signed int)v10 > g_physicsVFXEventAssets->m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7230, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "VFX event asset %s not found", name) )
      __debugbreak();
  }
  else
  {
    v12 = 0x7FFFFFFFi64;
    v13 = g_physicsVFXEventAssets->m_elem[v10].val->name;
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v14 = v13 - name;
    do
    {
      v15 = name[v14];
      v16 = v12;
      v17 = *name++;
      --v12;
      if ( !v16 )
        break;
      if ( v15 != v17 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7224, ASSERT_TYPE_ASSERT, "(I_strcmp( g_physicsVFXEventAssets->getValue( it )->name, physicsVFXEventAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( g_physicsVFXEventAssets->getValue( it )->name, physicsVFXEventAsset->name ) == 0", g_physicsVFXEventAssets->m_elem[v10].val->name, physicsVFXEventAsset->name) )
          __debugbreak();
        break;
      }
    }
    while ( v15 );
    if ( g_physicsVFXEventAssets->m_elem[v10].val != physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7225, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->getValue( it ) == physicsVFXEventAsset)", (const char *)&queryFormat, "g_physicsVFXEventAssets->getValue( it ) == physicsVFXEventAsset") )
      __debugbreak();
    v18 = g_physicsVFXEventAssets;
    m_elem = g_physicsVFXEventAssets->m_elem;
    --g_physicsVFXEventAssets->m_numElems;
    m_elem[v10].key = -1;
    v20 = v18->m_hashMod;
    v21 = v18->m_elem;
    v22 = v20 & (v20 + v10);
    if ( v18->m_elem[v22].key != -1 )
    {
      do
        v22 = v20 & (v20 + v22);
      while ( v21[v22].key != -1 );
    }
    v23 = v20 & (v10 + 1);
    v24 = v20 & (v22 + 1);
    v25 = v23;
    if ( v21[v25].key != -1 )
    {
      do
      {
        v26 = v20 & _byteswap_ulong(-1640531535 * v21[v25].key);
        if ( v23 < v24 || (v27 = v21, v26 <= v10) )
        {
          if ( v23 >= v10 || v26 <= v10 && v26 > v23 )
          {
            if ( v26 <= v10 || (v27 = v21, v26 >= v24) )
            {
              hkMemUtil::memCpy(&v21[v10], &v21[v25], 16i64);
              v10 = v23;
              v18->m_elem[v25].key = -1;
              v20 = v18->m_hashMod;
              v27 = v18->m_elem;
            }
          }
          else
          {
            v27 = v21;
          }
        }
        v21 = v27;
        v23 = v20 & (v23 + 1);
        v25 = v23;
      }
      while ( v27[v25].key != -1 );
    }
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v7;
}

/*
==============
HavokPhysics_RemoveRigidBodiesFromWorld
==============
*/
void HavokPhysics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, hknpBodyId *bodyIds, int bodyCount, bool activate)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11218, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to remove rigid bodies from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !bodyIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11219, ASSERT_TYPE_ASSERT, "(bodyIds)", (const char *)&queryFormat, "bodyIds") )
    __debugbreak();
  if ( bodyCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11220, ASSERT_TYPE_ASSERT, "(bodyCount > 0)", (const char *)&queryFormat, "bodyCount > 0") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11224, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics RemoveRigidBodiesFromWorld %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  MutableWorld->world->removeBodies(&MutableWorld->world->hknpWorldWriter, bodyIds, bodyCount, (hknpWorldWriter::ActivationMode)!activate);
}

/*
==============
HavokPhysics_RemoveShapeList
==============
*/
void HavokPhysics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  ;
}

/*
==============
HavokPhysics_RenderDebug
==============
*/
void HavokPhysics_RenderDebug(GfxCmdBufContext *gfxContext, bool includeWorlds)
{
  int v3; 
  hkCriticalSection *p_critSection; 
  __int64 v6; 
  GfxCmdBufContext v7; 

  if ( includeWorlds )
  {
    _RSI = gfxContext;
    v3 = 0;
    p_critSection = &g_havokPhysicsWorlds[0].critSection;
    do
    {
      if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
        __debugbreak();
      if ( (unsigned int)v3 > 7 )
      {
        LODWORD(v6) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 45, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to access invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
          __debugbreak();
      }
      EnterCriticalSection((LPCRITICAL_SECTION)p_critSection);
      if ( p_critSection[-4].m_section.SpinCount )
      {
        if ( !p_critSection[74].m_section.SpinCount )
        {
          LODWORD(v6) = v3;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17479, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->displayHandler)", "%s\n\tHavokPhysics: RenderDebug has invalid display handler for world %i", "havokPhysicsWorld->displayHandler", v6) )
            __debugbreak();
        }
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups [rsp+88h+var_38], xmm0
        }
        HavokPhysicsDisplayHandler::render((HavokPhysicsDisplayHandler *)p_critSection[74].m_section.SpinCount, &v7);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)p_critSection);
      ++v3;
      p_critSection += 96;
    }
    while ( v3 < 8 );
  }
}

/*
==============
HavokPhysics_SetDebugCameras
==============
*/
void HavokPhysics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  unsigned __int64 clientIndex; 

  clientIndex = viewInfo->clientIndex;
  if ( clientIndex >= 2 )
  {
    j___report_rangecheckfailure(viewInfo);
    JUMPOUT(0x141B5EEA9i64);
  }
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rcx+100h]
  }
  _R8 = 0x140000000ui64;
  _RAX = clientIndex;
  s_havokPhysics_VdbCameraSet[clientIndex] = 1;
  __asm
  {
    vmovss  dword ptr rva s_havokPhysics_VdbCameraOrigin.m_quad[r8+rax*8], xmm0
    vmulss  xmm2, xmm3, dword ptr [rcx+104h]
    vmovss  dword ptr (rva s_havokPhysics_VdbCameraOrigin.m_quad+4)[r8+rax*8], xmm2
    vmulss  xmm1, xmm3, dword ptr [rcx+108h]
    vmovss  dword ptr (rva s_havokPhysics_VdbCameraOrigin.m_quad+8)[r8+rax*8], xmm1
  }
  s_havokPhysics_VdbCameraOrigin[_RAX].m_quad.m128_i32[3] = 0;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vinsertps xmm2, xmm2, dword ptr [rcx+10Ch], 0
    vinsertps xmm2, xmm2, dword ptr [rcx+110h], 10h
    vinsertps xmm2, xmm2, dword ptr [rcx+114h], 20h ; ' '
    vmulps  xmm1, xmm2, cs:__xmm@40400000404000004040000040400000
    vaddps  xmm0, xmm1, xmmword ptr rva s_havokPhysics_VdbCameraOrigin.m_quad[r8+rax*8]
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr rva s_havokPhysics_VdbCameraLookat.m_quad[r8+rax*8], xmm0
    vinsertps xmm1, xmm1, dword ptr [rcx+124h], 0
    vinsertps xmm1, xmm1, dword ptr [rcx+128h], 10h
    vinsertps xmm1, xmm1, dword ptr [rcx+12Ch], 20h ; ' '
    vmovups xmmword ptr rva s_havokPhysics_VdbCameraUp.m_quad[r8+rax*8], xmm1
  }
}

/*
==============
HavokPhysics_SetErrorString
==============
*/
void HavokPhysics_SetErrorString(const char *string)
{
  s_errorExtraString = string;
}

/*
==============
HavokPhysics_SetInstanceDetailModel
==============
*/
void HavokPhysics_SetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  const HavokPhysicsWorld *ConstWorld; 
  XModelDetailCollision *detailCollision; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v11; 

  _RBP = xModel;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11018, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Instance detail model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11019, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to set detail model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v11) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10954, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance detail Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( instanceId == -1 )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10955, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get detailInstance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v11) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10960, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailModel %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  _RDI = HavokPhysicsInstanceManager_GetDetailModel(&ConstWorld->instanceManager, instanceId);
  if ( !_RBP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9944, ASSERT_TYPE_ASSERT, "(detailModelA)", (const char *)&queryFormat, "detailModelA") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9945, ASSERT_TYPE_ASSERT, "(detailModelB)", (const char *)&queryFormat, "detailModelB") )
    __debugbreak();
  detailCollision = _RDI->detailCollision;
  if ( _RBP->detailCollision != detailCollision )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vucomiss xmm0, dword ptr [rbp+28h]
  }
  if ( _RBP->detailCollision != detailCollision )
  {
LABEL_32:
    LODWORD(v11) = instanceId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11020, ASSERT_TYPE_ASSERT, "(HavokPhysics_AreDetailModelsInterchangeable( xModel, HavokPhysics_GetInstanceDetailModel( worldId, instanceId ) ))", "%s\n\tHavok Physics: Trying to set detail model that is not interchangeable with the existing model at instance %i in world %i", "HavokPhysics_AreDetailModelsInterchangeable( xModel, HavokPhysics_GetInstanceDetailModel( worldId, instanceId ) )", v11, worldId) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11024, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetXModel %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_SetDetailModel(&MutableWorld->instanceManager, instanceId, _RBP);
}

/*
==============
HavokPhysics_SetInstanceXModel
==============
*/
void HavokPhysics_SetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11001, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to set model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11005, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetXModel %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_SetXModel(&MutableWorld->instanceManager, instanceId, xModel);
}

/*
==============
HavokPhysics_SetMainShapeList
==============
*/
void HavokPhysics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7638, ASSERT_TYPE_ASSERT, "(s_shapeTagCodec)", (const char *)&queryFormat, "s_shapeTagCodec") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  if ( shapeList )
    HavokPhysicsShapeTagCodec::SetData(s_shapeTagCodec, &shapeList->m_shapeTagData);
  else
    HavokPhysicsShapeTagCodec::Clear(s_shapeTagCodec);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SetMapLocalAllocatorBuffer
==============
*/
void HavokPhysics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  *(_QWORD *)&s_mapLocalMemoryCapacity = size;
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2898, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMapLocalLargeBlockAllocator ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMapLocalLargeBlockAllocator", "nullptr", NULL, NULL) )
    __debugbreak();
  HavokPhysicsLargeBlockAllocator::setBuffer(s_havokPhysicsMapLocalLargeBlockAllocator, buffer, size);
}

/*
==============
HavokPhysics_SetMassPropertiesCenterOfMass
==============
*/
void HavokPhysics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, hkVector4f *centerOfMass)
{
  __asm
  {
    vmovups xmm0, xmmword ptr [rdx]
    vmovups xmmword ptr [rcx+10h], xmm0
  }
}

/*
==============
HavokPhysics_SetMassPropertiesInertiaTensor
==============
*/
void HavokPhysics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, hkVector4f *inertiaTensor)
{
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups xmmword ptr [rcx+40h], xmm0
  }
  massProperties->m_inertiaTensor.m_col0.m_quad.m128_i32[0] = inertiaTensor->m_quad.m128_i32[0];
  massProperties->m_inertiaTensor.m_col1.m_quad.m128_i32[1] = inertiaTensor->m_quad.m128_i32[1];
  massProperties->m_inertiaTensor.m_col2.m_quad.m128_i32[2] = inertiaTensor->m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_SetMassPropertiesMass
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesMass(hkMassProperties *massProperties, double mass)
{
  __asm { vmovss  dword ptr [rcx+4], xmm1 }
}

/*
==============
HavokPhysics_SetRigidBodyCenterOfMass
==============
*/
void HavokPhysics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *centerOfMass)
{
  hknpWorld *world; 
  __int64 v7; 
  __int64 v8; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11770, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Rigid Body center of mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11771, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to set Rigid Body center of mass with invalid body id for world %i", "bodyId.isValid()", v8) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11776, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics SetRigidBodyCenterOfMass %i: world is NULL", "world", v8) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v7 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11779, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const hkVector4f *))world->setMotionCenterOfMass)(&world->hknpWorldWriter, *(unsigned int *)(v7 + 64), centerOfMass);
}

/*
==============
HavokPhysics_SetRigidBodyContents
==============
*/
void HavokPhysics_SetRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  _BOOL8 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11889, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11890, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11895, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = !forceCacheRebuild && (*(_BYTE *)(v9 + 68) & 9) == 0;
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _BOOL8))MutableWorld->world->setBodyCollisionFilterInfo)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, (unsigned int)contents, v10);
}

/*
==============
HavokPhysics_SetRigidBodyDynamic
==============
*/
void HavokPhysics_SetRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11997, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11998, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Dynamic with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12003, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyDynamic %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 2i64);
}

/*
==============
HavokPhysics_SetRigidBodyInverseInertiaLocal
==============
*/
void HavokPhysics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *invInertia)
{
  hknpWorld *world; 
  __int64 v8; 
  __int64 v19; 

  _RBP = invInertia;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11788, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Rigid Body inverse inertia with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v19) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11789, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to set Rigid Body inverse inertia with invalid body id for world %i", "bodyId.isValid()", v19) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v19) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11794, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics SetRigidBodyCenterOfMass %i: world is NULL", "world", v19) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11797, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rbp+0] }
  _RAX = world->m_motionManager.m_motions.m_objects.m_data;
  _RCX = (unsigned __int64)*(unsigned int *)(v8 + 64) << 7;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovsd  xmm2, qword ptr [rcx+rax+20h]
    vpunpcklwd xmm3, xmm1, xmm2
    vblendps xmm2, xmm0, xmm3, 8
    vmulps  xmm0, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+330h; __m128 const near * const g_vectorfConstants
    vpsrad  xmm2, xmm0, 10h
    vpackssdw xmm1, xmm2, xmm2
    vmovsd  qword ptr [rcx+rax+20h], xmm1
  }
}

/*
==============
HavokPhysics_SetRigidBodyKeyframed
==============
*/
void HavokPhysics_SetRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11957, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( Physics_IsQueryWorld(worldId) )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11958, ASSERT_TYPE_ASSERT, "(!Physics_IsQueryWorld( worldId ))", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed in query world %i", "!Physics_IsQueryWorld( worldId )", v5) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11959, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11964, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
}

/*
==============
HavokPhysics_SetRigidBodyMass
==============
*/

void __fastcall HavokPhysics_SetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, double mass)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v8; 
  __int64 v11; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12015, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12016, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Mass with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12020, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyMass %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  __asm
  {
    vmovaps xmm2, xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64, _QWORD))MutableWorld->world->setBodyMass)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, v8, 0i64);
}

/*
==============
HavokPhysics_SetRigidBodyStatic
==============
*/
void HavokPhysics_SetRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11978, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11979, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody static with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11984, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyStatic %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _QWORD))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 0i64, 0i64);
}

/*
==============
HavokPhysics_SetRigidBodyToDefault
==============
*/
void HavokPhysics_SetRigidBodyToDefault(Physics_WorldId worldId, hknpBodyId bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  __int64 v7; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v10; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v12; 
  __int64 v17; 
  __int64 v18; 
  signed int i; 
  hknpShape *v20; 
  const char *MapEntsShapeName; 
  __int64 v22; 

  v7 = (int)assetIndex;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12033, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Default with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12034, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Default with invalid body id for world %i", "bodyId.isValid()", v22) )
      __debugbreak();
  }
  if ( !asset )
  {
    LODWORD(v22) = bodyId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12035, ASSERT_TYPE_ASSERT, "(asset)", "%s\n\tHavok Physics: Trying to Set RigidBody %i Default with invalid asset for world %i", "asset", v22, worldId) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12040, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyToDefault %i: world is NULL", "havokPhysicsWorld->world", v22) )
      __debugbreak();
  }
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(asset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12047, ASSERT_TYPE_ASSERT, "(havokAsset)", (const char *)&queryFormat, "havokAsset") )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12048, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData") )
    __debugbreak();
  if ( (int)v7 >= HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12049, ASSERT_TYPE_ASSERT, "((int)assetIndex < havokAsset->m_physicsSystemData->m_bodyCinfos.getSize())", (const char *)&queryFormat, "(int)assetIndex < havokAsset->m_physicsSystemData->m_bodyCinfos.getSize()") )
    __debugbreak();
  _RCX = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v7];
  if ( (*(_BYTE *)(_RCX + 8) & 4) == 0 && (*(_BYTE *)(v10 + 68) & 4) != 0 )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rcx+70h]
      vmovaps [rsp+0D8h+var_48], xmm6
      vxorps  xmm6, xmm6, xmm6
      vcomiss xmm2, xmm6
      vmovaps xmm6, [rsp+0D8h+var_48]
    }
    if ( (*(_BYTE *)(v10 + 68) & 4) != 0 )
      ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64, _QWORD))MutableWorld->world->setBodyMass)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, v12, 0i64);
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 2i64);
    v17 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
    v18 = *(_QWORD *)(v17 + 96);
    if ( *(_BYTE *)(v18 + 26) == 9 && *(int *)(v18 + 104) > 0 )
    {
      for ( i = 0; i < WorldCollision_GetMapEntsShapeCount(); ++i )
      {
        v20 = *(hknpShape **)(v17 + 96);
        if ( v20 == WorldCollision_GetMapEntsShape(i) )
          break;
      }
      if ( i >= WorldCollision_GetMapEntsShapeCount() )
      {
        Com_PrintWarning(16, "Physics: Setting a rigid body Dynamic using physicsasset %s with a collision-mesh (any terrain/patch or a brush with different contents/surface flags on some sides).  This will be slow and may result in CPU spikes and unwanted penetrations.\n", asset->name);
      }
      else
      {
        MapEntsShapeName = WorldCollision_GetMapEntsShapeName(i);
        Com_PrintWarning(16, "Physics: Setting a rigid body Dynamic using physicsasset %s with a collision-mesh from %s (any terrain/patch or a brush with different contents/surface flags on some sides).  This will be slow and may result in CPU spikes and unwanted penetrations.\n", asset->name, MapEntsShapeName);
      }
    }
  }
}

/*
==============
HavokPhysics_SetRigidBodyUserData
==============
*/
void HavokPhysics_SetRigidBodyUserData(Physics_WorldId worldId, hknpBodyId bodyId, unsigned __int64 userData)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11849, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody user data with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11850, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody user data with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11855, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  MutableWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData = userData;
}

/*
==============
HavokPhysics_SetRigidBodyVelocity
==============
*/
void HavokPhysics_SetRigidBodyVelocity(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkLinVel, const hkVector4f *hkAngVel)
{
  hknpWorld *world; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12800, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12801, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", v9) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12806, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics SetRigidBodyVelocity %i: world is NULL", "hkWorld", v9) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const hkVector4f *, const hkVector4f *, _DWORD))world->setBodyVelocity)(&world->hknpWorldWriter, bodyId.m_serialAndIndex, hkLinVel, hkAngVel, 0);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationGeneral
==============
*/
void HavokPhysics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2868, ASSERT_TYPE_ASSERT, "(unsigned)( threadId ) < (unsigned)( s_threadIdMax )", "threadId doesn't index s_threadIdMax\n\t%i not in [0, %i)", threadId, 28) )
    __debugbreak();
  v2 = s_threadMemoryRouters[v1];
  v3 = s_memoryRouter;
  if ( v2 )
    v3 = v2;
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2872, ASSERT_TYPE_ASSERT, "(memoryRouter)", (const char *)&queryFormat, "memoryRouter") )
    __debugbreak();
  HavokPhysicsFreeListMemorySystem::SetThreadHeapAllocationGeneral(s_havokPhysicsMemorySystem, v3);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationMapLocal
==============
*/
void HavokPhysics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2882, ASSERT_TYPE_ASSERT, "(unsigned)( threadId ) < (unsigned)( s_threadIdMax )", "threadId doesn't index s_threadIdMax\n\t%i not in [0, %i)", threadId, 28) )
    __debugbreak();
  v2 = s_threadMemoryRouters[v1];
  v3 = s_memoryRouter;
  if ( v2 )
    v3 = v2;
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2886, ASSERT_TYPE_ASSERT, "(memoryRouter)", (const char *)&queryFormat, "memoryRouter") )
    __debugbreak();
  HavokPhysicsFreeListMemorySystem::SetThreadHeapAllocationMapLocal(s_havokPhysicsMemorySystem, v3);
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  hknpCollisionQueryCollector *collector; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *startCollector; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v39; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v74; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  hkVector4f *v81; 
  hknpCollisionQueryContext queryContext; 
  int v83; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v85; 
  __int128 v86; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  hkQuaternionf *qi; 
  hknpShape *v90; 
  __int16 v91; 
  int contents; 
  int *v93; 
  __int64 v94; 
  hknpShapeCastQuery query; 
  hknpShapeQueryInfo queryShapeInfoIn; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v98[64]; 
  hknpInplaceTriangleShape v99; 
  char v100; 
  void *retaddr; 

  _RAX = &retaddr;
  v94 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  v90 = shape;
  v81 = (hkVector4f *)end;
  qi = (hkQuaternionf *)rotation;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v99, *(float *)&_XMM1);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v99;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v99;
  __asm { vmovss  [rbp+2F0h+queryContext.m_initialCastFractionHint], xmm6 }
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfoIn.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfoIn.m_shapeKeyPath.m_size = 0;
  queryShapeInfoIn.m_body = NULL;
  queryShapeInfoIn.m_parentShape = NULL;
  queryShapeInfoIn.m_shapeKeyMask = NULL;
  queryShapeInfoIn.m_scalingInternals.m_isScaled = 0;
  __asm
  {
    vmovups xmm2, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rbp+2F0h+queryShapeInfoIn.m_scalingInternals.m_scale.m_quad], xmm2
  }
  queryShapeInfoIn.m_scalingInternals.m_mode = 0;
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vmovups xmmword ptr [rbp+2F0h+queryShapeInfoIn.m_scalingInternals.m_offset.m_quad], xmm8
    vmovss  [rbp+2F0h+queryShapeInfoIn.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+2F0h+var_210.m_body], xmm0
  }
  targetShapeInfo.m_parentShape = NULL;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu xmmword ptr [rbp+2F0h+var_210.m_shapeToWorld], xmm1
  }
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm { vmovups xmmword ptr [rbp+2F0h+var_210.m_scalingInternals.m_scale.m_quad], xmm2 }
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vmovups xmmword ptr [rbp+2F0h+var_210.m_scalingInternals.m_offset.m_quad], xmm8
    vmovss  [rbp+2F0h+var_210.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  __asm { vmovss  [rbp+2F0h+var_368], xmm6 }
  ignoreBodies = NULL;
  v85 = 1;
  __asm { vmovdqu [rbp+2F0h+var_350], xmm0 }
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_shape = NULL;
  query.m_body = NULL;
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vmovss  [rbp+2F0h+query.m_accuracy], xmm0
    vmovss  [rbp+2F0h+query.m_startTolerance], xmm6
  }
  query.m_maxCastIterations = 256;
  __asm
  {
    vmovss  [rbp+2F0h+query.m_extraRadius], xmm6
    vmovups xmmword ptr [rbp+2F0h+query.m_deltaAngleLocal.m_quad], xmm8
    vmovups xmmword ptr [rbp+2F0h+query.m_rotationCenterLocal.m_quad], xmm8
    vmovss  xmm0, cs:__real@7f7fffee
    vmovss  [rbp+2F0h+query.m_angularAccuracy], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14953, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14954, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14955, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14956, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplifyStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14957, ASSERT_TYPE_ASSERT, "(!extendedData->simplifyStart)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with simplify start - not currently supported", "!extendedData->simplifyStart") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14958, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14959, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, start, v81, rotation, &query);
  collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    startCollector = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    startCollector = NULL;
  if ( !collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14966, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rdi+18h]
    vmovss  [rbp+2F0h+var_368], xmm0
  }
  v86 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  ignoreBodies = extendedData->ignoreBodies;
  v91 = -1;
  contents = extendedData->contents;
  v93 = &v83;
  queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rbp+2F0h+var_1B0], ymm0
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rbp+2F0h+var_1B0+20h], ymm0
  }
  hkRotationImpl<float>::set((hkRotationImpl<float> *)v98, qi);
  _RAX = start;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rbp+2F0h+var_1B0+30h], xmm0
  }
  queryShapeInfoIn.m_rootShape = v90;
  queryShapeInfoIn.m_shapeToWorld = (const hkTransformf *)v98;
  __asm { vmulss  xmm2, xmm6, dword ptr [rdi+4] }
  query.m_shape = v90;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rdi+8]
    vmovss  [rbp+2F0h+query.m_accuracy], xmm0
    vmovss  [rbp+2F0h+query.m_startTolerance], xmm2
  }
  query.m_body = NULL;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = ConstWorld->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v83;
  *(_DWORD *)query.m_levelOfDetail = 0;
  if ( numBodies )
  {
    v39 = numBodies;
    do
    {
      if ( (*bodyIds & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15012, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] )") )
        __debugbreak();
      _RDI = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, *bodyIds);
      m_shape = _RDI->m_shape;
      if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, SHAPE_CAST, (const hknpQueryFilterData *)&v91, _RDI) )
      {
        targetShapeInfo.m_body = _RDI;
        targetShapeInfo.m_rootShape = _RDI->m_shape;
        targetShapeInfo.m_parentShape = NULL;
        targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
        targetShapeInfo.m_shapeKeyPath.m_size = 0;
        targetShapeInfo.m_shapeToWorld = &_RDI->m_transform;
        targetShapeInfo.m_shapeKeyMask = NULL;
        targetShapeFilterDataIn.m_materialId.m_value = _RDI->m_materialId.m_value;
        targetShapeFilterDataIn.m_collisionFilterInfo = _RDI->m_collisionFilterInfo;
        targetShapeFilterDataIn.m_userData = _RDI->m_userData;
        s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, _RDI, m_shape, &targetShapeFilterDataIn);
        _RAX = start;
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vsubps  xmm1, xmm0, xmmword ptr [rdi+30h]
          vmovups xmm3, xmmword ptr [rdi]
          vmovups xmm4, xmmword ptr [rdi+10h]
          vmovups xmm6, xmmword ptr [rdi+20h]
          vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
          vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
          vdpps   xmm1, xmm6, xmm1, 74h ; 't'
          vorps   xmm0, xmm0, xmm2
          vorps   xmm7, xmm1, xmm0
        }
        _RAX = v81;
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vsubps  xmm1, xmm0, xmmword ptr [rdi+30h]
          vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
          vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
          vdpps   xmm1, xmm6, xmm1, 74h ; 't'
          vorps   xmm0, xmm0, xmm2
          vorps   xmm1, xmm1, xmm0
          vsubps  xmm2, xmm1, xmm7
          vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
          vcmpeqps xmm0, xmm3, xmm8
          vandnps xmm4, xmm0, xmm3
          vcmpeqps xmm0, xmm4, xmm8
          vrcpps  xmm3, xmm4
          vmulps  xmm2, xmm3, xmm4
          vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
          vsubps  xmm2, xmm1, xmm2
          vmulps  xmm3, xmm2, xmm3
          vmovups xmm1, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
          vblendvps xmm2, xmm3, xmm1, xmm0
          vmovups xmmword ptr [rbp+2F0h+query.m_ray.m_direction.m_quad], xmm4
          vmovups xmmword ptr [rbp+2F0h+query.m_ray.m_invDirection.m_quad], xmm2
          vmovups xmmword ptr [rbp+2F0h+query.m_ray.m_origin.m_quad], xmm7
        }
        Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( Value )
          hkMonitorStream::timerBegin(Value, "TtShapecast_Body_HK");
        hknpShapeQueryInterface::castShape(&queryContext, &query, &queryShapeInfoIn, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, collector, startCollector);
        v74 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( v74 )
          hkMonitorStream::timerEnd(v74, "Et");
      }
      ++bodyIds;
      --v39;
    }
    while ( v39 );
  }
  if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
  _R11 = &v100;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  hknpCollisionQueryCollector *Collector; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *v44; 
  hkMonitorStream *Value; 
  hkMonitorStream *v46; 
  unsigned int NumHits; 
  __int64 v48; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v50; 
  int v51; 
  int v52; 
  hknpCollisionResult *v53; 
  __int64 v55; 
  hknpBodyId *v61; 
  int Ref; 
  int v63; 
  unsigned int v64; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v66; 
  __int64 v69; 
  __int64 v70; 
  HavokPhysicsWorld *array; 
  int v72; 
  int v73; 
  hkQuaternionf *qi; 
  int v75; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v77; 
  __int128 v78; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  __int64 v81; 
  hknpShapeCastQuery query; 
  hkRotationImpl<float> v83; 
  void *retaddr; 

  _R11 = &retaddr;
  v81 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm7
    vmovaps xmmword ptr [r11-58h], xmm8
  }
  _R13 = end;
  _R12 = start;
  qi = (hkQuaternionf *)rotation;
  _RSI = extendedData;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovss  [rsp+1C8h+var_170], xmm1
  }
  ignoreBodies = NULL;
  v77 = 1;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rsp+1C8h+var_158], xmm0
  }
  phaseSelection = All;
  query.m_broadPhaseFilterMask = -5;
  query.m_maxCastIterations = 256;
  __asm
  {
    vmovss  [rsp+1C8h+query.m_extraRadius], xmm1
    vxorps  xmm8, xmm8, xmm8
    vmovups xmmword ptr [r11-0B8h], xmm8
    vmovups xmmword ptr [r11-0A8h], xmm8
    vmovss  xmm0, cs:__real@7f7fffee
    vmovss  [rsp+1C8h+query.m_angularAccuracy], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14139, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14140, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14141, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14142, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid result", "result") )
    __debugbreak();
  array = (HavokPhysicsWorld *)HavokPhysics_GetConstWorld(worldId);
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmulss  xmm7, xmm0, cs:__real@3d000000
  }
  ignoreBodies = extendedData->ignoreBodies;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+18h]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rsp+1C8h+var_170], xmm1
  }
  v78 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  query.m_shape = shape;
  __asm
  {
    vmovups xmm5, xmmword ptr [r12]
    vmovups xmm0, xmmword ptr [r13+0]
    vsubps  xmm1, xmm0, xmm5
    vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
    vcmpeqps xmm0, xmm8, xmm2
    vandnps xmm4, xmm0, xmm2
    vcmpeqps xmm0, xmm8, xmm4
    vrcpps  xmm3, xmm4
    vmulps  xmm2, xmm3, xmm4
    vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
    vsubps  xmm2, xmm1, xmm2
    vmulps  xmm3, xmm2, xmm3
    vmovups xmm1, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
    vblendvps xmm2, xmm3, xmm1, xmm0
    vmovups xmmword ptr [rsp+1C8h+query.m_ray.m_direction.m_quad], xmm4
    vmovups xmmword ptr [rsp+1C8h+query.m_ray.m_invDirection.m_quad], xmm2
    vmovups xmmword ptr [rsp+1C8h+query.m_ray.m_origin.m_quad], xmm5
    vmovss  xmm0, dword ptr [rsi+8]
    vmulss  xmm1, xmm0, cs:__real@3d000000
    vmovss  [rsp+1C8h+query.m_accuracy], xmm1
    vmovss  [rsp+1C8h+query.m_startTolerance], xmm7
  }
  query.m_body = NULL;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = array->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v75;
  *(_DWORD *)query.m_levelOfDetail = 0;
  hkRotationImpl<float>::set(&v83, qi);
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14174, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, _R12, _R13, qi, &query);
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    v44 = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    v44 = NULL;
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14181, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtShapetrace_HK");
  array->world->castShape(&array->world->hknpWorldReader, &query, &v83, Collector, v44);
  v46 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v46 )
    hkMonitorStream::timerEnd(v46, "Et");
  if ( startResult )
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
  else
    NumHits = 0;
  if ( extendedData->simplifyStart && NumHits )
  {
    array = NULL;
    v72 = 0;
    v73 = 0x80000000;
    v48 = (int)HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(startResult);
    v50 = hkMemHeapAllocator();
    v51 = 0;
    if ( (int)v48 > 0 )
    {
      v52 = v48;
      if ( (int)v48 < 0 )
        v52 = 0;
      hkArrayUtil::_reserve(v50, &array, v52, 112);
      v51 = v72;
    }
    v53 = (hknpCollisionResult *)array;
    _RCX = (char *)array + 112 * v51;
    v55 = v48;
    if ( (int)v48 > 0 )
    {
      _RBX = (char *)Hits - _RCX;
      do
      {
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbx+rcx]
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr [rbx+rcx+20h]
            vmovups ymmword ptr [rcx+20h], ymm1
            vmovups ymm0, ymmword ptr [rbx+rcx+40h]
            vmovups ymmword ptr [rcx+40h], ymm0
            vmovups xmm1, xmmword ptr [rbx+rcx+60h]
            vmovups xmmword ptr [rcx+60h], xmm1
          }
        }
        _RCX += 112;
        --v55;
      }
      while ( v55 );
      v53 = (hknpCollisionResult *)array;
    }
    v72 = v48;
    if ( (int)v48 > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v53, 0, v48 - 1, HavokPhysics_QueryHitSort);
    v44->reset(v44);
    v61 = (hknpBodyId *)array;
    if ( array != (HavokPhysicsWorld *)((char *)array + 112 * v72) )
    {
      do
      {
        Ref = HavokPhysics_GetRef(startResult->m_worldId, v61[18]);
        v63 = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
        v64 = 0;
        if ( v63 <= 0 )
        {
LABEL_51:
          v44->addHit(v44, (const hknpCollisionResult *)v61);
        }
        else
        {
          while ( 1 )
          {
            if ( v64 >= HavokPhysics_CollisionQueryResult::GetNumHits(startResult) )
            {
              LODWORD(v70) = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
              LODWORD(v69) = v64;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v69, v70) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(startResult, v64);
            if ( HavokPhysics_GetRef(startResult->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v64 >= v63 )
              goto LABEL_51;
          }
        }
        v61 += 28;
      }
      while ( v61 != (hknpBodyId *)((char *)array + 112 * v72) );
    }
    v66 = hkMemHeapAllocator();
    v72 = 0;
    if ( v73 >= 0 )
      hkMemoryAllocator::bufFree2(v66, array, 112, v73 & 0x3FFFFFFF);
  }
  __asm
  {
    vmovaps xmm7, [rsp+1C8h+var_48]
    vmovaps xmm8, [rsp+1C8h+var_58]
  }
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  hknpCollisionQueryCollector *v29; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *startCollector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpShape *m_shape; 
  const hknpShape *v41; 
  hkMonitorStream *Value; 
  hkMonitorStream *v78; 
  hknpCollisionQueryCollector *collector; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  __int16 v86; 
  int contents; 
  int *v88; 
  hknpCollisionQueryContext queryContext; 
  hkQuaternionf *qi; 
  const hkVector4f *v91; 
  hkVector4f *v92; 
  hknpShape *v93; 
  int v94; 
  __int64 v95; 
  int v96; 
  __int128 v97; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  __int64 v100; 
  hknpShapeCastQuery query; 
  hknpShapeQueryInfo queryShapeInfoIn; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v104[64]; 
  hknpInplaceTriangleShape v105; 
  char v106; 
  void *retaddr; 

  _RAX = &retaddr;
  v100 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  v91 = start;
  v93 = shape;
  v92 = (hkVector4f *)end;
  qi = (hkQuaternionf *)rotation;
  _RDI = extendedData;
  v86 = -1;
  contents = 0;
  v88 = NULL;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1; radius
  }
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v105, *(float *)&_XMM1);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v105;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v105;
  __asm { vmovss  [rsp+400h+queryContext.m_initialCastFractionHint], xmm6 }
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfoIn.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfoIn.m_shapeKeyPath.m_size = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+300h+queryShapeInfoIn.m_body], xmm0
  }
  queryShapeInfoIn.m_parentShape = NULL;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vmovdqu xmmword ptr [rbp+300h+queryShapeInfoIn.m_shapeToWorld], xmm1
  }
  queryShapeInfoIn.m_scalingInternals.m_isScaled = 0;
  __asm
  {
    vmovups xmm2, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rbp+300h+queryShapeInfoIn.m_scalingInternals.m_scale.m_quad], xmm2
  }
  queryShapeInfoIn.m_scalingInternals.m_mode = 0;
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vmovups xmmword ptr [rbp+300h+queryShapeInfoIn.m_scalingInternals.m_offset.m_quad], xmm9
    vmovss  [rbp+300h+queryShapeInfoIn.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm { vmovdqu xmmword ptr [rbp+300h+var_220.m_body], xmm0 }
  targetShapeInfo.m_parentShape = NULL;
  __asm { vmovdqu xmmword ptr [rbp+300h+var_220.m_shapeToWorld], xmm1 }
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  __asm { vmovups xmmword ptr [rbp+300h+var_220.m_scalingInternals.m_scale.m_quad], xmm2 }
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  __asm
  {
    vmovups xmmword ptr [rbp+300h+var_220.m_scalingInternals.m_offset.m_quad], xmm9
    vmovss  [rbp+300h+var_220.m_scalingInternals.m_convexRadius], xmm6
  }
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  __asm { vmovss  [rbp+300h+var_360], xmm6 }
  v95 = 0i64;
  v96 = 1;
  __asm { vmovdqu [rbp+300h+var_348], xmm0 }
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_shape = NULL;
  query.m_body = NULL;
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vmovss  [rbp+300h+query.m_accuracy], xmm0
    vmovss  [rbp+300h+query.m_startTolerance], xmm6
  }
  query.m_maxCastIterations = 256;
  __asm
  {
    vmovss  [rbp+300h+query.m_extraRadius], xmm6
    vmovups xmmword ptr [rbp+300h+query.m_deltaAngleLocal.m_quad], xmm9
    vmovups xmmword ptr [rbp+300h+query.m_rotationCenterLocal.m_quad], xmm9
    vmovss  xmm0, cs:__real@7f7fffee
    vmovss  [rbp+300h+query.m_angularAccuracy], xmm0
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14845, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(collector) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14846, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid body id %i", "bodyId.isValid()", collector) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14847, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14848, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14849, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire shapecast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplifyStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14850, ASSERT_TYPE_ASSERT, "(!extendedData->simplifyStart)", "%s\n\tHavok Physics: Trying to fire shapecast with body with simplify start - not currently supported", "!extendedData->simplifyStart") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14851, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14852, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, start, v92, qi, &query);
  v29 = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    startCollector = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    startCollector = NULL;
  if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14859, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  _RBX = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = _RBX->m_shape;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+18h]
    vmulss  xmm0, xmm0, cs:__real@3d000000
    vmovss  [rbp+300h+var_360], xmm0
  }
  v97 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  v86 = -1;
  contents = extendedData->contents;
  v88 = &v94;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, SHAPE_CAST, (const hknpQueryFilterData *)&v86, _RBX) )
  {
    queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rbp+300h+var_1C0], ymm0
      vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
      vmovups ymmword ptr [rbp+300h+var_1C0+20h], ymm0
    }
    hkRotationImpl<float>::set((hkRotationImpl<float> *)v104, qi);
    _RAX = v91;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbp+300h+var_1C0+30h], xmm0
    }
    v41 = v93;
    queryShapeInfoIn.m_rootShape = v93;
    queryShapeInfoIn.m_shapeToWorld = (const hkTransformf *)v104;
    targetShapeInfo.m_body = _RBX;
    targetShapeInfo.m_rootShape = _RBX->m_shape;
    targetShapeInfo.m_shapeToWorld = &_RBX->m_transform;
    targetShapeFilterDataIn.m_materialId.m_value = _RBX->m_materialId.m_value;
    targetShapeFilterDataIn.m_collisionFilterInfo = _RBX->m_collisionFilterInfo;
    targetShapeFilterDataIn.m_userData = _RBX->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, _RBX, m_shape, &targetShapeFilterDataIn);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+4]
      vmulss  xmm8, xmm0, cs:__real@3d000000
    }
    query.m_shape = v41;
    _RAX = v91;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vsubps  xmm1, xmm0, xmmword ptr [rbx+30h]
      vmovups xmm3, xmmword ptr [rbx]
      vmovups xmm4, xmmword ptr [rbx+10h]
      vmovups xmm6, xmmword ptr [rbx+20h]
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
      vorps   xmm0, xmm0, xmm2
      vorps   xmm7, xmm1, xmm0
    }
    _RAX = v92;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vsubps  xmm1, xmm0, xmmword ptr [rbx+30h]
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
      vorps   xmm0, xmm0, xmm2
      vorps   xmm1, xmm1, xmm0
      vsubps  xmm2, xmm1, xmm7
      vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
      vcmpeqps xmm0, xmm3, xmm9
      vandnps xmm4, xmm0, xmm3
      vcmpeqps xmm0, xmm4, xmm9
      vrcpps  xmm3, xmm4
      vmulps  xmm2, xmm3, xmm4
      vmovups xmm1, cs:?hkSse_floatTwo@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatTwo
      vsubps  xmm2, xmm1, xmm2
      vmulps  xmm3, xmm2, xmm3
      vmovups xmm1, cs:__xmm@7f7fffee7f7fffee7f7fffee7f7fffee
      vblendvps xmm2, xmm3, xmm1, xmm0
      vmovups xmmword ptr [rbp+300h+query.m_ray.m_direction.m_quad], xmm4
      vmovups xmmword ptr [rbp+300h+query.m_ray.m_invDirection.m_quad], xmm2
      vmovups xmmword ptr [rbp+300h+query.m_ray.m_origin.m_quad], xmm7
      vmovss  xmm0, dword ptr [rdi+8]
      vmulss  xmm1, xmm0, cs:__real@3d000000
      vmovss  [rbp+300h+query.m_accuracy], xmm1
      vmovss  [rbp+300h+query.m_startTolerance], xmm8
    }
    query.m_body = NULL;
    query.m_shapeTagCodec = s_shapeTagCodec;
    query.m_filter = ConstWorld->traceCollisionFilter;
    query.m_filterData.m_materialId.m_value = -1;
    query.m_filterData.m_collisionFilterInfo = extendedData->contents;
    query.m_filterData.m_userData = (unsigned __int64)&v94;
    *(_DWORD *)query.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtShapecast_Body_HK");
    hknpShapeQueryInterface::castShape(&queryContext, &query, &queryShapeInfoIn, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, v29, startCollector);
    v78 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v78 )
      hkMonitorStream::timerEnd(v78, "Et");
    if ( !queryContext.m_externallyAllocatedTriangles )
    {
      hkReferencedObject::removeReference(queryContext.m_queryTriangle);
      hkReferencedObject::removeReference(queryContext.m_targetTriangle);
    }
  }
  else if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
  _R11 = &v106;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
HavokPhysics_Shutdown
==============
*/
void HavokPhysics_Shutdown(void)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v0; 
  hkMemoryAllocator *v1; 
  int m_capacityAndFlags; 
  hkMemoryRouter *Value; 
  HavokPhysicsShapeTagCodec *v4; 
  hkMemoryAllocator **v5; 
  __int64 v6; 
  hkMemoryAllocator *v7; 
  int v8; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v9; 
  hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *v10; 
  int v11; 
  __int64 v12; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  hkReferencedObject *val; 
  unsigned __int16 m_refCount; 
  __int64 v17; 
  __int64 v18; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v19; 
  hkMemoryRouter *v20; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v21; 
  hkMemoryAllocator *v22; 
  int v23; 
  int v24; 
  __int64 v25; 
  __int64 v26; 
  signed int v27; 
  hkMemoryRouter *v28; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v29; 
  hkMemoryAllocator *v30; 
  int v31; 
  int v32; 
  __int64 v33; 
  __int64 v34; 
  signed int v35; 
  hkMemoryRouter *v36; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v37; 
  hkMemoryAllocator *v38; 
  int v39; 
  __int64 v40; 
  int *p_m_capacityAndFlags; 
  hkMemoryAllocator *v42; 
  int v43; 
  hkMemoryRouter *v44; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v45; 
  hkMemoryRouter *v46; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v47; 
  int v48; 
  __int64 v49; 
  __int64 v50; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v51; 
  const char **key; 
  __int64 v53; 
  __int64 v54; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v55; 
  hkMemoryRouter *v56; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v57; 
  hkMemoryRouter *v58; 
  HavokPhysicsThreadPool *v59; 
  HavokPhysicsThreadPool *v60; 
  signed __int32 v61[8]; 
  __int64 v62; 
  __int64 v63; 
  __int64 v64; 
  char v65; 

  v64 = -2i64;
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2657, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  v0 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels )
  {
    v1 = hkMemHeapAllocator();
    v0->m_size = 0;
    m_capacityAndFlags = v0->m_capacityAndFlags;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v1, v0->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
    v0->m_data = NULL;
    v0->m_capacityAndFlags = 0x80000000;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, v0, 16);
  }
  s_havokPhysicsXModels = NULL;
  v4 = s_shapeTagCodec;
  if ( s_shapeTagCodec )
    goto LABEL_14;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2663, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", NULL, NULL) )
    __debugbreak();
  v4 = s_shapeTagCodec;
  if ( s_shapeTagCodec )
LABEL_14:
    ((void (__fastcall *)(HavokPhysicsShapeTagCodec *, __int64))v4->~hkBaseObject)(v4, 1i64);
  s_shapeTagCodec = NULL;
  v5 = (hkMemoryAllocator **)s_threadMemoryRouters;
  v6 = 28i64;
  do
  {
    v7 = *v5;
    if ( *v5 )
    {
      ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryAllocator *, __int64))s_havokPhysicsMemorySystem->threadQuit)(s_havokPhysicsMemorySystem, v7, 3i64);
      *v5 = NULL;
      hkMemoryAllocator::~hkMemoryAllocator(v7);
    }
    ++v5;
    --v6;
  }
  while ( v6 );
  v8 = 27;
  v9 = &s_havokPhysicsShapeCaches[27];
  do
  {
    if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2689, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId])", "%s\n\tHavokPhysics Shutdown: havok physics shape caches should be valid", "s_havokPhysicsShapeCaches[threadId]") )
      __debugbreak();
    v10 = (hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *)*v9;
    v11 = 0;
    v12 = 0i64;
    m_hashMod = (*v9)->m_map.m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = v10->m_elem;
      do
      {
        if ( m_elem->key != -1i64 )
          break;
        ++v11;
        ++v12;
        ++m_elem;
      }
      while ( v12 <= m_hashMod );
    }
    if ( v11 <= (int)m_hashMod )
    {
      do
      {
        val = (hkReferencedObject *)v10->m_elem[v11].val;
        if ( !val || (_InterlockedOr(v61, 0), m_refCount = val->m_refCount, _InterlockedOr(v61, 0), m_refCount != 1) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2695, ASSERT_TYPE_ASSERT, "(shape && shape->getReferenceCount() == 1)", "%s\n\tHavokPhysics Shutdown: havok physics shape cache entries should have a single reference only", "shape && shape->getReferenceCount() == 1") )
            __debugbreak();
        }
        hkReferencedObject::removeReference(val);
        v10 = (hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *)*v9;
        ++v11;
        v17 = (*v9)->m_map.m_hashMod;
        if ( v11 > (int)v17 )
          break;
        v18 = v11;
        v19 = &v10->m_elem[v11];
        do
        {
          if ( v19->key != -1i64 )
            break;
          ++v11;
          ++v18;
          ++v19;
        }
        while ( v18 <= v17 );
      }
      while ( v11 <= (int)v17 );
    }
    if ( v10 )
    {
      hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(v10);
      v20 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v20 )
        v20 = hkMemoryRouter::s_fallbackRouter;
      v20->m_heap->blockFree(v20->m_heap, v10, 16);
    }
    *v9-- = NULL;
    --v8;
  }
  while ( v8 >= 0 );
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2704, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tHavokPhysics Shutdown: havok physics vfx event assets is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( (g_physicsVFXEventAssets->m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2705, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics vfx assets should be empty", "g_physicsVFXEventAssets->getSize() == 0") )
    __debugbreak();
  v21 = g_physicsVFXEventAssets;
  if ( g_physicsVFXEventAssets )
  {
    v22 = hkMemHeapAllocator();
    v23 = v21->m_hashMod;
    if ( v23 )
    {
      v24 = v23 + 1;
      v25 = v24;
      if ( v24 > 0 )
      {
        v26 = 0i64;
        do
        {
          if ( v21->m_elem[v26].key != -1 )
            v21->m_elem[v26].key = -1;
          ++v26;
          --v25;
        }
        while ( v25 );
      }
    }
    v27 = v21->m_numElems & 0x80000000;
    v21->m_numElems = v27;
    if ( v21->m_elem && v27 >= 0 )
      v22->blockFree(v22, v21->m_elem, 16 * (v21->m_hashMod + 1));
    v21->m_elem = NULL;
    v21->m_numElems = 0;
    v21->m_hashMod = -1;
    v28 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v28 )
      v28 = hkMemoryRouter::s_fallbackRouter;
    v28->m_heap->blockFree(v28->m_heap, v21, 16);
  }
  g_physicsVFXEventAssets = NULL;
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2709, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tHavokPhysics Shutdown: havok physics sfx event assets is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( (g_physicsSFXEventAssets->m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2710, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics sfx assets should be empty", "g_physicsSFXEventAssets->getSize() == 0") )
    __debugbreak();
  v29 = g_physicsSFXEventAssets;
  if ( g_physicsSFXEventAssets )
  {
    v30 = hkMemHeapAllocator();
    v31 = v29->m_hashMod;
    if ( v31 )
    {
      v32 = v31 + 1;
      v33 = v32;
      if ( v32 > 0 )
      {
        v34 = 0i64;
        do
        {
          if ( v29->m_elem[v34].key != -1 )
            v29->m_elem[v34].key = -1;
          ++v34;
          --v33;
        }
        while ( v33 );
      }
    }
    v35 = v29->m_numElems & 0x80000000;
    v29->m_numElems = v35;
    if ( v29->m_elem && v35 >= 0 )
      v30->blockFree(v30, v29->m_elem, 16 * (v29->m_hashMod + 1));
    v29->m_elem = NULL;
    v29->m_numElems = 0;
    v29->m_hashMod = -1;
    v36 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v36 )
      v36 = hkMemoryRouter::s_fallbackRouter;
    v36->m_heap->blockFree(v36->m_heap, v29, 16);
  }
  g_physicsSFXEventAssets = NULL;
  if ( !g_havokPhysicsXModelLODShapeTagDatas && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2720, ASSERT_TYPE_ASSERT, "(g_havokPhysicsXModelLODShapeTagDatas)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs shapetag datas is NULL", "g_havokPhysicsXModelLODShapeTagDatas") )
    __debugbreak();
  v37 = g_havokPhysicsXModelLODShapeTagDatas;
  if ( g_havokPhysicsXModelLODShapeTagDatas )
  {
    v38 = hkMemHeapAllocator();
    v39 = v37->m_size - 1;
    v40 = v39;
    if ( v39 >= 0 )
    {
      p_m_capacityAndFlags = &v37->m_data[v39].m_capacityAndFlags;
      do
      {
        v42 = hkMemHeapAllocator();
        *(p_m_capacityAndFlags - 1) = 0;
        if ( *p_m_capacityAndFlags >= 0 )
          hkMemoryAllocator::bufFree2(v42, *(void **)(p_m_capacityAndFlags - 3), 8, *p_m_capacityAndFlags & 0x3FFFFFFF);
        *(_QWORD *)(p_m_capacityAndFlags - 3) = 0i64;
        *p_m_capacityAndFlags = 0x80000000;
        p_m_capacityAndFlags -= 4;
        --v40;
      }
      while ( v40 >= 0 );
    }
    v37->m_size = 0;
    v43 = v37->m_capacityAndFlags;
    if ( v43 >= 0 )
      hkMemoryAllocator::bufFree2(v38, v37->m_data, 16, v43 & 0x3FFFFFFF);
    v37->m_data = NULL;
    v37->m_capacityAndFlags = 0x80000000;
    v44 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v44 )
      v44 = hkMemoryRouter::s_fallbackRouter;
    v44->m_heap->blockFree(v44->m_heap, v37, 16);
  }
  g_havokPhysicsXModelLODShapeTagDatas = NULL;
  v45 = s_havokPhysicsXModelLODShapeTagLookup;
  if ( s_havokPhysicsXModelLODShapeTagLookup )
    goto LABEL_98;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2724, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODShapeTagLookup)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs shapetag lookup is NULL", "s_havokPhysicsXModelLODShapeTagLookup") )
    __debugbreak();
  v45 = s_havokPhysicsXModelLODShapeTagLookup;
  if ( s_havokPhysicsXModelLODShapeTagLookup )
  {
LABEL_98:
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&v45->m_map);
    v46 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v46 )
      v46 = hkMemoryRouter::s_fallbackRouter;
    v46->m_heap->blockFree(v46->m_heap, v45, 16);
  }
  s_havokPhysicsXModelLODShapeTagLookup = NULL;
  v47 = s_havokPhysicsXModelLODs;
  if ( !s_havokPhysicsXModelLODs )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2729, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs is NULL", "s_havokPhysicsXModelLODs") )
      __debugbreak();
    v47 = s_havokPhysicsXModelLODs;
  }
  if ( (v47->m_map.m_numElems & 0x7FFFFFFF) != 0 )
  {
    Com_PrintWarning(16, "%i did not unload their PhysicsLODs - or may not be unloaded themselves\n", v47->m_map.m_numElems & 0x7FFFFFFF);
    v48 = 0;
    v47 = s_havokPhysicsXModelLODs;
    v49 = s_havokPhysicsXModelLODs->m_map.m_hashMod;
    if ( (int)v49 >= 0 )
    {
      v50 = 0i64;
      v51 = s_havokPhysicsXModelLODs->m_map.m_elem;
      do
      {
        if ( v51->key != -1i64 )
          break;
        ++v48;
        ++v50;
        ++v51;
      }
      while ( v50 <= v49 );
    }
    if ( v48 <= (int)v49 )
    {
      do
      {
        key = (const char **)v47->m_map.m_elem[v48].key;
        if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2738, ASSERT_TYPE_ASSERT, "(detailCollision)", (const char *)&queryFormat, "detailCollision") )
          __debugbreak();
        Com_PrintWarning(16, " %s did not unload it's PhysicsLOD - or may not be unloaded itself\n", *key);
        ++v48;
        v47 = s_havokPhysicsXModelLODs;
        v53 = s_havokPhysicsXModelLODs->m_map.m_hashMod;
        if ( v48 > (int)v53 )
          break;
        v54 = v48;
        v55 = &s_havokPhysicsXModelLODs->m_map.m_elem[v48];
        do
        {
          if ( v55->key != -1i64 )
            break;
          ++v48;
          ++v54;
          ++v55;
        }
        while ( v54 <= v53 );
      }
      while ( v48 <= (int)v53 );
    }
  }
  if ( (v47->m_map.m_numElems & 0x7FFFFFFF) != 0 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2745, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics LODs should be empty", "s_havokPhysicsXModelLODs->getSize() == 0") )
      __debugbreak();
    v47 = s_havokPhysicsXModelLODs;
  }
  if ( v47 )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&v47->m_map);
    v56 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v56 )
      v56 = hkMemoryRouter::s_fallbackRouter;
    v56->m_heap->blockFree(v56->m_heap, v47, 16);
  }
  s_havokPhysicsXModelLODs = NULL;
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2749, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tHavokPhysics Shutdown: havok physics assets is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  if ( (s_havokPhysicsAssets->m_map.m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2750, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics assets should be empty", "s_havokPhysicsAssets->getSize() == 0") )
    __debugbreak();
  v57 = s_havokPhysicsAssets;
  if ( s_havokPhysicsAssets )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&s_havokPhysicsAssets->m_map);
    v58 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v58 )
      v58 = hkMemoryRouter::s_fallbackRouter;
    v58->m_heap->blockFree(v58->m_heap, v57, 16);
  }
  s_havokPhysicsAssets = NULL;
  if ( !g_havokPhysicsThreadPool && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2756, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics Shutdown: thread pool is NULL", "g_havokPhysicsThreadPool") )
    __debugbreak();
  v59 = g_havokPhysicsThreadPool;
  _InterlockedOr(v61, 0);
  LOWORD(v59) = v59->m_refCount;
  _InterlockedOr(v61, 0);
  if ( (_WORD)v59 != 1 )
  {
    v60 = g_havokPhysicsThreadPool;
    _InterlockedOr(v61, 0);
    LODWORD(v60) = v60->m_refCount;
    _InterlockedOr(v61, 0);
    LODWORD(v62) = (_DWORD)v60;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2757, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool->getReferenceCount() == 1)", "%s\n\tHavokPhysics Shutdown: threadpool has %i references - should be 1", "g_havokPhysicsThreadPool->getReferenceCount() == 1", v62) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(g_havokPhysicsThreadPool);
  g_havokPhysicsThreadPool = NULL;
  if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2763, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
    __debugbreak();
  if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2764, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
    __debugbreak();
  if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2765, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
    __debugbreak();
  hkBaseSystem::quit();
  if ( !s_havokPhysicsGeneralLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2773, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics Shutdown: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator") )
    __debugbreak();
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, char *, __int64))s_havokPhysicsMemorySystem->mainQuit)(s_havokPhysicsMemorySystem, &v65, 3i64);
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, _QWORD))s_havokPhysicsMemorySystem->~hkMemorySystem)(s_havokPhysicsMemorySystem, 0i64);
  s_havokPhysicsMemorySystem = NULL;
  hkMemorySystem::replaceInstance(NULL);
  if ( s_memoryDebugRouter )
  {
    s_memoryDebugRouter = NULL;
    hkLargeBlockAllocator::freeAll(s_havokPhysicsDebugMemoryAllocator);
    ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsDebugMemoryAllocator->~hkMemoryAllocator)(s_havokPhysicsDebugMemoryAllocator, 0i64);
    s_havokPhysicsDebugMemoryAllocator = NULL;
  }
  s_memoryRouter = NULL;
  ((void (__fastcall *)(HavokPhysicsFreeListAllocator *, _QWORD))s_havokPhysicsMapLocalFreeListAllocator->~hkMemoryAllocator)(s_havokPhysicsMapLocalFreeListAllocator, 0i64);
  s_havokPhysicsMapLocalFreeListAllocator = NULL;
  hkLargeBlockAllocator::freeAll(s_havokPhysicsMapLocalLargeBlockAllocator);
  ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsMapLocalLargeBlockAllocator->~hkMemoryAllocator)(s_havokPhysicsMapLocalLargeBlockAllocator, 0i64);
  s_havokPhysicsMapLocalLargeBlockAllocator = NULL;
  ((void (__fastcall *)(HavokPhysicsFreeListAllocator *, _QWORD))s_havokPhysicsGeneralFreeListAllocator->~hkMemoryAllocator)(s_havokPhysicsGeneralFreeListAllocator, 0i64);
  s_havokPhysicsGeneralFreeListAllocator = NULL;
  hkLargeBlockAllocator::freeAll(s_havokPhysicsGeneralLargeBlockAllocator);
  ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsGeneralLargeBlockAllocator->~hkMemoryAllocator)(s_havokPhysicsGeneralLargeBlockAllocator, 0i64);
  s_havokPhysicsGeneralLargeBlockAllocator = NULL;
  s_havokPhysicsAssetLock.initialized = 0;
  if ( s_havokPhysicsAssetLock.acquireLock )
  {
    LODWORD(v63) = s_havokPhysicsAssetLock.acquireLock;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 138, ASSERT_TYPE_ASSERT, "( lock->acquireLock ) == ( 0 )", "%s == %s\n\t%i, %i", "lock->acquireLock", "0", v63, 0i64) )
      __debugbreak();
  }
  if ( s_havokPhysicsAssetLock.writeThreadId )
  {
    LODWORD(v63) = s_havokPhysicsAssetLock.writeThreadId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 139, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) == ( INVALID_THREAD_ID )", "%s == %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", v63, 0i64) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_SmoothTimeStep
==============
*/

void __fastcall HavokPhysics_SmoothTimeStep(Physics_WorldId worldId, double timeStep)
{
  const dvar_t *v11; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5658, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to PreStepWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RAX = HavokPhysics_GetMutableWorld(worldId);
  __asm
  {
    vmovss  xmm2, cs:__real@3d4ccccd; max
    vmovss  xmm1, cs:__real@3ada740e; min
    vmovaps xmm0, xmm6; val
    vmovss  dword ptr [rax+0B58h], xmm6
  }
  _RBX = _RAX;
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  _RCX = _RBX->timeStepHistoryStart;
  __asm { vmovss  dword ptr [rbx+rcx*4+30h], xmm0 }
  _RBX->timeStepHistoryStart = (_RBX->timeStepHistoryStart + 1) % 20;
  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x100) || !Physics_IsAuthoritativeWorld(worldId) )
    goto LABEL_11;
  v11 = DVARBOOL_physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc;
  if ( !DVARBOOL_physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( v11->current.enabled )
  {
    __asm
    {
      vmovss  dword ptr [rbx+84h], xmm6
      vmovaps xmm6, [rsp+58h+var_18]
    }
  }
  else
  {
LABEL_11:
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+34h]
      vaddss  xmm1, xmm0, dword ptr [rbx+30h]
      vaddss  xmm2, xmm1, dword ptr [rbx+38h]
      vaddss  xmm3, xmm2, dword ptr [rbx+3Ch]
      vaddss  xmm0, xmm3, dword ptr [rbx+40h]
      vaddss  xmm1, xmm0, dword ptr [rbx+44h]
      vaddss  xmm2, xmm1, dword ptr [rbx+48h]
      vaddss  xmm3, xmm2, dword ptr [rbx+4Ch]
      vaddss  xmm0, xmm3, dword ptr [rbx+50h]
      vaddss  xmm1, xmm0, dword ptr [rbx+54h]
      vaddss  xmm2, xmm1, dword ptr [rbx+58h]
      vaddss  xmm3, xmm2, dword ptr [rbx+5Ch]
      vaddss  xmm0, xmm3, dword ptr [rbx+60h]
      vaddss  xmm1, xmm0, dword ptr [rbx+64h]
      vaddss  xmm2, xmm1, dword ptr [rbx+68h]
      vaddss  xmm3, xmm2, dword ptr [rbx+6Ch]
      vaddss  xmm0, xmm3, dword ptr [rbx+70h]
      vaddss  xmm1, xmm0, dword ptr [rbx+74h]
      vaddss  xmm2, xmm1, dword ptr [rbx+78h]
      vaddss  xmm3, xmm2, dword ptr [rbx+7Ch]
      vmulss  xmm0, xmm3, cs:__real@3d4ccccd
      vmovss  dword ptr [rbx+84h], xmm0
      vmovaps xmm6, [rsp+58h+var_18]
    }
  }
}

/*
==============
HavokPhysics_StartDrawDebugWorld
==============
*/
void HavokPhysics_StartDrawDebugWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpProcessContext *visContext; 
  hkProcessContext *v6; 
  hkMemoryAllocator *v7; 
  int m_size; 
  hclClothContext *clothVisContext; 
  hkProcessContext *v10; 
  hkMemoryAllocator *v11; 
  int v12; 
  hkMemoryAllocator *v13; 
  int v14; 
  hkMemoryAllocator *v15; 
  int v16; 
  hkMemoryAllocator *v17; 
  int v18; 
  hkMemoryAllocator *v19; 
  int v20; 
  hkMemoryAllocator *v21; 
  int v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  hkMemoryAllocator *v25; 
  int v26; 
  hkMemoryAllocator *v27; 
  int v28; 
  hkMemoryAllocator *v29; 
  int v30; 
  hkMemoryAllocator *v31; 
  int v32; 
  hkMemoryAllocator *v33; 
  int v34; 
  hkMemoryAllocator *v35; 
  int v36; 
  hkMemoryAllocator *v37; 
  int v38; 
  hkMemoryAllocator *v39; 
  int v40; 
  hkMemoryAllocator *v41; 
  int v42; 
  hkMemoryAllocator *v43; 
  int v44; 
  hkMemoryAllocator *v45; 
  int v46; 
  hkMemoryAllocator *v47; 
  int v48; 
  hkMemoryAllocator *v49; 
  int v50; 
  hkMemoryAllocator *v51; 
  int v52; 
  hkMemoryAllocator *v53; 
  int v54; 
  hkMemoryAllocator *v55; 
  int v56; 
  hkMemoryAllocator *v57; 
  int v58; 
  hkMemoryAllocator *v59; 
  int v60; 
  hkMemoryAllocator *v61; 
  int v62; 
  hkMemoryAllocator *v63; 
  int v64; 
  hkMemoryAllocator *v65; 
  int v66; 
  hkMemoryAllocator *v67; 
  int v68; 
  hkMemoryAllocator *v69; 
  int v70; 
  hkMemoryAllocator *v71; 
  int v72; 
  hkMemoryAllocator *v73; 
  int v74; 
  hkMemoryAllocator *v75; 
  int v76; 
  hkMemoryAllocator *v77; 
  int v78; 
  hkMemoryAllocator *v79; 
  int v80; 
  hkMemoryAllocator *v81; 
  int v82; 
  hkMemoryAllocator *v83; 
  int v84; 
  hkMemoryAllocator *v85; 
  int v86; 
  hkMemoryAllocator *v87; 
  int v88; 
  int v89; 
  __int64 v90; 
  hkProcess *v91; 
  HavokPhysicsDisplayHandler *displayHandler; 
  hkReferencedObject *m_ptr; 
  hkServerObjectHandler *serverObjectHandler; 
  hkReferencedObject *v95; 
  hkMemoryAllocator *v96; 
  int v97; 
  hkMemoryAllocator *v98; 
  hkMemoryAllocator *v99; 
  void *p; 
  int v101; 
  int v102; 
  hkArray<hkProcessContext *,hkContainerHeapAllocator> array; 
  hkReflect::Var v104; 

  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  p = NULL;
  v101 = 0;
  v102 = 0x80000000;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17247, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StartDrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  visContext = MutableWorld->visContext;
  v6 = &visContext->hkProcessContext;
  if ( !visContext )
    v6 = NULL;
  v7 = hkMemHeapAllocator();
  m_size = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v7, &array, 8);
    m_size = array.m_size;
  }
  array.m_data[m_size] = v6;
  ++array.m_size;
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
  {
    v10 = &clothVisContext->hkProcessContext;
    v11 = hkMemHeapAllocator();
    v12 = array.m_size;
    if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v11, &array, 8);
      v12 = array.m_size;
    }
    array.m_data[v12] = v10;
    ++array.m_size;
  }
  hkDebugDisplayProcess::registerProcess();
  v13 = hkMemHeapAllocator();
  v14 = v101;
  if ( v101 == (v102 & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, &p, 8);
    v14 = v101;
  }
  *((_QWORD *)p + v14) = "Debug Display";
  ++v101;
  if ( physics_debugVisualizeWorldBodyId->current.enabled )
  {
    v15 = hkMemHeapAllocator();
    v16 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v15, &p, 8);
      v16 = v101;
    }
    *((_QWORD *)p + v16) = "Physics/Rigid Bodies/Body IDs";
    ++v101;
  }
  if ( physics_debugVisualizeWorldBroadphase->current.enabled )
  {
    v17 = hkMemHeapAllocator();
    v18 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v17, &p, 8);
      v18 = v101;
    }
    *((_QWORD *)p + v18) = "Physics/Broad Phase";
    ++v101;
  }
  if ( physics_debugVisualizeWorldConstraint->current.enabled )
  {
    v19 = hkMemHeapAllocator();
    v20 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v19, &p, 8);
      v20 = v101;
    }
    *((_QWORD *)p + v20) = "Physics/Constraints";
    ++v101;
  }
  if ( physics_debugVisualizeWorldDeactivation->current.enabled )
  {
    v21 = hkMemHeapAllocator();
    v22 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v21, &p, 8);
      v22 = v101;
    }
    *((_QWORD *)p + v22) = "Physics/Rigid Bodies/Deactivation";
    ++v101;
  }
  if ( physics_debugVisualizeWorldManifold->current.enabled )
  {
    v23 = hkMemHeapAllocator();
    v24 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v23, &p, 8);
      v24 = v101;
    }
    *((_QWORD *)p + v24) = "Physics/Rigid Bodies/Manifolds";
    ++v101;
  }
  if ( physics_debugVisualizeWorldMassProperties->current.enabled )
  {
    v25 = hkMemHeapAllocator();
    v26 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v25, &p, 8);
      v26 = v101;
    }
    *((_QWORD *)p + v26) = "Physics/Rigid Bodies/Mass Properties";
    ++v101;
  }
  if ( physics_debugVisualizeWorldMotionId->current.enabled )
  {
    v27 = hkMemHeapAllocator();
    v28 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v27, &p, 8);
      v28 = v101;
    }
    *((_QWORD *)p + v28) = "Physics/Rigid Bodies/Motion IDs";
    ++v101;
  }
  if ( physics_debugVisualizeWorldShape->current.enabled )
  {
    v29 = hkMemHeapAllocator();
    v30 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v29, &p, 8);
      v30 = v101;
    }
    *((_QWORD *)p + v30) = "Physics/Rigid Bodies/Shapes";
    ++v101;
  }
  if ( physics_debugVisualizeWorldVehicles->current.enabled )
  {
    v31 = hkMemHeapAllocator();
    v32 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v31, &p, 8);
      v32 = v101;
    }
    *((_QWORD *)p + v32) = "Physics/Vehicles";
    ++v101;
  }
  if ( physics_debugVisualizeWorldCollisionHeatmap->current.enabled )
  {
    v33 = hkMemHeapAllocator();
    v34 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v33, &p, 8);
      v34 = v101;
    }
    *((_QWORD *)p + v34) = "IW World-Collision Heatmap";
    ++v101;
  }
  if ( physics_debugVisualizeWorldDebugDraw->current.enabled )
  {
    v35 = hkMemHeapAllocator();
    v36 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v35, &p, 8);
      v36 = v101;
    }
    *((_QWORD *)p + v36) = "IW World-Debug Draw";
    ++v101;
  }
  if ( physics_debugVisualizeWorldCollisionTile->current.enabled )
  {
    v37 = hkMemHeapAllocator();
    v38 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v37, &p, 8);
      v38 = v101;
    }
    *((_QWORD *)p + v38) = "IW Collision Tile Draw";
    ++v101;
  }
  if ( physics_debugVisualizeWorldRaycasts->current.enabled )
  {
    v39 = hkMemHeapAllocator();
    v40 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v39, &p, 8);
      v40 = v101;
    }
    *((_QWORD *)p + v40) = "Physics/Queries/Ray Casts";
    ++v101;
  }
  if ( physics_debugVisualizeWorldShapecasts->current.enabled )
  {
    v41 = hkMemHeapAllocator();
    v42 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v41, &p, 8);
      v42 = v101;
    }
    *((_QWORD *)p + v42) = "Physics/Queries/Shape Casts";
    ++v101;
  }
  if ( physics_debugVisualizeWorldAABBQuery->current.enabled )
  {
    v43 = hkMemHeapAllocator();
    v44 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v43, &p, 8);
      v44 = v101;
    }
    *((_QWORD *)p + v44) = "Physics/Queries/Aabb Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldPointQuery->current.enabled )
  {
    v45 = hkMemHeapAllocator();
    v46 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v45, &p, 8);
      v46 = v101;
    }
    *((_QWORD *)p + v46) = "Physics/Queries/Point Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldClosestPointsQuery->current.enabled )
  {
    v47 = hkMemHeapAllocator();
    v48 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v47, &p, 8);
      v48 = v101;
    }
    *((_QWORD *)p + v48) = "Physics/Queries/Closest Points Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldIWShape->current.enabled )
  {
    v49 = hkMemHeapAllocator();
    v50 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v49, &p, 8);
      v50 = v101;
    }
    *((_QWORD *)p + v50) = "IW Shape Viewer";
    ++v101;
  }
  if ( physics_debugVisualizeWorldParticles->current.enabled )
  {
    v51 = hkMemHeapAllocator();
    v52 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v51, &p, 8);
      v52 = v101;
    }
    *((_QWORD *)p + v52) = "Physics/Particles/Shapes";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldGeometry->current.enabled )
  {
    v53 = hkMemHeapAllocator();
    v54 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v53, &p, 8);
      v54 = v101;
    }
    *((_QWORD *)p + v54) = "Cloth/Simulation/Geometry";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimParticlePosition->current.enabled )
  {
    v55 = hkMemHeapAllocator();
    v56 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v55, &p, 8);
      v56 = v101;
    }
    *((_QWORD *)p + v56) = "Cloth/Simulation/Particle/Position";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimNormals->current.enabled )
  {
    v57 = hkMemHeapAllocator();
    v58 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v57, &p, 8);
      v58 = v101;
    }
    *((_QWORD *)p + v58) = "Cloth/Simulation/Particle/Normal";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleVelocity->current.enabled )
  {
    v59 = hkMemHeapAllocator();
    v60 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v59, &p, 8);
      v60 = v101;
    }
    *((_QWORD *)p + v60) = "Cloth/Simulation/Particle/Velocity";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleId->current.enabled )
  {
    v61 = hkMemHeapAllocator();
    v62 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v61, &p, 8);
      v62 = v101;
    }
    *((_QWORD *)p + v62) = "Cloth/Simulation/Particle/Id";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimStandardLinks->current.enabled )
  {
    v63 = hkMemHeapAllocator();
    v64 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v63, &p, 8);
      v64 = v101;
    }
    *((_QWORD *)p + v64) = "Cloth/Simulation/Constraint/Standard Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimStretchLinks->current.enabled )
  {
    v65 = hkMemHeapAllocator();
    v66 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v65, &p, 8);
      v66 = v101;
    }
    *((_QWORD *)p + v66) = "Cloth/Simulation/Constraint/Stretch Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimBendLinks->current.enabled )
  {
    v67 = hkMemHeapAllocator();
    v68 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v67, &p, 8);
      v68 = v101;
    }
    *((_QWORD *)p + v68) = "Cloth/Simulation/Constraint/Stretch Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimBendStiffness->current.enabled )
  {
    v69 = hkMemHeapAllocator();
    v70 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v69, &p, 8);
      v70 = v101;
    }
    *((_QWORD *)p + v70) = "Cloth/Simulation/Constraint/Bend Stiffness";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimVolumeTransforms->current.enabled )
  {
    v71 = hkMemHeapAllocator();
    v72 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v71, &p, 8);
      v72 = v101;
    }
    *((_QWORD *)p + v72) = "Cloth/Simulation/Constraint/Volume";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldLocalRange->current.enabled )
  {
    v73 = hkMemHeapAllocator();
    v74 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v73, &p, 8);
      v74 = v101;
    }
    *((_QWORD *)p + v74) = "Cloth/Simulation/Constraint/Local Range";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldBonePlane->current.enabled )
  {
    v75 = hkMemHeapAllocator();
    v76 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v75, &p, 8);
      v76 = v101;
    }
    *((_QWORD *)p + v76) = "Cloth/Simulation/Constraint/Bone Plane";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldTransition->current.enabled )
  {
    v77 = hkMemHeapAllocator();
    v78 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v77, &p, 8);
      v78 = v101;
    }
    *((_QWORD *)p + v78) = "Cloth/Simulation/Constraint/Transition";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldCollidable->current.enabled )
  {
    v79 = hkMemHeapAllocator();
    v80 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v79, &p, 8);
      v80 = v101;
    }
    *((_QWORD *)p + v80) = "Cloth/Collidables/Collidables";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleRadius->current.enabled )
  {
    v81 = hkMemHeapAllocator();
    v82 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v81, &p, 8);
      v82 = v101;
    }
    *((_QWORD *)p + v82) = "Cloth/Simulation/Particle/Radius";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldVirtualCollisionPoints->current.enabled )
  {
    v83 = hkMemHeapAllocator();
    v84 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v83, &p, 8);
      v84 = v101;
    }
    *((_QWORD *)p + v84) = "Cloth/Simulation/Particle/VCP";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldVirtualCollisionPointsLandscape->current.enabled )
  {
    v85 = hkMemHeapAllocator();
    v86 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v85, &p, 8);
      v86 = v101;
    }
    *((_QWORD *)p + v86) = "Cloth/Simulation/Landscape/VCP";
    ++v101;
  }
  v87 = hkMemHeapAllocator();
  v88 = v101;
  if ( v101 == (v102 & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v87, &p, 8);
    v88 = v101;
  }
  *((_QWORD *)p + v88) = "Cloth/Simulation/Shared Geometry";
  ++v101;
  HavokPhysicsDisplayHandler::setShapeViewer(MutableWorld->displayHandler, NULL);
  v89 = 0;
  if ( v101 > 0 )
  {
    v90 = 0i64;
    do
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu [rbp+var_18], xmm0
      }
      v104.m_impl.m_ptrAndInt = NULL;
      v91 = hkProcessFactory::createProcess(hkProcessFactory::singleton.m_ptr, *(const char **)((char *)p + v90), &array, &v104);
      if ( !v91 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17347, ASSERT_TYPE_ASSERT, "(process)", "%s\n\tHavokPhysics: StartDrawDebugWorld couldn't create a process", "process") )
        __debugbreak();
      if ( !strcmp_0(*(const char **)((char *)p + v90), "IW Shape Viewer") )
        HavokPhysicsDisplayHandler::setShapeViewer(MutableWorld->displayHandler, v91);
      displayHandler = MutableWorld->displayHandler;
      if ( displayHandler )
        hkReferencedObject::addReference(MutableWorld->displayHandler);
      m_ptr = v91->m_displayHandler.m_ptr;
      if ( m_ptr )
        hkReferencedObject::removeReference(m_ptr);
      v91->m_displayHandler.m_ptr = displayHandler;
      serverObjectHandler = MutableWorld->serverObjectHandler;
      if ( serverObjectHandler )
        hkReferencedObject::addReference(MutableWorld->serverObjectHandler);
      v95 = v91->m_objectHandler.m_ptr;
      if ( v95 )
        hkReferencedObject::removeReference(v95);
      v91->m_objectHandler.m_ptr = serverObjectHandler;
      v91->m_processHandler = MutableWorld->processHandler;
      v91->init(v91);
      v96 = hkMemHeapAllocator();
      v97 = MutableWorld->visProcesses.m_size;
      if ( v97 == (MutableWorld->visProcesses.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v96, &MutableWorld->visProcesses, 8);
        v97 = MutableWorld->visProcesses.m_size;
      }
      MutableWorld->visProcesses.m_data[v97] = v91;
      ++MutableWorld->visProcesses.m_size;
      ++v89;
      v90 += 8i64;
    }
    while ( v89 < v101 );
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  }
  LeaveCriticalSection(p_critSection);
  v98 = hkMemHeapAllocator();
  v101 = 0;
  if ( v102 >= 0 )
    hkMemoryAllocator::bufFree2(v98, p, 8, v102 & 0x3FFFFFFF);
  p = NULL;
  v102 = 0x80000000;
  v99 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v99, array.m_data, 8, array.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_StepVDB
==============
*/

void __fastcall HavokPhysics_StepVDB(Physics_WorldId worldId, double time, bool updateStats)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v8; 
  hkMonitorStream *Value; 
  LocalClientNum_t LocalClientForWorld; 
  const char *v13; 
  __int64 v20; 
  __int64 v22; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v24; 
  int m_capacityAndFlags; 
  __int64 v28; 
  char v30[16]; 
  __int128 v31[3]; 
  char v36; 

  __asm
  {
    vmovaps [rsp+0B8h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6365, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v8 = MutableWorld;
  if ( updateStats )
  {
    hkCommonProcessContext::syncTimers(MutableWorld->comContext, NULL);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::reset(Value);
  }
  if ( !v8->vdbServer )
  {
    LODWORD(v28) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6377, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v28) )
      __debugbreak();
  }
  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  _RDX = 0x140000000ui64;
  if ( LocalClientForWorld == LOCAL_CLIENT_INVALID )
    LocalClientForWorld = LOCAL_CLIENT_0;
  if ( s_havokPhysics_VdbCameraSet[LocalClientForWorld] && v8->vdbServer->m_clients.m_size >= 1 )
  {
    __asm { vmovss  xmm1, cs:__real@3dcccccd }
    v13 = s_havokPhysics_VdbCameraNames[LocalClientForWorld];
    _RAX = 2i64 * (int)LocalClientForWorld;
    __asm
    {
      vmovss  [rsp+0B8h+var_38], xmm1
      vmovss  xmm1, cs:__real@42340000
      vmovss  [rsp+0B8h+var_30], xmm1
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraOrigin.m_quad[rdx+rax*8]
      vmovups [rsp+0B8h+var_68], xmm0
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraLookat.m_quad[rdx+rax*8]
      vmovups [rsp+0B8h+var_58], xmm0
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraUp.m_quad[rdx+rax*8]
      vmovups [rsp+0B8h+var_48], xmm0
      vmovss  xmm0, cs:__real@461c4000
      vmovss  [rsp+0B8h+var_34], xmm0
    }
    ((void (__fastcall *)(hkDebugDisplay *, char *, const char *, __int128 *))hkDebugDisplay::singleton.m_ptr->updateCamera)(hkDebugDisplay::singleton.m_ptr, v30, v13, v31);
  }
  hkCommonProcessContext::syncTimers(v8->comContext, NULL);
  LOBYTE(v20) = 5;
  __asm { vmulss  xmm1, xmm6, cs:__real@447a0000 }
  ((void (__fastcall *)(hkVisualDebugger *, __int64, __int64))v8->vdbServer->step)(v8->vdbServer, v22, v20);
  debugLines = v8->debugLines;
  v24 = hkMemHeapAllocator();
  m_capacityAndFlags = debugLines->m_capacityAndFlags;
  debugLines->m_size = 0;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v24, debugLines->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
  debugLines->m_capacityAndFlags = 0x80000000;
  debugLines->m_data = NULL;
  _R11 = &v36;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
HavokPhysics_StepWorldCollide
==============
*/
void HavokPhysics_StepWorldCollide(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *v8; 
  char v10; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v13; 
  int m_size; 
  hkMonitorStream *v15; 
  hkTaskQueue *taskQueue; 
  hkTaskQueue *v17; 
  int v18; 
  hkMonitorStream *v19; 
  hkMonitorStream *v20; 
  int v21; 
  struct hkTaskQueue::_Handle *v22; 
  hkMonitorStream *v23; 
  hkMemoryAllocator *v24; 
  __int64 v27; 
  int v28; 
  int v29; 
  void *p; 
  int v31; 
  int v32; 
  __int64 v33; 
  hknpTaskGraph taskGraph; 
  char v35; 
  void *retaddr; 

  _RAX = &retaddr;
  v33 = -2i64;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5872, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldCollide with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RAX = HavokPhysics_GetMutableWorld(worldId);
  v8 = _RAX;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rax+20h]
  }
  if ( v10 )
  {
    if ( _RAX->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v8->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v13 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v13, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    v15 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v15 )
      hkMonitorStream::timerBegin(v15, "TtPhysics stepCollide");
    taskQueue = (hkTaskQueue *)v8->taskQueue;
    v17 = taskQueue + 3;
    if ( !taskQueue )
      v17 = NULL;
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5897, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldCollide %i: threadpool is NULL", "g_havokPhysicsThreadPool", v27) )
        __debugbreak();
    }
    if ( v8->isMultithreaded && !v17 )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5898, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || taskQueue)", "%s\n\tHavokPhysics StepWorldCollide %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || taskQueue", v27) )
        __debugbreak();
    }
    if ( !v8->world )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5899, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldCollide %i: world is NULL", "havokPhysicsWorld->world", v27) )
        __debugbreak();
    }
    v18 = 623;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
      v18 = 626;
    Profile_Begin(v18);
    v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v20 = v19;
    if ( v19 )
      hkMonitorStream::timerBegin(v19, "TtPhysics");
    hknpTaskGraph::hknpTaskGraph(&taskGraph);
    Sys_ProfBeginNamedEvent(0xFFFF6347, "GenerateCollideTasks");
    hknpWorld::generateCollideTasks(v8->world, &v8->stepInput, &taskGraph);
    Sys_ProfEndNamedEvent();
    if ( v8->isMultithreaded )
    {
      Profile_Begin(611);
      if ( !Physics_RenderDebugEnabled() )
        HavokPhysicsThreadPool::setUsage(g_havokPhysicsThreadPool, HAVOKPHYSICS_THREADPOOL_USAGE_AUTHCOLLIDE);
      v21 = g_havokPhysicsThreadPool->getNumThreads(g_havokPhysicsThreadPool);
      HavokPhysicsThreadPool::startWorkerCommands(g_havokPhysicsThreadPool, worldId, v21);
      Profile_EndInternal(NULL);
    }
    if ( taskGraph.m_nodes.m_size || taskGraph.m_dependencies.m_size )
    {
      if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5939, ASSERT_TYPE_ASSERT, "(taskQueue != nullptr)", "%s\n\tNo task queue provided", "taskQueue != HK_NULL") )
        __debugbreak();
      v22 = hkTaskGraph::submitToTaskQueue(&taskGraph, v17, FIFO);
      if ( v20 )
        hkMonitorStream::timerEnd(v20, "Et");
      __asm
      {
        vmovss  [rsp+2B8h+var_274], xmm6
        vmovss  [rsp+2B8h+var_278], xmm6
      }
      v8->taskQueue->processUntilFinished(&v8->taskQueue->hkTaskQueue, (float *)&v29, (float *)&v28, v22);
      if ( v20 )
        hkMonitorStream::timerBegin(v20, "TtPhysics");
      hkTaskGraph::freeTaskQueueHandles(&taskGraph, v17);
    }
    if ( v20 )
      hkMonitorStream::timerEnd(v20, "EtPhysics");
    hkTaskGraph::~hkTaskGraph(&taskGraph);
    Profile_EndInternal(NULL);
    if ( v8->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v8->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v8->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v8->taskQueue);
      Profile_EndInternal(NULL);
    }
    v23 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v23 )
      hkMonitorStream::timerEnd(v23, "Et");
    if ( v8->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v8->visContext )
      {
        LODWORD(v27) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5978, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v27) )
          __debugbreak();
      }
      if ( v8->isMultithreaded )
      {
        p = NULL;
        v31 = 0;
        v32 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v24 = hkMemHeapAllocator();
        v31 = 0;
        if ( v32 >= 0 )
          hkMemoryAllocator::bufFree2(v24, p, 16, v32 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
  _R11 = &v35;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
HavokPhysics_StepWorldDetail
==============
*/
void HavokPhysics_StepWorldDetail(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ;
}

/*
==============
HavokPhysics_StepWorldEnd
==============
*/
void HavokPhysics_StepWorldEnd(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  unsigned __int64 TickCounter; 
  unsigned __int64 v8; 
  unsigned __int64 v9; 
  LocalClientNum_t LocalClientForWorld; 
  const char *v13; 
  __int64 v20; 
  __int64 v21; 
  hkVisualDebugger *vdbServer; 
  int v25; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v27; 
  int m_capacityAndFlags; 
  hkMonitorStream *Value; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream **i; 
  __int64 v32; 
  const dvar_t *v33; 
  __int64 v34; 
  __int64 v35; 
  __int64 m_ticks_total; 
  __int64 v50; 
  char v52[16]; 
  __int128 v53[3]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6220, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldEnd with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RBX = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
  TickCounter = hkStopwatch::getTickCounter();
  _RBX->stepStopWatch.m_running_flag.m_bool = 0;
  ++_RBX->stepStopWatch.m_num_timings;
  v8 = TickCounter;
  v9 = TickCounter - _RBX->stepStopWatch.m_ticks_at_split;
  _RBX->stepStopWatch.m_ticks_total += v8 - _RBX->stepStopWatch.m_ticks_at_start;
  _RBX->stepStopWatch.m_split_total += v9;
  if ( !_RBX->vdbServer )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6234, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v50) )
      __debugbreak();
  }
  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  _RDX = 0x140000000ui64;
  if ( LocalClientForWorld == LOCAL_CLIENT_INVALID )
    LocalClientForWorld = LOCAL_CLIENT_0;
  if ( s_havokPhysics_VdbCameraSet[LocalClientForWorld] && _RBX->vdbServer->m_clients.m_size >= 1 )
  {
    __asm { vmovss  xmm1, cs:__real@3dcccccd }
    v13 = s_havokPhysics_VdbCameraNames[LocalClientForWorld];
    _RAX = 2i64 * (int)LocalClientForWorld;
    __asm
    {
      vmovss  [rsp+0C8h+var_48], xmm1
      vmovss  xmm1, cs:__real@42340000
      vmovss  [rsp+0C8h+var_40], xmm1
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraOrigin.m_quad[rdx+rax*8]
      vmovups [rsp+0C8h+var_78], xmm0
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraLookat.m_quad[rdx+rax*8]
      vmovups [rsp+0C8h+var_68], xmm0
      vmovups xmm0, xmmword ptr rva s_havokPhysics_VdbCameraUp.m_quad[rdx+rax*8]
      vmovups [rsp+0C8h+var_58], xmm0
      vmovss  xmm0, cs:__real@461c4000
      vmovss  [rsp+0C8h+var_44], xmm0
    }
    ((void (__fastcall *)(hkDebugDisplay *, char *, const char *, __int128 *))hkDebugDisplay::singleton.m_ptr->updateCamera)(hkDebugDisplay::singleton.m_ptr, v52, v13, v53);
  }
  hkCommonProcessContext::syncTimers(_RBX->comContext, NULL);
  if ( !_RBX->vdbServer )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6248, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v50) )
      __debugbreak();
  }
  vdbServer = _RBX->vdbServer;
  LOBYTE(v21) = 5;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+20h]
    vmulss  xmm1, xmm0, cs:__real@447a0000
  }
  v52[8] = 5;
  ((void (__fastcall *)(hkVisualDebugger *, __int64, __int64))vdbServer->step)(vdbServer, v20, v21);
  v25 = numStepsPlanned - 1;
  if ( stepIndex == v25 )
  {
    debugLines = _RBX->debugLines;
    v27 = hkMemHeapAllocator();
    m_capacityAndFlags = debugLines->m_capacityAndFlags;
    debugLines->m_size = 0;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v27, debugLines->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
    debugLines->m_data = NULL;
    debugLines->m_capacityAndFlags = 0x80000000;
  }
  if ( _RBX->isMultithreaded || stepIndex == v25 )
  {
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::reset(Value);
    monitorStreams = _RBX->monitorStreams;
    if ( _RBX->isMultithreaded )
    {
      for ( i = monitorStreams->m_data; i != &monitorStreams->m_data[monitorStreams->m_size]; ++i )
      {
        hkMonitorStream::reset(*i);
        monitorStreams = _RBX->monitorStreams;
      }
      monitorStreams->m_size = 0;
      g_havokPhysicsThreadPool->clearTimerData(g_havokPhysicsThreadPool);
    }
    else if ( monitorStreams->m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6274, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams->getSize() == 0)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams->getSize() == 0") )
    {
      __debugbreak();
    }
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
  Profile_Begin(770);
  HavokPhysicsInstanceManager_PropagateAddedFlags(&_RBX->instanceManager);
  Profile_EndInternal(NULL);
  if ( stepIndex == v25 )
  {
    Profile_Begin(771);
    HavokPhysics_DoDeferredQueries(worldId);
    Profile_EndInternal(NULL);
  }
  if ( !_RBX->persistentStreamAllocator )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6297, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v50) )
      __debugbreak();
  }
  _RBX->persistentStreamAllocator->getMemoryStatistics(_RBX->persistentStreamAllocator, &_RBX->persistentMemoryStats.m_allocatorStats);
  if ( !s_havokPhysicsGeneralLargeBlockAllocator )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6301, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator", v50) )
      __debugbreak();
  }
  v32 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  if ( *(__int64 *)&s_generalMemoryPeakInUse > v32 )
    v32 = *(_QWORD *)&s_generalMemoryPeakInUse;
  *(_QWORD *)&s_generalMemoryPeakInUse = v32;
  if ( v32 > s_generalMemoryThreshold )
  {
    v33 = DVARBOOL_physics_disableSpammyWarnings;
    if ( !DVARBOOL_physics_disableSpammyWarnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_disableSpammyWarnings") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    if ( !v33->current.enabled )
      Com_PrintWarning(20, "Physics General Memory Buffer almost full - using %llu bytes with target max of %llu.  Turn this message off with dvar physics_disableSpammyWarnings\n", *(_QWORD *)&s_generalMemoryPeakInUse, s_generalMemoryThreshold);
  }
  v34 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  if ( *(__int64 *)&s_mapLocalMemoryPeakInUse > v34 )
    v34 = *(_QWORD *)&s_mapLocalMemoryPeakInUse;
  *(_QWORD *)&s_mapLocalMemoryPeakInUse = v34;
  if ( s_havokPhysicsDebugMemoryAllocator )
  {
    v35 = s_havokPhysicsDebugMemoryAllocator->getApproxTotalAllocated(&s_havokPhysicsDebugMemoryAllocator->hkMemoryAllocator::ExtendedInterface);
    if ( *(__int64 *)&s_debugMemoryPeakInUse > v35 )
      v35 = *(_QWORD *)&s_debugMemoryPeakInUse;
    *(_QWORD *)&s_debugMemoryPeakInUse = v35;
  }
  if ( _RBX->stepCPUIndex >= 6 )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6319, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->stepCPUIndex < PHYSICS_MAX_STEPS_PER_FRAME)", "%s\n\tHavokPhysics StepWorldEnd %i: too many steps captured", "havokPhysicsWorld->stepCPUIndex < PHYSICS_MAX_STEPS_PER_FRAME", v50) )
      __debugbreak();
  }
  m_ticks_total = _RBX->stepStopWatch.m_ticks_total;
  if ( _RBX->stepStopWatch.m_running_flag.m_bool )
    m_ticks_total += hkStopwatch::getTickCounter() - _RBX->stepStopWatch.m_ticks_at_start;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2sd xmm0, xmm0, rdi
  }
  if ( m_ticks_total < 0 )
    __asm { vaddsd  xmm0, xmm0, cs:__real@43f0000000000000 }
  __asm { vmulsd  xmm0, xmm0, qword ptr [rbx+0E80h] }
  _RAX = _RBX->stepCPUIndex;
  __asm
  {
    vcvtsd2ss xmm1, xmm0, xmm0
    vmulss  xmm2, xmm1, cs:__real@447a0000
    vmovss  dword ptr [rbx+rax*4+0ED8h], xmm2
  }
  _RCX = _RBX->stepCPUIndex;
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+0EF4h]
    vmaxss  xmm2, xmm1, dword ptr [rbx+rcx*4+0ED8h]
    vmovss  xmm1, dword ptr [rbx+0EFCh]
    vmovss  dword ptr [rbx+0EF4h], xmm2
    vmovss  xmm0, dword ptr [rbx+rcx*4+0ED8h]
    vaddss  xmm3, xmm0, dword ptr [rbx+0EF8h]
    vmaxss  xmm2, xmm1, xmm3
    vmovss  dword ptr [rbx+0EFCh], xmm2
    vmovss  dword ptr [rbx+0EF8h], xmm3
  }
  _RBX->stepCPUIndex = _RCX + 1;
}

/*
==============
HavokPhysics_StepWorldFX
==============
*/
void HavokPhysics_StepWorldFX(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v6; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v9; 
  int m_size; 
  hkMonitorStream *v11; 
  hkMonitorStream *v12; 
  hkMemoryAllocator *v13; 
  __int64 v14; 
  void *p; 
  int v17; 
  int v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6129, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldFX with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = MutableWorld;
  if ( MutableWorld->hasFXSupport )
  {
    if ( MutableWorld->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v6->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v9 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v9, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    PhysicsFX_Lock(1);
    v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v11 )
      hkMonitorStream::timerBegin(v11, "TtFX Step");
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6156, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldFX %i: threadpool is NULL", "g_havokPhysicsThreadPool", v14) )
        __debugbreak();
    }
    if ( v6->isMultithreaded && !v6->taskQueue )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6157, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics StepWorldFX %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue", v14) )
        __debugbreak();
    }
    if ( !v6->world )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6158, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldFX %i: world is NULL", "havokPhysicsWorld->world", v14) )
        __debugbreak();
    }
    if ( v6->hasFXSupport )
      PhysicsFX_StepWorld(worldId);
    if ( v6->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v6->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v6->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v6->taskQueue);
      Profile_EndInternal(NULL);
    }
    v12 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v12 )
      hkMonitorStream::timerEnd(v12, "Et");
    PhysicsFX_Lock(0);
    if ( v6->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v6->visContext )
      {
        LODWORD(v14) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6188, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v14) )
          __debugbreak();
      }
      if ( v6->isMultithreaded )
      {
        p = NULL;
        v17 = 0;
        v18 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v13 = hkMemHeapAllocator();
        v17 = 0;
        if ( v18 >= 0 )
          hkMemoryAllocator::bufFree2(v13, p, 16, v18 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
}

/*
==============
HavokPhysics_StepWorldPhysicsObjects
==============
*/
void HavokPhysics_StepWorldPhysicsObjects(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ;
}

/*
==============
HavokPhysics_StepWorldPrep
==============
*/

void __fastcall HavokPhysics_StepWorldPrep(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, double stepTimeOverride)
{
  char v8; 
  char v11; 
  Physics_WorldId v16; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  Profile_Begin(610);
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v16 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5842, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldStep with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v16) )
      __debugbreak();
  }
  _RAX = HavokPhysics_GetMutableWorld(worldId);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v11 | v8 )
    __asm { vmovss  xmm6, dword ptr [rax+84h] }
  __asm
  {
    vmovss  xmm1, dword ptr [rax+24h]
    vucomiss xmm1, xmm0
    vmovss  dword ptr [rax+20h], xmm6
  }
  if ( !v8 )
  {
    __asm
    {
      vminss  xmm6, xmm1, xmm6
      vmovss  dword ptr [rax+20h], xmm6
    }
  }
  __asm
  {
    vmulss  xmm0, xmm6, cs:__real@3f99999a
    vmaxss  xmm1, xmm0, xmm1
    vmovss  dword ptr [rax+24h], xmm1
    vmovaps xmm6, [rsp+58h+var_18]
  }
  Profile_EndInternal(NULL);
}

/*
==============
HavokPhysics_StepWorldSolve
==============
*/
void HavokPhysics_StepWorldSolve(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *v8; 
  char v10; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v13; 
  int m_size; 
  hkMonitorStream *v15; 
  hkTaskQueue *taskQueue; 
  hkTaskQueue *v17; 
  int v18; 
  hkMonitorStream *v19; 
  hkMonitorStream *v20; 
  int v21; 
  struct hkTaskQueue::_Handle *v22; 
  hkMonitorStream *v23; 
  hkMemoryAllocator *v24; 
  __int64 v27; 
  int v28; 
  int v29; 
  void *p; 
  int v31; 
  int v32; 
  __int64 v33; 
  hknpTaskGraph taskGraph; 
  char v35; 
  void *retaddr; 

  _RAX = &retaddr;
  v33 = -2i64;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6003, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldSolve with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  _RAX = HavokPhysics_GetMutableWorld(worldId);
  v8 = _RAX;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rax+20h]
  }
  if ( v10 )
  {
    if ( _RAX->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v8->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v13 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v13, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    v15 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v15 )
      hkMonitorStream::timerBegin(v15, "TtPhysics stepSolve");
    taskQueue = (hkTaskQueue *)v8->taskQueue;
    v17 = taskQueue + 3;
    if ( !taskQueue )
      v17 = NULL;
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6029, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldSolve %i: threadpool is NULL", "g_havokPhysicsThreadPool", v27) )
        __debugbreak();
    }
    if ( v8->isMultithreaded && !v17 )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6030, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || taskQueue)", "%s\n\tHavokPhysics StepWorldSolve %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || taskQueue", v27) )
        __debugbreak();
    }
    if ( !v8->world )
    {
      LODWORD(v27) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6031, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldSolve %i: world is NULL", "havokPhysicsWorld->world", v27) )
        __debugbreak();
    }
    v18 = 624;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
      v18 = 627;
    Profile_Begin(v18);
    v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v20 = v19;
    if ( v19 )
      hkMonitorStream::timerBegin(v19, "TtPhysics");
    hknpTaskGraph::hknpTaskGraph(&taskGraph);
    Sys_ProfBeginNamedEvent(0xFFFF6347, "GenerateSolveTasks");
    hknpWorld::generateSolveTasks(v8->world, &taskGraph);
    Sys_ProfEndNamedEvent();
    if ( v8->isMultithreaded )
    {
      Profile_Begin(611);
      if ( !Physics_RenderDebugEnabled() )
        HavokPhysicsThreadPool::setUsage(g_havokPhysicsThreadPool, HAVOKPHYSICS_THREADPOOL_USAGE_AUTHSOLVE);
      v21 = g_havokPhysicsThreadPool->getNumThreads(g_havokPhysicsThreadPool);
      HavokPhysicsThreadPool::startWorkerCommands(g_havokPhysicsThreadPool, worldId, v21);
      Profile_EndInternal(NULL);
    }
    if ( taskGraph.m_nodes.m_size || taskGraph.m_dependencies.m_size )
    {
      if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6071, ASSERT_TYPE_ASSERT, "(taskQueue != nullptr)", "%s\n\tNo task queue provided", "taskQueue != HK_NULL") )
        __debugbreak();
      v22 = hkTaskGraph::submitToTaskQueue(&taskGraph, v17, FIFO);
      if ( v20 )
        hkMonitorStream::timerEnd(v20, "Et");
      __asm
      {
        vmovss  [rsp+2B8h+var_274], xmm6
        vmovss  [rsp+2B8h+var_278], xmm6
      }
      v8->taskQueue->processUntilFinished(&v8->taskQueue->hkTaskQueue, (float *)&v29, (float *)&v28, v22);
      if ( v20 )
        hkMonitorStream::timerBegin(v20, "TtPhysics");
      hkTaskGraph::freeTaskQueueHandles(&taskGraph, v17);
    }
    if ( v20 )
      hkMonitorStream::timerEnd(v20, "EtPhysics");
    hkTaskGraph::~hkTaskGraph(&taskGraph);
    Profile_EndInternal(NULL);
    if ( v8->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v8->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v8->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v8->taskQueue);
      Profile_EndInternal(NULL);
    }
    v23 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v23 )
      hkMonitorStream::timerEnd(v23, "Et");
    if ( v8->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v8->visContext )
      {
        LODWORD(v27) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6110, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v27) )
          __debugbreak();
      }
      if ( v8->isMultithreaded )
      {
        p = NULL;
        v31 = 0;
        v32 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v24 = hkMemHeapAllocator();
        v31 = 0;
        if ( v32 >= 0 )
          hkMemoryAllocator::bufFree2(v24, p, 16, v32 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
  _R11 = &v35;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
HavokPhysics_StepWorldStart
==============
*/
void HavokPhysics_StepWorldStart(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  bool v6; 
  HavokPhysicsWorld *v7; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hkMemoryRouter *Value; 
  hkStreamWriter_vtbl *v10; 
  hknpWorldSnapshot *v11; 
  hknpWorldSnapshot *v12; 
  unsigned __int64 TickCounter; 
  hkBool result; 
  hkStreamWriter writer; 
  hkOstream v16; 

  writer.m_propertyBag.m_bag = (hkDefaultPropertyBag *)-2i64;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( s_havokPhysics_forceSnapshot )
  {
    s_havokPhysics_forceSnapshot = 0;
    v6 = s_havokPhysics_humanReadableSnapshot;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24049, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Take Snapshot with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
      __debugbreak();
    v7 = HavokPhysics_GetMutableWorld(worldId);
    p_critSection = (_RTL_CRITICAL_SECTION *)&v7->critSection;
    *(_QWORD *)&writer.m_memSizeAndFlags = &v7->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&v7->critSection);
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v10 = (hkStreamWriter_vtbl *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
    writer.__vftable = v10;
    if ( v10 )
    {
      hknpWorldSnapshot::hknpWorldSnapshot((hknpWorldSnapshot *)v10, v7->world, 0);
      v12 = v11;
    }
    else
    {
      v12 = NULL;
    }
    hkOstream::hkOstream(&v16, "HavokSnapshot.hkx");
    if ( hkOstream::isOk(&v16, &result)->m_bool )
    {
      if ( v6 )
        hknpWorldSnapshot::saveAsXml(v12, &writer);
      else
        hknpWorldSnapshot::saveAsBinary(v12, &writer);
    }
    hkReferencedObject::removeReference(v12);
    hkOstream::~hkOstream(&v16);
    LeaveCriticalSection(p_critSection);
  }
  MutableWorld->stepStopWatch.m_ticks_at_start = 0i64;
  MutableWorld->stepStopWatch.m_ticks_total = 0i64;
  MutableWorld->stepStopWatch.m_ticks_at_split = 0i64;
  MutableWorld->stepStopWatch.m_split_total = 0i64;
  MutableWorld->stepStopWatch.m_num_timings = 0;
  MutableWorld->stepStopWatch.m_running_flag.m_bool = 1;
  TickCounter = hkStopwatch::getTickCounter();
  MutableWorld->stepStopWatch.m_ticks_at_start = TickCounter;
  MutableWorld->stepStopWatch.m_ticks_at_split = TickCounter;
}

/*
==============
HavokPhysics_StopDrawDebugWorld
==============
*/
void HavokPhysics_StopDrawDebugWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  int v3; 
  __int64 v4; 
  hkProcess *v5; 
  hkMemoryAllocator *v6; 
  int m_capacityAndFlags; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17379, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StopDrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  v3 = 0;
  if ( MutableWorld->visProcesses.m_size > 0 )
  {
    v4 = 0i64;
    do
    {
      v5 = MutableWorld->visProcesses.m_data[v4];
      if ( v5 )
        ((void (__fastcall *)(hkProcess *, __int64))v5->~hkProcess)(v5, 1i64);
      ++v3;
      ++v4;
    }
    while ( v3 < MutableWorld->visProcesses.m_size );
  }
  v6 = hkMemHeapAllocator();
  MutableWorld->visProcesses.m_size = 0;
  m_capacityAndFlags = MutableWorld->visProcesses.m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v6, MutableWorld->visProcesses.m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  MutableWorld->visProcesses.m_data = NULL;
  MutableWorld->visProcesses.m_capacityAndFlags = 0x80000000;
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_SubscribeToEvent
==============
*/
void HavokPhysics_SubscribeToEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (*function)(const hknpEventHandlerInput *, const hknpEvent *), const char *name)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  hknpEventSignal *EventSignal; 
  __int64 v12; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 0x4000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to SubscribeToEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16388, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics SubscribeToEvent %i: world is NULL", "physicsWorld->world", v12) )
      __debugbreak();
  }
  m_serialAndIndex = specificBodyId.m_serialAndIndex;
  if ( (specificBodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    m_serialAndIndex = 0xFFFFFF;
  EventSignal = hknpWorld::getEventSignal(MutableWorld->world, eventType, (hknpBodyId)m_serialAndIndex);
  hkSignal2<hknpEventHandlerInput const &,hknpEvent const &>::subscribe<void (*)(hknpEventHandlerInput const &,hknpEvent const &)>(EventSignal, function, name);
}

/*
==============
HavokPhysics_SwapPhysicsAsset
==============
*/
void HavokPhysics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  Dummy *v9; 
  PhysicsAsset *key; 
  unsigned __int64 val; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  unsigned __int64 v18; 
  unsigned __int64 v19; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v25; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  unsigned __int32 v33; 
  unsigned __int32 v34; 
  int v35; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v37; 
  PhysicsAsset *v38; 
  __int64 v39; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v40; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v41; 
  int v42; 
  int v43; 
  unsigned __int32 v44; 
  unsigned __int32 v45; 
  int v46; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v47; 
  unsigned int v48; 
  PhysicsAsset *v49; 
  __int64 v50; 
  hkMemoryAllocator alloc; 
  hkMemoryAllocator v52; 

  _RSI = to;
  _RDI = from;
  HavokPhysics_LockAssetWrite();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7501, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7502, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7503, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)_RDI), v7 = _byteswap_ulong(-1640531535 * HIDWORD(_RDI)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = (Dummy *)v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != _RDI )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = (Dummy *)v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( (int)v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7506, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( fromIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( fromIt )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[(int)v9].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v4->m_map, v9);
  v12 = s_havokPhysicsAssets;
  v13 = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * (_DWORD)_RSI), v15 = _byteswap_ulong(-1640531535 * HIDWORD(_RSI)), v16 = v13 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = s_havokPhysicsAssets->m_map.m_elem[v16].key, v18 == -1i64) )
  {
LABEL_24:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( (PhysicsAsset *)v18 != _RSI )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = s_havokPhysicsAssets->m_map.m_elem[v16].key;
      if ( v18 == -1i64 )
        goto LABEL_24;
    }
  }
  if ( (int)v17 > v13 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7511, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( toIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( toIt )") )
      __debugbreak();
    v12 = s_havokPhysicsAssets;
  }
  v19 = v12->m_map.m_elem[(int)v17].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v12->m_map, v17);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymm3, ymmword ptr [rdi]
    vmovups ymm4, ymmword ptr [rdi+20h]
    vmovups xmm5, xmmword ptr [rdi+40h]
    vmovsd  xmm2, qword ptr [rdi+50h]
  }
  v25 = s_havokPhysicsAssets;
  __asm
  {
    vmovups ymmword ptr [rdi], ymm0
    vmovups ymm1, ymmword ptr [rsi+20h]
    vmovups ymmword ptr [rdi+20h], ymm1
    vmovups xmm0, xmmword ptr [rsi+40h]
    vmovups xmmword ptr [rdi+40h], xmm0
    vmovsd  xmm1, qword ptr [rsi+50h]
    vmovsd  qword ptr [rdi+50h], xmm1
    vmovups ymmword ptr [rsi], ymm3
    vmovups ymmword ptr [rsi+20h], ymm4
    vmovups xmmword ptr [rsi+40h], xmm5
    vmovsd  qword ptr [rsi+50h], xmm2
  }
  v29 = (unsigned int)hkMemHeapAllocator();
  v30 = v25->m_map.m_hashMod;
  if ( 2 * v25->m_map.m_numElems > v30 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v25->m_map, &alloc, v29);
    v30 = v25->m_map.m_hashMod;
  }
  v31 = 1;
  v32 = 1;
  v33 = _byteswap_ulong(-1640531535 * (_DWORD)_RSI);
  v34 = _byteswap_ulong(-1640531535 * HIDWORD(_RSI));
  v35 = v34 ^ ((v33 >> 2) + v33 + (v34 << 6) - 1640531527);
  m_elem = v25->m_map.m_elem;
  v37 = v30 & v35;
  v38 = (PhysicsAsset *)v25->m_map.m_elem[v37].key;
  if ( v38 != (PhysicsAsset *)-1i64 )
  {
    while ( v38 != _RSI )
    {
      v37 = v25->m_map.m_hashMod & (v37 + 1);
      v38 = (PhysicsAsset *)m_elem[v37].key;
      if ( v38 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v32 = 0;
  }
LABEL_36:
  v25->m_map.m_numElems += v32;
  v39 = (int)v37;
  m_elem[v39].key = (unsigned __int64)_RSI;
  v40 = v25->m_map.m_elem;
  v41 = s_havokPhysicsAssets;
  v40[v39].val = val;
  v42 = (unsigned int)hkMemHeapAllocator();
  v43 = v41->m_map.m_hashMod;
  if ( 2 * v41->m_map.m_numElems > v43 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v41->m_map, &v52, v42);
    v43 = v41->m_map.m_hashMod;
  }
  v44 = _byteswap_ulong(-1640531535 * (_DWORD)_RDI);
  v45 = _byteswap_ulong(-1640531535 * HIDWORD(_RDI));
  v46 = v45 ^ ((v44 >> 2) + v44 + (v45 << 6) - 1640531527);
  v47 = v41->m_map.m_elem;
  v48 = v43 & v46;
  v49 = (PhysicsAsset *)v41->m_map.m_elem[v48].key;
  if ( v49 != (PhysicsAsset *)-1i64 )
  {
    while ( v49 != _RDI )
    {
      v48 = v41->m_map.m_hashMod & (v48 + 1);
      v49 = (PhysicsAsset *)v47[v48].key;
      if ( v49 == (PhysicsAsset *)-1i64 )
        goto LABEL_43;
    }
    v31 = 0;
  }
LABEL_43:
  v41->m_map.m_numElems += v31;
  v50 = (int)v48;
  v47[v50].key = (unsigned __int64)_RDI;
  v41->m_map.m_elem[v50].val = v19;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapPhysicsSFXEventAsset
==============
*/
void HavokPhysics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  unsigned int v4; 
  unsigned int v7; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 

  val = to;
  _RDI = to;
  _RSI = from;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7092, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7093, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7094, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)_RSI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7097, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)_RDI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7098, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsSFXAssetInternal(_RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups ymm1, ymmword ptr [rsi]
    vmovups ymmword ptr [rsi], ymm0
    vmovups ymmword ptr [rdi], ymm1
  }
  v7 = v4;
  HavokPhysics_LockAssetWrite();
  key = v7;
  v8 = g_physicsSFXEventAssets;
  v9 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::insert(v8, v9, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapPhysicsVFXEventAsset
==============
*/
void HavokPhysics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  unsigned int v4; 
  unsigned int v7; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  unsigned int key; 
  PhysicsVFXEventAsset *val; 

  val = to;
  _RDI = to;
  _RSI = from;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7256, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7257, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7258, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)_RSI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7261, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)_RDI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7262, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsVFXAssetInternal(_RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups ymm1, ymmword ptr [rsi]
    vmovups ymmword ptr [rsi], ymm0
    vmovups ymmword ptr [rdi], ymm1
  }
  v7 = v4;
  HavokPhysics_LockAssetWrite();
  key = v7;
  v8 = g_physicsVFXEventAssets;
  v9 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::insert(v8, v9, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapXModelDetailCollisionAsset
==============
*/
void HavokPhysics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  unsigned __int64 v5; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v6; 
  int m_hashMod; 
  unsigned __int32 v8; 
  unsigned __int32 v9; 
  unsigned int v10; 
  Dummy *v11; 
  XModelDetailCollision *key; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  XModelDetailCollision *v18; 
  int v19; 
  int v20; 
  int v21; 
  int v22; 
  unsigned __int32 v23; 
  unsigned __int32 v24; 
  int v25; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v27; 
  XModelDetailCollision *v28; 
  __int64 v29; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v30; 
  int v31; 
  int v32; 
  unsigned __int32 v33; 
  unsigned __int32 v34; 
  int v35; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v36; 
  unsigned int v37; 
  XModelDetailCollision *v38; 
  __int64 v39; 
  hkMemoryAllocator alloc; 
  hkMemoryAllocator v41; 

  val = 0i64;
  v5 = 0i64;
  HavokPhysics_LockAssetWrite();
  v6 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v8 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v9 = _byteswap_ulong(-1640531535 * (_DWORD)from), v10 = m_hashMod & (v8 ^ ((v9 >> 2) + v9 + (v8 << 6) - 1640531527)), v11 = (Dummy *)v10, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v10].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v11 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v10 = m_hashMod & (v10 + 1);
      v11 = (Dummy *)v10;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v10].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( (int)v11 <= m_hashMod )
  {
    val = s_havokPhysicsXModelLODs->m_map.m_elem[(int)v11].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&s_havokPhysicsXModelLODs->m_map, v11);
    v6 = s_havokPhysicsXModelLODs;
  }
  v13 = v6->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v15 = _byteswap_ulong(-1640531535 * (_DWORD)to), v16 = v13 & (v14 ^ ((v15 >> 2) + v15 + (v14 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = (XModelDetailCollision *)v6->m_map.m_elem[v16].key, v18 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( v18 != to )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = (XModelDetailCollision *)v6->m_map.m_elem[v16].key;
      if ( v18 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( (int)v17 <= v13 )
  {
    v5 = v6->m_map.m_elem[(int)v17].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v6->m_map, v17);
    v6 = s_havokPhysicsXModelLODs;
  }
  v19 = 1;
  if ( val )
  {
    v20 = (unsigned int)hkMemHeapAllocator();
    v21 = v6->m_map.m_hashMod;
    if ( 2 * v6->m_map.m_numElems > v21 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v6->m_map, &alloc, v20);
      v21 = v6->m_map.m_hashMod;
    }
    v22 = 1;
    v23 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v24 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v25 = v24 ^ ((v23 >> 2) + v23 + (v24 << 6) - 1640531527);
    m_elem = v6->m_map.m_elem;
    v27 = v21 & v25;
    v28 = (XModelDetailCollision *)v6->m_map.m_elem[v27].key;
    if ( v28 != (XModelDetailCollision *)-1i64 )
    {
      while ( v28 != to )
      {
        v27 = v6->m_map.m_hashMod & (v27 + 1);
        v28 = (XModelDetailCollision *)m_elem[v27].key;
        if ( v28 == (XModelDetailCollision *)-1i64 )
          goto LABEL_23;
      }
      v22 = 0;
    }
LABEL_23:
    v6->m_map.m_numElems += v22;
    v29 = (int)v27;
    m_elem[v29].key = (unsigned __int64)to;
    v30 = v6->m_map.m_elem;
    v6 = s_havokPhysicsXModelLODs;
    v30[v29].val = val;
  }
  if ( v5 )
  {
    v31 = (unsigned int)hkMemHeapAllocator();
    v32 = v6->m_map.m_hashMod;
    if ( 2 * v6->m_map.m_numElems > v32 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v6->m_map, &v41, v31);
      v32 = v6->m_map.m_hashMod;
    }
    v33 = _byteswap_ulong(-1640531535 * (_DWORD)from);
    v34 = _byteswap_ulong(-1640531535 * HIDWORD(from));
    v35 = v34 ^ ((v33 >> 2) + v33 + (v34 << 6) - 1640531527);
    v36 = v6->m_map.m_elem;
    v37 = v32 & v35;
    v38 = (XModelDetailCollision *)v6->m_map.m_elem[v37].key;
    if ( v38 != (XModelDetailCollision *)-1i64 )
    {
      while ( v38 != from )
      {
        v37 = v6->m_map.m_hashMod & (v37 + 1);
        v38 = (XModelDetailCollision *)v36[v37].key;
        if ( v38 == (XModelDetailCollision *)-1i64 )
          goto LABEL_32;
      }
      v19 = 0;
    }
LABEL_32:
    v6->m_map.m_numElems += v19;
    v39 = (int)v37;
    v36[v39].key = (unsigned __int64)from;
    v6->m_map.m_elem[v39].val = v5;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_TakeMemorySnapshot
==============
*/
void HavokPhysics_TakeMemorySnapshot(const char *filename)
{
  hkMemoryTrackerReportUtil::takeSnapshotsAndGenerateReport(hkMemoryTracker::s_singleton, filename);
}

/*
==============
HavokPhysics_TakeSnapshot
==============
*/
void HavokPhysics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hkMemoryRouter *Value; 
  hknpWorldSnapshot *v9; 
  hknpWorldSnapshot *v10; 
  hknpWorldSnapshot *v11; 
  hkOstream v12; 
  hkStreamWriter result; 
  hkCriticalSection *v14; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24049, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Take Snapshot with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  v14 = &MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v9 = (hknpWorldSnapshot *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
  if ( v9 )
  {
    hknpWorldSnapshot::hknpWorldSnapshot(v9, MutableWorld->world, 0);
    v11 = v10;
  }
  else
  {
    v11 = NULL;
  }
  hkOstream::hkOstream(&v12, filename);
  if ( hkOstream::isOk(&v12, (hkBool *)&result)->m_bool )
  {
    if ( humanReadable )
      hknpWorldSnapshot::saveAsXml(v11, &result);
    else
      hknpWorldSnapshot::saveAsBinary(v11, &result);
  }
  hkReferencedObject::removeReference(v11);
  hkOstream::~hkOstream(&v12);
  LeaveCriticalSection(p_critSection);
}

/*
==============
HavokPhysics_Task
==============
*/
void HavokPhysics_Task(Physics_WorldId worldId, int taskId)
{
  hkMonitorStream *Value; 
  HavokPhysicsWorld *MutableWorld; 
  hkMonitorStream *v8; 
  __int64 v11; 
  int v12; 
  __int64 v13; 
  Physics_WorldId v14; 
  float timeWaiting; 
  float timeTaken; 

  HavokPhysicsThreadPool::onWorkerCommandStart(g_havokPhysicsThreadPool, taskId);
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtThread Task");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v14 = worldId;
    v12 = taskId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6341, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to do a Task %i with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v12, v14) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->taskQueue )
  {
    LODWORD(v13) = worldId;
    LODWORD(v11) = taskId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6345, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics: Trying to do a Task %i with invalid task queue for world %i", "havokPhysicsWorld->taskQueue", v11, v13) )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+48h+timeTaken], xmm0
    vmovss  [rsp+48h+timeWaiting], xmm0
  }
  hkDefaultTaskQueue::process(MutableWorld->taskQueue, &timeTaken, &timeWaiting);
  v8 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v8 )
    hkMonitorStream::timerEnd(v8, "Et");
  __asm
  {
    vmovss  xmm3, [rsp+48h+timeWaiting]; timeWaiting
    vmovss  xmm2, [rsp+48h+timeTaken]; timeTaken
  }
  HavokPhysicsThreadPool::onWorkerCommandEnd(g_havokPhysicsThreadPool, taskId, *(float *)&_XMM2, *(float *)&_XMM3);
}

/*
==============
HavokPhysics_TightenConstraint
==============
*/

void __fastcall HavokPhysics_TightenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *values, double proportion)
{
  HavokPhysicsWorld *MutableWorld; 
  int v9; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  _RBX = *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value) + 8);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13518, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)_RBX + 24i64))(_RBX);
  if ( v9 == 2 )
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm2, xmm0, xmm6
      vmulss  xmm1, xmm2, dword ptr [rdi+8]
      vmulss  xmm0, xmm6, dword ptr [rdi+1Ch]
      vaddss  xmm1, xmm1, xmm0
      vmovss  dword ptr [rbx+0FCh], xmm1
      vmulss  xmm2, xmm2, dword ptr [rdi+4]
      vmulss  xmm0, xmm6, dword ptr [rdi+18h]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+0F8h], xmm1
    }
  }
  else if ( v9 == 7 )
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm3, xmm0, xmm6
      vmulss  xmm1, xmm3, dword ptr [rdi+4]
      vmulss  xmm0, xmm6, dword ptr [rdi+18h]
      vaddss  xmm1, xmm1, xmm0
      vmovss  dword ptr [rbx+15Ch], xmm1
      vmulss  xmm2, xmm3, dword ptr [rdi+0Ch]
      vmulss  xmm0, xmm6, dword ptr [rdi+20h]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+17Ch], xmm1
      vmulss  xmm2, xmm3, dword ptr [rdi+8]
      vmulss  xmm0, xmm6, dword ptr [rdi+1Ch]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+178h], xmm1
      vmulss  xmm2, xmm3, dword ptr [rdi+14h]
      vmulss  xmm0, xmm6, dword ptr [rdi+28h]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+13Ch], xmm1
      vmulss  xmm2, xmm3, dword ptr [rdi+10h]
      vmulss  xmm0, xmm6, dword ptr [rdi+24h]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+138h], xmm1
      vmovaps xmm6, [rsp+48h+var_18]
    }
    return;
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
HavokPhysics_TransientZoneLoaded
==============
*/
void HavokPhysics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  const char *WorldTransientName; 
  char *fmt; 
  __int64 v6; 

  if ( worldTransientIndex )
  {
    if ( worldTransientIndex - 1 <= 0x1E )
      goto LABEL_7;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3937, ASSERT_TYPE_ASSERT, "(worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE)", (const char *)&queryFormat, "worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE") )
  {
    __debugbreak();
  }
  LODWORD(v6) = worldTransientIndex;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3938, ASSERT_TYPE_ASSERT, "( HAVOK_PHYSICS_TRANSIENT_ZONES_START ) <= ( worldTransientIndex ) && ( worldTransientIndex ) <= ( HAVOK_PHYSICS_MAX_ZONES - 1 )", "worldTransientIndex not in [HAVOK_PHYSICS_TRANSIENT_ZONES_START, HAVOK_PHYSICS_MAX_ZONES - 1]\n\t%i not in [%i, %i]", v6, 1, 31) )
    __debugbreak();
LABEL_7:
  WorldTransientName = DB_Transients_GetWorldTransientName(worldTransientIndex);
  LODWORD(fmt) = fullLoad;
  Com_Printf(10, "HavokPhysics_TransientZone: Loaded %u %s %d\n", worldTransientIndex, WorldTransientName, fmt);
}

/*
==============
HavokPhysics_TransientZoneUnloading
==============
*/
void HavokPhysics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  const char *WorldTransientName; 
  char *fmt; 
  __int64 v6; 

  if ( worldTransientIndex )
  {
    if ( worldTransientIndex - 1 <= 0x1E )
      goto LABEL_7;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3947, ASSERT_TYPE_ASSERT, "(worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE)", (const char *)&queryFormat, "worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE") )
  {
    __debugbreak();
  }
  LODWORD(v6) = worldTransientIndex;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3948, ASSERT_TYPE_ASSERT, "( HAVOK_PHYSICS_TRANSIENT_ZONES_START ) <= ( worldTransientIndex ) && ( worldTransientIndex ) <= ( HAVOK_PHYSICS_MAX_ZONES - 1 )", "worldTransientIndex not in [HAVOK_PHYSICS_TRANSIENT_ZONES_START, HAVOK_PHYSICS_MAX_ZONES - 1]\n\t%i not in [%i, %i]", v6, 1, 31) )
    __debugbreak();
LABEL_7:
  WorldTransientName = DB_Transients_GetWorldTransientName(worldTransientIndex);
  LODWORD(fmt) = fullUnload;
  Com_Printf(10, "HavokPhysics_TransientZone: Unloading %u %s %d\n", worldTransientIndex, WorldTransientName, fmt);
}

/*
==============
HavokPhysics_UnlockAssetRead
==============
*/
void HavokPhysics_UnlockAssetRead(void)
{
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_UnlockAssetWrite
==============
*/
void HavokPhysics_UnlockAssetWrite(void)
{
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_UnlockWorld
==============
*/
void HavokPhysics_UnlockWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6438, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to unlock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_UnsubscribeFromEvent
==============
*/
void HavokPhysics_UnsubscribeFromEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (*function)(const hknpEventHandlerInput *, const hknpEvent *))
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  hknpEventSignal *EventSignal; 
  __int64 v11; 
  void (__fastcall *method[5])(const hknpEventHandlerInput *, const hknpEvent *); 
  hkBool result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16407, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to UnsubscribeFromEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16411, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics UnsubscribeFromEvent %i: world is NULL", "physicsWorld->world", v11) )
      __debugbreak();
  }
  m_serialAndIndex = specificBodyId.m_serialAndIndex;
  if ( (specificBodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    m_serialAndIndex = 0xFFFFFF;
  EventSignal = hknpWorld::getEventSignal(MutableWorld->world, eventType, (hknpBodyId)m_serialAndIndex);
  method[0] = function;
  hkSignal::unsubscribeInternal(EventSignal, &result, NULL, method, 8);
}

/*
==============
HavokPhysics_UpdateBroadphase
==============
*/
void HavokPhysics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  hknpWorld *world; 
  unsigned __int8 v5; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  int v7; 
  __int64 v8; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13109, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Update broadphase with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  v5 = 2;
  if ( updateAll )
    v5 = -1;
  world->m_broadPhase->update(world->m_broadPhase, v5);
  if ( Physics_IsQueryWorld(worldId) )
  {
    UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(world);
    if ( ((unsigned int (__fastcall *)(hknpBroadPhase *))UndecoratedBroadPhase->getType)(UndecoratedBroadPhase) == 2 )
    {
      v7 = 0;
      if ( UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_size > 0 )
      {
        v8 = 0i64;
        do
        {
          v9 = *(_QWORD *)&UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_data[v8];
          if ( v9 )
            *(_BYTE *)(v9 + 6620) = 0;
          ++v7;
          v8 += 2i64;
        }
        while ( v7 < UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_size );
      }
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13136, ASSERT_TYPE_ASSERT, "(false)", "%s\n\tUnexpected broadphase type!", "false") )
    {
      __debugbreak();
    }
  }
}

/*
==============
HavokPhysics_UpdateGravityScalar
==============
*/

void __fastcall HavokPhysics_UpdateGravityScalar(Physics_WorldId worldId, Physics_GravityType gravityType, double scalar)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int v7; 
  unsigned int m_size; 
  hknpWorld *world; 
  hknpMotionPropertiesId result; 
  hknpMotionProperties motionProperties; 

  __asm
  {
    vmovaps [rsp+0E8h+var_28], xmm6
    vmovaps xmm6, xmm2
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5602, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", (const char *)&queryFormat, "havokPhysicsWorld->world") )
    __debugbreak();
  v7 = 0;
  m_size = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
  if ( m_size )
  {
    do
    {
      if ( (unsigned int)gravityType <= Physics_GravityType_Item )
      {
        HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, gravityType + 1, v7);
        world = MutableWorld->world;
        _R8 = 112i64 * result.m_value;
        _RCX = world->m_motionPropertiesLibrary.m_ptr->m_motionProperties.m_objects.m_data;
        __asm
        {
          vmovups ymm2, ymmword ptr [r8+rcx]
          vmovups ymmword ptr [rsp+0E8h+motionProperties.m_isExclusive], ymm2
          vmovups ymm0, ymmword ptr [r8+rcx+20h]
          vmovups ymmword ptr [rsp+0E8h+motionProperties.m_solverStabilizationSpeedThreshold], ymm0
          vmovups ymm1, ymmword ptr [r8+rcx+40h]
          vmovups ymmword ptr [rsp+0E8h+motionProperties.m_fullCastSettings.m_minSeparation], ymm1
          vmovups xmm0, xmmword ptr [r8+rcx+60h]
          vmovups xmmword ptr [rsp+0E8h+motionProperties.m_fullCastSettings.m_keepDistance], xmm0
          vshufps xmm2, xmm2, xmm2, 0AAh ; ''
          vmulss  xmm0, xmm2, xmm6
          vmovss  [rsp+0E8h+motionProperties.m_gravityFactor], xmm0
        }
        hknpMotionPropertiesLibrary::updateEntry(world->m_motionPropertiesLibrary.m_ptr, result, &motionProperties);
      }
      ++v7;
    }
    while ( v7 < m_size );
  }
  __asm { vmovaps xmm6, [rsp+0E8h+var_28] }
}

/*
==============
HavokPhysics_UpdateLoosenedConstraint
==============
*/
char HavokPhysics_UpdateLoosenedConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  int v10; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v9 = *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value) + 8);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13408, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  *(_DWORD *)&result->coneChanged = 0;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24i64))(v9);
  if ( v10 == 2 )
  {
    HavokPhysics_LoosenHingeConstraint((hkpLimitedHingeConstraintData::Atoms *)(v9 + 32), bodyATransform, bodyBTransform, result);
  }
  else
  {
    if ( v10 != 7 )
      return 0;
    HavokPhysics_LoosenRagdollConstraint((hkpRagdollConstraintData::Atoms *)(v9 + 32), bodyATransform, bodyBTransform, result);
  }
  return 1;
}

/*
==============
HavokPhysics_UpdateWorld
==============
*/
void HavokPhysics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v4; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6403, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  HavokPhysicsInstanceManager_PropagateAddedFlags(&MutableWorld->instanceManager);
  if ( !MutableWorld->persistentStreamAllocator )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6410, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v4) )
      __debugbreak();
  }
  MutableWorld->persistentStreamAllocator->getMemoryStatistics(MutableWorld->persistentStreamAllocator, &MutableWorld->persistentMemoryStats.m_allocatorStats);
}

/*
==============
HavokPhysics_ValidateWorld
==============
*/
void HavokPhysics_ValidateWorld(Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  Physics_WorldId v3; 

  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5320, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics ValidateWorld %i: world is NULL", "havokPhysicsWorld->world", v3) )
      __debugbreak();
  }
  EnterCriticalSection((LPCRITICAL_SECTION)&ConstWorld->critSection);
  hknpWorld::checkConsistency(ConstWorld->world);
  LeaveCriticalSection((LPCRITICAL_SECTION)&ConstWorld->critSection);
}

/*
==============
HavokPhysics_WarpDetailRigidBodyTo
==============
*/
__int64 HavokPhysics_WarpDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase)
{
  hknpWorldReader_vtbl *v28; 
  int v29; 
  const hkTransformf *v30; 
  const hknpShape *v32; 
  __int64 v74; 
  float zero[4]; 
  hkQuaternionf qi; 
  __int128 v77; 
  hkTransformf v78; 

  _RBP = hkOrientation;
  _R14 = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12109, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v74) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12110, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid body id for world %i", "bodyId.isValid()", v74) )
      __debugbreak();
  }
  _RSI = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !_RSI )
  {
    LODWORD(v74) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12115, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "world", v74) )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm5, xmmword ptr [rbp+0]
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+148h+qi.m_vec.m_quad], xmm1
  }
  hkRotationImpl<float>::set(&v78.m_rotation, &qi);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovss  xmm1, cs:__real@3727c5ac
    vmovups [rsp+148h+var_98], xmm0
  }
  v28 = _RSI->hknpWorldReader::__vftable;
  v29 = 0;
  __asm { vmovss  [rsp+148h+zero], xmm1 }
  v30 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v28->getBodyTransform)(&_RSI->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( !hkTransformf::isApproximatelyEqual(&v78, v30, zero) )
  {
    __asm
    {
      vmovaps [rsp+148h+var_28], xmm6
      vmovaps [rsp+148h+var_38], xmm7
      vmovaps [rsp+148h+var_48], xmm8
      vmovaps [rsp+148h+var_58], xmm9
      vmovaps [rsp+148h+var_68], xmm10
      vmovaps [rsp+148h+var_78], xmm11
    }
    _RBX = &_RSI->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod;
    hknpBody::setTransform(_RBX, &v78);
    hknpBody::syncStaticMotionToBodyTransform(_RBX);
    v32 = _RBX->m_lodVariantTable[_RBX->m_lodTypeToVariant[3].m_data & 7];
    v32->calcAabb((hknpShape *)v32, &_RBX->m_transform, (hkAabb *)&v77);
    __asm
    {
      vmovups xmm2, xmmword ptr [rsi+540h]
      vmovups xmm3, xmmword ptr [rsi+550h]
      vmovdqu xmm6, xmmword ptr [rsi+580h]
      vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+150h; __m128 const near * const g_vectorfConstants
      vmulps  xmm11, xmm0, xmmword ptr [rsi+800h]
      vaddps  xmm5, xmm11, [rsp+148h+var_D8]
      vmovups xmm0, [rsp+148h+var_E8]
      vsubps  xmm1, xmm0, xmm11
      vaddps  xmm0, xmm2, xmm1
      vmovups xmm1, cs:?two31@?1??setConvertF32toS32@hkIntVector@@QEAAXAEBVhkVector4f@@@Z@4QBIB; uint const near * const `hkIntVector::setConvertF32toS32(hkVector4f const &)'::`2'::two31
      vmulps  xmm9, xmm0, xmm3
      vaddps  xmm0, xmm2, xmm5
      vmovdqu xmm5, xmmword ptr [rsi+5E0h]
      vmulps  xmm10, xmm0, xmm3
      vcmpleps xmm4, xmm1, xmm9
      vcmpleps xmm8, xmm1, xmm10
      vcvttps2dq xmm0, xmm9
      vmovaps xmm9, [rsp+148h+var_58]
    }
    v29 = 1;
    __asm
    {
      vpxor   xmm1, xmm0, xmm4
      vpxor   xmm7, xmm7, xmm7
      vpmaxsd xmm2, xmm7, xmm1
      vpminsd xmm3, xmm5, xmm2
      vcvttps2dq xmm0, xmm10
      vmovaps xmm10, [rsp+148h+var_68]
      vpxor   xmm1, xmm0, xmm8
      vmovaps xmm8, [rsp+148h+var_48]
      vpmaxsd xmm2, xmm7, xmm1
      vmovaps xmm7, [rsp+148h+var_38]
      vpshufb xmm4, xmm3, xmm6
      vpminsd xmm3, xmm5, xmm2
      vpshufb xmm0, xmm3, xmm6
      vmovaps xmm6, [rsp+148h+var_28]
      vblendps xmm1, xmm0, xmm4, 3
      vxorps  xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rbx+50h], xmm1
      vmulps  xmm1, xmm11, xmmword ptr [rsi+7E0h]
      vmovaps xmm11, [rsp+148h+var_78]
      vmaxps  xmm2, xmm1, xmm0
      vminps  xmm2, xmm2, cs:__xmm@477fff00477fff00477fff00477fff00
      vcvttps2dq xmm0, xmm2
      vmovd   eax, xmm0
    }
    _RBX->m_maxContactDistance = _EAX;
    _RBX->m_maxContactDistanceFromRotation = _EAX;
  }
  if ( updateBroadphase )
    _RSI->updateBroadPhase(&_RSI->hknpWorldWriter);
  return (unsigned int)(2 * v29);
}

/*
==============
HavokPhysics_WarpInstanceTo
==============
*/
__int64 HavokPhysics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphaseIfNecessary)
{
  __int64 v9; 
  hknpWorld *world; 
  unsigned __int8 v12; 
  unsigned int v13; 
  int NumRigidBodys; 
  __int64 v15; 
  hknpWorldReader *v16; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  hkTransformf *v21; 
  hkTransformf *p_r; 
  hknpWorld *v24; 
  __int64 activate; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  hknpBodyId result; 
  float zero; 
  __int64 v32; 
  hkQuaternionf hkOrientationa; 
  hkTransformf r; 
  hkTransformf aTb; 
  hkTransformf bTc; 
  hkTransformf v37; 

  _RDI = hkPosition;
  v9 = instanceId;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12198, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v27) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12203, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "hkWorld", v27) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&r.m_rotation, hkOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+1C8h+var_128], xmm0
  }
  if ( !hkTransformf::isOk(&r) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12207, ASSERT_TYPE_ASSERT, "(body0NewTransform.isOk())", (const char *)&queryFormat, "body0NewTransform.isOk()") )
    __debugbreak();
  v12 = 0;
  v13 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v9);
  if ( NumRigidBodys > 0 )
  {
    v15 = 80 * v9;
    v16 = &world->hknpWorldReader;
    __asm
    {
      vmovaps [rsp+1C8h+var_48], xmm6
      vmovss  xmm6, cs:__real@3a83126f
    }
    v32 = 80 * v9;
    do
    {
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(v27) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v27) )
          __debugbreak();
      }
      if ( (_DWORD)v9 == -1 )
      {
        LODWORD(v27) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v27) )
          __debugbreak();
      }
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      if ( !ConstWorld->world )
      {
        LODWORD(v27) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v27) )
          __debugbreak();
      }
      p_instanceManager = &ConstWorld->instanceManager;
      if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      if ( v13 >= *(int *)((char *)&p_instanceManager->buffer->bodies.m_size + v15) )
      {
        LODWORD(v28) = worldId;
        LODWORD(v27) = v13;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v27, v28) )
          __debugbreak();
      }
      HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v9, v13);
      m_serialAndIndex = result.m_serialAndIndex;
      if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        LODWORD(v29) = worldId;
        LODWORD(v28) = v9;
        LODWORD(v27) = v13;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12219, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v27, v28, v29) )
          __debugbreak();
      }
      v21 = (hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v16->getBodyTransform)(v16, m_serialAndIndex);
      if ( !hkTransformf::isOk(v21) )
      {
        LODWORD(activate) = v13;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12223, ASSERT_TYPE_ASSERT, "( ( bodyOldTransform.isOk() ) )", "( bodyIt ) = %i", activate) )
          __debugbreak();
      }
      if ( v13 )
      {
        hkTransformf::setMul(&bTc, &aTb, v21);
        hkTransformf::setMul(&v37, &r, &bTc);
        p_r = &v37;
      }
      else
      {
        __asm { vmovss  [rsp+1C8h+zero], xmm6 }
        if ( hkTransformf::isApproximatelyEqual(v21, &r, &zero) )
          break;
        hkTransformf::setInverse(&aTb, v21);
        p_r = &r;
      }
      hkQuaternionf::setAndNormalize(&hkOrientationa, &p_r->m_rotation);
      if ( HavokPhysics_WarpRigidBodyTo(worldId, (const hknpBodyId)m_serialAndIndex, &p_r->m_translation, &hkOrientationa, 0, 1) && ((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))v16->isBodyAdded)(v16, m_serialAndIndex) )
        v12 = 1;
      v15 = v32;
      ++v13;
    }
    while ( (int)v13 < NumRigidBodys );
    __asm { vmovaps xmm6, [rsp+1C8h+var_48] }
  }
  if ( updateBroadphaseIfNecessary && v12 )
  {
    v24 = HavokPhysics_GetMutableWorld(worldId)->world;
    Sys_ProfBeginNamedEvent(0xFF6A5ACD, "HavokPhysics_WarpInstanceTo broadphase update");
    v24->updateBroadPhase(&v24->hknpWorldWriter);
    Sys_ProfEndNamedEvent();
  }
  return v12;
}

/*
==============
HavokPhysics_WarpLeafDetailRigidBodyTo
==============
*/
__int64 HavokPhysics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase)
{
  hknpWorld *world; 
  hknpWorldReader_vtbl *v22; 
  int v23; 
  const hkTransformf *v24; 
  __int64 v26; 
  float zero[4]; 
  hkQuaternionf qi; 
  hkTransformf v29; 

  _RBP = hkOrientation;
  _R14 = hkPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12158, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12159, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid body id for world %i", "bodyId.isValid()", v26) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12164, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "world", v26) )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm5, xmmword ptr [rbp+0]
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0C8h+qi.m_vec.m_quad], xmm1
  }
  hkRotationImpl<float>::set(&v29.m_rotation, &qi);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovss  xmm1, cs:__real@3727c5ac
    vmovups [rsp+0C8h+var_38], xmm0
  }
  v22 = world->hknpWorldReader::__vftable;
  v23 = 0;
  __asm { vmovss  [rsp+0C8h+zero], xmm1 }
  v24 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v22->getBodyTransform)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( !hkTransformf::isApproximatelyEqual(&v29, v24, zero) )
  {
    hknpBody::setTransform(&world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod, &v29);
    v23 = 1;
  }
  if ( updateBroadphase )
    world->updateBroadPhase(&world->hknpWorldWriter);
  return (unsigned int)(2 * v23);
}

/*
==============
HavokPhysics_WarpRigidBodyToRelative
==============
*/
void HavokPhysics_WarpRigidBodyToRelative(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkStartPosition, const hkQuaternionf *hkStartOrientation, const hkVector4f *hkEndPosition, const hkQuaternionf *hkEndOrientation)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v27; 
  hkQuaternionf hkOrientation; 
  hkTransformf v30; 
  hkTransformf bTc; 
  hkTransformf v32; 
  hkTransformf v33; 
  hkTransformf aTb; 
  hkTransformf v35; 

  _R14 = hkStartPosition;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12763, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body relative with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v27) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12764, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body relative with invalid body id for world %i", "bodyId.isValid()", v27) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v27) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12769, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", v27) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v30.m_rotation, hkStartOrientation);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups [rsp+208h+var_188], xmm0
  }
  hkTransformf::setInverse(&aTb, &v30);
  hkRotationImpl<float>::set(&v32.m_rotation, hkEndOrientation);
  _RAX = hkEndPosition;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups [rsp+208h+var_108], xmm0
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+208h+bTc.m_rotation.baseclass_0.m_col0.m_quad], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+208h+bTc.m_rotation.baseclass_0.m_col2.m_quad], ymm1
  }
  hkTransformf::setMul(&v35, &aTb, &bTc);
  hkTransformf::setMul(&v33, &v32, &v35);
  hkQuaternionf::set(&hkOrientation, &v33.m_rotation);
  __asm
  {
    vmovups xmm5, xmmword ptr [rsp+208h+hkOrientation.m_vec.m_quad]
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+208h+hkOrientation.m_vec.m_quad], xmm1
  }
  HavokPhysics_WarpRigidBodyTo(worldId, bodyId, &v33.m_translation, &hkOrientation, 0, 1);
}

/*
==============
HavokPhysics_Write
==============
*/
void HavokPhysics_Write(MemoryFile *memFile)
{
  if ( !g_havokPhysicsWorlds[0].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5193, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  HavokPhysicsInstanceManager_Write(memFile, &g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysics_WriteSnapshot(memFile, PHYSICS_WORLD_ID_FIRST);
  if ( !g_havokPhysicsWorlds[1].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5203, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld detail is NULL", "world->world") )
    __debugbreak();
  HavokPhysicsInstanceManager_Write(memFile, &g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysics_WriteSnapshot(memFile, PHYSICS_WORLD_ID_SERVER_DETAIL);
}

/*
==============
HavokPhysics_WriteConstraints
==============
*/
void HavokPhysics_WriteConstraints(MemoryFile *memFile, Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  int v4; 
  hknpWorld *world; 
  int v6; 
  unsigned int v7; 
  hknpConstraintManager *m_constraintManager; 
  hknpThreadSafeObjectPoolElement<hknpConstraint> *m_data; 
  unsigned int v10; 
  unsigned __int64 m_userData; 
  int p; 

  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4892, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  p = ConstWorld->world->getNumConstraints(&ConstWorld->world->hknpWorldReader);
  v4 = p;
  MemFile_WriteData(memFile, 4ui64, &p);
  world = ConstWorld->world;
  v6 = 0;
  v7 = 0;
  m_constraintManager = world->m_constraintManager;
  m_data = m_constraintManager->m_constraints.m_objects.m_data;
  v10 = m_constraintManager->m_constraints.m_peakIndex + 1;
  if ( m_constraintManager->m_constraints.m_numAllocated )
  {
    if ( m_data->m_pod.m_id.m_value != 0x7FFFFFFF )
      goto LABEL_15;
    v7 = 1;
    if ( v10 > 1 )
    {
      while ( m_data[v7].m_pod.m_id.m_value == 0x7FFFFFFF )
      {
        if ( ++v7 >= v10 )
          goto LABEL_16;
      }
      if ( v7 != -1 )
      {
LABEL_15:
        do
        {
          m_userData = m_data[v7].m_pod.m_userData;
          p = m_data[v7].m_pod.m_id.m_value;
          MemFile_WriteData(memFile, 4ui64, &p);
          p = m_userData;
          MemFile_WriteData(memFile, 4ui64, &p);
          p = HIDWORD(m_userData);
          MemFile_WriteData(memFile, 4ui64, &p);
          ++v6;
          if ( ++v7 >= v10 )
            break;
          while ( m_data[v7].m_pod.m_id.m_value == 0x7FFFFFFF )
          {
            if ( ++v7 >= v10 )
              goto LABEL_16;
          }
        }
        while ( v7 != -1 );
      }
    }
  }
LABEL_16:
  if ( v4 != v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4910, ASSERT_TYPE_ASSERT, "(numConstraints == numWrittenConstraints)", (const char *)&queryFormat, "numConstraints == numWrittenConstraints") )
    __debugbreak();
}

/*
==============
HavokPhysics_WriteInstance
==============
*/
void HavokPhysics_WriteInstance(MemoryFile *memFile, Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v11; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  const PhysicsAsset *PhysicsAsset; 
  const PhysicsAsset *PhysicsAssetAddendum; 
  const char *name; 
  const char *v19; 
  const XModel *DetailModel; 
  const char *v21; 
  const XModel *XModel; 
  const char *v23; 
  __int64 v24; 
  HavokPhysicsInstance *buffer; 
  int m_size; 
  int v27; 
  __int64 v28; 
  hknpBodyId v29; 
  __int64 v30; 
  hknpShape *v32; 
  hknpShape *m_ptr; 
  unsigned int i; 
  __int64 v35; 
  __int64 v36; 
  hkRefCountedProperties *v37; 
  int MapEntsShapeCount; 
  __int64 v40; 
  __int64 v41; 
  int v42; 
  int v43; 
  __int64 v44; 
  unsigned __int16 v45; 
  int v46; 
  __int64 v47; 
  int v50; 
  unsigned int j; 
  int v56; 
  int v57; 
  hkPointerMap<hknpShape const *,float,hkContainerHeapAllocator> *capsuleRadii; 
  int m_hashMod; 
  unsigned __int32 v66; 
  unsigned __int32 v67; 
  unsigned int v68; 
  signed int v69; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  Physics_WorldId v81; 
  int v82; 
  Physics_RefSystem RefSystem; 
  unsigned __int8 RefSubSystem; 
  bool v85; 
  Physics_WorldId v86; 
  Physics_WorldId v87; 
  int Ref; 
  int v89; 
  HavokPhysicsInstance *v90; 
  __int64 v91; 
  __int64 v92; 
  __int64 v93; 
  __int64 v94; 
  __int64 v103; 
  __int64 v104; 
  unsigned int m_serialAndIndex; 
  char v106[8]; 
  char v107[8]; 
  int p; 
  Physics_WorldId worldIda; 
  int v110; 
  const HavokPhysicsAsset *v111; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsWorld *v113; 
  int v114; 
  hknpBodyId *m_data; 
  __int64 v116; 
  const XModel *v117; 
  HavokPhysicsInstanceManager *v118; 
  __int64 v119; 
  __int64 v120; 
  int v121; 
  int v122; 
  __int64 v123; 
  __int128 v124; 
  char v126; 
  void *retaddr; 

  _RAX = &retaddr;
  v123 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
  }
  v11 = instanceId;
  worldIda = worldId;
  v120 = 0i64;
  v121 = 0;
  v122 = 0x80000000;
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4219, ASSERT_TYPE_ASSERT, "(memFile)", "%s\n\tHavokPhysics: WriteInstance has NULL memfile", "memFile") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4220, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to WriteInstance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v11 == -1 )
  {
    LODWORD(v104) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4221, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics: Trying to WriteInstance with invalid instance id %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v104) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v113 = ConstWorld;
  if ( !ConstWorld->world )
  {
    LODWORD(v104) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4225, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteInstance %i: world is NULL", "physicsWorld->world", v104) )
      __debugbreak();
  }
  p_instanceManager = &ConstWorld->instanceManager;
  v118 = &ConstWorld->instanceManager;
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&ConstWorld->instanceManager, v11);
  PhysicsAssetAddendum = HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(p_instanceManager, v11);
  if ( PhysicsAsset )
    name = PhysicsAsset->name;
  else
    name = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, name);
  if ( PhysicsAssetAddendum )
    v19 = PhysicsAssetAddendum->name;
  else
    v19 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v19);
  if ( PhysicsAsset )
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
  else
    HavokPhysicsAsset = NULL;
  if ( PhysicsAssetAddendum )
    v111 = HavokPhysics_GetHavokPhysicsAsset(PhysicsAssetAddendum);
  else
    v111 = NULL;
  DetailModel = HavokPhysicsInstanceManager_GetDetailModel(p_instanceManager, v11);
  v117 = DetailModel;
  if ( DetailModel )
    v21 = DetailModel->name;
  else
    v21 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v21);
  XModel = HavokPhysicsInstanceManager_GetXModel(p_instanceManager, v11);
  if ( XModel )
    v23 = XModel->name;
  else
    v23 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v23);
  HavokPhysicsInstanceManager_Write(memFile, p_instanceManager, v11);
  if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v11 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  v24 = 80 * v11;
  v119 = 80 * v11;
  buffer = p_instanceManager->buffer;
  m_data = p_instanceManager->buffer[v11].bodies.m_data;
  m_size = buffer[v11].bodies.m_size;
  v110 = m_size;
  p = m_size;
  MemFile_WriteData(memFile, 4ui64, &p);
  v27 = 0;
  p = 0;
  if ( m_size > 0 )
  {
    v28 = 0i64;
    *(_QWORD *)&v124 = 0i64;
    while ( 1 )
    {
      m_serialAndIndex = m_data[v28].m_serialAndIndex;
      v29.m_serialAndIndex = m_serialAndIndex;
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      v30 = (__int64)v113;
      v116 = *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v113->world->getBody)(&v113->world->hknpWorldReader, v29.m_serialAndIndex) + 160);
      MemFile_WriteData(memFile, 8ui64, &v116);
      MemFile_WriteCString(memFile, (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v30 + 24) + 192i64) + 8i64 * (v29.m_serialAndIndex & 0xFFFFFF)) & 0xFFFFFFFFFFFFFFFEui64));
      _RSI = *(_QWORD *)((*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(*(_QWORD *)(v30 + 24) + 32i64) + 104i64))(*(_QWORD *)(v30 + 24) + 32i64, v29.m_serialAndIndex) + 96);
      v32 = NULL;
      if ( HavokPhysicsAsset )
        break;
      if ( v117 )
      {
        if ( v27 != v110 - 1 || v110 <= 1 )
          goto LABEL_168;
        if ( *(_BYTE *)(_RSI + 26) != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4398, ASSERT_TYPE_ASSERT, "( bodyShape->getType() == hknpShapeType::SPHERE )", (const char *)&queryFormat, "bodyShape->getType() == hknpShapeType::SPHERE") )
          __debugbreak();
        __asm { vmovss  xmm9, dword ptr [rsi+20h] }
        _RCX = *(unsigned __int16 *)(_RSI + 60);
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rsi+3Ah]
          vmovups [rbp+0A0h+var_D0], xmm0
          vmovss  [rsp+1A0h+var_160], xmm9
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4402, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm8, dword ptr [rbp+0A0h+var_D0]
          vmovss  [rsp+1A0h+var_160], xmm8
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4403, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 0 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm7, dword ptr [rbp+0A0h+var_D0+4]
          vmovss  [rsp+1A0h+var_160], xmm7
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4404, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 1 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm6, dword ptr [rbp+0A0h+var_D0+8]
          vmovss  [rsp+1A0h+var_160], xmm6
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 )
        {
          v56 = 4405;
LABEL_119:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", v56, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 2 ) )") )
            __debugbreak();
        }
      }
      else
      {
        v57 = *(unsigned __int8 *)(_RSI + 26);
        m_serialAndIndex = v57;
        MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
        switch ( v57 )
        {
          case 1:
            v86 = worldIda;
            if ( G_PhysicsCoverWall_InstanceIdIsCoverWallPlayerClip(worldIda, v11, NULL) )
            {
              m_serialAndIndex = 0;
              MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
              PhysicsCoverWall_WriteShapeData_PlayerClip(memFile, v86, v11);
              goto LABEL_168;
            }
            v85 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4492, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported CONVEX shape");
            goto LABEL_166;
          case 2:
            __asm { vmovss  xmm9, dword ptr [rsi+20h]; jumptable 0000000141B6A75B case 2 }
            _RCX = *(unsigned __int16 *)(_RSI + 60);
            __asm
            {
              vmovups xmm0, xmmword ptr [rcx+rsi+3Ah]
              vmovups [rbp+0A0h+var_D0], xmm0
              vmovss  [rsp+1A0h+var_160], xmm9
            }
            if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4424, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
              __debugbreak();
            __asm
            {
              vmovss  xmm8, dword ptr [rbp+0A0h+var_D0]
              vmovss  [rsp+1A0h+var_160], xmm8
            }
            if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4425, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 0 ) )") )
              __debugbreak();
            __asm
            {
              vmovss  xmm7, dword ptr [rbp+0A0h+var_D0+4]
              vmovss  [rsp+1A0h+var_160], xmm7
            }
            if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4426, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 1 ) )") )
              __debugbreak();
            __asm
            {
              vmovss  xmm6, dword ptr [rbp+0A0h+var_D0+8]
              vmovss  [rsp+1A0h+var_160], xmm6
            }
            if ( (m_serialAndIndex & 0x7F800000) != 2139095040 )
              goto LABEL_121;
            v56 = 4427;
            goto LABEL_119;
          case 3:
            capsuleRadii = v113->capsuleRadii;
            m_hashMod = capsuleRadii->m_map.m_hashMod;
            if ( m_hashMod <= 0 )
              goto LABEL_126;
            v66 = _byteswap_ulong(-1640531535 * _RSI);
            v67 = _byteswap_ulong(-1640531535 * HIDWORD(_RSI));
            v68 = m_hashMod & (v67 ^ ((v66 >> 2) + v66 + (v67 << 6) - 1640531527));
            v69 = v68;
            m_elem = capsuleRadii->m_map.m_elem;
            key = capsuleRadii->m_map.m_elem[v68].key;
            if ( key == -1i64 )
              goto LABEL_126;
            break;
          case 9:
            v87 = worldIda;
            Ref = HavokPhysics_GetRef(worldIda, v29);
            if ( Physics_GetRefSystem(Ref) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4500, ASSERT_TYPE_ASSERT, "(Physics_GetRefSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_RefSystem_WorldGeo)", (const char *)&queryFormat, "Physics_GetRefSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_RefSystem_WorldGeo") )
              __debugbreak();
            v89 = HavokPhysics_GetRef(v87, v29);
            if ( !Physics_GetRefSubSystem(v89) )
              goto LABEL_168;
            v85 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4501, ASSERT_TYPE_ASSERT, "(Physics_GetRefSubSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_WorldGeometrySubSystem_WorldGeo)", (const char *)&queryFormat, "Physics_GetRefSubSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_WorldGeometrySubSystem_WorldGeo");
            goto LABEL_166;
          case 12:
          case 22:
            v81 = worldIda;
            v82 = HavokPhysics_GetRef(worldIda, v29);
            RefSystem = Physics_GetRefSystem(v82);
            RefSubSystem = Physics_GetRefSubSystem(v82);
            if ( RefSystem )
              goto LABEL_154;
            if ( RefSubSystem == 1 )
            {
              m_serialAndIndex = 0;
              goto LABEL_89;
            }
            if ( RefSubSystem == 2 )
            {
              m_serialAndIndex = 2;
              goto LABEL_89;
            }
LABEL_154:
            if ( G_PhysicsCoverWall_InstanceIdIsCoverWall(v81, v11, NULL) )
            {
              m_serialAndIndex = 1;
              MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
              PhysicsCoverWall_WriteShapeData(memFile, v81, v11);
            }
            else
            {
              v85 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4479, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported COMPOUND/USER_0 shape");
LABEL_166:
              if ( v85 )
                __debugbreak();
            }
            goto LABEL_168;
          default:
            v85 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4506, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported shape");
            goto LABEL_166;
        }
        while ( key != _RSI )
        {
          v68 = m_hashMod & (v68 + 1);
          v69 = v68;
          key = m_elem[v68].key;
          if ( key == -1i64 )
          {
LABEL_126:
            v69 = m_hashMod + 1;
            m_elem = capsuleRadii->m_map.m_elem;
            break;
          }
        }
        m_serialAndIndex = m_elem[v69].val;
        __asm { vmovss  xmm12, [rsp+1A0h+var_160] }
        _RAX = *(unsigned __int16 *)(_RSI + 60);
        __asm
        {
          vmovups xmm0, xmmword ptr [rax+rsi+3Ah]
          vmovups [rbp+0A0h+var_D0], xmm0
          vmovups xmm1, xmmword ptr [rax+rsi+4Ah]
          vmovups [rbp+0A0h+var_C0], xmm1
          vmovss  [rsp+1A0h+var_160], xmm12
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4441, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm11, dword ptr [rbp+0A0h+var_D0]
          vmovss  [rsp+1A0h+var_160], xmm11
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4442, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 0 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm10, dword ptr [rbp+0A0h+var_D0+4]
          vmovss  [rsp+1A0h+var_160], xmm10
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4443, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 1 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm9, dword ptr [rbp+0A0h+var_D0+8]
          vmovss  [rsp+1A0h+var_160], xmm9
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4444, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 2 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm8, dword ptr [rbp+0A0h+var_C0]
          vmovss  [rsp+1A0h+var_160], xmm8
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4445, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 0 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm7, dword ptr [rbp+0A0h+var_C0+4]
          vmovss  [rsp+1A0h+var_160], xmm7
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4446, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 1 ) )") )
          __debugbreak();
        __asm
        {
          vmovss  xmm6, dword ptr [rbp+0A0h+var_C0+8]
          vmovss  [rsp+1A0h+var_160], xmm6
        }
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4447, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 2 ) )") )
          __debugbreak();
        __asm { vmovaps xmm1, xmm12; value }
        MemFile_WriteFloat(memFile, *(float *)&_XMM1);
        __asm { vmovaps xmm1, xmm11; value }
        MemFile_WriteFloat(memFile, *(float *)&_XMM1);
        __asm { vmovaps xmm1, xmm10; value }
        MemFile_WriteFloat(memFile, *(float *)&_XMM1);
      }
LABEL_121:
      __asm { vmovaps xmm1, xmm9; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
      __asm { vmovaps xmm1, xmm8; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
      __asm { vmovaps xmm1, xmm7; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
      __asm { vmovaps xmm1, xmm6; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
LABEL_168:
      ++p;
      *(_QWORD *)&v124 = ++v28;
      v27 = p;
      if ( v28 >= v110 )
      {
        p_instanceManager = v118;
        v24 = v119;
        goto LABEL_170;
      }
    }
    m_ptr = (hknpShape *)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v28].m_shape.m_ptr;
    i = -1;
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vxorps  xmm7, xmm7, xmm7
    }
    v35 = 0i64;
    if ( !(_QWORD)v124 && v111 )
    {
      v36 = *(_QWORD *)(_RSI + 72);
      _RSI = *(_QWORD *)(v36 + 80);
      v32 = *(hknpShape **)(v36 + 192);
    }
    if ( (hknpShape *)_RSI != m_ptr )
    {
      if ( *(_BYTE *)(_RSI + 26) == 2 )
      {
        __asm { vmovss  xmm6, dword ptr [rsi+20h] }
      }
      else
      {
        v37 = *(hkRefCountedProperties **)(_RSI + 48);
        if ( v37 && (_RAX = hkRefCountedProperties::accessProperty(v37, 1u)) != NULL )
        {
          __asm
          {
            vmovss  xmm6, dword ptr [rax+18h]
            vmovss  xmm7, dword ptr [rax+1Ch]
          }
        }
        else if ( m_ptr->m_type.m_storage == 12 && m_ptr->getMutationSignals(m_ptr) )
        {
          if ( *(_BYTE *)(_RSI + 26) != 18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4304, ASSERT_TYPE_ASSERT, "(bodyShape->getType() == hknpShapeType::MASKED)", (const char *)&queryFormat, "bodyShape->getType() == hknpShapeType::MASKED") )
            __debugbreak();
          v35 = _RSI;
        }
        else
        {
          MapEntsShapeCount = WorldCollision_GetMapEntsShapeCount();
          for ( i = 0; (int)i < MapEntsShapeCount; ++i )
          {
            if ( WorldCollision_GetMapEntsShape(i) == (hknpShape *)_RSI )
              break;
          }
          if ( i >= MapEntsShapeCount )
          {
            LODWORD(v104) = MapEntsShapeCount;
            LODWORD(v103) = i;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4320, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( numShapes )", "shapeIdx doesn't index numShapes\n\t%i not in [0, %i)", v103, v104) )
              __debugbreak();
          }
        }
      }
    }
    v106[0] = v35 != 0;
    MemFile_WriteData(memFile, 1ui64, v106);
    if ( v35 )
    {
      v40 = *(_QWORD *)(v35 + 64);
      v41 = *(_QWORD *)(v35 + 56);
      if ( *(_BYTE *)(v41 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4337, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
        __debugbreak();
      v42 = *(_DWORD *)(v41 + 80);
      v43 = 0;
      v114 = 0;
      if ( v42 > 0 )
      {
        v44 = *(_QWORD *)(v41 + 72);
        while ( 1 )
        {
          v45 = v114;
          if ( !*(_BYTE *)(112i64 * (unsigned __int16)v114 + v44 + 92) )
            break;
          v114 = ++v43;
          if ( v43 >= v42 )
            goto LABEL_77;
        }
        while ( v43 != -1 )
        {
          v107[0] = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v40 + 32i64))(v40, (0xFFFFFFFF >> *(_BYTE *)(v41 + 27)) | (v45 << (32 - *(_BYTE *)(v41 + 27))));
          MemFile_WriteData(memFile, 1ui64, v107);
          v46 = *(_DWORD *)(v41 + 80);
          v114 = ++v43;
          if ( v43 >= v46 )
            break;
          v47 = *(_QWORD *)(v41 + 72);
          while ( 1 )
          {
            v45 = v114;
            if ( !*(_BYTE *)(112i64 * (unsigned __int16)v114 + v47 + 92) )
              break;
            v114 = ++v43;
            if ( v43 >= v46 )
              goto LABEL_77;
          }
        }
      }
    }
    else
    {
      m_serialAndIndex = i;
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      __asm { vmovaps xmm1, xmm6; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
      __asm { vmovaps xmm1, xmm7; value }
      MemFile_WriteFloat(memFile, *(float *)&_XMM1);
    }
LABEL_77:
    v28 = v124;
    if ( (_QWORD)v124 || !v111 )
    {
      m_serialAndIndex = -1;
      goto LABEL_89;
    }
    if ( v32 == v111->m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr )
    {
      j = -1;
    }
    else
    {
      v50 = WorldCollision_GetMapEntsShapeCount();
      for ( j = 0; (int)j < v50; ++j )
      {
        if ( WorldCollision_GetMapEntsShape(j) == v32 )
          break;
      }
      if ( j >= v50 )
      {
        LODWORD(v104) = v50;
        LODWORD(v103) = j;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4377, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( numShapes )", "shapeIdx doesn't index numShapes\n\t%i not in [0, %i)", v103, v104) )
        {
          __debugbreak();
          m_serialAndIndex = j;
LABEL_89:
          MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
          goto LABEL_168;
        }
      }
    }
    m_serialAndIndex = j;
    goto LABEL_89;
  }
LABEL_170:
  if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 79, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v11 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 80, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  v90 = p_instanceManager->buffer;
  v91 = *(__int64 *)((char *)&p_instanceManager->buffer->constraints.m_data + v24);
  v92 = *(int *)((char *)&v90->constraints.m_size + v24);
  m_serialAndIndex = v92;
  MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
  v93 = v92;
  if ( (int)v92 > 0 )
  {
    v94 = 0i64;
    do
    {
      m_serialAndIndex = *(_DWORD *)(v91 + 4 * v94);
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      ++v94;
    }
    while ( v94 < v93 );
  }
  hkMemHeapAllocator();
  _R11 = &v126;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
HavokPhysics_WriteSnapshot
==============
*/
void HavokPhysics_WriteSnapshot(MemoryFile *memFile, Physics_WorldId worldId)
{
  Physics_WorldId v2; 
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  char v8; 
  const char *WorldTransientName; 
  bool IsGameSystemTransientLoaded; 
  int v11; 
  unsigned int i; 
  __int64 v13; 
  hkMemoryAllocator *v14; 
  __int64 v15; 
  hkArray<char,hkContainerHeapAllocator> buf; 
  hkOstream v17; 
  bool p; 
  Physics_WorldId numAllocatedInstances; 
  unsigned int WorldTransientCount; 
  const HavokPhysicsWorld *v21; 

  numAllocatedInstances = worldId;
  v2 = worldId;
  buf.m_data = NULL;
  buf.m_size = 0;
  buf.m_capacityAndFlags = 0x80000000;
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v21 = ConstWorld;
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4961, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  hknpWorld::checkConsistency(ConstWorld->world);
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteWorld");
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4097, ASSERT_TYPE_ASSERT, "(memFile)", "%s\n\tHavokPhysics: WriteWorld has NULL memfile", "memFile") )
    __debugbreak();
  if ( (unsigned int)v2 > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4098, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to WriteWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
    __debugbreak();
  if ( !HavokPhysics_GetConstWorld(v2)->world )
  {
    LODWORD(v15) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4102, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteWorld %i: world is NULL", "physicsWorld->world", v15) )
      __debugbreak();
  }
  v5 = 0;
  WorldTransientCount = 1;
  p = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END|0x80);
  if ( p )
  {
    v5 = 32;
    WorldTransientCount = DB_Transients_GetWorldTransientCount();
  }
  v6 = 0;
  if ( v5 )
  {
    v7 = WorldTransientCount;
    v8 = p;
    do
    {
      if ( v8 && v6 < v7 )
      {
        WorldTransientName = DB_Transients_GetWorldTransientName(v6);
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4128, ASSERT_TYPE_ASSERT, "(zoneName)", (const char *)&queryFormat, "zoneName") )
          __debugbreak();
        IsGameSystemTransientLoaded = CL_TransientsSP_IsGameSystemTransientLoaded(v6);
        p = 1;
        MemFile_WriteData(memFile, 1ui64, &p);
        MemFile_WriteCString(memFile, WorldTransientName);
        p = IsGameSystemTransientLoaded;
        MemFile_WriteData(memFile, 1ui64, &p);
      }
      else
      {
        p = 0;
        MemFile_WriteData(memFile, 1ui64, &p);
      }
      ++v6;
    }
    while ( v6 < v5 );
    ConstWorld = v21;
    v2 = numAllocatedInstances;
  }
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteConstraints");
  HavokPhysics_WriteConstraints(memFile, v2);
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteInstances");
  numAllocatedInstances = ConstWorld->instanceManager.numAllocatedInstances;
  MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
  v11 = 0;
  for ( i = 0; i < ConstWorld->instanceManager.capacity; ++i )
  {
    if ( HavokPhysicsInstanceManager_IsInstanceInUse(&ConstWorld->instanceManager, i) )
    {
      numAllocatedInstances = i;
      MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
      HavokPhysics_WriteInstance(memFile, v2, i);
      ++v11;
    }
  }
  Sys_ProfEndNamedEvent();
  if ( v11 != ConstWorld->instanceManager.numAllocatedInstances && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4987, ASSERT_TYPE_ASSERT, "(numInstancesWritten == world->instanceManager.numAllocatedInstances)", (const char *)&queryFormat, "numInstancesWritten == world->instanceManager.numAllocatedInstances") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "exportSimulationState");
  hknpWorld::checkConsistency(ConstWorld->world);
  hkOstream::hkOstream(&v17, &buf);
  NpSimulationSnapshot::exportSimulationState(ConstWorld->world, *(hkStreamWriter **)(v13 + 24));
  hkOstream::~hkOstream(&v17);
  hknpWorld::checkConsistency(ConstWorld->world);
  numAllocatedInstances = buf.m_size;
  MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
  MemFile_WriteData(memFile, buf.m_size, buf.m_data);
  Sys_ProfEndNamedEvent();
  v14 = hkMemHeapAllocator();
  buf.m_size = 0;
  if ( buf.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v14, buf.m_data, 1, buf.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_XModelsSortByDetailBodyCount
==============
*/
hkBool *HavokPhysics_XModelsSortByDetailBodyCount(hkBool *result, const XModel *a, const XModel *b)
{
  int m_size; 
  XModelDetailCollision *detailCollision; 
  int v8; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  PhysicsAsset *physicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  XModelDetailCollision *v12; 
  const HavokPhysicsXModelLOD *v13; 
  PhysicsAsset *v14; 
  const HavokPhysicsAsset *v15; 
  bool v16; 

  m_size = 0;
  detailCollision = a->detailCollision;
  v8 = 0;
  if ( detailCollision )
  {
    HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
    if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18204, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
      __debugbreak();
    m_size = HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size;
    if ( m_size == 1 )
      m_size = 2;
  }
  else
  {
    physicsAsset = a->physicsAsset;
    if ( physicsAsset )
    {
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18211, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      m_size = HavokPhysicsAsset->m_bodyServerUsage.m_size;
    }
  }
  v12 = b->detailCollision;
  if ( v12 )
  {
    v13 = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v12);
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18218, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
      __debugbreak();
    v8 = v13->m_bodyNames.m_size;
    if ( v8 == 1 )
      v8 = 2;
  }
  else
  {
    v14 = b->physicsAsset;
    if ( v14 )
    {
      v15 = HavokPhysics_GetHavokPhysicsAsset(v14);
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18225, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      v8 = v15->m_bodyServerUsage.m_size;
    }
  }
  if ( m_size == v8 )
    v16 = I_stricmp(a->name, b->name) < 0;
  else
    v16 = m_size > v8;
  result->m_bool = v16;
  return result;
}

/*
==============
HavokPhysics_XModelsSortByMemory
==============
*/
hkBool *HavokPhysics_XModelsSortByMemory(hkBool *result, const XModel *a, const XModel *b)
{
  result->m_bool = a->detailCollision->physicsLODDataSize > b->detailCollision->physicsLODDataSize;
  return result;
}

/*
==============
HavokPhysics_XModelsSortByName
==============
*/
hkBool *HavokPhysics_XModelsSortByName(hkBool *result, const XModel *a, const XModel *b)
{
  result->m_bool = I_stricmp(a->name, b->name) < 0;
  return result;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::Reset
==============
*/
void HavokPhysics_BroadphaseCollisionQueryResult::Reset(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  this->m_hits.m_size = 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::Reset
==============
*/
void HavokPhysics_CollisionQueryResult::Reset(HavokPhysics_CollisionQueryResult *this, bool clearModifiers)
{
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::Reset(this->m_collector, clearModifiers);
}

/*
==============
HavokPhysics_IgnoreBodies::Reset
==============
*/
void HavokPhysics_IgnoreBodies::Reset(HavokPhysics_IgnoreBodies *this)
{
  this->m_ignoreRefs = 0;
  this->m_ignoreEntities.m_size = 0;
  this->m_ignoreBodies.m_size = 0;
  this->m_ignoreTeamCharacters = TEAM_ZERO;
  this->m_ignoreTransparentVolumes = 0;
  this->m_ignoreLayers = 32;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreBody
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreBody(HavokPhysics_IgnoreBodies *this, int index, unsigned int bodyId)
{
  __int64 v4; 
  int m_size; 

  v4 = index;
  if ( (unsigned int)index >= this->m_ignoreBodies.m_size )
  {
    m_size = this->m_ignoreBodies.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 794, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreBodies.getSize() )", "index doesn't index m_ignoreBodies.getSize()\n\t%i not in [0, %i)", index, m_size) )
      __debugbreak();
  }
  this->m_ignoreBodies.m_data[v4].m_serialAndIndex = bodyId;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreEntity
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreEntity(HavokPhysics_IgnoreBodies *this, int index, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  __int64 v9; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *m_data; 
  int m_size; 

  v9 = index;
  if ( (unsigned int)index >= this->m_ignoreEntities.m_size )
  {
    m_size = this->m_ignoreEntities.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 801, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreEntities.getSize() )", "index doesn't index m_ignoreEntities.getSize()\n\t%i not in [0, %i)", index, m_size) )
      __debugbreak();
  }
  if ( svEntNum != 2047 )
  {
    m_data = this->m_ignoreEntities.m_data;
    *((_BYTE *)&m_data[v9] + 4) &= ~1u;
    m_data[v9].svEntNum = svEntNum;
    *((_BYTE *)&m_data[v9] + 4) = (self | *((_BYTE *)&m_data[v9] + 4)) & 0xE1 | (2 * (children & 0xF1 | (2 * (parent & 0xF9 | (2 * ((2 * linked) | siblings & 0xFD))))));
  }
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreRefs
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreRefs(HavokPhysics_IgnoreBodies *this, int refFlags)
{
  this->m_ignoreRefs = refFlags;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIsClutter
==============
*/
void HavokPhysics_IgnoreBodies::SetIsClutter(HavokPhysics_IgnoreBodies *this, bool isClutter)
{
  this->m_isClutter = isClutter;
}

/*
==============
HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly
==============
*/
void HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly(HavokPhysics_IgnoreBodies *this, bool simulationBodiesOnly)
{
  int v2; 

  v2 = this->m_ignoreLayers | 2;
  if ( !simulationBodiesOnly )
    v2 = this->m_ignoreLayers & 0xFFFFFFFD;
  this->m_ignoreLayers = v2;
}

/*
==============
HavokPhysics_CollisionQueryResult::SortResults
==============
*/
void HavokPhysics_CollisionQueryResult::SortResults(HavokPhysics_CollisionQueryResult *this)
{
  hknpAllHitsCollector *Collector; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 897, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( HavokPhysicsHitCollector::GetCollectorType(this->m_collector) != PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 898, ASSERT_TYPE_ASSERT, "(m_collector->GetCollectorType() == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL)", (const char *)&queryFormat, "m_collector->GetCollectorType() == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL") )
    __debugbreak();
  Collector = (hknpAllHitsCollector *)HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 901, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 903, ASSERT_TYPE_ASSERT, "(allHitsCollector)", (const char *)&queryFormat, "allHitsCollector") )
      __debugbreak();
  }
  hknpAllHitsCollector::sortHits(Collector);
}

/*
==============
HavokPhysics_SnapshotFixup::Validate
==============
*/
void HavokPhysics_SnapshotFixup::Validate(HavokPhysics_SnapshotFixup *this, HavokPhysicsWorld *world)
{
  __int64 m_hashMod; 
  int v3; 
  HavokPhysicsWorld *v4; 
  int v6; 
  __int64 v7; 
  __int64 v8; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  __int64 v10; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *v11; 
  unsigned __int64 key; 
  __int64 v15; 
  _WORD *v25; 
  __int64 v26; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *v27; 
  __int64 v28; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v29; 
  unsigned int capacity; 
  __int64 *v31; 
  __int64 v32; 
  int v33; 
  __int64 v34; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v35; 
  signed __int32 v36[8]; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  HavokPhysicsWorld *v40; 
  _WORD *v41; 
  char v42[256]; 

  m_hashMod = this->bodyData.m_hashMod;
  v3 = 0;
  v40 = world;
  v4 = world;
  v6 = 0;
  if ( (int)m_hashMod >= 0 )
  {
    v7 = m_hashMod;
    v8 = 0i64;
    m_elem = this->bodyData.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v6;
      ++v8;
      ++m_elem;
    }
    while ( v8 <= v7 );
  }
  if ( v6 <= this->bodyData.m_hashMod )
  {
    do
    {
      v10 = v6;
      v11 = this->bodyData.m_elem;
      key = v11[v10].key;
      _RDX = (__int64)&v11[v10].val;
      _RAX = &v41;
      v15 = 2i64;
      do
      {
        _RAX += 16;
        __asm { vmovups xmm0, xmmword ptr [rdx] }
        _RDX += 128i64;
        __asm
        {
          vmovups xmmword ptr [rax-80h], xmm0
          vmovups xmm1, xmmword ptr [rdx-70h]
          vmovups xmmword ptr [rax-70h], xmm1
          vmovups xmm0, xmmword ptr [rdx-60h]
          vmovups xmmword ptr [rax-60h], xmm0
          vmovups xmm1, xmmword ptr [rdx-50h]
          vmovups xmmword ptr [rax-50h], xmm1
          vmovups xmm0, xmmword ptr [rdx-40h]
          vmovups xmmword ptr [rax-40h], xmm0
          vmovups xmm1, xmmword ptr [rdx-30h]
          vmovups xmmword ptr [rax-30h], xmm1
          vmovups xmm0, xmmword ptr [rdx-20h]
          vmovups xmmword ptr [rax-20h], xmm0
          vmovups xmm1, xmmword ptr [rdx-10h]
          vmovups xmmword ptr [rax-10h], xmm1
        }
        --v15;
      }
      while ( v15 );
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx]
        vmovups xmmword ptr [rax], xmm0
      }
      (*(void (__fastcall **)(_WORD *))(*(_QWORD *)v41 + 24i64))(v41);
      if ( !v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4019, ASSERT_TYPE_ASSERT, "(data.shape != 0)", "%s\n\tInvalid shape for body %s with id %llu", "data.shape != NULL", v42, key) )
        __debugbreak();
      v25 = v41;
      _InterlockedOr(v36, 0);
      LOWORD(v25) = v25[9];
      _InterlockedOr(v36, 0);
      if ( !(_WORD)v25 && v41[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4020, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %llu", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", v42, key) )
        __debugbreak();
      if ( ++v6 <= this->bodyData.m_hashMod )
      {
        v26 = v6;
        v27 = &this->bodyData.m_elem[v6];
        do
        {
          if ( v27->key != -1i64 )
            break;
          ++v6;
          ++v26;
          ++v27;
        }
        while ( v26 <= this->bodyData.m_hashMod );
      }
    }
    while ( v6 <= this->bodyData.m_hashMod );
    v4 = v40;
  }
  if ( this->constraintData.m_hashMod >= 0 )
  {
    v28 = 0i64;
    v29 = this->constraintData.m_elem;
    do
    {
      if ( v29->key != -1i64 )
        break;
      ++v3;
      ++v28;
      ++v29;
    }
    while ( v28 <= this->constraintData.m_hashMod );
  }
  if ( v3 <= this->constraintData.m_hashMod )
  {
    do
    {
      capacity = v4->instanceManager.capacity;
      v31 = (__int64 *)&this->constraintData.m_elem[v3];
      v32 = v31[1];
      if ( HIDWORD(v32) >= capacity )
      {
        v39 = *v31;
        LODWORD(v38) = capacity;
        LODWORD(v37) = HIDWORD(v32);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4026, ASSERT_TYPE_ASSERT, "(data.instanceId < world->instanceManager.capacity)", "%s\n\tInstanceID %d out of range of %d for body %llu.", "data.instanceId < world->instanceManager.capacity", v37, v38, v39) )
          __debugbreak();
      }
      v33 = v3 + 1;
      if ( v3 + 1 <= this->constraintData.m_hashMod )
      {
        v34 = v33;
        v35 = &this->constraintData.m_elem[v33];
        do
        {
          if ( v35->key != -1i64 )
            break;
          ++v33;
          ++v34;
          ++v35;
        }
        while ( v34 <= this->constraintData.m_hashMod );
      }
      v3 = v33;
    }
    while ( v33 <= this->constraintData.m_hashMod );
  }
}

/*
==============
HavokPhysics_SnapshotFixup::getConstraintDataForConstraint
==============
*/
hkpConstraintData *HavokPhysics_SnapshotFixup::getConstraintDataForConstraint(HavokPhysics_SnapshotFixup *this, hknpConstraint *constraint)
{
  int m_hashMod; 
  __int64 m_value; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned __int64 key; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint val; 
  const HavokPhysicsWorld *ConstWorld; 
  const PhysicsAsset *PhysicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo *v15; 
  hkpConstraintData *v16; 
  const hkTransformf *v17; 
  hkTransformf pivot; 
  hkTransformf v20; 

  m_hashMod = this->constraintData.m_hashMod;
  m_value = constraint->m_id.m_value;
  if ( m_hashMod <= 0 || (m_elem = this->constraintData.m_elem, v6 = _byteswap_ulong(0), v7 = _byteswap_ulong(-1640531535 * m_value), v8 = m_hashMod & (v6 ^ ((v7 >> 2) + v7 + (v6 << 6) - 1640531527)), v9 = v8, key = m_elem[v8].key, key == -1i64) )
  {
LABEL_5:
    m_elem = this->constraintData.m_elem;
    v9 = m_hashMod + 1;
  }
  else
  {
    while ( key != m_value )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = v8;
      key = m_elem[v8].key;
      if ( key == -1i64 )
        goto LABEL_5;
    }
  }
  val = m_elem[v9].val;
  ConstWorld = HavokPhysics_GetConstWorld(this->worldId);
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4049, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics %i: world is NULL", "physicsWorld->world", this->worldId) )
    __debugbreak();
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&ConstWorld->instanceManager, val.instanceId);
  if ( PhysicsAsset )
  {
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
    if ( HavokPhysicsAsset )
      goto LABEL_15;
  }
  else
  {
    HavokPhysicsAsset = NULL;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4055, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
    __debugbreak();
LABEL_15:
  v15 = &HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data[val.constraintIdx];
  if ( (v15->m_bodyB.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF )
    return v15->m_constraintData.m_ptr;
  v16 = hkpConstraintDataUtils::deepClone(v15->m_constraintData.m_ptr);
  v17 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBodyTransform)(&ConstWorld->world->hknpWorldReader, v15->m_bodyA.m_serialAndIndex);
  hkpConstraintDataUtils::getPivotTransform(v15->m_constraintData.m_ptr, 1, &pivot);
  hkTransformf::setMul(&v20, v17, &pivot);
  hkpConstraintDataUtils::setPivotTransform(v16, &v20, 1);
  return v16;
}

/*
==============
HavokPhysics_SnapshotFixup::getShapeForBody
==============
*/
const hknpShape *HavokPhysics_SnapshotFixup::getShapeForBody(HavokPhysics_SnapshotFixup *this, hknpBody *body)
{
  int m_hashMod; 
  __int64 m_serialAndIndex; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned __int64 key; 
  __int64 v14; 
  const hknpShape *v24; 
  bool v25; 
  const hknpShape *result; 
  signed __int32 v27[8]; 
  __int64 v28; 
  const hknpShape *v29; 
  char v30[256]; 

  m_hashMod = this->bodyData.m_hashMod;
  m_serialAndIndex = body->m_id.m_serialAndIndex;
  if ( m_hashMod <= 0 || (m_elem = this->bodyData.m_elem, v7 = _byteswap_ulong(0), v8 = _byteswap_ulong(-1640531535 * m_serialAndIndex), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = v9, key = m_elem[v9].key, key == -1i64) )
  {
LABEL_5:
    m_elem = this->bodyData.m_elem;
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != m_serialAndIndex )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = m_elem[v9].key;
      if ( key == -1i64 )
        goto LABEL_5;
    }
  }
  _RAX = &v29;
  _RDX = (__int64)&m_elem[v10].val;
  v14 = 2i64;
  do
  {
    _RAX += 16;
    __asm { vmovups xmm0, xmmword ptr [rdx] }
    _RDX += 128i64;
    __asm
    {
      vmovups xmmword ptr [rax-80h], xmm0
      vmovups xmm1, xmmword ptr [rdx-70h]
      vmovups xmmword ptr [rax-70h], xmm1
      vmovups xmm0, xmmword ptr [rdx-60h]
      vmovups xmmword ptr [rax-60h], xmm0
      vmovups xmm1, xmmword ptr [rdx-50h]
      vmovups xmmword ptr [rax-50h], xmm1
      vmovups xmm0, xmmword ptr [rdx-40h]
      vmovups xmmword ptr [rax-40h], xmm0
      vmovups xmm1, xmmword ptr [rdx-30h]
      vmovups xmmword ptr [rax-30h], xmm1
      vmovups xmm0, xmmword ptr [rdx-20h]
      vmovups xmmword ptr [rax-20h], xmm0
      vmovups xmm1, xmmword ptr [rdx-10h]
      vmovups xmmword ptr [rax-10h], xmm1
    }
    --v14;
  }
  while ( v14 );
  __asm
  {
    vmovups xmm0, xmmword ptr [rdx]
    vmovups xmmword ptr [rax], xmm0
  }
  if ( v29 == (const hknpShape *)(unsigned __int8)v14 )
  {
    LODWORD(v28) = m_serialAndIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4035, ASSERT_TYPE_ASSERT, "(data.shape != 0)", "%s\n\tInvalid shape for body %s with id %d", "data.shape != NULL", v30, v28) )
      __debugbreak();
  }
  v24 = v29;
  _InterlockedOr(v27, 0);
  LOWORD(v24) = v24->m_refCount;
  _InterlockedOr(v27, 0);
  v25 = (_WORD)v24 == 0;
  result = v29;
  if ( v25 && v29->m_memSizeAndFlags )
  {
    LODWORD(v28) = body->m_id.m_serialAndIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4036, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %d", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", v30, v28) )
      __debugbreak();
    return v29;
  }
  return result;
}

/*
==============
hkKeycodeManager::setKeycodes
==============
*/
__int64 hkKeycodeManager::setKeycodes()
{
  const dvar_t *v0; 
  const dvar_t *v1; 
  const char *string; 
  const char *v3; 
  hkResult v5; 
  unsigned int v6; 
  int v7; 
  hkResult v9; 
  unsigned int v10; 
  hkStringView v13; 

  v0 = DVARSTR_physics_HavokPhysicsLicense;
  if ( !DVARSTR_physics_HavokPhysicsLicense && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_HavokPhysicsLicense") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  v1 = DVARSTR_physics_HavokClothLicense;
  string = v0->current.string;
  if ( !DVARSTR_physics_HavokClothLicense && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_HavokClothLicense") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  v3 = v1->current.string;
  v13 = (hkStringView)(unsigned __int64)string;
  if ( string )
    v13.m_end = &string[hkString::strLen(string)];
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+58h+var_18.m_begin]
    vmovdqa xmmword ptr [rsp+58h+var_18.m_begin], xmm0
  }
  v5.m_code = hkKeycodeManager::setKeycode(PHYSICS, &v13).m_code;
  v13 = (hkStringView)(unsigned __int64)v3;
  v6 = -2147220992;
  v7 = -2147220992;
  if ( v5.m_code >= 0 )
    v7 = 0;
  if ( v3 )
    v13.m_end = &v3[hkString::strLen(v3)];
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+58h+var_18.m_begin]
    vmovdqa xmmword ptr [rsp+58h+var_18.m_begin], xmm0
  }
  v9.m_code = hkKeycodeManager::setKeycode(CLOTH, &v13).m_code;
  v10 = -2147220992;
  v13.m_begin = (char *)&queryFormat.fmt + 3;
  if ( v9.m_code >= 0 )
    v10 = v7;
  v13.m_end = (char *)&queryFormat.fmt + hkString::strLen((const char *)&queryFormat.fmt + 3) + 3;
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+58h+var_18.m_begin]
    vmovdqa xmmword ptr [rsp+58h+var_18.m_begin], xmm0
  }
  if ( hkKeycodeManager::setKeycode(ANIMATION, &v13).m_code >= 0 )
    return v10;
  return v6;
}

/*
==============
setKeycodes
==============
*/
__int64 setKeycodes(void *__formal)
{
  int i; 
  unsigned int v3; 
  __int64 v4; 
  char *v5; 
  char *v6; 
  hkLog::Message v7; 
  const char *ProductName; 

  if ( hkKeycodeDataBase::singleton.m_ptr )
  {
    if ( hkKeycodeManager::setKeycodes().m_code >= 0 )
    {
      for ( i = 0; i < 10; ++i )
      {
        v3 = hkKeycodeData::s_linkedProducts;
        if ( _bittest((const int *)&v3, (unsigned __int8)i) )
        {
          v4 = 257i64 * (unsigned __int8)i;
          v5 = (char *)&hkKeycodeDataBase::singleton.m_ptr[1] + v4;
          v6 = NULL;
          if ( (hkKeycodeDataBase *)((char *)hkKeycodeDataBase::singleton.m_ptr + v4) != (hkKeycodeDataBase *)-24i64 )
            v6 = &v5[hkString::strLen((const char *)&hkKeycodeDataBase::singleton.m_ptr[1] + v4)];
          if ( v5 == v6 )
          {
            ProductName = hkKeycodeManager::getProductName((hkKeycodeManager::Products)i);
            hkLog::Message::Message(&v7, &s_keycodeLogOrigin, Canceled);
            hkLog::Message::setText(&v7, "  [ERROR: MISSING KEY] Product license key for Havok {} is missing.", (const hkVarArgs::Detail::VarArgsTypeArray<0> *)&hkVarArgs::Detail::VarArgsTypesOf<void,char const *>::typesArray, &ProductName, 0i64);
            hkLog::AutoMessage::~AutoMessage((hkLog::AutoMessage *)&v7);
          }
        }
      }
    }
    return 0i64;
  }
  else
  {
    return 2147746304i64;
  }
}

