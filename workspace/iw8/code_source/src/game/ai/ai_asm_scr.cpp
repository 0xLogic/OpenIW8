/*
==============
AIScr_ASM_GetEphemeralEventData
==============
*/

void __fastcall AIScr_ASM_GetEphemeralEventData(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetEphemeralEventData@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_DevGetAllNotetrackAimStates
==============
*/

void __fastcall AIScr_ASM_DevGetAllNotetrackAimStates(scrContext_t *scrContext)
{
  ?AIScr_ASM_DevGetAllNotetrackAimStates@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
AIScr_ASM_Terminate
==============
*/

void __fastcall AIScr_ASM_Terminate(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_Terminate@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_SetState
==============
*/

void __fastcall AIScr_ASM_SetState(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_SetState@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetEventData
==============
*/

void __fastcall AIScr_ASM_GetEventData(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetEventData@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetFacialState
==============
*/

void __fastcall AIScr_ASM_GetFacialState(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetFacialState@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_CurrentStateHasAimset
==============
*/

void __fastcall AIScr_ASM_CurrentStateHasAimset(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_CurrentStateHasAimset@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_CurrentStateHasShootAdditive
==============
*/

void __fastcall AIScr_ASM_CurrentStateHasShootAdditive(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_CurrentStateHasShootAdditive@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_HasPainState
==============
*/

void __fastcall AIScr_ASM_HasPainState(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_HasPainState@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_FireEvent
==============
*/

void __fastcall AIScr_ASM_FireEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_FireEvent@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_EventFiredWithin
==============
*/

void __fastcall AIScr_ASM_EventFiredWithin(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_EventFiredWithin@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_HasState
==============
*/

void __fastcall AIScr_ASM_HasState(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_HasState@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetCurrentState
==============
*/

void __fastcall AIScr_ASM_GetCurrentState(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetCurrentState@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_EphemeralEventFired
==============
*/

void __fastcall AIScr_ASM_EphemeralEventFired(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_EphemeralEventFired@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetNoteHandler
==============
*/

void __fastcall AIScr_ASM_GetNoteHandler(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetNoteHandler@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_EvalPainTransition
==============
*/

void __fastcall AIScr_ASM_EvalPainTransition(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_EvalPainTransition@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_DevGetAllStates
==============
*/

void __fastcall AIScr_ASM_DevGetAllStates(scrContext_t *scrContext)
{
  ?AIScr_ASM_DevGetAllStates@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
AIScr_ASM_ChooseAnim
==============
*/

void __fastcall AIScr_ASM_ChooseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_ChooseAnim@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_FireEphemeralEvent
==============
*/

void __fastcall AIScr_ASM_FireEphemeralEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_FireEphemeralEvent@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_RegisterGenericHandler
==============
*/

void __fastcall AIScr_ASM_RegisterGenericHandler(scrContext_t *scrContext)
{
  ?AIScr_ASM_RegisterGenericHandler@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
AIScr_ASM_ClearEphemeralEvents
==============
*/

void __fastcall AIScr_ASM_ClearEphemeralEvents(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_ClearEphemeralEvents@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_EventFired
==============
*/

void __fastcall AIScr_ASM_EventFired(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_EventFired@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_Tick
==============
*/

void __fastcall AIScr_ASM_Tick(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_Tick@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetStateTransitioningFrom
==============
*/

void __fastcall AIScr_ASM_GetStateTransitioningFrom(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetStateTransitioningFrom@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_CurrentStateHasFlag
==============
*/

void __fastcall AIScr_ASM_CurrentStateHasFlag(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_CurrentStateHasFlag@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_GetEventTime
==============
*/

void __fastcall AIScr_ASM_GetEventTime(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_GetEventTime@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_DoDeathTransition
==============
*/

void __fastcall AIScr_ASM_DoDeathTransition(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_DoDeathTransition@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_Instantiate
==============
*/

void __fastcall AIScr_ASM_Instantiate(scrContext_t *scrContext, scr_entref_t entref)
{
  ?AIScr_ASM_Instantiate@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
AIScr_ASM_ChooseAnim
==============
*/
void AIScr_ASM_ChooseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t v5; 
  scr_string_t stateName; 
  int NumParam; 
  int numParamsOverride; 
  int v9; 
  signed int i; 
  VariableType Type; 
  VariableType v13; 
  const char *v14; 
  int v15; 
  Ai_Asm *v16; 
  int v17; 
  scr_string_t v18; 
  ASM_Error v19; 
  int number; 
  const char *v21; 
  ComErrorCode v22; 
  const char *v23; 
  const char *v24; 
  unsigned int v25; 
  const char *v26; 
  const char *v27; 
  scr_string_t asmName; 
  ASM_Function_Param pParamsOverride; 

  Entity = GetEntity(entref);
  asmName = Scr_GetConstString(scrContext, 0);
  v5 = asmName;
  stateName = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
    stateName = Scr_GetConstString(scrContext, 1u);
  if ( NumParam <= 2 )
  {
    number = Entity->s.number;
    v16 = Ai_Asm::Singleton();
    v18 = asmName;
    v17 = number;
  }
  else
  {
    numParamsOverride = 0;
    v9 = 0;
    _RBX = &pParamsOverride.m_Type;
    for ( i = 2; i < NumParam; ++i )
    {
      Type = Scr_GetType(scrContext, i);
      if ( Type )
      {
        switch ( Type )
        {
          case VAR_STRING:
            *_RBX = ParamType_String;
            *((_DWORD *)_RBX - 1) = Scr_GetConstString(scrContext, i);
            break;
          case VAR_FLOAT:
            *_RBX = ParamType_Float;
            *(double *)&_XMM0 = Scr_GetFloat(scrContext, i);
            __asm { vmovss  dword ptr [rbx-4], xmm0 }
            break;
          case VAR_INTEGER:
            *_RBX = ParamType_Int;
            *((_DWORD *)_RBX - 1) = Scr_GetInt(scrContext, i);
            break;
          default:
            v13 = Scr_GetType(scrContext, i);
            v14 = j_va("Unsupported function param type (%d).", (unsigned __int8)v13);
            Scr_Error(COM_ERR_2884, scrContext, v14);
            break;
        }
      }
      else
      {
        *_RBX = ParamType_Undefined;
        ++v9;
      }
      ++numParamsOverride;
      _RBX += 2;
    }
    v15 = Entity->s.number;
    v16 = Ai_Asm::Singleton();
    v5 = asmName;
    v17 = v15;
    v18 = asmName;
    if ( v9 != numParamsOverride )
    {
      v19 = Common_Asm::ChooseAnimWithParamOverride(v16, NULL, v15, asmName, stateName, numParamsOverride, &pParamsOverride, NULL);
      goto LABEL_20;
    }
  }
  v19 = Common_Asm::ChooseAnim(v16, NULL, v17, v18, stateName, NULL);
LABEL_20:
  switch ( v19 )
  {
    case ASM_ERR_NO_INST:
      v21 = j_va("Ent %d is not running an ASM!", (unsigned int)Entity->s.number);
      v22 = COM_ERR_2885;
      break;
    case ASM_ERR_NO_SUBTREE:
      v23 = SL_ConvertToString(v5);
      v21 = j_va("Ent %d is not currently running ASM %s", (unsigned int)Entity->s.number, v23);
      v22 = COM_ERR_2886;
      break;
    case ASM_ERR_NO_STATE:
      v24 = SL_ConvertToString(v5);
      v25 = Entity->s.number;
      v26 = v24;
      v27 = SL_ConvertToString(stateName);
      v21 = j_va("Unable to find state %s in ent %d ASM %s", v27, v25, v26);
      v22 = COM_ERR_2887;
      break;
    default:
      return;
  }
  Scr_Error(v22, scrContext, v21);
}

/*
==============
AIScr_ASM_ClearEphemeralEvents
==============
*/
void AIScr_ASM_ClearEphemeralEvents(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  Ai_Asm *v8; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2923, scrContext, v7);
  }
  v8 = Ai_Asm::Singleton();
  Common_Asm::ClearEphemeralEventsByInstance(v8, Instance);
}

/*
==============
AIScr_ASM_CurrentStateHasAimset
==============
*/
void AIScr_ASM_CurrentStateHasAimset(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  const ASM_Instance *Instance; 
  const char *v9; 
  const char *String; 
  const char *v11; 
  scr_string_t AnimsetName; 
  bool AddonAnimsFromState; 
  int outAnimIndices; 
  scr_string_t aliases; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2892, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 && !Common_Asm::Utils::GetSubtree(Instance, v6) )
  {
    String = Scr_GetString(scrContext, 0);
    v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, String);
    Scr_Error(COM_ERR_2893, scrContext, v11);
  }
  AnimsetName = BG_AnimationState_GetAnimsetName(&Entity->s);
  AddonAnimsFromState = BG_Animset_GetAddonAnimsFromState(AnimsetName, (Entity->s.animInfo.animData >> 1) & 0x3FF, (Entity->s.animInfo.animData >> 11) & 0x7F, ANIMSTATE_AIMSET, &aliases, 0, &outAnimIndices);
  Scr_AddBool(scrContext, AddonAnimsFromState);
}

/*
==============
AIScr_ASM_CurrentStateHasFlag
==============
*/
void AIScr_ASM_CurrentStateHasFlag(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  scr_string_t ConstLowercaseString; 
  int number; 
  scr_string_t v7; 
  Ai_Asm *v8; 
  const ASM_Instance *Instance; 
  const char *v10; 
  const char *String; 
  const char *v12; 
  bool HasFlag; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  number = Entity->s.number;
  v7 = ConstLowercaseString;
  v8 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v8, NULL, number);
  if ( !Instance )
  {
    v10 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2890, scrContext, v10);
  }
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      String = Scr_GetString(scrContext, 0);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, String);
      Scr_Error(COM_ERR_2891, scrContext, v12);
    }
  }
  HasFlag = Common_Asm::Utils::CurrentStateHasFlag(Instance, v7);
  Scr_AddBool(scrContext, HasFlag);
}

/*
==============
AIScr_ASM_CurrentStateHasShootAdditive
==============
*/
void AIScr_ASM_CurrentStateHasShootAdditive(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  const ASM_Instance *Instance; 
  const char *v9; 
  const char *String; 
  const char *v11; 
  scr_string_t AnimsetName; 
  bool AddonAnimsFromState; 
  int outAnimIndices; 
  scr_string_t aliases; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_5746, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 && !Common_Asm::Utils::GetSubtree(Instance, v6) )
  {
    String = Scr_GetString(scrContext, 0);
    v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, String);
    Scr_Error(COM_ERR_5747, scrContext, v11);
  }
  AnimsetName = BG_AnimationState_GetAnimsetName(&Entity->s);
  AddonAnimsFromState = BG_Animset_GetAddonAnimsFromState(AnimsetName, (Entity->s.animInfo.animData >> 1) & 0x3FF, (Entity->s.animInfo.animData >> 11) & 0x7F, ANIMSTATE_SHOOT, &aliases, 0, &outAnimIndices);
  Scr_AddBool(scrContext, AddonAnimsFromState);
}

/*
==============
AIScr_ASM_DevGetAllNotetrackAimStates
==============
*/
void AIScr_ASM_DevGetAllNotetrackAimStates(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  Ai_Asm *v3; 
  ASM *ASM; 
  const char *v5; 
  const char *v6; 
  int v7; 
  __int64 v8; 
  ASM_State *m_States; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Ai_Asm::Singleton();
  ASM = Common_Asm::GetASM(v3, ConstString);
  if ( !ASM )
  {
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("ASM %s not loaded!", v5);
    Scr_Error(COM_ERR_2932, scrContext, v6);
  }
  Scr_MakeArray(scrContext);
  v7 = 0;
  if ( ASM->m_NumStates > 0 )
  {
    v8 = 0i64;
    do
    {
      m_States = ASM->m_States;
      if ( (m_States[v8].m_Flags & 2) != 0 )
      {
        Scr_AddConstString(scrContext, m_States[v8].m_Name);
        Scr_AddArray(scrContext);
      }
      ++v7;
      ++v8;
    }
    while ( v7 < ASM->m_NumStates );
  }
}

/*
==============
AIScr_ASM_DevGetAllStates
==============
*/
void AIScr_ASM_DevGetAllStates(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  Ai_Asm *v3; 
  ASM *ASM; 
  const char *v5; 
  const char *v6; 
  int v7; 
  __int64 v8; 
  ASM_State *m_States; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Ai_Asm::Singleton();
  ASM = Common_Asm::GetASM(v3, ConstString);
  if ( !ASM )
  {
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("ASM %s not loaded!", v5);
    Scr_Error(COM_ERR_2933, scrContext, v6);
  }
  Scr_MakeArray(scrContext);
  v7 = 0;
  if ( ASM->m_NumStates > 0 )
  {
    v8 = 0i64;
    do
    {
      m_States = ASM->m_States;
      if ( !m_States[v8].m_Type )
      {
        Scr_AddConstString(scrContext, m_States[v8].m_Name);
        Scr_AddArray(scrContext);
      }
      ++v7;
      ++v8;
    }
    while ( v7 < ASM->m_NumStates );
  }
}

/*
==============
AIScr_ASM_DoDeathTransition
==============
*/
void AIScr_ASM_DoDeathTransition(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  ASM_Instance *Instance; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  Ai_Asm *v12; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2900, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, v6);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(v6);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2901, scrContext, v11);
    }
  }
  v12 = Ai_Asm::Singleton();
  Common_Asm::Death(v12, NULL, Instance);
}

/*
==============
AIScr_ASM_EphemeralEventFired
==============
*/
void AIScr_ASM_EphemeralEventFired(scrContext_t *scrContext, scr_entref_t entref)
{
  int number; 
  Ai_Asm *v4; 
  ASM_Instance *Instance; 
  int v6; 
  ASM_Instance *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  Ai_Asm *v10; 

  number = GetEntity(entref)->s.number;
  v4 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v4, NULL, number);
  v6 = 0;
  v7 = Instance;
  if ( Instance )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v9 = Scr_GetConstString(scrContext, 1u);
    v10 = Ai_Asm::Singleton();
    v6 = Common_Asm::EphemeralEventFired(v10, v7, ConstString, v9);
  }
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScr_ASM_EvalPainTransition
==============
*/
void AIScr_ASM_EvalPainTransition(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  ASM_Instance *Instance; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const ASM_State *State; 
  int m_PainState; 
  const ASM_State *v14; 
  const char *v15; 
  const char *v16; 
  ASM_Function_Param *pParamsOverrideEntry; 
  int m_PainNumParams; 
  Ai_Asm *v19; 
  const char *v20; 
  const char *v21; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2896, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, v6);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(v6);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2897, scrContext, v11);
    }
  }
  State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
  if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 377, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
    __debugbreak();
  m_PainState = State->m_PainState;
  if ( m_PainState != -1 )
  {
    v14 = Common_Asm::Utils::GetState(Instance->m_pASM, m_PainState);
    if ( !v14 )
    {
      v15 = SL_ConvertToString(State->m_Name);
      v16 = j_va("Unable to find pain state listed in ASM %s, state %s", Instance->m_pASM->m_szName, v15);
      Scr_Error(COM_ERR_2898, scrContext, v16);
    }
    pParamsOverrideEntry = State->m_PainParams;
    m_PainNumParams = State->m_PainNumParams;
    v19 = Ai_Asm::Singleton();
    if ( Common_Asm::SetState(v19, NULL, Instance, v14, m_PainNumParams, pParamsOverrideEntry) == ASM_ERR_NO_PASS )
    {
      v20 = SL_ConvertToString(v14->m_Name);
      v21 = j_va("Unable to set pain state %s. No valid passthrough transitions evaluated.", v20);
      Scr_Error(COM_ERR_2899, scrContext, v21);
    }
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
AIScr_ASM_EventFired
==============
*/
void AIScr_ASM_EventFired(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  const char *v10; 
  const char *v11; 
  bool v12; 
  __int64 v13; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2919, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 775, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(ConstString);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2920, scrContext, v11);
    }
  }
  if ( Instance->m_CurState >= (unsigned int)Instance->m_pASM->m_NumStates )
  {
    LODWORD(v13) = Instance->m_CurState;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 783, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", v13, Instance->m_pASM->m_NumStates) )
      __debugbreak();
  }
  v12 = Common_Asm::Utils::EventFired(Instance, v9);
  Scr_AddBool(scrContext, v12);
}

/*
==============
AIScr_ASM_EventFiredWithin
==============
*/
void AIScr_ASM_EventFiredWithin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  int Int; 
  const char *v11; 
  const char *v12; 
  Ai_Asm *v13; 
  bool v14; 
  __int64 v15; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2921, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 843, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v11 = SL_ConvertToString(ConstString);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v11);
      Scr_Error(COM_ERR_2922, scrContext, v12);
    }
  }
  if ( Instance->m_CurState >= (unsigned int)Instance->m_pASM->m_NumStates )
  {
    LODWORD(v15) = Instance->m_CurState;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 851, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", v15, Instance->m_pASM->m_NumStates) )
      __debugbreak();
  }
  v13 = Ai_Asm::Singleton();
  v14 = Common_Asm::EventFiredWithin(v13, Instance, v9, Int);
  Scr_AddBool(scrContext, v14);
}

/*
==============
AIScr_ASM_FireEphemeralEvent
==============
*/
void AIScr_ASM_FireEphemeralEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t eventName; 
  VariableValue *pParam; 
  Ai_Asm *v11; 
  Ai_Asm *v12; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2918, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  eventName = Scr_GetConstString(scrContext, 1u);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    pParam = Scr_GetVariable(scrContext, 2u);
    v11 = Ai_Asm::Singleton();
    Common_Asm::FireEphemeralEvent(v11, NULL, Instance, ConstString, eventName, pParam);
  }
  else
  {
    v12 = Ai_Asm::Singleton();
    Common_Asm::FireEphemeralEvent(v12, NULL, Instance, ConstString, eventName);
  }
}

/*
==============
AIScr_ASM_FireEvent
==============
*/
void AIScr_ASM_FireEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  const char *v10; 
  const char *v11; 
  VariableValue *Variable; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2916, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 698, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(ConstString);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2917, scrContext, v11);
    }
  }
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Variable = Scr_GetVariable(scrContext, 2u);
    AI_ASM_FireEvent(Instance, v9, Variable);
  }
  else
  {
    AI_ASM_FireEvent(Instance, v9);
  }
}

/*
==============
AIScr_ASM_GetCurrentState
==============
*/
void AIScr_ASM_GetCurrentState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  const ASM_Instance *Instance; 
  const char *v9; 
  const ASM_State *CurrentStateByAssetName; 
  const char *String; 
  const char *v12; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an ASM!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2888, scrContext, v9);
  }
  CurrentStateByAssetName = Common_Asm::Utils::GetCurrentStateByAssetName(Instance, v6);
  if ( !CurrentStateByAssetName )
  {
    String = Scr_GetString(scrContext, 0);
    v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, String);
    Scr_Error(COM_ERR_2889, scrContext, v12);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 195, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
  }
  Scr_AddConstString(scrContext, CurrentStateByAssetName->m_Name);
}

/*
==============
AIScr_ASM_GetEphemeralEventData
==============
*/
void AIScr_ASM_GetEphemeralEventData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t eventTag; 
  scr_string_t ConstString; 
  const char *v10; 
  Ai_Asm *v11; 
  int paramID; 
  unsigned int eventTableID; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2930, scrContext, v7);
  }
  eventTag = Scr_GetConstString(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( !ConstString )
  {
    v10 = j_va("ASMGetEvent: invalid event name.");
    Scr_Error(COM_ERR_2931, scrContext, v10);
  }
  v11 = Ai_Asm::Singleton();
  if ( Ai_Asm::GetEphemeralEventData(v11, Entity->s.number, Instance, ConstString, eventTag, &eventTableID, &paramID) )
    ASM_FetchEventData(scrContext, eventTableID, paramID);
}

/*
==============
AIScr_ASM_GetEventData
==============
*/
void AIScr_ASM_GetEventData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  Ai_Asm *v13; 
  int paramID; 
  unsigned int outVar; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2924, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !v9 )
  {
    v10 = j_va("ASMGetEventID: invalid event name.");
    Scr_Error(COM_ERR_2925, scrContext, v10);
  }
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 919, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v11 = SL_ConvertToString(ConstString);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v11);
      Scr_Error(COM_ERR_2926, scrContext, v12);
    }
  }
  v13 = Ai_Asm::Singleton();
  if ( Ai_Asm::GetEventData(v13, Entity->s.number, Instance, v9, &outVar, &paramID) )
    ASM_FetchEventData(scrContext, outVar, paramID);
}

/*
==============
AIScr_ASM_GetEventTime
==============
*/
void AIScr_ASM_GetEventTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  ASM_Event *m_EventTable; 
  __int64 v14; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2927, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !v9 )
  {
    v10 = j_va("ASMGetEventID: invalid event name.");
    Scr_Error(COM_ERR_2928, scrContext, v10);
  }
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 959, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v11 = SL_ConvertToString(ConstString);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v11);
      Scr_Error(COM_ERR_2929, scrContext, v12);
    }
  }
  m_EventTable = Instance->m_EventTable;
  v14 = 0i64;
  while ( m_EventTable->m_Name != v9 )
  {
    ++v14;
    ++m_EventTable;
    if ( v14 >= 8 )
      return;
  }
  Scr_AddInt(scrContext, m_EventTable->m_Time);
}

/*
==============
AIScr_ASM_GetFacialState
==============
*/
void AIScr_ASM_GetFacialState(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  scr_string_t v5; 
  Ai_Asm *v6; 
  const ASM *ASM; 
  Ai_Asm *v8; 
  const ASM_State *StateByName; 
  scr_string_t m_FacialState; 
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v13; 
  ASM_Instance *Instance; 
  const char *v15; 
  const ASM_State *State; 

  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v5 = Scr_GetConstString(scrContext, 1u);
    v6 = Ai_Asm::Singleton();
    ASM = Common_Asm::GetASM(v6, ConstString);
    v8 = Ai_Asm::Singleton();
    StateByName = Common_Asm::GetStateByName(v8, ASM, v5);
    if ( !StateByName )
      return;
    m_FacialState = StateByName->m_FacialState;
  }
  else
  {
    Entity = GetEntity(entref);
    number = Entity->s.number;
    v13 = Ai_Asm::Singleton();
    Instance = Ai_Asm::GetInstance(v13, NULL, number);
    if ( !Instance )
    {
      v15 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_2914, scrContext, v15);
    }
    State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
    if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 645, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
    m_FacialState = State->m_FacialState;
  }
  if ( m_FacialState )
    Scr_AddConstString(scrContext, m_FacialState);
}

/*
==============
AIScr_ASM_GetNoteHandler
==============
*/
void AIScr_ASM_GetNoteHandler(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  ASM_Instance *Instance; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const ASM_State *State; 
  int m_FuncID; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2912, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, v6);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(v6);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2913, scrContext, v11);
    }
  }
  State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
  if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 605, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
    __debugbreak();
  m_FuncID = -1;
  if ( !State->m_PlayAnimNoteHandler.m_bBuiltin )
    m_FuncID = State->m_PlayAnimNoteHandler.m_FuncID;
  Scr_AddInt(scrContext, m_FuncID);
}

/*
==============
AIScr_ASM_GetStateTransitioningFrom
==============
*/
void AIScr_ASM_GetStateTransitioningFrom(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  ASM_Instance *Instance; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  int m_PrevState; 
  const ASM_State *State; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2894, scrContext, v9);
  }
  if ( Instance->m_pASM->m_Name != v6 )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, v6);
    if ( !Instance )
    {
      v10 = SL_ConvertToString(v6);
      v11 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v10);
      Scr_Error(COM_ERR_2895, scrContext, v11);
    }
  }
  m_PrevState = Instance->m_PrevState;
  if ( m_PrevState != -1 )
  {
    State = Common_Asm::Utils::GetState(Instance->m_pASM, m_PrevState);
    if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 343, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
    Scr_AddConstString(scrContext, State->m_Name);
  }
}

/*
==============
AIScr_ASM_HasPainState
==============
*/
void AIScr_ASM_HasPainState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int number; 
  scr_string_t v6; 
  Ai_Asm *v7; 
  const ASM_Instance *Instance; 
  const char *v9; 
  const ASM_State *CurrentStateByAssetName; 
  const char *String; 
  const char *v12; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  number = Entity->s.number;
  v6 = ConstString;
  v7 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v7, NULL, number);
  if ( !Instance )
  {
    v9 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2902, scrContext, v9);
  }
  CurrentStateByAssetName = Common_Asm::Utils::GetCurrentStateByAssetName(Instance, v6);
  if ( !CurrentStateByAssetName )
  {
    String = Scr_GetString(scrContext, 0);
    v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, String);
    Scr_Error(COM_ERR_2903, scrContext, v12);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 453, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
  }
  Scr_AddBool(scrContext, CurrentStateByAssetName->m_PainState != -1);
}

/*
==============
AIScr_ASM_HasState
==============
*/
void AIScr_ASM_HasState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  scr_string_t v5; 
  int number; 
  scr_string_t v7; 
  Ai_Asm *v8; 
  const ASM_Instance *Instance; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  Ai_Asm *v13; 
  bool HasState; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = Scr_GetConstString(scrContext, 1u);
  number = Entity->s.number;
  v7 = v5;
  v8 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v8, NULL, number);
  if ( !Instance )
  {
    v10 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2904, scrContext, v10);
  }
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v11 = SL_ConvertToString(ConstString);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v11);
      Scr_Error(COM_ERR_2905, scrContext, v12);
    }
  }
  v13 = Ai_Asm::Singleton();
  HasState = Common_Asm::HasState(v13, Instance->m_pASM, v7);
  Scr_AddBool(scrContext, HasState);
}

/*
==============
AIScr_ASM_Instantiate
==============
*/
void AIScr_ASM_Instantiate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  scr_string_t v5; 
  Ai_Asm *v6; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  LODWORD(Entity) = Entity->s.number;
  v5 = ConstString;
  v6 = Ai_Asm::Singleton();
  Common_Asm::Instantiate(v6, NULL, (int)Entity, v5, 0, scrContext);
}

/*
==============
AIScr_ASM_RegisterGenericHandler
==============
*/
void AIScr_ASM_RegisterGenericHandler(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int Func; 
  Ai_Asm *v4; 
  ASM *ASM; 
  const char *v6; 
  const char *v7; 

  ConstString = Scr_GetConstString(scrContext, 0);
  Func = Scr_GetFunc(scrContext, 1u);
  v4 = Ai_Asm::Singleton();
  ASM = Common_Asm::GetASM(v4, ConstString);
  if ( !ASM )
  {
    v6 = SL_ConvertToString(ConstString);
    v7 = j_va("Unable to find ASM asset %s.", v6);
    Scr_Error(COM_ERR_2883, scrContext, v7);
  }
  if ( ASM->m_Mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 40, ASSERT_TYPE_ASSERT, "( pASM->m_Mode == ASM_MODE_AI )", (const char *)&queryFormat, "pASM->m_Mode == ASM_MODE_AI") )
    __debugbreak();
  ASM->u.m_AIASM->m_ScriptHandler = Func;
}

/*
==============
AIScr_ASM_SetState
==============
*/
void AIScr_ASM_SetState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  scr_string_t v6; 
  int number; 
  Ai_Asm *v8; 
  ASM_Instance *Instance; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  int numParamsOverrideEntry; 
  int NumParam; 
  int v15; 
  const char *v16; 
  int v17; 
  signed int v18; 
  VariableType Type; 
  const char *v21; 
  Ai_Asm *v22; 
  ASM_Error v23; 
  const char *m_szName; 
  const char *v25; 
  const char *v26; 
  ComErrorCode v27; 
  const char *v28; 
  scr_string_t stateName; 
  ASM_Function_Param pParamsOverrideEntry; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  v6 = Scr_GetConstString(scrContext, 1u);
  number = Entity->s.number;
  stateName = v6;
  v8 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v8, NULL, number);
  if ( !Instance )
  {
    v10 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2906, scrContext, v10);
  }
  if ( Instance->m_pASM->m_Name != ConstString )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, ConstString);
    if ( !Instance )
    {
      v11 = SL_ConvertToString(ConstString);
      v12 = j_va("ent %d is not currently running asm %s!", (unsigned int)Entity->s.number, v11);
      Scr_Error(COM_ERR_2907, scrContext, v12);
    }
  }
  numParamsOverrideEntry = 0;
  NumParam = Scr_GetNumParam(scrContext);
  v15 = 0;
  if ( NumParam > 10 )
  {
    v16 = j_va("Function passed more than the max allowed param overrides (%d)", 8i64);
    Scr_Error(COM_ERR_2908, scrContext, v16);
  }
  v17 = 0;
  if ( NumParam > 2 )
  {
    v18 = 2;
    _RBX = &pParamsOverrideEntry.m_Type;
    do
    {
      Type = Scr_GetType(scrContext, v18);
      if ( Type )
      {
        switch ( Type )
        {
          case VAR_STRING:
            *_RBX = ParamType_String;
            *((_DWORD *)_RBX - 1) = Scr_GetConstString(scrContext, v18);
            break;
          case VAR_FLOAT:
            *_RBX = ParamType_Float;
            *(double *)&_XMM0 = Scr_GetFloat(scrContext, v18);
            __asm { vmovss  dword ptr [rbx-4], xmm0 }
            break;
          case VAR_INTEGER:
            *_RBX = ParamType_Int;
            *((_DWORD *)_RBX - 1) = Scr_GetInt(scrContext, v18);
            break;
          default:
            v21 = j_va("Function passed unsupported param override type (%d)", (unsigned __int8)Type);
            Scr_Error(COM_ERR_2909, scrContext, v21);
            break;
        }
      }
      else
      {
        *_RBX = ParamType_Undefined;
        ++v17;
      }
      ++v15;
      ++v18;
      _RBX += 2;
    }
    while ( v18 < NumParam );
  }
  v22 = Ai_Asm::Singleton();
  if ( v17 != v15 )
    numParamsOverrideEntry = v15;
  v23 = Common_Asm::SetState(v22, NULL, Instance, stateName, numParamsOverrideEntry, &pParamsOverrideEntry);
  if ( v23 == ASM_ERR_NO_STATE )
  {
    m_szName = Instance->m_pASM->m_szName;
    v25 = SL_ConvertToString(stateName);
    v26 = j_va("unable to find state %s in asm %s.", v25, m_szName);
    v27 = COM_ERR_2910;
  }
  else
  {
    if ( v23 != ASM_ERR_NO_PASS )
      return;
    v28 = SL_ConvertToString(stateName);
    v26 = j_va("unable to successfully transition to state %s. no valid passthrough transitions found.", v28);
    v27 = COM_ERR_2911;
  }
  Scr_Error(v27, scrContext, v26);
}

/*
==============
AIScr_ASM_Terminate
==============
*/
void AIScr_ASM_Terminate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  Ai_Asm *v8; 
  int v9; 
  Ai_Asm *v10; 

  Entity = GetEntity(entref);
  number = Entity->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_2915, scrContext, v7);
  }
  v8 = Ai_Asm::Singleton();
  Common_Asm::TerminateAllStates(v8, NULL, Instance);
  v9 = Entity->s.number;
  v10 = Ai_Asm::Singleton();
  Ai_Asm::FreeInstance(v10, NULL, v9);
}

/*
==============
AIScr_ASM_Tick
==============
*/
void AIScr_ASM_Tick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  int number; 
  Ai_Asm *v6; 

  Entity = GetEntity(entref);
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  number = Entity->s.number;
  SV_Profile_BeginEvent(SVPROF_AI_ASM_TICK);
  v6 = Ai_Asm::Singleton();
  Common_Asm::Tick(v6, NULL, number, v4, 0);
  SV_Profile_EndEvent(SVPROF_AI_ASM_TICK);
}

/*
==============
ASM_FetchEventData
==============
*/
void ASM_FetchEventData(scrContext_t *scrContext, unsigned int eventTableID, int paramID)
{
  unsigned int ArrayVariable; 
  VariableValue out; 

  if ( !eventTableID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 879, ASSERT_TYPE_ASSERT, "(eventTableID)", (const char *)&queryFormat, "eventTableID") )
    __debugbreak();
  if ( paramID < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_scr.cpp", 880, ASSERT_TYPE_ASSERT, "(paramID >= 0)", (const char *)&queryFormat, "paramID >= 0") )
    __debugbreak();
  ArrayVariable = FindArrayVariable(scrContext, eventTableID, paramID);
  if ( ArrayVariable )
  {
    Scr_EvalVariable_Out(scrContext, ArrayVariable, &out);
    Scr_AddValue(scrContext, &out);
    RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
  }
}

