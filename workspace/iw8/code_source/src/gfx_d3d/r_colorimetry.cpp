/*
==============
R_DisplayMapping_GetHdrMinLum
==============
*/

double __fastcall R_DisplayMapping_GetHdrMinLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetHdrMinLum@@YAMXZ();
  return result;
}

/*
==============
R_GetDefaultHDRMappingParams
==============
*/

GfxDisplayMappingParams *__fastcall R_GetDefaultHDRMappingParams(GfxDisplayMappingParams *result)
{
  return ?R_GetDefaultHDRMappingParams@@YA?AUGfxDisplayMappingParams@@XZ(result);
}

/*
==============
R_GetDisplayColorimetry
==============
*/

GfxColorimetry __fastcall R_GetDisplayColorimetry()
{
  return ?R_GetDisplayColorimetry@@YA?AW4GfxColorimetry@@XZ();
}

/*
==============
R_DisplayMapping_GetMaxLum
==============
*/

double __fastcall R_DisplayMapping_GetMaxLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetMaxLum@@YAMXZ();
  return result;
}

/*
==============
R_DisplayMappingGetAdjustedHDRMinLum
==============
*/

double __fastcall R_DisplayMappingGetAdjustedHDRMinLum(float calibratedMinLuminance)
{
  double result; 

  *(float *)&result = ?R_DisplayMappingGetAdjustedHDRMinLum@@YAMM@Z(calibratedMinLuminance);
  return result;
}

/*
==============
R_GetDisplayHdrUiMaxLuminance
==============
*/

double __fastcall R_GetDisplayHdrUiMaxLuminance()
{
  double result; 

  *(float *)&result = ?R_GetDisplayHdrUiMaxLuminance@@YAMXZ();
  return result;
}

/*
==============
R_GetSdrDisplayMappingParams
==============
*/

GfxDisplayMappingParams *__fastcall R_GetSdrDisplayMappingParams(GfxDisplayMappingParams *result)
{
  return ?R_GetSdrDisplayMappingParams@@YA?AUGfxDisplayMappingParams@@XZ(result);
}

/*
==============
R_DisplayMapping_GetSdrMaxLum
==============
*/

double __fastcall R_DisplayMapping_GetSdrMaxLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetSdrMaxLum@@YAMXZ();
  return result;
}

/*
==============
R_GetSdrDisplayColorimetry
==============
*/

GfxColorimetry __fastcall R_GetSdrDisplayColorimetry()
{
  return ?R_GetSdrDisplayColorimetry@@YA?AW4GfxColorimetry@@XZ();
}

/*
==============
R_IsDisplayHDRCapable
==============
*/

bool __fastcall R_IsDisplayHDRCapable()
{
  return ?R_IsDisplayHDRCapable@@YA_NXZ();
}

/*
==============
R_ShouldUseHDR
==============
*/

bool __fastcall R_ShouldUseHDR()
{
  return ?R_ShouldUseHDR@@YA_NXZ();
}

/*
==============
R_GetHdrDisplayMappingParams
==============
*/

GfxDisplayMappingParams *__fastcall R_GetHdrDisplayMappingParams(GfxDisplayMappingParams *result)
{
  return ?R_GetHdrDisplayMappingParams@@YA?AUGfxDisplayMappingParams@@XZ(result);
}

/*
==============
R_ShouldForceHDRCapable
==============
*/

bool __fastcall R_ShouldForceHDRCapable()
{
  return ?R_ShouldForceHDRCapable@@YA_NXZ();
}

/*
==============
R_DisplayMapping_GetHdrMaxLum
==============
*/

double __fastcall R_DisplayMapping_GetHdrMaxLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetHdrMaxLum@@YAMXZ();
  return result;
}

/*
==============
R_IsColorimetryHDR
==============
*/

bool __fastcall R_IsColorimetryHDR(const GfxColorimetry colorimetry)
{
  return ?R_IsColorimetryHDR@@YA_NW4GfxColorimetry@@@Z(colorimetry);
}

/*
==============
R_InitColorimetry
==============
*/

void R_InitColorimetry(void)
{
  ?R_InitColorimetry@@YAXXZ();
}

/*
==============
R_DisplayMapping_GetHdrGamma
==============
*/

double __fastcall R_DisplayMapping_GetHdrGamma()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetHdrGamma@@YAMXZ();
  return result;
}

/*
==============
R_GetDesiredDisplayColorimetry
==============
*/

GfxColorimetry __fastcall R_GetDesiredDisplayColorimetry()
{
  return ?R_GetDesiredDisplayColorimetry@@YA?AW4GfxColorimetry@@XZ();
}

/*
==============
R_GetFramebufferColorimetry
==============
*/

GfxColorimetry __fastcall R_GetFramebufferColorimetry()
{
  return ?R_GetFramebufferColorimetry@@YA?AW4GfxColorimetry@@XZ();
}

/*
==============
R_DisplayMapping_GetMinLum
==============
*/

double __fastcall R_DisplayMapping_GetMinLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetMinLum@@YAMXZ();
  return result;
}

/*
==============
R_GetDisplayBlacklevel
==============
*/

double __fastcall R_GetDisplayBlacklevel(bool apply)
{
  double result; 

  *(float *)&result = ?R_GetDisplayBlacklevel@@YAM_N@Z(apply);
  return result;
}

/*
==============
R_DisplayMapping_GetSdrGamma
==============
*/

double __fastcall R_DisplayMapping_GetSdrGamma()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetSdrGamma@@YAMXZ();
  return result;
}

/*
==============
R_IsHDRAllowed
==============
*/

bool __fastcall R_IsHDRAllowed()
{
  return ?R_IsHDRAllowed@@YA_NXZ();
}

/*
==============
R_DisplayMapping_GetSdrMinLum
==============
*/

double __fastcall R_DisplayMapping_GetSdrMinLum()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetSdrMinLum@@YAMXZ();
  return result;
}

/*
==============
R_GetSdrDefaultColorimetry
==============
*/

GfxColorimetry __fastcall R_GetSdrDefaultColorimetry()
{
  return ?R_GetSdrDefaultColorimetry@@YA?AW4GfxColorimetry@@XZ();
}

/*
==============
R_GetDisplayMappingParams
==============
*/

GfxDisplayMappingParams *__fastcall R_GetDisplayMappingParams(GfxDisplayMappingParams *result)
{
  return ?R_GetDisplayMappingParams@@YA?AUGfxDisplayMappingParams@@XZ(result);
}

/*
==============
R_DisplayMapping_GetGamma
==============
*/

double __fastcall R_DisplayMapping_GetGamma()
{
  double result; 

  *(float *)&result = ?R_DisplayMapping_GetGamma@@YAMXZ();
  return result;
}

/*
==============
R_DisplayMappingGetAdjustedHDRMinLum
==============
*/

float __fastcall R_DisplayMappingGetAdjustedHDRMinLum(double calibratedMinLuminance)
{
  __asm
  {
    vsubss  xmm1, xmm0, cs:__real@3d4ccccd
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm0, xmm1, xmm0
  }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetGamma
==============
*/
float R_DisplayMapping_GetGamma()
{
  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
    __debugbreak();
  _RAX = r_displayMappingHdrGamma;
  if ( g_dx.features.displayColorimetry != GFX_COLORIMETRY_BT2020_PQ )
    _RAX = r_displayMappingSdrGamma;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetHdrGamma
==============
*/
float R_DisplayMapping_GetHdrGamma()
{
  _RAX = r_displayMappingHdrGamma;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetHdrMaxLum
==============
*/
float R_DisplayMapping_GetHdrMaxLum()
{
  _RAX = r_displayMappingHdrMaxLum;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetHdrMinLum
==============
*/
float R_DisplayMapping_GetHdrMinLum()
{
  _RAX = r_displayMappingHdrMinLum;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetMaxLum
==============
*/
float R_DisplayMapping_GetMaxLum()
{
  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
    __debugbreak();
  if ( g_dx.features.displayColorimetry == GFX_COLORIMETRY_BT2020_PQ )
  {
    _RAX = r_displayMappingHdrMaxLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  else if ( r_displayMappingSdrUseBlacklevel->current.enabled )
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  else
  {
    _RAX = r_displayMappingSdrMaxLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetMinLum
==============
*/

float __fastcall R_DisplayMapping_GetMinLum(double _XMM0_8)
{
  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
    __debugbreak();
  if ( g_dx.features.displayColorimetry == GFX_COLORIMETRY_BT2020_PQ )
  {
    _RAX = r_displayMappingHdrMinLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  else if ( r_displayMappingSdrUseBlacklevel->current.enabled )
  {
    if ( r_blacklevelDisable->current.enabled )
    {
      __asm { vxorps  xmm0, xmm0, xmm0 }
    }
    else
    {
      _RAX = r_blacklevel;
      __asm { vmovss  xmm0, dword ptr [rax+28h] }
    }
  }
  else
  {
    _RAX = r_displayMappingSdrMinLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetSdrGamma
==============
*/
float R_DisplayMapping_GetSdrGamma()
{
  _RAX = r_displayMappingSdrGamma;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetSdrMaxLum
==============
*/
float R_DisplayMapping_GetSdrMaxLum()
{
  if ( r_displayMappingSdrUseBlacklevel->current.enabled )
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  else
  {
    _RAX = r_displayMappingSdrMaxLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
R_DisplayMapping_GetSdrMinLum
==============
*/

float __fastcall R_DisplayMapping_GetSdrMinLum(double _XMM0_8)
{
  if ( r_displayMappingSdrUseBlacklevel->current.enabled )
  {
    if ( r_blacklevelDisable->current.enabled )
    {
      __asm { vxorps  xmm0, xmm0, xmm0 }
    }
    else
    {
      _RAX = r_blacklevel;
      __asm { vmovss  xmm0, dword ptr [rax+28h] }
    }
  }
  else
  {
    _RAX = r_displayMappingSdrMinLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
R_GetDefaultHDRMappingParams
==============
*/
GfxDisplayMappingParams *R_GetDefaultHDRMappingParams(GfxDisplayMappingParams *result)
{
  GfxDisplayMappingParams *v1; 

  result->minLuminance = 0.0;
  v1 = result;
  result->maxLuminance = 0.80000001;
  result->gamma = 1.0;
  return v1;
}

/*
==============
R_GetDesiredDisplayColorimetry
==============
*/
__int64 R_GetDesiredDisplayColorimetry()
{
  if ( !g_dx.features.displayHDRCapable )
  {
    if ( !r_forceHDRCapable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 93, ASSERT_TYPE_ASSERT, "(r_forceHDRCapable)", (const char *)&queryFormat, "r_forceHDRCapable") )
      __debugbreak();
    if ( !r_forceHDRCapable->current.enabled )
      return r_colorimetrySdr->current.unsignedInt;
  }
  if ( !r_allowHDR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 87, ASSERT_TYPE_ASSERT, "(r_allowHDR)", (const char *)&queryFormat, "r_allowHDR") )
    __debugbreak();
  if ( r_allowHDR->current.enabled )
    return 3i64;
  else
    return r_colorimetrySdr->current.unsignedInt;
}

/*
==============
R_GetDisplayBlacklevel
==============
*/
float R_GetDisplayBlacklevel(bool apply)
{
  if ( !apply || r_blacklevelDisable->current.enabled )
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  else
  {
    _RAX = r_blacklevel;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
R_GetDisplayColorimetry
==============
*/
__int64 R_GetDisplayColorimetry()
{
  __int64 result; 

  result = (unsigned int)g_dx.features.displayColorimetry;
  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
      __debugbreak();
    return (unsigned int)g_dx.features.displayColorimetry;
  }
  return result;
}

/*
==============
R_GetDisplayHdrUiMaxLuminance
==============
*/
float R_GetDisplayHdrUiMaxLuminance()
{
  _RAX = r_hdrUIMaxLum;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  return *(float *)&_XMM0;
}

/*
==============
R_GetDisplayMappingParams
==============
*/

GfxDisplayMappingParams *__fastcall R_GetDisplayMappingParams(GfxDisplayMappingParams *result, double _XMM1_8)
{
  bool enabled; 
  float v19; 

  _RBX = result;
  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
    __debugbreak();
  if ( g_dx.features.displayColorimetry != GFX_COLORIMETRY_BT2020_PQ )
  {
    enabled = r_displayMappingSdrUseBlacklevel->current.enabled;
    if ( enabled )
    {
      __asm { vmovss  xmm0, cs:__real@3f800000 }
    }
    else
    {
      _RAX = r_displayMappingSdrMaxLum;
      __asm { vmovss  xmm0, dword ptr [rax+28h] }
    }
    __asm { vmovss  [rsp+48h+var_10], xmm0 }
    if ( enabled )
    {
      if ( r_blacklevelDisable->current.enabled )
      {
        __asm { vxorps  xmm1, xmm1, xmm1 }
LABEL_15:
        _RAX = r_displayMappingSdrGamma;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+28h]
          vunpcklps xmm0, xmm0, xmm1
        }
        goto LABEL_16;
      }
      _RAX = r_blacklevel;
    }
    else
    {
      _RAX = r_displayMappingSdrMinLum;
    }
    __asm { vmovss  xmm1, dword ptr [rax+28h] }
    goto LABEL_15;
  }
  _RAX = r_displayMappingHdrMinLum;
  __asm { vmovss  xmm2, dword ptr [rax+28h] }
  _RAX = r_displayMappingHdrMaxLum;
  __asm { vmovss  xmm0, dword ptr [rax+28h] }
  _RAX = r_displayMappingHdrGamma;
  __asm
  {
    vmovss  [rsp+48h+var_10], xmm0
    vmovss  xmm1, dword ptr [rax+28h]
    vunpcklps xmm0, xmm1, xmm2
  }
LABEL_16:
  __asm { vmovsd  qword ptr [rbx], xmm0 }
  _RBX->maxLuminance = v19;
  return _RBX;
}

/*
==============
R_GetFramebufferColorimetry
==============
*/
__int64 R_GetFramebufferColorimetry()
{
  __int64 result; 

  if ( g_dx.features.displayColorimetry >= GFX_COLORIMETRY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 31, ASSERT_TYPE_ASSERT, "(g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT)", (const char *)&queryFormat, "g_dx.features.displayColorimetry < GFX_COLORIMETRY_COUNT") )
    __debugbreak();
  result = 0i64;
  if ( g_dx.features.displayColorimetry != GFX_COLORIMETRY_BT709_BT709 )
    return (unsigned int)g_dx.features.displayColorimetry;
  return result;
}

/*
==============
R_GetHdrDisplayMappingParams
==============
*/
GfxDisplayMappingParams *R_GetHdrDisplayMappingParams(GfxDisplayMappingParams *result)
{
  const dvar_t *v1; 
  float value; 
  const dvar_t *v3; 
  float v4; 
  GfxDisplayMappingParams *v5; 

  v1 = r_displayMappingHdrMaxLum;
  LODWORD(result->minLuminance) = r_displayMappingHdrMinLum->current.integer;
  value = v1->current.value;
  v3 = r_displayMappingHdrGamma;
  result->maxLuminance = value;
  v4 = v3->current.value;
  v5 = result;
  result->gamma = v4;
  return v5;
}

/*
==============
R_GetSdrDefaultColorimetry
==============
*/
__int64 R_GetSdrDefaultColorimetry()
{
  return 1i64;
}

/*
==============
R_GetSdrDisplayColorimetry
==============
*/
__int64 R_GetSdrDisplayColorimetry()
{
  return r_colorimetrySdr->current.unsignedInt;
}

/*
==============
R_GetSdrDisplayMappingParams
==============
*/
GfxDisplayMappingParams *R_GetSdrDisplayMappingParams(GfxDisplayMappingParams *result)
{
  bool enabled; 
  const dvar_t *v7; 
  int integer; 
  GfxDisplayMappingParams *v9; 

  _RDX = result;
  enabled = r_displayMappingSdrUseBlacklevel->current.enabled;
  if ( enabled )
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  else
  {
    _RAX = r_displayMappingSdrMaxLum;
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
  }
  __asm { vmovss  dword ptr [rdx+8], xmm0 }
  if ( !enabled )
  {
    _RAX = r_displayMappingSdrMinLum;
    goto LABEL_9;
  }
  if ( !r_blacklevelDisable->current.enabled )
  {
    _RAX = r_blacklevel;
LABEL_9:
    __asm { vmovss  xmm0, dword ptr [rax+28h] }
    goto LABEL_10;
  }
  __asm { vxorps  xmm0, xmm0, xmm0 }
LABEL_10:
  v7 = r_displayMappingSdrGamma;
  __asm { vmovss  dword ptr [rdx+4], xmm0 }
  integer = v7->current.integer;
  v9 = _RDX;
  LODWORD(_RDX->gamma) = integer;
  return v9;
}

/*
==============
R_InitColorimetry
==============
*/
void R_InitColorimetry(void)
{
  if ( !g_dx.features.displayHDRCapable )
  {
    if ( !r_forceHDRCapable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 93, ASSERT_TYPE_ASSERT, "(r_forceHDRCapable)", (const char *)&queryFormat, "r_forceHDRCapable") )
      __debugbreak();
    if ( !r_forceHDRCapable->current.enabled )
      goto LABEL_11;
  }
  if ( !r_allowHDR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 87, ASSERT_TYPE_ASSERT, "(r_allowHDR)", (const char *)&queryFormat, "r_allowHDR") )
    __debugbreak();
  if ( r_allowHDR->current.enabled )
    g_dx.features.displayColorimetry = GFX_COLORIMETRY_BT2020_PQ;
  else
LABEL_11:
    g_dx.features.displayColorimetry = r_colorimetrySdr->current.integer;
}

/*
==============
R_IsColorimetryHDR
==============
*/
bool R_IsColorimetryHDR(const GfxColorimetry colorimetry)
{
  return colorimetry == GFX_COLORIMETRY_BT2020_PQ;
}

/*
==============
R_IsDisplayHDRCapable
==============
*/
bool R_IsDisplayHDRCapable()
{
  if ( g_dx.features.displayHDRCapable )
    return 1;
  if ( !r_forceHDRCapable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 93, ASSERT_TYPE_ASSERT, "(r_forceHDRCapable)", (const char *)&queryFormat, "r_forceHDRCapable") )
    __debugbreak();
  return r_forceHDRCapable->current.enabled;
}

/*
==============
R_IsHDRAllowed
==============
*/
__int64 R_IsHDRAllowed()
{
  const dvar_t *v0; 

  v0 = r_allowHDR;
  if ( !r_allowHDR )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 87, ASSERT_TYPE_ASSERT, "(r_allowHDR)", (const char *)&queryFormat, "r_allowHDR") )
      __debugbreak();
    v0 = r_allowHDR;
  }
  return v0->current.color[0];
}

/*
==============
R_ShouldForceHDRCapable
==============
*/
__int64 R_ShouldForceHDRCapable()
{
  const dvar_t *v0; 

  v0 = r_forceHDRCapable;
  if ( !r_forceHDRCapable )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 93, ASSERT_TYPE_ASSERT, "(r_forceHDRCapable)", (const char *)&queryFormat, "r_forceHDRCapable") )
      __debugbreak();
    v0 = r_forceHDRCapable;
  }
  return v0->current.color[0];
}

/*
==============
R_ShouldUseHDR
==============
*/
bool R_ShouldUseHDR()
{
  if ( !g_dx.features.displayHDRCapable )
  {
    if ( !r_forceHDRCapable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 93, ASSERT_TYPE_ASSERT, "(r_forceHDRCapable)", (const char *)&queryFormat, "r_forceHDRCapable") )
      __debugbreak();
    if ( !r_forceHDRCapable->current.enabled )
      return 0;
  }
  if ( !r_allowHDR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_colorimetry.cpp", 87, ASSERT_TYPE_ASSERT, "(r_allowHDR)", (const char *)&queryFormat, "r_allowHDR") )
    __debugbreak();
  return r_allowHDR->current.enabled;
}

