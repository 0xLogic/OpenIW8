/*
==============
CG_ProcessReflectionVolumeUnregisterCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeUnregisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeUnregisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessCameraCommand
==============
*/

void __fastcall CG_ProcessCameraCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessCameraCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessLocatorReadCommand
==============
*/

void __fastcall CG_ProcessLocatorReadCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorReadCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_FreeRadiantReflectionVolume
==============
*/

void __fastcall CG_FreeRadiantReflectionVolume(RadiantRemoteReflectionVolume *radiantReflectionVolume)
{
  ?CG_FreeRadiantReflectionVolume@@YAXPEAURadiantRemoteReflectionVolume@@@Z(radiantReflectionVolume);
}

/*
==============
BG_RadiantLiveEnable
==============
*/

void __fastcall BG_RadiantLiveEnable(bool enable)
{
  ?BG_RadiantLiveEnable@@YAX_N@Z(enable);
}

/*
==============
CG_FindRadiantReflectionVolume
==============
*/

RadiantRemoteReflectionVolume *__fastcall CG_FindRadiantReflectionVolume(const char *livePath)
{
  return ?CG_FindRadiantReflectionVolume@@YAPEAURadiantRemoteReflectionVolume@@PEBD@Z(livePath);
}

/*
==============
CG_GetRadiantSyncActive
==============
*/

unsigned int __fastcall CG_GetRadiantSyncActive()
{
  return ?CG_GetRadiantSyncActive@@YAIXZ();
}

/*
==============
CG_ProcessReflectionVolumeCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessReflectionVolumeCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_SetRadiantStatusOff
==============
*/

void CG_SetRadiantStatusOff(void)
{
  ?CG_SetRadiantStatusOff@@YAXXZ();
}

/*
==============
CG_ProcessLocatorUpdateCommand
==============
*/

void __fastcall CG_ProcessLocatorUpdateCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorUpdateCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_IsRadiantSyncAny
==============
*/

bool __fastcall CG_IsRadiantSyncAny()
{
  return ?CG_IsRadiantSyncAny@@YA_NXZ();
}

/*
==============
CG_IsRadiantSync
==============
*/

bool __fastcall CG_IsRadiantSync(ERadiantSyncType syncType)
{
  return ?CG_IsRadiantSync@@YA_NW4ERadiantSyncType@@@Z(syncType);
}

/*
==============
CG_ProcessSyncTypeStatusCommand
==============
*/

void __fastcall CG_ProcessSyncTypeStatusCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessSyncTypeStatusCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessReflectionVolumeDeleteCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeDeleteCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeDeleteCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ShowWorldReflectionVolume
==============
*/

void __fastcall CG_ShowWorldReflectionVolume(const char *livePath, bool show)
{
  ?CG_ShowWorldReflectionVolume@@YAXPEBD_N@Z(livePath, show);
}

/*
==============
CG_ProcessVolumetricRegisterCommand
==============
*/

void __fastcall CG_ProcessVolumetricRegisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricRegisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
R_DrawRadiantLiveConnectionStatus
==============
*/

void R_DrawRadiantLiveConnectionStatus(void)
{
  ?R_DrawRadiantLiveConnectionStatus@@YAXXZ();
}

/*
==============
CG_ProcessReflectionVolumeUpdateCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeUpdateCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeUpdateCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessDecalVolumeDeleteCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeDeleteCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeDeleteCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricDeleteCommand
==============
*/

void __fastcall CG_ProcessVolumetricDeleteCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricDeleteCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
R_RadiantRemoteGetGfxReflectionProbeInstance
==============
*/

bool __fastcall R_RadiantRemoteGetGfxReflectionProbeInstance(const char *livePath, GfxReflectionProbeInstance *outReflectionProbeInstance)
{
  return ?R_RadiantRemoteGetGfxReflectionProbeInstance@@YA_NPEBDPEAUGfxReflectionProbeInstance@@@Z(livePath, outReflectionProbeInstance);
}

/*
==============
CG_ShowWorldVolumetric
==============
*/

void __fastcall CG_ShowWorldVolumetric(const char *livePath, bool show)
{
  ?CG_ShowWorldVolumetric@@YAXPEBD_N@Z(livePath, show);
}

/*
==============
CG_GetDecalVolume
==============
*/

bool __fastcall CG_GetDecalVolume(const SpawnVar *spawnVar, unsigned int *outUid, unsigned int *outIndex, bool *outIsDynamic)
{
  return ?CG_GetDecalVolume@@YA_NAEBUSpawnVar@@PEAI1PEA_N@Z(spawnVar, outUid, outIndex, outIsDynamic);
}

/*
==============
BG_IsRadiantLiveFlowing
==============
*/

bool __fastcall BG_IsRadiantLiveFlowing()
{
  return ?BG_IsRadiantLiveFlowing@@YA_NXZ();
}

/*
==============
CG_ProcessDecalVolumeCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessDecalVolumeCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessDecalVolumeRegisterCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeRegisterCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeRegisterCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessRadiantCmds
==============
*/

void __fastcall CG_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  ?CG_ProcessRadiantCmds@@YAXW4RadiantLiveGameMode@@@Z(inMode);
}

/*
==============
CG_AllocRadiantReflectionVolume
==============
*/

RadiantRemoteReflectionVolume *__fastcall CG_AllocRadiantReflectionVolume()
{
  return ?CG_AllocRadiantReflectionVolume@@YAPEAURadiantRemoteReflectionVolume@@XZ();
}

/*
==============
CG_AddRadiantCmd
==============
*/

bool __fastcall CG_AddRadiantCmd(const char *command)
{
  return ?CG_AddRadiantCmd@@YA_NPEBD@Z(command);
}

/*
==============
CG_IsRadiantConnected
==============
*/

bool __fastcall CG_IsRadiantConnected()
{
  return ?CG_IsRadiantConnected@@YA_NXZ();
}

/*
==============
CG_ProcessReflectionVolumeSetSelectionCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeSetSelectionCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeSetSelectionCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricCommand
==============
*/

void __fastcall CG_ProcessVolumetricCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessVolumetricCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_SetRadiantStatus
==============
*/

void __fastcall CG_SetRadiantStatus(unsigned int inMask)
{
  ?CG_SetRadiantStatus@@YAXI@Z(inMask);
}

/*
==============
CG_FreeRadiantVolumetric
==============
*/

void __fastcall CG_FreeRadiantVolumetric(RadiantRemoteVolumetric *radiantVolumetric)
{
  ?CG_FreeRadiantVolumetric@@YAXPEAURadiantRemoteVolumetric@@@Z(radiantVolumetric);
}

/*
==============
CG_MakeReflectionProbeInstanceFeatherPositive
==============
*/

void __fastcall CG_MakeReflectionProbeInstanceFeatherPositive(GfxReflectionProbeInstance *reflectionProbeInstance)
{
  ?CG_MakeReflectionProbeInstanceFeatherPositive@@YAXPEAUGfxReflectionProbeInstance@@@Z(reflectionProbeInstance);
}

/*
==============
CG_ProcessReflectionVolumeRegisterCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeRegisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeRegisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessLocatorDeleteCommand
==============
*/

void __fastcall CG_ProcessLocatorDeleteCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorDeleteCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessLocatorCreateCommand
==============
*/

void __fastcall CG_ProcessLocatorCreateCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorCreateCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_DrawRadiantReflectionVolumes
==============
*/

void CG_DrawRadiantReflectionVolumes(void)
{
  ?CG_DrawRadiantReflectionVolumes@@YAXXZ();
}

/*
==============
BG_IsRadiantLiveEnabled
==============
*/

bool __fastcall BG_IsRadiantLiveEnabled()
{
  return ?BG_IsRadiantLiveEnabled@@YA_NXZ();
}

/*
==============
CG_ProcessExposureCommand
==============
*/

void __fastcall CG_ProcessExposureCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessExposureCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_AllocRadiantVolumetric
==============
*/

RadiantRemoteVolumetric *__fastcall CG_AllocRadiantVolumetric()
{
  return ?CG_AllocRadiantVolumetric@@YAPEAURadiantRemoteVolumetric@@XZ();
}

/*
==============
CG_ProcessVolumetricUpdateCommand
==============
*/

void __fastcall CG_ProcessVolumetricUpdateCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricUpdateCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_DrawRadiantVolumetrics
==============
*/

void CG_DrawRadiantVolumetrics(void)
{
  ?CG_DrawRadiantVolumetrics@@YAXXZ();
}

/*
==============
CG_ProcessDecalVolumeUpdateCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeUpdateCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeUpdateCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_GetRadiantStatus
==============
*/

unsigned int __fastcall CG_GetRadiantStatus()
{
  return ?CG_GetRadiantStatus@@YAIXZ();
}

/*
==============
CG_GetReflectionProbeIndexFromLivePath
==============
*/

unsigned int __fastcall CG_GetReflectionProbeIndexFromLivePath(const char *livePath)
{
  return ?CG_GetReflectionProbeIndexFromLivePath@@YAIPEBD@Z(livePath);
}

/*
==============
CG_ProcessVolumetricSetSelectionCommand
==============
*/

void __fastcall CG_ProcessVolumetricSetSelectionCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricSetSelectionCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricUnregisterCommand
==============
*/

void __fastcall CG_ProcessVolumetricUnregisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricUnregisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_GetDecalVolumeUid
==============
*/

unsigned int __fastcall CG_GetDecalVolumeUid(const SpawnVar *spawnVar)
{
  return ?CG_GetDecalVolumeUid@@YAIAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessDecalVolumeSetSelectionCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeSetSelectionCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeSetSelectionCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_FindRadiantVolumetric
==============
*/

RadiantRemoteVolumetric *__fastcall CG_FindRadiantVolumetric(const char *livePath)
{
  return ?CG_FindRadiantVolumetric@@YAPEAURadiantRemoteVolumetric@@PEBD@Z(livePath);
}

/*
==============
G_ProcessRadiantCmds
==============
*/

void __fastcall G_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  ?G_ProcessRadiantCmds@@YAXW4RadiantLiveGameMode@@@Z(inMode);
}

/*
==============
CG_ProcessCameraCommand
==============
*/
void CG_ProcessCameraCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  const char *PairValue; 
  const char *v5; 
  int v15; 
  int v16; 
  int v17; 
  int v18; 
  int v19; 
  int v20; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) )
  {
    spawnVar = commandData->spawnVar;
    PairValue = GetPairValue(spawnVar, "origin");
    v5 = GetPairValue(spawnVar, "angles");
    _RBX = CG_GetLocalClientGlobals(FirstActiveGameLocalClient);
    if ( _RBX )
    {
      if ( PairValue )
        j_sscanf(PairValue, "%f %f %f", &v18, &v19, &v20);
      if ( v5 )
        j_sscanf(v5, "%f %f %f", &v15, &v16, &v17);
      __asm
      {
        vmovss  xmm0, [rsp+68h+var_38]
        vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
        vmovss  xmm0, [rsp+68h+var_28]
        vmovss  [rsp+68h+var_38], xmm1
        vmovss  dword ptr [rbx+18048h], xmm0
        vmovss  xmm1, [rsp+68h+var_24]
        vmovss  dword ptr [rbx+1804Ch], xmm1
        vmovss  xmm0, [rsp+68h+var_20]
        vmovss  dword ptr [rbx+18050h], xmm0
        vmovss  xmm1, [rsp+68h+var_38]
        vmovss  dword ptr [rbx+18054h], xmm1
        vmovss  xmm0, [rsp+68h+var_34]
        vmovss  dword ptr [rbx+18058h], xmm0
        vmovss  xmm1, [rsp+68h+var_30]
        vmovss  dword ptr [rbx+1805Ch], xmm1
      }
      _RBX->radiantCamReceived = 1;
      _RBX->radiantCamInUse = 1;
    }
  }
}

/*
==============
CG_ProcessLocatorCreateCommand
==============
*/
void CG_ProcessLocatorCreateCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorReadCommand
==============
*/
void CG_ProcessLocatorReadCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorUpdateCommand
==============
*/
void CG_ProcessLocatorUpdateCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorDeleteCommand
==============
*/
void CG_ProcessLocatorDeleteCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessDecalVolumeCommand
==============
*/
void CG_ProcessDecalVolumeCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  const char *v4; 
  const char *PairValue; 
  unsigned int i; 
  __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  const char *v10; 
  unsigned int v11; 
  GfxDynamicDecalVolumeIndex DynamicIndex; 
  unsigned int v13; 
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex Dynamic; 
  bool outIsDynamic[4]; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( !CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) || !CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
    return;
  spawnVar = commandData->spawnVar;
  switch ( commandData->radiantCommand->type )
  {
    case RADIANT_COMMAND_DECAL_VOLUME_REGISTER:
      DecalVolumeUid = CG_GetDecalVolumeUid(commandData->spawnVar);
      if ( !R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, outIsDynamic) )
      {
        Dynamic = R_DecalVolumes_AllocateDynamic(DecalVolumeUid);
        if ( Dynamic == DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
          return;
        outIndex = (unsigned __int16)Dynamic;
        outIsDynamic[0] = 1;
      }
LABEL_19:
      CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
      CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic[0]);
      R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
      R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
      __asm { vmovss  xmm2, [rbp+57h+outEdgeFeatherZ]; zFeather }
      R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, *(float *)&_XMM2);
      R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
      R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic[0], &dst);
      return;
    case RADIANT_COMMAND_DECAL_VOLUME_UPDATE:
      v13 = CG_GetDecalVolumeUid(commandData->spawnVar);
      if ( !R_DecalVolumes_GetUID(v13, &outIndex, outIsDynamic) )
        return;
      goto LABEL_19;
    case RADIANT_COMMAND_DECAL_VOLUME_DELETE:
      v11 = CG_GetDecalVolumeUid(commandData->spawnVar);
      DynamicIndex = R_DecalVolumes_GetDynamicIndex(v11);
      if ( DynamicIndex != DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
        R_DecalVolumes_ReleaseDynamic(DynamicIndex);
      break;
    case RADIANT_COMMAND_DECAL_VOLUME_SET_SELECTION:
      R_DecalVolumes_ClearSelection();
      v4 = j_va("uid%u", 0i64);
      PairValue = GetPairValue(spawnVar, v4);
      for ( i = 1; PairValue; PairValue = GetPairValue(spawnVar, v10) )
      {
        v7 = -1i64;
        v8 = -1;
        do
          ++v7;
        while ( PairValue[v7] );
        for ( ; v7; --v7 )
        {
          v9 = *(unsigned __int8 *)PairValue++;
          v8 = (v8 >> 8) ^ g_crc32Table[v9 ^ (unsigned __int8)v8];
        }
        if ( R_DecalVolumes_GetUID(~v8, &outIndex, outIsDynamic) && !R_DecalVolumes_SetSelected(outIndex, outIsDynamic[0], 1) )
          break;
        v10 = j_va("uid%u", i++);
      }
      break;
  }
}

/*
==============
CG_ProcessExposureCommand
==============
*/
void CG_ProcessExposureCommand(RadiantCommandData *commandData)
{
  const char *PairValue; 

  PairValue = GetPairValue(commandData->spawnVar, "exposure");
  if ( PairValue )
  {
    __asm { vmovaps [rsp+38h+var_18], xmm6 }
    *(double *)&_XMM0 = strtod(PairValue, NULL);
    __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
    Dvar_SetBool_Internal(DVARBOOL_r_tonemapUseTweaks, 1);
    __asm { vmovaps xmm1, xmm6; value }
    Dvar_SetFloat_Internal(DVARFLT_r_tonemapExposure, *(float *)&_XMM1);
    __asm { vmovaps xmm6, [rsp+38h+var_18] }
  }
}

/*
==============
CG_ProcessSyncTypeStatusCommand
==============
*/
void CG_ProcessSyncTypeStatusCommand(RadiantCommandData *commandData)
{
  const char *PairValue; 
  __int16 v2; 
  __int16 v3; 
  int v4; 

  PairValue = GetPairValue(commandData->spawnVar, "mask");
  if ( PairValue )
  {
    v2 = strtol(PairValue, NULL, 10);
    v3 = v2 ^ cgRadiantLiveStatus;
    v4 = v2 & 0x7FF;
    cgRadiantLiveStatus = v4;
    if ( (v3 & 0x7FF) != 0 || !triggerCnt )
    {
      cgRadiantLiveProcessStatus = v4 | 0x800;
      Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      gRadiantLiveProcessStatus = cgRadiantLiveStatus | 0x800;
      Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      triggerCnt = 4;
    }
    else
    {
      --triggerCnt;
    }
  }
}

/*
==============
CG_ProcessReflectionVolumeCommand
==============
*/
void CG_ProcessReflectionVolumeCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  RadiantRemoteReflectionVolume *v4; 
  int v5; 
  const char *v6; 
  const char *j; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  const char *v9; 
  const char *v10; 
  RadiantRemoteReflectionVolume *v11; 
  RadiantRemoteReflectionVolume *v12; 
  const char *PairValue; 
  const char *v14; 
  int v15; 
  RadiantRemoteReflectionVolume *i; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( !CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) || !CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
    return;
  spawnVar = commandData->spawnVar;
  if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_REGISTER )
  {
    PairValue = GetPairValue(spawnVar, "livePath");
    v14 = PairValue;
    if ( PairValue )
    {
      if ( !CG_FindRadiantReflectionVolume(PairValue) )
      {
        v15 = 0;
        for ( i = s_radiantReflectionVolumes; i->active; ++i )
        {
          if ( (unsigned int)++v15 >= 0x80 )
          {
            Com_PrintWarning(14, "Radiant Live: Too many selected reflection volume entities (max is %i), %s will not be tracked.\n", 128i64, v14);
            return;
          }
        }
        memset_0(&i->selected, 0, 0xD7ui64);
        i->active = 1;
        Core_strcpy(i->livePath, 0x40ui64, v14);
        CG_ShowWorldReflectionVolume(v14, 0);
        CG_ProcessReflectionVolumeUpdateCommand(spawnVar);
      }
    }
    else
    {
      Com_PrintWarning(14, "Radiant Live: Reflection volume select command has no livePath KVP.\n");
    }
  }
  else
  {
    if ( commandData->radiantCommand->type != RADIANT_COMMAND_REFLECTION_VOLUME_UNREGISTER )
    {
      if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_UPDATE )
      {
        CG_ProcessReflectionVolumeUpdateCommand(commandData->spawnVar);
        return;
      }
      if ( commandData->radiantCommand->type != RADIANT_COMMAND_REFLECTION_VOLUME_DELETE )
      {
        if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_SET_SELECTION )
        {
          v4 = s_radiantReflectionVolumes;
          do
          {
            v4->selected = 0;
            ++v4;
          }
          while ( v4 < (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
          v5 = 0;
          v6 = j_va("livePath%d", 0i64);
          for ( j = GetPairValue(spawnVar, v6); j; j = GetPairValue(spawnVar, v9) )
          {
            RadiantReflectionVolume = CG_FindRadiantReflectionVolume(j);
            if ( RadiantReflectionVolume )
              RadiantReflectionVolume->selected = 1;
            v9 = j_va("livePath%d", (unsigned int)++v5);
          }
        }
        return;
      }
      v10 = GetPairValue(commandData->spawnVar, "livePath");
      if ( !v10 )
        return;
      goto LABEL_16;
    }
    v10 = GetPairValue(commandData->spawnVar, "livePath");
    if ( v10 )
    {
LABEL_16:
      v11 = CG_FindRadiantReflectionVolume(v10);
      if ( v11 )
      {
        CG_FreeRadiantReflectionVolume(v11);
        CG_ShowWorldReflectionVolume(v10, 1);
      }
      return;
    }
    v12 = s_radiantReflectionVolumes;
    do
    {
      if ( v12->active )
      {
        CG_FreeRadiantReflectionVolume(v12);
        CG_ShowWorldReflectionVolume(v12->livePath, 1);
      }
      ++v12;
    }
    while ( v12 != (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  }
}

/*
==============
CG_ProcessVolumetricCommand
==============
*/
void CG_ProcessVolumetricCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  RadiantRemoteVolumetric *v4; 
  int v5; 
  const char *v6; 
  const char *j; 
  RadiantRemoteVolumetric *v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  RadiantRemoteVolumetric *v12; 
  const char *v13; 
  const char *v14; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *v16; 
  const char *PairValue; 
  const char *v18; 
  int v19; 
  RadiantRemoteVolumetric *i; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) && CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
  {
    spawnVar = commandData->spawnVar;
    switch ( commandData->radiantCommand->type )
    {
      case RADIANT_COMMAND_VOLUMETRIC_REGISTER:
        PairValue = GetPairValue(spawnVar, "livePath");
        v18 = PairValue;
        if ( PairValue )
        {
          if ( !CG_FindRadiantVolumetric(PairValue) )
          {
            v19 = 0;
            for ( i = s_radiantVolumetrics; i->active; ++i )
            {
              if ( (unsigned int)++v19 >= 0x80 )
              {
                Com_PrintWarning(14, "Radiant Live: Too many selected volumetric entities (max is %i), %s will not be tracked.\n", 128i64, v18);
                return;
              }
            }
            memset_0(&i->selected, 0, 0x14Fui64);
            i->active = 1;
            Core_strcpy(i->livePath, 0x40ui64, v18);
            CG_ShowWorldVolumetric(v18, 0);
            CG_ProcessVolumetricUpdateCommand(spawnVar);
          }
        }
        else
        {
          Com_PrintWarning(14, "Radiant Live: Volumetric select command has no livePath KVP.\n");
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_UNREGISTER:
        v13 = GetPairValue(commandData->spawnVar, "livePath");
        v14 = v13;
        if ( v13 )
        {
          RadiantVolumetric = CG_FindRadiantVolumetric(v13);
          if ( RadiantVolumetric )
          {
            CG_FreeRadiantVolumetric(RadiantVolumetric);
            CG_ShowWorldVolumetric(v14, 1);
          }
        }
        else
        {
          v16 = s_radiantVolumetrics;
          do
          {
            if ( v16->active )
            {
              CG_FreeRadiantVolumetric(v16);
              CG_ShowWorldVolumetric(v16->livePath, 1);
            }
            ++v16;
          }
          while ( v16 != (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_UPDATE:
        CG_ProcessVolumetricUpdateCommand(commandData->spawnVar);
        break;
      case RADIANT_COMMAND_VOLUMETRIC_DELETE:
        v10 = GetPairValue(commandData->spawnVar, "livePath");
        v11 = v10;
        if ( v10 )
        {
          v12 = CG_FindRadiantVolumetric(v10);
          if ( v12 )
            CG_FreeRadiantVolumetric(v12);
          CG_ShowWorldVolumetric(v11, 0);
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_SET_SELECTION:
        v4 = s_radiantVolumetrics;
        do
        {
          v4->selected = 0;
          ++v4;
        }
        while ( v4 < (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
        v5 = 0;
        v6 = j_va("livePath%d", 0i64);
        for ( j = GetPairValue(spawnVar, v6); j; j = GetPairValue(spawnVar, v9) )
        {
          v8 = CG_FindRadiantVolumetric(j);
          if ( v8 )
            v8->selected = 1;
          v9 = j_va("livePath%d", (unsigned int)++v5);
        }
        break;
    }
  }
}

/*
==============
BG_IsRadiantLiveEnabled
==============
*/
_BOOL8 BG_IsRadiantLiveEnabled()
{
  return bgRadiantLiveEnabled;
}

/*
==============
BG_IsRadiantLiveFlowing
==============
*/
_BOOL8 BG_IsRadiantLiveFlowing()
{
  return cgRadiantLiveFlowing;
}

/*
==============
BG_RadiantLiveEnable
==============
*/
void BG_RadiantLiveEnable(bool enable)
{
  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  bgRadiantLiveEnabled = enable;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
}

/*
==============
CG_AddRadiantCmd
==============
*/
char CG_AddRadiantCmd(const char *command)
{
  const char *v2; 
  char v4; 
  char v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  const char *v9; 
  bool v10; 
  __int64 v11; 
  char v12; 
  __int64 v13; 
  char v14; 
  RadiantCommandType v15; 
  const char *v16; 
  CommandProcessorType v17; 
  const char *v18; 
  unsigned int *v19; 
  size_t v20; 
  char *v21; 
  __int64 v22; 
  RadiantCommandType v23; 
  unsigned int v24; 
  char s0[512]; 

  j_sscanf(command + 6, "%d", &v24);
  v2 = I_stristr(command + 6, " ") + 1;
  if ( v24 != 4 )
  {
    Com_PrintWarning(14, "Radiant Live Update: Radiant (%d) and game (%d) are out of sync.  Dropping command.\n", v24, 4i64);
    return 0;
  }
  if ( clientUIActives[0].connectionState != CA_ACTIVE || cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
    return 0;
  v4 = *v2;
  v5 = 0;
  v6 = 0i64;
  v7 = 0;
  if ( *v2 != 32 )
  {
    v8 = 0i64;
    do
    {
      if ( v4 == 46 )
      {
        v5 = 1;
      }
      else if ( !v5 && v8 < 511 )
      {
        ++v7;
        s0[v8++] = v4;
      }
      v4 = *++v2;
    }
    while ( v4 != 32 );
  }
  v9 = v2 + 1;
  v10 = cls.m_activeGameMapName[0] == 0;
  s0[v7] = 0;
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 295, ASSERT_TYPE_ASSERT, "(m_activeGameMapName[0])", "%s\n\tRequested mapname before it was set", "m_activeGameMapName[0]") )
    __debugbreak();
  if ( I_strcmp(s0, cls.m_activeGameMapName) )
  {
    v11 = 0x7FFFFFFFi64;
    do
    {
      v12 = s0[v6];
      v13 = v11;
      v14 = aRelaxed[v6++];
      --v11;
      if ( !v13 )
        break;
      if ( v12 != v14 )
      {
        Com_PrintWarning(14, "Radiant Live Update: maps do not match %s and %s\n", cls.m_activeGameMapName, s0);
        return 0;
      }
    }
    while ( v12 );
  }
  j_sscanf(v9, "%d", &v23);
  v15 = v23;
  if ( !s_isCommandBinary[v23] )
  {
    v16 = I_stristr(v9, " ");
    v15 = v23;
    v9 = v16 + 1;
  }
  if ( (unsigned int)v15 >= RADIANT_COMMAND_COUNT )
  {
    LODWORD(v22) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2236, ASSERT_TYPE_ASSERT, "(unsigned)( commandType ) < (unsigned)( RADIANT_COMMAND_COUNT )", "commandType doesn't index RADIANT_COMMAND_COUNT\n\t%i not in [0, %i)", v22, 28) )
      __debugbreak();
    v15 = v23;
  }
  v17 = s_commandProcessorType[v15];
  if ( (unsigned int)(v17 - 3) <= 1 )
    return 1;
  if ( (unsigned int)(v17 - 1) > 1 )
  {
LABEL_47:
    if ( (v17 & 0xFFFFFFFD) == 0 )
    {
      Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      if ( gCommandCount < 24 )
      {
        Core_strcpy_truncate(gCommands[gCommandCount].command, 0x8100ui64, v9);
        gCommands[gCommandCount++].type = v23;
        Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
        return 1;
      }
      Com_PrintWarning(15, "Radiant Live Update: Too many server commands\n");
      Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    }
    return 1;
  }
  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  if ( cgCommandCount >= 24 )
  {
    Com_PrintWarning(14, "Radiant Live Update: Too many client commands\n");
    goto LABEL_46;
  }
  if ( !s_isCommandBinary[v23] )
  {
    Core_strcpy_truncate(cgCommands[cgCommandCount].command, 0x8100ui64, v9);
LABEL_44:
    cgCommands[cgCommandCount++].type = v23;
LABEL_46:
    Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
    goto LABEL_47;
  }
  v18 = v9;
  if ( !*v9 )
  {
LABEL_35:
    v19 = (unsigned int *)(v18 + 1);
    v20 = *v19 + 4i64;
    v21 = cgCommands[cgCommandCount].command;
    if ( v21 )
    {
      if ( v20 > 0x8100 )
      {
        memset_0(v21, 0, 0x8100ui64);
        *_errno() = 34;
        _invalid_parameter_noinfo();
      }
      else
      {
        memcpy_0(v21, v19, v20);
      }
    }
    else
    {
      *_errno() = 22;
      _invalid_parameter_noinfo();
    }
    goto LABEL_44;
  }
  while ( ++v18 < v9 + 33024 )
  {
    if ( !*v18 )
      goto LABEL_35;
  }
  Com_PrintWarning(14, "Radiant Live Update: Binary message is invalid\n");
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  return 0;
}

/*
==============
CG_AllocRadiantReflectionVolume
==============
*/
RadiantRemoteReflectionVolume *CG_AllocRadiantReflectionVolume()
{
  int v0; 
  RadiantRemoteReflectionVolume *i; 
  RadiantRemoteReflectionVolume *result; 

  v0 = 0;
  for ( i = s_radiantReflectionVolumes; i->active; ++i )
  {
    if ( (unsigned int)++v0 >= 0x80 )
      return 0i64;
  }
  memset_0(&i->selected, 0, 0xD7ui64);
  result = i;
  i->active = 1;
  return result;
}

/*
==============
CG_AllocRadiantVolumetric
==============
*/
RadiantRemoteVolumetric *CG_AllocRadiantVolumetric()
{
  int v0; 
  RadiantRemoteVolumetric *i; 
  RadiantRemoteVolumetric *result; 

  v0 = 0;
  for ( i = s_radiantVolumetrics; i->active; ++i )
  {
    if ( (unsigned int)++v0 >= 0x80 )
      return 0i64;
  }
  memset_0(&i->selected, 0, 0x14Fui64);
  result = i;
  i->active = 1;
  return result;
}

/*
==============
CG_DrawRadiantReflectionVolumes
==============
*/
void CG_DrawRadiantReflectionVolumes()
{
  __int64 v3; 
  bool v7; 
  const vec4_t *v11; 
  Bounds bounds; 
  tmat33_t<vec3_t> rotation; 
  char v16; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  _RBX = &s_radiantReflectionVolumes[0].reflectionProbeInstance.volumeObb.halfSize.v[2];
  v3 = 128i64;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    if ( *((_BYTE *)_RBX - 168) )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbx-4]
        vmovss  xmm0, dword ptr [rbx-8]
      }
      v7 = *((_BYTE *)_RBX - 167) == 0;
      __asm
      {
        vmovss  dword ptr [rsp+98h+bounds.halfSize+4], xmm1
        vmovups ymm1, ymmword ptr [rbx-2Ch]
        vmovups ymmword ptr [rsp+98h+rotation], ymm1
        vmovss  xmm1, dword ptr [rbx-0Ch]
        vmovss  dword ptr [rsp+98h+bounds.halfSize], xmm0
        vmovss  xmm0, dword ptr [rbx]
      }
      v11 = &colorRed;
      if ( v7 )
        v11 = &colorWhite;
      __asm
      {
        vmovss  dword ptr [rsp+98h+rotation+20h], xmm1
        vmovss  dword ptr [rsp+98h+bounds.midPoint], xmm6
        vmovss  dword ptr [rsp+98h+bounds.midPoint+4], xmm6
        vmovss  dword ptr [rsp+98h+bounds.midPoint+8], xmm6
        vmovss  dword ptr [rsp+98h+bounds.halfSize+8], xmm0
      }
      CG_DebugBoxOriented((const vec3_t *)(_RBX - 14), &bounds, &rotation, v11, 1, 0);
      R_AddReflectionProbeInstanceToScene((const GfxReflectionProbeInstance *)(_RBX - 24));
    }
    _RBX += 54;
    --v3;
  }
  while ( v3 );
  _R11 = &v16;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
CG_DrawRadiantVolumetrics
==============
*/
void CG_DrawRadiantVolumetrics()
{
  __int64 v3; 
  bool v7; 
  const vec4_t *v11; 
  Bounds bounds; 
  tmat33_t<vec3_t> rotation; 
  char v16; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  _RBX = &s_radiantVolumetrics[0].volumetric.obb.halfSize.v[2];
  v3 = 128i64;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    if ( *((_BYTE *)_RBX - 140) )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbx-4]
        vmovss  xmm0, dword ptr [rbx-8]
      }
      v7 = *((_BYTE *)_RBX - 139) == 0;
      __asm
      {
        vmovss  dword ptr [rsp+98h+bounds.halfSize+4], xmm1
        vmovups ymm1, ymmword ptr [rbx-2Ch]
        vmovups ymmword ptr [rsp+98h+rotation], ymm1
        vmovss  xmm1, dword ptr [rbx-0Ch]
        vmovss  dword ptr [rsp+98h+bounds.halfSize], xmm0
        vmovss  xmm0, dword ptr [rbx]
      }
      v11 = &colorRed;
      if ( v7 )
        v11 = &colorWhite;
      __asm
      {
        vmovss  dword ptr [rsp+98h+rotation+20h], xmm1
        vmovss  dword ptr [rsp+98h+bounds.midPoint], xmm6
        vmovss  dword ptr [rsp+98h+bounds.midPoint+4], xmm6
        vmovss  dword ptr [rsp+98h+bounds.midPoint+8], xmm6
        vmovss  dword ptr [rsp+98h+bounds.halfSize+8], xmm0
      }
      CG_DebugBoxOriented((const vec3_t *)(_RBX - 14), &bounds, &rotation, v11, 1, 0);
      R_AddVolumetricToScene((const GfxVolumetric *)(_RBX - 17));
    }
    _RBX += 84;
    --v3;
  }
  while ( v3 );
  _R11 = &v16;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
CG_FindRadiantReflectionVolume
==============
*/
RadiantRemoteReflectionVolume *CG_FindRadiantReflectionVolume(const char *livePath)
{
  RadiantRemoteReflectionVolume *v2; 
  unsigned int v3; 
  __int64 v4; 
  const char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v2 = s_radiantReflectionVolumes;
  v3 = 0;
  while ( !v2->active )
  {
LABEL_13:
    ++v3;
    ++v2;
    if ( v3 >= 0x80 )
      return 0i64;
  }
  v4 = 0x7FFFFFFFi64;
  v5 = livePath;
  if ( v2 == (RadiantRemoteReflectionVolume *)-2i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  do
  {
    v6 = v5[v2->livePath - livePath];
    v7 = v4;
    v8 = *v5++;
    --v4;
    if ( !v7 )
      break;
    if ( v6 != v8 )
      goto LABEL_13;
  }
  while ( v6 );
  return v2;
}

/*
==============
CG_FindRadiantVolumetric
==============
*/
RadiantRemoteVolumetric *CG_FindRadiantVolumetric(const char *livePath)
{
  RadiantRemoteVolumetric *v2; 
  unsigned int v3; 
  __int64 v4; 
  const char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v2 = s_radiantVolumetrics;
  v3 = 0;
  while ( !v2->active )
  {
LABEL_13:
    ++v3;
    ++v2;
    if ( v3 >= 0x80 )
      return 0i64;
  }
  v4 = 0x7FFFFFFFi64;
  v5 = livePath;
  if ( v2 == (RadiantRemoteVolumetric *)-2i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  do
  {
    v6 = v5[v2->livePath - livePath];
    v7 = v4;
    v8 = *v5++;
    --v4;
    if ( !v7 )
      break;
    if ( v6 != v8 )
      goto LABEL_13;
  }
  while ( v6 );
  return v2;
}

/*
==============
CG_FreeRadiantReflectionVolume
==============
*/
void CG_FreeRadiantReflectionVolume(RadiantRemoteReflectionVolume *radiantReflectionVolume)
{
  if ( !radiantReflectionVolume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1324, ASSERT_TYPE_ASSERT, "(radiantReflectionVolume)", (const char *)&queryFormat, "radiantReflectionVolume") )
    __debugbreak();
  if ( !radiantReflectionVolume->active && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1325, ASSERT_TYPE_ASSERT, "(radiantReflectionVolume->active)", (const char *)&queryFormat, "radiantReflectionVolume->active") )
    __debugbreak();
  radiantReflectionVolume->active = 0;
}

/*
==============
CG_FreeRadiantVolumetric
==============
*/
void CG_FreeRadiantVolumetric(RadiantRemoteVolumetric *radiantVolumetric)
{
  if ( !radiantVolumetric && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 414, ASSERT_TYPE_ASSERT, "(radiantVolumetric)", (const char *)&queryFormat, "radiantVolumetric") )
    __debugbreak();
  if ( !radiantVolumetric->active && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 415, ASSERT_TYPE_ASSERT, "(radiantVolumetric->active)", (const char *)&queryFormat, "radiantVolumetric->active") )
    __debugbreak();
  radiantVolumetric->active = 0;
}

/*
==============
CG_GetDecalVolume
==============
*/
bool CG_GetDecalVolume(const SpawnVar *spawnVar, unsigned int *outUid, unsigned int *outIndex, bool *outIsDynamic)
{
  unsigned int DecalVolumeUid; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( outUid )
    *outUid = DecalVolumeUid;
  return R_DecalVolumes_GetUID(DecalVolumeUid, outIndex, outIsDynamic);
}

/*
==============
CG_GetDecalVolumeUid
==============
*/
__int64 CG_GetDecalVolumeUid(const SpawnVar *spawnVar)
{
  const char *PairValue; 
  checksum128_t checksumOut; 

  PairValue = GetPairValue(spawnVar, "uid");
  if ( !PairValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1007, ASSERT_TYPE_ASSERT, "(uid_string)", (const char *)&queryFormat, "uid_string") )
    __debugbreak();
  Core_StringToChecksum(PairValue, &checksumOut);
  return checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527) ^ (((checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527)) << 6) + (checksumOut.hash[2] ^ ((checksumOut.hash[2] >> 2) + checksumOut.hash[3] + (checksumOut.hash[2] << 6) - 1640531527)) + ((checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527)) >> 2) - 1640531527);
}

/*
==============
CG_GetRadiantStatus
==============
*/
__int64 CG_GetRadiantStatus()
{
  return cgRadiantLiveStatus;
}

/*
==============
CG_GetRadiantSyncActive
==============
*/
__int64 CG_GetRadiantSyncActive()
{
  return cgRadiantLiveStatus & 0x3F;
}

/*
==============
CG_GetReflectionProbeIndexFromLivePath
==============
*/
__int64 CG_GetReflectionProbeIndexFromLivePath(const char *livePath)
{
  GfxWorld *world; 
  __int64 v2; 
  char *v4; 
  __int64 v5; 
  const char *v6; 
  char v7; 
  __int64 v8; 
  char v9; 

  world = rgp.world;
  v2 = 0i64;
  if ( !rgp.world->draw.reflectionProbeData.reflectionProbeCount )
    return 0i64;
  while ( 1 )
  {
    v4 = world->draw.reflectionProbeData.reflectionProbes[v2].livePath;
    if ( v4 )
      break;
LABEL_11:
    v2 = (unsigned int)(v2 + 1);
    if ( (unsigned int)v2 >= world->draw.reflectionProbeData.reflectionProbeCount )
      return 0i64;
  }
  v5 = 0x7FFFFFFFi64;
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v6 = (const char *)(livePath - v4);
  do
  {
    v7 = v4[(_QWORD)v6];
    v8 = v5;
    v9 = *v4++;
    --v5;
    if ( !v8 )
      break;
    if ( v7 != v9 )
      goto LABEL_11;
  }
  while ( v7 );
  return (unsigned int)v2;
}

/*
==============
CG_IsRadiantConnected
==============
*/
bool CG_IsRadiantConnected()
{
  return rdbgClientIsConnected(RDBG_CLIENTTYPE_RADIANT);
}

/*
==============
CG_IsRadiantSync
==============
*/
bool CG_IsRadiantSync(ERadiantSyncType syncType)
{
  return ((1 << syncType) & cgRadiantLiveStatus) == 1 << syncType;
}

/*
==============
CG_IsRadiantSyncAny
==============
*/
bool CG_IsRadiantSyncAny()
{
  return (cgRadiantLiveStatus & 0x3F) != 0;
}

/*
==============
CG_MakeReflectionProbeInstanceFeatherPositive
==============
*/
void CG_MakeReflectionProbeInstanceFeatherPositive(GfxReflectionProbeInstance *reflectionProbeInstance)
{
  unsigned int v7; 
  bool v11; 
  char v24; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovss  xmm7, cs:__real@3dcccccd
    vmovaps xmmword ptr [rax-38h], xmm8
  }
  v7 = 0;
  __asm { vmovaps xmmword ptr [rax-48h], xmm9 }
  _RSI = reflectionProbeInstance;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovss  xmm8, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vxorps  xmm9, xmm9, xmm9
  }
  v11 = 1;
  do
  {
    _RDI = (int)v7;
    __asm { vcomiss xmm9, dword ptr [rsi+rdi*4+68h] }
    if ( !v11 )
    {
      __asm
      {
        vmovss  xmm6, dword ptr [rsi+rdi*4+68h]
        vandps  xmm6, xmm6, xmm8
        vmovss  dword ptr [rsi+rdi*4+68h], xmm6
        vmovss  xmm6, dword ptr [rsi+rdi*4+68h]
        vaddss  xmm0, xmm6, dword ptr [rsi+rdi*4+58h]
        vmovss  dword ptr [rsi+rdi*4+58h], xmm0
      }
    }
    __asm { vcomiss xmm7, dword ptr [rsi+rdi*4+68h] }
    v11 = ++v7 <= 3;
  }
  while ( v7 < 3 );
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
  _R11 = &v24;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
CG_ProcessDecalVolumeDeleteCommand
==============
*/
void CG_ProcessDecalVolumeDeleteCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex DynamicIndex; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  DynamicIndex = R_DecalVolumes_GetDynamicIndex(DecalVolumeUid);
  if ( DynamicIndex != DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
    R_DecalVolumes_ReleaseDynamic(DynamicIndex);
}

/*
==============
CG_ProcessDecalVolumeRegisterCommand
==============
*/
void CG_ProcessDecalVolumeRegisterCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex Dynamic; 
  bool outIsDynamic; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( !R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, &outIsDynamic) )
  {
    Dynamic = R_DecalVolumes_AllocateDynamic(DecalVolumeUid);
    if ( Dynamic == DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
      return;
    outIndex = (unsigned __int16)Dynamic;
    outIsDynamic = 1;
  }
  CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
  CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic);
  R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
  R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
  __asm { vmovss  xmm2, [rsp+108h+outEdgeFeatherZ]; zFeather }
  R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, *(float *)&_XMM2);
  R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
  R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic, &dst);
}

/*
==============
CG_ProcessDecalVolumeSetSelectionCommand
==============
*/
void CG_ProcessDecalVolumeSetSelectionCommand(const SpawnVar *spawnVar)
{
  const char *v2; 
  const char *PairValue; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  const char *v8; 
  bool outIsDynamic; 
  unsigned int outIndex; 

  R_DecalVolumes_ClearSelection();
  v2 = j_va("uid%u", 0i64);
  PairValue = GetPairValue(spawnVar, v2);
  for ( i = 1; PairValue; PairValue = GetPairValue(spawnVar, v8) )
  {
    v5 = -1i64;
    v6 = -1;
    do
      ++v5;
    while ( PairValue[v5] );
    for ( ; v5; --v5 )
    {
      v7 = *(unsigned __int8 *)PairValue++;
      v6 = (v6 >> 8) ^ g_crc32Table[v7 ^ (unsigned __int8)v6];
    }
    if ( R_DecalVolumes_GetUID(~v6, &outIndex, &outIsDynamic) && !R_DecalVolumes_SetSelected(outIndex, outIsDynamic, 1) )
      break;
    v8 = j_va("uid%u", i++);
  }
}

/*
==============
CG_ProcessDecalVolumeUpdateCommand
==============
*/
void CG_ProcessDecalVolumeUpdateCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  bool outIsDynamic; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, &outIsDynamic) )
  {
    CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
    CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic);
    R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
    R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
    __asm { vmovss  xmm2, [rsp+108h+outEdgeFeatherZ]; zFeather }
    R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, *(float *)&_XMM2);
    R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
    R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic, &dst);
  }
}

/*
==============
CG_ProcessRadiantCmd
==============
*/
void CG_ProcessRadiantCmd(RadiantCommand *command)
{
  unsigned __int64 v2; 
  void *v3; 
  __int64 type; 
  RadiantCommandData v6; 
  SpawnVar spawnVar; 

  if ( s_isCommandBinary[command->type] )
  {
    if ( command->command[1] == 123 )
    {
      v2 = *(unsigned int *)&command->command[2];
      v3 = operator new[](v2);
      memcpy_0(v3, &command->command[6], (unsigned int)v2);
      if ( command->command[v2 + 6] != 125 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1984, ASSERT_TYPE_ASSERT, "(*curr == '}')", (const char *)&queryFormat, "*curr == '}'") )
        __debugbreak();
    }
  }
  else
  {
    Com_BeginParseSession("RadiantCmd");
    ParseRadiantSpawnVars(command->command, &spawnVar);
    Com_EndParseSession();
  }
  v6.radiantCommand = command;
  v6.spawnVar = &spawnVar;
  __asm { vmovups xmm0, [rsp+2468h+var_2438] }
  type = command->type;
  __asm { vmovdqa [rsp+2468h+var_2438], xmm0 }
  ((void (__fastcall *)(RadiantCommandData *))g_radiantCommandTable[type])(&v6);
}

/*
==============
CG_ProcessRadiantCmds
==============
*/
void CG_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  unsigned int TimeAsSeconds; 
  unsigned int v4; 
  unsigned int v5; 
  volatile int i; 
  bool v7; 
  __int64 v8; 
  __int64 v10; 
  bool v14; 
  const vec4_t *v18; 
  const vec4_t *v25; 
  char v27; 
  Bounds bounds; 
  Bounds v29; 
  tmat33_t<vec3_t> rotation; 
  tmat33_t<vec3_t> v31; 

  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  if ( bgRadiantLiveEnabled )
  {
    __asm { vmovaps [rsp+0F0h+var_30], xmm6 }
    TimeAsSeconds = Sys_GetTimeAsSeconds();
    v4 = lastSec;
    v5 = TimeAsSeconds;
    if ( !lastSec )
      v4 = TimeAsSeconds;
    lastSec = v4;
    if ( cgCommandCount )
    {
      Stream_ImageRecord_Disable("radiant_live_cmd");
      for ( i = 0; i < cgCommandCount; ++i )
        CG_ProcessRadiantCmd(&cgCommands[i]);
      cgRadiantLiveFlowing = 1;
      lastSec = v5;
    }
    else if ( (cgRadiantLiveStatus & 0x3F) != 0 )
    {
      v7 = cgRadiantLiveFlowing;
      if ( TimeAsSeconds > lastSec + 2 )
        v7 = 0;
      cgRadiantLiveFlowing = v7;
    }
    v8 = 128i64;
    _RBX = &s_radiantVolumetrics[0].volumetric.obb.halfSize.v[2];
    v10 = 128i64;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    do
    {
      if ( *((_BYTE *)_RBX - 140) )
      {
        __asm
        {
          vmovss  xmm1, dword ptr [rbx-4]
          vmovss  xmm0, dword ptr [rbx-8]
        }
        v14 = *((_BYTE *)_RBX - 139) == 0;
        __asm
        {
          vmovss  dword ptr [rbp+57h+bounds.halfSize+4], xmm1
          vmovups ymm1, ymmword ptr [rbx-2Ch]
          vmovups ymmword ptr [rbp+57h+rotation], ymm1
          vmovss  xmm1, dword ptr [rbx-0Ch]
          vmovss  dword ptr [rbp+57h+bounds.halfSize], xmm0
          vmovss  xmm0, dword ptr [rbx]
        }
        v18 = &colorRed;
        if ( v14 )
          v18 = &colorWhite;
        __asm
        {
          vmovss  dword ptr [rbp+57h+rotation+20h], xmm1
          vmovss  dword ptr [rbp+57h+bounds.midPoint], xmm6
          vmovss  dword ptr [rbp+57h+bounds.midPoint+4], xmm6
          vmovss  dword ptr [rbp+57h+bounds.midPoint+8], xmm6
          vmovss  dword ptr [rbp+57h+bounds.halfSize+8], xmm0
        }
        CG_DebugBoxOriented((const vec3_t *)(_RBX - 14), &bounds, &rotation, v18, 1, 0);
        R_AddVolumetricToScene((const GfxVolumetric *)(_RBX - 17));
      }
      _RBX += 84;
      --v10;
    }
    while ( v10 );
    _RBX = &s_radiantReflectionVolumes[0].reflectionProbeInstance.volumeObb.halfSize.v[2];
    do
    {
      if ( *((_BYTE *)_RBX - 168) )
      {
        __asm
        {
          vmovss  xmm1, dword ptr [rbx-4]
          vmovss  xmm0, dword ptr [rbx-8]
        }
        v14 = *((_BYTE *)_RBX - 167) == 0;
        __asm
        {
          vmovss  dword ptr [rbp+57h+var_A8.halfSize+4], xmm1
          vmovups ymm1, ymmword ptr [rbx-2Ch]
          vmovups ymmword ptr [rbp+57h+var_68], ymm1
          vmovss  xmm1, dword ptr [rbx-0Ch]
          vmovss  dword ptr [rbp+57h+var_A8.halfSize], xmm0
          vmovss  xmm0, dword ptr [rbx]
        }
        v25 = &colorRed;
        if ( v14 )
          v25 = &colorWhite;
        __asm
        {
          vmovss  dword ptr [rbp+57h+var_68+20h], xmm1
          vmovss  dword ptr [rbp+57h+var_A8.midPoint], xmm6
          vmovss  dword ptr [rbp+57h+var_A8.midPoint+4], xmm6
          vmovss  dword ptr [rbp+57h+var_A8.midPoint+8], xmm6
          vmovss  dword ptr [rbp+57h+var_A8.halfSize+8], xmm0
        }
        CG_DebugBoxOriented((const vec3_t *)(_RBX - 14), &v29, &v31, v25, 1, 0);
        R_AddReflectionProbeInstanceToScene((const GfxReflectionProbeInstance *)(_RBX - 24));
      }
      _RBX += 54;
      --v8;
    }
    while ( v8 );
    __asm { vmovaps xmm6, [rsp+0F0h+var_30] }
    if ( cgRadiantLiveProcessStatus )
    {
      Stream_ImageRecord_Disable("radiant_live");
      v27 = cgRadiantLiveProcessStatus;
      if ( (cgRadiantLiveProcessStatus & 1) != 0 && (cgRadiantLiveStatus & 0x400) != 0 && inMode == RADIANT_GAMEMODE_SP )
      {
        Dvar_SetIntByName("LTNQQOMQSO", 2);
        v27 = cgRadiantLiveProcessStatus;
      }
      if ( (v27 & 2) != 0 )
      {
        Dvar_SetBoolByName("TLMMOPMSK", 1);
        Dvar_SetIntByName("PNSPTQSLN", 0);
      }
      cgRadiantLiveProcessStatus = 0;
    }
    CG_UpdateRadiantLightEffects();
  }
  cgCommandCount = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
}

/*
==============
CG_ProcessReflectionVolumeDeleteCommand
==============
*/
void CG_ProcessReflectionVolumeDeleteCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      CG_FreeRadiantReflectionVolume(RadiantReflectionVolume);
      CG_ShowWorldReflectionVolume(v2, 1);
    }
  }
}

/*
==============
CG_ProcessReflectionVolumeRegisterCommand
==============
*/
void CG_ProcessReflectionVolumeRegisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v3; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  RadiantRemoteReflectionVolume *i; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v3 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( !RadiantReflectionVolume )
    {
      for ( i = s_radiantReflectionVolumes; i->active; ++i )
      {
        LODWORD(RadiantReflectionVolume) = (_DWORD)RadiantReflectionVolume + 1;
        if ( (unsigned int)RadiantReflectionVolume >= 0x80 )
        {
          Com_PrintWarning(14, "Radiant Live: Too many selected reflection volume entities (max is %i), %s will not be tracked.\n", 128i64, v3);
          return;
        }
      }
      memset_0(&i->selected, 0, 0xD7ui64);
      i->active = 1;
      Core_strcpy(i->livePath, 0x40ui64, v3);
      CG_ShowWorldReflectionVolume(v3, 0);
      CG_ProcessReflectionVolumeUpdateCommand(spawnVar);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Reflection volume select command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessReflectionVolumeSetSelectionCommand
==============
*/
void CG_ProcessReflectionVolumeSetSelectionCommand(SpawnVar *spawnVar)
{
  RadiantRemoteReflectionVolume *v2; 
  int v3; 
  const char *v4; 
  const char *i; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  const char *v7; 

  v2 = s_radiantReflectionVolumes;
  do
  {
    v2->selected = 0;
    ++v2;
  }
  while ( v2 < (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  v3 = 0;
  v4 = j_va("livePath%d", 0i64);
  for ( i = GetPairValue(spawnVar, v4); i; i = GetPairValue(spawnVar, v7) )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(i);
    if ( RadiantReflectionVolume )
      RadiantReflectionVolume->selected = 1;
    v7 = j_va("livePath%d", (unsigned int)++v3);
  }
}

/*
==============
CG_ProcessReflectionVolumeUnregisterCommand
==============
*/
void CG_ProcessReflectionVolumeUnregisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  RadiantRemoteReflectionVolume *v4; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      CG_FreeRadiantReflectionVolume(RadiantReflectionVolume);
      CG_ShowWorldReflectionVolume(v2, 1);
    }
  }
  else
  {
    v4 = s_radiantReflectionVolumes;
    do
    {
      if ( v4->active )
      {
        CG_FreeRadiantReflectionVolume(v4);
        CG_ShowWorldReflectionVolume(v4->livePath, 1);
      }
      ++v4;
    }
    while ( v4 != (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  }
}

/*
==============
CG_ProcessReflectionVolumeUpdateCommand
==============
*/
void CG_ProcessReflectionVolumeUpdateCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  const char *v18; 
  const char *v22; 
  const char *v24; 
  const char *v25; 
  const char *v26; 
  const char *v30; 
  const char *v34; 
  unsigned int v35; 
  unsigned int reflectionProbeCount; 
  char *livePath; 
  __int64 v38; 
  signed __int64 v39; 
  char v40; 
  __int64 v41; 
  char v42; 
  int v43; 
  int v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 

  PairValue = GetPairValue(spawnVar, "livePath");
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      _RBX = &RadiantReflectionVolume->reflectionProbeInstance;
      memset_0(&RadiantReflectionVolume->reflectionProbeInstance, 0, sizeof(RadiantReflectionVolume->reflectionProbeInstance));
      _RBX->flags = 0;
      __asm
      {
        vmovss  xmm0, dword ptr cs:?quat_identity@@3Tvec4_t@@B; vec4_t const quat_identity
        vmovss  dword ptr [rbx+18h], xmm0
        vmovss  xmm1, dword ptr cs:?quat_identity@@3Tvec4_t@@B+4; vec4_t const quat_identity
        vmovss  dword ptr [rbx+1Ch], xmm1
        vmovss  xmm0, dword ptr cs:?quat_identity@@3Tvec4_t@@B+8; vec4_t const quat_identity
        vmovss  dword ptr [rbx+20h], xmm0
        vmovss  xmm1, dword ptr cs:?quat_identity@@3Tvec4_t@@B+0Ch; vec4_t const quat_identity
        vmovss  dword ptr [rbx+24h], xmm1
      }
      v9 = GetPairValue(spawnVar, "obb_origin");
      if ( v9 )
        j_sscanf(v9, "%f %f %f", &_RBX->volumeObb, &_RBX->volumeObb.center.y, &_RBX->volumeObb.center.z);
      v10 = GetPairValue(spawnVar, "obb_xAxis");
      if ( v10 )
        j_sscanf(v10, "%f %f %f", &_RBX->volumeObb.xAxis, &_RBX->volumeObb.xAxis.y, &_RBX->volumeObb.xAxis.z);
      v11 = GetPairValue(spawnVar, "obb_yAxis");
      if ( v11 )
        j_sscanf(v11, "%f %f %f", &_RBX->volumeObb.yAxis, &_RBX->volumeObb.yAxis.y, &_RBX->volumeObb.yAxis.z);
      v12 = GetPairValue(spawnVar, "obb_zAxis");
      if ( v12 )
        j_sscanf(v12, "%f %f %f", &_RBX->volumeObb.zAxis, &_RBX->volumeObb.zAxis.y, &_RBX->volumeObb.zAxis.z);
      v13 = GetPairValue(spawnVar, "obb_halfSize");
      if ( v13 )
        j_sscanf(v13, "%f %f %f", &_RBX->volumeObb.halfSize, &_RBX->volumeObb.halfSize.y, &_RBX->volumeObb.halfSize.z);
      *(_QWORD *)_RBX->expandProjectionNeg.v = 0i64;
      _RBX->expandProjectionNeg.v[2] = 0.0;
      v14 = GetPairValue(spawnVar, "expandProjectionNeg");
      if ( v14 && j_sscanf(v14, "%f %f %f", &v52, &v53, &v54) == 3 )
      {
        __asm
        {
          vmovss  xmm0, [rbp+arg_8]
          vmovss  xmm1, [rbp+arg_10]
          vmovss  dword ptr [rbx+74h], xmm0
          vmovss  xmm0, [rbp+arg_18]
          vmovss  dword ptr [rbx+7Ch], xmm0
          vmovss  dword ptr [rbx+78h], xmm1
        }
      }
      *(_QWORD *)_RBX->expandProjectionPos.v = 0i64;
      _RBX->expandProjectionPos.v[2] = 0.0;
      v18 = GetPairValue(spawnVar, "expandProjectionPos");
      if ( v18 && j_sscanf(v18, "%f %f %f", &v52, &v53, &v54) == 3 )
      {
        __asm
        {
          vmovss  xmm0, [rbp+arg_8]
          vmovss  xmm1, [rbp+arg_10]
          vmovss  dword ptr [rbx+80h], xmm0
          vmovss  xmm0, [rbp+arg_18]
          vmovss  dword ptr [rbx+88h], xmm0
          vmovss  dword ptr [rbx+84h], xmm1
        }
      }
      v22 = GetPairValue(spawnVar, "priority");
      _RBX->priority = -1.0;
      if ( v22 && j_sscanf(v22, "%f", &v43) == 1 )
      {
        __asm
        {
          vmovss  xmm0, [rbp+var_48]
          vmovss  dword ptr [rbx+64h], xmm0
        }
      }
      v24 = GetPairValue(spawnVar, "noParallax");
      if ( v24 && j_sscanf(v24, "%d", &v44) == 1 && v44 == 1 )
        _RBX->flags |= 1u;
      v25 = GetPairValue(spawnVar, "overrideLightgrid");
      if ( v25 && j_sscanf(v25, "%d", &v45) == 1 && v45 == 1 )
        _RBX->flags |= 4u;
      _RBX->feather.v[0] = 8.0;
      _RBX->feather.v[1] = 8.0;
      _RBX->feather.v[2] = 8.0;
      v26 = GetPairValue(spawnVar, "feather");
      if ( v26 && j_sscanf(v26, "%f %f %f", &v48, &v47, &v46) == 3 )
      {
        __asm
        {
          vmovss  xmm2, [rbp+var_3C]
          vmovss  xmm1, [rbp+var_38]
          vmovss  xmm0, [rbp+var_34]
          vmovss  dword ptr [rbx+68h], xmm0
          vmovss  dword ptr [rbx+6Ch], xmm1
          vmovss  dword ptr [rbx+70h], xmm2
        }
      }
      *(_QWORD *)_RBX->probePosition.v = 0i64;
      _RBX->probePosition.v[2] = 0.0;
      v30 = GetPairValue(spawnVar, "probePosition");
      if ( v30 )
      {
        if ( j_sscanf(v30, "%f %f %f", &v51, &v50, &v49) == 3 )
        {
          __asm
          {
            vmovss  xmm2, [rbp+var_30]
            vmovss  xmm1, [rbp+var_2C]
            vmovss  xmm0, [rbp+var_28]
            vmovss  dword ptr [rbx+8], xmm0
            vmovss  dword ptr [rbx+0Ch], xmm1
            vmovss  dword ptr [rbx+10h], xmm2
          }
        }
      }
      v34 = GetPairValue(spawnVar, "reflectionProbeLivePath");
      if ( v34 )
      {
        v35 = 0;
        reflectionProbeCount = rgp.world->draw.reflectionProbeData.reflectionProbeCount;
        if ( reflectionProbeCount )
        {
          while ( 1 )
          {
            livePath = rgp.world->draw.reflectionProbeData.reflectionProbes[v35].livePath;
            if ( livePath )
              break;
LABEL_45:
            if ( ++v35 >= reflectionProbeCount )
              goto LABEL_46;
          }
          v38 = 0x7FFFFFFFi64;
          v39 = v34 - livePath;
          do
          {
            v40 = livePath[v39];
            v41 = v38;
            v42 = *livePath++;
            --v38;
            if ( !v41 )
              break;
            if ( v40 != v42 )
              goto LABEL_45;
          }
          while ( v40 );
        }
        else
        {
LABEL_46:
          v35 = 0;
        }
        _RBX->probeImageIndex = truncate_cast<unsigned short,unsigned int>(v35);
      }
      CG_MakeReflectionProbeInstanceFeatherPositive(_RBX);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Reflection volume update command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessVolumetricDeleteCommand
==============
*/
void CG_ProcessVolumetricDeleteCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteVolumetric *RadiantVolumetric; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( RadiantVolumetric )
      CG_FreeRadiantVolumetric(RadiantVolumetric);
    CG_ShowWorldVolumetric(v2, 0);
  }
}

/*
==============
CG_ProcessVolumetricRegisterCommand
==============
*/
void CG_ProcessVolumetricRegisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v3; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *i; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v3 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( !RadiantVolumetric )
    {
      for ( i = s_radiantVolumetrics; i->active; ++i )
      {
        LODWORD(RadiantVolumetric) = (_DWORD)RadiantVolumetric + 1;
        if ( (unsigned int)RadiantVolumetric >= 0x80 )
        {
          Com_PrintWarning(14, "Radiant Live: Too many selected volumetric entities (max is %i), %s will not be tracked.\n", 128i64, v3);
          return;
        }
      }
      memset_0(&i->selected, 0, 0x14Fui64);
      i->active = 1;
      Core_strcpy(i->livePath, 0x40ui64, v3);
      CG_ShowWorldVolumetric(v3, 0);
      CG_ProcessVolumetricUpdateCommand(spawnVar);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Volumetric select command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessVolumetricSetSelectionCommand
==============
*/
void CG_ProcessVolumetricSetSelectionCommand(SpawnVar *spawnVar)
{
  RadiantRemoteVolumetric *v2; 
  int v3; 
  const char *v4; 
  const char *i; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  const char *v7; 

  v2 = s_radiantVolumetrics;
  do
  {
    v2->selected = 0;
    ++v2;
  }
  while ( v2 < (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
  v3 = 0;
  v4 = j_va("livePath%d", 0i64);
  for ( i = GetPairValue(spawnVar, v4); i; i = GetPairValue(spawnVar, v7) )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(i);
    if ( RadiantVolumetric )
      RadiantVolumetric->selected = 1;
    v7 = j_va("livePath%d", (unsigned int)++v3);
  }
}

/*
==============
CG_ProcessVolumetricUnregisterCommand
==============
*/
void CG_ProcessVolumetricUnregisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *v4; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( RadiantVolumetric )
    {
      CG_FreeRadiantVolumetric(RadiantVolumetric);
      CG_ShowWorldVolumetric(v2, 1);
    }
  }
  else
  {
    v4 = s_radiantVolumetrics;
    do
    {
      if ( v4->active )
      {
        CG_FreeRadiantVolumetric(v4);
        CG_ShowWorldVolumetric(v4->livePath, 1);
      }
      ++v4;
    }
    while ( v4 != (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
  }
}

/*
==============
CG_ProcessVolumetricUpdateCommand
==============
*/

void __fastcall CG_ProcessVolumetricUpdateCommand(SpawnVar *spawnVar, double _XMM1_8)
{
  SpawnVar *v5; 
  const char *PairValue; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v22; 
  int v23; 
  const char *v32; 
  const char *v38; 
  const char *v42; 
  int v43; 
  unsigned int flags; 
  unsigned int v45; 
  int v46; 
  const char *v47; 
  const char *v56; 
  int v57; 
  VolumetricMaskKey *v59; 
  unsigned int v60; 
  unsigned int v61; 
  const char **v62; 
  unsigned int v63; 
  const char *v64; 
  const char *v65; 
  XAssetHeader v66; 
  const char *v67; 
  const char *v68; 
  unsigned int i; 
  const char *name; 
  __int64 v71; 
  const char *v72; 
  signed __int64 v73; 
  int v74; 
  __int64 v75; 
  int v76; 
  int v77; 
  int v78; 
  const char *v79; 
  const char *v80; 
  unsigned int v81; 
  bool v82; 
  const char *v92; 
  const char *v93; 
  const char *v96; 
  const char *v97; 
  char *fmt; 
  char *fmta; 
  int v105; 
  int v106; 
  unsigned int v107; 
  int v108; 
  int v109; 
  int v110; 
  int v111; 
  SpawnVar *spawnVara; 
  int v113; 
  int v114; 
  int v115; 
  int v116; 
  int v117; 
  int v118; 
  int v119; 
  int v120; 
  int v121; 

  spawnVara = spawnVar;
  v5 = spawnVar;
  PairValue = GetPairValue(spawnVar, "livePath");
  if ( PairValue )
  {
    _RBX = CG_FindRadiantVolumetric(PairValue);
    if ( _RBX )
    {
      __asm
      {
        vmovaps [rsp+0E0h+var_30], xmm6
        vmovaps [rsp+0E0h+var_40], xmm7
        vmovaps [rsp+0E0h+var_50], xmm8
      }
      v8 = GetPairValue(v5, "obb_origin");
      if ( !v8 || j_sscanf(v8, "%f %f %f", &_RBX->volumetric.obb, &_RBX->volumetric.obb.center.y, &_RBX->volumetric.obb.center.z) != 3 )
        Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete origin.\n");
      v9 = GetPairValue(v5, "obb_xAxis");
      if ( !v9 || j_sscanf(v9, "%f %f %f", &_RBX->volumetric.obb.xAxis, &_RBX->volumetric.obb.xAxis.y, &_RBX->volumetric.obb.xAxis.z) != 3 )
        Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete xAxis.\n");
      v10 = GetPairValue(v5, "obb_yAxis");
      if ( !v10 || j_sscanf(v10, "%f %f %f", &_RBX->volumetric.obb.yAxis, &_RBX->volumetric.obb.yAxis.y, &_RBX->volumetric.obb.yAxis.z) != 3 )
        Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete yAxis.\n");
      v11 = GetPairValue(v5, "obb_zAxis");
      if ( !v11 || j_sscanf(v11, "%f %f %f", &_RBX->volumetric.obb.zAxis, &_RBX->volumetric.obb.zAxis.y, &_RBX->volumetric.obb.zAxis.z) != 3 )
        Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete zAxis.\n");
      v12 = GetPairValue(v5, "obb_halfSize");
      if ( !v12 || j_sscanf(v12, "%f %f %f", &_RBX->volumetric.obb.halfSize, &_RBX->volumetric.obb.halfSize.y, &_RBX->volumetric.obb.halfSize.z) != 3 )
        Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete halfSize.\n");
      v13 = GetPairValue(v5, "density");
      if ( v13 && j_sscanf(v13, "%f", &v108) == 1 )
      {
        __asm { vmovss  xmm0, [rbp+57h+var_A4] }
      }
      else
      {
        __asm
        {
          vmovsd  xmm2, cs:__real@3fb99999a0000000
          vmovq   r8, xmm2
        }
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing density, will use default: %.2f\n", _R8);
        __asm
        {
          vmovss  xmm0, cs:__real@3dcccccd
          vmovss  [rbp+57h+var_A4], xmm0
        }
      }
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vmulss  xmm0, xmm0, cs:__real@3c23d70a; val
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
        vxorps  xmm7, xmm7, xmm7
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rbx+9Ch], xmm0 }
      v22 = GetPairValue(v5, "falloff");
      if ( v22 && (v23 = j_sscanf(v22, "%f", &v105), v23 == 1) )
      {
        __asm
        {
          vmovss  xmm3, [rbp+57h+var_B0]
          vcomiss xmm3, xmm7
        }
        Com_PrintWarning(14, "Radiant Live: Volumetric has zero or negative falloff, using default, but this will fail map compile!.\n");
      }
      else
      {
        __asm
        {
          vmovsd  xmm2, cs:__real@4034000000000000
          vmovq   r8, xmm2
        }
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing falloff, will use default: %.2f.\n", _R8);
      }
      __asm
      {
        vmovss  xmm3, cs:__real@41a00000
        vmovss  [rbp+57h+var_B0], xmm3
        vmovss  xmm0, dword ptr [rbx+88h]
        vminss  xmm1, xmm0, dword ptr [rbx+84h]
        vminss  xmm2, xmm1, dword ptr [rbx+8Ch]
        vminss  xmm3, xmm2, xmm3
        vmovss  dword ptr [rbx+0A0h], xmm3
      }
      v32 = GetPairValue(v5, "height_fade");
      if ( v32 && j_sscanf(v32, "%f", &v106) == 1 )
      {
        __asm
        {
          vmovss  xmm0, [rbp+57h+var_AC]
          vcomiss xmm0, xmm7
        }
      }
      else
      {
        __asm
        {
          vxorpd  xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing height_fade, will use default: %.2f.\n", _R8);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0; val
          vmovss  [rbp+57h+var_AC], xmm0
        }
      }
      __asm
      {
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rbx+0A4h], xmm0 }
      v38 = GetPairValue(v5, "anisotropy");
      if ( v38 && j_sscanf(v38, "%f", &v109) == 1 )
      {
        __asm { vmovss  xmm0, [rbp+57h+var_A0] }
      }
      else
      {
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing anisotropy, will be disabled.\n");
        __asm
        {
          vxorps  xmm0, xmm0, xmm0; val
          vmovss  [rbp+57h+var_A0], xmm0
        }
      }
      __asm
      {
        vmovss  xmm1, cs:__real@bf800000; min
        vmovaps xmm2, xmm6; max
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rbx+0A8h], xmm0 }
      v42 = GetPairValue(v5, "anisotropy_enabled");
      if ( v42 && j_sscanf(v42, "%i", &v110) == 1 )
      {
        v43 = v110;
      }
      else
      {
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing anisotropy_enabled, will be disabled.\n");
        v43 = 0;
        v110 = 0;
      }
      flags = _RBX->volumetric.flags;
      v45 = flags & 0xFFFFFFFD;
      v46 = flags | 2;
      if ( v43 )
        v45 = v46;
      _RBX->volumetric.flags = v45;
      v47 = GetPairValue(v5, "color");
      __asm { vmovsd  xmm8, cs:__real@3ff0000000000000 }
      if ( v47 && j_sscanf(v47, "%f %f %f", &v119, &v120, &v121) == 3 )
      {
        __asm { vmovss  xmm0, [rbp+57h+var_70] }
      }
      else
      {
        __asm
        {
          vmovaps xmm3, xmm8
          vmovaps xmm2, xmm8
          vmovq   r9, xmm3
          vmovq   r8, xmm2
          vmovsd  [rsp+0E0h+fmt], xmm8
        }
        Com_PrintWarning(14, "Radiant Live: Volumetric color missing or incomplete, will use [%.1f %.1f %.1f]\n", _R8, _R9, fmt);
        __asm
        {
          vmovaps xmm0, xmm6
          vmovss  [rbp+57h+var_70], xmm6
          vmovss  [rbp+57h+var_6C], xmm6
          vmovss  [rbp+57h+var_68], xmm6
        }
      }
      __asm
      {
        vmovss  dword ptr [rbx+90h], xmm0
        vmovss  xmm0, [rbp+57h+var_6C]
        vmovss  dword ptr [rbx+94h], xmm0
        vmovss  xmm1, [rbp+57h+var_68]
        vmovss  dword ptr [rbx+98h], xmm1
      }
      v56 = GetPairValue(v5, "color_enabled");
      if ( v56 && j_sscanf(v56, "%i", &v111) == 1 )
      {
        v57 = v111;
      }
      else
      {
        Com_PrintWarning(14, "Radiant Live: Volumetric is missing color_enabled, will be disabled.\n");
        v57 = 0;
        v111 = 0;
      }
      _R13 = (float *)&_RBX->volumetric.masks[0].offset + 1;
      v59 = s_maskAxes;
      v60 = _RBX->volumetric.flags & 0xFFFFFFFB;
      if ( v57 )
        v60 = _RBX->volumetric.flags | 4;
      v61 = 0;
      v107 = 0;
      _RBX->volumetric.flags = v60;
      do
      {
        *(_R13 - 7) = 0.0;
        v62 = s_maskTypes;
        v63 = 0;
        *(_QWORD *)(_R13 - 5) = rgp.whiteImage;
        while ( 1 )
        {
          v64 = j_va("mask%d%s", v61, *v62);
          v65 = GetPairValue(v5, v64);
          if ( v65 )
          {
            if ( *v65 )
            {
              v66.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_IMAGE, v65, 0).physicsLibrary;
              if ( v66.physicsLibrary )
                break;
            }
          }
          ++v63;
          ++v62;
          if ( v63 >= 3 )
            goto LABEL_61;
        }
        *((_DWORD *)_R13 - 7) = v63;
        *(XAssetHeader *)(_R13 - 5) = v66;
LABEL_61:
        if ( v63 == 3 )
        {
          Com_PrintWarning(14, "Radiant Live: Volumetric mask %d type not specified, this mask will be ignored.\n", v61);
        }
        else if ( v63 )
        {
          *((_DWORD *)_R13 - 6) = 2;
          v67 = j_va("mask%daxis", v61);
          v68 = GetPairValue(v5, v67);
          if ( v68 )
          {
            for ( i = 0; i < 6; ++i )
            {
              name = v59->name;
              v71 = 0x7FFFFFFFi64;
              v72 = v68;
              if ( !v59->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
                __debugbreak();
              v73 = name - v68;
              while ( 1 )
              {
                v74 = *(unsigned __int8 *)v72;
                v75 = v71;
                v76 = (unsigned __int8)(v72++)[v73];
                --v71;
                if ( !v75 )
                {
LABEL_78:
                  v59 = s_maskAxes;
                  *(_R13 - 6) = *(float *)&s_maskAxes[i].value;
                  goto LABEL_81;
                }
                if ( v74 != v76 )
                {
                  v77 = v74 + 32;
                  if ( (unsigned int)(v74 - 65) > 0x19 )
                    v77 = v74;
                  v74 = v77;
                  v78 = v76 + 32;
                  if ( (unsigned int)(v76 - 65) > 0x19 )
                    v78 = v76;
                  if ( v74 != v78 )
                    break;
                }
                if ( !v74 )
                  goto LABEL_78;
              }
              ++v59;
            }
            v59 = s_maskAxes;
LABEL_81:
            v61 = v107;
            if ( i == 6 )
              Com_PrintWarning(14, "Radiant Live: Volumetric mask %d has invalid axis: %s, using +Z axis instead, but this will fail map compile!.\n", v107, v68);
          }
          else
          {
            Com_PrintWarning(14, "Radiant Live: Volumetric mask %d axis not specified, will use +Z axis.\n", v61);
          }
          v79 = j_va("mask%dscale", v61);
          v5 = spawnVara;
          v80 = GetPairValue(spawnVara, v79);
          if ( v80 && (v81 = j_sscanf(v80, "%f %f", &v113, &v114), v82 = v81 < 2, v81 == 2) )
          {
            __asm { vmovss  xmm0, [rbp+57h+var_88] }
          }
          else
          {
            __asm
            {
              vmovaps xmm3, xmm8
              vmovq   r9, xmm3
              vmovsd  [rsp+0E0h+fmt], xmm8
            }
            Com_PrintWarning(14, "Radiant Live: Volumetric mask %d scale missing or incomplete, will use [%.1f %.1f]\n", v61, _R9, fmta);
            __asm
            {
              vmovaps xmm0, xmm6
              vmovss  [rbp+57h+var_88], xmm6
              vmovss  [rbp+57h+var_84], xmm6
            }
          }
          __asm
          {
            vmovss  dword ptr [r13-0Ch], xmm0
            vmovss  xmm1, dword ptr [r13-0Ch]
            vcomiss xmm1, xmm6
            vmovss  xmm0, [rbp+57h+var_84]
            vmovss  dword ptr [r13-8], xmm0
          }
          if ( v82 )
            goto LABEL_90;
          __asm
          {
            vmovss  xmm0, [rbp+57h+var_84]
            vcomiss xmm0, xmm6
          }
          if ( v82 )
          {
LABEL_90:
            Com_PrintWarning(14, "Radiant Live: Volumetric scale is smaller than the minimum, this will fail the map compile.\n");
            __asm { vmovss  xmm1, dword ptr [r13-0Ch] }
          }
          __asm
          {
            vmaxss  xmm0, xmm1, xmm6
            vmovss  dword ptr [r13-0Ch], xmm0
            vmovss  xmm1, dword ptr [r13-8]
            vmaxss  xmm2, xmm1, xmm6
            vmovss  dword ptr [r13-8], xmm2
          }
          v92 = j_va("mask%doffset", v61);
          v93 = GetPairValue(v5, v92);
          if ( v93 && j_sscanf(v93, "%f %f", &v115, &v116) == 2 )
          {
            __asm { vmovss  xmm0, [rbp+57h+var_80] }
          }
          else
          {
            Com_PrintWarning(14, "Radiant Live: Volumetric mask %d offset missing or incomplete, will use [0 0]\n", v61);
            __asm
            {
              vmovaps xmm0, xmm7
              vmovss  [rbp+57h+var_80], xmm7
              vmovss  [rbp+57h+var_7C], xmm7
            }
          }
          __asm
          {
            vmovss  dword ptr [r13-4], xmm0
            vmovss  xmm0, [rbp+57h+var_7C]
            vmovss  dword ptr [r13+0], xmm0
          }
          v96 = j_va("mask%dscroll", v61);
          v97 = GetPairValue(v5, v96);
          if ( v97 && j_sscanf(v97, "%f %f", &v117, &v118) == 2 )
          {
            __asm { vmovss  xmm0, [rbp+57h+var_78] }
          }
          else
          {
            Com_PrintWarning(14, "Radiant Live: Volumetric mask %d scroll missing or incomplete, will use [0 0]\n", v61);
            __asm
            {
              vmovaps xmm0, xmm7
              vmovss  [rbp+57h+var_78], xmm7
              vmovss  [rbp+57h+var_74], xmm7
            }
          }
          __asm
          {
            vmovss  dword ptr [r13+4], xmm0
            vmovss  xmm0, [rbp+57h+var_74]
            vmovss  dword ptr [r13+8], xmm0
          }
        }
        ++v61;
        _R13 += 10;
        v107 = v61;
      }
      while ( v61 < 4 );
      __asm
      {
        vmovaps xmm8, [rsp+0E0h+var_50]
        vmovaps xmm7, [rsp+0E0h+var_40]
        vmovaps xmm6, [rsp+0E0h+var_30]
      }
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Volumetric update command has no livePath KVP.\n");
  }
}

/*
==============
CG_SetRadiantStatus
==============
*/
void CG_SetRadiantStatus(unsigned int inMask)
{
  __int16 v1; 
  unsigned int v2; 

  v1 = inMask ^ cgRadiantLiveStatus;
  v2 = inMask & 0x7FF;
  cgRadiantLiveStatus = v2;
  if ( (v1 & 0x7FF) != 0 || !triggerCnt )
  {
    cgRadiantLiveProcessStatus = v2 | 0x800;
    Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    gRadiantLiveProcessStatus = cgRadiantLiveStatus | 0x800;
    Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    triggerCnt = 4;
  }
  else
  {
    --triggerCnt;
  }
}

/*
==============
CG_SetRadiantStatusOff
==============
*/
void CG_SetRadiantStatusOff(void)
{
  cgRadiantLiveStatus = 0;
  cgRadiantLiveProcessStatus = 0;
  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  gRadiantLiveProcessStatus = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
}

/*
==============
CG_ShowWorldReflectionVolume
==============
*/
void CG_ShowWorldReflectionVolume(const char *livePath, bool show)
{
  __int64 v2; 
  __int64 v5; 
  GfxReflectionProbeInstance *v6; 
  char *v7; 
  const char *v8; 
  char v9; 
  __int64 v10; 
  char v11; 
  unsigned __int8 flags; 
  unsigned __int8 v13; 

  v2 = 0i64;
  if ( rgp.world->draw.reflectionProbeData.reflectionProbeInstanceCount )
  {
LABEL_2:
    v5 = 0x7FFFFFFFi64;
    v6 = &rgp.world->draw.reflectionProbeData.reflectionProbeInstances[v2];
    v7 = v6->livePath;
    if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v8 = (const char *)(livePath - v7);
    do
    {
      v9 = v7[(_QWORD)v8];
      v10 = v5;
      v11 = *v7++;
      --v5;
      if ( !v10 )
        break;
      if ( v9 != v11 )
      {
        v2 = (unsigned int)(v2 + 1);
        if ( (unsigned int)v2 >= rgp.world->draw.reflectionProbeData.reflectionProbeInstanceCount )
          return;
        goto LABEL_2;
      }
    }
    while ( v9 );
    flags = v6->flags;
    if ( show )
      v13 = flags & 0x7F;
    else
      v13 = flags | 0x80;
    v6->flags = v13;
  }
}

/*
==============
CG_ShowWorldVolumetric
==============
*/
void CG_ShowWorldVolumetric(const char *livePath, bool show)
{
  int v2; 
  __int64 v5; 
  GfxVolumetric *v6; 
  char *v7; 
  const char *v8; 
  char v9; 
  __int64 v10; 
  char v11; 
  unsigned int flags; 
  unsigned int v13; 

  v2 = 0;
  if ( rgp.world->draw.volumetrics.volumetricCount )
  {
LABEL_2:
    v5 = 0x7FFFFFFFi64;
    v6 = &rgp.world->draw.volumetrics.volumetrics[v2];
    v7 = v6->livePath;
    if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v8 = (const char *)(livePath - v7);
    do
    {
      v9 = v7[(_QWORD)v8];
      v10 = v5;
      v11 = *v7++;
      --v5;
      if ( !v10 )
        break;
      if ( v9 != v11 )
      {
        if ( ++v2 >= rgp.world->draw.volumetrics.volumetricCount )
          return;
        goto LABEL_2;
      }
    }
    while ( v9 );
    flags = v6->flags;
    if ( show )
      v13 = flags & 0xFFFFFFFE;
    else
      v13 = flags | 1;
    v6->flags = v13;
  }
}

/*
==============
CG_UpdateDecalVolumeMaterial
==============
*/
void CG_UpdateDecalVolumeMaterial(const SpawnVar *spawnVar, GfxStaticDecalVolumeUnpacked *decalVolume, vec3_t *outBlendMapAdjust, float *outEdgeFeatherZ, unsigned int decalIndex, bool isDynamic)
{
  const char *PairValue; 
  Material *v13; 
  GfxDecalVolumeMaterial *v14; 
  Material *v15; 
  GfxDecalVolumeMaterial *decalVolumeMaterial; 
  const char *v17; 
  unsigned int v18; 
  const char *v19; 
  GfxDecalVolumeMask *v20; 
  const char *v21; 
  const char *v22; 
  unsigned __int8 v23; 
  const char *v24; 
  const char *v28; 
  const char *v29; 
  const char *v30; 
  const char *v31; 
  int v36; 
  const char *v37; 
  const char *v38; 
  const char *v39; 
  const char *v40; 
  const char *v41; 
  const char *v42; 
  const char *v43; 
  const char *v44; 
  const char *v45; 
  GfxImage **channels; 
  GfxImage *v47; 
  unsigned __int16 width; 
  unsigned __int16 height; 
  vec3_t *p_size_min; 
  vec3_t *p_size_max; 
  unsigned int outMapIndex; 
  unsigned int outDrawOrder; 
  float v60; 
  bool autoTiling; 
  DecalVolumesNormalBlendMode outNormalBlendMode; 
  int v63; 
  GfxDecalVolumeMaterial *outMaterial; 
  int v65; 
  int v66; 
  int v67; 
  int v68; 
  vec2_t v69; 
  int v70; 
  GfxDecalVolumeMask *outMask; 
  unsigned int drawOrder; 
  unsigned int mapIndex; 
  vec2_t uvShift; 
  vec2_t uvScale; 
  vec3_t size_max; 
  int v77; 
  int v78; 
  int v79; 
  vec2_t outUvOffset; 
  int v81[4]; 
  vec3_t _size_min; 
  vec4_t outUvMatrix; 
  char dest[512]; 

  __asm { vmovaps [rsp+380h+var_50], xmm6 }
  _R12 = outEdgeFeatherZ;
  _R13 = outBlendMapAdjust;
  _R15 = decalVolume;
  R_DecalVolumes_GetMaterialInfo(decalIndex, isDynamic, &outMaterial, &outMask, &outNormalBlendMode, &mapIndex, &drawOrder);
  PairValue = GetPairValue(spawnVar, "modeloverridematerial");
  if ( PairValue )
  {
    Com_sprintf(dest, 0x1FFui64, "%s/%s", "i", PairValue);
    dest[511] = 0;
    if ( outMaterial )
    {
      if ( I_strcmp(outMaterial->name, dest) )
      {
        v15 = Material_Register(dest, IMAGE_TRACK_EMBLEM);
        if ( v15 )
        {
          decalVolumeMaterial = v15->decalVolumeMaterial;
          v14 = outMaterial;
          if ( decalVolumeMaterial )
            v14 = decalVolumeMaterial;
          goto LABEL_9;
        }
      }
    }
    else
    {
      v13 = Material_Register(dest, IMAGE_TRACK_EMBLEM);
      if ( v13 )
      {
        v14 = v13->decalVolumeMaterial;
LABEL_9:
        outMaterial = v14;
      }
    }
  }
  v17 = GetPairValue(spawnVar, "blendMapImageName");
  v18 = 0;
  v19 = v17;
  if ( v17 && *v17 )
  {
    if ( !outMask || !outMask->blendMap || I_strcmp(outMask->name, v17) )
    {
      v20 = R_DecalVolume_RegisterMask(v19, IMAGE_TRACK_EMBLEM);
      outMask = v20;
      if ( v20 )
        R_DecalVolumes_StartStreaming(v20->blendMap);
    }
  }
  else
  {
    outMask = NULL;
  }
  v21 = GetPairValue(spawnVar, "normalBlendModeOverride");
  v22 = v21;
  if ( v21 && *v21 )
  {
    v23 = outNormalBlendMode;
    if ( I_stricmp(v21, "blend") )
    {
      if ( I_stricmp(v22, "add") )
      {
        if ( I_stricmp(v22, "no_override") )
        {
          Com_PrintWarning(8, "WARNING: Invalid normal blend mode for decal volume: '%s'\n", v22);
          LOBYTE(outNormalBlendMode) = v23;
        }
        else
        {
          v23 = 2;
          LOBYTE(outNormalBlendMode) = 2;
        }
      }
      else
      {
        v23 = 1;
        LOBYTE(outNormalBlendMode) = 1;
      }
    }
    else
    {
      v23 = 0;
      LOBYTE(outNormalBlendMode) = 0;
    }
  }
  else
  {
    v23 = outNormalBlendMode;
  }
  _R15->packedMaterialInfo = R_DecalVolumes_RadiantLive_PackMaterialInfo(outMaterial, outMask, (DecalVolumesNormalBlendMode)v23, mapIndex, drawOrder).packed;
  v24 = GetPairValue(spawnVar, "edgeFeatherZ");
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( v24 )
  {
    __asm { vmovss  [rsp+380h+var_310], xmm6 }
    j_sscanf(v24, "%f", &v65);
    __asm
    {
      vmovss  xmm0, [rsp+380h+var_310]; zFeatherIn
      vmovss  dword ptr [r12], xmm0
      vmovss  xmm1, dword ptr [r15+30h]; decalHalfDepth
    }
    *(double *)&_XMM0 = R_DecalVolumes_CalculateZFeatherRcp(*(float *)&_XMM0, *(float *)&_XMM1);
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@c7c35000 }
  }
  __asm
  {
    vmovaps [rsp+380h+var_60], xmm7
    vmovss  dword ptr [r15+3Ch], xmm0
  }
  v28 = GetPairValue(spawnVar, "blendMapAdjustEdge0");
  v29 = GetPairValue(spawnVar, "blendMapAdjustEdge1");
  v30 = GetPairValue(spawnVar, "blendMapAdjustScale");
  v31 = v30;
  if ( v28 && v29 && v30 )
  {
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovss  [rsp+380h+var_308], xmm7
      vmovss  [rsp+380h+var_304], xmm7
      vmovss  [rsp+380h+var_30C], xmm6
    }
    j_sscanf(v28, "%f", &v66);
    j_sscanf(v29, "%f", &v67);
    j_sscanf(v31, "%f", &v68);
    __asm
    {
      vmovss  xmm0, [rsp+380h+var_30C]; edge0
      vmovss  xmm1, [rsp+380h+var_308]; edge1
      vmovss  xmm2, [rsp+380h+var_304]; scale
      vunpcklps xmm3, xmm0, xmm1
      vmovss  [rbp+280h+var_2F8], xmm2
    }
    v36 = v70;
    __asm { vmovsd  qword ptr [r13+0], xmm3 }
    LODWORD(_R13->v[2]) = v36;
    R_DecalVolumes_PrecalculateBlendMapAdjust(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, &_R15->blendMapAdjust);
  }
  else
  {
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovss  dword ptr [rbp+280h+var_300], xmm7
      vmovss  dword ptr [rbp+280h+var_300+4], xmm6
    }
    _R15->blendMapAdjust = v69;
  }
  v37 = GetPairValue(spawnVar, "explicitUVShift");
  v38 = GetPairValue(spawnVar, "explicitUVScale");
  v39 = GetPairValue(spawnVar, "explicitUVRotateDeg");
  v40 = GetPairValue(spawnVar, "uvAutoTiling");
  v41 = v40;
  if ( v37 && v38 && v39 && v40 )
  {
    __asm
    {
      vmovss  dword ptr [rbp+280h+uvShift], xmm6
      vmovss  dword ptr [rbp+280h+uvShift+4], xmm6
      vmovss  dword ptr [rbp+280h+uvScale], xmm7
      vmovss  dword ptr [rbp+280h+uvScale+4], xmm7
      vmovss  [rsp+380h+var_31C], xmm6
    }
    j_sscanf(v37, "%f %f", &uvShift, &uvShift.y);
    j_sscanf(v38, "%f %f", &uvScale, &uvScale.y);
    j_sscanf(v39, "%f", &v63);
    BYTE1(outNormalBlendMode) = 0;
    GetBoolFromString(v41, (bool *)&outNormalBlendMode + 1);
    if ( !BYTE1(outNormalBlendMode) || !outMaterial )
    {
      p_size_min = &_size_min;
      p_size_max = (vec3_t *)v81;
      autoTiling = 0;
      __asm { vmovss  [rsp+380h+var_348], xmm6 }
      outDrawOrder = 0;
      outMapIndex = 0;
      __asm
      {
        vmovss  [rbp+280h+var_2A8], xmm6
        vmovss  [rbp+280h+var_2A4], xmm6
        vmovss  [rbp+280h+var_2A0], xmm6
        vmovss  dword ptr [rbp+280h+_size_min], xmm6
        vmovss  dword ptr [rbp+280h+_size_min+4], xmm6
        vmovss  dword ptr [rbp+280h+_size_min+8], xmm6
      }
      goto LABEL_53;
    }
    v42 = GetPairValue(spawnVar, "RadiantDefaultTextureDensity");
    v43 = GetPairValue(spawnVar, "size_min");
    v44 = GetPairValue(spawnVar, "size_max");
    v45 = v44;
    if ( v42 && v43 && v44 )
    {
      channels = outMaterial->channels;
      while ( !*channels )
      {
        ++v18;
        ++channels;
        if ( v18 >= 4 )
          goto LABEL_54;
      }
      v47 = outMaterial->channels[v18];
      width = v47->width;
      height = v47->height;
      if ( width )
      {
        if ( height )
        {
          LODWORD(v69.v[0]) = 16;
          __asm
          {
            vmovss  [rbp+280h+var_2C0], xmm6
            vmovss  [rbp+280h+var_2BC], xmm6
            vmovss  [rbp+280h+var_2B8], xmm6
            vmovss  dword ptr [rbp+280h+size_max], xmm6
            vmovss  dword ptr [rbp+280h+size_max+4], xmm6
            vmovss  dword ptr [rbp+280h+size_max+8], xmm6
          }
          j_sscanf(v42, "%u", &v69);
          j_sscanf(v43, "%f %f %f", &v77, &v78, &v79);
          j_sscanf(v45, "%f %f %f", &size_max, &size_max.y, &size_max.z);
          p_size_min = (vec3_t *)&v77;
          autoTiling = 1;
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, rax
            vmovss  [rsp+380h+var_348], xmm0
          }
          outDrawOrder = height;
          p_size_max = &size_max;
          outMapIndex = width;
LABEL_53:
          __asm { vmovss  xmm2, [rsp+380h+var_31C]; uvRotateDeg }
          R_DecalVolumes_CalculateUVTranform(&uvScale, &uvShift, *(float *)&_XMM2, p_size_min, p_size_max, outMapIndex, outDrawOrder, v60, autoTiling, &outUvMatrix, &outUvOffset);
          __asm { vmovups xmm0, xmmword ptr [rbp+280h+var_288] }
          _R15->uvOffset = outUvOffset;
          __asm { vmovups xmmword ptr [r15+48h], xmm0 }
        }
      }
    }
  }
LABEL_54:
  __asm
  {
    vmovaps xmm7, [rsp+380h+var_60]
    vmovaps xmm6, [rsp+380h+var_50]
  }
}

/*
==============
CG_UpdateDecalVolumeObb
==============
*/
void CG_UpdateDecalVolumeObb(const SpawnVar *spawnVar, GfxStaticDecalVolumeUnpacked *decalVolume)
{
  const char *PairValue; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  const char *v52; 
  int v71; 
  int v72; 
  __int64 v73; 
  __int64 v74; 
  float v75; 
  int v76; 
  int v77; 
  int v78; 
  int v79; 
  int v80; 
  __int64 v81; 
  tmat33_t<vec3_t> axis; 
  vec3_t angles; 
  vec3_t in1; 
  tmat43_t<vec3_t> in2; 
  __int64 v86; 
  char v90; 
  void *retaddr; 

  _RAX = &retaddr;
  _RBP = &v86;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
  }
  _RSI = decalVolume;
  PairValue = GetPairValue(spawnVar, "origin");
  v12 = GetPairValue(spawnVar, "angles");
  j_sscanf(PairValue, "%f %f %f", &v74, (char *)&v74 + 4, &v75);
  j_sscanf(v12, "%f %f %f", &angles, &angles.y, &angles.z);
  AnglesToAxis(&angles, &axis);
  v13 = GetPairValue(spawnVar, "size_min");
  v14 = GetPairValue(spawnVar, "size_max");
  v15 = v14;
  __asm
  {
    vmovss  xmm10, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovss  xmm9, cs:__real@3f000000
  }
  if ( v13 && v14 )
  {
    __asm
    {
      vmovaps xmmword ptr [rsp+150h+var_28+8], xmm6
      vmovaps [rsp+150h+var_38+8], xmm7
      vmovaps [rsp+150h+var_48+8], xmm8
    }
    j_sscanf(v13, "%f %f %f", &v76, &v77, &v78);
    j_sscanf(v15, "%f %f %f", &v79, &v80, &v81);
    __asm
    {
      vmovss  xmm2, [rsp+150h+var_F0]
      vmovss  xmm0, [rsp+150h+var_100]
      vmovss  xmm1, [rsp+150h+var_FC]
      vxorps  xmm5, xmm0, xmm10
      vmovss  xmm0, [rsp+150h+var_F8]
      vxorps  xmm3, xmm0, xmm10
      vmovss  xmm0, dword ptr [rsp+150h+var_E8]
      vminss  xmm8, xmm0, xmm3
      vmaxss  xmm3, xmm0, xmm3
      vxorps  xmm4, xmm1, xmm10
      vmovss  xmm1, [rsp+150h+var_EC]
      vminss  xmm6, xmm2, xmm5
      vminss  xmm7, xmm1, xmm4
      vmaxss  xmm5, xmm2, xmm5
      vmaxss  xmm4, xmm1, xmm4
    }
    in2.m[0].v[2] = axis.m[0].v[2];
    __asm
    {
      vaddss  xmm0, xmm5, xmm6
      vmulss  xmm1, xmm0, xmm9
      vmovss  dword ptr [rbp+50h+in1], xmm1
      vaddss  xmm2, xmm4, xmm7
      vmulss  xmm0, xmm2, xmm9
      vmovss  dword ptr [rbp+50h+in1+4], xmm0
      vaddss  xmm1, xmm3, xmm8
      vmulss  xmm2, xmm1, xmm9
      vmovss  dword ptr [rbp+50h+in1+8], xmm2
      vsubss  xmm0, xmm5, xmm6
      vmaxss  xmm1, xmm0, xmm9
      vsubss  xmm2, xmm4, xmm7
      vmaxss  xmm0, xmm2, xmm9
      vmovss  [rsp+150h+var_11C], xmm0
      vmovsd  xmm0, qword ptr [rsp+150h+axis]
      vmovsd  qword ptr [rbp+50h+in2], xmm0
      vmovsd  xmm0, qword ptr [rsp+150h+axis+0Ch]
      vmovsd  qword ptr [rbp+50h+in2+0Ch], xmm0
      vmovsd  xmm0, qword ptr [rbp+50h+axis+18h]
    }
    in2.m[1].v[2] = axis.m[1].v[2];
    __asm
    {
      vmovss  [rsp+150h+var_120], xmm1
      vsubss  xmm1, xmm3, xmm8
      vmovsd  qword ptr [rbp+50h+in2+18h], xmm0
      vmovsd  xmm0, qword ptr [rsp+150h+var_110]
      vmaxss  xmm2, xmm1, xmm9
    }
    in2.m[2].v[2] = axis.m[2].v[2];
    __asm
    {
      vmovsd  qword ptr [rbp+50h+in2+24h], xmm0
      vmovss  dword ptr [rsp+150h+var_118], xmm2
    }
    in2.m[3].v[2] = v75;
    MatrixTransformVector43(&in1, &in2, &_RSI->obb.center);
    __asm
    {
      vmovaps xmm8, [rsp+150h+var_48+8]
      vmovaps xmm7, [rsp+150h+var_38+8]
      vmovaps xmm6, xmmword ptr [rsp+150h+var_28+8]
    }
  }
  else
  {
    v52 = GetPairValue(spawnVar, "decalsize");
    j_sscanf(v52, "%f %f %f", &v71, &v72, &v73);
    __asm
    {
      vmovss  xmm0, [rsp+150h+var_110]
      vmovss  xmm1, [rsp+150h+var_10C]
      vmovss  dword ptr [rsi], xmm0
      vmovss  xmm0, [rsp+150h+var_108]
      vmovss  dword ptr [rsi+8], xmm0
      vmovss  dword ptr [rsi+4], xmm1
    }
  }
  __asm
  {
    vmulss  xmm1, xmm9, [rsp+150h+var_120]
    vmulss  xmm0, xmm9, [rsp+150h+var_11C]
    vmulss  xmm2, xmm9, dword ptr [rsp+150h+var_118]
    vmovss  dword ptr [rsi+34h], xmm0
    vmovss  xmm0, dword ptr [rsp+150h+axis]
    vmovss  dword ptr [rsi+30h], xmm1
    vmovss  dword ptr [rsi+38h], xmm2
    vmovss  xmm2, dword ptr [rsp+150h+axis+4]
    vxorps  xmm1, xmm0, xmm10
    vmovss  dword ptr [rsi+0Ch], xmm1
    vmovss  xmm1, dword ptr [rsp+150h+axis+8]
    vxorps  xmm0, xmm2, xmm10
    vmovss  dword ptr [rsi+10h], xmm0
    vmovups xmm0, xmmword ptr [rsp+150h+axis+0Ch]
    vxorps  xmm2, xmm1, xmm10
    vmovss  xmm1, dword ptr [rbp+50h+axis+20h]
    vmovss  dword ptr [rsi+14h], xmm2
    vmovups xmmword ptr [rsi+18h], xmm0
    vmovss  xmm0, dword ptr [rbp+50h+axis+1Ch]
    vmovss  dword ptr [rsi+28h], xmm0
    vmovss  dword ptr [rsi+2Ch], xmm1
  }
  _R11 = &v90;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
G_ProcessRadiantCmd
==============
*/
void G_ProcessRadiantCmd(RadiantCommand *command)
{
  __int64 v3; 
  RadiantCommandType type; 
  int v5; 
  RadiantCommandData v6; 
  SpawnVar spawnVar; 

  Com_BeginParseSession("G_ProcessRadiantCmd");
  ParseRadiantSpawnVars(command->command, &spawnVar);
  Com_EndParseSession();
  v6.radiantCommand = command;
  v6.spawnVar = &spawnVar;
  if ( command->type >= (unsigned int)RADIANT_COMMAND_COUNT )
  {
    v5 = 28;
    type = command->type;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2098, ASSERT_TYPE_ASSERT, "(unsigned)( command->type ) < (unsigned)( RADIANT_COMMAND_COUNT )", "command->type doesn't index RADIANT_COMMAND_COUNT\n\t%i not in [0, %i)", type, v5) )
      __debugbreak();
  }
  if ( !g_radiantCommandTable[command->type] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2099, ASSERT_TYPE_ASSERT, "(g_radiantCommandTable[command->type])", (const char *)&queryFormat, "g_radiantCommandTable[command->type]") )
    __debugbreak();
  __asm { vmovups xmm0, [rsp+2478h+var_2438] }
  v3 = command->type;
  __asm { vmovdqa [rsp+2478h+var_2438], xmm0 }
  ((void (__fastcall *)(RadiantCommandData *))g_radiantCommandTable[v3])(&v6);
}

/*
==============
G_ProcessRadiantCmds
==============
*/
void G_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  volatile int i; 
  gentity_s *v2; 
  gclient_s *client; 

  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  if ( bgRadiantLiveEnabled )
  {
    if ( gCommandCount )
    {
      Stream_ImageRecord_Disable("radiant_live_cmd");
      for ( i = 0; i < gCommandCount; ++i )
        G_ProcessRadiantCmd(&gCommands[i]);
    }
    if ( gRadiantLiveProcessStatus )
    {
      Stream_ImageRecord_Disable("radiant_live");
      if ( (gRadiantLiveProcessStatus & 1) != 0 && (cgRadiantLiveStatus & 0x400) != 0 )
      {
        v2 = g_entities;
        if ( G_Cmds_AreCheatsOk_NoHealthCheck(g_entities) )
        {
          client = v2->client;
          if ( client )
            client->flags |= 2u;
        }
      }
      gRadiantLiveProcessStatus = 0;
    }
  }
  gCommandCount = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
}

/*
==============
GetPairValue
==============
*/
char *GetPairValue(const SpawnVar *spawnVar, const char *key)
{
  int v2; 
  char *(*spawnVars)[2]; 
  const char *v6; 
  __int64 v7; 
  const char *v8; 
  int v9; 
  __int64 v10; 
  int v11; 
  int v12; 
  int v13; 

  v2 = 0;
  if ( spawnVar->numSpawnVars > 0 )
  {
    spawnVars = spawnVar->spawnVars;
    do
    {
      v6 = (*spawnVars)[0];
      v7 = 0x7FFFFFFFi64;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v8 = (const char *)(key - v6);
      while ( 1 )
      {
        v9 = (unsigned __int8)v6[(_QWORD)v8];
        v10 = v7;
        v11 = *(unsigned __int8 *)v6++;
        --v7;
        if ( !v10 )
          return spawnVar->spawnVars[v2][1];
        if ( v9 != v11 )
        {
          v12 = v9 + 32;
          if ( (unsigned int)(v9 - 65) > 0x19 )
            v12 = v9;
          v9 = v12;
          v13 = v11 + 32;
          if ( (unsigned int)(v11 - 65) > 0x19 )
            v13 = v11;
          if ( v9 != v13 )
            break;
        }
        if ( !v9 )
          return spawnVar->spawnVars[v2][1];
      }
      ++v2;
      ++spawnVars;
    }
    while ( v2 < spawnVar->numSpawnVars );
  }
  return 0i64;
}

/*
==============
ParseRadiantSpawnVars
==============
*/
void ParseRadiantSpawnVars(const char *command, SpawnVar *spawnVar)
{
  const char *v3; 
  const char *v4; 
  const char *v5; 
  __int64 v6; 
  __int64 numSpawnVarChars; 
  size_t v8; 
  char *v9; 
  __int64 v10; 
  __int64 v11; 
  size_t v12; 
  char *v13; 
  __int64 numSpawnVars; 
  char *data_p[2]; 
  char dest[1024]; 
  char s[1024]; 

  data_p[0] = (char *)command;
  spawnVar->numSpawnVars = 0;
  spawnVar->numSpawnVarChars = 0;
  spawnVar->spawnVarsValid = 0;
  v3 = Com_Parse((const char **)data_p);
  Core_strcpy(dest, 0x400ui64, v3);
  if ( dest[0] != 123 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE70, 1091i64, dest);
  while ( 1 )
  {
    v4 = Com_Parse((const char **)data_p);
    Core_strcpy(s, 0x400ui64, v4);
    if ( !data_p[0] )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CEC0, 1092i64);
    if ( s[0] == 125 )
      break;
    I_strlwr(s);
    v5 = Com_Parse((const char **)data_p);
    Core_strcpy(dest, 0x400ui64, v5);
    if ( !data_p[0] )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CEC0, 1093i64);
    if ( dest[0] == 125 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CF10, 1094i64);
    if ( spawnVar->numSpawnVars == 64 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CF60, 1095i64);
    v6 = -1i64;
    do
      ++v6;
    while ( s[v6] );
    numSpawnVarChars = spawnVar->numSpawnVarChars;
    if ( (unsigned __int64)(numSpawnVarChars + v6 + 1) > 0x2000 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE18, 1090i64);
      LODWORD(numSpawnVarChars) = spawnVar->numSpawnVarChars;
    }
    v8 = v6 + 1;
    v9 = &spawnVar->spawnVarChars[(int)numSpawnVarChars];
    memcpy_0(v9, s, v8);
    if ( (v8 > 0x7FFFFFFFFFFFFFFFi64 || v8 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v8, "unsigned", v8) )
      __debugbreak();
    spawnVar->numSpawnVarChars += v8;
    v10 = -1i64;
    spawnVar->spawnVars[spawnVar->numSpawnVars][0] = v9;
    do
      ++v10;
    while ( dest[v10] );
    v11 = spawnVar->numSpawnVarChars;
    if ( (unsigned __int64)(v11 + v10 + 1) > 0x2000 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE18, 1090i64);
      LODWORD(v11) = spawnVar->numSpawnVarChars;
    }
    v12 = v10 + 1;
    v13 = &spawnVar->spawnVarChars[(int)v11];
    memcpy_0(v13, dest, v12);
    if ( (v12 > 0x7FFFFFFFFFFFFFFFi64 || v12 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v12, "unsigned", v12) )
      __debugbreak();
    numSpawnVars = spawnVar->numSpawnVars;
    spawnVar->numSpawnVarChars += v12;
    spawnVar->spawnVars[numSpawnVars][1] = v13;
    ++spawnVar->numSpawnVars;
  }
  spawnVar->spawnVarsValid = 1;
}

/*
==============
R_DrawRadiantLiveConnectionStatus
==============
*/

void __fastcall R_DrawRadiantLiveConnectionStatus(__int64 a1, double _XMM1_8, double _XMM2_8)
{
  Material *radiantLiveDebugConnectionMaterial; 
  char v34; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  float v72; 
  __m256i verts_8; 
  void *retaddr; 

  _R11 = &retaddr;
  if ( (cgRadiantLiveStatus & 0x3F) != 0 )
  {
    radiantLiveDebugConnectionMaterial = rgp.radiantLiveDebugConnectionMaterial;
    __asm
    {
      vmovups ymm0, cs:__ymm@42f800004220000042f8000042d000004270000042d000004270000042200000
      vmovaps xmmword ptr [r11-18h], xmm6
      vmovaps xmmword ptr [r11-28h], xmm7
      vmovss  xmm7, cs:__real@42c80000
      vmovaps xmmword ptr [r11-38h], xmm8
      vmovss  xmm8, cs:__real@42700000
      vmovaps xmmword ptr [r11-48h], xmm9
      vmovaps xmmword ptr [r11-58h], xmm10
      vmovaps xmmword ptr [r11-78h], xmm12
      vmovaps xmmword ptr [r11-88h], xmm13
      vmovss  xmm13, cs:__real@3e800000
      vmovaps xmmword ptr [r11-98h], xmm14
      vmovaps [rsp+110h+var_A8+8], xmm15
      vmovss  xmm15, cs:__real@3f800000
      vmovaps xmm3, xmm13; s1
      vxorps  xmm2, xmm2, xmm2; t0
      vxorps  xmm1, xmm1, xmm1; s0
      vmovss  dword ptr [rsp+110h+var_F0], xmm15
      vmovaps xmm6, xmm8
      vmovups ymmword ptr [rsp+110h+verts+8], ymm0
    }
    R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v65, &color, radiantLiveDebugConnectionMaterial);
    __asm
    {
      vmovss  xmm10, cs:__real@3f000000
      vmovss  xmm14, cs:__real@3ec00000
    }
    if ( (cgRadiantLiveStatus & 1) != 0 )
    {
      __asm
      {
        vmovups ymm0, cs:__ymm@4298000042c800004298000042e800004270000042e800004270000042c80000
        vmovaps xmm3, xmm14; s1
        vxorps  xmm2, xmm2, xmm2; t0
        vmovaps xmm1, xmm13; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm10
        vmovups ymmword ptr [rsp+110h+verts+8], ymm0
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v66, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vmovss  xmm6, cs:__real@42980000 }
    }
    __asm
    {
      vmovss  xmm9, cs:__real@41800000
      vmovss  xmm12, cs:__real@42f80000
      vmovaps [rsp+110h+var_68+8], xmm11
    }
    if ( (cgRadiantLiveStatus & 2) != 0 )
    {
      __asm
      {
        vmovss  xmm11, cs:__real@42e80000
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vaddss  xmm6, xmm6, xmm9
        vmovaps xmm3, xmm14; s1
        vmovaps xmm2, xmm10; t0
        vmovaps xmm1, xmm13; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm15
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+10h], xmm11
        vmovss  dword ptr [rsp+110h+verts+18h], xmm11
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm6
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm6
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v67, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vcomiss xmm6, xmm12 }
      if ( !v34 )
      {
        __asm
        {
          vmovaps xmm6, xmm8
          vmovaps xmm7, xmm11
        }
      }
    }
    if ( (cgRadiantLiveStatus & 4) != 0 )
    {
      __asm
      {
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vaddss  xmm11, xmm7, xmm9
        vaddss  xmm6, xmm6, xmm9
        vmovaps xmm3, xmm10; s1
        vxorps  xmm2, xmm2, xmm2; t0
        vmovaps xmm1, xmm14; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm10
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+10h], xmm11
        vmovss  dword ptr [rsp+110h+verts+18h], xmm11
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm6
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm6
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v68, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vcomiss xmm6, xmm12 }
      if ( !v34 )
      {
        __asm
        {
          vmovaps xmm6, xmm8
          vmovaps xmm7, xmm11
        }
      }
    }
    if ( (cgRadiantLiveStatus & 8) != 0 )
    {
      __asm
      {
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vaddss  xmm11, xmm7, xmm9
        vaddss  xmm6, xmm6, xmm9
        vmovaps xmm3, xmm10; s1
        vmovaps xmm2, xmm10; t0
        vmovaps xmm1, xmm14; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm15
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+10h], xmm11
        vmovss  dword ptr [rsp+110h+verts+18h], xmm11
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm6
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm6
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v69, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vcomiss xmm6, xmm12 }
      if ( !v34 )
      {
        __asm
        {
          vmovaps xmm6, xmm8
          vmovaps xmm7, xmm11
        }
      }
    }
    __asm { vmovss  xmm14, cs:__real@3f200000 }
    if ( (cgRadiantLiveStatus & 0x10) != 0 )
    {
      __asm
      {
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vaddss  xmm11, xmm7, xmm9
        vaddss  xmm6, xmm6, xmm9
        vmovaps xmm3, xmm14; s1
        vmovaps xmm2, xmm10; t0
        vmovaps xmm1, xmm10; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm15
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+10h], xmm11
        vmovss  dword ptr [rsp+110h+verts+18h], xmm11
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm6
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm6
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v70, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vcomiss xmm6, xmm12 }
      if ( !v34 )
      {
        __asm
        {
          vmovaps xmm6, xmm8
          vmovaps xmm7, xmm11
        }
      }
    }
    __asm { vmovss  xmm13, cs:__real@3f400000 }
    if ( (cgRadiantLiveStatus & 0x20) != 0 )
    {
      __asm
      {
        vmovss  xmm3, cs:__real@3f600000; s1
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vaddss  xmm11, xmm7, xmm9
        vaddss  xmm6, xmm6, xmm9
        vxorps  xmm2, xmm2, xmm2; t0
        vmovaps xmm1, xmm13; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm10
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+10h], xmm11
        vmovss  dword ptr [rsp+110h+verts+18h], xmm11
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm6
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm6
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v71, &color, rgp.radiantLiveDebugConnectionMaterial);
      __asm { vcomiss xmm6, xmm12 }
      if ( !v34 )
      {
        __asm
        {
          vmovaps xmm6, xmm8
          vmovaps xmm7, xmm11
        }
      }
    }
    __asm
    {
      vmovaps xmm12, [rsp+110h+var_78+8]
      vmovaps xmm11, [rsp+110h+var_68+8]
      vmovaps xmm8, [rsp+110h+var_38+8]
    }
    if ( !cgRadiantLiveFlowing && (Sys_GetTimeAsSeconds() & 3) != 3 )
    {
      __asm
      {
        vaddss  xmm0, xmm7, xmm9
        vaddss  xmm4, xmm6, xmm9
        vmovaps xmm3, xmm13; s1
        vmovaps xmm2, xmm10; t0
        vmovaps xmm1, xmm14; s0
        vmovss  dword ptr [rsp+110h+var_F0], xmm15
        vmovss  dword ptr [rsp+110h+verts+8], xmm7
        vmovss  dword ptr [rsp+110h+verts+0Ch], xmm6
        vmovss  dword ptr [rsp+110h+verts+10h], xmm0
        vmovss  dword ptr [rsp+110h+verts+14h], xmm6
        vmovss  dword ptr [rsp+110h+verts+18h], xmm0
        vmovss  dword ptr [rsp+110h+verts+1Ch], xmm4
        vmovss  dword ptr [rsp+110h+var_B8], xmm7
        vmovss  dword ptr [rsp+110h+var_B8+4], xmm4
      }
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v72, &color, rgp.radiantLiveDebugConnectionMaterial);
    }
    __asm
    {
      vmovaps xmm14, [rsp+110h+var_98+8]
      vmovaps xmm13, [rsp+110h+var_88+8]
      vmovaps xmm10, [rsp+110h+var_58+8]
      vmovaps xmm9, [rsp+110h+var_48+8]
      vmovaps xmm7, [rsp+110h+var_28+8]
      vmovaps xmm6, xmmword ptr [rsp+110h+var_18+8]
      vmovaps xmm15, [rsp+110h+var_A8+8]
    }
  }
}

/*
==============
R_RadiantRemoteGetGfxReflectionProbeInstance
==============
*/
bool R_RadiantRemoteGetGfxReflectionProbeInstance(const char *livePath, GfxReflectionProbeInstance *outReflectionProbeInstance)
{
  _RBX = outReflectionProbeInstance;
  _RAX = CG_FindRadiantReflectionVolume(livePath);
  if ( _RAX )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+48h]
      vmovups ymmword ptr [rbx], ymm0
      vmovups ymm1, ymmword ptr [rax+68h]
      vmovups ymmword ptr [rbx+20h], ymm1
      vmovups ymm0, ymmword ptr [rax+88h]
      vmovups ymmword ptr [rbx+40h], ymm0
      vmovups ymm1, ymmword ptr [rax+0A8h]
      vmovups ymmword ptr [rbx+60h], ymm1
      vmovups xmm0, xmmword ptr [rax+0C8h]
      vmovups xmmword ptr [rbx+80h], xmm0
    }
    _RBX->livePath = NULL;
    LOBYTE(_RAX) = 1;
  }
  return (char)_RAX;
}

