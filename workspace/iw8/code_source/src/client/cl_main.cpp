/*
==============
CL_Main_ShutdownClientMemory
==============
*/

void CL_Main_ShutdownClientMemory(void)
{
  ?CL_Main_ShutdownClientMemory@@YAXXZ();
}

/*
==============
CL_Main_Disconnect
==============
*/

void __fastcall CL_Main_Disconnect(LocalClientNum_t localClientNum)
{
  ?CL_Main_Disconnect@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_StartPrivateParty
==============
*/

void __fastcall CL_Main_StartPrivateParty(const LocalClientNum_t localClientNum, int localControllerIndex)
{
  ?CL_Main_StartPrivateParty@@YAXW4LocalClientNum_t@@H@Z(localClientNum, localControllerIndex);
}

/*
==============
ClStatic::SetGameMapName
==============
*/

void __fastcall ClStatic::SetGameMapName(ClStatic *this, const char *mapname)
{
  ?SetGameMapName@ClStatic@@QEAAXPEBD@Z(this, mapname);
}

/*
==============
CL_Main_ForwardToServer_f
==============
*/

void CL_Main_ForwardToServer_f(void)
{
  ?CL_Main_ForwardToServer_f@@YAXXZ();
}

/*
==============
CL_Main_FreeSkelMemory
==============
*/

void CL_Main_FreeSkelMemory(void)
{
  ?CL_Main_FreeSkelMemory@@YAXXZ();
}

/*
==============
CL_Main_FreeLoadZones
==============
*/

void CL_Main_FreeLoadZones(void)
{
  ?CL_Main_FreeLoadZones@@YAXXZ();
}

/*
==============
CL_Main_IsUIActive
==============
*/

bool __fastcall CL_Main_IsUIActive(const LocalClientNum_t localClientNum)
{
  return ?CL_Main_IsUIActive@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Cl_Main_UnregisterGameDvars
==============
*/

void Cl_Main_UnregisterGameDvars(void)
{
  ?Cl_Main_UnregisterGameDvars@@YAXXZ();
}

/*
==============
CL_Main_IsOnlineGame
==============
*/

bool __fastcall CL_Main_IsOnlineGame()
{
  return ?CL_Main_IsOnlineGame@@YA_NXZ();
}

/*
==============
CL_Main_IsGameClientLocal
==============
*/

bool __fastcall CL_Main_IsGameClientLocal(int clientNum)
{
  return ?CL_Main_IsGameClientLocal@@YA_NH@Z(clientNum);
}

/*
==============
ClStatic::ClearGameActiveClientInfo
==============
*/

void __fastcall ClStatic::ClearGameActiveClientInfo(ClStatic *this)
{
  ?ClearGameActiveClientInfo@ClStatic@@QEAAXXZ(this);
}

/*
==============
CL_Main_ReInitDevGUI
==============
*/

void __fastcall CL_Main_ReInitDevGUI(GameModeType gameMode)
{
  ?CL_Main_ReInitDevGUI@@YAXW4GameModeType@@@Z(gameMode);
}

/*
==============
ClStatic::GenerateGameActiveClientInfo
==============
*/

void __fastcall ClStatic::GenerateGameActiveClientInfo(ClStatic *this)
{
  ?GenerateGameActiveClientInfo@ClStatic@@QEAAXXZ(this);
}

/*
==============
CL_Main_InitOnceForAllClients
==============
*/

void CL_Main_InitOnceForAllClients(void)
{
  ?CL_Main_InitOnceForAllClients@@YAXXZ();
}

/*
==============
CL_Main_ShutdownGameWorld
==============
*/

void CL_Main_ShutdownGameWorld(void)
{
  ?CL_Main_ShutdownGameWorld@@YAXXZ();
}

/*
==============
CL_Main_IsSystemLinkGame
==============
*/

bool __fastcall CL_Main_IsSystemLinkGame()
{
  return ?CL_Main_IsSystemLinkGame@@YA_NXZ();
}

/*
==============
ClStatic::ShutdownClStatic
==============
*/

void __fastcall ClStatic::ShutdownClStatic(ClStatic *this)
{
  ?ShutdownClStatic@ClStatic@@QEAAXXZ(this);
}

/*
==============
CL_Main_ShutdownHunkUsers
==============
*/

void CL_Main_ShutdownHunkUsers(void)
{
  ?CL_Main_ShutdownHunkUsers@@YAXXZ();
}

/*
==============
CL_Main_DisconnectLocalClient
==============
*/

void __fastcall CL_Main_DisconnectLocalClient(LocalClientNum_t localClientNum, bool declineInvite)
{
  ?CL_Main_DisconnectLocalClient@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, declineInvite);
}

/*
==============
CL_Main_ResetSkeletonCache
==============
*/

void CL_Main_ResetSkeletonCache(void)
{
  ?CL_Main_ResetSkeletonCache@@YAXXZ();
}

/*
==============
CL_Main_GetRealTimeCmd
==============
*/

void __fastcall CL_Main_GetRealTimeCmd(const void *const data)
{
  ?CL_Main_GetRealTimeCmd@@YAXQEBX@Z(data);
}

/*
==============
CL_ScaledMilliseconds
==============
*/

int __fastcall CL_ScaledMilliseconds()
{
  return ?CL_ScaledMilliseconds@@YAHXZ();
}

/*
==============
ClStatic::IsBRActiveGameTypeQuick
==============
*/

bool __fastcall ClStatic::IsBRActiveGameTypeQuick(ClStatic *this)
{
  return ?IsBRActiveGameTypeQuick@ClStatic@@QEBA_NXZ(this);
}

/*
==============
CL_Main_StartHunkUsers
==============
*/

void CL_Main_StartHunkUsers(void)
{
  ?CL_Main_StartHunkUsers@@YAXXZ();
}

/*
==============
CL_Main_IsBRGameType
==============
*/

bool __fastcall CL_Main_IsBRGameType(const LocalClientNum_t localClientNum)
{
  return ?CL_Main_IsBRGameType@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_ShutdownOnceForAllClients
==============
*/

void CL_Main_ShutdownOnceForAllClients(void)
{
  ?CL_Main_ShutdownOnceForAllClients@@YAXXZ();
}

/*
==============
CL_Main_InitClient
==============
*/

void __fastcall CL_Main_InitClient(LocalClientNum_t localClientNum)
{
  ?CL_Main_InitClient@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_ControllerRemoved
==============
*/

void __fastcall CL_Main_ControllerRemoved(int portIndex)
{
  ?CL_Main_ControllerRemoved@@YAXH@Z(portIndex);
}

/*
==============
CL_Main_AllocateSkelMemory
==============
*/

void __fastcall CL_Main_AllocateSkelMemory(HunkUser *hunkUser, const unsigned int allocationSize)
{
  ?CL_Main_AllocateSkelMemory@@YAXPEAUHunkUser@@I@Z(hunkUser, allocationSize);
}

/*
==============
CL_Main_ShutdownRef
==============
*/

void CL_Main_ShutdownRef(void)
{
  ?CL_Main_ShutdownRef@@YAXXZ();
}

/*
==============
ClStatic::SetActiveHardcoreMode
==============
*/

void __fastcall ClStatic::SetActiveHardcoreMode(ClStatic *this, const bool isHardcore)
{
  ?SetActiveHardcoreMode@ClStatic@@QEAAX_N@Z(this, isHardcore);
}

/*
==============
CL_Main_ClientFrame
==============
*/

void __fastcall CL_Main_ClientFrame(LocalClientNum_t localClientNum)
{
  ?CL_Main_ClientFrame@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_RegisterGameDvars
==============
*/

void CL_Main_RegisterGameDvars(void)
{
  ?CL_Main_RegisterGameDvars@@YAXXZ();
}

/*
==============
CL_Main_AllocateDObjMemory
==============
*/

void __fastcall CL_Main_AllocateDObjMemory(HunkUser *hunkUser, int flags, int maxLocalClients)
{
  ?CL_Main_AllocateDObjMemory@@YAXPEAUHunkUser@@HH@Z(hunkUser, flags, maxLocalClients);
}

/*
==============
CL_Main_FreeDObjMemory
==============
*/

void CL_Main_FreeDObjMemory(void)
{
  ?CL_Main_FreeDObjMemory@@YAXXZ();
}

/*
==============
CL_Main_GetCLStatic
==============
*/

ClStatic *__fastcall CL_Main_GetCLStatic()
{
  return ?CL_Main_GetCLStatic@@YAPEAUClStatic@@XZ();
}

/*
==============
CL_Main_ConnectionlessPacket_Universal
==============
*/

bool __fastcall CL_Main_ConnectionlessPacket_Universal(LocalClientNum_t localClientNum, netadr_t *from, msg_t *msg, int time, const char *c)
{
  return ?CL_Main_ConnectionlessPacket_Universal@@YA_NW4LocalClientNum_t@@Unetadr_t@@PEAUmsg_t@@HPEBD@Z(localClientNum, from, msg, time, c);
}

/*
==============
CL_Main_InitRef
==============
*/

void CL_Main_InitRef(void)
{
  ?CL_Main_InitRef@@YAXXZ();
}

/*
==============
CL_Main_AllocateHunkUser
==============
*/

HunkUser *__fastcall CL_Main_AllocateHunkUser(const unsigned int reserveSize)
{
  return ?CL_Main_AllocateHunkUser@@YAPEAUHunkUser@@I@Z(reserveSize);
}

/*
==============
ClStatic::SetWeaponMapRuntimeMaxEntries
==============
*/

void __fastcall ClStatic::SetWeaponMapRuntimeMaxEntries(ClStatic *this, const unsigned __int16 maxEntries)
{
  ?SetWeaponMapRuntimeMaxEntries@ClStatic@@QEAAXG@Z(this, maxEntries);
}

/*
==============
CL_Main_RegisterCommonDvars
==============
*/

void CL_Main_RegisterCommonDvars(void)
{
  ?CL_Main_RegisterCommonDvars@@YAXXZ();
}

/*
==============
CL_Main_AnyLocalClientsRunning
==============
*/

bool __fastcall CL_Main_AnyLocalClientsRunning()
{
  return ?CL_Main_AnyLocalClientsRunning@@YA_NXZ();
}

/*
==============
CL_Main_GetPlayerName
==============
*/

const char *__fastcall CL_Main_GetPlayerName(LocalClientNum_t localClientNum)
{
  return ?CL_Main_GetPlayerName@@YAPEBDW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_ResetViewport
==============
*/

void CL_Main_ResetViewport(void)
{
  ?CL_Main_ResetViewport@@YAXXZ();
}

/*
==============
CL_Main_ForwardSuperUserCommandToServer
==============
*/

void __fastcall CL_Main_ForwardSuperUserCommandToServer(LocalClientNum_t localClientNum, const char *string)
{
  ?CL_Main_ForwardSuperUserCommandToServer@@YAXW4LocalClientNum_t@@PEBD@Z(localClientNum, string);
}

/*
==============
CL_Main_InvalidateSkeletonCache
==============
*/

void CL_Main_InvalidateSkeletonCache(void)
{
  ?CL_Main_InvalidateSkeletonCache@@YAXXZ();
}

/*
==============
ClStatic::SetActiveGameType
==============
*/

void __fastcall ClStatic::SetActiveGameType(ClStatic *this, const char *gametype)
{
  ?SetActiveGameType@ClStatic@@QEAAXPEBD@Z(this, gametype);
}

/*
==============
CL_Main_InitRenderer
==============
*/

void CL_Main_InitRenderer(void)
{
  ?CL_Main_InitRenderer@@YAXXZ();
}

/*
==============
CL_Main_ShutdownRenderer
==============
*/

void __fastcall CL_Main_ShutdownRenderer(int destroyWindow, int isRestart)
{
  ?CL_Main_ShutdownRenderer@@YAXHH@Z(destroyWindow, isRestart);
}

/*
==============
CL_Main_SetupGfxConfig
==============
*/

void __fastcall CL_Main_SetupGfxConfig(GfxConfiguration *config)
{
  ?CL_Main_SetupGfxConfig@@YAXPEAUGfxConfiguration@@@Z(config);
}

/*
==============
CL_Main_IsServerLoadingMap
==============
*/

bool __fastcall CL_Main_IsServerLoadingMap()
{
  return ?CL_Main_IsServerLoadingMap@@YA_NXZ();
}

/*
==============
CL_Main_SyncGpu
==============
*/

void __fastcall CL_Main_SyncGpu(LocalClientNum_t localClientNum)
{
  ?CL_Main_SyncGpu@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_RunOncePerClientFrame
==============
*/

void __fastcall CL_Main_RunOncePerClientFrame(int msec, float sec_base, float rawSeconds)
{
  ?CL_Main_RunOncePerClientFrame@@YAXHMM@Z(msec, sec_base, rawSeconds);
}

/*
==============
CL_Main_ForwardCommandToServer
==============
*/

void __fastcall CL_Main_ForwardCommandToServer(LocalClientNum_t localClientNum, const char *string)
{
  ?CL_Main_ForwardCommandToServer@@YAXW4LocalClientNum_t@@PEBD@Z(localClientNum, string);
}

/*
==============
CL_Main_ShutdownClient
==============
*/

void __fastcall CL_Main_ShutdownClient(LocalClientNum_t localClientNum)
{
  ?CL_Main_ShutdownClient@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_Main_ControllerInserted
==============
*/

void __fastcall CL_Main_ControllerInserted(int portIndex)
{
  ?CL_Main_ControllerInserted@@YAXH@Z(portIndex);
}

/*
==============
CL_Main_GetHunkUser
==============
*/

HunkUser *__fastcall CL_Main_GetHunkUser()
{
  return ?CL_Main_GetHunkUser@@YAPEAUHunkUser@@XZ();
}

/*
==============
CL_Main_CheckNotify
==============
*/

void __fastcall CL_Main_CheckNotify(LocalClientNum_t localClientNum, int cmdIndex, int forceNotify, bool paused)
{
  ?CL_Main_CheckNotify@@YAXW4LocalClientNum_t@@HH_N@Z(localClientNum, cmdIndex, forceNotify, paused);
}

/*
==============
CL_Main_SkeletonCacheValidity_Lock
==============
*/

void __fastcall CL_Main_SkeletonCacheValidity_Lock(SkeletonCacheValidityLockType type)
{
  ?CL_Main_SkeletonCacheValidity_Lock@@YAXW4SkeletonCacheValidityLockType@@@Z(type);
}

/*
==============
CL_Main_ShutdownAll
==============
*/

void __fastcall CL_Main_ShutdownAll(int isRestart, int fullRenderShutdown)
{
  ?CL_Main_ShutdownAll@@YAXHH@Z(isRestart, fullRenderShutdown);
}

/*
==============
ClStatic::GetActiveGameTypeQuick
==============
*/

GameTypeQuick_t __fastcall ClStatic::GetActiveGameTypeQuick(ClStatic *this)
{
  return ?GetActiveGameTypeQuick@ClStatic@@QEBA?AW4GameTypeQuick_t@@XZ(this);
}

/*
==============
CL_Main_StopParty
==============
*/

void __fastcall CL_Main_StopParty(int backoutParty)
{
  ?CL_Main_StopParty@@YAXH@Z(backoutParty);
}

/*
==============
CL_Main_UpdateSound
==============
*/

void __fastcall CL_Main_UpdateSound(bool deferred)
{
  ?CL_Main_UpdateSound@@YAX_N@Z(deferred);
}

/*
==============
CL_Main_FreeHunkUser
==============
*/

void CL_Main_FreeHunkUser(void)
{
  ?CL_Main_FreeHunkUser@@YAXXZ();
}

/*
==============
CL_Main_IsSplitscreenGame
==============
*/

bool __fastcall CL_Main_IsSplitscreenGame()
{
  return ?CL_Main_IsSplitscreenGame@@YA_NXZ();
}

/*
==============
CL_Main_SkeletonCacheValidity_Unlock
==============
*/

void __fastcall CL_Main_SkeletonCacheValidity_Unlock(SkeletonCacheValidityLockType type)
{
  ?CL_Main_SkeletonCacheValidity_Unlock@@YAXW4SkeletonCacheValidityLockType@@@Z(type);
}

/*
==============
CL_Main_CancelConnectingDialog
==============
*/
void CL_Main_CancelConnectingDialog()
{
  const char *String; 

  Com_Printf(14, "CL_Live_CancelConnectingDialog()\n");
  Live_CancelConnecting();
  if ( InviteJoinHSM::IsHSMHandlingInvitation(&g_invitationHSM) )
    InviteJoinHSM::Handle_UserCancelInvitation(&g_invitationHSM);
  if ( Com_FrontEnd_IsInFrontEnd() )
  {
    PartyUI_RecoverFromError();
  }
  else
  {
    String = SEH_StringEd_GetString((const char *)&stru_143DD5890);
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&queryFormat, String);
  }
}

/*
==============
CL_Main_CancelInviteJoin
==============
*/
void CL_Main_CancelInviteJoin()
{
  InviteJoinHSM::Handle_UserCancelInvitation(&g_invitationHSM);
  CrosslaunchHSM::UserCancelCrosslaunch(&g_crosslaunchHSM);
}

/*
==============
CL_Main_MapUPnP
==============
*/
void CL_Main_MapUPnP()
{
  ;
}

/*
==============
CL_Main_SetPlayerProfileData
==============
*/

void __fastcall CL_Main_SetPlayerProfileData(double _XMM0_8)
{
  int v1; 
  const char *v2; 
  int DataIndexByName; 
  const char *v4; 
  GamerProfileData v7; 

  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_LocalControllerIndex();
    v2 = Cmd_Argv(1);
    DataIndexByName = GamerProfile_GetDataIndexByName(v2);
    if ( DataIndexByName >= 0 )
    {
      v4 = Cmd_Argv(2);
      v7.type = GamerProfile_GetDataType(DataIndexByName);
      switch ( v7.type )
      {
        case TYPE_BYTE:
          v7.u.byteVal = atoi(v4);
          break;
        case TYPE_BOOL:
          v7.u.byteVal = atoi(v4) != 0;
          break;
        case TYPE_SHORT:
          v7.u.shortVal = atoi(v4);
          break;
        case TYPE_INT:
        case TYPE_FLAG:
          v7.u.intVal = atoi(v4);
          break;
        case TYPE_FLOAT:
          _XMM0_8 = atof(v4);
          __asm
          {
            vcvtsd2ss xmm1, xmm0, xmm0
            vmovss  dword ptr [rsp+38h+var_18+8], xmm1
          }
          break;
        case TYPE_STRING:
          v7.u.stringVal = v4;
          break;
        default:
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1440E19F0, 757i64);
          break;
      }
      __asm
      {
        vmovups xmm0, [rsp+38h+var_18]
        vmovdqa [rsp+38h+var_18], xmm0
      }
      GamerProfile_SetData(v1, DataIndexByName, &v7);
    }
    else
    {
      Com_Printf(14, "unknown profile setting: %s\n", v2);
    }
  }
  else
  {
    Com_Printf(14, "usage: setPlayerProfileData [settingName] [value]\nSettingNames:\n");
    GamerProfile_ListProfileArgsToConsole(14);
  }
}

/*
==============
CL_Main_GetPlayerProfileData
==============
*/
void CL_Main_GetPlayerProfileData()
{
  int v0; 
  const char *v1; 
  __int64 v5; 
  __int128 v9; 
  GamerProfileData result; 

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_LocalControllerIndex();
    v1 = Cmd_Argv(1);
    _RAX = GamerProfile_GetDataByName(&result, v0, v1);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovd   ebx, xmm0
      vmovups [rsp+48h+var_28], xmm0
    }
    if ( _EBX )
    {
      Com_Printf(14, "%s: ", v1);
      switch ( _EBX )
      {
        case 1:
        case 2:
          v5 = BYTE8(v9);
          goto LABEL_9;
        case 3:
          v5 = (unsigned int)SWORD4(v9);
          goto LABEL_9;
        case 4:
        case 8:
          v5 = DWORD2(v9);
LABEL_9:
          Com_Printf(14, "%i\n", v5);
          break;
        case 5:
          __asm
          {
            vmovss  xmm2, dword ptr [rsp+48h+var_28+8]; jumptable 0000000141A2B339 case 5
            vcvtss2sd xmm2, xmm2, xmm2
            vmovq   r8, xmm2
          }
          Com_Printf(14, "%f\n", *(double *)&_XMM2);
          break;
        case 6:
          Com_Printf(14, "%s\n", *((const char **)&v9 + 1));
          break;
        default:
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1440E19F0, 758i64);
          break;
      }
    }
    else
    {
      Com_Printf(14, "unknown profile setting: %s\n", v1);
    }
  }
  else
  {
    Com_Printf(14, "usage: getPlayerProfileData [settingName]\nSettingNames:\n");
    GamerProfile_ListProfileArgsToConsole(14);
  }
}

/*
==============
CL_Main_UpdateGamerProfile
==============
*/
void CL_Main_UpdateGamerProfile()
{
  int ControllerFromClient; 
  int v1; 

  if ( Cmd_Argc() == 2 )
  {
    v1 = Cmd_ArgInt(1);
    GamerProfile_UpdateCommand(v1, 1);
  }
  else
  {
    ControllerFromClient = CL_Mgr_GetControllerFromClient(LOCAL_CLIENT_0);
    GamerProfile_UpdateCommand(ControllerFromClient, 0);
  }
}

/*
==============
CL_Main_ConfirmInvitation
==============
*/
void CL_Main_ConfirmInvitation()
{
  InviteJoinHSM::Handle_ConfirmInvitation(&g_invitationHSM);
}

/*
==============
CL_Main_CancelInvitation
==============
*/
void CL_Main_CancelInvitation()
{
  InviteJoinHSM::Handle_UserDeclineInvitation(&g_invitationHSM);
}

/*
==============
CL_Main_StartPrivateParty_f
==============
*/
void CL_Main_StartPrivateParty_f()
{
  LocalClientNum_t v0; 
  int v1; 

  v0 = Cmd_LocalClientNum();
  v1 = Cmd_LocalControllerIndex();
  if ( v0 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1441F4EA0, 759i64);
  CL_Main_StartPrivateParty(v0, v1);
}

/*
==============
CL_Main_StopPrivateParty_f
==============
*/
void CL_Main_StopPrivateParty_f()
{
  PartyDisconnectReason v0; 
  bool v1; 
  int ControllerFromClient; 
  const char *v3; 
  OnlineChatManager *Instance; 

  Com_Printf(14, "CL_Main_StopPrivateParty_f was called, calling Party_StopParty\n");
  LOBYTE(v0) = 2;
  PartyAtomic_AbortJoinAttempt(&g_partyJoinInfo, v0);
  v1 = 1;
  if ( Cmd_Argc() == 2 )
    v1 = Cmd_ArgInt(1) != 0;
  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_ArgInt(1) != 0;
    if ( Cmd_ArgInt(2) )
    {
      if ( Party_CountUIVisibleMembers(&g_partyData) > 1 )
      {
        ControllerFromClient = CL_Mgr_GetControllerFromClient(LOCAL_CLIENT_0);
        v3 = SEH_LocalizeTextMessage("LUA_MENU/TEXTCHAT_YOU_LEFT_PARTY", "ui string", LOCMSG_NOERR);
        if ( v3 )
        {
          Instance = OnlineChatManager::GetInstance();
          OnlineChatManager::SendSystemEvent(Instance, ControllerFromClient, v3);
        }
      }
    }
  }
  if ( v1 )
    Party_StopParty(&g_partyData);
  else
    Party_StopPartyNoUIScreenChange(&g_partyData);
  Party_Sleep(&g_partyData);
}

/*
==============
CL_Main_StopParty_f
==============
*/
void CL_Main_StopParty_f()
{
  const char *v0; 
  PartyDisconnectReason v1; 
  PartyData *PartyData; 
  int v3; 
  PartyData *v4; 
  const dvar_t *v5; 
  LocalClientNum_t v6; 
  int v7; 

  if ( Cmd_Argc() < 2 )
    v0 = "UNKNOWN";
  else
    v0 = Cmd_Argv(1);
  Com_Printf(14, "CL_Main_StopParty_f was called (context %s), calling Party_StopParty.\n", v0);
  LOBYTE(v1) = 2;
  PartyAtomic_AbortJoinAttempt(&g_partyJoinInfo, v1);
  PartyData = Lobby_GetPartyData();
  Party_StopParty(PartyData);
  v3 = Cmd_LocalControllerIndex();
  Party_Awake(&g_partyData, v3, 0);
  v4 = Lobby_GetPartyData();
  Party_Sleep(v4);
  v5 = DVARBOOL_onlinegame;
  if ( !DVARBOOL_onlinegame && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "onlinegame") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled && !g_partyData.inParty )
  {
    v6 = Cmd_LocalClientNum();
    v7 = Cmd_LocalControllerIndex();
    if ( v6 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1441F4EA0, 759i64);
    CL_Main_StartPrivateParty(v6, v7);
  }
}

/*
==============
CL_Main_ResetViewport_f
==============
*/
void CL_Main_ResetViewport_f()
{
  if ( cls.rendererStarted )
  {
    ScrPlace_SetupFullscreenViewports();
    ScrPlace_SetupClientViewports();
    if ( CL_AnyLocalClientStateActive() )
      CL_SetupScreenPlacements();
  }
}

/*
==============
CL_Main_Disconnect_f
==============
*/
char CL_Main_Disconnect_f()
{
  int v0; 
  connstate_t *p_connectionState; 
  connstate_t LocalClientGameConnectionState; 
  ClGameModeApplication *ActiveClientApplication; 
  __int64 v4; 
  __int64 v6; 
  __int64 v7; 

  v0 = 0;
  p_connectionState = &clientUIActives[0].connectionState;
  do
  {
    LocalClientGameConnectionState = CL_GetLocalClientGameConnectionState((const LocalClientNum_t)v0);
    if ( LocalClientGameConnectionState )
    {
      LOBYTE(LocalClientGameConnectionState) = ClGameModeApplication::HasActiveApplicationGameMode();
      if ( (_BYTE)LocalClientGameConnectionState )
      {
        ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
        LOBYTE(v4) = 1;
        LOBYTE(LocalClientGameConnectionState) = ((__int64 (__fastcall *)(ClGameModeApplication *, _QWORD, __int64))ActiveClientApplication->DisconnectLocalClient)(ActiveClientApplication, (unsigned int)v0, v4);
      }
      else
      {
        if ( (unsigned int)v0 >= 2 )
        {
          LODWORD(v7) = 2;
          LODWORD(v6) = v0;
          LOBYTE(LocalClientGameConnectionState) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v6, v7);
          if ( (_BYTE)LocalClientGameConnectionState )
            __debugbreak();
        }
        if ( *p_connectionState )
        {
          LOBYTE(LocalClientGameConnectionState) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1738, ASSERT_TYPE_ASSERT, "(CL_IsLocalClientDisconnectedFromAnyServer( localClientNum ))", "%s\n\tWe were connected to a game but did not know what game type we were connected to.", "CL_IsLocalClientDisconnectedFromAnyServer( localClientNum )");
          if ( (_BYTE)LocalClientGameConnectionState )
            __debugbreak();
        }
      }
    }
    ++v0;
    p_connectionState += 110;
  }
  while ( v0 < 2 );
  return LocalClientGameConnectionState;
}

/*
==============
CL_Main_SetNatStrict_f
==============
*/
void CL_Main_SetNatStrict_f()
{
  NET_SetNatType(3);
}

/*
==============
CL_Main_SetNatModerate_f
==============
*/
void CL_Main_SetNatModerate_f()
{
  NET_SetNatType(2);
}

/*
==============
CL_Main_SetNatOpen_f
==============
*/
void CL_Main_SetNatOpen_f()
{
  NET_SetNatType(1);
}

/*
==============
CL_Main_ForwardToServer_f
==============
*/
void CL_Main_ForwardToServer_f(void)
{
  LocalClientNum_t v0; 
  __int64 v1; 
  char buffer[1024]; 

  v0 = Cmd_LocalClientNum();
  v1 = v0;
  if ( (unsigned int)v0 >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v0, 2) )
    __debugbreak();
  if ( clientUIActives[v1].connectionState == CA_ACTIVE )
  {
    if ( Cmd_Argc() > 1 )
    {
      Cmd_ArgsBuffer(1, buffer, 0x400ui64);
      CL_Main_AddReliableCommand((LocalClientNum_t)v1, buffer);
    }
  }
  else
  {
    Com_Printf(0, "Not connected to a server.\n");
  }
}

/*
==============
CL_Main_AllocateDObjMemory
==============
*/
void CL_Main_AllocateDObjMemory(HunkUser *hunkUser, int flags, int maxLocalClients)
{
  unsigned int v3; 
  unsigned __int64 FreeReserveAmount; 

  v3 = maxLocalClients << 11;
  if ( (flags & 1) == 0 )
    v3 = 2048;
  Com_InitDObjBuffer(hunkUser, v3);
  FreeReserveAmount = Mem_HunkUser_GetFreeReserveAmount(hunkUser);
  Com_Printf(10, "GameAllocate: Free client hunk memory (Post-DObj): %zu kb\n", FreeReserveAmount >> 10);
}

/*
==============
CL_Main_AllocateHunkUser
==============
*/
HunkUser *CL_Main_AllocateHunkUser(const unsigned int reserveSize)
{
  unsigned __int64 v1; 
  HunkUser *result; 

  v1 = reserveSize;
  if ( s_clientHunkUser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1599, ASSERT_TYPE_ASSERT, "(s_clientHunkUser == nullptr)", (const char *)&queryFormat, "s_clientHunkUser == nullptr") )
    __debugbreak();
  if ( !(_DWORD)v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1600, ASSERT_TYPE_ASSERT, "(reserveSize)", (const char *)&queryFormat, "reserveSize") )
    __debugbreak();
  result = Mem_HunkUser_Create(v1, "s_clientHunkUser", TRACK_NETWORK_ENTITY, MEM_ALLOC_FLAG_NO_MEM_CLEAR);
  s_clientHunkUser = result;
  if ( !result )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1603, ASSERT_TYPE_ASSERT, "(s_clientHunkUser != nullptr)", (const char *)&queryFormat, "s_clientHunkUser != nullptr") )
      __debugbreak();
    return s_clientHunkUser;
  }
  return result;
}

/*
==============
CL_Main_AllocateSkelMemory
==============
*/
void CL_Main_AllocateSkelMemory(HunkUser *hunkUser, const unsigned int allocationSize)
{
  unsigned __int64 v2; 
  SkelMemoryPool *skelMemPools; 
  __int64 v5; 

  v2 = allocationSize;
  if ( !hunkUser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1650, ASSERT_TYPE_ASSERT, "(hunkUser)", (const char *)&queryFormat, "hunkUser") )
    __debugbreak();
  if ( !(_DWORD)v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1651, ASSERT_TYPE_ASSERT, "(allocationSize > 0)", (const char *)&queryFormat, "allocationSize > 0") )
    __debugbreak();
  if ( (v2 & 0x1F) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1658, ASSERT_TYPE_ASSERT, "( allocationSize % DSKEL_CREATE_INC ) == ( 0 )", "%s == %s\n\t%i, %i", "allocationSize % DSKEL_CREATE_INC", "0", v2 & 0x1F, 0i64) )
    __debugbreak();
  skelMemPools = cls.skelMemPools;
  v5 = 3i64;
  do
  {
    if ( skelMemPools->buffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1662, ASSERT_TYPE_ASSERT, "(cls.skelMemPools[poolIndex].buffer == nullptr)", (const char *)&queryFormat, "cls.skelMemPools[poolIndex].buffer == nullptr") )
      __debugbreak();
    skelMemPools->buffer = (char *)Mem_HunkUser_AllocInternal(hunkUser, v2, 0x10ui64, "CL_Main_AllocateSkelMemory");
    ++skelMemPools;
    --v5;
  }
  while ( v5 );
  cls.skelMemPoolSize = v2;
  CL_Main_ResetSkeletonCache();
}

/*
==============
CL_Main_AnyLocalClientsRunning
==============
*/
char CL_Main_AnyLocalClientsRunning()
{
  bool *p_isRunning; 

  p_isRunning = &clientUIActives[0].isRunning;
  while ( !*p_isRunning )
  {
    p_isRunning += 440;
    if ( (__int64)p_isRunning >= (__int64)VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_916.v.m128_i64 + 1 )
      return 0;
  }
  return 1;
}

/*
==============
CL_Main_CheckNotify
==============
*/
void CL_Main_CheckNotify(LocalClientNum_t localClientNum, int cmdIndex, int forceNotify, bool paused)
{
  char dest[1024]; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 633, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Com_sprintf(dest, 0x400ui64, "n %i", (unsigned int)cmdIndex);
  if ( !paused || forceNotify && !CL_Main_FindUnacknowledgedCommand(localClientNum, dest) )
    CL_Main_AddReliableCommand(localClientNum, dest);
}

/*
==============
CL_Main_ClientFrame
==============
*/
void CL_Main_ClientFrame(LocalClientNum_t localClientNum)
{
  ClGameModeApplication *ActiveClientApplication; 
  clientUIActive_t *LocalClientUIGlobals; 
  int ControllerFromClient; 
  PartyData *ActiveParty; 

  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    ActiveClientApplication->RunClientFrame(ActiveClientApplication, localClientNum);
LABEL_11:
    if ( Party_PartiesAcrossGamemodesFeatureEnabled() )
    {
      Profile_Begin(489);
      CL_VoiceFrame(localClientNum);
      Profile_EndInternal(NULL);
      ActiveParty = Live_GetActiveParty();
      PeerMesh_Frame(ActiveParty, localClientNum);
    }
    return;
  }
  if ( !CL_AllLocalClientsDisconnected() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2646, ASSERT_TYPE_ASSERT, "(CL_AllLocalClientsDisconnected())", "%s\n\tNo game mode has been allocated but a client is connected to a server", "CL_AllLocalClientsDisconnected()") )
    __debugbreak();
  LocalClientUIGlobals = CL_GetLocalClientUIGlobals(localClientNum);
  if ( LocalClientUIGlobals->isRunning )
  {
    CL_DevGuiFrame(localClientNum);
    if ( CL_Mgr_IsClientActive(localClientNum) && (LocalClientUIGlobals->keyCatchers & 0xC40) != 0 )
    {
      ControllerFromClient = CL_Mgr_GetControllerFromClient(localClientNum);
      CL_GamepadRepeatScrollingButtons(localClientNum, ControllerFromClient);
    }
    Online_Telemetry_Frame(localClientNum);
    goto LABEL_11;
  }
}

/*
==============
CL_Main_ConnectionlessPacket_Universal
==============
*/
bool CL_Main_ConnectionlessPacket_Universal(LocalClientNum_t localClientNum, netadr_t *from, msg_t *msg, int time, const char *c)
{
  PartyData *ActiveParty; 
  char froma[24]; 

  *(_DWORD *)&froma[16] = from->addrHandleIndex;
  __asm
  {
    vmovups xmm0, xmmword ptr [rdx]
    vmovups xmmword ptr [rsp+68h+from], xmm0
  }
  if ( !c && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2726, ASSERT_TYPE_ASSERT, "(c)", (const char *)&queryFormat, "c", *(_QWORD *)froma, *(_QWORD *)&froma[8], *(_QWORD *)&froma[16]) )
    __debugbreak();
  ActiveParty = Live_GetActiveParty();
  if ( I_stricmp(c, "v") )
    return PeerMesh_Receive(ActiveParty, localClientNum, c, msg, (const netadr_t *)froma);
  Voice_HandlePacket(ActiveParty, localClientNum, msg);
  return 1;
}

/*
==============
CL_Main_ControllerInserted
==============
*/
void CL_Main_ControllerInserted(int portIndex)
{
  LocalClientNum_t outLocalClientNum; 

  if ( (unsigned int)portIndex > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1518, ASSERT_TYPE_ASSERT, "( ( (portIndex >= 0) && (portIndex < 8) ) )", "( portIndex ) = %i", portIndex) )
    __debugbreak();
  if ( CL_Mgr_IsControllerActive(portIndex) && CL_Mgr_IsControllerMappedToClient(portIndex, &outLocalClientNum) && CL_IsLocalClientActive(outLocalClientNum) )
    UI_SetShowControllerRemovedPopup(outLocalClientNum, 0);
}

/*
==============
CL_Main_ControllerRemoved
==============
*/
void CL_Main_ControllerRemoved(int portIndex)
{
  clientUIActive_t *LocalClientUIGlobals; 
  UIInputType lastInputType; 
  ClGameModeApplication *ActiveClientApplication; 
  LocalClientNum_t outLocalClientNum; 

  if ( (unsigned int)portIndex > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1550, ASSERT_TYPE_ASSERT, "( ( (portIndex >= 0) && (portIndex < 8) ) )", "( portIndex ) = %i", portIndex) )
    __debugbreak();
  if ( CL_Mgr_IsControllerActive(portIndex) && CL_Mgr_IsControllerMappedToClient(portIndex, &outLocalClientNum) && CL_IsLocalClientActive(outLocalClientNum) )
  {
    LocalClientUIGlobals = CL_GetLocalClientUIGlobals(outLocalClientNum);
    lastInputType = LocalClientUIGlobals->lastInputType;
    IN_GamepadsReset(portIndex);
    LocalClientUIGlobals->lastInputType = lastInputType;
    CL_Keys_ClearStates(outLocalClientNum);
    if ( ClGameModeApplication::HasActiveApplicationGameMode() )
    {
      ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
      ActiveClientApplication->ControlRemoved(ActiveClientApplication, outLocalClientNum);
    }
    UI_SetShowControllerRemovedPopup(outLocalClientNum, 1);
  }
}

/*
==============
CL_Main_DevGuiCmd_f
==============
*/
void CL_Main_DevGuiCmd_f()
{
  const char *v0; 
  const char *v1; 
  const char *v2; 

  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_Argv(2);
    v2 = Cmd_Argv(1);
    DevGui_AddCommand(v2, v1);
  }
  else
  {
    v0 = Cmd_Argv(0);
    Com_Printf(0, "USAGE: %s \"devgui path\" \"command text\"\n", v0);
  }
}

/*
==============
CL_Main_DevGuiDvar_f
==============
*/
void CL_Main_DevGuiDvar_f()
{
  const char *v0; 
  const char *v1; 
  const dvar_t *VarByName; 
  const char *v3; 
  const char *v4; 

  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_Argv(2);
    VarByName = Dvar_FindVarByName(v1);
    if ( VarByName )
    {
      v4 = Cmd_Argv(1);
      DevGui_AddDvar(v4, VarByName);
    }
    else
    {
      v3 = Cmd_Argv(2);
      Com_Printf(11, "dvar '%s' doesn't exist\n", v3);
    }
  }
  else
  {
    v0 = Cmd_Argv(0);
    Com_Printf(0, "USAGE: %s \"devgui path\" dvarName\n", v0);
  }
}

/*
==============
CL_Main_DevGuiOpen_f
==============
*/
void CL_Main_DevGuiOpen_f()
{
  const char *v0; 
  const char *v1; 

  if ( Cmd_Argc() == 2 )
  {
    v1 = Cmd_Argv(1);
    DevGui_OpenMenu(v1);
  }
  else
  {
    v0 = Cmd_Argv(0);
    Com_Printf(0, "USAGE: %s \"devgui path\"\n", v0);
  }
}

/*
==============
CL_Main_Disconnect
==============
*/
void CL_Main_Disconnect(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  ClGameModeApplication *ActiveClientApplication; 
  int v3; 
  int v4; 

  v1 = localClientNum;
  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    ActiveClientApplication->Disconnect(ActiveClientApplication, (LocalClientNum_t)v1);
  }
  else
  {
    if ( (unsigned int)v1 >= 2 )
    {
      v4 = 2;
      v3 = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v3, v4) )
        __debugbreak();
    }
    if ( clientUIActives[v1].connectionState )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1723, ASSERT_TYPE_ASSERT, "(CL_IsLocalClientDisconnectedFromAnyServer( localClientNum ))", "%s\n\tWe were connected to a game but did not know what game type we were connected to.", "CL_IsLocalClientDisconnectedFromAnyServer( localClientNum )") )
        __debugbreak();
    }
  }
}

/*
==============
CL_Main_DisconnectLocalClient
==============
*/
void CL_Main_DisconnectLocalClient(LocalClientNum_t localClientNum, bool declineInvite)
{
  __int64 v3; 
  ClGameModeApplication *ActiveClientApplication; 
  int v5; 
  int v6; 

  v3 = localClientNum;
  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    ActiveClientApplication->DisconnectLocalClient(ActiveClientApplication, (LocalClientNum_t)v3, declineInvite);
  }
  else
  {
    if ( (unsigned int)v3 >= 2 )
    {
      v6 = 2;
      v5 = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v5, v6) )
        __debugbreak();
    }
    if ( clientUIActives[v3].connectionState )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1738, ASSERT_TYPE_ASSERT, "(CL_IsLocalClientDisconnectedFromAnyServer( localClientNum ))", "%s\n\tWe were connected to a game but did not know what game type we were connected to.", "CL_IsLocalClientDisconnectedFromAnyServer( localClientNum )") )
        __debugbreak();
    }
  }
}

/*
==============
CL_Main_FindUnacknowledgedCommand
==============
*/
__int64 CL_Main_FindUnacknowledgedCommand(const LocalClientNum_t localClientNum, const char *command)
{
  ClConnection *ClientConnection; 
  __int64 v4; 
  __int64 v5; 
  int v6; 
  __int64 v7; 
  int v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  const char *v13; 
  char v14; 
  __int64 v15; 
  char v16; 
  __int64 v18; 
  __int64 v19; 

  ClientConnection = ClConnection::GetClientConnection(localClientNum);
  v4 = (__int64)ClientConnection->GetConnectionData(ClientConnection);
  v5 = ((unsigned __int8)*(_DWORD *)(v4 + 16) + 1) & 0x7F;
  v6 = ((unsigned __int8)*(_DWORD *)(v4 + 8) + 1) & 0x7F;
  if ( !command && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 617, ASSERT_TYPE_ASSERT, "(command)", (const char *)&queryFormat, "command") )
    __debugbreak();
  if ( (_DWORD)v5 == v6 )
    return 0i64;
  v7 = v4 + 20;
  while ( 1 )
  {
    v8 = *(_DWORD *)(v7 + 8 * v5 + 4);
    if ( (unsigned int)(*(_DWORD *)(v7 + 132100) - v8) <= 0x20000 )
    {
      v9 = *(_WORD *)(v7 + 8 * v5 + 8);
      if ( v9 )
        break;
    }
LABEL_22:
    v5 = ((_BYTE)v5 + 1) & 0x7F;
    if ( (_DWORD)v5 == v6 )
      return 0i64;
  }
  v10 = v8 & 0x1FFFF;
  if ( (unsigned int)v10 + v9 > 0x20000 )
  {
    LODWORD(v19) = 0x20000;
    LODWORD(v18) = v10 + v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_circular_buffer.h", 202, ASSERT_TYPE_ASSERT, "( bufferIndex + m_entries[entryIndex].size ) <= ( sizeof( m_buffer ) )", "%s <= %s\n\t%i, %i", "bufferIndex + m_entries[entryIndex].size", "sizeof( m_buffer )", v18, v19) )
      __debugbreak();
  }
  v11 = v10 + v7 + 1028;
  v12 = 0x7FFFFFFFi64;
  if ( !command && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v13 = &command[-v11];
  do
  {
    v14 = v13[v11];
    v15 = v12;
    v16 = *(_BYTE *)v11++;
    --v12;
    if ( !v15 )
      break;
    if ( v14 != v16 )
      goto LABEL_22;
  }
  while ( v14 );
  return 1i64;
}

/*
==============
CL_Main_ForwardCommandToServer
==============
*/
void CL_Main_ForwardCommandToServer(LocalClientNum_t localClientNum, const char *string)
{
  const char *v4; 

  v4 = Cmd_Argv(0);
  if ( CL_Main_ShouldForwardCommandToServer(localClientNum, v4) )
  {
    if ( CL_GetLocalClientGameConnectionState(localClientNum) >= CA_CONNECTED )
      CL_Main_ForwardCommandToServerInternal(localClientNum, string, v4);
    else
      Com_PrintWarning(14, "Unknown command (Not connected to server) \"%s\"\n", v4);
  }
}

/*
==============
CL_Main_ForwardCommandToServerInternal
==============
*/
void CL_Main_ForwardCommandToServerInternal(LocalClientNum_t localClientNum, const char *string, const char *cmd)
{
  if ( !string && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 679, ASSERT_TYPE_ASSERT, "(string)", (const char *)&queryFormat, "string") )
    __debugbreak();
  if ( !cmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 680, ASSERT_TYPE_ASSERT, "(cmd)", (const char *)&queryFormat, "cmd") )
    __debugbreak();
  if ( Cmd_Argc() > 1 )
    cmd = string;
  CL_Main_AddReliableCommand(localClientNum, cmd);
}

/*
==============
CL_Main_ForwardSuperUserCommandToServer
==============
*/
void CL_Main_ForwardSuperUserCommandToServer(LocalClientNum_t localClientNum, const char *string)
{
  __int64 v2; 
  const char *v4; 
  int v5; 
  int v6; 

  v2 = localClientNum;
  v4 = Cmd_Argv(0);
  if ( CL_Main_ShouldForwardCommandToServer((LocalClientNum_t)v2, v4) )
  {
    if ( (unsigned int)v2 >= 2 )
    {
      v6 = 2;
      v5 = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v5, v6) )
        __debugbreak();
    }
    if ( clientUIActives[v2].connectionState >= CA_CONNECTED )
      CL_Main_ForwardCommandToServerInternal((LocalClientNum_t)v2, string, v4);
    else
      Com_PrintWarning(14, "Unknown command (SU) (Not connected to server) \"%s\"\n", v4);
  }
}

/*
==============
CL_Main_FreeDObjMemory
==============
*/
void CL_Main_FreeDObjMemory(void)
{
  Com_ShutdownDObj();
  Com_ShutdownDObjBuffer();
}

/*
==============
CL_Main_FreeHunkUser
==============
*/
void CL_Main_FreeHunkUser(void)
{
  if ( s_clientHunkUser )
  {
    Mem_HunkUser_Destroy(s_clientHunkUser);
    s_clientHunkUser = NULL;
  }
}

/*
==============
CL_Main_FreeLoadZones
==============
*/

void CL_Main_FreeLoadZones(void)
{
  Com_Frontend_LoadFastfile_Free();
}

/*
==============
CL_Main_FreeSkelMemory
==============
*/

void __fastcall CL_Main_FreeSkelMemory(double _XMM0_8)
{
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr cs:?cls@@3UClStatic@@A.skelMemPools.buffer, xmm0; ClStatic cls
  }
  cls.skelMemPools[2].buffer = NULL;
  cls.skelMemPoolSize = 0;
}

/*
==============
CL_Main_GetCLStatic
==============
*/
ClStatic *CL_Main_GetCLStatic()
{
  return &cls;
}

/*
==============
CL_Main_GetHunkUser
==============
*/
HunkUser *CL_Main_GetHunkUser()
{
  HunkUser *result; 

  result = s_clientHunkUser;
  if ( !s_clientHunkUser )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1611, ASSERT_TYPE_ASSERT, "(s_clientHunkUser != nullptr)", (const char *)&queryFormat, "s_clientHunkUser != nullptr") )
      __debugbreak();
    return s_clientHunkUser;
  }
  return result;
}

/*
==============
CL_Main_GetPlayerName
==============
*/
const char *CL_Main_GetPlayerName(LocalClientNum_t localClientNum)
{
  int ControllerFromClient; 

  ControllerFromClient = CL_Mgr_GetControllerFromClient(localClientNum);
  return CL_GetUsernameForLocalClient(ControllerFromClient);
}

/*
==============
CL_Main_GetRealTimeCmd
==============
*/
void CL_Main_GetRealTimeCmd(const void *const data)
{
  Com_RealTime(0, &cls.m_realTime);
}

/*
==============
CL_Main_InitClient
==============
*/
void CL_Main_InitClient(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v2; 
  int ControllerFromClient; 
  __int64 v4; 
  int v5; 
  __int64 v6; 
  int v7; 

  v1 = localClientNum;
  Com_Printf(14, "----- Common Client Initialization %i -----\n", (unsigned int)localClientNum);
  if ( (unsigned int)v1 >= 2 )
  {
    v7 = 2;
    v5 = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v5, v7) )
      __debugbreak();
  }
  v2 = v1;
  if ( (unsigned int)v1 >= 2 )
  {
    LODWORD(v6) = 2;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 195, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v4, v6) )
      __debugbreak();
  }
  Com_Printf(14, "CL_SetLocalConnectionState %i -> %i.\n", (unsigned int)clientUIActives[v2].connectionState, 0i64);
  clientUIActives[v2].connectionState = CA_DISCONNECTED;
  Online_Telemetry_ResetInputSession((const LocalClientNum_t)v1);
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)v1);
  Cbuf_Execute((LocalClientNum_t)v1, ControllerFromClient);
  clientUIActives[v2].isRunning = 1;
  clientUIActives[v2].lastInputType = GAMEPAD;
  Com_Printf(14, "-----------------------\n");
}

/*
==============
CL_Main_InitDevGUI
==============
*/
void CL_Main_InitDevGUI(GameModeType gameMode)
{
  char v1; 
  int v2; 
  const char *v3; 
  const char *v4; 

  v1 = gameMode;
  if ( !cls.devGuiStarted )
  {
    DevGui_Init();
    Cmd_AddCommandInternal("devgui_dvar", CL_Main_DevGuiDvar_f, &CL_Main_DevGuiDvar_f_VAR);
    Cmd_AddCommandInternal("devgui_cmd", CL_Main_DevGuiCmd_f, &CL_Main_DevGuiCmd_f_VAR);
    Cmd_AddCommandInternal("devgui_open", CL_Main_DevGuiOpen_f, &CL_Main_DevGuiOpen_f_VAR);
    switch ( v1 )
    {
      case 1:
        v2 = 44;
        v3 = "devgui_sp";
        v4 = "devgui_maps_sp";
        break;
      case 2:
        v2 = 7;
        v3 = "devgui_mp";
        v4 = "devgui_maps_mp";
        break;
      case 3:
        v2 = 7;
        v3 = "devgui_cp";
        v4 = "devgui_maps_cp";
        break;
      default:
        v2 = 0;
        v3 = NULL;
        v4 = NULL;
        break;
    }
    CL_CreateDevGui(v2, v3, v4);
    cls.devGuiStarted = 1;
  }
}

/*
==============
CL_Main_InitOnceForAllClients
==============
*/
void CL_Main_InitOnceForAllClients(void)
{
  unsigned int v0; 
  const char *v1; 

  Com_Printf(14, "----- All Clients Initialization -----\n");
  cls.realtime = 0;
  v0 = Sys_MillisecondsRaw();
  srand(v0);
  Con_Init();
  Dvar_BeginPermanentRegistration();
  v1 = SEH_SafeTranslateString("PLATFORM/NOMOTD");
  DVARSTR_motd = Dvar_RegisterString("NONSLROPSR", v1, 0, "Message of the day");
  DVARSTR_motd_title = Dvar_RegisterString("MLKLTQRSPM", (const char *)&queryFormat.fmt + 3, 0, "Message of the day title.");
  DVARSTR_motd_icon = Dvar_RegisterString("NOQQMMQMMR", (const char *)&queryFormat.fmt + 3, 0, "Message of the day icon.");
  Dvar_EndPermanentRegistration();
  Cmd_AddClientCommandList(CLIENT_COMMAND_LIST, 0x10u);
  Cmd_AddServerCommandList(SERVER_COMMAND_LIST, 1u);
  PlayercardCache_RegisterCommands();
  GamerProfile_RegisterCommands();
  CL_XB3_RegisterCommands();
  CL_Debug_RegisterCommands();
  CL_Input_RegisterCommands();
  CL_UIStreaming_RegisterCommands();
  UI_AutoNavigation_RegisterCmds();
  Ragdoll_Init();
  Ragdoll_SetCallbacks(CG_RagdollCallback_EnterRunning, CG_RagdollCallback_UpdateRunning, CG_RagdollCallback_ExitRunning);
  CL_Screen_Init();
  CL_Input_AutomatedInput_Init();
  Com_Printf(14, "----- All Clients Initialization Complete -----\n");
}

/*
==============
CL_Main_InitRef
==============
*/
void CL_Main_InitRef(void)
{
  GfxConfiguration config; 

  Com_Printf(14, "----- Initializing Renderer ----\n");
  *(_DWORD *)&config.inited = 0;
  config.maxClientViews = 2;
  *(_DWORD *)&config.defaultFullscreen = 131073;
  config.maxClientRenderViews = 4;
  config.entCount = 2560;
  config.entnumNone = 2047;
  config.entnumOrdinaryEnd = 2046;
  config.threadContextCount = 28;
  config.critSectCount = 116;
  R_ConfigureRenderer(&config);
  if ( cl_paused )
    CL_Pause_UnpauseGame();
}

/*
==============
CL_Main_InitRenderer
==============
*/
void CL_Main_InitRenderer(void)
{
  const char *v1; 
  GfxFont *v5; 

  if ( cls.rendererStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 972, ASSERT_TYPE_ASSERT, "(!cls.rendererStarted)", (const char *)&queryFormat, "!cls.rendererStarted") )
    __debugbreak();
  cls.rendererStarted = 1;
  R_BeginRegistration(&cls.vidConfig);
  if ( cls.rendererStarted )
  {
    ScrPlace_SetupFullscreenViewports();
    ScrPlace_SetupClientViewports();
    if ( CL_AnyLocalClientStateActive() )
      CL_SetupScreenPlacements();
  }
  cls.whiteMaterial = Material_RegisterHandle("white", IMAGE_TRACK_UI);
  cls.consoleMaterial = Material_RegisterHandle("console", IMAGE_TRACK_UI);
  if ( cls.vidConfig.sceneHeight <= 0x438 )
  {
    _RBX = DCONST_DVARFLT_cl_devguiFontScaleHD;
    if ( DCONST_DVARFLT_cl_devguiFontScaleHD )
      goto LABEL_14;
    v1 = "cl_devguiFontScaleHD";
  }
  else
  {
    _RBX = DCONST_DVARFLT_cl_devguiFontScaleUHD;
    if ( DCONST_DVARFLT_cl_devguiFontScaleUHD )
      goto LABEL_14;
    v1 = "cl_devguiFontScaleUHD";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v1) )
    __debugbreak();
LABEL_14:
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmulss  xmm0, xmm0, cs:__real@41900000
    vcvttss2si rdx, xmm0; pixelHeight
  }
  cls.consoleFont = R_RegisterFont("fonts/fira_mono_regular.ttf", _RDX);
  cls.smallDevFont = R_RegisterFont("fonts/fira_mono_bold.ttf", 14);
  v5 = R_RegisterFont("fonts/fira_mono_bold.ttf", 26);
  __asm { vmovss  xmm0, cs:?g_console_char_height@@3MA; float g_console_char_height }
  cls.bigDevFont = v5;
  g_consoleField.fixedSize = 1;
  g_console_field_width = cls.vidConfig.displayWidth - 40;
  g_consoleField.widthInPixels = cls.vidConfig.displayWidth - 40;
  __asm { vmovss  cs:?g_consoleField@@3Ufield_t@@A.charHeight, xmm0; field_t g_consoleField }
  StatMon_Reset();
  Con_InitClientAssets();
}

/*
==============
CL_Main_InvalidateSkeletonCache
==============
*/
void CL_Main_InvalidateSkeletonCache(void)
{
  signed __int32 i; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 792, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( ((unsigned __int8)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
    __debugbreak();
  for ( i = _InterlockedCompareExchange(&s_SkeletonCacheValidityLock, 2, 0); i; i = _InterlockedCompareExchange(&s_SkeletonCacheValidityLock, 2, 0) )
  {
    if ( i == 2 )
      break;
    if ( GetCurrentProcessorNumber() == 1 )
      Sys_PushUnblockDatabaseThread();
    Sys_Sleep(1);
    if ( GetCurrentProcessorNumber() == 1 )
      Sys_PopUnblockDatabaseThread();
    if ( ((unsigned __int64)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
      __debugbreak();
  }
  cls.skelValid = 0;
}

/*
==============
CL_Main_IsBRGameType
==============
*/
bool CL_Main_IsBRGameType(const LocalClientNum_t localClientNum)
{
  bool result; 
  const dvar_t *v2; 

  if ( CL_GetLocalClientGameConnectionState(localClientNum) >= CA_LOADING )
    return cls.m_activeGameTypeQuick[0] == 1;
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_AIM|0x100) )
    return 0;
  v2 = DVARSTR_ui_gametype;
  if ( !DVARSTR_ui_gametype && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ui_gametype") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  result = BG_GetGameTypeQuickForName(v2->current.string);
  if ( !result )
    return 0;
  return result;
}

/*
==============
CL_Main_IsGameClientLocal
==============
*/
char CL_Main_IsGameClientLocal(int clientNum)
{
  unsigned int v1; 
  cg_t **v3; 
  connstate_t *i; 
  __int64 v6; 
  __int64 v7; 

  v1 = 0;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
    return 0;
  v3 = cg_t::ms_cgArray;
  for ( i = &clientUIActives[0].connectionState; ; i += 110 )
  {
    if ( v1 >= 2 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( *(int *)i > 7 )
    {
      if ( v1 >= cg_t::ms_allocatedCount )
      {
        LODWORD(v7) = cg_t::ms_allocatedCount;
        LODWORD(v6) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( !*v3 )
      {
        LODWORD(v7) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v7) )
          __debugbreak();
      }
      if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
      {
        LODWORD(v7) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v7) )
          __debugbreak();
      }
      if ( (*v3)->clientNum == clientNum )
        break;
    }
    ++v1;
    ++v3;
    if ( (int)v1 >= SLODWORD(cl_maxLocalClients) )
      return 0;
  }
  return 1;
}

/*
==============
CL_Main_IsOnlineGame
==============
*/
__int64 CL_Main_IsOnlineGame()
{
  const dvar_t *v0; 

  if ( SLODWORD(cl_maxLocalClients) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 325, ASSERT_TYPE_ASSERT, "(cl_maxLocalClients > 0)", "%s\n\tThis function can only be called for an active game context", "cl_maxLocalClients > 0") )
    __debugbreak();
  if ( Com_FrontEndScene_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 326, ASSERT_TYPE_ASSERT, "(!Com_FrontEndScene_IsActive())", "%s\n\tCannot be used while the frontr-end scene is active", "!Com_FrontEndScene_IsActive()") )
    __debugbreak();
  v0 = DVARBOOL_onlinegame;
  if ( !DVARBOOL_onlinegame && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "onlinegame") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CL_Main_IsServerLoadingMap
==============
*/
_BOOL8 CL_Main_IsServerLoadingMap()
{
  return cl_serverLoadingMap;
}

/*
==============
CL_Main_IsSplitscreenGame
==============
*/
__int64 CL_Main_IsSplitscreenGame()
{
  const dvar_t *v0; 

  if ( SLODWORD(cl_maxLocalClients) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 343, ASSERT_TYPE_ASSERT, "(cl_maxLocalClients > 0)", "%s\n\tThis function can only be called for an active game context", "cl_maxLocalClients > 0") )
    __debugbreak();
  if ( Com_FrontEndScene_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 344, ASSERT_TYPE_ASSERT, "(!Com_FrontEndScene_IsActive())", "%s\n\tCannot be used while the frontr-end scene is active", "!Com_FrontEndScene_IsActive()") )
    __debugbreak();
  v0 = DVARBOOL_splitscreen;
  if ( !DVARBOOL_splitscreen && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "splitscreen") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CL_Main_IsSystemLinkGame
==============
*/
__int64 CL_Main_IsSystemLinkGame()
{
  const dvar_t *v0; 

  if ( SLODWORD(cl_maxLocalClients) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 334, ASSERT_TYPE_ASSERT, "(cl_maxLocalClients > 0)", "%s\n\tThis function can only be called for an active game context", "cl_maxLocalClients > 0") )
    __debugbreak();
  if ( Com_FrontEndScene_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 335, ASSERT_TYPE_ASSERT, "(!Com_FrontEndScene_IsActive())", "%s\n\tCannot be used while the frontr-end scene is active", "!Com_FrontEndScene_IsActive()") )
    __debugbreak();
  v0 = DVARBOOL_systemlink;
  if ( !DVARBOOL_systemlink && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "systemlink") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CL_Main_IsUIActive
==============
*/
bool CL_Main_IsUIActive(const LocalClientNum_t localClientNum)
{
  return 0;
}

/*
==============
CL_Main_ReInitDevGUI
==============
*/
void CL_Main_ReInitDevGUI(GameModeType gameMode)
{
  unsigned __int8 v1; 

  v1 = gameMode;
  if ( cls.devGuiStarted )
  {
    CL_DestroyDevGui();
    DevGui_Shutdown();
    Cmd_RemoveCommand("devgui_dvar");
    Cmd_RemoveCommand("devgui_cmd");
    Cmd_RemoveCommand("devgui_open");
    cls.devGuiStarted = 0;
  }
  CL_Main_InitDevGUI((GameModeType)v1);
}

/*
==============
CL_Main_RegisterCommonDvars
==============
*/

void __fastcall CL_Main_RegisterCommonDvars(__int64 a1, __int64 a2, double _XMM2_8)
{
  const dvar_t *v34; 
  const dvar_t *v38; 
  const dvar_t *v46; 
  const dvar_t *v72; 
  const dvar_t *v79; 
  const dvar_t *v86; 
  const dvar_t *v110; 
  const dvar_t *v114; 
  const dvar_t *v118; 
  const dvar_t *v145; 
  const dvar_t *v152; 
  const dvar_t *v156; 
  const dvar_t *v164; 
  const dvar_t *v173; 
  const dvar_t *v184; 
  const dvar_t *v188; 
  const dvar_t *v192; 
  const dvar_t *v196; 
  const dvar_t *v200; 
  const dvar_t *v204; 
  const dvar_t *v208; 
  const dvar_t *v212; 
  const dvar_t *v216; 
  const dvar_t *v223; 
  const dvar_t *v230; 
  float flags; 
  float flagsa; 
  float flagsb; 
  float flagsc; 
  char v266; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm12
    vmovaps xmmword ptr [rax-78h], xmm13
    vmovaps [rsp+0D8h+var_88], xmm14
    vmovaps [rsp+0D8h+var_98], xmm15
  }
  Dvar_BeginPermanentRegistration();
  __asm
  {
    vmovss  xmm10, cs:__real@3f800000
    vmovss  xmm6, cs:__real@3f666666
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_safeArea_horizontal = Dvar_RegisterFloat("MPPPPOKORK", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Horizontal safe area as a fraction of the screen width");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_safeArea_vertical = Dvar_RegisterFloat("NPPTKLOOLO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Vertical safe area as a fraction of the screen height");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_safeArea_adjusted_horizontal = Dvar_RegisterFloat("NQTKNOPLSP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x2000u, "User-adjustable horizontal safe area as a fraction of the screen width");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
    vmovss  xmm9, cs:__real@7f7fffff
  }
  DVARFLT_safeArea_adjusted_vertical = Dvar_RegisterFloat("MRMTSPOKQP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x2000u, "User-adjustable vertical safe area as a fraction of the screen height");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vmovaps xmm2, xmm10; min
    vmovaps xmm1, xmm10; value
  }
  DVARFLT_cg_hudLegacySplitscreenScale = Dvar_RegisterFloat("LRKQTOTOPQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Screen scale for hud elements in splitscreen");
  DVARBOOL_cg_hudSplitscreenOffsetsUseScale = Dvar_RegisterBool("QPOKQTQRQ", 0, 0, "Use splitscreen scaling for element offsets");
  DVARBOOL_cl_voice = Dvar_RegisterBool("LPOPTLTKR", 1, 0x200u, "Use voice communications");
  DVARBOOL_cl_voice_mute = Dvar_RegisterBool("LOOTLTLRNN", 0, 0, "Mute all voice communications");
  DVARINT_cl_shownet = Dvar_RegisterInt("NLTMKNTMSL", 0, -2, 4, 0, "Display network debugging information");
  DVARBOOL_cl_showServerCommands = Dvar_RegisterBool("NRRRMMSOLP", 0, 0, "Enable debug prints for server commands");
  DVARBOOL_cl_showSend = Dvar_RegisterBool("MTQNSLQMPS", 0, 0, "Enable debugging information for sent commands");
  __asm
  {
    vmovss  xmm3, cs:__real@438c0000; max
    vmovss  xmm1, cs:__real@430c0000; value
  }
  DVARBOOL_cl_skipFNFVersionCheck = Dvar_RegisterBool("NTSTSTRPTO", 0, 0, "Ignore version check for FNF builds");
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  v34 = Dvar_RegisterFloat("LMTTMSNLLR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Max yaw speed in degrees for game pad and keyboard");
  __asm
  {
    vmovss  xmm3, cs:__real@438c0000; max
    vmovss  xmm1, cs:__real@430c0000; value
  }
  DVARFLT_cl_yawspeed = v34;
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  v38 = Dvar_RegisterFloat("MPOPKKONQO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Max pitch speed in degrees for game pad");
  __asm
  {
    vmovss  xmm3, cs:__real@40a00000; max
    vmovss  xmm1, cs:__real@3fc00000; value
  }
  DVARFLT_cl_pitchspeed = v38;
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  DVARFLT_cl_anglespeedkey = Dvar_RegisterFloat("MNKMMQMSOS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Multiplier for max angle speed for game pad and keyboard");
  __asm
  {
    vmovss  xmm8, cs:__real@bf800000
    vmovss  xmm1, cs:__real@3cb43958; value
  }
  DVARBOOL_cl_showmouserate = Dvar_RegisterBool("MQSTRMLMST", 0, 0, "Print mouse rate debugging information to the console");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm8; min
  }
  v46 = Dvar_RegisterFloat("MRKQKRMMMP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Default pitch");
  __asm { vmovss  xmm1, cs:__real@3cb43958; value }
  DVARFLT_m_pitch = v46;
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm8; min
    vmovss  xmm6, cs:__real@3e800000
  }
  DVARFLT_m_yaw = Dvar_RegisterFloat("LKNSOOTMTM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Default yaw");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_m_forward = Dvar_RegisterFloat("NMSMNMKNSK", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Forward speed in units per second");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_m_side = Dvar_RegisterFloat("MTNMKMKKRQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Sideways motion in units per second");
  DCONST_DVARINT_cl_specialOffhandDelay = Dvar_RegisterInt("cl_specialOffhandDelay", 60, 0, 500, 0x40004u, "Delay offhand to allow double bumper special offhand");
  DVARINT_ac_test_value = Dvar_RegisterInt("OLONTONOPK", 1, 0, 0x7FFFFFFF, 0, "Test functionality");
  DVARINT_session_join_min_time = Dvar_RegisterInt("NTLOSSSOTR", 4000, 0, 10000, 0, "Minimum number of milliseconds between join attempts");
  DVARBOOL_cl_textChatEnabled = Dvar_RegisterBool("NLPSQMQRTP", 0, 0, "Do we want to use the old in-game text chat");
  DCONST_DVARINT_cl_transient_max_load_zones = Dvar_RegisterInt("cl_transient_max_load_zones", 8, 1, 100, 0x40004u, "Sets the number of zone loads that can occur at once before a PostLoad() is processed");
  DCONST_DVARINT_cl_transient_max_load_zones_fe = Dvar_RegisterInt("cl_transient_max_load_zones_fe", 32, 1, 100, 0x40004u, "Sets the number of zone loads that can occur at once before a PostLoad() is processed. Frontend number.");
  DCONST_DVARBOOL_cl_transient_cancel_load_zones = Dvar_RegisterBool("cl_transient_cancel_load_zones", 1, 0x40004u, "Enables or disables canceling of transient fastfiles that are no longer required but are busy loading");
  DCONST_DVARBOOL_cl_transient_pause_load_zones = Dvar_RegisterBool("cl_transient_pause_load_zones", 0, 0x40004u, "Enables or disables pausing of low priority transient zones to allow high priority zones to load");
  DVARBOOL_cl_transient_sp_yield_for_streamer = Dvar_RegisterBool("MQPSPTNLLP", 1, 0x40u, "Enables or disables yielding the SP transient file loads to allow the image streamer time to load images (SP transient)");
  DVARBOOL_cl_transient_sp_streamer_syncflush = Dvar_RegisterBool("LORKLOOKKT", 1, 0x40u, "Enables or disables a hard sync and flush of the streamer with each SP client transient sync");
  DCONST_DVARINT_cl_transient_sp_stream_minimum_time = Dvar_RegisterInt("cl_transient_sp_stream_minimum_time", 6000, 0, 0x7FFFFFFF, 0x40004u, "The minimum amount of time in ms to stay in the streaming state to prevent bouncing around quickly (SP transient)");
  DCONST_DVARINT_cl_transient_sp_yield_minimum_time = Dvar_RegisterInt("cl_transient_sp_yield_minimum_time", 1000, 0, 0x7FFFFFFF, 0x40004u, "The minimum amount of time in ms to stay in the yielded state to prevent bouncing around quickly (SP transient)");
  __asm
  {
    vmovss  xmm7, cs:__real@41800000
    vmovss  xmm1, cs:__real@3d800000; value
  }
  DCONST_DVARINT_cl_transient_sp_yield_timeout = Dvar_RegisterInt("cl_transient_sp_yield_timeout", 2000, 0, 0x7FFFFFFF, 0x40004u, "The maximum amount of time in ms to yield to the image streamer before resuming file loads (SP transient)");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARFLT_cl_transient_sp_yield_start_priority = Dvar_RegisterFloat("LOSLTNTQT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40u, "The priority threshold expressed as a stream distance metric where the file loading will yield to the image streamer (SP transient)");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_cl_transient_sp_yield_end_priority = Dvar_RegisterFloat("OKTKQKMTSQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40u, "The priority threshold expressed as a stream distance metric to end the yield, to avoid bouncing around states (SP transient)");
  __asm
  {
    vmovss  xmm15, cs:__real@41200000
    vmovss  xmm12, cs:__real@3c23d70a
  }
  DVARBOOL_cl_transient_mp_streamer_interrupt_enabled = Dvar_RegisterBool("LLLPMRSLLN", 1, 0, "Enables the DB to schedule high priority fastfile loads before yielding to the streamer.");
  __asm
  {
    vmovaps xmm3, xmm8; min
    vmovaps xmm2, xmm12; y
    vmovaps xmm1, xmm15; x
    vmovss  [rsp+0D8h+flags], xmm15
  }
  DVARVEC2_cl_transient_mp_yield_to_streamer_quality_threshold = Dvar_RegisterVec2("OMSNMNMOKN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flags, 0, "Only yield to streamer if image quality is below the number specified here (when moving at max speed or greater, -1 means don't yield)");
  DVARINT_cl_transient_mp_yield_timeout_at_max_velocity = Dvar_RegisterInt("NRPRQKQTLQ", 250, 0, 0x7FFFFFFF, 0, "The maximum amount of time in ms to yield to the image streamer before resuming file loads for multiplayer when the camera is moving at 'max' speed");
  DVARINT_cl_transient_mp_yield_timeout_at_mid_velocity = Dvar_RegisterInt("NMROPTKMTQ", 500, 0, 0x7FFFFFFF, 0, "The maximum amount of time in ms to yield to the image streamer before resuming file loads for multiplayer  when the camera is moving at our 'mid' speed");
  __asm
  {
    vmovss  xmm3, cs:__real@44fa0000; max
    vmovss  xmm1, cs:__real@44340000; value
  }
  DVARINT_cl_transient_mp_yield_timeout_at_min_velocity = Dvar_RegisterInt("NOKLQNLNKQ", 2000, 0, 0x7FFFFFFF, 0, "The maximum amount of time in ms to yield to the image streamer before resuming file loads for multiplayer  when the camera is not moving");
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  v72 = Dvar_RegisterFloat("MPPNKPSNKM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Mid velocity - use mid timeout. Faster == lower timeout.");
  __asm
  {
    vmovss  xmm3, cs:__real@44fa0000; max
    vmovss  xmm1, cs:__real@44898000; value
  }
  DVARFLT_cl_transient_mp_yield_mid_velocity = v72;
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  DVARFLT_cl_transient_mp_yield_max_velocity = Dvar_RegisterFloat("NQPTNLRTPO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Max velocity - use max timeout. Faster == lower timeout.");
  DVARINT_cl_transient_mp_yield_priority_timeout = Dvar_RegisterInt("NMRKPSTNQO", 200, 0, 0x7FFFFFFF, 0, "The maximum amount of time in ms to yield to the image streamer when high priority loads are outstanding before resuming file loads for multiplayer");
  DVARBOOL_cl_transient_mp_yield_for_streamer_zoom_enabled = Dvar_RegisterBool("OLPOMMRMNL", 1, 0, "Enables or disables a yield timeout to the image streamer when zoom / ads");
  __asm
  {
    vmovss  xmm2, cs:__real@3a83126f; y
    vmovss  xmm1, cs:__real@3d000000; x
  }
  DVARINT_cl_transient_mp_yield_timeout_zoom = Dvar_RegisterInt("LRNOTROKT", 250, 0, 0x7FFFFFFF, 0, "The maximum amount of time in ms to yield to the image streamer when zoom / ads before resuming file loads for multiplayer");
  __asm
  {
    vxorps  xmm3, xmm3, xmm3; min
    vmovss  [rsp+0D8h+flags], xmm7
  }
  v79 = Dvar_RegisterVec2("LORRMQTSRS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsa, 0, "Minimum image streaming quality before loading medium tiles when the camera is moving at 'max' speed");
  __asm
  {
    vmovss  xmm2, cs:__real@3ba3d70a; y
    vmovss  xmm1, cs:__real@3f400000; x
  }
  DVARVEC2_cl_transient_mp_yield_medium_priority = v79;
  __asm
  {
    vxorps  xmm3, xmm3, xmm3; min
    vmovss  [rsp+0D8h+flags], xmm7
  }
  DVARVEC2_cl_transient_mp_yield_far_priority = Dvar_RegisterVec2("TPSOSKNMM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsb, 0, "Minimum image streaming quality before loading far tiles when the camera is moving at 'max' speed");
  DCONST_DVARBOOL_cl_transientCommon_debugVerbose = Dvar_RegisterBool("cl_transientCommon_debugVerbose", 0, 0x40004u, "Enable to log development debug messages to the console");
  DVARBOOL_cl_transientCommon_debugDump = Dvar_RegisterBool("MKSTMNQRLS", 0, 4u, "Enable to dump the currently request common mp transient assets");
  DCONST_DVARINT_cl_transientCommon_debugListLoadingAssets = Dvar_RegisterInt("cl_transientCommon_debugListLoadingAssets", 0, 0, 50, 0x40004u, "Set the number of in-progress transient loads to display");
  DCONST_DVARBOOL_cl_transientCommon_memoryBudgetStrictlyEnforced = Dvar_RegisterBool("cl_transientCommon_memoryBudgetStrictlyEnforced", 0, 0x40004u, "If enabled, CL_TransientsCommonMP will reject the request to load an asset if it would cause us to exceed our memory budget for MPCommon transients.");
  DCONST_DVARINT_cl_transientCommon_cpMemoryBudgetMB = Dvar_RegisterInt("cl_transientCommon_cpMemoryBudgetMB", 125, 0, 1000, 0x40004u, "Memory budget in MB of all transient MPCommon assets in CP");
  DCONST_DVARINT_cl_transientCommon_mpMemoryBudgetMB = Dvar_RegisterInt("cl_transientCommon_mpMemoryBudgetMB", 250, 0, 1000, 0x40004u, "Memory budget in MB of all transient MPCommon assets in MP");
  DCONST_DVARINT_cl_transientCommon_mpLPCMemoryBudgetMB = Dvar_RegisterInt("cl_transientCommon_mpLPCMemoryBudgetMB", 150, 0, 1000, 0x40004u, "Memory budget in MB of all transient MPCommon assets in large player count MP maps.");
  DCONST_DVARBOOL_cl_transientCommon_drawBudgets = Dvar_RegisterBool("cl_transientCommon_drawBudgets", 0, 0x40004u, "Draw transient common memory budgets per asset type");
  DCONST_DVARBOOL_cl_transientCommon_devAllowHeads = Dvar_RegisterBool("cl_transientCommon_devAllowHeads", 1, 0x40004u, "Disable to suppress loading any head models");
  DCONST_DVARBOOL_cl_transientCommon_devAllowBodies = Dvar_RegisterBool("cl_transientCommon_devAllowBodies", 1, 0x40004u, "Disable to suppress loading any body models");
  DCONST_DVARBOOL_cl_transientCommon_devAllowWeapons = Dvar_RegisterBool("cl_transientCommon_devAllowWeapons", 1, 0x40004u, "Disable to suppress loading any weapon models");
  DCONST_DVARBOOL_cl_transientCommon_devAllowViewArms = Dvar_RegisterBool("cl_transientCommon_devAllowViewArms", 1, 0x40004u, "Disable to suppress loading any view arm models");
  DCONST_DVARBOOL_cl_transientCommon_devAllowViewWeapons = Dvar_RegisterBool("cl_transientCommon_devAllowViewWeapons", 1, 0x40004u, "Disable to suppress loading any view weapon models");
  DVARBOOL_cl_preload_sp_yield_for_streamer = Dvar_RegisterBool("LOONNQSTSM", 1, 0x40u, "Enables or disables yielding the SP preload file loads to allow the image streamer time to load images (SP preload)");
  DVARINT_cl_preload_sp_yield_timeout = Dvar_RegisterInt("NMSTSKPRQQ", 3000, 0, 0x7FFFFFFF, 0x40u, "The maximum amount of time in ms to yield to the image streamer before resuming file loads (SP preload)");
  DVARINT_cl_preload_sp_stream_minimum_time = Dvar_RegisterInt("LMQPRMTOSO", 6000, 0, 0x7FFFFFFF, 0x40u, "The minimum amount of time in ms to stay in the streaming state to prevent bouncing around quickly (SP preload)");
  __asm { vmovss  xmm1, cs:__real@3d000000; value }
  DVARINT_cl_preload_sp_yield_minimum_time = Dvar_RegisterInt("LQRMTPPMQP", 1000, 0, 0x7FFFFFFF, 0x40u, "The minimum amount of time in ms to stay in the yielded state to prevent bouncing around quickly (SP preload)");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v86 = Dvar_RegisterFloat("NSPQSTSNOK", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40u, "The priority threshold expressed as a stream distance metric where the file loading will yield to the image streamer (SP preload)");
  __asm { vmovss  xmm1, cs:__real@3e000000; value }
  DVARFLT_cl_preload_sp_yield_start_priority = v86;
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARFLT_cl_preload_sp_yield_end_priority = Dvar_RegisterFloat("NTLOROTPQR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40u, "The priority threshold expressed as a stream distance metric to end the yielding, to avoid bouncing around states (SP preload)");
  DVARINT_cl_preload_sp_yield_delay_time = Dvar_RegisterInt("NMMNPNLLQM", 1000, 0, 60000, 4u, "Sets the delay time to apply when the server requests that we don't yield for a while");
  DCONST_DVARINT_cl_transient_mp_cost_threshold = Dvar_RegisterInt("cl_transient_mp_cost_threshold", 20971520, 0, 0x20000000, 0x40004u, "The cost threshold in bytes for putting fastfiles in a batch.");
  DCONST_DVARINT_cl_transient_mp_printVerbosity = Dvar_RegisterInt("cl_transient_mp_printVerbosity", 1, 0, 1, 0x40004u, "Controls the amount of MP world transient status prints.  0=disable, 1=enable");
  DVARBOOL_cl_keybinding_experiment_enabled = Dvar_RegisterBool("MNNMPMRSLT", 0, 0, "Whether or not the keybindings experiment is active");
  DVARBOOL_cl_use_experimental_default_keybindings = Dvar_RegisterBool("TKNOSKTON", 0, 0, "Whether or not the user should load the experimental default keybindings store in experimental_default_keys.cfg");
  DVARBOOL_cl_has_enrolled_in_keybindings_experiment = Dvar_RegisterBool("NPMRNRNPPT", 0, 0, "Whether or not the user has enrolled in the keybinding experiment");
  DVARBOOL_scriptable_entity_parenting = Dvar_RegisterBool("NMLQLKNPRP", 1, 0, "Enable runtime scriptable parenting support");
  DVARBOOL_cg_entityWorkers_missilesEnabled = Dvar_RegisterBool("RQQORRRQT", 1, 0, "When enabled, ET_MISSILE entities will be threaded off in entity workers");
  DVARBOOL_cg_enableAgentEntityWorkers = Dvar_RegisterBool("NTPOKONPNQ", 1, 0, "Enable distributed entity processing for agents and agent corpses.");
  DVARBOOL_cg_customizationStreaming_highPriorityCorpses = Dvar_RegisterBool("NNMTTPLMKN", 1, 0, "Killswitch to disable to elevated prioritization for high priority corpses");
  DVARBOOL_cg_prematch_playerVisbilityRequiresCharacterModels = Dvar_RegisterBool("LQLTOQSRNO", 1, 0, "Hides the player during the prematch countdown if their weapon models are not loaded.");
  DVARBOOL_cg_prematch_playerVisbilityRequiresWeaponModels = Dvar_RegisterBool("MPKLOLKTLR", 0, 0, "Hides the player during the prematch countdown if their character models are not loaded (body + all attach models).");
  __asm
  {
    vmovss  xmm14, cs:__real@42c80000
    vmovss  xmm3, cs:__real@461c4000; max
  }
  DVARBOOL_cg_umbraWorstCaseMinObjectContributionEnabled = Dvar_RegisterBool("QTMTSNTNO", 0, 0, "Enables setting the rg.umbraWorstCaseMinObjectContribution if we think we may be in a scenario where we will hit the vert buffer limit to avoid missing important geo.");
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm14; value
  }
  DCONST_DVARFLT_cg_umbraWorstCaseMinObjectContributionValue = Dvar_RegisterFloat("cg_umbraWorstCaseMinObjectContributionValue", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "The value used for rg.umbraWorstCaseMinObjectContribution if we think we may be in a scenario where we will hit the vert buffer limit to avoid missing important geo.");
  DVARBOOL_cg_entityResetPhysicsFixEnabled = Dvar_RegisterBool("LMOTKRTOKP", 1, 0, "killswitch for a fix that has had little testing.");
  DVARBOOL_cg_weaponStreaming_enableWorldClientModels = Dvar_RegisterBool("LPOPSQLKT", 1, 0, "Killswitch for client-model driven world weapons for streaming");
  DVARBOOL_cg_weaponStreaming_enableWorldScriptableLoot = Dvar_RegisterBool("SQKMQKTOT", 1, 0, "Killswitch for scriptable loot driven world weapons for streaming");
  __asm { vmovss  xmm1, cs:__real@44480000; value }
  DVARBOOL_cg_weaponStreaming_enableWorldWeaponMap = Dvar_RegisterBool("NMRROQTQQQ", 1, 0, "Killswitch for WeaponMap driven world weapons for streaming");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARFLT_cg_weaponStreaming_scriptableLootRadius = Dvar_RegisterFloat("OKTNRQQMNS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Radius at which we start predictively streaming scriptable loot.");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm10; value
  }
  DCONST_DVARFLT_cg_small_dev_string_fontscale = Dvar_RegisterFloat("cg_small_dev_string_fontscale", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Font scale for a small development only display string");
  DVARBOOL_cg_playerLegsDObjFixActive = Dvar_RegisterBool("LLRLORNPMS", 1, 0, "Killswitch/activation of player legs dobj model fix (IWH-286590). Default is true (fix is active).");
  DCONST_DVARBOOL_cl_devLoadPlayerCards = Dvar_RegisterBool("cl_devLoadPlayerCards", 1, 0x40004u, "When set, loads random player cards for default profiles and any unoccupied party member slots to simulate image streaming load.");
  DVARBOOL_cl_anonymization_enabled = Dvar_RegisterBool("QNOOPTKTT", 1, 0, "Anonymization feature killswitch; true: feature enabled, false: feature disabled.");
  DVARBOOL_cl_anonymization_useSimpleNames = Dvar_RegisterBool("QORQLMRPP", 0, 4u, "Use simple names (e.g., Anon#42069) vs use randomized bot names from mp/namesTable.csv (e.g., Smith#558)");
  DVARBOOL_cl_anonymization_genericGameMessages = Dvar_RegisterBool("LSTTSQNTKP", 1, 4u, "Anonymize game messages sent by the server with generic messages (e.g., \"<gamertag> left the game\" becomes \"A player left the game\"");
  DVARBOOL_cl_combinedCameraRotationSpeed = Dvar_RegisterBool("NMOLNMOSOM", 0, 0, "This triggers the mouse accumulated input treatment with the max rotation setting");
  DVARBOOL_cg_playerNameplateUsePlayerVisibilityCrosshairsTest = Dvar_RegisterBool("MPTSLQLRR", 1, 0, "Killswitch/activation to use new cg_player_visibility module for nameplate 'crosshairs' test.");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovss  xmm2, cs:__real@38d1b717; min
    vmovss  xmm1, cs:__real@3f4ccccd; value
  }
  DVARFLT_cl_analog_attack_threshold = Dvar_RegisterFloat("MMKKOSTMSO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "The threshold before firing");
  __asm
  {
    vmovss  xmm3, cs:__real@3f7d70a4; max
    vmovss  xmm1, cs:__real@3f19999a; value
  }
  DCONST_DVARINT_cl_weaponToggleAltModeHoldTime = Dvar_RegisterInt("cl_weaponToggleAltModeHoldTime", 200, 0, 10000, 0x40004u, "The time to hold the weapon next button before the player toggles the weapon's alt mode.");
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm8, cs:__real@3dcccccd
  }
  DCONST_DVARFLT_cl_dirSelMinStickThreshold = Dvar_RegisterFloat("cl_dirSelMinStickThreshold", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Ignore stick controls if the stick deflection less than this while selecting a direction on the map.");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vmovaps xmm2, xmm12; min
    vmovaps xmm1, xmm8; value
  }
  v110 = Dvar_RegisterFloat("cl_dirSelConvergeTimeGross", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Time to converge to the new direction when far from that direction while selecting a direction on the map.");
  __asm { vmovss  xmm1, cs:__real@3e99999a; value }
  DCONST_DVARFLT_cl_dirSelConvergeTimeGross = v110;
  __asm
  {
    vmovaps xmm3, xmm9; max
    vmovaps xmm2, xmm12; min
  }
  v114 = Dvar_RegisterFloat("cl_dirSelConvergeTimePrecise", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Time to converge to the new direction when near to that direction while selecting a direction on the map.");
  __asm
  {
    vmovss  xmm3, cs:__real@43340000; max
    vmovss  xmm1, cs:__real@41f00000; value
  }
  DCONST_DVARFLT_cl_dirSelConvergeTimePrecise = v114;
  __asm { vxorps  xmm2, xmm2, xmm2; min }
  v118 = Dvar_RegisterFloat("cl_dirSelPreciseOuterAngle", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Outer bounds of the precise angle range while selecting a direction on the map. The coverge time lerps between the inner and outer bounds.");
  __asm
  {
    vmovss  xmm3, cs:__real@43340000; max
    vmovss  xmm1, cs:__real@41700000; value
  }
  DCONST_DVARFLT_cl_dirSelPreciseOuterAngle = v118;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm12, cs:__real@40000000
  }
  DCONST_DVARFLT_cl_dirSelPreciseInnerAngle = Dvar_RegisterFloat("cl_dirSelPreciseInnerAngle", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Inner bounds of the precise angle range while selecting a direction on the map. The coverge time lerps between the inner and outer bounds.");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DCONST_DVARFLT_cl_bradleyMouseSensFactorX = Dvar_RegisterFloat("cl_bradleyMouseSensFactorX", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mouse sensitivity in X for the Bradley Cannon");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DCONST_DVARFLT_cl_bradleyMouseSensFactorY = Dvar_RegisterFloat("cl_bradleyMouseSensFactorY", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mouse sensitivity in Y for the Bradley Cannon");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DCONST_DVARFLT_cl_wheelsonMouseSensFactorX = Dvar_RegisterFloat("cl_wheelsonMouseSensFactorX", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mouse sensitivity in X for the Wheelson turret");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DCONST_DVARFLT_cl_wheelsonMouseSensFactorY = Dvar_RegisterFloat("cl_wheelsonMouseSensFactorY", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mouse sensitivity in Y for the Wheelson turret");
  DCONST_DVARBOOL_cl_slideToProneEnabled = Dvar_RegisterBool("cl_slideToProneEnabled", 1, 0x40004u, "Enables slide to prone transition");
  DCONST_DVARINT_cl_stanceCrouchToProneHoldTime = Dvar_RegisterInt("cl_stanceCrouchToProneHoldTime", 200, 0, 1000, 0x40004u, "The time to hold the stance button before the player goes prone from crouch");
  DCONST_DVARINT_cl_stanceProneToStandHoldTime = Dvar_RegisterInt("cl_stanceProneToStandHoldTime", 300, 0, 1000, 0x40004u, "The time to hold the stance button before the player stands up from prone");
  __asm { vmovss  xmm1, cs:__real@3c23d70a; value }
  DCONST_DVARBOOL_cl_inputVelocityLogging = Dvar_RegisterBool("cl_inputVelocityLogging", 0, 0x40004u, "Enables input velocity logging.  Used for debugging turn rates and weapon sway.");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_cl_inputVelocityLogging_mouseMovePerMicro = Dvar_RegisterFloat("cl_inputVelocityLogging_mouseMovePerMicro", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Speed of artificial mouse input while inputVelocityLogging is enabled.  Dots / microsecond.");
  __asm { vmovss  xmm2, cs:__real@3c23d70a; min }
  DVARBOOL_cl_mouseAdsUseMonitorDistance = Dvar_RegisterBool("NSOMRKSPO", 1, 0, "Enables monitor distance ADS scaling based on the sensitivity coefficient.");
  __asm
  {
    vmovaps xmm6, xmm10
    vmovaps xmm3, xmm12; max
    vmovaps xmm1, xmm6; value
  }
  DVARFLT_cl_adsSensitivityMultiplier = Dvar_RegisterFloat("LTNQSKLMTN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "ADS vertical sensitivity multiplier");
  DVARBOOL_cl_fovAdsMouseSensitivityScaleImmediately = Dvar_RegisterBool("MKRMPPPOK", 1, 0, "Enables immediate scaling of sensivity based on ADS fov change. This is the default. Turning this dvar off will cause the hipfire sensitivity to be maintained until the player is 100% ADS, at which point the FoV-scaled sensitivity will be used.");
  __asm { vmovss  xmm1, cs:__real@41f00000; value }
  DCONST_DVARBOOL_cl_legacyMouseSensitivity = Dvar_RegisterBool("cl_legacyMouseSensitivity", 0, 0x40004u, "Restores mouse sensitivity to previous scale");
  __asm
  {
    vmovaps xmm3, xmm14; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v145 = Dvar_RegisterFloat("cl_highAdsZoomFovLimit", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Defines the biggest FoV value that is still considered an High Zoom instead of a Low Zoom for the gameplay options.");
  __asm
  {
    vmovss  xmm3, cs:__real@447a0000; max
    vmovss  xmm1, cs:__real@43960000; value
  }
  DCONST_DVARFLT_cl_highAdsZoomFovLimit = v145;
  __asm { vmovaps xmm2, xmm14; min }
  DCONST_DVARFLT_cl_superSprintTriggerWindowWithHoldToSprint = Dvar_RegisterFloat("cl_superSprintTriggerWindowWithHoldToSprint", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Defines the time window after a sprint end to trigger the SuperSprint when using the option Hold to Sprint");
  __asm { vmovss  xmm1, cs:__real@3f400000; value }
  DCONST_DVARINT_cl_autoForwardDoubleForwardInputTime = Dvar_RegisterInt("cl_autoForwardDoubleForwardInputTime", 400, 0, 5000, 0x40004u, "Window of time to process the double-tap stick forward, in ms");
  __asm
  {
    vmovaps xmm3, xmm6; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v152 = Dvar_RegisterFloat("cl_autoForwardControlMaxRightDeflection", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Percentage of controller deflection from neutral to right that is allowed to activate control.");
  __asm { vmovss  xmm1, cs:__real@3f000000; value }
  DCONST_DVARFLT_cl_autoForwardControlMaxRightDeflection = v152;
  __asm
  {
    vmovaps xmm3, xmm6; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v156 = Dvar_RegisterFloat("cl_autoForwardControlMinForwardDeflection", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Percentage of controller deflection from neutral to forward needed to register a forward input.");
  __asm
  {
    vmovss  xmm2, cs:__real@bf800000; min
    vmovss  xmm1, cs:__real@bf000000; value
  }
  DCONST_DVARFLT_cl_autoForwardControlMinForwardDeflection = v156;
  __asm { vxorps  xmm3, xmm3, xmm3; max }
  DCONST_DVARFLT_cl_autoForwardCancelMinBackwardDeflection = Dvar_RegisterFloat("cl_autoForwardCancelMinBackwardDeflection", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Percentage of controller deflection from neutral to backward needed to cancel auto-forward (some gamepad have a bounce back).");
  DCONST_DVARBOOL_cl_accumulateShellshockedMouseInput = Dvar_RegisterBool("cl_accumulateShellshockedMouseInput", 1, 0x40004u, "Accumulates mouse input when shellshocked, to be used when camera rotation speed clamps are active");
  __asm
  {
    vmovaps xmm13, xmm9
    vmovaps xmm3, xmm13; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm15; value
  }
  v164 = Dvar_RegisterFloat("cl_maxAccumulatedMouseInput", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Maximum accumulated mouse input that can be stored for shellshock");
  __asm
  {
    vmovss  xmm7, cs:__real@42200000
    vmovss  xmm1, cs:__real@42700000; value
  }
  DCONST_DVARFLT_cl_maxAccumulatedMouseInput = v164;
  __asm
  {
    vmovaps xmm3, xmm13; max
    vmovaps xmm2, xmm7; min
  }
  DCONST_DVARFLT_cl_maxShellshockCatchUpSpeed = Dvar_RegisterFloat("cl_maxShellshockCatchUpSpeed", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Maximum rotation speed (clamp) allowed when consuming accumulated mouse input for shellshock");
  __asm
  {
    vmovaps xmm3, xmm13; max
    vmovss  xmm13, cs:__real@3c23d70a
    vmovaps xmm2, xmm13; min
    vmovaps xmm1, xmm7; value
  }
  v173 = Dvar_RegisterFloat("cl_shortMovementThreshold", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Amount of mouse movement below which we consider it to be a fine, precision input");
  __asm { vmovss  xmm1, cs:__real@42a00000; value }
  DCONST_DVARFLT_cl_shortMovementThreshold = v173;
  __asm
  {
    vmovaps xmm3, xmm9; max
    vmovaps xmm2, xmm13; min
  }
  DCONST_DVARFLT_cl_longMovementThreshold = Dvar_RegisterFloat("cl_longMovementThreshold", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Amount of mouse movement above which we consider it to be a long, abrupt movement");
  DCONST_DVARINT_cl_accumulatedInputExpirationTime = Dvar_RegisterInt("cl_accumulatedInputExpirationTime", 75, 0, 0x7FFFFFFF, 0x40004u, "Time limit to discard accumulated input; only ticks if users are doing fine movements (below short movement threshold)");
  DCONST_DVARINT_cl_weaponInspectAltToggle_holdTime_ms = Dvar_RegisterInt("cl_weaponInspectAltToggle_holdTime_ms", 500, 0, 0x7FFFFFFF, 0x40004u, "Time the player must hold alt toggle on a controller to initiate Weapon Inspect.");
  DVARBOOL_con_bindableGrave = Dvar_RegisterBool("OKLQKPPKPQ", 0, 0, "Allow binding the ` key (and remove console functionality)");
  DVARBOOL_con_restricted = Dvar_RegisterBool("MOQQSONTOT", 0, 0, "Restrict console access");
  DVARBOOL_con_matchPrefixOnly = Dvar_RegisterBool("LORPQQPQKR", 1, 0, "Only match the prefix when listing matching Dvars");
  DVARBOOL_cl_noprint = Dvar_RegisterBool("ONKQOSSTR", 0, 0, "Print nothing to the console");
  DVARBOOL_cl_lessprint = Dvar_RegisterBool("NLLLORPQQT", 1, 0, "Print less to the console by filtering out certain spammy channels");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm10; value
  }
  DCONST_DVARFLT_cl_devguiFontScaleHD = Dvar_RegisterFloat("cl_devguiFontScaleHD", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Scaling modifier for the devgui console font on 1080p hardware");
  __asm
  {
    vmovaps xmm3, xmm15; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm8, xmm10
    vmovaps xmm1, xmm8; value
  }
  v184 = Dvar_RegisterFloat("cl_devguiFontScaleUHD", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Scaling modifier for the devgui console font on 4K hardware");
  __asm
  {
    vmovss  xmm3, cs:__real@3f7d70a4; max
    vmovss  xmm2, cs:__real@bf7d70a4; min
  }
  DCONST_DVARFLT_cl_devguiFontScaleUHD = v184;
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  v188 = Dvar_RegisterFloat("NMRKMSMTOO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm3, cs:__real@3e4ccccd; max
    vxorps  xmm2, xmm2, xmm2; min
    vxorps  xmm1, xmm1, xmm1; value
  }
  DVARFLT_profileMenuOption_blacklevel = v188;
  v192 = Dvar_RegisterFloat("LLTNTOTMMT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm2, cs:__real@3f19999a; min
    vmovss  xmm1, cs:__real@3f4ccccd; value
    vmovaps xmm3, xmm8; max
  }
  DVARFLT_profileMenuOption_hdrMinLum = v192;
  v196 = Dvar_RegisterFloat("NKQOMLOSN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm3, cs:__real@3fc00000; max
    vmovss  xmm2, cs:__real@3f000000; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_hdrMaxLum = v196;
  v200 = Dvar_RegisterFloat("PPNORSOSS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_hdrGamma = v200;
  v204 = Dvar_RegisterFloat("LQTPNKKMOP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_volume = v204;
  v208 = Dvar_RegisterFloat("MSSPLOROPP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_voiceVolume = v208;
  v212 = Dvar_RegisterFloat("LLPPPNKTSO", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_musicVolume = v212;
  v216 = Dvar_RegisterFloat("MPTTMMKST", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_effectsVolume = v216;
  DVARFLT_profileMenuOption_licensedMusicVolume = Dvar_RegisterFloat("OLMSPQPNNL", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  DVARINT_profileMenuOption_presetMix = Dvar_RegisterInt("PTKLRRLLQ", 0, 0, 9, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm1, cs:__real@3f666666; value
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARBOOL_profileMenuOption_controllerSpeakerEnabled = Dvar_RegisterBool("MNKONSOLT", 1, 4u, (const char *)&queryFormat.fmt + 3);
  v223 = Dvar_RegisterFloat("NNLRMRKOTM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm1, cs:__real@3f666666; value
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARFLT_profileMenuOption_safeAreaHorz = v223;
  DVARFLT_profileMenuOption_safeAreaVert = Dvar_RegisterFloat("MKOOLLQRPS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm3, cs:__real@41a00000; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DVARINT_profileMenuOption_lootCardDetail = Dvar_RegisterInt("MSLNPQSPLM", 1, 1, 3, 0, "Controls the amount of detail a br loot card shows - 1( low ), 2( medium ), 3( high )");
  v230 = Dvar_RegisterFloat("MRKPMKMRQL", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm
  {
    vmovss  xmm3, cs:__real@41a00000; max
    vmovaps xmm2, xmm8; min
    vmovaps xmm1, xmm12; value
  }
  DVARFLT_profileMenuOption_vertsensitivity = v230;
  DVARFLT_profileMenuOption_horzsensitivity = Dvar_RegisterFloat("NQQNNPQPKR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, (const char *)&queryFormat.fmt + 3);
  __asm { vmovss  xmm1, cs:__real@41400000; value }
  DVARINT_profileMenuOption_offensiveContentMode = Dvar_RegisterInt("NQPNSRQLRK", 0, 0, 2, 0, "Mode of the offensive content warning at startup - 0, skip and turn on 1, skip and turn off; 2, ask user");
  __asm
  {
    vmovaps xmm3, xmm14; max
    vmovaps xmm2, xmm13; min
  }
  DVARFLT_profileMenuOption_mousehorzsensitivity = Dvar_RegisterFloat("NLQQLQRKSM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Mouse sensitivity (horiz).");
  __asm
  {
    vmovaps xmm3, xmm12; max
    vmovaps xmm2, xmm13; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_mousevertsensitivity = Dvar_RegisterFloat("LONMSRNMSK", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Mouse sensitivity multiplier for vertical axis");
  __asm
  {
    vmovaps xmm3, xmm14; max
    vmovaps xmm2, xmm13; min
    vmovaps xmm1, xmm7; value
  }
  DVARFLT_profileMenuOption_mouseflighthorzsensitivity = Dvar_RegisterFloat("MKONQNTMKQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Mouse sensitivity during flight (horiz).");
  __asm
  {
    vmovaps xmm3, xmm12; max
    vmovaps xmm2, xmm13; min
    vmovaps xmm1, xmm8; value
  }
  DVARFLT_profileMenuOption_mouseflightvertsensitivity = Dvar_RegisterFloat("MPKPOPRTLQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 4u, "Mouse sensitivity multiplier for vertical axis during flight.");
  DVARBOOL_profileMenuOption_mouseflightinversion = Dvar_RegisterBool("LRTLMMOTML", 0, 4u, "Mouse flight inversion");
  DVARBOOL_profileMenuOption_netRegionHide = Dvar_RegisterBool("MKMOPQKMPO", 0, 4u, "Hide the network info screen region");
  DVARBOOL_profileMenuOption_netExternalIPHide = Dvar_RegisterBool("MTSPMPOSTO", 0, 4u, "Hide the network info screen external ip");
  DVARBOOL_profileMenuOption_netInternalIPHide = Dvar_RegisterBool("SQMORMQQS", 0, 4u, "Hide the network info screen internal ip");
  DVARBOOL_profileMenuOption_netConnectionMeterHide = Dvar_RegisterBool("OMOTRTTLNP", 1, 4u, "Hide the network info screen connection meters");
  DVARBOOL_gamerprofile_bb_analytics = Dvar_RegisterBool("MONMLLPPNM", 1, 4u, "If true, will send analytics information to blackbox on some gamerprofile setting changes.");
  DVARBOOL_gamerprofile_armorPlateApplyAll_optionsAvailable = Dvar_RegisterBool("LOLOTKQLLN", 1, 4u, "Make available the profile option to chain apply all armor plates after one activation");
  DVARBOOL_gamerprofile_updateAimAssistwithFOV_optionsAvailable = Dvar_RegisterBool("OMMKPSMQOL", 1, 4u, "Allow the profile option to scale aim-assist region based on FOV,i.e., screen-region is smaller at higher FOVs and vice-versa.");
  DVARBOOL_profileMenuOption_gore = Dvar_RegisterBool("OQLRMLRK", 1, 4u, "Profile option to allow gore");
  DVARBOOL_gamerprofile_parachuteAutoDeploy_optionsAvailable = Dvar_RegisterBool("NMMMNQPNTO", 1, 4u, "Make available the option to activate or deactivate the parachute auto deploy");
  DVARINT_cl_worldStreamingQuality = Dvar_RegisterInt("OMKLNPPNSM", 1, 0, 1, 0, "World streaming quality option");
  __asm
  {
    vmovss  xmm0, cs:__real@46000000
    vmovss  xmm2, cs:__real@44200000; y
    vmovss  xmm1, cs:__real@43c80000; x
  }
  DVARINT_cl_transientWorldMemoryMinMB = Dvar_RegisterInt("TQOTNSOPL", 50, 0, 0x2000, 0, "Minimum bounds of the budget for TRWorld Memory");
  __asm
  {
    vxorps  xmm3, xmm3, xmm3; min
    vmovss  [rsp+0D8h+flags], xmm0
  }
  DVARVEC2_cl_transientWorldMemoryMaxMB = Dvar_RegisterVec2("LMLPNTMPN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsc, 0, "Maximum bounds of the budget for TRWorld Memory");
  DCONST_DVARINT_cl_streaming_devDelayLoadBase = Dvar_RegisterInt("cl_streaming_devDelayLoadBase", 1000, 0, 60000, 0x40004u, "When set, introduces a minimum load time delay, to simulate.");
  DCONST_DVARINT_cl_streaming_devDelayLoadJitter = Dvar_RegisterInt("cl_streaming_devDelayLoadJitter", 200, 0, 60000, 0x40004u, "When set, introduces randomness to the minimum time delay, to simulate.");
  DCONST_DVARBOOL_cl_streaming_devNoLoad = Dvar_RegisterBool("cl_streaming_devNoLoad", 0, 0x40004u, "When set, prevents actual transients from being loaded");
  DCONST_DVARBOOL_cl_streaming_devVerbose = Dvar_RegisterBool("cl_streaming_devVerbose", 0, 0x40004u, "More spam on the client for transient");
  DCONST_DVARBOOL_cl_streaming_devMaxLoad = Dvar_RegisterBool("cl_streaming_devMaxLoad", 0, 0x40004u, "When set, constinually loads all possible streaming assets in game");
  DCONST_DVARBOOL_cl_streaming_devMaxLoadCustom = Dvar_RegisterBool("cl_streaming_devMaxLoadCustom", 1, 0x40004u, "When set, constinually loads all possible streaming customization assets in game");
  DCONST_DVARBOOL_cl_streaming_devMaxLoadWeapons = Dvar_RegisterBool("cl_streaming_devMaxLoadWeapons", 1, 0x40004u, "When set, constinually loads all possible streaming weapon assets in game");
  DCONST_DVARBOOL_cl_streaming_devLoadWeaponsRandom = Dvar_RegisterBool("cl_streaming_devLoadWeaponsRandom", 0, 0x40004u, "When set, devloads with use random weapons instead of iterating over attachments and variants sequentially.");
  DCONST_DVARBOOL_cl_streamingErrorOnMissingRequiredImages = Dvar_RegisterBool("cl_streamingErrorOnMissingRequiredImages", 1, 0x40004u, "Enables Com_Error's when we exceed the required image cache capacity, disable to measure high water mark for required images.");
  DCONST_DVARBOOL_cl_streaming_drawPendingLoads = Dvar_RegisterBool("cl_streaming_drawPendingLoads", 1, 0x40004u, "Draw the number of pending model and image loads required by ClStreaming.");
  DCONST_DVARINT_cl_streaming_drawBuffer = Dvar_RegisterInt("cl_streaming_drawBuffer", -1, -1, 0x7FFFFFFF, 0x40004u, "Draw the request buffer for the given buffer index. -1 is off");
  DCONST_DVARINT_cl_streaming_drawQueue = Dvar_RegisterInt("cl_streaming_drawQueue", -1, -1, 0x7FFFFFFF, 0x40004u, "Draw the request queue for the given queue index. -1 is off");
  DCONST_DVARBOOL_cl_streaming_devInjectChaos = Dvar_RegisterBool("cl_streaming_devInjectChaos", 0, 0x40004u, "When enabled, periodically tries to unload streamed assets.");
  DCONST_DVARBOOL_cl_streaming_headUpdatesEnabled = Dvar_RegisterBool("cl_streaming_headUpdatesEnabled", 1, 0x40004u, "Enables streaming request updates for heads.");
  DCONST_DVARBOOL_cl_streaming_bodyUpdatesEnabled = Dvar_RegisterBool("cl_streaming_bodyUpdatesEnabled", 1, 0x40004u, "Enables streaming request updates for bodies.");
  DCONST_DVARBOOL_cl_streaming_weaponUpdatesEnabled = Dvar_RegisterBool("cl_streaming_weaponUpdatesEnabled", 1, 0x40004u, "Enables streaming request updates for weapons.");
  DCONST_DVARBOOL_cl_streaming_viewWeaponUpdatesEnabled = Dvar_RegisterBool("cl_streaming_viewWeaponUpdatesEnabled", 1, 0x40004u, "Enables streaming request updates for view weapons.");
  DCONST_DVARBOOL_cl_streaming_viewArmsUpdatesEnabled = Dvar_RegisterBool("cl_streaming_viewArmsUpdatesEnabled", 1, 0x40004u, "Enables streaming request updates for view arms.");
  DCONST_DVARBOOL_cl_uistreaming_pedantic = Dvar_RegisterBool("cl_uistreaming_pedantic", 0, 0x40004u, "Enable to turn on pedantic checks in UI Streaming");
  DCONST_DVARBOOL_cl_uistreaming_verbose = Dvar_RegisterBool("cl_uistreaming_verbose", 0, 0x40004u, "Enable to turn on verbose logging for UI Streaming");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForHeads = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForHeads", g_clStreamingStreamImageMipNames, 0, 0x40004u, "Required image mip setting for heads");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForBodies = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForBodies", g_clStreamingStreamImageMipNames, 0, 0x40004u, "Required image mip setting for bodies");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForWorldWeapons = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForWorldWeapons", g_clStreamingStreamImageMipNames, 0, 0x40004u, "Required image mip setting for world weapons");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForViewArms = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForViewArms", g_clStreamingStreamImageMipNames, 1, 0x40004u, "Required image mip setting for view arms");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForViewWeapons = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForViewWeapons", g_clStreamingStreamImageMipNames, 1, 0x40004u, "Required image mip setting for view weapons");
  DCONST_DVARINT_cl_streaming_requiredStreamImageMipForClientModels = Dvar_RegisterEnum("cl_streaming_requiredStreamImageMipForClientModels", g_clStreamingStreamImageMipNames, 0, 0x40004u, "Required image mip setting for client models");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForHeads = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForHeads", g_clStreamingStreamModelLodNames, 0, 0x40004u, "Required model lod setting for heads");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForBodies = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForBodies", g_clStreamingStreamModelLodNames, 0, 0x40004u, "Required model lod setting for bodies");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForWorldWeapons = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForWorldWeapons", g_clStreamingStreamModelLodNames, 0, 0x40004u, "Required model lod setting for world weapons");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForViewArms = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForViewArms", g_clStreamingStreamModelLodNames, 1, 0x40004u, "Required model lod setting for view arms");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForViewWeapons = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForViewWeapons", g_clStreamingStreamModelLodNames, 1, 0x40004u, "Required model lod setting for view weapons");
  DCONST_DVARINT_cl_streaming_requiredStreamModelLodForClientModels = Dvar_RegisterEnum("cl_streaming_requiredStreamModelLodForClientModels", g_clStreamingStreamModelLodNames, 0, 0x40004u, "Required model lod setting for client models");
  CG_ModelPreviewer_RegisterCommonDvars();
  CG_CreateFx_RegisterCommonDvars();
  CG_EntityWorkers_RegisterDars();
  __asm { vmovaps xmm15, [rsp+0D8h+var_98] }
  _R11 = &v266;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm12, xmmword ptr [r11-60h]
    vmovaps xmm13, xmmword ptr [r11-70h]
    vmovaps xmm14, xmmword ptr [r11-80h]
  }
  Dvar_EndPermanentRegistration();
}

/*
==============
CL_Main_RegisterGameDvars
==============
*/
void CL_Main_RegisterGameDvars(void)
{
  if ( !(unsigned __int8)Com_GameMode_GetActiveGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2281, ASSERT_TYPE_ASSERT, "(Com_GameMode_GetActiveGameMode() != GameModeType::NONE)", "%s\n\tThese dvars must be registered after game mode creation", "Com_GameMode_GetActiveGameMode() != GameModeType::NONE") )
    __debugbreak();
}

/*
==============
CL_Main_ResetSkeletonCache
==============
*/
void CL_Main_ResetSkeletonCache(void)
{
  int v0; 
  __int64 v1; 
  SkelMemoryPool *v2; 
  int v3; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 804, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Sys_ProfSetMarker(0xFFFFFFFF, "CL_Main_ResetSkeletonCache");
  v0 = cls.skelTimeStamp + 1;
  cls.skelValid = 1;
  v1 = (cls.skelTimeStamp + 1) % 3;
  if ( cls.skelTimeStamp == -1 )
    v0 = 1;
  cls.skelTimeStamp = v0;
  v2 = &cls.skelMemPools[v1];
  if ( cls.skelMemPoolSize )
  {
    if ( !v2->buffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 826, ASSERT_TYPE_ASSERT, "(pool->buffer)", (const char *)&queryFormat, "pool->buffer") )
      __debugbreak();
    if ( ((__int64)v2->buffer & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 827, ASSERT_TYPE_ASSERT, "(IsAligned( pool->buffer, 16 ))", (const char *)&queryFormat, "IsAligned( pool->buffer, SKEL_MEM_ALIGNMENT )") )
      __debugbreak();
  }
  cls.skelMemoryStart = v2->buffer;
  cls.skelMemPos = 0;
  CL_Debug_InitSkeletonMemTracking();
  R_SetGlobalSkelTimeStamp(cls.skelTimeStamp, 2);
  if ( CL_IsRenderingSplitScreen() )
    v3 = cls.skelTimeStamp - 2;
  else
    v3 = cls.skelTimeStamp - 1;
  if ( !v3 )
    v3 = -1;
  cls.skelPrevFrameTimeStamp = v3;
  if ( s_SkeletonCacheValidityLock && s_SkeletonCacheValidityLock != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 785, ASSERT_TYPE_ASSERT, "(s_SkeletonCacheValidityLock == SkeletonCacheValidityLockType_Unlocked || s_SkeletonCacheValidityLock == type)", (const char *)&queryFormat, "s_SkeletonCacheValidityLock == SkeletonCacheValidityLockType_Unlocked || s_SkeletonCacheValidityLock == type") )
    __debugbreak();
  if ( ((unsigned __int8)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
    __debugbreak();
  _InterlockedExchange(&s_SkeletonCacheValidityLock, 0);
}

/*
==============
CL_Main_ResetViewport
==============
*/
void CL_Main_ResetViewport(void)
{
  if ( cls.rendererStarted )
  {
    ScrPlace_SetupFullscreenViewports();
    ScrPlace_SetupClientViewports();
    if ( CL_AnyLocalClientStateActive() )
      CL_SetupScreenPlacements();
  }
}

/*
==============
CL_Main_RunOncePerClientFrame
==============
*/

void __fastcall CL_Main_RunOncePerClientFrame(int msec, double sec_base, double rawSeconds)
{
  ClGameModeApplication *ActiveClientApplication; 
  ClGameModeApplication *v9; 
  int i; 
  ClGameModeApplication *v14; 
  ClGameModeApplication *v15; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps [rsp+48h+var_28], xmm7
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm1
  }
  Sys_ProfBeginNamedEvent(0xFFD2691E, "CL_Main_RunOncePerClientFrame");
  Sys_AddWorkerCmd(WRKCMD_CL_GETREALTIME, &workerCmdDummy);
  CL_Pause_UpdatePauseState();
  Profile_Begin(493);
  if ( g_doLiveFrameHack )
    Live_Frame(msec);
  else
    g_doLiveFrameHack = 1;
  Profile_EndInternal(NULL);
  if ( !Party_PartiesAcrossGamemodesFeatureEnabled() && ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    ActiveClientApplication->RunAuthenticationManager(ActiveClientApplication, msec);
  }
  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    v9 = ClGameModeApplication::GetActiveClientApplication();
    v9->RunDvarValidation(v9);
  }
  CL_PlayAgain_Frame();
  OnlineDevMap::Pump(&OnlineDevMap::ms_instance);
  LUI_CoD_PumpCollectGarbage();
  Users_Update();
  ATClient_Update(msec);
  UI_AutoNavigation_Frame();
  __asm { vmovaps xmm0, xmm6; dT }
  CL_Cameraman_Update(*(float *)&_XMM0);
  if ( !cls.inputUpdatedPrevFrame )
  {
    IN_Frame();
    for ( i = 0; i <= 1; ++i )
      CL_Input_AutomatedInput_Frame((LocalClientNum_t)i);
  }
  cls.inputUpdatedPrevFrame = 0;
  IN_Frame_Mouse();
  cls.realtime += msec;
  __asm
  {
    vmovss  cs:?cls@@3UClStatic@@A.frametime_base, xmm6; ClStatic cls
    vmovss  cs:?cls@@3UClStatic@@A.frametime_rawSeconds, xmm7; ClStatic cls
  }
  cls.frametime = msec;
  __asm
  {
    vmovaps xmm7, [rsp+48h+var_28]
    vmovaps xmm6, [rsp+48h+var_18]
  }
  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    v14 = ClGameModeApplication::GetActiveClientApplication();
    v14->RunFrameTimeClamp(v14);
  }
  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    v15 = ClGameModeApplication::GetActiveClientApplication();
    v15->RunTransientProcessing(v15);
  }
  CL_UIStreaming_Update();
  CL_Streaming_Update();
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_CL_GETREALTIME);
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_Main_SetupGfxConfig
==============
*/
void CL_Main_SetupGfxConfig(GfxConfiguration *config)
{
  if ( !config && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 890, ASSERT_TYPE_ASSERT, "(config)", (const char *)&queryFormat, "config") )
    __debugbreak();
  *(_DWORD *)&config->inited = 0;
  config->maxClientViews = 2;
  *(_DWORD *)&config->defaultFullscreen = 131073;
  config->maxClientRenderViews = 4;
  config->entCount = 2560;
  config->entnumNone = 2047;
  config->entnumOrdinaryEnd = 2046;
  config->threadContextCount = 28;
  config->critSectCount = 116;
}

/*
==============
CL_Main_ShouldForwardCommandToServer
==============
*/
char CL_Main_ShouldForwardCommandToServer(LocalClientNum_t localClientNum, const char *cmd)
{
  if ( !cmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 659, ASSERT_TYPE_ASSERT, "(cmd)", (const char *)&queryFormat, "cmd") )
    __debugbreak();
  if ( *cmd == 45 )
    return 0;
  if ( *cmd == 43 )
  {
    Com_Printf(14, "Unknown command (<key down> commands can't be forwarded to the server) \"%s\"\n", cmd);
    return 0;
  }
  return 1;
}

/*
==============
CL_Main_ShutdownAll
==============
*/
void CL_Main_ShutdownAll(int isRestart, int fullRenderShutdown)
{
  R_SyncRenderThread();
  CL_Main_ShutdownHunkUsers();
  if ( fullRenderShutdown )
  {
    if ( cls.rendererStarted )
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      cls.rendererStarted = 0;
      __asm { vmovdqu xmmword ptr cs:?cls@@3UClStatic@@A.whiteMaterial, xmm0; ClStatic cls }
      cls.consoleFont = NULL;
      R_Shutdown(0, isRestart);
      Con_ShutdownClientAssets();
      if ( cls.rendererStarted )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 565, ASSERT_TYPE_ASSERT, "(!cls.rendererStarted)", (const char *)&queryFormat, "!cls.rendererStarted") )
          __debugbreak();
      }
    }
  }
  else
  {
    R_ShutdownWorld(isRestart, 1);
  }
}

/*
==============
CL_Main_ShutdownClient
==============
*/
void CL_Main_ShutdownClient(LocalClientNum_t localClientNum)
{
  ClGameModeApplication *ActiveClientApplication; 
  clientUIActive_t *LocalClientUIGlobals; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2424, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Com_SyncThreads();
  Com_Printf(14, "----- CL_Main_ShutdownClient -----\n");
  if ( recursive_0 )
  {
    Com_Printf(14, "recursive shutdown\n");
  }
  else
  {
    recursive_0 = 1;
    if ( ClGameModeApplication::HasActiveApplicationGameMode() )
    {
      ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
      ActiveClientApplication->Disconnect(ActiveClientApplication, localClientNum);
    }
    LocalClientUIGlobals = CL_GetLocalClientUIGlobals(localClientNum);
    recursive_0 = 0;
    LocalClientUIGlobals->isRunning = 0;
    Com_Printf(14, "-----------------------\n");
  }
}

/*
==============
CL_Main_ShutdownClientMemory
==============
*/
void CL_Main_ShutdownClientMemory(void)
{
  ClGameModeApplication *ActiveClientApplication; 

  if ( ClGameModeApplication::HasActiveApplicationGameMode() )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    ActiveClientApplication->ShutdownClientMemory(ActiveClientApplication);
  }
}

/*
==============
CL_Main_ShutdownGameWorld
==============
*/
void CL_Main_ShutdownGameWorld(void)
{
  ClGameModeApplication *ActiveClientApplication; 

  R_SyncRenderThread();
  if ( cls.hunkUsersStarted )
  {
    if ( ClGameModeApplication::HasActiveApplicationGameMode() )
    {
      ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
      ActiveClientApplication->ShutdownHunkUsers(ActiveClientApplication);
      if ( !cls.hunkUsersStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 594, ASSERT_TYPE_ASSERT, "(cls.hunkUsersStarted)", (const char *)&queryFormat, "cls.hunkUsersStarted") )
        __debugbreak();
    }
  }
  CG_Main_CleanupLevel();
  R_ShutdownWorld(0, 0);
}

/*
==============
CL_Main_ShutdownHunkUsers
==============
*/
void CL_Main_ShutdownHunkUsers(void)
{
  ClGameModeApplication *ActiveClientApplication; 

  if ( Com_FrontEndScene_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 513, ASSERT_TYPE_ASSERT, "(!Com_FrontEndScene_IsActive())", "%s\n\tShutting down UI while front end scene is active; it must be disabled first", "!Com_FrontEndScene_IsActive()") )
    __debugbreak();
  Com_SyncThreads();
  if ( cls.hunkUsersStarted )
  {
    if ( ClGameModeApplication::HasActiveApplicationGameMode() )
    {
      ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
      ActiveClientApplication->ShutdownHunkUsers(ActiveClientApplication);
    }
    CG_Main_CleanupLevel();
    if ( cls.devGuiStarted )
    {
      CL_DestroyDevGui();
      DevGui_Shutdown();
      Cmd_RemoveCommand("devgui_dvar");
      Cmd_RemoveCommand("devgui_cmd");
      Cmd_RemoveCommand("devgui_open");
      cls.devGuiStarted = 0;
    }
    CL_ShutdownUI();
    if ( cls.uiStarted )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 535, ASSERT_TYPE_ASSERT, "(!cls.uiStarted)", (const char *)&queryFormat, "!cls.uiStarted") )
        __debugbreak();
    }
    cls.hunkUsersStarted = 0;
  }
}

/*
==============
CL_Main_ShutdownOnceForAllClients
==============
*/
void CL_Main_ShutdownOnceForAllClients(void)
{
  size_t skelMemPoolSize; 
  char *buffer; 
  char *v2; 
  char *v3; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2351, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Com_Printf(14, "----- CL_Main_ShutdownOnceForAllClients -----\n");
  if ( recursive )
  {
    Com_Printf(14, "recursive CL_Main_ShutdownOnceForAllClients\n");
  }
  else
  {
    recursive = 1;
    if ( !CL_AllLocalClientsDisconnected() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 2362, ASSERT_TYPE_ASSERT, "(CL_AllLocalClientsDisconnected())", (const char *)&queryFormat, "CL_AllLocalClientsDisconnected()") )
      __debugbreak();
    CL_Streaming_Shutdown();
    CL_TransientsMP_Shutdown();
    CL_ShutdownDebugData();
    CL_Main_ShutdownHunkUsers();
    Mayhem_Shutdown();
    Ragdoll_SetCallbacks(NULL, NULL, NULL);
    Ragdoll_Shutdown();
    UI_AutoNavigation_UnregisterCmds();
    CL_Input_UnregisterCommands();
    CL_Debug_UnregisterCommands();
    CL_XB3_UnregisterCommands();
    GamerProfile_UnregisterCommands();
    PlayercardCache_UnregisterCommands();
    Cmd_RemoveServerCommandList(SERVER_COMMAND_LIST, 1u);
    Cmd_RemoveClientCommandList(CLIENT_COMMAND_LIST, 0x10u);
    skelMemPoolSize = cls.skelMemPoolSize;
    buffer = cls.skelMemPools[0].buffer;
    v2 = cls.skelMemPools[1].buffer;
    v3 = cls.skelMemPools[2].buffer;
    memset_0(&cls.rendererStarted, 0, 0x2A4ui64);
    *(&cls.skelMemPoolSize + 1) = 0;
    memset_0(&cls.skelMemoryStart, 0, 0x215A0ui64);
    cls.skelMemPoolSize = skelMemPoolSize;
    cls.skelMemPools[0].buffer = buffer;
    if ( buffer )
      memset_0(buffer, 0, (unsigned int)skelMemPoolSize);
    cls.skelMemPools[1].buffer = v2;
    if ( v2 )
      memset_0(v2, 0, skelMemPoolSize);
    cls.skelMemPools[2].buffer = v3;
    if ( v3 )
      memset_0(v3, 0, skelMemPoolSize);
    cls.quit = 1;
    recursive = 0;
    Com_Printf(14, "-----------------------\n");
  }
}

/*
==============
CL_Main_ShutdownRef
==============
*/

void __fastcall CL_Main_ShutdownRef(double _XMM0_8)
{
  R_SyncRenderThread();
  __asm { vpxor   xmm0, xmm0, xmm0 }
  cls.rendererStarted = 0;
  __asm { vmovdqu xmmword ptr cs:?cls@@3UClStatic@@A.whiteMaterial, xmm0; ClStatic cls }
  cls.consoleFont = NULL;
  Com_ScreenShotSaveGame_Terminate();
  R_Shutdown(1, 0);
  Con_ShutdownClientAssets();
  StatMon_Reset();
}

/*
==============
CL_Main_ShutdownRenderer
==============
*/
void CL_Main_ShutdownRenderer(int destroyWindow, int isRestart)
{
  if ( !cls.rendererStarted && !destroyWindow && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1013, ASSERT_TYPE_ASSERT, "(cls.rendererStarted || destroyWindow)", (const char *)&queryFormat, "cls.rendererStarted || destroyWindow") )
    __debugbreak();
  cls.rendererStarted = 0;
  cls.consoleFont = NULL;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr cs:?cls@@3UClStatic@@A.whiteMaterial, xmm0; ClStatic cls
  }
  if ( destroyWindow )
    Com_ScreenShotSaveGame_Terminate();
  R_Shutdown(destroyWindow, isRestart);
  Con_ShutdownClientAssets();
}

/*
==============
CL_Main_SkeletonCacheValidity_Lock
==============
*/
void CL_Main_SkeletonCacheValidity_Lock(SkeletonCacheValidityLockType type)
{
  signed __int32 i; 

  if ( ((unsigned __int8)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
    __debugbreak();
  for ( i = _InterlockedCompareExchange(&s_SkeletonCacheValidityLock, type, 0); i; i = _InterlockedCompareExchange(&s_SkeletonCacheValidityLock, type, 0) )
  {
    if ( i == type )
      break;
    if ( GetCurrentProcessorNumber() == 1 )
      Sys_PushUnblockDatabaseThread();
    Sys_Sleep(1);
    if ( GetCurrentProcessorNumber() == 1 )
      Sys_PopUnblockDatabaseThread();
    if ( ((unsigned __int64)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
      __debugbreak();
  }
}

/*
==============
CL_Main_SkeletonCacheValidity_Unlock
==============
*/
void CL_Main_SkeletonCacheValidity_Unlock(SkeletonCacheValidityLockType type)
{
  if ( s_SkeletonCacheValidityLock && s_SkeletonCacheValidityLock != type && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 785, ASSERT_TYPE_ASSERT, "(s_SkeletonCacheValidityLock == SkeletonCacheValidityLockType_Unlocked || s_SkeletonCacheValidityLock == type)", (const char *)&queryFormat, "s_SkeletonCacheValidityLock == SkeletonCacheValidityLockType_Unlocked || s_SkeletonCacheValidityLock == type") )
    __debugbreak();
  if ( ((unsigned __int8)&s_SkeletonCacheValidityLock & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_SkeletonCacheValidityLock) )
    __debugbreak();
  _InterlockedExchange(&s_SkeletonCacheValidityLock, 0);
}

/*
==============
CL_Main_StartHunkUsers
==============
*/
void CL_Main_StartHunkUsers(void)
{
  bool *p_isRunning; 
  unsigned __int8 ActiveGameMode; 

  if ( cls.hunkUsersStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 482, ASSERT_TYPE_ASSERT, "(!cls.hunkUsersStarted)", (const char *)&queryFormat, "!cls.hunkUsersStarted") )
    __debugbreak();
  p_isRunning = &clientUIActives[0].isRunning;
  while ( !*p_isRunning )
  {
    p_isRunning += 440;
    if ( (__int64)p_isRunning >= (__int64)VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_916.v.m128_i64 + 1 )
      return;
  }
  if ( !cls.soundStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 488, ASSERT_TYPE_ASSERT, "(cls.soundStarted)", (const char *)&queryFormat, "cls.soundStarted") )
    __debugbreak();
  if ( !cls.rendererStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 492, ASSERT_TYPE_ASSERT, "(cls.rendererStarted)", (const char *)&queryFormat, "cls.rendererStarted") )
    __debugbreak();
  if ( !cls.uiStarted )
  {
    CL_InitUI();
    if ( !cls.uiStarted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 499, ASSERT_TYPE_ASSERT, "(cls.uiStarted)", (const char *)&queryFormat, "cls.uiStarted") )
      __debugbreak();
  }
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  CL_Main_InitDevGUI((GameModeType)ActiveGameMode);
  cls.hunkUsersStarted = 1;
}

/*
==============
CL_Main_StartPrivateParty
==============
*/
void CL_Main_StartPrivateParty(const LocalClientNum_t localClientNum, int localControllerIndex)
{
  const dvar_t *v2; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  const dvar_t *v7; 
  const dvar_t *v8; 
  bool v9; 
  PartyData *PartyData; 
  PartyData *v11; 
  OnlinePlayFailureReason failureReason; 

  v2 = DVARBOOL_systemlink;
  if ( !DVARBOOL_systemlink && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "systemlink") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled && !Live_CanUserPlayOnline(localControllerIndex, &failureReason) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1330, ASSERT_TYPE_ASSERT, "(Dvar_GetBool_Internal_DebugName( DVARBOOL_systemlink, \"systemlink\" ) || Live_CanUserPlayOnline( localControllerIndex, &failureReason ))", (const char *)&queryFormat, "Dvar_GetBool( systemlink ) || Live_CanUserPlayOnline( localControllerIndex, &failureReason )") )
    __debugbreak();
  v5 = DVARBOOL_systemlink;
  if ( !DVARBOOL_systemlink && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "systemlink") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( !v5->current.enabled && dwGetLogOnStatus(localControllerIndex) != DW_LIVE_CONNECTED && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1331, ASSERT_TYPE_ASSERT, "(Dvar_GetBool_Internal_DebugName( DVARBOOL_systemlink, \"systemlink\" ) || (dwGetLogOnStatus( localControllerIndex ) == DW_LIVE_CONNECTED))", (const char *)&queryFormat, "Dvar_GetBool( systemlink ) || (dwGetLogOnStatus( localControllerIndex ) == DW_LIVE_CONNECTED)") )
    __debugbreak();
  v6 = DVARBOOL_systemlink;
  if ( !DVARBOOL_systemlink && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "systemlink") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( !v6->current.enabled && Live_UserIsGuest(localControllerIndex) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1332, ASSERT_TYPE_ASSERT, "(Dvar_GetBool_Internal_DebugName( DVARBOOL_systemlink, \"systemlink\" ) || !Live_UserIsGuest( localControllerIndex ))", (const char *)&queryFormat, "Dvar_GetBool( systemlink ) || !Live_UserIsGuest( localControllerIndex )") )
    __debugbreak();
  v7 = DVARBOOL_onlinegame;
  if ( !DVARBOOL_onlinegame && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "onlinegame") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
  {
    v8 = DVARBOOL_systemlink;
    if ( !DVARBOOL_systemlink && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "systemlink") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( !v8->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1333, ASSERT_TYPE_ASSERT, "(Dvar_GetBool_Internal_DebugName( DVARBOOL_onlinegame, \"onlinegame\" ) || Dvar_GetBool_Internal_DebugName( DVARBOOL_systemlink, \"systemlink\" ))", "%s\n\tStarting a private party outside of the online game or LAN section", "Dvar_GetBool( onlinegame ) || Dvar_GetBool( systemlink )") )
      __debugbreak();
  }
  v9 = Party_AreWeHost(&g_partyData) > 0 && Party_IsRunning(&g_partyData);
  PartyData = Lobby_GetPartyData();
  Party_Sleep(PartyData);
  if ( !v9 )
    Party_Sleep(&g_partyData);
  Com_Printf(14, "CL_Main_StartPrivateParty() was called, calling Party_StopParty\n");
  v11 = Lobby_GetPartyData();
  Party_StopParty(v11);
  if ( !v9 )
    Party_StopParty(&g_partyData);
  if ( CL_GetLocalClientGameConnectionState(localClientNum) >= CA_CONNECTED && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1350, ASSERT_TYPE_ASSERT, "(!CL_IsLocalClientConnectedToGameServer( localClientNum ))", (const char *)&queryFormat, "!CL_IsLocalClientConnectedToGameServer( localClientNum )") )
    __debugbreak();
  if ( !v9 )
    Party_Awake(&g_partyData, localControllerIndex, 1);
  if ( Live_IsInSystemlinkLobby() )
    Party_ResetTweakDvars();
  if ( !v9 )
    PartyHost_StartPrivateParty(localClientNum, localControllerIndex, 1, PARTY_HOST_CLIENT);
}

/*
==============
CL_Main_StopParty
==============
*/
void CL_Main_StopParty(int backoutParty, PartyDisconnectReason a2)
{
  PartyData *PartyData; 
  int v4; 
  PartyData *v5; 
  const dvar_t *v6; 
  LocalClientNum_t v7; 
  int v8; 

  LOBYTE(a2) = 2;
  PartyAtomic_AbortJoinAttempt(&g_partyJoinInfo, a2);
  PartyData = Lobby_GetPartyData();
  if ( backoutParty )
    Party_StopPartyOnBackout(PartyData);
  else
    Party_StopParty(PartyData);
  v4 = Cmd_LocalControllerIndex();
  Party_Awake(&g_partyData, v4, 0);
  v5 = Lobby_GetPartyData();
  Party_Sleep(v5);
  v6 = DVARBOOL_onlinegame;
  if ( !DVARBOOL_onlinegame && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "onlinegame") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled && !g_partyData.inParty )
  {
    v7 = Cmd_LocalClientNum();
    v8 = Cmd_LocalControllerIndex();
    if ( v7 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1441F4EA0, 759i64);
    CL_Main_StartPrivateParty(v7, v8);
  }
}

/*
==============
CL_Main_SyncGpu
==============
*/
void CL_Main_SyncGpu(LocalClientNum_t localClientNum)
{
  float v1; 
  float v4; 

  v1 = cl_maxLocalClients;
  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) )
  {
    v4 = cl_maxLocalClients;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 352, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v4) )
      __debugbreak();
    v1 = cl_maxLocalClients;
  }
  if ( v1 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 336, ASSERT_TYPE_ASSERT, "(cl_maxLocalClients)", "%s\n\tMust be called after client allocation", "cl_maxLocalClients") )
    __debugbreak();
  if ( cls.m_localClientsActive.activeCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 353, ASSERT_TYPE_ASSERT, "(GetGameLocalClientActiveCount() > 0)", "%s\n\tClient active data has not been setup", "GetGameLocalClientActiveCount() > 0") )
    __debugbreak();
  if ( cls.m_localClientsActive.firstActiveIndex == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 354, ASSERT_TYPE_ASSERT, "(m_localClientsActive.firstActiveIndex != LOCAL_CLIENT_INVALID)", "%s\n\tClient active data has not been setup", "m_localClientsActive.firstActiveIndex != LOCAL_CLIENT_INVALID") )
    __debugbreak();
  if ( localClientNum == cls.m_localClientsActive.firstActiveIndex )
    R_SyncGpu();
}

/*
==============
CL_Main_UpdateSound
==============
*/
void CL_Main_UpdateSound(bool deferred)
{
  if ( !Sys_IsRenderThread() && (!Sys_IsMainThread() || R_IsInRemoteScreenUpdate()) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 1407, ASSERT_TYPE_ASSERT, "(Sys_IsRenderThread() || (Sys_IsMainThread() && !R_IsInRemoteScreenUpdate()))", (const char *)&queryFormat, "Sys_IsRenderThread() || (Sys_IsMainThread() && !R_IsInRemoteScreenUpdate())") )
    __debugbreak();
  SND_BankStreamUpdate();
  if ( cls.soundStarted )
  {
    if ( !cls.inUpdateSound )
    {
      Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
      cls.inUpdateSound = 1;
      Sys_ProfBeginNamedEvent(0xFFFFFFFF, "update sound");
      Profile_BeginCSV(5);
      SND_Update();
      Profile_EndCSV(5);
      Sys_ProfEndNamedEvent();
      cls.inUpdateSound = 0;
      Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    }
  }
}

/*
==============
CL_ScaledMilliseconds
==============
*/
__int64 CL_ScaledMilliseconds()
{
  return (unsigned int)cls.realtime;
}

/*
==============
Cl_Main_UnregisterGameDvars
==============
*/
void Cl_Main_UnregisterGameDvars(void)
{
  ;
}

/*
==============
ClStatic::ClearGameActiveClientInfo
==============
*/
void ClStatic::ClearGameActiveClientInfo(ClStatic *this)
{
  *(_QWORD *)&this->m_localClientsActive.activeCount = 0i64;
  *(_QWORD *)&this->m_localClientsActive.firstActiveIndex = -1i64;
}

/*
==============
ClStatic::GenerateGameActiveClientInfo
==============
*/
void ClStatic::GenerateGameActiveClientInfo(ClStatic *this)
{
  int v2; 
  float v3; 
  bool *isActive; 
  int v5; 
  int v6; 
  float v7; 

  if ( SLODWORD(cl_maxLocalClients) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 273, ASSERT_TYPE_ASSERT, "((cl_maxLocalClients) > 0)", (const char *)&queryFormat, "MAX_LOCAL_CLIENTS > 0") )
    __debugbreak();
  v2 = 0;
  *(_QWORD *)&this->m_localClientsActive.activeCount = 0i64;
  *(_QWORD *)&this->m_localClientsActive.firstActiveIndex = -1i64;
  v3 = cl_maxLocalClients;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
  {
    v5 = 0;
  }
  else
  {
    isActive = this->m_localClientsActive.isActive;
    do
    {
      if ( this->m_localClientsActive.firstActiveIndex == LOCAL_CLIENT_INVALID )
        this->m_localClientsActive.firstActiveIndex = v2;
      this->m_localClientsActive.lastActiveIndex = v2++;
      *isActive++ = 1;
      v5 = this->m_localClientsActive.activeCount + 1;
      this->m_localClientsActive.activeCount = v5;
      v3 = cl_maxLocalClients;
    }
    while ( v2 < SLODWORD(cl_maxLocalClients) );
  }
  if ( v5 != LODWORD(v3) )
  {
    v7 = v3;
    v6 = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 290, ASSERT_TYPE_ASSERT, "( m_localClientsActive.activeCount ) == ( (cl_maxLocalClients) )", "%s == %s\n\t%i, %i", "m_localClientsActive.activeCount", "MAX_LOCAL_CLIENTS", v6, v7) )
      __debugbreak();
  }
}

/*
==============
ClStatic::GetActiveGameTypeQuick
==============
*/
__int64 ClStatic::GetActiveGameTypeQuick(ClStatic *this)
{
  return (unsigned __int8)this->m_activeGameTypeQuick[0];
}

/*
==============
ClStatic::IsBRActiveGameTypeQuick
==============
*/
bool ClStatic::IsBRActiveGameTypeQuick(ClStatic *this)
{
  return this->m_activeGameTypeQuick[0] == 1;
}

/*
==============
ClStatic::SetActiveGameType
==============
*/
void ClStatic::SetActiveGameType(ClStatic *this, const char *gametype)
{
  if ( !gametype && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 228, ASSERT_TYPE_ASSERT, "(gametype)", (const char *)&queryFormat, "gametype") )
    __debugbreak();
  if ( this->m_activeGameTypeName[0] && *gametype )
    Com_PrintWarning(14, "ClStatic::SetGameMode: Overwriting existing gametype '%s' with '%s'\n", this->m_activeGameTypeName, gametype);
  else
    Com_Printf(14, "ClStatic::SetGameMode: Setting gametype to '%s'\n", gametype);
  Core_strcpy(this->m_activeGameTypeName, 0x24ui64, gametype);
  this->m_activeGameTypeQuick[0] = BG_GetGameTypeQuickForName(gametype);
}

/*
==============
ClStatic::SetActiveHardcoreMode
==============
*/
void ClStatic::SetActiveHardcoreMode(ClStatic *this, const bool isHardcore)
{
  this->m_activeGameHardcoreSetting = isHardcore;
}

/*
==============
ClStatic::SetGameMapName
==============
*/
void ClStatic::SetGameMapName(ClStatic *this, const char *mapname)
{
  if ( !mapname && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 211, ASSERT_TYPE_ASSERT, "(mapname)", (const char *)&queryFormat, "mapname") )
    __debugbreak();
  if ( this->m_activeGameMapName[0] && *mapname )
    Com_PrintWarning(14, "ClStatic::SetGameMapName: Overwriting existing mapname '%s' with '%s'\n", this->m_activeGameMapName, mapname);
  else
    Com_Printf(14, "ClStatic::SetGameMapName: Setting mapname to '%s'\n", mapname);
  Core_strcpy(this->m_activeGameMapName, 0x24ui64, mapname);
}

/*
==============
ClStatic::SetWeaponMapRuntimeMaxEntries
==============
*/
void ClStatic::SetWeaponMapRuntimeMaxEntries(ClStatic *this, const unsigned __int16 maxEntries)
{
  int v4; 
  int v5; 

  if ( maxEntries > 0x3FFu )
  {
    v5 = 1023;
    v4 = maxEntries;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_main.cpp", 264, ASSERT_TYPE_ASSERT, "( maxEntries ) <= ( BgWeaponMap::MAX_ENTRIES )", "%s <= %s\n\t%u, %u", "maxEntries", "BgWeaponMap::MAX_ENTRIES", v4, v5) )
      __debugbreak();
  }
  this->m_weaponMapMaxRuntimeEntries = maxEntries;
}

/*
==============
ClStatic::ShutdownClStatic
==============
*/
void ClStatic::ShutdownClStatic(ClStatic *this)
{
  size_t skelMemPoolSize; 
  char *buffer; 
  char *v4; 
  char *v5; 

  skelMemPoolSize = this->skelMemPoolSize;
  buffer = this->skelMemPools[0].buffer;
  v4 = this->skelMemPools[1].buffer;
  v5 = this->skelMemPools[2].buffer;
  memset_0(&this->rendererStarted, 0, 0x2A4ui64);
  *(&this->skelMemPoolSize + 1) = 0;
  memset_0(&this->skelMemoryStart, 0, 0x215A0ui64);
  this->skelMemPoolSize = skelMemPoolSize;
  this->skelMemPools[0].buffer = buffer;
  if ( buffer )
    memset_0(buffer, 0, (unsigned int)skelMemPoolSize);
  this->skelMemPools[1].buffer = v4;
  if ( v4 )
    memset_0(v4, 0, skelMemPoolSize);
  this->skelMemPools[2].buffer = v5;
  if ( v5 )
    memset_0(v5, 0, skelMemPoolSize);
  this->quit = 1;
}

