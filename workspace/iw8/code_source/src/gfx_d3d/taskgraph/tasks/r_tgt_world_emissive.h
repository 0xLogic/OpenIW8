/*
==============
RBTD_ShowEmissiveOverdraw
==============
*/

void __fastcall RBTD_ShowEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_ShowEmissiveOverdraw@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cUtil_CreateRelativeColorAlpha4xMS@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_HalfRes_Upsample@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBT_DrawEmissivePostBlur
==============
*/

void __fastcall RBT_DrawEmissivePostBlur(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissivePostBlur@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawEmissiveCommon
==============
*/

void __fastcall RBT_DrawEmissiveCommon(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissiveCommon@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RTD_DrawEmissiveOverdrawSetup
==============
*/

void __fastcall RTD_DrawEmissiveOverdrawSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RTD_DrawEmissiveOverdrawSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_HalfRes_DownsampleDepth@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBTD_DrawEmissiveOverdraw
==============
*/

void __fastcall RBTD_DrawEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawEmissiveOverdraw@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_ShowEmissiveOverdraw@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_HalfRes_DownsampleDepth
==============
*/

void __fastcall RBT_HalfRes_DownsampleDepth(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HalfRes_DownsampleDepth@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawEmissiveSetup
==============
*/

void __fastcall RT_DrawEmissiveSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawEmissiveSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_DrawEmissive
==============
*/

void __fastcall RBT_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissive@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawEmissiveCommonSetup
==============
*/

void __fastcall RT_DrawEmissiveCommonSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo, R_RT_Handle *lmapColor, R_RT_Handle *lmapSH, R_RT_Handle *lmapFog, R_RT_Handle *packedStencil)
{
  ?RT_DrawEmissiveCommonSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@VR_RT_Handle@@222@Z(taskInfo, viewInfo, lmapColor, lmapSH, lmapFog, packedStencil);
}

/*
==============
cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cUtil_CreateHalfRelativeColorAlpha@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_HalfRes_Upsample
==============
*/

void __fastcall RBT_HalfRes_Upsample(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HalfRes_Upsample@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_ShowEmissiveOverdraw.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HalfRes_DownsampleDepth.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HalfRes_Upsample.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_CreateHalfRelativeColorAlpha.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_CreateRelativeColorAlpha4xMS.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_DrawEmissiveOverdraw
==============
*/
void RBTD_DrawEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_DrawEmissiveCommon(&v4, taskInfo, viewInfo, data);
}

/*
==============
RBTD_ShowEmissiveOverdraw
==============
*/
void RBTD_ShowEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 
  GfxCmdBufContext v5; 
  R_RT_Handle v6; 

  v4 = *gfxContext;
  v6 = *taskInfo->attachments;
  v5 = v4;
  R_ShowOverdrawOverlay(&v5, viewInfo, &v6);
}

/*
==============
RBT_DrawEmissive
==============
*/
void RBT_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_DrawEmissiveCommon(&v4, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawEmissiveCommon
==============
*/
void RBT_DrawEmissiveCommon(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int64 v7; 
  unsigned int *p_count; 
  const R_TG_DrawListGroup *v9; 
  __int64 v10; 
  unsigned int taskFlags; 

  RB_DrawEmissive_UnmapMeshes(data);
  if ( !rg.debugShaderEnabled )
  {
    v7 = 0i64;
    p_count = &g_R_TG_emissiveGroups[*taskInfo->pTaskData].count;
    if ( *p_count )
    {
      v9 = &g_R_TG_emissiveGroups[*taskInfo->pTaskData];
      do
      {
        v10 = (__int64)&v9->drawLists[v7];
        if ( (unsigned int)(*(_DWORD *)v10 - 19) > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_emissive.h", 95, ASSERT_TYPE_ASSERT, "(drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE)", (const char *)&queryFormat, "drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE") )
          __debugbreak();
        taskFlags = taskInfo->pGraphInfo->taskFlags;
        if ( (taskFlags & *(_DWORD *)(v10 + 4)) == *(_DWORD *)(v10 + 4) && (taskFlags & *(_DWORD *)(v10 + 8)) == 0 )
          RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, *(GfxDrawListType *)v10);
        v7 = (unsigned int)(v7 + 1);
      }
      while ( (unsigned int)v7 < *p_count );
    }
  }
}

/*
==============
RBT_DrawEmissivePostBlur
==============
*/
void RBT_DrawEmissivePostBlur(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_DrawEmissiveCommon(&v4, taskInfo, viewInfo, data);
}

/*
==============
RBT_HalfRes_DownsampleDepth
==============
*/
void RBT_HalfRes_DownsampleDepth(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 
  GfxCmdBufContext v5; 
  R_RT_Handle v6; 

  v4 = *gfxContext;
  v6 = *taskInfo->attachments;
  v5 = v4;
  R_HalfRes_DownsampleDepth(&v5, &v6, &viewInfo->sceneEmissiveViewport);
}

/*
==============
RBT_HalfRes_Upsample
==============
*/
void RBT_HalfRes_Upsample(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *attachments; 
  R_RT_Handle v5; 
  R_RT_Handle v6; 
  __m256i v7; 
  GfxCmdBufContext v8; 
  GfxCmdBufContext v9; 
  R_RT_Handle v10; 
  R_RT_Handle v11; 
  R_RT_Handle v12; 
  __m256i v13; 

  attachments = taskInfo->attachments;
  v5 = attachments[2];
  v10 = attachments[3];
  v6 = attachments[1];
  v11 = v5;
  v7 = *(__m256i *)attachments;
  v12 = v6;
  v8 = *gfxContext;
  v13 = v7;
  v9 = v8;
  R_HalfRes_Upsample(&v9, (R_RT_Handle *)&v13, &v12, &v11, &v10, &viewInfo->sceneViewport);
}

/*
==============
RTD_DrawEmissiveOverdrawSetup
==============
*/
void RTD_DrawEmissiveOverdrawSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle v4; 
  R_RT_Handle v5; 
  R_RT_Handle v6; 
  R_RT_Handle v7; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  v4.m_surfaceID = 0;
  v4.m_tracking.m_allocCounter = 0;
  *(_OWORD *)&v4.m_tracking.m_name = _XMM0;
  v5.m_surfaceID = 0;
  v5.m_tracking.m_allocCounter = 0;
  v6.m_surfaceID = 0;
  v6.m_tracking.m_allocCounter = 0;
  *(_OWORD *)&v6.m_tracking.m_name = _XMM0;
  v7.m_surfaceID = 0;
  v7.m_tracking.m_allocCounter = 0;
  *(_OWORD *)&v5.m_tracking.m_name = _XMM0;
  *(_OWORD *)&v7.m_tracking.m_name = _XMM0;
  RT_DrawEmissiveCommonSetup(taskInfo, viewInfo, &v7, &v6, &v5, &v4);
}

/*
==============
RT_DrawEmissiveCommonSetup
==============
*/
void RT_DrawEmissiveCommonSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo, R_RT_Handle *lmapColor, R_RT_Handle *lmapSH, R_RT_Handle *lmapFog, R_RT_Handle *packedStencil)
{
  __int16 v6; 
  R_RT_Image *defaultWaveWaterFloatZImage; 
  R_RT_Handle v12; 
  R_RT_Image *whiteImage; 
  R_RT_Handle v14; 
  R_RT_Image *p_m_image; 
  R_RT_Image *defaultFogLightmapImage; 
  bool enabled; 
  R_RT_Image *blackImage; 
  __int64 v19; 
  unsigned int *p_count; 
  const R_TG_DrawListGroup *v21; 
  __int64 v22; 
  unsigned int taskFlags; 
  R_RT_Handle v24; 

  if ( !rg.debugShaderEnabled )
  {
    defaultWaveWaterFloatZImage = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
    v24 = *taskInfo->attachments;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v24);
      defaultWaveWaterFloatZImage = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v12 = *lmapColor;
    viewInfo->input.codePersistentImages[15] = &defaultWaveWaterFloatZImage->m_base;
    whiteImage = (R_RT_Image *)rgp.whiteImage;
    v24 = v12;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v24);
      whiteImage = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v14 = *lmapSH;
    viewInfo->input.codeImages[36] = &whiteImage->m_base;
    p_m_image = (R_RT_Image *)rgp.whiteImage;
    v24 = v14;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v24);
      p_m_image = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codeImages[37] = &p_m_image->m_base;
    defaultFogLightmapImage = (R_RT_Image *)rgp.defaultFogLightmapImage;
    v24 = *lmapFog;
    enabled = fx_gpu_deferred_fog->current.enabled;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v24);
      if ( enabled )
        defaultFogLightmapImage = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codeImages[38] = &defaultFogLightmapImage->m_base;
    blackImage = (R_RT_Image *)rgp.blackImage;
    v24 = *packedStencil;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v24);
      blackImage = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codeImages[79] = &blackImage->m_base;
    v19 = 0i64;
    p_count = &g_R_TG_emissiveGroups[*taskInfo->pTaskData].count;
    if ( *p_count )
    {
      v21 = &g_R_TG_emissiveGroups[*taskInfo->pTaskData];
      do
      {
        v22 = (__int64)&v21->drawLists[v19];
        if ( (unsigned int)(*(_DWORD *)v22 - 19) > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_emissive.h", 72, ASSERT_TYPE_ASSERT, "(drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE)", (const char *)&queryFormat, "drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE") )
          __debugbreak();
        taskFlags = taskInfo->pGraphInfo->taskFlags;
        if ( (taskFlags & *(_DWORD *)(v22 + 4)) == *(_DWORD *)(v22 + 4) && (taskFlags & *(_DWORD *)(v22 + 8)) == 0 )
          R_AddDrawCall(viewInfo, &taskInfo->rtGroup, *(GfxDrawListType *)v22, 0x5Du);
        v19 = (unsigned int)(v19 + 1);
      }
      while ( (unsigned int)v19 < *p_count );
    }
  }
}

/*
==============
RT_DrawEmissiveSetup
==============
*/
void RT_DrawEmissiveSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle *attachments; 
  R_RT_Handle v3; 
  R_RT_Handle v4; 
  R_RT_Handle v5; 
  R_RT_Handle v6; 
  R_RT_Handle v7; 
  R_RT_Handle v8; 
  __m256i v9; 

  attachments = taskInfo->attachments;
  v3 = attachments[8];
  v6 = attachments[18];
  v4 = attachments[7];
  v7 = v3;
  v5 = attachments[6];
  v8 = v4;
  v9 = (__m256i)v5;
  RT_DrawEmissiveCommonSetup(taskInfo, viewInfo, (R_RT_Handle *)&v9, &v8, &v7, &v6);
}

