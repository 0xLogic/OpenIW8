/*
==============
Util_KickoffToken
==============
*/

void __fastcall Util_KickoffToken(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?Util_KickoffToken@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawOpaqueSetup
==============
*/

void __fastcall RT_DrawOpaqueSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawOpaqueSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>, const R_TG_Handle *<args_24>, const R_TG_Handle *<args_25>)
{
  return ??$cRBT_DrawOpaque@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>, <args_24>, <args_25>);
}

/*
==============
RBT_DrawDecal
==============
*/

void __fastcall RBT_DrawDecal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawDecal@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>)
{
  return ??$cRBT_DrawDecal@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>);
}

/*
==============
cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cUtil_KickoffToken@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RT_DrawDecalSetup
==============
*/

void __fastcall RT_DrawDecalSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawDecalSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_DrawOpaque
==============
*/

void __fastcall RBT_DrawOpaque(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOpaque@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawDecal.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>);
}

/*
==============
cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>, const R_TG_Handle *<args_24>, const R_TG_Handle *<args_25>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawOpaque.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>, <args_24>, <args_25>);
}

/*
==============
cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_KickoffToken.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBT_DrawDecal
==============
*/
void RBT_DrawDecal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, DRAWLIST_LIT_DECAL);
}

/*
==============
RBT_DrawOpaque
==============
*/
void RBT_DrawOpaque(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const dvar_t *v4; 
  unsigned int taskFlags; 
  __int64 v9; 
  __int64 v10; 
  const R_TG_DrawList *v11; 
  const dvar_t *v12; 

  v4 = r_flushCommandListsAt_Flags;
  taskFlags = taskInfo->pGraphInfo->taskFlags;
  if ( !r_flushCommandListsAt_Flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 627, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  v9 = 0i64;
  v10 = 13i64;
  do
  {
    v11 = &g_R_TG_opaqueGroups[0].drawLists[v9];
    if ( (taskFlags & g_R_TG_opaqueGroups[0].drawLists[v9].enableFlags) == g_R_TG_opaqueGroups[0].drawLists[v9].enableFlags && (taskFlags & v11->disableFlags) == 0 )
      RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, v11->type);
    ++v9;
    --v10;
  }
  while ( v10 );
  v12 = r_flushCommandListsAt_Flags;
  if ( !r_flushCommandListsAt_Flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 627, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
}

/*
==============
RT_DrawDecalSetup
==============
*/
void RT_DrawDecalSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Image *blackImage3D; 
  R_RT_Image *whiteImage3D; 
  R_RT_Image *whiteImage; 
  R_RT_Image *defaultWaveWaterFloatZImage; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v20; 

  _RAX = taskInfo->attachments;
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    blackImage3D = &R_RT_Handle::GetSurface(&v20)->m_image;
  }
  else if ( v20.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v20.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[25] = &blackImage3D->m_base;
  _RAX = taskInfo->attachments;
  whiteImage3D = (R_RT_Image *)rgp.whiteImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    whiteImage3D = &R_RT_Handle::GetSurface(&v20)->m_image;
  }
  else if ( v20.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v20.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[26] = &whiteImage3D->m_base;
  _RAX = taskInfo->attachments;
  whiteImage = (R_RT_Image *)rgp.whiteImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+120h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    whiteImage = &R_RT_Handle::GetSurface(&v20)->m_image;
  }
  else if ( v20.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v20.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[27] = &whiteImage->m_base;
  _RAX = taskInfo->attachments;
  defaultWaveWaterFloatZImage = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+2A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    defaultWaveWaterFloatZImage = &R_RT_Handle::GetSurface(&v20)->m_image;
  }
  else if ( v20.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v20.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[15] = &defaultWaveWaterFloatZImage->m_base;
  _RAX = taskInfo->attachments;
  p_m_image = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+2A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    p_m_image = &R_RT_Handle::GetSurface(&v20)->m_image;
  }
  else if ( v20.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v20.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codeImages[77] = &p_m_image->m_base;
  R_AddDrawCall(viewInfo, &taskInfo->rtGroup, DRAWLIST_LIT_DECAL, 0x5Du);
}

/*
==============
RT_DrawOpaqueSetup
==============
*/
void RT_DrawOpaqueSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  GfxCmdBufInput *p_input; 
  R_RT_Image *blackImage3D; 
  R_RT_Image *p_m_image; 
  R_RT_Image *blackImage; 
  R_RT_Image *whiteImage; 
  R_RT_Image *v29; 
  bool v31; 
  R_RT_Image *blackShadowImage; 
  bool v35; 
  R_RT_Image *whiteUintImage; 
  R_RT_Image *v40; 
  R_RT_Image *v43; 
  R_RT_Image *v46; 
  GfxImage *v48; 
  GfxWrappedBuffer *p_dummyDataBufferR32UINT; 
  const R_RT_Surface *Surface; 
  GfxWrappedBuffer *p_dummyStructuredBuffer8; 
  const R_RT_Surface *v56; 
  __int64 v57; 
  __int64 v58; 
  unsigned int taskFlags; 
  const R_TG_DrawList *v60; 
  R_RT_Handle v61; 

  _RAX = taskInfo->attachments;
  p_input = &viewInfo->input;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  R_SetInputCodePersistentBuffer(&viewInfo->input, 0xAu, &v61);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  R_SetInputCodePersistentBuffer(p_input, 0xBu, &v61);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  R_SetInputCodePersistentBuffer(p_input, 6u, &v61);
  _RAX = taskInfo->attachments;
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    blackImage3D = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[21] = &blackImage3D->m_base;
  _RAX = taskInfo->attachments;
  p_m_image = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    p_m_image = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[22] = &p_m_image->m_base;
  _RAX = taskInfo->attachments;
  blackImage = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    blackImage = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[0] = &blackImage->m_base;
  _RAX = taskInfo->attachments;
  whiteImage = (R_RT_Image *)rgp.whiteImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    whiteImage = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[10] = &whiteImage->m_base;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+140h]
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  R_SetInputCodePersistentBuffer(p_input, 0x11u, &v61);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+160h]
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  R_SetInputCodePersistentBuffer(p_input, 0x10u, &v61);
  _RAX = taskInfo->attachments;
  v29 = (R_RT_Image *)rgp.whiteImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+180h]
    vmovd   eax, xmm0
  }
  v31 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
  __asm { vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0 }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    if ( v31 )
      v29 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[0] = &v29->m_base;
  _RAX = taskInfo->attachments;
  blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+1A0h]
    vmovd   eax, xmm0
  }
  v35 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
  __asm { vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0 }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    if ( v35 )
      blackShadowImage = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[8] = &blackShadowImage->m_base;
  _RAX = taskInfo->attachments;
  whiteUintImage = (R_RT_Image *)rgp.whiteUintImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+1C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    whiteUintImage = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[9] = &whiteUintImage->m_base;
  _RAX = taskInfo->attachments;
  v40 = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+1E0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v40 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[7] = &v40->m_base;
  _RAX = taskInfo->attachments;
  v43 = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+200h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v43 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[11] = &v43->m_base;
  _RAX = taskInfo->attachments;
  v46 = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+260h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v46 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[80] = &v46->m_base;
  v48 = rgp.blackImage;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[12] = v48;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+280h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    Surface = R_RT_Handle::GetSurface(&v61);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v61.m_surfaceID) )
      __debugbreak();
    p_dummyDataBufferR32UINT = (GfxWrappedBuffer *)&Surface->1080;
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
      __debugbreak();
    p_dummyDataBufferR32UINT = &gfxBuf.dummyDataBufferR32UINT;
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1503, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentBuffers[14] = p_dummyDataBufferR32UINT;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+2A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+var_20.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v56 = R_RT_Handle::GetSurface(&v61);
    if ( (v56->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v61.m_surfaceID) )
      __debugbreak();
    p_dummyStructuredBuffer8 = (GfxWrappedBuffer *)&v56->1080;
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
      __debugbreak();
    p_dummyStructuredBuffer8 = &gfxBuf.dummyStructuredBuffer8;
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeBuffers[43] = p_dummyStructuredBuffer8;
  v57 = 0i64;
  v58 = 13i64;
  taskFlags = taskInfo->pGraphInfo->taskFlags;
  do
  {
    v60 = &g_R_TG_opaqueGroups[0].drawLists[v57];
    if ( (taskFlags & g_R_TG_opaqueGroups[0].drawLists[v57].enableFlags) == g_R_TG_opaqueGroups[0].drawLists[v57].enableFlags && (taskFlags & v60->disableFlags) == 0 )
      R_AddDrawCall(viewInfo, &taskInfo->rtGroup, v60->type, 0x5Du);
    ++v57;
    --v58;
  }
  while ( v58 );
}

/*
==============
Util_KickoffToken
==============
*/
void Util_KickoffToken(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

