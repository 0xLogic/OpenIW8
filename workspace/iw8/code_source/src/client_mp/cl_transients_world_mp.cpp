/*
==============
CL_TransientsWorldMP_DrawOverlay
==============
*/

void __fastcall CL_TransientsWorldMP_DrawOverlay(LocalClientNum_t screenLocalClient)
{
  ?CL_TransientsWorldMP_DrawOverlay@@YAXW4LocalClientNum_t@@@Z(screenLocalClient);
}

/*
==============
CL_TransientsWorldMP_GetBudgetBytes
==============
*/

unsigned __int64 __fastcall CL_TransientsWorldMP_GetBudgetBytes()
{
  return ?CL_TransientsWorldMP_GetBudgetBytes@@YA_KXZ();
}

/*
==============
CL_TransientsWorldMP_SoakTestUpdate
==============
*/

void CL_TransientsWorldMP_SoakTestUpdate(void)
{
  ?CL_TransientsWorldMP_SoakTestUpdate@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnPlayAgainRestart
==============
*/

void CL_TransientsWorldMP_OnPlayAgainRestart(void)
{
  ?CL_TransientsWorldMP_OnPlayAgainRestart@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnLevelLoad
==============
*/

void CL_TransientsWorldMP_OnLevelLoad(void)
{
  ?CL_TransientsWorldMP_OnLevelLoad@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsLOD0
==============
*/

bool __fastcall CL_TransientsWorldMP_IsLOD0(unsigned int transientIndex)
{
  return ?CL_TransientsWorldMP_IsLOD0@@YA_NI@Z(transientIndex);
}

/*
==============
CL_TransientsWorldMP_OnLobbyToGameStart
==============
*/

void CL_TransientsWorldMP_OnLobbyToGameStart(void)
{
  ?CL_TransientsWorldMP_OnLobbyToGameStart@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadAllowed
==============
*/

void CL_TransientsWorldMP_OnLevelPreloadAllowed(void)
{
  ?CL_TransientsWorldMP_OnLevelPreloadAllowed@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance
==============
*/

bool __fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  return ?Advance@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAA_NXZ(this);
}

/*
==============
CL_TransientsWorldMP_OnFirstSnapshot
==============
*/

void CL_TransientsWorldMP_OnFirstSnapshot(void)
{
  ?CL_TransientsWorldMP_OnFirstSnapshot@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsBRMode
==============
*/

bool __fastcall CL_TransientsWorldMP_IsBRMode()
{
  return ?CL_TransientsWorldMP_IsBRMode@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds
==============
*/

const Bounds *__fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  return ?GetCurrentBounds@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAAAEBUBounds@@XZ(this);
}

/*
==============
CL_TransientsWorldMP_ErrorCleanup
==============
*/

void CL_TransientsWorldMP_ErrorCleanup(void)
{
  ?CL_TransientsWorldMP_ErrorCleanup@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_SetGridStreamingClientStreamViews
==============
*/

void __fastcall CL_TransientsWorldMP_SetGridStreamingClientStreamViews(LocalClientNum_t localClientNum)
{
  ?CL_TransientsWorldMP_SetGridStreamingClientStreamViews@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadCancel
==============
*/

void CL_TransientsWorldMP_OnLevelPreloadCancel(void)
{
  ?CL_TransientsWorldMP_OnLevelPreloadCancel@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnServerShutdown
==============
*/

void CL_TransientsWorldMP_OnServerShutdown(void)
{
  ?CL_TransientsWorldMP_OnServerShutdown@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_AnyTilesVisibleAtLOD
==============
*/

bool __fastcall CL_TransientsWorldMP_AnyTilesVisibleAtLOD(const LocalClientNum_t localClientNum, const unsigned int lodLevel)
{
  return ?CL_TransientsWorldMP_AnyTilesVisibleAtLOD@@YA_NW4LocalClientNum_t@@I@Z(localClientNum, lodLevel);
}

/*
==============
CL_TransientsWorldMP_AddLobbyStreamPositions
==============
*/

void __fastcall CL_TransientsWorldMP_AddLobbyStreamPositions(const vec3_t *pos)
{
  ?CL_TransientsWorldMP_AddLobbyStreamPositions@@YAXAEBTvec3_t@@@Z(pos);
}

/*
==============
CL_TransientsWorldMP_DrawBounds
==============
*/

void CL_TransientsWorldMP_DrawBounds(void)
{
  ?CL_TransientsWorldMP_DrawBounds@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_RegisterFileIndex
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterFileIndex(unsigned __int16 mpSystemFileIndex, const char *name)
{
  ?CL_TransientsWorldMP_RegisterFileIndex@@YAXGPEBD@Z(mpSystemFileIndex, name);
}

/*
==============
CL_TransientsWorldMP_GetLODFileCount
==============
*/

unsigned int __fastcall CL_TransientsWorldMP_GetLODFileCount(unsigned int lodLevel)
{
  return ?CL_TransientsWorldMP_GetLODFileCount@@YAII@Z(lodLevel);
}

/*
==============
CL_TransientsWorldMP_BeginListenServerStall
==============
*/

void CL_TransientsWorldMP_BeginListenServerStall(void)
{
  ?CL_TransientsWorldMP_BeginListenServerStall@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsZoomLoadActive
==============
*/

bool __fastcall CL_TransientsWorldMP_IsZoomLoadActive(const LocalClientNum_t localClientNum)
{
  return ?CL_TransientsWorldMP_IsZoomLoadActive@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_TransientsWorldMP_ResetLobbyStreamPositions
==============
*/

void CL_TransientsWorldMP_ResetLobbyStreamPositions(void)
{
  ?CL_TransientsWorldMP_ResetLobbyStreamPositions@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_DrawPriorityGraph
==============
*/

void __fastcall CL_TransientsWorldMP_DrawPriorityGraph(const LocalClientNum_t screenLocalClient)
{
  ?CL_TransientsWorldMP_DrawPriorityGraph@@YAXW4LocalClientNum_t@@@Z(screenLocalClient);
}

/*
==============
CL_TransientsWorldMP_ProcessFastfiles
==============
*/

void CL_TransientsWorldMP_ProcessFastfiles(void)
{
  ?CL_TransientsWorldMP_ProcessFastfiles@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Init
==============
*/

void __fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::Init(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  ?Init@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAAXXZ(this);
}

/*
==============
CL_TransientsWorldMP_HasLobbyStreamPositions
==============
*/

bool __fastcall CL_TransientsWorldMP_HasLobbyStreamPositions()
{
  return ?CL_TransientsWorldMP_HasLobbyStreamPositions@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_UpdateMissingModels
==============
*/

void CL_TransientsWorldMP_UpdateMissingModels(void)
{
  ?CL_TransientsWorldMP_UpdateMissingModels@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_GetChangeVisible
==============
*/

const bitarray<1536> *__fastcall CL_TransientsWorldMP_GetChangeVisible()
{
  return ?CL_TransientsWorldMP_GetChangeVisible@@YAPEBV?$bitarray@$0GAA@@@XZ();
}

/*
==============
CL_TransientsWorldMP_UseLowAlwaysloadedFlagging
==============
*/

bool __fastcall CL_TransientsWorldMP_UseLowAlwaysloadedFlagging()
{
  return ?CL_TransientsWorldMP_UseLowAlwaysloadedFlagging@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_AnyMissingModels
==============
*/

bool __fastcall CL_TransientsWorldMP_AnyMissingModels()
{
  return ?CL_TransientsWorldMP_AnyMissingModels@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_UpdateIgnoreTransientSkip
==============
*/

void CL_TransientsWorldMP_UpdateIgnoreTransientSkip(void)
{
  ?CL_TransientsWorldMP_UpdateIgnoreTransientSkip@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_HasGridStreamingCompletedForPosition
==============
*/

bool __fastcall CL_TransientsWorldMP_HasGridStreamingCompletedForPosition(const LocalClientNum_t localClientNum, const vec3_t *pos)
{
  return ?CL_TransientsWorldMP_HasGridStreamingCompletedForPosition@@YA_NW4LocalClientNum_t@@AEBTvec3_t@@@Z(localClientNum, pos);
}

/*
==============
CL_TransientsWorldMP_OnLevelUnload
==============
*/

void CL_TransientsWorldMP_OnLevelUnload(void)
{
  ?CL_TransientsWorldMP_OnLevelUnload@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles(const char *name, const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles@@YAXPEBDPEBUTransientInfo@@@Z(name, transientInfo);
}

/*
==============
InterleavedPriorities::GetPriority
==============
*/

unsigned __int16 __fastcall InterleavedPriorities::GetPriority(InterleavedPriorities *this, const unsigned __int64 tileIndex, const unsigned __int16 lod1Index, const bool insideLod0Cell)
{
  return ?GetPriority@InterleavedPriorities@@QEAAG_KG_N@Z(this, tileIndex, lod1Index, insideLod0Cell);
}

/*
==============
CL_TransientsWorldMP_UnregisterGridStreamingInfo
==============
*/

void __fastcall CL_TransientsWorldMP_UnregisterGridStreamingInfo(const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_UnregisterGridStreamingInfo@@YAXPEBUTransientInfo@@@Z(transientInfo);
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfo
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterGridStreamingInfo(const char *name, const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_RegisterGridStreamingInfo@@YAXPEBDPEBUTransientInfo@@@Z(name, transientInfo);
}

/*
==============
CL_TransientsWorldMP_ResetGridStreaming
==============
*/

void __fastcall CL_TransientsWorldMP_ResetGridStreaming(bool useSplitscreenRadius)
{
  ?CL_TransientsWorldMP_ResetGridStreaming@@YAX_N@Z(useSplitscreenRadius);
}

/*
==============
CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading
==============
*/

void CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading(void)
{
  ?CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_GetXB3BudgetBytes
==============
*/

unsigned __int64 __fastcall CL_TransientsWorldMP_GetXB3BudgetBytes()
{
  return ?CL_TransientsWorldMP_GetXB3BudgetBytes@@YA_KXZ();
}

/*
==============
CL_TransientsWorldMP_GetLobbyStreamPositions
==============
*/

unsigned int __fastcall CL_TransientsWorldMP_GetLobbyStreamPositions(vec3_t *outPos, unsigned int outPosSize)
{
  return ?CL_TransientsWorldMP_GetLobbyStreamPositions@@YAIPEATvec3_t@@I@Z(outPos, outPosSize);
}

/*
==============
CL_TransientsWorldMP_IsActive
==============
*/

bool __fastcall CL_TransientsWorldMP_IsActive()
{
  return ?CL_TransientsWorldMP_IsActive@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_GetMemoryMaxMB
==============
*/

__int64 __fastcall CL_TransientsWorldMP_GetMemoryMaxMB(WorldStreamingQuality qualityLevel)
{
  return ?CL_TransientsWorldMP_GetMemoryMaxMB@@YA_JW4WorldStreamingQuality@@@Z(qualityLevel);
}

/*
==============
InterleavedPriorities::Insert
==============
*/

unsigned __int16 __fastcall InterleavedPriorities::Insert(InterleavedPriorities *this, const unsigned int trIndex, const bool insideCell)
{
  return ?Insert@InterleavedPriorities@@QEAAGI_N@Z(this, trIndex, insideCell);
}

/*
==============
CL_TransientsWorldMP_EndListenServerStall
==============
*/

void CL_TransientsWorldMP_EndListenServerStall(void)
{
  ?CL_TransientsWorldMP_EndListenServerStall@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnFrontendPreload
==============
*/

void CL_TransientsWorldMP_OnFrontendPreload(void)
{
  ?CL_TransientsWorldMP_OnFrontendPreload@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance
==============
*/
bool CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  unsigned int m_currentBits; 
  unsigned int m_wordCount; 
  __int64 v4; 
  unsigned int v5; 
  unsigned int v6; 
  bool result; 

  m_currentBits = this->m_currentBits;
  if ( !m_currentBits )
  {
    m_wordCount = this->m_wordCount;
    LODWORD(v4) = this->m_wordIndex;
    do
    {
      v4 = (unsigned int)(v4 + 1);
      if ( (unsigned int)v4 >= m_wordCount )
        break;
      this->m_wordIndex = v4;
      m_currentBits = s_transientsWorldMP.changedVisible.array[v4];
      this->m_currentBits = m_currentBits;
    }
    while ( !m_currentBits );
    if ( !m_currentBits )
      return 0;
  }
  v5 = __lzcnt(m_currentBits);
  this->m_currentTransientIndex = v5 + 32 * this->m_wordIndex;
  v6 = m_currentBits & ~(0x80000000 >> (v5 & 0x1F));
  result = 1;
  this->m_currentBits = v6;
  return result;
}

/*
==============
CL_TransientsWorldMPValidateVisibilityState
==============
*/
char CL_TransientsWorldMPValidateVisibilityState()
{
  bitarray<1536> *visibleTarget; 
  __int64 v1; 
  unsigned int v2; 
  unsigned int v3; 
  bitarray<1536> *v4; 
  unsigned int v5; 
  bitarray<1536> *v6; 
  unsigned int v7; 
  bitarray<1536> *v8; 
  unsigned int v9; 
  bitarray<1536> *p_changedVisible; 
  bitarray<1536> *p_wantVisibleButNotLoaded; 

  visibleTarget = s_transientsWorldMP.visibleTarget;
  v1 = 2i64;
  v2 = 0;
  do
  {
    v3 = 0;
    v4 = visibleTarget - 2;
    while ( !v4->array[0] )
    {
      ++v3;
      v4 = (bitarray<1536> *)((char *)v4 + 4);
      if ( v3 >= 0x30 )
        goto LABEL_8;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1864, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleCurrent[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleCurrent[i].anyBitsOn()") )
      __debugbreak();
LABEL_8:
    v5 = 0;
    v6 = visibleTarget;
    while ( !v6->array[0] )
    {
      ++v5;
      v6 = (bitarray<1536> *)((char *)v6 + 4);
      if ( v5 >= 0x30 )
        goto LABEL_14;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1865, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleTarget[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleTarget[i].anyBitsOn()") )
      __debugbreak();
LABEL_14:
    v7 = 0;
    v8 = visibleTarget + 2;
    while ( !v8->array[0] )
    {
      ++v7;
      v8 = (bitarray<1536> *)((char *)v8 + 4);
      if ( v7 >= 0x30 )
        goto LABEL_20;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1866, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleHint[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleHint[i].anyBitsOn()") )
      __debugbreak();
LABEL_20:
    ++visibleTarget;
    --v1;
  }
  while ( v1 );
  v9 = 0;
  p_changedVisible = &s_transientsWorldMP.changedVisible;
  while ( !p_changedVisible->array[0] )
  {
    ++v9;
    p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 4);
    if ( v9 >= 0x30 )
      goto LABEL_27;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1868, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.changedVisible.anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.changedVisible.anyBitsOn()") )
    __debugbreak();
LABEL_27:
  p_wantVisibleButNotLoaded = &s_transientsWorldMP.wantVisibleButNotLoaded;
  while ( !p_wantVisibleButNotLoaded->array[0] )
  {
    ++v2;
    p_wantVisibleButNotLoaded = (bitarray<1536> *)((char *)p_wantVisibleButNotLoaded + 4);
    if ( v2 >= 0x30 )
      return (char)p_wantVisibleButNotLoaded;
  }
  LOBYTE(p_wantVisibleButNotLoaded) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1870, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.wantVisibleButNotLoaded.anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.wantVisibleButNotLoaded.anyBitsOn()");
  if ( (_BYTE)p_wantVisibleButNotLoaded )
    __debugbreak();
  return (char)p_wantVisibleButNotLoaded;
}

/*
==============
CL_TransientsWorldMP_AddGridStreamingPosInternal
==============
*/
__int64 CL_TransientsWorldMP_AddGridStreamingPosInternal(const LocalClientNum_t localClientNum, const vec3_t *pos, const vec3_t *angles, const bool streamRender, const vec3_t *velocity, const bool mainCamera, const bool nextCamera, const float loadDist)
{
  __int64 numStreamPositions; 
  float v19; 
  __int64 v27; 
  const dvar_t *v28; 
  WorldStreamPosition *v29; 
  unsigned int localClientIndex; 
  bool v31; 
  __int64 v33; 
  __int64 v34; 

  _R13 = angles;
  _R12 = pos;
  if ( s_transientsWorldMP.numStreamPositions >= 0xE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3300, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", s_transientsWorldMP.numStreamPositions, 14) )
    __debugbreak();
  if ( mainCamera && mainCamera == nextCamera && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3302, ASSERT_TYPE_ASSERT, "( (!mainCamera && !nextCamera) || (mainCamera != nextCamera) )", "Can't have both 'main' and 'next' cameras set") )
    __debugbreak();
  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  __asm
  {
    vmovss  xmm1, [rsp+68h+loadDist]
    vmulss  xmm3, xmm1, xmm1
    vxorps  xmm2, xmm3, cs:__xmm@80000000800000008000000080000000
  }
  ++s_transientsWorldMP.numStreamPositions;
  __asm { vmovsd  xmm0, qword ptr [r12] }
  _RDI = &s_transientsWorldMP.streamPositions[numStreamPositions];
  __asm { vmovsd  qword ptr [rdi], xmm0 }
  _RDI->pos.v[2] = _R12->v[2];
  __asm
  {
    vmovsd  xmm0, qword ptr [r13+0]
    vmovsd  qword ptr [rdi+0Ch], xmm0
  }
  v19 = _R13->v[2];
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcmpless xmm1, xmm0, xmm1
    vblendvps xmm1, xmm2, xmm3, xmm1
    vmovss  dword ptr [rdi+90h], xmm1
  }
  _RDI->angles.v[2] = v19;
  _RDI->streamRender = streamRender;
  _RDI->mainCamera = mainCamera;
  _RDI->nextCamera = nextCamera;
  _RDI->localClientIndex = localClientNum;
  _RDI->fallingHint = 0;
  CL_TransientsWorldMP_FillGridStreamingPosViewInfo(localClientNum, streamRender, mainCamera, _RDI);
  _RBP = velocity;
  if ( localClientNum == LOCAL_CLIENT_0 && mainCamera )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0]
      vmovss  dword ptr cs:s_transientsWorldMP.lastVelocityClient0, xmm0
      vmovss  xmm1, dword ptr [rbp+4]
      vmovss  dword ptr cs:s_transientsWorldMP.lastVelocityClient0+4, xmm1
      vmovss  xmm0, dword ptr [rbp+8]
      vmovss  dword ptr cs:s_transientsWorldMP.lastVelocityClient0+8, xmm0
    }
  }
  v27 = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions >= 0xE )
  {
    LODWORD(v34) = 14;
    LODWORD(v33) = s_transientsWorldMP.numStreamPositions;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3327, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", v33, v34) )
      __debugbreak();
    v27 = s_transientsWorldMP.numStreamPositions;
  }
  v28 = DVARBOOL_cl_transientWorldStreamLookAheadEnabled;
  v29 = &s_transientsWorldMP.streamPositions[v27];
  if ( !DVARBOOL_cl_transientWorldStreamLookAheadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v28);
  if ( v28->current.enabled )
  {
    localClientIndex = _RDI->localClientIndex;
    if ( localClientIndex >= 2 )
    {
      LODWORD(v34) = 2;
      LODWORD(v33) = _RDI->localClientIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v33, v34) )
        __debugbreak();
    }
    if ( (int)localClientIndex < cg_t::ms_allocatedCount )
    {
      v31 = _RDI->nextCamera;
      if ( _RDI->mainCamera )
      {
        if ( v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1087, ASSERT_TYPE_ASSERT, "( !playerPos.nextCamera )", "Shouldn't be both main and next cameras") )
          __debugbreak();
        if ( !_RDI->streamRender || _RDI->zoomLoad || !CL_TransientsWorldMP_AddVelocityHintPos_Internal(&s_transientsWorldMP.streamPositions[numStreamPositions], v29, velocity, 1) )
          return (unsigned int)numStreamPositions;
      }
      else if ( !v31 || !CL_TransientsWorldMP_AddVelocityHintPos_Internal(&s_transientsWorldMP.streamPositions[numStreamPositions], v29, velocity, 0) )
      {
        return (unsigned int)numStreamPositions;
      }
      ++s_transientsWorldMP.numStreamPositions;
    }
  }
  return (unsigned int)numStreamPositions;
}

/*
==============
CL_TransientsWorldMP_AddLobbyStreamPositions
==============
*/
void CL_TransientsWorldMP_AddLobbyStreamPositions(const vec3_t *pos)
{
  __int64 lobbyStreamPosCount; 

  lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  _RBX = pos;
  if ( s_transientsWorldMP.lobbyStreamPosCount >= 2 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3431, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.lobbyStreamPosCount ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lobbyStreamPos ) ) + 0 ) )", "s_transientsWorldMP.lobbyStreamPosCount doesn't index ARRAY_COUNT( s_transientsWorldMP.lobbyStreamPos )\n\t%i not in [0, %i)", s_transientsWorldMP.lobbyStreamPosCount, 2) )
      __debugbreak();
    lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  }
  __asm { vmovsd  xmm0, qword ptr [rbx] }
  _RCX = lobbyStreamPosCount;
  _RDX = s_transientsWorldMP.lobbyStreamPos;
  __asm { vmovsd  qword ptr [rdx+rcx*4], xmm0 }
  s_transientsWorldMP.lobbyStreamPos[_RCX].v[2] = _RBX->v[2];
  ++s_transientsWorldMP.lobbyStreamPosCount;
}

/*
==============
CL_TransientsWorldMP_AddVelocityHintPos_Internal
==============
*/
bool CL_TransientsWorldMP_AddVelocityHintPos_Internal(WorldStreamPosition *playerPos, WorldStreamPosition *outHintPos, const vec3_t *velocity, const bool mainCamera)
{
  char v27; 
  char v28; 
  int v44; 
  bool result; 
  _BYTE v58[128]; 
  int v61; 
  char v62; 
  void *retaddr; 

  _RAX = &retaddr;
  _RDI = DVARFLT_cl_transientWorldStreamLookAheadTime;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  _RBX = outHintPos;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovss  xmm8, dword ptr [r8+8]
    vmovss  xmm6, dword ptr [r8]
    vmovss  xmm7, dword ptr [r8+4]
  }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm0, dword ptr [rdi+28h] }
  _RDI = DVARFLT_cl_transientWorldStreamLookAheadMinDist;
  __asm
  {
    vmulss  xmm7, xmm7, xmm0
    vmulss  xmm8, xmm8, xmm0
    vmulss  xmm1, xmm7, xmm7
    vmulss  xmm6, xmm6, xmm0
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm8, xmm8
    vaddss  xmm9, xmm2, xmm1
  }
  if ( !DVARFLT_cl_transientWorldStreamLookAheadMinDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMinDist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmulss  xmm1, xmm0, xmm0
    vcomiss xmm9, xmm1
  }
  if ( v27 | v28 )
  {
    result = 0;
  }
  else
  {
    _RDI = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
    if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, xmm0
      vcomiss xmm9, xmm1
    }
    if ( !(v27 | v28) )
    {
      __asm { vmovss  xmm1, cs:__real@3f800000 }
      _RDI = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
      __asm
      {
        vsqrtss xmm2, xmm9, xmm9
        vcmpless xmm0, xmm2, cs:__real@80000000
        vblendvps xmm0, xmm2, xmm1, xmm0
        vdivss  xmm1, xmm1, xmm0
        vmulss  xmm6, xmm6, xmm1
        vmulss  xmm7, xmm7, xmm1
        vmulss  xmm8, xmm8, xmm1
      }
      if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+28h]
        vmulss  xmm6, xmm6, xmm0
        vmulss  xmm7, xmm7, xmm0
        vmulss  xmm8, xmm8, xmm0
      }
    }
    memset_0(v58, 0, 0x9Cui64);
    __asm
    {
      vmovups ymm0, [rsp+138h+var_F8]
      vmovups ymm1, [rsp+138h+var_D8]
    }
    v44 = v61;
    __asm
    {
      vmovups ymmword ptr [rbx], ymm0
      vmovups ymm0, [rsp+138h+var_B8]
      vmovups ymmword ptr [rbx+20h], ymm1
      vmovups ymm1, [rsp+138h+var_98]
      vmovups ymmword ptr [rbx+40h], ymm0
      vmovups xmm0, [rsp+138h+var_78]
      vmovups ymmword ptr [rbx+60h], ymm1
      vmovsd  xmm1, [rsp+138h+var_68]
      vmovups xmmword ptr [rbx+80h], xmm0
      vmovsd  qword ptr [rbx+90h], xmm1
    }
    *(_DWORD *)&_RBX->zoomLoad = v44;
    __asm
    {
      vaddss  xmm0, xmm6, dword ptr [rsi]
      vmovss  dword ptr [rbx], xmm0
      vaddss  xmm1, xmm7, dword ptr [rsi+4]
      vmovss  dword ptr [rbx+4], xmm1
      vaddss  xmm0, xmm8, dword ptr [rsi+8]
      vmovss  dword ptr [rbx+8], xmm0
    }
    _RBX->loadDistLimitSq = playerPos->loadDistLimitSq;
    result = 1;
  }
  _R11 = &v62;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  return result;
}

/*
==============
CL_TransientsWorldMP_AnyMissingModels
==============
*/
_BOOL8 CL_TransientsWorldMP_AnyMissingModels()
{
  return s_transientsWorldMP.anyMissingModels;
}

/*
==============
CL_TransientsWorldMP_AnyTilesVisibleAtLOD
==============
*/
char CL_TransientsWorldMP_AnyTilesVisibleAtLOD(const LocalClientNum_t localClientNum, const unsigned int lodLevel)
{
  __int64 v2; 
  bitarray<1536> *v4; 
  unsigned int v5; 
  unsigned int v6; 
  const unsigned __int16 *HighLODLookups; 
  unsigned int v8; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3772, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
      __debugbreak();
    LODWORD(v13) = 2;
    LODWORD(v11) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3773, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.visibleCurrent ) ) + 0 ) )", "localClientNum doesn't index s_transientsWorldMP.visibleCurrent\n\t%i not in [0, %i)", v11, v13) )
      __debugbreak();
  }
  if ( lodLevel >= 2 )
  {
    LODWORD(v12) = 2;
    LODWORD(v10) = lodLevel;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3774, ASSERT_TYPE_ASSERT, "(unsigned)( lodLevel ) < (unsigned)( CL_TRANSIENT_WORLD_LOD_LEVELS )", "lodLevel doesn't index CL_TRANSIENT_WORLD_LOD_LEVELS\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v4 = &s_transientsWorldMP.visibleCurrent[v2];
  v5 = 1;
  v6 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  if ( v6 <= 1 )
    return 0;
  while ( 1 )
  {
    HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v5);
    v8 = lodLevel ? HighLODLookups[lodLevel - 1] : v5;
    if ( v8 >= 0x600 )
    {
      LODWORD(v12) = 1536;
      LODWORD(v10) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v10, v12) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v8 & 0x1F)) & v4->array[(unsigned __int64)v8 >> 5]) != 0 )
      break;
    if ( ++v5 >= v6 )
      return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded
==============
*/
bool CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded(const LocalClientNum_t localClientNum, const vec3_t *visPos)
{
  signed __int64 v2; 
  void *v6; 
  bool v8; 
  const vec3_t *v9; 
  __int64 v10; 
  const dvar_t *v12; 
  const dvar_t *v15; 
  const dvar_t *v18; 
  int integer; 
  int v21; 
  SpatialPartition_Tree *transientWorldGridSpatial; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  char v52; 
  const unsigned __int16 *HighLODLookups; 
  unsigned int v55; 
  const dvar_t *v56; 
  unsigned int v57; 
  unsigned __int64 v58; 
  unsigned int v59; 
  bool result; 
  __int64 v64; 
  __int64 v65; 
  __int64 v66; 
  char v67[4464]; 
  char v70; 

  v6 = alloca(v2);
  __asm
  {
    vmovaps [rsp+1228h+var_48], xmm6
    vmovaps [rsp+1228h+var_58], xmm7
  }
  _RBP = (unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_QWORD *)(_RBP + 4448) = (unsigned __int64)&v64 ^ _security_cookie;
  v8 = s_transientsWorldMP.worldGridInfo == NULL;
  v9 = visPos;
  *(_QWORD *)_RBP = visPos;
  v10 = localClientNum;
  if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3507, ASSERT_TYPE_ASSERT, "(CL_TransientsWorldMP_IsActive())", (const char *)&queryFormat, "CL_TransientsWorldMP_IsActive()") )
    __debugbreak();
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0);
  __asm { vmulss  xmm6, xmm0, cs:s_transientsWorldMP.radiusMultiplier }
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadius(1u, v9);
  v12 = DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv0;
  __asm { vmovaps xmm7, xmm0 }
  if ( !DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamSyncRadiusMulLv0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  __asm { vmulss  xmm6, xmm6, dword ptr [rbx+28h] }
  v15 = DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv1;
  __asm { vmovss  dword ptr [rbp+38h], xmm6 }
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamSyncRadiusMulLv1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  __asm
  {
    vmulss  xmm0, xmm7, dword ptr [rbx+28h]
    vmaxss  xmm1, xmm0, xmm6
    vmovss  dword ptr [rbp+3Ch], xmm1
  }
  CL_TransientsWorldMP_GetWorldStreamParamsInternal((WorldStreamParameters *)(_RBP + 48), v9);
  if ( (unsigned int)v10 >= 2 )
  {
    LODWORD(v66) = 2;
    LODWORD(v65) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3512, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamSyncDraw ) ) + 0 ) )", "localClientNum doesn't index s_transientsWorldMP.streamSyncDraw\n\t%i not in [0, %i)", v65, v66) )
      __debugbreak();
  }
  v18 = DCONST_DVARINT_cl_transientWorldOverlayStreamSyncTimeout;
  _RDI = &s_transientsWorldMP.streamSyncDraw[v10];
  if ( !DCONST_DVARINT_cl_transientWorldOverlayStreamSyncTimeout && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayStreamSyncTimeout") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  integer = v18->current.integer;
  v21 = Sys_Milliseconds();
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+30h]
    vmovups xmm1, xmmword ptr [rbp+50h]
    vmovups ymmword ptr [rdi+10h], ymm0
    vmovups xmmword ptr [rdi+30h], xmm1
  }
  _RDI->requestEndTime = integer + v21;
  _RDI->params.visRadiusMaxSq = *(float *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60);
  _RDI->pos.v[0] = v9->v[0];
  _RDI->pos.v[1] = v9->v[1];
  _RDI->pos.v[2] = v9->v[2];
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3519, ASSERT_TYPE_ASSERT, "( ( s_transientsWorldMP.worldGridInfo != nullptr ) )", "( s_transientsWorldMP.worldGridInfo ) = %p", NULL) )
    __debugbreak();
  transientWorldGridSpatial = s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial;
  if ( !transientWorldGridSpatial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3521, ASSERT_TYPE_ASSERT, "( ( spatial != nullptr ) )", "( spatial ) = %p", NULL) )
    __debugbreak();
  __asm { vmovss  xmm3, dword ptr [rbp+5Ch]; radius }
  *(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) = 0i64;
  *(_DWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148) = 0;
  *(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) = 0i64;
  *(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) = 0i64;
  SpatialPartition_Tree_SphereIterator::Init((SpatialPartition_Tree_SphereIterator *)(_RBP + 128), transientWorldGridSpatial, v9, *(float *)&_XMM3);
  if ( SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(_RBP + 128)) )
  {
    __asm { vmovss  xmm7, dword ptr [rbp+60h] }
    while ( 1 )
    {
      if ( !*(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
        __debugbreak();
      v27 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) + 20i64);
      v28 = *(_DWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148);
      if ( v28 == v27 )
      {
        if ( !*(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
          __debugbreak();
        if ( (**(_BYTE **)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
          __debugbreak();
        if ( *(_DWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) >= **(unsigned __int8 **)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
          __debugbreak();
        v29 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) + 4i64 * *(unsigned int *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) + 4);
      }
      else
      {
        if ( v28 >= v27 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
            __debugbreak();
          v28 = *(_DWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148);
        }
        v29 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v67 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) + 8i64) + 4i64 * v28);
      }
      if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3528, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
        __debugbreak();
      if ( v29 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
      {
        LODWORD(v66) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
        LODWORD(v65) = v29;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3529, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v65, v66) )
          __debugbreak();
      }
      _RDX = 3i64 * v29;
      _RCX = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+rdx*8]
        vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+0Ch]
        vmovss  dword ptr [rbp+18h], xmm1
        vmovss  xmm0, dword ptr [rcx+rdx*8+4]
        vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+10h]
        vmovss  dword ptr [rbp+1Ch], xmm1
        vmovss  xmm0, dword ptr [rcx+rdx*8+8]
        vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+14h]
        vmovss  dword ptr [rbp+20h], xmm1
        vmovss  xmm0, dword ptr [rcx+rdx*8]
        vaddss  xmm1, xmm0, dword ptr [rcx+rdx*8+0Ch]
        vmovss  dword ptr [rbp+24h], xmm1
        vmovss  xmm2, dword ptr [rcx+rdx*8+10h]
        vaddss  xmm0, xmm2, dword ptr [rcx+rdx*8+4]
        vmovss  dword ptr [rbp+28h], xmm0
        vmovss  xmm1, dword ptr [rcx+rdx*8+14h]
        vaddss  xmm2, xmm1, dword ptr [rcx+rdx*8+8]
        vmovss  dword ptr [rbp+2Ch], xmm2
      }
      PointToClosestAABBPoint((const vec3_t *)(_RBP + 24), (const vec3_t *)(_RBP + 36), v9, (vec3_t *)(_RBP + 8));
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+8]
        vmovss  xmm1, dword ptr [rbp+0Ch]
        vmulss  xmm3, xmm0, xmm0
        vmovss  xmm0, dword ptr [rbp+10h]
        vmulss  xmm2, xmm1, xmm1
        vmulss  xmm1, xmm0, xmm0
        vaddss  xmm4, xmm3, xmm2
        vaddss  xmm6, xmm4, xmm1
        vcomiss xmm6, xmm7
      }
      if ( v52 | v8 )
        break;
LABEL_70:
      if ( !SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(_RBP + 128)) )
        goto LABEL_71;
    }
    HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v29);
    _R15 = _RBP + 64;
    v55 = 0;
    while ( 1 )
    {
      v56 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
      if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v56);
      if ( (signed int)v55 >= v56->current.integer )
      {
        __asm { vcomiss xmm6, dword ptr [r15] }
        if ( v55 <= v56->current.integer )
        {
          if ( v55 )
            v57 = HighLODLookups[v55 - 1];
          else
            v57 = v29;
          if ( v57 >= 0x600 )
          {
            LODWORD(v66) = 1536;
            LODWORD(v65) = v57;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v65, v66) )
              __debugbreak();
          }
          v58 = (unsigned __int64)v57 >> 5;
          v59 = 0x80000000 >> (v57 & 0x1F);
          if ( (v59 & s_transientsWorldMP.requested.array[v58]) != 0 )
            break;
        }
      }
      ++v55;
      _R15 += 4i64;
      if ( v55 >= 2 )
        goto LABEL_69;
    }
    if ( v57 >= 0x600 )
    {
      LODWORD(v66) = 1536;
      LODWORD(v65) = v57;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v65, v66) )
        __debugbreak();
    }
    if ( (v59 & s_transientsWorldMP.loaded.array[v58]) != 0 )
    {
LABEL_69:
      v9 = *(const vec3_t **)_RBP;
      goto LABEL_70;
    }
    result = 0;
  }
  else
  {
LABEL_71:
    result = 1;
  }
  _R11 = &v70;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
CL_TransientsWorldMP_BeginListenServerStall
==============
*/
void CL_TransientsWorldMP_BeginListenServerStall(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3743, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_CancelInFlightLoads();
  if ( s_transientsWorldMP.listenServerStall && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3748, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.listenServerStall)", (const char *)&queryFormat, "!s_transientsWorldMP.listenServerStall") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 1;
}

/*
==============
CL_TransientsWorldMP_CalcLoadPriorityDistance
==============
*/

float __fastcall CL_TransientsWorldMP_CalcLoadPriorityDistance(const WorldStreamPosition *worldStreamPos, double distSqXY, double distZ, const unsigned int lod, const Bounds *bounds, const float cellSize, const bool useZoomedDistances, const bool isStreamingHint, const bool lod0Missing, const float viewDot, const float cellExteriorAddition, const float lod0VisRadiusSq, const float lod1FalloffDistSq, const bool lod1BoostBRMethod)
{
  char v27; 
  bool v28; 
  const dvar_t *v40; 
  const dvar_t *v49; 
  char v94; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  _RBX = worldStreamPos;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm10
    vxorps  xmm10, xmm10, xmm10
    vucomiss xmm1, xmm10
    vmovaps xmm8, xmm2
    vmovaps xmm6, xmm1
    vmovaps [rsp+0B8h+var_28], xmm7
    vmovaps [rsp+0B8h+var_48], xmm9
    vmovss  xmm9, [rsp+0B8h+cellExteriorAddition]
  }
  if ( lod )
  {
    if ( lod == 1 )
    {
      v27 = 0;
      v28 = !useZoomedDistances;
      if ( !useZoomedDistances )
      {
        v27 = 0;
        v28 = !isStreamingHint;
        if ( !isStreamingHint )
        {
          __asm
          {
            vmovss  xmm3, [rsp+0B8h+viewDot]; viewDot
            vmovss  xmm1, dword ptr [rbx+28h]; viewZDir
            vmovss  xmm0, dword ptr [rbx+8]; viewZPos
            vmovaps xmm2, xmm6; distSqXY
          }
          *(float *)&_XMM0 = CL_TransientsWorldMP_CalcViewDotBoostInAir(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2, *(const float *)&_XMM3);
          __asm
          {
            vcomiss xmm0, xmm10
            vmovaps xmm7, xmm0
          }
          if ( !(v27 | v28) )
          {
            v27 = 0;
            v28 = !lod1BoostBRMethod;
            if ( lod1BoostBRMethod )
            {
              *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirBRDistance, "cl_transientWorldLoadXYLOD1BoostInAirBRDistance");
              __asm
              {
                vmulss  xmm1, xmm0, xmm0
                vmulss  xmm2, xmm1, xmm7
                vminss  xmm3, xmm2, xmm9
                vsubss  xmm9, xmm9, xmm3
              }
            }
            else
            {
              __asm
              {
                vmovss  xmm0, cs:__real@3f800000
                vsubss  xmm1, xmm0, xmm7
                vmulss  xmm6, xmm6, xmm1
                vmulss  xmm8, xmm8, xmm1
              }
            }
          }
        }
      }
      __asm
      {
        vmovss  xmm0, [rsp+0B8h+lod1FalloffDistSq]
        vcomiss xmm6, xmm0
      }
      if ( !(v27 | v28) )
      {
        v40 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffMultiplier;
        __asm { vsubss  xmm7, xmm6, xmm0 }
        if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffMultiplier") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v40);
        __asm
        {
          vmulss  xmm0, xmm7, dword ptr [rdi+28h]
          vaddss  xmm9, xmm9, xmm0
        }
      }
      __asm
      {
        vmovss  xmm7, [rsp+0B8h+lod0VisRadiusSq]
        vcomiss xmm6, xmm7
      }
      if ( useZoomedDistances )
      {
        if ( v27 | v28 )
          goto LABEL_43;
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+38h]
          vmulss  xmm1, xmm0, xmm0
          vcomiss xmm6, xmm1
          vmovss  xmm0, dword ptr [rbx+3Ch]
          vmulss  xmm1, xmm0, xmm0
          vcomiss xmm6, xmm1
        }
      }
      if ( !(v27 | v28) )
      {
        v49 = DCONST_DVARFLT_cl_transientWorldLoadXYMultiplierAddLOD1;
        __asm { vsubss  xmm6, xmm6, xmm7 }
        if ( !DCONST_DVARFLT_cl_transientWorldLoadXYMultiplierAddLOD1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYMultiplierAddLOD1") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v49);
        __asm
        {
          vmulss  xmm0, xmm6, dword ptr [rbx+28h]
          vaddss  xmm6, xmm0, xmm7
        }
      }
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1013, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Bad LOD %d", lod) )
    {
      __debugbreak();
    }
  }
  else
  {
    _RDI = DVARFLT_cl_transientWorldLoadZLOD0AdjustEndZ;
    __asm
    {
      vmovaps [rsp+0B8h+var_68], xmm11
      vmovaps [rsp+0B8h+var_78], xmm12
      vmovss  xmm11, dword ptr [rbx+8]
    }
    if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustEndZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustEndZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm7, dword ptr [rdi+28h] }
    _RDI = DVARFLT_cl_transientWorldLoadZLOD0AdjustStartZ;
    if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustStartZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustStartZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm1, dword ptr [rdi+28h]; rampStart
      vmovaps xmm2, xmm7; rampEnd
      vmovaps xmm0, xmm11; value
    }
    *(float *)&_XMM0 = LinearRamp(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
    __asm
    {
      vcomiss xmm0, xmm10
      vmovaps xmm12, xmm0
    }
    if ( !(v27 | v28) )
    {
      _RDI = DVARFLT_cl_transientWorldLoadZLOD0AdjustEndDist;
      __asm
      {
        vmulss  xmm1, xmm8, xmm8
        vaddss  xmm2, xmm1, xmm6
        vsqrtss xmm11, xmm2, xmm2
      }
      if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustEndDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustEndDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm { vmovss  xmm7, dword ptr [rdi+28h] }
      _RDI = DVARFLT_cl_transientWorldLoadZLOD0AdjustStartDist;
      if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustStartDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustStartDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+28h]; rampStart
        vmovaps xmm2, xmm7; rampEnd
        vmovaps xmm0, xmm11; value
      }
      *(float *)&_XMM0 = LinearRamp(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
      __asm
      {
        vcomiss xmm0, xmm10
        vmovaps xmm7, xmm0
      }
      if ( !(v27 | v28) )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldLoadZLOD0AdjustMaxAddition, "cl_transientWorldLoadZLOD0AdjustMaxAddition");
        __asm
        {
          vmulss  xmm1, xmm0, xmm0
          vmulss  xmm2, xmm1, xmm12
          vmulss  xmm3, xmm2, xmm7
          vaddss  xmm9, xmm3, xmm9
        }
      }
    }
    __asm
    {
      vmovaps xmm12, [rsp+0B8h+var_78]
      vmovaps xmm11, [rsp+0B8h+var_68]
    }
    if ( useZoomedDistances )
    {
      __asm
      {
        vmovss  xmm7, [rsp+0B8h+lod0VisRadiusSq]
        vcomiss xmm6, xmm7
        vmovss  xmm0, dword ptr [rbx+38h]
        vmulss  xmm1, xmm0, xmm0
        vcomiss xmm6, xmm1
      }
    }
  }
LABEL_43:
  __asm
  {
    vmovaps xmm7, [rsp+0B8h+var_28]
    vmulss  xmm0, xmm8, xmm8
    vaddss  xmm1, xmm0, xmm6
    vaddss  xmm0, xmm1, xmm9
    vmovaps xmm9, [rsp+0B8h+var_48]
  }
  _R11 = &v94;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_CalcViewDotBoostInAir
==============
*/

float __fastcall CL_TransientsWorldMP_CalcViewDotBoostInAir(double viewZPos, double viewZDir, double distSqXY, double viewDot)
{
  char v19; 
  char v20; 
  const dvar_t *v47; 
  const dvar_t *v51; 
  const dvar_t *v64; 
  char v85; 
  void *retaddr; 

  _RAX = &retaddr;
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps [rsp+0C8h+var_88], xmm13
    vmovaps xmm13, xmm1
    vmovaps xmm8, xmm3
    vmovaps xmm10, xmm2
    vmovaps xmm12, xmm0
  }
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+0C8h+var_18], xmm6
    vmovaps [rsp+0C8h+var_48], xmm9
    vmovaps [rsp+0C8h+var_68], xmm11
  }
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vcomiss xmm12, dword ptr [rbx+28h]
    vxorps  xmm7, xmm7, xmm7
  }
  if ( v19 | v20 )
    goto LABEL_55;
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirDotEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirDotStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+28h]; rampStart
    vmovaps xmm2, xmm6; rampEnd
    vmovaps xmm0, xmm8; value
  }
  *(float *)&_XMM0 = LinearRamp(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd;
  __asm { vmovaps xmm9, xmm0 }
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirNearDistStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+28h]; rampStart
    vmovaps xmm2, xmm6; rampEnd
    vmovaps xmm0, xmm10; valueSq
  }
  LinearRampSq(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd;
  __asm
  {
    vmovss  xmm11, cs:__real@3f800000
    vsubss  xmm8, xmm11, xmm0
  }
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirFarDistStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+28h]; rampStart
    vmovaps xmm2, xmm6; rampEnd
    vmovaps xmm0, xmm10; valueSq
  }
  LinearRampSq(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
  __asm
  {
    vsubss  xmm1, xmm11, xmm0
    vmaxss  xmm0, xmm8, xmm9
    vmulss  xmm9, xmm1, xmm0
    vcomiss xmm9, xmm7
  }
  if ( v19 | v20 )
  {
LABEL_55:
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  else
  {
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZEnd") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vcomiss xmm6, dword ptr [rbx+28h] }
    if ( v19 | v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 860, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd, \"cl_transientWorldLoadXYLOD1BoostInAirZEnd\" ) > Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart, \"cl_transientWorldLoadXYLOD1BoostInAirZStart\" ))", (const char *)&queryFormat, "Dconst_GetFloat( cl_transientWorldLoadXYLOD1BoostInAirZEnd ) > Dconst_GetFloat( cl_transientWorldLoadXYLOD1BoostInAirZStart )") )
      __debugbreak();
    v47 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v47);
    __asm { vsubss  xmm7, xmm12, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZEnd") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    v51 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v51);
    __asm { vsubss  xmm0, xmm6, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ;
    __asm
    {
      vdivss  xmm1, xmm7, xmm0
      vminss  xmm8, xmm1, xmm11
    }
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+28h]; rampStart
      vmovaps xmm2, xmm6; rampEnd
      vmovaps xmm0, xmm13; value
    }
    *(float *)&_XMM0 = LinearRamp(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish;
    __asm { vmovaps xmm6, xmm0 }
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm7, dword ptr [rbx+28h] }
    v64 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v64);
    __asm
    {
      vsubss  xmm0, xmm11, xmm6
      vmulss  xmm1, xmm0, dword ptr [rbx+28h]
      vmulss  xmm0, xmm7, xmm6
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm8, xmm9
      vmulss  xmm0, xmm2, xmm1
    }
  }
  __asm { vmovaps xmm11, [rsp+0C8h+var_68] }
  _R11 = &v85;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm9, [rsp+0C8h+var_48]
    vmovaps xmm6, [rsp+0C8h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_CancelInFlightLoads
==============
*/
void CL_TransientsWorldMP_CancelInFlightLoads()
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3597, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  v0 = 0;
  v1 = 0i64;
  do
  {
    v2 = 0x80000000 >> (v0 & 0x1F);
    v3 = v1 >> 5;
    if ( (v2 & s_transientsWorldMP.loaded.array[v3]) == 0 && (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
    {
      CL_TransientsWorldMP_UnloadIndex(v0);
      if ( (v2 & s_transientsWorldMP.requested.array[v3]) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3605, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.requested.testBit( i ))", (const char *)&queryFormat, "!s_transientsWorldMP.requested.testBit( i )") )
        __debugbreak();
    }
    ++v0;
    ++v1;
  }
  while ( v0 < 0x600 );
}

/*
==============
CL_TransientsWorldMP_ClearLoadState
==============
*/
__int64 CL_TransientsWorldMP_ClearLoadState()
{
  __int64 v0; 
  bitarray<1536> *p_requested; 
  __int64 v2; 
  bitarray<1536> *p_loaded; 
  __int64 result; 

  v0 = 3i64;
  p_requested = &s_transientsWorldMP.requested;
  v2 = 3i64;
  do
  {
    *(_QWORD *)p_requested->array = 0i64;
    *(_QWORD *)&p_requested->array[2] = 0i64;
    *(_QWORD *)&p_requested->array[4] = 0i64;
    p_requested = (bitarray<1536> *)((char *)p_requested + 64);
    *(_QWORD *)&p_requested[-1].array[38] = 0i64;
    *(_QWORD *)&p_requested[-1].array[40] = 0i64;
    *(_QWORD *)&p_requested[-1].array[42] = 0i64;
    *(_QWORD *)&p_requested[-1].array[44] = 0i64;
    *(_QWORD *)&p_requested[-1].array[46] = 0i64;
    --v2;
  }
  while ( v2 );
  s_transientsWorldMP.requestedCount = 0;
  p_loaded = &s_transientsWorldMP.loaded;
  do
  {
    *(_QWORD *)p_loaded->array = 0i64;
    *(_QWORD *)&p_loaded->array[2] = 0i64;
    *(_QWORD *)&p_loaded->array[4] = 0i64;
    p_loaded = (bitarray<1536> *)((char *)p_loaded + 64);
    *(_QWORD *)&p_loaded[-1].array[38] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[40] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[42] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[44] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[46] = 0i64;
    --v0;
  }
  while ( v0 );
  CL_TransientsWorldMP_ClearVisibilityState(0i64, 0i64, 0i64);
  TransientCostCalc_Reset(&s_transientsWorldMP.worldCost);
  result = 0i64;
  *(_DWORD *)&s_transientsWorldMP.lastFastfileState.backtoFE = 0;
  s_transientsWorldMP.lastFastfileState.inLobbyState = 0;
  return result;
}

/*
==============
CL_TransientsWorldMP_ClearVisibilityState
==============
*/
bitarray<1536> *CL_TransientsWorldMP_ClearVisibilityState()
{
  unsigned int *v0; 
  __int64 v1; 
  __int64 v2; 
  bitarray<1536> *p_changedVisible; 
  __int64 v4; 
  bitarray<1536> *result; 

  v0 = &s_transientsWorldMP.visibleCurrent[0].array[2];
  v1 = 2i64;
  do
  {
    *((_QWORD *)v0 - 1) = 0i64;
    *(_QWORD *)v0 = 0i64;
    *((_QWORD *)v0 + 1) = 0i64;
    *((_QWORD *)v0 + 2) = 0i64;
    *((_QWORD *)v0 + 3) = 0i64;
    *((_QWORD *)v0 + 4) = 0i64;
    *((_QWORD *)v0 + 5) = 0i64;
    *((_QWORD *)v0 + 6) = 0i64;
    *((_QWORD *)v0 + 7) = 0i64;
    *((_QWORD *)v0 + 8) = 0i64;
    *((_QWORD *)v0 + 9) = 0i64;
    *((_QWORD *)v0 + 10) = 0i64;
    *((_QWORD *)v0 + 11) = 0i64;
    *((_QWORD *)v0 + 12) = 0i64;
    *((_QWORD *)v0 + 13) = 0i64;
    *((_QWORD *)v0 + 14) = 0i64;
    *((_QWORD *)v0 + 15) = 0i64;
    *((_QWORD *)v0 + 16) = 0i64;
    *((_QWORD *)v0 + 17) = 0i64;
    *((_QWORD *)v0 + 18) = 0i64;
    *((_QWORD *)v0 + 19) = 0i64;
    *((_QWORD *)v0 + 20) = 0i64;
    *((_QWORD *)v0 + 21) = 0i64;
    *((_QWORD *)v0 + 22) = 0i64;
    *((_QWORD *)v0 + 47) = 0i64;
    *((_QWORD *)v0 + 48) = 0i64;
    *((_QWORD *)v0 + 49) = 0i64;
    *((_QWORD *)v0 + 50) = 0i64;
    *((_QWORD *)v0 + 51) = 0i64;
    *((_QWORD *)v0 + 52) = 0i64;
    *((_QWORD *)v0 + 53) = 0i64;
    *((_QWORD *)v0 + 54) = 0i64;
    *((_QWORD *)v0 + 55) = 0i64;
    *((_QWORD *)v0 + 56) = 0i64;
    *((_QWORD *)v0 + 57) = 0i64;
    *((_QWORD *)v0 + 58) = 0i64;
    *((_QWORD *)v0 + 59) = 0i64;
    *((_QWORD *)v0 + 60) = 0i64;
    *((_QWORD *)v0 + 61) = 0i64;
    *((_QWORD *)v0 + 62) = 0i64;
    *((_QWORD *)v0 + 63) = 0i64;
    *((_QWORD *)v0 + 64) = 0i64;
    *((_QWORD *)v0 + 65) = 0i64;
    *((_QWORD *)v0 + 66) = 0i64;
    *((_QWORD *)v0 + 67) = 0i64;
    *((_QWORD *)v0 + 68) = 0i64;
    *((_QWORD *)v0 + 69) = 0i64;
    *((_QWORD *)v0 + 70) = 0i64;
    *((_QWORD *)v0 + 95) = 0i64;
    *((_QWORD *)v0 + 96) = 0i64;
    *((_QWORD *)v0 + 97) = 0i64;
    *((_QWORD *)v0 + 98) = 0i64;
    *((_QWORD *)v0 + 99) = 0i64;
    *((_QWORD *)v0 + 100) = 0i64;
    *((_QWORD *)v0 + 101) = 0i64;
    *((_QWORD *)v0 + 102) = 0i64;
    *((_QWORD *)v0 + 103) = 0i64;
    *((_QWORD *)v0 + 104) = 0i64;
    *((_QWORD *)v0 + 105) = 0i64;
    *((_QWORD *)v0 + 106) = 0i64;
    *((_QWORD *)v0 + 107) = 0i64;
    *((_QWORD *)v0 + 108) = 0i64;
    *((_QWORD *)v0 + 109) = 0i64;
    *((_QWORD *)v0 + 110) = 0i64;
    *((_QWORD *)v0 + 111) = 0i64;
    *((_QWORD *)v0 + 112) = 0i64;
    *((_QWORD *)v0 + 113) = 0i64;
    *((_QWORD *)v0 + 114) = 0i64;
    *((_QWORD *)v0 + 115) = 0i64;
    *((_QWORD *)v0 + 116) = 0i64;
    *((_QWORD *)v0 + 117) = 0i64;
    *((_QWORD *)v0 + 118) = 0i64;
    v0 += 48;
    --v1;
  }
  while ( v1 );
  v2 = 3i64;
  p_changedVisible = &s_transientsWorldMP.changedVisible;
  v4 = 3i64;
  do
  {
    *(_QWORD *)p_changedVisible->array = 0i64;
    *(_QWORD *)&p_changedVisible->array[2] = 0i64;
    *(_QWORD *)&p_changedVisible->array[4] = 0i64;
    p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 64);
    *(_QWORD *)&p_changedVisible[-1].array[38] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[40] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[42] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[44] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[46] = 0i64;
    --v4;
  }
  while ( v4 );
  result = &s_transientsWorldMP.wantVisibleButNotLoaded;
  do
  {
    *(_QWORD *)result->array = 0i64;
    *(_QWORD *)&result->array[2] = 0i64;
    *(_QWORD *)&result->array[4] = 0i64;
    result = (bitarray<1536> *)((char *)result + 64);
    *(_QWORD *)&result[-1].array[38] = 0i64;
    *(_QWORD *)&result[-1].array[40] = 0i64;
    *(_QWORD *)&result[-1].array[42] = 0i64;
    *(_QWORD *)&result[-1].array[44] = 0i64;
    *(_QWORD *)&result[-1].array[46] = 0i64;
    --v2;
  }
  while ( v2 );
  return result;
}

/*
==============
CL_TransientsWorldMP_DrawBounds
==============
*/

void __fastcall CL_TransientsWorldMP_DrawBounds(__int64 a1, __int64 a2, double _XMM2_8)
{
  unsigned int v3; 
  unsigned __int64 v5; 
  __int64 v6; 
  vec3_t origin; 
  vec4_t color; 

  v3 = 0;
  _R14 = 0x140000000ui64;
  v5 = 0i64;
  v6 = 0i64;
  do
  {
    if ( ((0x80000000 >> (v3 & 0x1F)) & s_transientsWorldMP.transientsHighestLOD.array[v5 >> 5]) == 0 && v3 < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
    {
      _RAX = 2i64 * (unsigned int)CL_TransientsWorldMP_GetCellState(v3);
      __asm
      {
        vxorps  xmm2, xmm2, xmm2; yaw
        vmovups xmm0, xmmword ptr ds:rva CELL_STATE_COLORS[r14+rax*8]
      }
      *(_QWORD *)origin.v = 0i64;
      origin.v[2] = 0.0;
      __asm { vmovups xmmword ptr [rsp+88h+color], xmm0 }
      CG_DebugBox(&origin, &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v6], *(float *)&_XMM2_8, &color, 0, 1);
    }
    ++v3;
    ++v5;
    ++v6;
  }
  while ( v3 < 0x600 );
}

/*
==============
CL_TransientsWorldMP_DrawCell
==============
*/
void CL_TransientsWorldMP_DrawCell(CL_DebugMapOverlay *context, const unsigned int gridX, const unsigned int gridY, const unsigned int tileMapIndex)
{
  CL_DebugMapOverlay *v15; 
  __int64 v16; 
  unsigned int transientWorldGridTileMapCount; 
  CL_DebugMapOverlay::ClipMode OverlayClipMode; 
  CL_DebugMapOverlay::ClipMode v29; 
  const dvar_t *v33; 
  unsigned int unsignedInt; 
  bool ShouldDrawCellIndexLabel; 
  unsigned int v43; 
  unsigned __int16 TransientIndex; 
  const dvar_t *v48; 
  const dvar_t *v49; 
  CellState CellState; 
  bool v53; 
  int v54; 
  const dvar_t *v55; 
  bool v63; 
  int v64; 
  const dvar_t *v95; 
  char v104; 
  bool v105; 
  CL_DebugMapOverlay::ClipMode v106; 
  const dvar_t *v107; 
  const dvar_t *v116; 
  const unsigned __int16 *v119; 
  const dvar_t *v132; 
  int CellDelayRemaining; 
  const dvar_t *v134; 
  int v135; 
  const unsigned __int16 *HighLODLookups; 
  const vec4_t *v145; 
  unsigned int v155; 
  __int64 clipMode; 
  __int64 clipModea; 
  __int64 clipModeb; 
  char *v172; 
  char *v173; 
  char *v174; 
  __int64 v175; 
  double v176; 
  __int64 v177; 
  double v178; 
  double v179; 
  double v180; 
  CL_DebugMapOverlay::ClipMode v181; 
  unsigned __int16 v182; 
  int outLodNumber; 
  unsigned int gridYa; 
  unsigned int gridXa; 
  CL_DebugMapOverlay *v186; 
  TransientWorldGridTileMap *tileMap; 
  vec2_t v188; 
  vec2_t pos2D; 
  vec4_t color; 
  vec2_t outMin2D; 
  vec3_t inMax3D; 
  vec2_t outMax2D; 
  vec3_t inMin3D; 
  vec2_t maxPos2D; 
  vec2_t minPos2D; 
  vec2_t v197; 
  vec2_t v198; 
  vec2_t v199; 
  char v210; 

  __asm
  {
    vmovaps [rsp+1D0h+var_A0], xmm11
    vmovaps [rsp+1D0h+var_B0], xmm12
    vmovaps [rsp+1D0h+var_C0], xmm13
    vmovaps [rsp+1D0h+var_D0], xmm14
  }
  v15 = context;
  v186 = context;
  v16 = tileMapIndex;
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  outLodNumber = tileMapIndex;
  gridYa = gridY;
  gridXa = gridX;
  if ( tileMapIndex >= transientWorldGridTileMapCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4132, ASSERT_TYPE_ASSERT, "(unsigned)( tileMapIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )", "tileMapIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount\n\t%i not in [0, %i)", tileMapIndex, transientWorldGridTileMapCount) )
    __debugbreak();
  _RDI = &s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps[v16];
  tileMap = _RDI;
  OverlayClipMode = CL_TransientsWorldMP_GetOverlayClipMode();
  __asm
  {
    vmovss  xmm4, dword ptr [rdi+1Ch]
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r14
    vmulss  xmm1, xmm0, xmm4
    vaddss  xmm5, xmm1, dword ptr [rdi+20h]
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r12
    vmulss  xmm1, xmm0, xmm4
    vaddss  xmm3, xmm1, dword ptr [rdi+24h]
  }
  v29 = OverlayClipMode;
  v181 = OverlayClipMode;
  __asm
  {
    vaddss  xmm0, xmm4, xmm3
    vaddss  xmm2, xmm4, xmm5
    vxorps  xmm11, xmm11, xmm11
    vmovss  dword ptr [rbp+0D0h+inMax3D+4], xmm0
    vmovss  dword ptr [rbp+0D0h+inMax3D], xmm2
    vmovss  dword ptr [rbp+0D0h+inMax3D+8], xmm11
    vmovss  dword ptr [rbp+0D0h+inMin3D], xmm5
    vmovss  dword ptr [rbp+0D0h+inMin3D+4], xmm3
    vmovss  dword ptr [rbp+0D0h+inMin3D+8], xmm11
  }
  CL_DebugMapOverlay::TransformBox(v15, &inMin3D, &inMax3D, &outMin2D, &outMax2D);
  v33 = DCONST_DVARINT_cl_transientWorldOverlayLodCount;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0D0h+outMax2D]
    vmovss  xmm1, dword ptr [rbp+0D0h+outMax2D+4]
    vsubss  xmm12, xmm0, dword ptr [rbp+0D0h+outMin2D]
    vsubss  xmm14, xmm1, dword ptr [rbp+0D0h+outMin2D+4]
  }
  if ( !DCONST_DVARINT_cl_transientWorldOverlayLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayLodCount") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v33);
  unsignedInt = v33->current.unsignedInt;
  __asm { vmovss  xmm1, cs:__real@3f000000 }
  if ( (signed int)_RDI->lodCount < (signed int)unsignedInt )
    unsignedInt = _RDI->lodCount;
  ShouldDrawCellIndexLabel = 0;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rax
  }
  v182 = 0;
  v43 = 0;
  __asm { vdivss  xmm13, xmm1, xmm0 }
  if ( !unsignedInt )
    goto LABEL_72;
  __asm
  {
    vmovaps [rsp+1D0h+var_90], xmm10
    vmovss  xmm10, cs:__real@3f800000
    vmovaps [rsp+1D0h+var_E0], xmm15
    vmovss  xmm15, cs:__real@3f400000
    vmovaps [rsp+1D0h+var_50], xmm6
    vmovaps [rsp+1D0h+var_60], xmm7
    vmovaps [rsp+1D0h+var_70], xmm8
    vmovaps [rsp+1D0h+var_80], xmm9
  }
  do
  {
    TransientIndex = CL_TransientsWorldMP_GetTransientIndex(_RDI, gridXa, gridYa, v43);
    LOWORD(_RDI) = TransientIndex;
    if ( v43 )
    {
      if ( v43 == 2 )
        goto LABEL_16;
    }
    else
    {
      v182 = TransientIndex;
    }
    if ( !ShouldDrawCellIndexLabel )
      ShouldDrawCellIndexLabel = CL_TransientsWorldMP_ShouldDrawCellIndexLabel(TransientIndex);
LABEL_16:
    v48 = DVARBOOL_cl_transientWorldOverlayPriorityColors;
    if ( !DVARBOOL_cl_transientWorldOverlayPriorityColors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v48);
    if ( v48->current.enabled )
      goto LABEL_26;
    v49 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested;
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColorsRequested") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v49);
    if ( v49->current.enabled )
    {
LABEL_26:
      if ( v43 == 2 || !(_WORD)_RDI )
        goto LABEL_51;
      v53 = 0;
      v54 = 0;
      if ( s_transientsWorldMP.fileBackedTransientCount )
      {
        while ( s_transientsWorldMP.priorityOrder[v54] != (_WORD)_RDI )
        {
          if ( ++v54 >= s_transientsWorldMP.fileBackedTransientCount )
            goto LABEL_35;
        }
        _RDI = (TransientWorldGridTileMap *)(unsigned __int16)_RDI;
        if ( (unsigned __int16)_RDI >= 0x600u )
        {
          LODWORD(v172) = 1536;
          LODWORD(clipMode) = (_DWORD)_RDI;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, v172) )
            __debugbreak();
        }
        v53 = ((0x80000000 >> ((unsigned __int8)_RDI & 0x1F)) & s_transientsWorldMP.requested.array[(unsigned __int64)_RDI >> 5]) != 0;
      }
LABEL_35:
      v55 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColorsRequested") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v55);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ecx
        vcvtsi2ss xmm1, xmm1, rax
        vdivss  xmm1, xmm1, xmm0
        vmaxss  xmm1, xmm1, xmm11
        vminss  xmm0, xmm1, xmm10
        vsubss  xmm2, xmm10, xmm0
      }
      if ( v53 || !v55->current.enabled )
      {
        __asm
        {
          vmovss  dword ptr [rsp+1D0h+color], xmm2
          vmovss  dword ptr [rsp+1D0h+color+4], xmm2
          vmovss  dword ptr [rbp+0D0h+color+8], xmm2
        }
      }
      else
      {
        __asm
        {
          vmulss  xmm0, xmm2, xmm15
          vaddss  xmm1, xmm0, cs:__real@3e800000
          vmovss  dword ptr [rsp+1D0h+color], xmm1
          vmovss  dword ptr [rsp+1D0h+color+4], xmm11
          vmovss  dword ptr [rbp+0D0h+color+8], xmm11
        }
      }
      v29 = v181;
      v15 = v186;
      __asm
      {
        vmovaps xmm1, xmm10
        vmovss  dword ptr [rbp+0D0h+color+0Ch], xmm1
      }
    }
    else
    {
      CellState = CL_TransientsWorldMP_GetCellState((unsigned __int16)_RDI);
      _RDX = 0x140000000ui64;
      _RAX = 2i64 * (unsigned int)CellState;
      __asm
      {
        vmovups xmm0, xmmword ptr ds:rva CELL_STATE_COLORS[rdx+rax*8]
        vshufps xmm1, xmm0, xmm0, 0FFh
        vmovups xmmword ptr [rsp+1D0h+color], xmm0
      }
    }
    v63 = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount == 1;
    if ( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount > 1 )
    {
      v64 = outLodNumber;
      if ( outLodNumber > 1 )
        v64 = 1;
      v63 = v64 == 0;
      __asm
      {
        vmulss  xmm1, xmm1, ds:rva OVERLAPPED_TILEMAP_ALPHAS[rdx+rax*4]
        vmovss  dword ptr [rbp+0D0h+color+0Ch], xmm1
      }
    }
    __asm { vucomiss xmm1, xmm11 }
    if ( !v63 )
    {
      __asm
      {
        vmovss  xmm4, dword ptr [rbp+0D0h+outMin2D]
        vmovss  xmm5, dword ptr [rbp+0D0h+outMin2D+4]
        vxorps  xmm2, xmm2, xmm2
        vcvtsi2ss xmm2, xmm2, rax
        vmulss  xmm6, xmm12, xmm13
        vmulss  xmm0, xmm2, xmm6
        vaddss  xmm0, xmm0, xmm4
        vmovss  dword ptr [rsp+1D0h+pos2D], xmm0
        vmulss  xmm7, xmm14, xmm13
        vmulss  xmm1, xmm7, xmm2
        vaddss  xmm0, xmm1, xmm5
        vmulss  xmm2, xmm2, xmm13
        vsubss  xmm3, xmm10, xmm2
        vmovss  dword ptr [rsp+1D0h+pos2D+4], xmm0
        vmulss  xmm0, xmm3, xmm12
        vmulss  xmm2, xmm3, xmm14
        vaddss  xmm1, xmm0, xmm4
        vaddss  xmm3, xmm2, xmm5
        vmovss  dword ptr [rsp+1D0h+var_168], xmm1
        vmovss  dword ptr [rsp+1D0h+var_168+4], xmm3
      }
      if ( v43 + 1 >= unsignedInt )
      {
        CL_DebugMapOverlay::DrawFilledRect2D(v15, &pos2D, &v188, &color, v29);
      }
      else
      {
        __asm
        {
          vxorps  xmm2, xmm2, xmm2
          vcvtsi2ss xmm2, xmm2, rax
          vmulss  xmm0, xmm2, xmm6
          vaddss  xmm9, xmm0, xmm4
          vmulss  xmm1, xmm2, xmm7
          vmulss  xmm0, xmm2, xmm13
          vaddss  xmm6, xmm1, xmm5
          vsubss  xmm1, xmm10, xmm0
          vmulss  xmm0, xmm1, xmm12
          vmulss  xmm1, xmm1, xmm14
        }
        *(vec2_t *)inMax3D.v = pos2D;
        __asm
        {
          vaddss  xmm8, xmm1, xmm5
          vmovss  dword ptr [rbp+0D0h+maxPos2D], xmm9
          vmovss  dword ptr [rbp+0D0h+maxPos2D+4], xmm3
          vaddss  xmm7, xmm0, xmm4
        }
        CL_DebugMapOverlay::DrawFilledRect2D(v15, (const vec2_t *)&inMax3D, &maxPos2D, &color, v29);
        __asm { vmovss  xmm0, dword ptr [rsp+1D0h+pos2D+4] }
        *(vec2_t *)inMax3D.v = v188;
        __asm
        {
          vmovss  dword ptr [rbp+0D0h+minPos2D+4], xmm0
          vmovss  dword ptr [rbp+0D0h+minPos2D], xmm7
        }
        CL_DebugMapOverlay::DrawFilledRect2D(v15, &minPos2D, (const vec2_t *)&inMax3D, &color, v29);
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+1D0h+pos2D+4]
          vmovss  dword ptr [rbp+0D0h+var_100+4], xmm0
          vmovss  dword ptr [rbp+0D0h+var_108], xmm7
          vmovss  dword ptr [rbp+0D0h+var_108+4], xmm6
          vmovss  dword ptr [rbp+0D0h+var_100], xmm9
        }
        CL_DebugMapOverlay::DrawFilledRect2D(v15, &v198, &v197, &color, v29);
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+1D0h+var_168+4]
          vmovss  [rbp+0D0h+var_F4], xmm0
          vmovss  [rbp+0D0h+var_F8], xmm7
          vmovss  dword ptr [rbp+0D0h+inMin3D], xmm9
          vmovss  dword ptr [rbp+0D0h+inMin3D+4], xmm8
        }
        CL_DebugMapOverlay::DrawFilledRect2D(v15, (const vec2_t *)&inMin3D, &v199, &color, v29);
      }
    }
LABEL_51:
    _RDI = tileMap;
    ++v43;
  }
  while ( v43 < unsignedInt );
  __asm { vmovaps xmm15, [rsp+1D0h+var_E0] }
  if ( ShouldDrawCellIndexLabel && v182 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0D0h+outMax2D]
      vaddss  xmm1, xmm0, dword ptr [rbp+0D0h+outMin2D]
      vmovss  xmm8, cs:__real@3f000000
      vmovss  xmm0, dword ptr [rbp+0D0h+outMax2D+4]
    }
    v95 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers;
    __asm
    {
      vandps  xmm12, xmm12, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vmulss  xmm6, xmm12, cs:__real@3c4ccccd
      vmulss  xmm2, xmm1, xmm8
      vaddss  xmm1, xmm0, dword ptr [rbp+0D0h+outMin2D+4]
      vmovss  dword ptr [rsp+1D0h+pos2D], xmm2
      vmulss  xmm2, xmm1, xmm8
      vmovss  dword ptr [rsp+1D0h+pos2D+4], xmm2
    }
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawCellNumbers") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v95);
    __asm { vmovss  xmm7, cs:__real@3eaaaaab }
    if ( v95->current.enabled )
    {
      __asm
      {
        vmovaps xmm3, xmm6; fontScale
        vmovd   r9d, xmm6
      }
      CL_DebugMapOverlay::DrawTextf2D(v15, &pos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorWhite, v29, "%u", v182);
      goto LABEL_59;
    }
    v132 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues;
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawDelayValues") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v132);
    v104 = 0;
    v105 = !v132->current.enabled;
    if ( !v132->current.enabled )
      goto LABEL_59;
    CellDelayRemaining = DB_TransientsWorldMP_GetCellDelayRemaining(0, v182, &outLodNumber);
    v134 = DCONST_DVARBOOL_cl_transientWorldDebugDelay;
    v135 = CellDelayRemaining;
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v134);
    if ( v134->current.enabled )
    {
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v182);
      if ( !HighLODLookups && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4269, ASSERT_TYPE_ASSERT, "(highLodLookups)", (const char *)&queryFormat, "highLodLookups") )
        __debugbreak();
      __asm { vmovss  xmm9, cs:__real@3a83126f }
      v106 = v181;
      v188 = pos2D;
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+1D0h+var_168+4]
        vmulss  xmm10, xmm14, xmm7
        vsubss  xmm1, xmm0, xmm10
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ebx
        vmulss  xmm0, xmm0, xmm9
        vmovss  dword ptr [rsp+1D0h+var_168+4], xmm1
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+1D0h+var_198], xmm1
      }
      v145 = &colorYellow;
      __asm
      {
        vmulss  xmm8, xmm6, xmm8
        vmovaps xmm3, xmm8; fontScale
        vmovd   r9d, xmm3
      }
      if ( v135 )
        v145 = &colorRed;
      CL_DebugMapOverlay::DrawTextf2D(v15, &v188, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, v145, v181, "%.1f", v177);
      if ( v182 >= 0x600u )
      {
        LODWORD(v173) = 1536;
        LODWORD(clipModea) = v182;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4279, ASSERT_TYPE_ASSERT, "(unsigned)( drawCellNumber ) < (unsigned)( ( sizeof( *array_counter( delayTargetArray.data ) ) + 0 ) )", "drawCellNumber doesn't index delayTargetArray.data\n\t%i not in [0, %i)", clipModea, v173) )
          __debugbreak();
      }
      *(vec2_t *)inMax3D.v = pos2D;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovaps xmm3, xmm8; fontScale
        vmovd   r9d, xmm3
        vcvtsi2ss xmm0, xmm0, dword ptr rva s_transientsWorldMP.switchDelayTarget.data[rcx+rax*4]
        vmulss  xmm1, xmm0, xmm9
        vcvtss2sd xmm2, xmm1, xmm1
        vmovsd  [rsp+1D0h+var_198], xmm2
      }
      CL_DebugMapOverlay::DrawTextf2D(v15, (const vec2_t *)&inMax3D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorWhite, v181, "%.1f", v178);
      v155 = *HighLODLookups;
      v104 = 0;
      v105 = v155 == 0;
      if ( *HighLODLookups )
      {
        if ( v155 >= 0x600 )
        {
          LODWORD(v174) = 1536;
          LODWORD(clipModeb) = *HighLODLookups;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4288, ASSERT_TYPE_ASSERT, "(unsigned)( lod1Index ) < (unsigned)( ( sizeof( *array_counter( delayTargetArray.data ) ) + 0 ) )", "lod1Index doesn't index delayTargetArray.data\n\t%i not in [0, %i)", clipModeb, v174) )
            __debugbreak();
        }
        v188.v[0] = pos2D.v[0];
        __asm
        {
          vaddss  xmm1, xmm10, dword ptr [rsp+1D0h+var_168+4]
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, dword ptr rva s_transientsWorldMP.switchDelayTarget.data[rcx+rsi*4]
          vmovss  dword ptr [rsp+1D0h+var_168+4], xmm1
          vmulss  xmm1, xmm0, xmm9
          vcvtss2sd xmm2, xmm1, xmm1
          vmovsd  [rsp+1D0h+var_198], xmm2
          vmovaps xmm3, xmm8; fontScale
          vmovd   r9d, xmm3
        }
        CL_DebugMapOverlay::DrawTextf2D(v15, &v188, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorWhite, v181, "%.1f", v179);
      }
      goto LABEL_60;
    }
    v104 = 0;
    v105 = outLodNumber == 0;
    if ( outLodNumber < 0 )
    {
LABEL_59:
      v106 = v181;
      goto LABEL_60;
    }
    v106 = v181;
    v104 = 0;
    v105 = v135 == 0;
    if ( v135 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ebx
        vmulss  xmm1, xmm0, cs:__real@3a83126f
        vcvtss2sd xmm2, xmm1, xmm1
        vmovsd  [rsp+1D0h+var_198], xmm2
        vmovaps xmm3, xmm6; fontScale
        vmovd   r9d, xmm6
      }
      CL_DebugMapOverlay::DrawTextf2D(v15, &pos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorWhite, v181, "%.1f", v180);
    }
LABEL_60:
    __asm { vcomiss xmm6, cs:__real@3e99999a }
    if ( !(v104 | v105) )
    {
      v107 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawZBoundsTopValue;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawZBoundsTopValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawZBoundsTopValue") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v107);
      if ( v107->current.enabled )
      {
        _RAX = CL_TransientsWorldMP_GetTileBounds(tileMap, gridXa, gridYa, 0);
        __asm
        {
          vmulss  xmm1, xmm14, cs:__real@beaaaaab
          vmulss  xmm3, xmm6, xmm7; fontScale
          vmovd   r9d, xmm3
          vmovss  xmm0, dword ptr [rax+14h]
          vaddss  xmm2, xmm0, dword ptr [rax+8]
        }
        v188.v[0] = pos2D.v[0];
        __asm
        {
          vaddss  xmm1, xmm1, dword ptr [rsp+1D0h+var_168+4]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovsd  [rsp+1D0h+var_198], xmm2
          vmovss  dword ptr [rsp+1D0h+var_168+4], xmm1
        }
        CL_DebugMapOverlay::DrawTextf2D(v15, &v188, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorOrange, v106, "z=%.0f", v176);
      }
      v116 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawLOD1Indices;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawLOD1Indices && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawLOD1Indices") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v116);
      if ( v116->current.enabled )
      {
        v188.v[0] = pos2D.v[0];
        __asm
        {
          vmulss  xmm1, xmm14, xmm7
          vaddss  xmm1, xmm1, dword ptr [rsp+1D0h+var_168+4]
          vmovss  dword ptr [rsp+1D0h+var_168+4], xmm1
        }
        v119 = CL_TransientsWorldMP_GetHighLODLookups(v182);
        __asm
        {
          vmulss  xmm3, xmm6, xmm7; fontScale
          vmovd   r9d, xmm3
        }
        LODWORD(v175) = *v119;
        CL_DebugMapOverlay::DrawTextf2D(v15, &v188, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &colorBlue, v106, "L1:%u", v175);
      }
    }
  }
  __asm
  {
    vmovaps xmm9, [rsp+1D0h+var_80]
    vmovaps xmm8, [rsp+1D0h+var_70]
    vmovaps xmm7, [rsp+1D0h+var_60]
    vmovaps xmm6, [rsp+1D0h+var_50]
    vmovaps xmm10, [rsp+1D0h+var_90]
  }
LABEL_72:
  _R11 = &v210;
  __asm
  {
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
  }
}

/*
==============
CL_TransientsWorldMP_DrawCellOutline
==============
*/
void CL_TransientsWorldMP_DrawCellOutline(CL_DebugMapOverlay *context, const unsigned int gridX, const unsigned int gridY, const unsigned int tileMapIndex, bool insideCell)
{
  unsigned int v9; 
  unsigned int v10; 
  unsigned int transientWorldGridTileMapCount; 
  __int64 v12; 
  CL_DebugMapOverlay::ClipMode OverlayClipMode; 
  const dvar_t *v15; 
  CL_DebugMapOverlay::ClipMode v16; 
  char v20; 
  unsigned int v21; 
  unsigned int v22; 
  unsigned __int16 TransientIndex; 
  unsigned int v24; 
  unsigned __int16 v26; 
  const unsigned __int16 *HighLODLookups; 
  int v28; 
  unsigned __int16 v29; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned int *v32; 
  unsigned int v33; 
  unsigned __int16 v34; 
  unsigned int v35; 
  char v36; 
  unsigned int v37; 
  unsigned int *v38; 
  bool v39; 
  CL_DebugMapOverlay::ClipMode v42; 
  unsigned __int16 v43; 
  unsigned __int16 v44; 
  __int64 v78; 
  __int64 v79; 
  char *v80; 
  char *v81; 
  char v82; 
  unsigned __int16 v83; 
  unsigned int v85; 
  const unsigned __int16 *v86; 
  Bounds *bounds; 
  vec2_t gridXa; 
  vec2_t clipMode; 
  vec4_t color; 
  __m256i v92; 
  __m256i v94; 

  v9 = gridY;
  v10 = gridX;
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  v12 = tileMapIndex;
  LODWORD(gridXa.v[0]) = gridX;
  if ( tileMapIndex >= transientWorldGridTileMapCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4331, ASSERT_TYPE_ASSERT, "(unsigned)( tileMapIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )", "tileMapIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount\n\t%i not in [0, %i)", tileMapIndex, transientWorldGridTileMapCount) )
    __debugbreak();
  _R12 = &s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps[v12];
  OverlayClipMode = CL_TransientsWorldMP_GetOverlayClipMode();
  v15 = DVARBOOL_cl_transientWorldOverlayBounds;
  v16 = OverlayClipMode;
  LODWORD(clipMode.v[0]) = OverlayClipMode;
  if ( !DVARBOOL_cl_transientWorldOverlayBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayBounds") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  if ( v15->current.enabled )
  {
    __asm
    {
      vmovups ymm0, cs:__ymm@3f800000000000003ecccccd3f4ccccd3f800000000000003f4ccccd3ecccccd
      vmovups xmm1, cs:__xmm@3f8000003f4ccccd0000000000000000
      vmovups [rbp+40h+var_B8], ymm0
      vmovups ymm0, cs:__ymm@3f800000000000003f4000003f8000003f800000000000003f8000003f400000
      vmovups [rbp+40h+var_88], ymm0
      vmovups [rbp+40h+var_98], xmm1
      vmovups [rbp+40h+var_68], xmm1
    }
    v20 = 0;
    bounds = (Bounds *)CL_TransientsWorldMP_GetTileBounds(_R12, v10, v9, 0);
    v21 = 0;
    v82 = 0;
    v22 = 0;
    if ( _R12->lodCount )
    {
      do
      {
        TransientIndex = CL_TransientsWorldMP_GetTransientIndex(_R12, v10, v9, v22);
        v24 = TransientIndex;
        v20 |= CL_TransientsWorldMP_ShouldDrawCellIndexLabel(TransientIndex);
        if ( ((CL_TransientsWorldMP_GetCellState(v24) - 9) & 0xFFFFFFFD) == 0 )
          break;
        ++v22;
      }
      while ( v22 < _R12->lodCount );
      v82 = v20;
    }
    if ( insideCell )
    {
      __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
    }
    else
    {
      v26 = CL_TransientsWorldMP_GetTransientIndex(_R12, v10, v9, 0);
      v83 = v26;
      v85 = 2;
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v26);
      v86 = HighLODLookups;
      v28 = 0;
      if ( _R12->lodCount )
      {
        while ( 1 )
        {
          v29 = v28 ? HighLODLookups[v28 - 1] : v26;
          v30 = v29;
          if ( v29 )
            break;
LABEL_26:
          if ( ++v28 >= _R12->lodCount )
          {
            v9 = gridY;
            goto LABEL_30;
          }
        }
        v31 = 0;
        v32 = &s_transientsWorldMP.visibleCurrent[0].array[(unsigned __int64)v29 >> 5];
        while ( 1 )
        {
          if ( v30 >= 0x600 )
          {
            LODWORD(v80) = 1536;
            LODWORD(v78) = v30;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v78, v80) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v30 & 0x1F)) & *v32) != 0 )
            break;
          ++v31;
          v32 += 48;
          if ( v31 >= 2 )
          {
            v26 = v83;
            HighLODLookups = v86;
            goto LABEL_26;
          }
        }
        v9 = gridY;
        v85 = v28;
      }
      else
      {
LABEL_30:
        v28 = 2;
      }
      v33 = v28;
      v10 = LODWORD(gridXa.v[0]);
      v34 = CL_TransientsWorldMP_GetTransientIndex(_R12, LODWORD(gridXa.v[0]), v9, v33);
      v35 = v34;
      v36 = 0;
      v37 = 0x80000000 >> (v34 & 0x1F);
      v38 = &s_transientsWorldMP.zoomTransients[0].array[(unsigned __int64)v34 >> 5];
      while ( 1 )
      {
        if ( v35 >= 0x600 )
        {
          LODWORD(v80) = 1536;
          LODWORD(v78) = v35;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v78, v80) )
            __debugbreak();
        }
        if ( (v37 & *v38) != 0 )
          break;
        ++v21;
        v38 += 48;
        if ( v21 >= 2 )
          goto LABEL_39;
      }
      v36 = 1;
LABEL_39:
      if ( v85 >= 3 )
      {
        LODWORD(v80) = 3;
        LODWORD(v78) = v85;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4407, ASSERT_TYPE_ASSERT, "(unsigned)( firstVisibleLod ) < (unsigned)( ( sizeof( *array_counter( BOUNDS_LOD_COLOR ) ) + 0 ) )", "firstVisibleLod doesn't index ARRAY_COUNT( BOUNDS_LOD_COLOR )\n\t%i not in [0, %i)", v78, v80) )
          __debugbreak();
        LODWORD(v81) = 3;
        LODWORD(v79) = v85;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4408, ASSERT_TYPE_ASSERT, "(unsigned)( firstVisibleLod ) < (unsigned)( ( sizeof( *array_counter( BOUNDS_LOD_COLOR_ZOOM ) ) + 0 ) )", "firstVisibleLod doesn't index ARRAY_COUNT( BOUNDS_LOD_COLOR_ZOOM )\n\t%i not in [0, %i)", v79, v81) )
          __debugbreak();
      }
      v20 = v82;
      v39 = v36 == 0;
      _RCX = &v92;
      v9 = gridY;
      if ( !v39 )
        _RCX = &v94;
      _RAX = 2i64 * v85;
      __asm { vmovups xmm0, xmmword ptr [rcx+rax*8] }
    }
    v42 = LODWORD(clipMode.v[0]);
    __asm { vmovups xmmword ptr [rsp+140h+color], xmm0 }
    CL_DebugMapOverlay::DrawBox(context, bounds, 0, &color, SLODWORD(clipMode.v[0]));
    v43 = CL_TransientsWorldMP_GetTransientIndex(_R12, v10, v9, 0);
    v44 = v43;
    if ( v20 )
    {
      if ( v43 != 2 )
      {
        _RAX = bounds;
        __asm
        {
          vmovaps [rsp+140h+var_50], xmm6
          vmovss  xmm6, dword ptr [rax]
          vsubss  xmm0, xmm6, dword ptr [rax+0Ch]
          vmovss  xmm5, dword ptr [rax+4]
          vmovss  xmm3, dword ptr [rax+8]
          vaddss  xmm1, xmm6, dword ptr [rax+0Ch]
          vmovss  dword ptr [rbp+40h+var_B8], xmm0
          vsubss  xmm0, xmm5, dword ptr [rax+10h]
          vmovss  dword ptr [rbp+40h+var_B8+4], xmm0
          vsubss  xmm0, xmm3, dword ptr [rax+14h]
          vmovss  dword ptr [rbp+40h+var_B8+8], xmm0
          vaddss  xmm0, xmm5, dword ptr [rax+10h]
          vmovss  dword ptr [rbp+40h+var_B8+0Ch], xmm1
          vaddss  xmm1, xmm3, dword ptr [rax+14h]
          vmovss  dword ptr [rbp+40h+var_B8+10h], xmm0
          vmovss  dword ptr [rbp+40h+var_B8+14h], xmm1
        }
        CL_DebugMapOverlay::TransformBox(context, (const vec3_t *)&v92, (const vec3_t *)((char *)&v92.m256i_u64[1] + 4), &clipMode, (vec2_t *)&bounds);
        __asm
        {
          vmovss  xmm1, dword ptr [rsp+140h+bounds+4]
          vaddss  xmm2, xmm1, [rsp+140h+var_CC]
          vmovss  xmm4, dword ptr [rsp+140h+bounds]
          vaddss  xmm0, xmm4, [rsp+140h+clipMode]
          vmulss  xmm0, xmm0, cs:__real@3f000000
          vsubss  xmm1, xmm4, [rsp+140h+clipMode]
          vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vmulss  xmm3, xmm1, cs:__real@3c4ccccd; fontScale
          vmovss  [rsp+140h+gridX], xmm0
          vmulss  xmm0, xmm2, cs:__real@3f000000
          vmovd   r9d, xmm3
          vmovss  [rsp+140h+var_D4], xmm0
        }
        CL_DebugMapOverlay::DrawTextf2D(context, &gridXa, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, *(float *)&_XMM3, &color, v42, "%u", v44);
        __asm { vmovaps xmm6, [rsp+140h+var_50] }
      }
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm5, dword ptr [r12+1Ch]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, r15
      vmulss  xmm1, xmm0, xmm5
      vaddss  xmm4, xmm1, dword ptr [r12+20h]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rsi
      vmulss  xmm1, xmm0, xmm5
      vaddss  xmm3, xmm1, dword ptr [r12+24h]
      vxorps  xmm2, xmm2, xmm2
      vaddss  xmm1, xmm5, xmm3
      vaddss  xmm0, xmm5, xmm4
      vmovss  dword ptr [rbp+40h+var_B8+10h], xmm1
      vmovss  dword ptr [rbp+40h+var_B8], xmm4
      vmovss  dword ptr [rbp+40h+var_B8+4], xmm3
      vmovss  dword ptr [rbp+40h+var_B8+8], xmm2
      vmovss  dword ptr [rbp+40h+var_B8+0Ch], xmm0
      vmovss  dword ptr [rbp+40h+var_B8+14h], xmm2
    }
    CL_DebugMapOverlay::DrawExtBox(context, (const ExtentBounds *)&v92, 0, &CL_DebugMapOverlay::WHITE_COLOR, v16);
    if ( insideCell )
      CL_DebugMapOverlay::DrawExtBox(context, (const ExtentBounds *)&v92, -1, &CL_DebugMapOverlay::WHITE_COLOR, v16);
  }
}

/*
==============
CL_TransientsWorldMP_DrawLegend
==============
*/

void __fastcall CL_TransientsWorldMP_DrawLegend(CL_DebugMapOverlay *context, double xoffset, double yoffset, const vec4_t *color, const char *const label)
{
  const dvar_t *v7; 
  vec2_t minPos2D; 
  vec2_t maxPos2D; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps [rsp+0A8h+var_48], xmm7
  }
  v7 = DVARVEC2_cl_transientWorldOverlayOffset;
  __asm
  {
    vmovaps xmm6, xmm2
    vmovaps xmm7, xmm1
  }
  if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  __asm
  {
    vaddss  xmm1, xmm7, dword ptr [rbx+28h]
    vaddss  xmm7, xmm6, dword ptr [rbx+2Ch]
    vaddss  xmm0, xmm7, cs:__real@41200000
    vaddss  xmm6, xmm1, cs:__real@41200000
    vmovss  dword ptr [rsp+0A8h+maxPos2D+4], xmm0
    vmovss  dword ptr [rsp+0A8h+maxPos2D], xmm6
    vmovss  dword ptr [rsp+0A8h+minPos2D], xmm1
    vmovss  dword ptr [rsp+0A8h+minPos2D+4], xmm7
  }
  CL_DebugMapOverlay::DrawFilledRect2D(context, &minPos2D, &maxPos2D, color, Unclipped);
  __asm
  {
    vaddss  xmm0, xmm6, cs:__real@40000000
    vaddss  xmm1, xmm7, cs:__real@41000000
    vmovss  xmm3, cs:__real@3e19999a; fontScale
    vmovss  dword ptr [rsp+0A8h+minPos2D], xmm0
    vmovss  dword ptr [rsp+0A8h+minPos2D+4], xmm1
  }
  CL_DebugMapOverlay::DrawText2D(context, &minPos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, *(float *)&_XMM3, &colorWhite, Unclipped, label);
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_38]
    vmovaps xmm7, [rsp+0A8h+var_48]
  }
}

/*
==============
CL_TransientsWorldMP_DrawOverlay
==============
*/

void __fastcall CL_TransientsWorldMP_DrawOverlay(LocalClientNum_t screenLocalClient, __int64 a2, double _XMM2_8)
{
  const dvar_t *v4; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  const dvar_t *v7; 
  unsigned int v8; 
  unsigned __int64 v9; 
  __int64 v11; 
  vec3_t origin; 
  vec4_t color; 

  if ( !Sys_IsUpdateScreenThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5504, ASSERT_TYPE_ASSERT, "(Sys_IsUpdateScreenThread())", (const char *)&queryFormat, "Sys_IsUpdateScreenThread()") )
    __debugbreak();
  v4 = DCONST_DVARBOOL_cl_transientWorldStreamProgress;
  if ( !DCONST_DVARBOOL_cl_transientWorldStreamProgress && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamProgress") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    ++s_transientsWorldMP.streamProgressCurrentFrame;
    CL_TransientsWorldMP_UpdateStreamProgress(1);
  }
  if ( s_transientsWorldMP.worldGridInfo )
  {
    v5 = DVARBOOL_cl_transientWorldOverlay;
    if ( !DVARBOOL_cl_transientWorldOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    if ( v5->current.enabled )
      CL_TransientsWorldMP_DrawScreenOverlay(screenLocalClient);
    v6 = DCONST_DVARINT_cl_transientWorldPriorityGraph;
    if ( !DCONST_DVARINT_cl_transientWorldPriorityGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraph") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    if ( v6->current.integer )
      CL_TransientsWorldMP_DrawPriorityGraph(screenLocalClient);
    v7 = DCONST_DVARBOOL_cl_transientWorldDrawBounds;
    if ( !DCONST_DVARBOOL_cl_transientWorldDrawBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDrawBounds") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.enabled )
    {
      v8 = 0;
      v9 = 0i64;
      _R14 = 0x140000000ui64;
      v11 = 0i64;
      do
      {
        if ( ((0x80000000 >> (v8 & 0x1F)) & s_transientsWorldMP.transientsHighestLOD.array[v9 >> 5]) == 0 && v8 < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        {
          _RAX = 2i64 * (unsigned int)CL_TransientsWorldMP_GetCellState(v8);
          __asm
          {
            vxorps  xmm2, xmm2, xmm2; yaw
            vmovups xmm0, xmmword ptr ds:rva CELL_STATE_COLORS[r14+rax*8]
          }
          *(_QWORD *)origin.v = 0i64;
          origin.v[2] = 0.0;
          __asm { vmovups xmmword ptr [rsp+88h+color], xmm0 }
          CG_DebugBox(&origin, &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v11], *(float *)&_XMM2_8, &color, 0, 1);
        }
        ++v8;
        ++v9;
        ++v11;
      }
      while ( v8 < 0x600 );
    }
  }
}

/*
==============
CL_TransientsWorldMP_DrawPlayerFOV
==============
*/
void CL_TransientsWorldMP_DrawPlayerFOV(CL_DebugMapOverlay *context, const WorldStreamPosition *worldStreamPos)
{
  LocalClientNum_t localClientIndex; 
  const dvar_t *v18; 
  const vec4_t *v21; 
  const vec4_t *v22; 
  const dvar_t *v24; 
  const dvar_t *v27; 
  __int64 v141; 
  LocalClientNum_t v142; 
  __int64 v143; 
  int v144; 
  vec3_t forward; 
  vec3_t up; 
  vec3_t dst; 
  vec3_t v148; 
  vec3_t v149; 
  vec3_t v150; 
  vec3_t v151; 
  vec3_t v152; 
  vec3_t v153; 
  vec3_t v154; 
  vec3_t startPos; 
  vec3_t v156; 
  vec3_t v157; 
  vec3_t v158; 
  vec3_t endPos; 
  vec3_t v160; 
  vec3_t v161; 
  vec4_t v162; 
  vec4_t v163; 
  vec4_t v164; 
  vec4_t v165; 
  vec4_t color; 
  vec3_t right; 
  vec4_t v168[2]; 
  vec4_t v169[2]; 
  char v170; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovups ymm0, cs:__ymm@3f8000003f0f5c29000000003f8000003f8000003f800000000000003f800000
    vmovups ymm1, cs:__ymm@3f8000003f800000000000003edc28f63f8000003f8000003f11eb8500000000
  }
  localClientIndex = worldStreamPos->localClientIndex;
  _RBX = worldStreamPos;
  __asm
  {
    vmovups ymmword ptr [rbp+190h+var_E0], ymm0
    vmovups xmm0, cs:__xmm@3f8000003e4ccccd3e99999a3f19999a
    vmovups ymmword ptr [rbp+190h+var_C0], ymm1
    vmovups xmm1, cs:__xmm@3f8000003dcccccd3e4ccccd3f000000
    vmovups xmmword ptr [rbp+190h+var_140], xmm0
    vmovups xmm0, cs:__xmm@3f8000003e428f5c3d8f5c293f63d70a
    vmovups xmmword ptr [rbp+190h+var_130], xmm1
    vmovups xmm1, cs:__xmm@3f8000003db851ec3ee666663f800000
    vmovups xmmword ptr [rbp+190h+var_120], xmm0
    vmovups xmmword ptr [rbp+190h+var_110], xmm1
  }
  if ( (unsigned int)localClientIndex >= LOCAL_CLIENT_COUNT )
  {
    v144 = 2;
    v142 = localClientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4498, ASSERT_TYPE_ASSERT, "(unsigned)( worldStreamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( FOV_COLOR ) ) + 0 ) )", "worldStreamPos.localClientIndex doesn't index ARRAY_COUNT( FOV_COLOR )\n\t%i not in [0, %i)", v142, v144) )
      __debugbreak();
  }
  if ( _RBX->localClientIndex >= (unsigned int)LOCAL_CLIENT_COUNT )
  {
    LODWORD(v143) = 2;
    LODWORD(v141) = _RBX->localClientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4499, ASSERT_TYPE_ASSERT, "(unsigned)( worldStreamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( FOV_TARGET_COLOR ) ) + 0 ) )", "worldStreamPos.localClientIndex doesn't index ARRAY_COUNT( FOV_TARGET_COLOR )\n\t%i not in [0, %i)", v141, v143) )
      __debugbreak();
  }
  v18 = DVARFLT_cg_fov;
  __asm
  {
    vmovss  xmm7, cs:__real@3f000000
    vmulss  xmm9, xmm7, dword ptr [rbx+34h]
  }
  v21 = &v168[_RBX->localClientIndex];
  v22 = &v169[_RBX->localClientIndex];
  if ( !DVARFLT_cg_fov && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_fov") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  __asm { vmulss  xmm6, xmm7, dword ptr [rsi+28h] }
  v24 = DVARFLT_cl_transientWorldZoomCutoffLoad;
  if ( !DVARFLT_cl_transientWorldZoomCutoffLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomCutoffLoad") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v24);
  __asm
  {
    vsubss  xmm8, xmm6, xmm9
    vmulss  xmm0, xmm8, dword ptr [rsi+28h]
  }
  v27 = DVARFLT_cl_transientWorldZoomCutoffVisibility;
  __asm { vsubss  xmm10, xmm6, xmm0 }
  if ( !DVARFLT_cl_transientWorldZoomCutoffVisibility && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomCutoffVisibility") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  __asm
  {
    vmulss  xmm0, xmm8, dword ptr [rsi+28h]
    vsubss  xmm8, xmm6, xmm0
    vmulss  xmm6, xmm7, dword ptr [rbx+30h]
  }
  AngleVectors(&_RBX->angles, &forward, &right, &up);
  __asm
  {
    vmovss  xmm7, dword ptr cs:__xmm@80000000800000008000000080000000
    vxorps  xmm3, xmm6, xmm7; degrees
  }
  RotatePointAroundVector(&dst, &up, &forward, *(float *)&_XMM3);
  __asm { vmovaps xmm3, xmm6; degrees }
  RotatePointAroundVector(&v148, &up, &forward, *(float *)&_XMM3);
  __asm
  {
    vxorps  xmm11, xmm9, xmm7
    vmovaps xmm3, xmm11; degrees
  }
  RotatePointAroundVector(&v149, &up, &forward, *(float *)&_XMM3);
  __asm { vmovaps xmm3, xmm9; degrees }
  RotatePointAroundVector(&v150, &up, &forward, *(float *)&_XMM3);
  __asm { vxorps  xmm3, xmm10, xmm7; degrees }
  RotatePointAroundVector(&v151, &up, &forward, *(float *)&_XMM3);
  __asm { vmovaps xmm3, xmm10; degrees }
  RotatePointAroundVector(&v152, &up, &forward, *(float *)&_XMM3);
  __asm { vxorps  xmm3, xmm8, xmm7; degrees }
  RotatePointAroundVector(&v153, &up, &forward, *(float *)&_XMM3);
  __asm { vmovaps xmm3, xmm8; degrees }
  RotatePointAroundVector(&v154, &up, &forward, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm6, cs:__real@497423f0
    vmovss  xmm5, dword ptr [rbx]
    vmovss  xmm4, dword ptr [rbx+4]
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+forward]
    vmovss  xmm3, dword ptr [rbx+8]
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+forward+4]
    vmovss  dword ptr [rbp+190h+endPos], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+forward+8]
    vmovss  dword ptr [rbp+190h+endPos+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+dst]
    vmovss  dword ptr [rbp+190h+endPos+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+dst+4]
    vmovss  dword ptr [rsp+290h+dst], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+dst+8]
    vmovss  dword ptr [rsp+290h+dst+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+var_220]
    vmovss  dword ptr [rsp+290h+dst+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+var_220+4]
    vmovss  dword ptr [rsp+290h+var_220], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rsp+290h+var_220+8]
    vmovss  dword ptr [rsp+290h+var_220+4], xmm2
    vmovups xmm0, cs:__xmm@3f19999a3f19999a3f19999a3f19999a
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_210]
    vmovss  dword ptr [rsp+290h+var_220+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_210+4]
    vmovss  dword ptr [rbp+190h+var_210], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_210+8]
    vmovss  dword ptr [rbp+190h+var_210+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_200]
    vmovss  dword ptr [rbp+190h+var_210+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_200+4]
    vmovss  dword ptr [rbp+190h+var_200], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_200+8]
    vmovss  dword ptr [rbp+190h+var_200+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1F0]
    vmovss  dword ptr [rbp+190h+var_200+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1F0+4]
    vmovss  dword ptr [rbp+190h+var_1F0], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1F0+8]
    vmovss  dword ptr [rbp+190h+var_1F0+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1E0]
    vmovss  dword ptr [rbp+190h+var_1F0+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1E0+4]
    vmovss  dword ptr [rbp+190h+var_1E0], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1E0+8]
    vmovss  dword ptr [rbp+190h+var_1E0+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1D0]
    vmovss  dword ptr [rbp+190h+var_1E0+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1D0+4]
    vmovss  dword ptr [rbp+190h+var_1D0], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1D0+8]
    vmovss  dword ptr [rbp+190h+var_1D0+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1C0]
    vmovss  dword ptr [rbp+190h+var_1D0+8], xmm2
    vaddss  xmm2, xmm1, xmm5
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1C0+4]
    vmovss  dword ptr [rbp+190h+var_1C0], xmm2
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm6, dword ptr [rbp+190h+var_1C0+8]
    vmovss  dword ptr [rbp+190h+var_1C0+4], xmm2
    vaddss  xmm2, xmm1, xmm3
    vmovss  dword ptr [rbp+190h+var_1C0+8], xmm2
    vmovups xmmword ptr [rbp+190h+color], xmm0
  }
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &endPos, &color, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &dst, v21, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v148, v21, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v149, v22, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v150, v22, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v151, &v164, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v152, &v164, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v153, &v165, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v154, &v165, Unclipped);
  _RSI = DVARFLT_cl_transientWorldZoomFovXPadding;
  if ( !DVARFLT_cl_transientWorldZoomFovXPadding && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomFovXPadding") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RSI);
  __asm
  {
    vmovss  xmm6, dword ptr [rsi+28h]
    vsubss  xmm3, xmm11, xmm6; degrees
  }
  RotatePointAroundVector(&v160, &up, &forward, *(float *)&_XMM3);
  __asm { vaddss  xmm3, xmm9, xmm6; degrees }
  RotatePointAroundVector(&v161, &up, &forward, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm3, dword ptr [rbx+38h]
    vmovss  xmm11, dword ptr [rbx]
    vmovss  xmm10, dword ptr [rbx+4]
    vmovss  xmm9, dword ptr [rbx+8]
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_160]
    vaddss  xmm1, xmm0, xmm11
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_160+4]
    vmovss  dword ptr [rbp+190h+startPos], xmm1
    vaddss  xmm1, xmm0, xmm10
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_160+8]
    vmovss  dword ptr [rbp+190h+startPos+4], xmm1
    vaddss  xmm1, xmm0, xmm9
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_150]
    vmovss  dword ptr [rbp+190h+startPos+8], xmm1
    vaddss  xmm1, xmm0, xmm11
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_150+4]
    vmovss  dword ptr [rbp+190h+var_1A0], xmm1
    vaddss  xmm1, xmm0, xmm10
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_150+8]
    vmovss  xmm3, dword ptr [rbx+3Ch]
    vmulss  xmm2, xmm3, dword ptr [rbp+190h+var_160+4]
    vmovss  dword ptr [rbp+190h+var_1A0+4], xmm1
    vaddss  xmm1, xmm0, xmm9
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_160]
    vmovss  dword ptr [rbp+190h+var_1A0+8], xmm1
    vaddss  xmm1, xmm0, xmm11
    vaddss  xmm0, xmm2, xmm10
    vmovss  dword ptr [rbp+190h+var_180], xmm1
    vmulss  xmm1, xmm3, dword ptr [rbp+190h+var_160+8]
    vaddss  xmm2, xmm1, xmm9
    vmovss  dword ptr [rbp+190h+var_180+4], xmm0
    vmulss  xmm0, xmm3, dword ptr [rbp+190h+var_150]
    vaddss  xmm1, xmm0, xmm11
    vmovss  dword ptr [rbp+190h+var_180+8], xmm2
    vmulss  xmm2, xmm3, dword ptr [rbp+190h+var_150+4]
    vaddss  xmm0, xmm2, xmm10
    vmovss  dword ptr [rbp+190h+var_190], xmm1
    vmulss  xmm1, xmm3, dword ptr [rbp+190h+var_150+8]
    vaddss  xmm2, xmm1, xmm9
    vmovss  dword ptr [rbp+190h+var_190+8], xmm2
    vmovss  dword ptr [rbp+190h+var_190+4], xmm0
  }
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &startPos, &v162, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &_RBX->pos, &v156, &v162, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &startPos, &v156, &v162, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &startPos, &v158, &v163, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &v156, &v157, &v163, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &v158, &v157, &v163, Unclipped);
  _R11 = &v170;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
CL_TransientsWorldMP_DrawPriorityGraph
==============
*/
void CL_TransientsWorldMP_DrawPriorityGraph(const LocalClientNum_t screenLocalClient)
{
  signed __int64 v1; 
  void *v12; 
  const ScreenPlacement *ActivePlacement; 
  unsigned int v34; 
  const dvar_t *v35; 
  int integer; 
  char *v37; 
  __int64 v38; 
  bool v39; 
  unsigned __int8 *transientLODIndex; 
  __int64 v42; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  __int64 *v47; 
  unsigned int *v48; 
  __int64 v49; 
  unsigned int *v50; 
  const dvar_t *v51; 
  __int64 v52; 
  unsigned int *v58; 
  __int64 *v59; 
  unsigned int *v60; 
  __int64 v61; 
  char v73; 
  const dvar_t *v78; 
  unsigned int v79; 
  unsigned int numStreamPositions; 
  int v82; 
  WorldStreamPosition *v83; 
  const cg_t *v84; 
  const dvar_t *v86; 
  unsigned int v90; 
  unsigned int *v91; 
  __int64 *v92; 
  char v93; 
  char v94; 
  __int64 v95; 
  unsigned int *v96; 
  bool v100; 
  char v101; 
  char v111; 
  CellState CellState; 
  __int64 v169; 
  const vec4_t *v172; 
  float fmt; 
  char *fmta; 
  char *fmtb; 
  char *fmtc; 
  char *fmtd; 
  __int64 clipMode; 
  float clipModea; 
  vec4_t *frustumPlanes; 
  vec4_t *frustumPlanesa; 
  double v194; 
  double v195; 
  double v196; 
  double v197; 
  WorldTransientPriorityGraphOrder v198; 
  char v199; 
  unsigned int v200; 
  int v201; 
  unsigned int v202; 
  __int64 v205; 
  int v210; 
  __int64 v211; 
  __int64 *v212; 
  __int64 v213; 
  vec2_t anchor; 
  vec2_t screenBoundsMin; 
  vec2_t endPos; 
  vec2_t pos2D; 
  vec3_t forward; 
  vec2_t startPos; 
  vec2_t v220; 
  vec2_t v221; 
  vec2_t v222; 
  vec2_t v223; 
  vec2_t v224; 
  vec2_t v225; 
  vec2_t screenBoundsMax; 
  vec2_t maxPos; 
  vec2_t minPos; 
  vec2_t v229; 
  CL_DebugMapOverlay v230; 
  Bounds worldBounds; 
  vec4_t v232; 
  unsigned int _First[3072]; 
  char dest[256]; 
  char v245; 

  v12 = alloca(v1);
  v213 = -2i64;
  __asm
  {
    vmovaps [rsp+33B0h+var_30], xmm6
    vmovaps [rsp+33B0h+var_40], xmm7
    vmovaps [rsp+33B0h+var_50], xmm8
    vmovaps [rsp+33B0h+var_60], xmm9
    vmovaps [rsp+33B0h+var_70], xmm10
    vmovaps [rsp+33B0h+var_80], xmm11
    vmovaps [rsp+33B0h+var_90], xmm12
    vmovaps [rsp+33B0h+var_A0], xmm13
    vmovaps [rsp+33B0h+var_B0], xmm14
    vmovaps [rsp+33B0h+var_C0], xmm15
  }
  ActivePlacement = ScrPlace_GetActivePlacement(screenLocalClient);
  if ( !ActivePlacement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4983, ASSERT_TYPE_ASSERT, "(scrPlace)", (const char *)&queryFormat, "scrPlace") )
    __debugbreak();
  CL_DebugMapOverlay::CL_DebugMapOverlay(&v230);
  _RBX = DCONST_DVARVEC2_cl_transientWorldPriorityScreenOffset;
  if ( !DCONST_DVARVEC2_cl_transientWorldPriorityScreenOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityScreenOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmovss  dword ptr [rbp+32B0h+screenBoundsMin], xmm0
    vmovss  xmm1, dword ptr [rbx+2Ch]
    vmovss  dword ptr [rbp+32B0h+screenBoundsMin+4], xmm1
  }
  _RBX = DCONST_DVARVEC2_cl_transientWorldPriorityScreenSize;
  if ( !DCONST_DVARVEC2_cl_transientWorldPriorityScreenSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityScreenSize") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vmovss  [rsp+33B0h+var_3338], xmm6
    vmovss  xmm7, dword ptr [rbx+2Ch]
    vmovss  [rsp+33B0h+var_3334], xmm7
    vaddss  xmm0, xmm6, dword ptr [rbp+32B0h+screenBoundsMin]
    vmovss  dword ptr [rbp+32B0h+screenBoundsMax], xmm0
    vaddss  xmm1, xmm7, dword ptr [rbp+32B0h+screenBoundsMin+4]
    vmovss  dword ptr [rbp+32B0h+screenBoundsMax+4], xmm1
    vmovups xmm0, cs:__xmm@3f800000000000000000000000000000
    vmovups xmmword ptr [rbp+32B0h+worldBounds.midPoint], xmm0
    vmovss  xmm14, cs:__real@3f800000
    vmovss  dword ptr [rbp+32B0h+worldBounds.halfSize+4], xmm14
    vmovss  dword ptr [rbp+32B0h+worldBounds.halfSize+8], xmm14
  }
  CL_DebugMapOverlay::Init(&v230, ActivePlacement, &screenBoundsMin, &screenBoundsMax, &worldBounds);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+32B0h+screenBoundsMin]
    vmovss  dword ptr [rbp+32B0h+endPos], xmm0
    vaddss  xmm1, xmm7, dword ptr [rbp+32B0h+screenBoundsMin+4]
    vmovss  dword ptr [rbp+32B0h+endPos+4], xmm1
    vaddss  xmm0, xmm6, xmm0
    vmovss  dword ptr [rbp+32B0h+pos2D], xmm0
    vmovss  dword ptr [rbp+32B0h+pos2D+4], xmm1
  }
  CL_DebugMapOverlay::DrawLine2D(&v230, &screenBoundsMin, &endPos, &colorWhite, Unclipped);
  CL_DebugMapOverlay::DrawLine2D(&v230, &endPos, &pos2D, &colorWhite, Unclipped);
  _RBX = DCONST_DVARFLT_cl_transientWorldPriorityGraphXMin;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphXMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphXMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm12, dword ptr [rbx+28h]
    vmovss  [rsp+33B0h+var_3350], xmm12
  }
  _RBX = DCONST_DVARFLT_cl_transientWorldPriorityGraphXMax;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphXMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphXMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm7, cs:__real@34000000
    vaddss  xmm1, xmm12, xmm7
    vmovss  xmm0, dword ptr [rbx+28h]
    vmaxss  xmm8, xmm0, xmm1
    vmovss  [rsp+33B0h+var_3340], xmm8
  }
  v34 = 0;
  v205 = 0i64;
  v35 = DCONST_DVARINT_cl_transientWorldPriorityGraphLod;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraphLod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphLod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v35);
  integer = v35->current.integer;
  v37 = dest;
  v38 = 3i64;
  do
  {
    *(_QWORD *)v37 = 0i64;
    *((_QWORD *)v37 + 1) = 0i64;
    *((_QWORD *)v37 + 2) = 0i64;
    v37 += 64;
    *((_QWORD *)v37 - 5) = 0i64;
    *((_QWORD *)v37 - 4) = 0i64;
    *((_QWORD *)v37 - 3) = 0i64;
    *((_QWORD *)v37 - 2) = 0i64;
    *((_QWORD *)v37 - 1) = 0i64;
    v100 = v38-- == 0;
    v39 = v100 || v38 == 0;
  }
  while ( v38 );
  transientLODIndex = s_transientsWorldMP.transientLODIndex;
  _R14 = s_transientsWorldMP.priorityDistXY;
  v42 = 2i64;
  do
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r14]
      vcomiss xmm0, xmm8
    }
    if ( v39 )
    {
      v44 = *transientLODIndex;
      if ( (unsigned int)v44 >= 2 )
      {
        LODWORD(frustumPlanes) = 2;
        LODWORD(clipMode) = *transientLODIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5017, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( CL_TRANSIENT_WORLD_LOD_LEVELS )", "lod doesn't index CL_TRANSIENT_WORLD_LOD_LEVELS\n\t%i not in [0, %i)", clipMode, frustumPlanes) )
          __debugbreak();
      }
      if ( (_DWORD)v44 == integer || integer == 2 )
      {
        v45 = *((unsigned int *)&v205 + v44);
        _First[1536 * v44 + v45] = v34;
        *((_DWORD *)&v205 + v44) = v45 + 1;
      }
    }
    ++v34;
    ++_R14;
    ++transientLODIndex;
    v39 = v34 <= 0x600;
  }
  while ( v34 < 0x600 );
  v46 = 0i64;
  v47 = &v205;
  v48 = _First;
  v49 = 2i64;
  do
  {
    v50 = &_First[v46 + *(unsigned int *)v47];
    std::_Sort_unchecked<unsigned int *,WorldTransientPriorityGraphOrder>(v48, v50, v50 - v48, v198);
    v46 += 1536i64;
    v48 += 1536;
    v47 = (__int64 *)((char *)v47 + 4);
    --v49;
  }
  while ( v49 );
  v51 = DCONST_DVARINT_cl_transientWorldPriorityGraph;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraph") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v51);
  v52 = v51->current.integer;
  v201 = v51->current.integer;
  _RBX = DCONST_DVARFLT_cl_transientWorldPriorityGraphYMin;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphYMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphYMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm11, dword ptr [rbx+28h]
    vmovss  [rsp+33B0h+var_3354], xmm11
  }
  _RBX = DCONST_DVARFLT_cl_transientWorldPriorityGraphYMax;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphYMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphYMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vxorps  xmm15, xmm15, xmm15
    vucomiss xmm6, xmm15
  }
  if ( v73 )
  {
    v58 = _First;
    v59 = &v205;
    do
    {
      if ( *(_DWORD *)v59 )
      {
        v60 = v58;
        v61 = *(unsigned int *)v59;
        do
        {
          *(float *)&_XMM0 = CL_TransientsWorldMP_GetPriorityGraphValueY(*v60, (TransientWorldPriorityGraphType)v52);
          __asm
          {
            vmaxss  xmm6, xmm0, xmm6
            vminss  xmm11, xmm0, xmm11
          }
          ++v60;
          --v61;
        }
        while ( v61 );
        __asm { vmovss  [rsp+33B0h+var_3354], xmm11 }
      }
      v59 = (__int64 *)((char *)v59 + 4);
      v58 += 1536;
      --v42;
    }
    while ( v42 );
  }
  __asm
  {
    vaddss  xmm0, xmm11, xmm7
    vmaxss  xmm0, xmm0, xmm6
    vmovss  [rsp+33B0h+var_333C], xmm0
    vmovss  dword ptr [rbp+32B0h+anchor], xmm15
    vmovss  dword ptr [rbp+32B0h+anchor+4], xmm14
    vcvtss2sd xmm0, xmm0, xmm0
    vmovsd  [rsp+33B0h+var_3370], xmm0
    vmovss  xmm13, cs:__real@3e4ccccd
    vmovaps xmm3, xmm13; fontScale
    vmovd   r9d, xmm3
  }
  CL_DebugMapOverlay::DrawTextf2D(&v230, &screenBoundsMin, &anchor, *(float *)&_XMM3, &colorWhite, Unclipped, "%s (%.0f)", cl_transientWorldPriorityGraphType[v52], v197);
  __asm
  {
    vmovss  xmm0, cs:__real@3f000000
    vmovss  dword ptr [rbp+32B0h+anchor], xmm0
    vmovss  dword ptr [rbp+32B0h+anchor+4], xmm15
    vcvtss2sd xmm1, xmm8, xmm8
    vmovsd  [rsp+33B0h+var_3378], xmm1
    vmovaps xmm3, xmm13; fontScale
    vmovd   r9d, xmm3
  }
  CL_DebugMapOverlay::DrawTextf2D(&v230, &pos2D, &anchor, *(float *)&_XMM3, &colorWhite, Unclipped, "DistXY (%.0f)", v194);
  __asm { vucomiss xmm12, xmm15 }
  if ( !v73 )
  {
    __asm
    {
      vmovss  dword ptr [rbp+32B0h+anchor], xmm15
      vmovss  dword ptr [rbp+32B0h+anchor+4], xmm15
      vcvtss2sd xmm0, xmm12, xmm12
      vmovsd  [rsp+33B0h+var_3378], xmm0
      vmovaps xmm3, xmm13; fontScale
      vmovd   r9d, xmm3
    }
    CL_DebugMapOverlay::DrawTextf2D(&v230, &endPos, &anchor, *(float *)&_XMM3, &colorWhite, Unclipped, "%.0f", v195);
  }
  __asm { vucomiss xmm11, xmm15 }
  if ( !v73 )
  {
    __asm
    {
      vmovss  dword ptr [rbp+32B0h+anchor], xmm14
      vmovss  dword ptr [rbp+32B0h+anchor+4], xmm14
      vcvtss2sd xmm0, xmm11, xmm11
      vmovsd  [rsp+33B0h+var_3378], xmm0
      vmovaps xmm3, xmm13; fontScale
      vmovd   r9d, xmm3
    }
    CL_DebugMapOverlay::DrawTextf2D(&v230, &endPos, &anchor, *(float *)&_XMM3, &colorWhite, Unclipped, "%.0f", v196);
  }
  v199 = 0;
  v78 = DCONST_DVARBOOL_cl_transientWorldPriorityGraphHighlightInFrustum;
  if ( !DCONST_DVARBOOL_cl_transientWorldPriorityGraphHighlightInFrustum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphHighlightInFrustum") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v78);
  if ( v78->current.enabled )
  {
    v79 = 0;
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
    if ( s_transientsWorldMP.numStreamPositions )
    {
      __asm { vmovss  xmm6, cs:__real@4e6e6b28 }
      v82 = cg_t::ms_allocatedCount;
      do
      {
        v83 = &s_transientsWorldMP.streamPositions[v79];
        if ( v83->localClientIndex == LOCAL_CLIENT_0 && v83->streamRender && v82 > 0 )
        {
          if ( !cg_t::ms_cgArray[0] )
          {
            LODWORD(frustumPlanesa) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", frustumPlanesa) )
              __debugbreak();
          }
          if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
          {
            LODWORD(frustumPlanesa) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", frustumPlanesa) )
              __debugbreak();
          }
          v84 = cg_t::ms_cgArray[0];
          AngleVectors(&v83->angles, &forward, NULL, NULL);
          __asm
          {
            vmovss  [rsp+33B0h+clipMode], xmm15
            vmovss  dword ptr [rsp+33B0h+fmt], xmm15
            vmovaps xmm3, xmm6; farDistance
          }
          CL_TransientsWorldMP_GetFrustumPlanes(v84, &s_transientsWorldMP.streamPositions[v79].pos, &forward, *(float *)&_XMM3, fmt, clipModea, &v232);
          v199 = 1;
          numStreamPositions = s_transientsWorldMP.numStreamPositions;
          v82 = cg_t::ms_allocatedCount;
        }
        ++v79;
      }
      while ( v79 < numStreamPositions );
      LODWORD(v52) = v201;
    }
  }
  v86 = DCONST_DVARINT_cl_transientWorldPriorityGraphLabels;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraphLabels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphLabels") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v86);
  v210 = v86->current.integer;
  v202 = 0;
  __asm
  {
    vmovss  xmm9, cs:__real@40000000
    vmovss  xmm10, cs:__real@40800000
    vmovss  xmm8, cs:__real@35800000
  }
  do
  {
    v90 = 0;
    v200 = 0;
    v91 = _First;
    *(_QWORD *)forward.v = _First;
    v92 = &v205;
    v212 = &v205;
    do
    {
      v225 = 0i64;
      v93 = 0;
      v94 = 0;
      v95 = *(unsigned int *)v92;
      if ( !(_DWORD)v95 )
        goto LABEL_94;
      v96 = v91;
      v211 = v95;
      do
      {
        _RBX = *v96;
        if ( !(_DWORD)_RBX )
          goto LABEL_92;
        _RAX = s_transientsWorldMP.priorityDistXY;
        __asm { vmovss  xmm7, dword ptr [rax+rbx*4] }
        *(float *)&_XMM0 = CL_TransientsWorldMP_GetPriorityGraphValueY(_RBX, (TransientWorldPriorityGraphType)v52);
        __asm
        {
          vmovaps xmm6, xmm0
          vsubss  xmm2, xmm7, xmm12
          vmovss  xmm0, [rsp+33B0h+var_3340]
          vsubss  xmm1, xmm0, xmm12
          vdivss  xmm0, xmm2, xmm1
          vsubss  xmm3, xmm6, xmm11
          vmovss  xmm1, [rsp+33B0h+var_333C]
          vsubss  xmm2, xmm1, xmm11
          vdivss  xmm1, xmm3, xmm2
          vcomiss xmm0, xmm15
        }
        if ( v100 )
          goto LABEL_82;
        __asm { vcomiss xmm0, xmm14 }
        if ( !(v100 | v101) )
          goto LABEL_82;
        __asm
        {
          vcomiss xmm1, xmm15
          vcomiss xmm1, xmm14
        }
        if ( v100 | v101 )
          v111 = 1;
        else
LABEL_82:
          v111 = 0;
        __asm
        {
          vmulss  xmm0, xmm0, [rsp+33B0h+var_3338]
          vaddss  xmm2, xmm0, dword ptr [rbp+32B0h+endPos]
          vmovss  dword ptr [rbp+32B0h+anchor], xmm2
          vmulss  xmm1, xmm1, [rsp+33B0h+var_3334]
          vmovss  xmm0, dword ptr [rbp+32B0h+endPos+4]
          vsubss  xmm3, xmm0, xmm1
          vmovss  dword ptr [rbp+32B0h+anchor+4], xmm3
        }
        if ( v202 )
        {
          if ( v93 && (v94 || v111) )
          {
            v169 = v200;
            CL_DebugMapOverlay::DrawLine2D(&v230, &v225, &anchor, &LOD_LINE_COLORS[v200], Unclipped);
            __asm
            {
              vmovss  xmm3, dword ptr [rbp+32B0h+anchor+4]
              vmovss  xmm2, dword ptr [rbp+32B0h+anchor]
            }
          }
          else
          {
            v169 = v200;
          }
          if ( v111 )
          {
            __asm
            {
              vaddss  xmm0, xmm2, xmm14
              vmovss  dword ptr [rbp+32B0h+var_32C8], xmm0
              vmovss  dword ptr [rbp+32B0h+var_32C8+4], xmm3
              vsubss  xmm1, xmm2, xmm14
              vmovss  dword ptr [rbp+32B0h+var_32C0], xmm1
              vmovss  dword ptr [rbp+32B0h+var_32C0+4], xmm3
            }
            v172 = &LOD_LINE_COLORS[v169];
            CL_DebugMapOverlay::DrawLine2D(&v230, &v221, &v220, v172, Unclipped);
            __asm
            {
              vmovss  xmm2, dword ptr [rbp+32B0h+anchor]
              vmovss  dword ptr [rbp+32B0h+var_32B8], xmm2
              vmovss  xmm1, dword ptr [rbp+32B0h+anchor+4]
              vaddss  xmm0, xmm14, xmm1
              vmovss  dword ptr [rbp+32B0h+var_32B8+4], xmm0
              vmovss  dword ptr [rbp+32B0h+var_32B0], xmm2
              vsubss  xmm1, xmm1, xmm14
              vmovss  dword ptr [rbp+32B0h+var_32B0+4], xmm1
            }
            CL_DebugMapOverlay::DrawLine2D(&v230, &v223, &v222, v172, Unclipped);
            switch ( v210 )
            {
              case 1:
                Com_sprintf(dest, 0x100ui64, "%u", (unsigned int)_RBX);
                goto LABEL_117;
              case 2:
                if ( (_DWORD)v52 == 7 )
                {
                  __asm
                  {
                    vmulss  xmm0, xmm6, xmm8
                    vcvtss2sd xmm3, xmm0, xmm0
                    vmovq   r9, xmm3
                  }
                  Com_sprintf(dest, 0x100ui64, "%.3f MB", *(double *)&_XMM3);
                }
                else
                {
                  __asm
                  {
                    vcvtss2sd xmm3, xmm6, xmm6
                    vmovq   r9, xmm3
                  }
                  Com_sprintf(dest, 0x100ui64, "%.1f", *(double *)&_XMM3);
                }
LABEL_117:
                if ( dest[0] )
                {
                  __asm
                  {
                    vmovss  dword ptr [rbp+32B0h+var_32A8], xmm15
                    vmovss  dword ptr [rbp+32B0h+var_32A8+4], xmm14
                    vmovaps xmm3, xmm13; fontScale
                  }
                  CL_DebugMapOverlay::DrawText2D(&v230, &anchor, &v224, *(float *)&_XMM3, v172, Unclipped, dest);
                }
                break;
              case 3:
                if ( (_DWORD)v52 == 7 )
                {
                  __asm
                  {
                    vmulss  xmm0, xmm6, xmm8
                    vcvtss2sd xmm1, xmm0, xmm0
                    vmovsd  [rsp+33B0h+fmt], xmm1
                  }
                  Com_sprintf(dest, 0x100ui64, "%u: %.3f MB", (unsigned int)_RBX, *(double *)&fmtc);
                }
                else
                {
                  __asm
                  {
                    vcvtss2sd xmm0, xmm6, xmm6
                    vmovsd  [rsp+33B0h+fmt], xmm0
                  }
                  Com_sprintf(dest, 0x100ui64, "%u: %.1f", (unsigned int)_RBX, *(double *)&fmtd);
                }
                goto LABEL_117;
              case 4:
                __asm
                {
                  vcvtss2sd xmm3, xmm7, xmm7
                  vmovq   r9, xmm3
                }
                if ( (_DWORD)v52 == 7 )
                {
                  __asm
                  {
                    vmulss  xmm0, xmm6, xmm8
                    vcvtss2sd xmm1, xmm0, xmm0
                    vmovsd  [rsp+33B0h+fmt], xmm1
                  }
                  Com_sprintf(dest, 0x100ui64, "(%.1f: %.3f MB)", *(double *)&_XMM3, *(double *)&fmta);
                }
                else
                {
                  __asm
                  {
                    vcvtss2sd xmm0, xmm6, xmm6
                    vmovsd  [rsp+33B0h+fmt], xmm0
                  }
                  Com_sprintf(dest, 0x100ui64, "(%.1f, %.1f)", *(double *)&_XMM3, *(double *)&fmtb);
                }
                goto LABEL_117;
            }
          }
        }
        else if ( v111 )
        {
          CellState = CL_TransientsWorldMP_GetCellState(_RBX);
          __asm
          {
            vmovss  xmm3, dword ptr [rbp+32B0h+anchor]
            vaddss  xmm0, xmm9, xmm3
            vmovss  dword ptr [rbp+32B0h+maxPos], xmm0
            vmovss  xmm2, dword ptr [rbp+32B0h+anchor+4]
            vaddss  xmm1, xmm9, xmm2
            vmovss  dword ptr [rbp+32B0h+maxPos+4], xmm1
            vsubss  xmm0, xmm3, xmm9
            vmovss  dword ptr [rbp+32B0h+minPos], xmm0
            vsubss  xmm1, xmm2, xmm9
            vmovss  dword ptr [rbp+32B0h+minPos+4], xmm1
          }
          CL_DebugMapOverlay::DrawRect2D(&v230, &minPos, &maxPos, &CELL_STATE_COLORS[CellState], Unclipped);
          __asm { vmovss  xmm0, dword ptr [rbp+32B0h+anchor+4] }
          if ( v200 )
            __asm { vaddss  xmm2, xmm0, xmm10 }
          else
            __asm { vsubss  xmm2, xmm0, xmm10 }
          __asm
          {
            vmovss  xmm1, dword ptr [rbp+32B0h+anchor]
            vaddss  xmm0, xmm14, xmm1
            vmovss  dword ptr [rbp+32B0h+var_3280], xmm0
            vmovss  dword ptr [rbp+32B0h+var_3280+4], xmm2
            vsubss  xmm1, xmm1, xmm14
            vmovss  dword ptr [rbp+32B0h+startPos], xmm1
            vmovss  dword ptr [rbp+32B0h+startPos+4], xmm2
          }
          CL_DebugMapOverlay::DrawLine2D(&v230, &startPos, &v229, &CELL_STATE_COLORS[CellState], Unclipped);
          if ( v199 && (unsigned int)_RBX < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
          {
            _RCX = 3 * _RBX;
            _RAX = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
            __asm
            {
              vmovss  xmm8, dword ptr [rax+rcx*8]
              vmovss  xmm9, dword ptr [rax+rcx*8+4]
              vmovss  xmm10, dword ptr [rax+rcx*8+8]
              vmovss  xmm11, dword ptr [rax+rcx*8+0Ch]
              vmovss  xmm12, dword ptr [rax+rcx*8+10h]
              vmovss  xmm13, dword ptr [rax+rcx*8+14h]
            }
            _RAX = &v232.v[1];
            __asm
            {
              vmovss  xmm6, dword ptr [rax+4]
              vmovss  xmm2, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
              vandps  xmm7, xmm6, xmm2
              vmovss  xmm4, dword ptr [rax]
              vandps  xmm5, xmm4, xmm2
              vmovss  xmm0, dword ptr [rax-4]
              vandps  xmm1, xmm0, xmm2
              vmulss  xmm0, xmm8, xmm0
              vaddss  xmm2, xmm0, dword ptr [rax+8]
              vmulss  xmm1, xmm11, xmm1
              vaddss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm9, xmm4
              vaddss  xmm4, xmm3, xmm0
              vmulss  xmm1, xmm5, xmm12
              vaddss  xmm2, xmm4, xmm1
              vmulss  xmm0, xmm10, xmm6
              vaddss  xmm3, xmm2, xmm0
              vmulss  xmm1, xmm7, xmm13
              vaddss  xmm4, xmm3, xmm1
              vcomiss xmm4, xmm15
              vmovss  xmm13, cs:__real@3e4ccccd
              vmovss  xmm12, [rsp+33B0h+var_3350]
              vmovss  xmm11, [rsp+33B0h+var_3354]
              vmovss  xmm10, cs:__real@40800000
              vmovss  xmm9, cs:__real@40000000
              vmovss  xmm8, cs:__real@35800000
            }
          }
        }
        v225 = anchor;
        v93 = 1;
        v94 = v111;
        v95 = v211;
LABEL_92:
        ++v96;
        v211 = --v95;
      }
      while ( v95 );
      v90 = v200;
      v91 = *(unsigned int **)forward.v;
LABEL_94:
      v200 = ++v90;
      v92 = (__int64 *)((char *)v212 + 4);
      v212 = (__int64 *)((char *)v212 + 4);
      v91 += 1536;
      *(_QWORD *)forward.v = v91;
    }
    while ( v90 < 2 );
    ++v202;
  }
  while ( v202 < 2 );
  CL_DebugMapOverlay::~CL_DebugMapOverlay(&v230);
  _R11 = &v245;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
CL_TransientsWorldMP_DrawScreenOverlay
==============
*/
void CL_TransientsWorldMP_DrawScreenOverlay(const LocalClientNum_t screenLocalClient)
{
  signed __int64 v1; 
  void *v9; 
  const ScreenPlacement *ActivePlacement; 
  int v15; 
  unsigned int i; 
  unsigned __int64 v17; 
  char v18; 
  float v19; 
  cg_t *LocalClientGlobals; 
  RefdefView *p_view; 
  unsigned int refdefViewOrg_aab; 
  _DWORD *v; 
  int v24; 
  bool v55; 
  bool v56; 
  unsigned __int64 v85; 
  const TransientInfo *worldGridInfo; 
  unsigned int transientWorldGridTileMapCount; 
  __int64 v89; 
  __int64 v90; 
  const TransientWorldGridTileMap *v91; 
  unsigned int v92; 
  unsigned int j; 
  unsigned __int16 v94; 
  __int64 v95; 
  const unsigned __int16 *HighLODLookups; 
  const XModel *ProxyModel; 
  __int64 v98; 
  unsigned __int16 k; 
  const dvar_t *v120; 
  unsigned int v152; 
  vec2_t v153; 
  const TransientWorldGridTileMap *v154; 
  const dvar_t *v155; 
  unsigned int v156; 
  unsigned int m; 
  unsigned int n; 
  unsigned int ii; 
  unsigned __int16 TransientIndex; 
  bool v161; 
  __int64 v162; 
  bool IsLoadModeInFrontend; 
  unsigned __int64 CurCost; 
  const dvar_t *v202; 
  int v203; 
  unsigned __int64 tileBudget; 
  const char *v205; 
  const char *v209; 
  unsigned int v213; 
  unsigned int jj; 
  const char *v217; 
  const char *v219; 
  const char *v229; 
  unsigned int kk; 
  const dvar_t *v233; 
  TransientWorldStreamSyncDrawRequest *v234; 
  unsigned int v235; 
  const vec3_t *p_pos; 
  const dvar_t *v239; 
  unsigned int v240; 
  unsigned __int16 *priorityOrder; 
  __int64 v242; 
  unsigned __int64 v246; 
  unsigned int v248; 
  const char *v252; 
  const dvar_t *v253; 
  const char *v254; 
  const vec4_t *v257; 
  const char *v260; 
  char *fmta; 
  char *fmt; 
  __int64 clipMode; 
  double clipModea; 
  char *label; 
  char *labela; 
  unsigned int v277; 
  vec2_t screenBoundsMin[2]; 
  vec4_t color; 
  vec2_t screenBoundsMax; 
  CL_DebugMapOverlay context; 
  Bounds worldBounds; 
  vec4_t v284; 
  MemBudget_PollData dest; 
  vec4_t v286[2]; 
  __int64 v287; 
  __int64 v288; 
  __int64 v289; 
  __int64 v290; 
  char v298; 

  v9 = alloca(v1);
  __asm
  {
    vmovaps [rsp+41A0h+var_30], xmm6
    vmovaps [rsp+41A0h+var_40], xmm7
    vmovaps [rsp+41A0h+var_50], xmm8
    vmovaps [rsp+41A0h+var_60], xmm9
    vmovaps [rsp+41A0h+var_70], xmm11
    vmovaps [rsp+41A0h+var_80], xmm12
    vmovaps [rsp+41A0h+var_90], xmm13
    vmovups ymm0, cs:__ymm@3f8000003f80000000000000000000003f80000000000000000000003f800000
    vmovups ymmword ptr [rbp+40A0h+var_E0], ymm0
    vmovups xmm1, cs:__xmm@3f800000000000000000000000000000
    vmovups xmmword ptr [rbp+40A0h+var_40D8], xmm1
  }
  ActivePlacement = ScrPlace_GetActivePlacement(screenLocalClient);
  if ( !ActivePlacement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5186, ASSERT_TYPE_ASSERT, "(scrPlace)", (const char *)&queryFormat, "scrPlace") )
    __debugbreak();
  __asm { vmovss  xmm11, cs:__real@c1700000 }
  v15 = 0;
  for ( i = 0; i < s_transientsWorldMP.fileBackedTransientCount; ++i )
  {
    v17 = s_transientsWorldMP.priorityOrder[i];
    if ( s_transientsWorldMP.priorityOrder[i] )
    {
      if ( (unsigned int)v17 >= 0x600 )
      {
        LODWORD(label) = 1536;
        LODWORD(clipMode) = s_transientsWorldMP.priorityOrder[i];
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, label) )
          __debugbreak();
      }
      if ( ((0x80000000 >> (v17 & 0x1F)) & s_transientsWorldMP.requested.array[v17 >> 5]) != 0 )
        ++v15;
    }
  }
  v18 = 0;
  v19 = 0.0;
  *(_QWORD *)color.v = 0i64;
  color.v[2] = 0.0;
  if ( (unsigned int)screenLocalClient >= LOCAL_CLIENT_COUNT )
  {
    LODWORD(label) = 2;
    LODWORD(clipMode) = screenLocalClient;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", clipMode, label) )
      __debugbreak();
  }
  if ( screenLocalClient >= cg_t::ms_allocatedCount )
  {
    __asm { vmovsd  xmm7, qword ptr [rsp+41A0h+color] }
  }
  else
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(screenLocalClient);
    p_view = &LocalClientGlobals->refdef.view;
    if ( LocalClientGlobals == (cg_t *)-26928i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1316, ASSERT_TYPE_ASSERT, "(refdefView)", (const char *)&queryFormat, "refdefView") )
      __debugbreak();
    refdefViewOrg_aab = p_view->refdefViewOrg_aab;
    v = (_DWORD *)p_view->org.org.v;
    if ( !v && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1284, ASSERT_TYPE_ASSERT, "(viewOrg)", (const char *)&queryFormat, "viewOrg") )
      __debugbreak();
    LODWORD(screenBoundsMin[0].v[0]) = *v ^ ((refdefViewOrg_aab ^ (unsigned int)v) * ((refdefViewOrg_aab ^ (unsigned int)v) + 2));
    LODWORD(screenBoundsMin[0].v[1]) = v[1] ^ ((refdefViewOrg_aab ^ ((_DWORD)v + 4)) * ((refdefViewOrg_aab ^ ((_DWORD)v + 4)) + 2));
    LODWORD(screenBoundsMax.v[0]) = refdefViewOrg_aab ^ ((_DWORD)v + 8);
    v24 = v[2] ^ (LODWORD(screenBoundsMax.v[0]) * (LODWORD(screenBoundsMax.v[0]) + 2));
    __asm
    {
      vmovsd  xmm7, qword ptr [rsp+41A0h+screenBoundsMin]
      vmovsd  qword ptr [rsp+41A0h+color], xmm7
    }
    v19 = *(float *)&v24;
    LODWORD(color.v[2]) = v24;
    v18 = 1;
    memset(screenBoundsMin, 0, 0xCui64);
  }
  CL_DebugMapOverlay::CL_DebugMapOverlay(&context);
  _RDI = DVARFLT_cl_transientWorldOverlayZoom;
  if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vxorps  xmm12, xmm12, xmm12
    vucomiss xmm0, xmm12
  }
  if ( v55 || !v18 )
  {
    v55 = s_transientsWorldMP.worldGridInfo == NULL;
    if ( !s_transientsWorldMP.worldGridInfo )
    {
      v56 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3887, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo");
      v55 = !v56;
      if ( v56 )
        __debugbreak();
    }
    _RCX = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rax
      vmulss  xmm4, xmm0, dword ptr [rcx+1Ch]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rax
      vmulss  xmm5, xmm0, dword ptr [rcx+1Ch]
      vmaxss  xmm1, xmm5, xmm4
      vcomiss xmm1, cs:__real@47c35000
    }
    if ( v55 )
    {
      __asm { vmovss  xmm8, cs:__real@3b449ba6 }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, cs:__real@43960000
        vdivss  xmm8, xmm0, xmm1
      }
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rcx+20h]
      vmovss  dword ptr [rbp+40A0h+var_C0], xmm2
      vmovss  xmm3, dword ptr [rcx+24h]
      vmovss  dword ptr [rbp+40A0h+var_C0+4], xmm3
      vmovss  dword ptr [rbp+40A0h+var_B8], xmm12
      vaddss  xmm7, xmm2, xmm4
      vmovss  dword ptr [rbp+40A0h+var_B8+4], xmm7
      vaddss  xmm6, xmm5, xmm3
      vmovss  dword ptr [rbp+40A0h+var_B0], xmm6
      vmovss  dword ptr [rbp+40A0h+var_B0+4], xmm12
      vaddss  xmm0, xmm2, xmm7
      vmulss  xmm5, xmm0, cs:__real@3f000000
      vmovss  dword ptr [rbp+40A0h+worldBounds.midPoint], xmm5
      vaddss  xmm0, xmm3, xmm6
      vmulss  xmm4, xmm0, cs:__real@3f000000
      vmovss  dword ptr [rbp+40A0h+worldBounds.midPoint+4], xmm4
      vmovss  dword ptr [rbp+40A0h+worldBounds.midPoint+8], xmm12
      vsubss  xmm2, xmm5, xmm2
      vsubss  xmm3, xmm4, xmm3
      vsubss  xmm0, xmm7, xmm5
      vsubss  xmm1, xmm6, xmm4
      vmaxss  xmm0, xmm0, xmm2
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize], xmm0
      vmaxss  xmm1, xmm1, xmm3
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize+4], xmm1
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize+8], xmm12
    }
    _RDI = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm0
      vmovss  xmm1, dword ptr [rdi+2Ch]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm1
      vmovaps xmm3, xmm8; desiredWorldToScreenScale
    }
    CL_DebugMapOverlay::InitFromScale(&context, ActivePlacement, screenBoundsMin, *(float *)&_XMM3, &worldBounds);
  }
  else
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rax
      vmulss  xmm0, xmm0, cs:__real@3f000000
      vmulss  xmm8, xmm0, dword ptr [rcx+1Ch]
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, rax
      vmulss  xmm0, xmm1, cs:__real@3f000000
      vmulss  xmm9, xmm0, dword ptr [rcx+1Ch]
    }
    *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadius(1u, (const vec3_t *)&color);
    __asm { vmovaps xmm6, xmm0 }
    *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0);
    __asm
    {
      vmulss  xmm2, xmm0, cs:s_transientsWorldMP.radiusMultiplier
      vmaxss  xmm6, xmm6, xmm2
    }
    _RDI = DVARFLT_cl_transientWorldOverlayZoom;
    if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm1, dword ptr [rdi+28h]
      vmovsd  qword ptr [rbp+40A0h+worldBounds.midPoint], xmm7
    }
    worldBounds.midPoint.v[2] = v19;
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm2, xmm0, xmm1
      vmulss  xmm3, xmm1, xmm6
      vmulss  xmm1, xmm8, xmm2
      vaddss  xmm0, xmm1, xmm3
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize], xmm0
      vmulss  xmm2, xmm2, xmm9
      vaddss  xmm1, xmm2, xmm3
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize+4], xmm1
      vmovss  dword ptr [rbp+40A0h+worldBounds.halfSize+8], xmm12
    }
    _RDI = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm0
      vmovss  xmm1, dword ptr [rdi+2Ch]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm1
    }
    _RDI = DVARVEC2_cl_transientWorldOverlayZoomScreenSize;
    if ( !DVARVEC2_cl_transientWorldOverlayZoomScreenSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoomScreenSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax], xmm0
      vmovss  xmm1, dword ptr [rdi+2Ch]
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax+4], xmm1
    }
    CL_DebugMapOverlay::Init(&context, ActivePlacement, screenBoundsMin, &screenBoundsMax, &worldBounds);
  }
  v287 = 0i64;
  v288 = 0i64;
  v289 = 0i64;
  v290 = 0i64;
  v85 = 0i64;
  __asm { vmovss  xmm13, cs:__real@41200000 }
  if ( v18 )
  {
    worldGridInfo = s_transientsWorldMP.worldGridInfo;
    transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
    if ( !transientWorldGridTileMapCount )
      goto LABEL_64;
    v89 = 0i64;
    v90 = transientWorldGridTileMapCount;
    do
    {
      v91 = &worldGridInfo->transientWorldGridTileMaps[v89];
      if ( v91->indexCount )
      {
        if ( v91->lodCount )
        {
          v92 = 0;
          if ( v91->gridCountY )
          {
            do
            {
              for ( j = 0; j < v91->gridCountX; ++j )
              {
                if ( CL_TransientsWorldMP_GridContainsPos((const vec3_t *)&color, v91, j, v92, 0) && v85 < 0x10 )
                  *((_WORD *)&v287 + v85++) = CL_TransientsWorldMP_GetTransientIndex(v91, j, v92, 0);
              }
              ++v92;
            }
            while ( v92 < v91->gridCountY );
            worldGridInfo = s_transientsWorldMP.worldGridInfo;
          }
        }
      }
      ++v89;
      --v90;
    }
    while ( v90 );
    if ( !v85 )
    {
LABEL_64:
      LOWORD(v287) = 0;
      v85 = 1i64;
    }
    memset_0(&dest, 0, 0x400ui64);
    Core_strcpy((char *)&dest, 0x400ui64, "Current model(s): ");
    v94 = 0;
    v95 = 0i64;
    do
    {
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(*((unsigned __int16 *)&v287 + v95));
      ProxyModel = CL_TransientsWorldMP_FindProxyModel(*HighLODLookups);
      if ( ProxyModel )
      {
        if ( v94 )
          I_strcat_truncate((char *)&dest, 0x400ui64, ", ");
        I_strcat_truncate((char *)&dest, 0x400ui64, ProxyModel->name);
      }
      v95 = ++v94;
    }
    while ( v94 < v85 );
    v98 = 0i64;
    _RBX = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+28h]
      vmovss  xmm0, dword ptr [rbx+2Ch]
      vsubss  xmm2, xmm0, cs:__real@41700000
      vaddss  xmm1, xmm13, xmm3
      vmovss  xmm8, cs:__real@40000000
      vaddss  xmm7, xmm1, xmm8
      vmovss  xmm9, cs:__real@41000000
      vaddss  xmm6, xmm2, xmm9
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm1
      vaddss  xmm0, xmm2, xmm13
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm0
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax], xmm3
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax+4], xmm2
    }
    CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
    __asm
    {
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm7
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm6
      vmovss  xmm3, cs:__real@3e19999a; fontScale
    }
    CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, *(float *)&_XMM3, &colorWhite, Unclipped, (const char *)&dest);
    Core_strcpy((char *)&dest, 0x400ui64, "Current zone(s): ");
    for ( k = 0; k < v85; v98 = ++k )
    {
      if ( k )
        I_strcat_truncate((char *)&dest, 0x400ui64, ", ");
      I_strcat_truncate((char *)&dest, 0x400ui64, s_transientsWorldMP.worldGridInfo->transientFiles[*((unsigned __int16 *)&v287 + v98)].name);
    }
    _RBX = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+28h]
      vmovss  xmm0, dword ptr [rbx+2Ch]
      vsubss  xmm2, xmm0, cs:__real@41c80000
      vaddss  xmm1, xmm13, xmm3
      vaddss  xmm6, xmm1, xmm8
      vaddss  xmm7, xmm2, xmm9
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm1
      vaddss  xmm0, xmm2, xmm13
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm0
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax], xmm3
      vmovss  dword ptr [rsp+41A0h+screenBoundsMax+4], xmm2
    }
    CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
    __asm
    {
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm6
      vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm7
      vmovss  xmm3, cs:__real@3e19999a; fontScale
    }
    CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, *(float *)&_XMM3, &colorWhite, Unclipped, (const char *)&dest);
    __asm { vmovss  xmm11, cs:__real@c20c0000 }
    v120 = DVARBOOL_cl_transientWorldStreamLookAheadEnabled;
    if ( !DVARBOOL_cl_transientWorldStreamLookAheadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v120);
    if ( v120->current.enabled )
    {
      __asm
      {
        vmovss  xmm0, dword ptr cs:s_transientsWorldMP.lastVelocityClient0
        vmulss  xmm3, xmm0, xmm0
        vmovss  xmm1, dword ptr cs:s_transientsWorldMP.lastVelocityClient0+4
        vmulss  xmm2, xmm1, xmm1
        vaddss  xmm4, xmm3, xmm2
        vmovss  xmm0, dword ptr cs:s_transientsWorldMP.lastVelocityClient0+8
        vmulss  xmm1, xmm0, xmm0
        vaddss  xmm2, xmm4, xmm1
        vsqrtss xmm7, xmm2, xmm2
      }
      _RBX = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
      if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm6, dword ptr [rbx+28h] }
      _RBX = DVARFLT_cl_transientWorldStreamLookAheadTime;
      if ( !DVARFLT_cl_transientWorldStreamLookAheadTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm2, dword ptr [rbx+28h]
        vmulss  xmm1, xmm2, xmm7
        vminss  xmm0, xmm1, xmm6
        vcvtss2sd xmm4, xmm0, xmm0
        vcvtss2sd xmm5, xmm6, xmm6
        vcvtss2sd xmm0, xmm1, xmm1
        vcvtss2sd xmm3, xmm2, xmm2
        vcvtss2sd xmm2, xmm7, xmm7
        vmovsd  [rsp+41A0h+label], xmm4
        vmovsd  qword ptr [rsp+41A0h+clipMode], xmm5
        vmovsd  [rsp+41A0h+fmt], xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_sprintf<1024>((char (*)[1024])&dest, "LookAhead Vel=%.0f Time=%.2f Lookahead=%.0f Cap=%.0f Result=%.0f", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmta, clipModea, *(double *)&labela);
      _RBX = DVARVEC2_cl_transientWorldOverlayOffset;
      if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm3, dword ptr [rbx+28h]
        vmovss  xmm0, dword ptr [rbx+2Ch]
        vsubss  xmm2, xmm0, cs:__real@420c0000
        vaddss  xmm1, xmm13, xmm3
        vaddss  xmm6, xmm1, xmm8
        vaddss  xmm7, xmm2, xmm9
        vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm1
        vaddss  xmm0, xmm2, xmm13
        vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm0
        vmovss  dword ptr [rsp+41A0h+screenBoundsMax], xmm3
        vmovss  dword ptr [rsp+41A0h+screenBoundsMax+4], xmm2
      }
      CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
      __asm
      {
        vmovss  dword ptr [rsp+41A0h+screenBoundsMin], xmm6
        vmovss  dword ptr [rsp+41A0h+screenBoundsMin+4], xmm7
        vmovss  xmm3, cs:__real@3e19999a; fontScale
      }
      CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, *(float *)&_XMM3, &colorWhite, Unclipped, (const char *)&dest);
      __asm { vmovss  xmm11, cs:__real@c2340000 }
    }
  }
  v277 = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  v152 = 0;
  if ( v277 )
  {
    v153 = 0i64;
    screenBoundsMin[0] = 0i64;
    do
    {
      v154 = (TransientWorldGridTileMap *)((char *)s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps + *(_QWORD *)&v153);
      if ( v154->indexCount )
      {
        v155 = DVARBOOL_cl_transientWorldOverlayBounds;
        if ( !DVARBOOL_cl_transientWorldOverlayBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayBounds") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v155);
        if ( !v155->current.enabled )
        {
          v156 = 0;
          if ( v154->gridCountY )
          {
            do
            {
              for ( m = 0; m < v154->gridCountX; ++m )
              {
                if ( CL_TransientsWorldMP_GetTransientIndex(v154, m, v156, 0) )
                  CL_TransientsWorldMP_DrawCell(&context, m, v156, v152);
              }
              ++v156;
            }
            while ( v156 < v154->gridCountY );
            v153 = screenBoundsMin[0];
          }
        }
        for ( n = 0; n < v154->gridCountY; ++n )
        {
          for ( ii = 0; ii < v154->gridCountX; ++ii )
          {
            TransientIndex = CL_TransientsWorldMP_GetTransientIndex(v154, ii, n, 0);
            if ( TransientIndex )
            {
              v161 = 0;
              v162 = 0i64;
              if ( v85 )
              {
                while ( *((_WORD *)&v287 + v162) != TransientIndex )
                {
                  if ( ++v162 >= v85 )
                    goto LABEL_117;
                }
                v161 = 1;
              }
LABEL_117:
              CL_TransientsWorldMP_DrawCellOutline(&context, ii, n, v152, v161);
            }
          }
        }
      }
      ++v152;
      *(_QWORD *)&v153 += 40i64;
      screenBoundsMin[0] = v153;
    }
    while ( v152 < v277 );
  }
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+0C0h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm11; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Visible Falling Hint");
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+70h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm11; yoffset
    vmovss  xmm7, cs:__real@42aa0000
    vmovaps xmm1, xmm7; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Want visibility, no mem for tile");
  __asm
  {
    vmovss  xmm8, cs:__real@c1200000
    vaddss  xmm6, xmm11, xmm8
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+0A0h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Visible Bad Quality");
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+60h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm7; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Want visibility, tile not loaded yet");
  __asm
  {
    vaddss  xmm6, xmm6, xmm8
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+90h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Visible Good Quality");
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+80h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm7; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Want visibility, waiting for quality bar or timeout");
  __asm
  {
    vaddss  xmm6, xmm6, xmm8
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+30h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Loaded");
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+40h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm7; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Hinted, not wanting visibility yet. Bad Quality.");
  __asm
  {
    vaddss  xmm6, xmm6, xmm8
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+20h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Loading");
  __asm
  {
    vmovups xmm0, xmmword ptr cs:CELL_STATE_COLORS+50h
    vmovups xmmword ptr [rsp+41A0h+color], xmm0
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm7; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &color, "Hinted, not wanting visibility yet. Good Quality.");
  __asm { vaddss  xmm6, xmm6, xmm8 }
  IsLoadModeInFrontend = CL_TransientsMP_IsLoadModeInFrontend();
  CurCost = TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend);
  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    goto LABEL_127;
  v202 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
  if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v202);
  v203 = v202->current.integer << 20;
  tileBudget = v203;
  if ( !v203 )
LABEL_127:
    tileBudget = s_transientsWorldMP.tileBudget;
  v205 = j_va("%zu / %zu mb worldtilemem used", CurCost >> 20, tileBudget >> 20);
  __asm
  {
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &WORLDMP_INVIS_COLOR, v205);
  __asm { vaddss  xmm6, xmm6, xmm8 }
  if ( MemBudget_Poll_FramesSinceLastUpdate() <= 0x3C )
  {
    MemBudget_Poll_GetLastUpdateForHUD(&dest);
    v209 = j_va("%zu mb streamer slop", (unsigned __int64)(dest.readings.pollValues[8] + dest.readings.pollValues[9]) >> 20);
  }
  else
  {
    v209 = "? streamer slop";
  }
  __asm
  {
    vmovaps xmm2, xmm6; yoffset
    vmovaps xmm1, xmm12; xoffset
  }
  CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &WORLDMP_INVIS_COLOR, v209);
  __asm { vaddss  xmm6, xmm6, xmm8 }
  v213 = 0;
  for ( jj = 0; jj < s_transientsWorldMP.numStreamPositions; ++jj )
  {
    if ( jj >= 0xE )
    {
      LODWORD(label) = 14;
      LODWORD(clipMode) = jj;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5410, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "i doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", clipMode, label) )
        __debugbreak();
    }
    _RDI = jj;
    if ( s_transientsWorldMP.streamPositions[_RDI].mainCamera )
    {
      if ( v213 >= 2 )
      {
        LODWORD(label) = 2;
        LODWORD(clipMode) = v213;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5413, ASSERT_TYPE_ASSERT, "(unsigned)( renderIndex ) < (unsigned)( ( sizeof( *array_counter( ARROW_COLOR ) ) + 0 ) )", "renderIndex doesn't index ARRAY_COUNT( ARROW_COLOR )\n\t%i not in [0, %i)", clipMode, label) )
          __debugbreak();
      }
      __asm { vmovaps xmm3, xmm13; size }
      CL_DebugMapOverlay::DrawArrow(&context, &s_transientsWorldMP.streamPositions[_RDI].pos, &s_transientsWorldMP.streamPositions[_RDI].angles, *(float *)&_XMM3, &v286[v213], Unclipped);
      if ( s_transientsWorldMP.streamPositions[_RDI].zoomLoad )
      {
        CL_TransientsWorldMP_DrawPlayerFOV(&context, &s_transientsWorldMP.streamPositions[_RDI]);
        v217 = "false";
        _R14 = &s_transientsWorldMP;
        if ( s_transientsWorldMP.streamPositions[_RDI].zoomLoad )
          v217 = "true";
        v219 = "false";
        if ( s_transientsWorldMP.streamPositions[_RDI].zoomVisibility )
          v219 = "true";
        __asm
        {
          vmovss  xmm3, dword ptr [rdi+r14+0C5Ch]
          vcvtss2sd xmm3, xmm3, xmm3
          vmovss  xmm2, dword ptr [rdi+r14+0C58h]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovss  xmm1, dword ptr [rdi+r14+0C54h]
          vcvtss2sd xmm1, xmm1, xmm1
          vmovq   r9, xmm3
          vmovq   r8, xmm2
          vmovq   rdx, xmm1
        }
        v229 = j_va("FOV: %.2f, Distance0: %.2f, Distance1: %.2f, ZoomVisibility: %s, ZoomLoad: %s", _RDX, _R8, _R9, v219, v217);
        __asm
        {
          vmovaps xmm2, xmm6; yoffset
          vmovaps xmm1, xmm12; xoffset
        }
        CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &WORLDMP_INVIS_COLOR, v229);
        __asm { vaddss  xmm6, xmm6, xmm8 }
      }
      ++v213;
    }
  }
  for ( kk = 0; kk < s_transientsWorldMP.numStreamPositions; ++kk )
    CL_TransientsWorldMP_DrawStreamingPos(&context, &v284, &s_transientsWorldMP.streamPositions[kk]);
  v233 = DCONST_DVARBOOL_cl_transientWorldOverlayStreamSync;
  if ( !DCONST_DVARBOOL_cl_transientWorldOverlayStreamSync && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayStreamSync") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v233);
  if ( v233->current.enabled )
  {
    if ( (unsigned int)screenLocalClient >= LOCAL_CLIENT_COUNT )
    {
      LODWORD(label) = 2;
      LODWORD(clipMode) = screenLocalClient;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4685, ASSERT_TYPE_ASSERT, "(unsigned)( screenLocalClient ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamSyncDraw ) ) + 0 ) )", "screenLocalClient doesn't index s_transientsWorldMP.streamSyncDraw\n\t%i not in [0, %i)", clipMode, label) )
        __debugbreak();
    }
    v234 = &s_transientsWorldMP.streamSyncDraw[screenLocalClient];
    if ( v234->requestEndTime > Sys_Milliseconds() )
    {
      v235 = 0;
      p_pos = &v234->pos;
      _RBX = v234->params.visRadius;
      do
      {
        __asm { vmovss  xmm2, dword ptr [rbx]; radius }
        CL_DebugMapOverlay::DrawCircle(&context, p_pos, *(float *)&_XMM2, &colorRed, Unclipped);
        ++v235;
        ++_RBX;
      }
      while ( v235 < 2 );
    }
  }
  v239 = DVARBOOL_cl_transientWorldOverlayPriorityList;
  if ( !DVARBOOL_cl_transientWorldOverlayPriorityList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityList") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v239);
  if ( v239->current.enabled )
  {
    v240 = 0;
    priorityOrder = s_transientsWorldMP.priorityOrder;
    v242 = 200i64;
    __asm
    {
      vmovss  xmm6, cs:__real@437a0000
      vmovss  xmm7, cs:__real@40f00000
    }
    do
    {
      _RDI = *priorityOrder;
      if ( (unsigned int)_RDI >= 0x600 )
      {
        LODWORD(label) = 1536;
        LODWORD(clipMode) = *priorityOrder;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, label) )
          __debugbreak();
      }
      v246 = _RDI;
      _RCX = &s_transientsWorldMP;
      if ( ((0x80000000 >> (_RDI & 0x1F)) & s_transientsWorldMP.requested.array[_RDI >> 5]) != 0 )
      {
        v248 = s_transientsWorldMP.lastTrPriority[_RDI];
        __asm
        {
          vmovss  xmm3, dword ptr [rcx+rdi*4+0D29Ch]
          vcvtss2sd xmm3, xmm3, xmm3
        }
        LODWORD(fmt) = v248;
        __asm { vmovq   r9, xmm3 }
        v252 = j_va("%d (LOD%u) %.3f Pri=%u", (unsigned int)_RDI, s_transientsWorldMP.transientLODIndex[_RDI], _R9, fmt);
        v253 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityListSkipLod1;
        if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityListSkipLod1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityListSkipLod1") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v253);
        if ( v253->current.enabled && s_transientsWorldMP.transientLODIndex[v246] )
        {
          ++v240;
        }
        else
        {
          if ( v240 )
          {
            v254 = j_va("%u LOD1 tiles", v240);
            __asm
            {
              vmovaps xmm2, xmm12; yoffset
              vmovaps xmm1, xmm6; xoffset
            }
            CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &WORLDMP_INVIS_COLOR, v254);
            __asm { vaddss  xmm12, xmm12, xmm7 }
            v240 = 0;
          }
          v257 = &WORLDMP_INVIS_COLOR;
          if ( v248 - 5976 <= 5 )
            v257 = &colorRed;
          __asm
          {
            vmovaps xmm2, xmm12; yoffset
            vmovaps xmm1, xmm6; xoffset
          }
          CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, v257, v252);
          __asm { vaddss  xmm12, xmm12, xmm7 }
        }
      }
      ++priorityOrder;
      --v242;
    }
    while ( v242 );
    if ( v240 )
    {
      v260 = j_va("%u LOD1 tiles", v240);
      __asm
      {
        vmovaps xmm2, xmm12; yoffset
        vmovaps xmm1, xmm6; xoffset
      }
      CL_TransientsWorldMP_DrawLegend(&context, *(double *)&_XMM1, *(double *)&_XMM2, &WORLDMP_INVIS_COLOR, v260);
    }
  }
  CL_DebugMapOverlay::~CL_DebugMapOverlay(&context);
  _R11 = &v298;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm11, xmmword ptr [r11-50h]
    vmovaps xmm12, xmmword ptr [r11-60h]
    vmovaps xmm13, xmmword ptr [r11-70h]
  }
}

/*
==============
CL_TransientsWorldMP_DrawStreamingPos
==============
*/
void CL_TransientsWorldMP_DrawStreamingPos(CL_DebugMapOverlay *context, const vec4_t *color, const WorldStreamPosition *streamPos)
{
  const vec4_t *v13; 
  __int64 transientWorldGridTileMapCount; 
  __int64 v19; 
  const TransientWorldGridTileMap *v24; 
  unsigned int v25; 
  unsigned int i; 
  unsigned int v47; 
  int *v48; 
  char v49; 
  bool v50; 
  char v60; 
  char v61; 
  const dvar_t *v64; 
  char v69; 
  char v70; 
  int v81[2]; 
  const vec4_t *v82; 
  __int64 v83; 
  __int64 v84; 
  vec3_t outCenter; 
  vec3_t outPointToClosestVec; 
  vec3_t angles; 
  vec3_t mins; 
  vec3_t maxs; 

  _RBX = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0;
  v82 = color;
  _R12 = streamPos;
  v13 = color;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1;
  __asm { vmovss  [rsp+160h+var_120], xmm0 }
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmovss  [rsp+160h+var_11C], xmm0
  }
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  if ( (_DWORD)transientWorldGridTileMapCount )
  {
    __asm { vmovaps [rsp+160h+var_40], xmm6 }
    v19 = 0i64;
    __asm
    {
      vmovaps [rsp+160h+var_50], xmm7
      vmovaps [rsp+160h+var_60], xmm8
      vmovaps [rsp+160h+var_70], xmm9
      vmovaps [rsp+160h+var_80], xmm10
      vmovaps [rsp+160h+var_90], xmm11
      vmovss  xmm11, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vmovaps [rsp+160h+var_A0], xmm12
      vmovss  xmm12, cs:__real@41200000
      vmovaps [rsp+160h+var_B0], xmm13
      vmovss  xmm13, cs:__real@7f7fffff
    }
    v83 = 0i64;
    v84 = transientWorldGridTileMapCount;
    __asm { vxorps  xmm10, xmm10, xmm10 }
    while ( 1 )
    {
      v24 = (TransientWorldGridTileMap *)((char *)s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps + v19);
      if ( !v24->indexCount )
        goto LABEL_48;
      if ( !_R12->mainCamera )
      {
        __asm
        {
          vmovaps xmm3, xmm12; size2D
          vmovss  dword ptr [rbp+60h+angles], xmm10
          vmovss  dword ptr [rbp+60h+angles+4], xmm10
          vmovss  dword ptr [rbp+60h+angles+8], xmm10
        }
        CL_DebugMapOverlay::DrawImage(context, &_R12->pos, &angles, *(float *)&_XMM3, v13, Unclipped, cgMedia.objectiveMaterials[0]);
        goto LABEL_48;
      }
      CL_TransientsWorldMP_GetVisibilityCenterPos(_R12, &outCenter);
      v25 = 0;
      __asm
      {
        vmovaps xmm6, xmm13
        vmovaps xmm7, xmm10
      }
      if ( v24->gridCountY )
      {
        do
        {
          for ( i = 0; i < v24->gridCountX; ++i )
          {
            _RAX = CL_TransientsWorldMP_GetTileBounds(v24, i, v25, 0);
            __asm
            {
              vmovss  xmm0, dword ptr [rax]
              vsubss  xmm1, xmm0, dword ptr [rax+0Ch]
              vmovss  dword ptr [rbp+60h+mins], xmm1
              vmovss  xmm0, dword ptr [rax+4]
              vsubss  xmm1, xmm0, dword ptr [rax+10h]
              vmovss  dword ptr [rbp+60h+mins+4], xmm1
              vmovss  xmm0, dword ptr [rax+8]
              vsubss  xmm1, xmm0, dword ptr [rax+14h]
              vmovss  dword ptr [rbp+60h+mins+8], xmm1
              vmovss  xmm0, dword ptr [rax]
              vaddss  xmm1, xmm0, dword ptr [rax+0Ch]
              vmovss  dword ptr [rbp+60h+maxs], xmm1
              vmovss  xmm2, dword ptr [rax+10h]
              vaddss  xmm0, xmm2, dword ptr [rax+4]
              vmovss  dword ptr [rbp+60h+maxs+4], xmm0
              vmovss  xmm1, dword ptr [rax+14h]
              vaddss  xmm2, xmm1, dword ptr [rax+8]
              vmovss  dword ptr [rbp+60h+maxs+8], xmm2
            }
            PointToClosestAABBPoint(&mins, &maxs, &outCenter, &outPointToClosestVec);
            __asm
            {
              vmovss  xmm0, dword ptr [rsp+160h+outPointToClosestVec+4]
              vmovss  xmm1, dword ptr [rsp+160h+outPointToClosestVec]
              vmulss  xmm3, xmm0, xmm0
              vmulss  xmm2, xmm1, xmm1
              vaddss  xmm0, xmm3, xmm2
              vcomiss xmm0, xmm6
            }
            if ( v49 | v50 )
            {
              __asm
              {
                vmovaps xmm6, xmm0
                vmovss  xmm0, dword ptr [rsp+160h+outPointToClosestVec+8]
                vandps  xmm0, xmm0, xmm11
                vmaxss  xmm7, xmm0, xmm7
              }
            }
          }
          ++v25;
        }
        while ( v25 < v24->gridCountY );
      }
      v47 = 0;
      v48 = v81;
      do
      {
        if ( v24->level && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4626, ASSERT_TYPE_ASSERT, "(tileMap.level == 0)", (const char *)&queryFormat, "tileMap.level == 0") )
          __debugbreak();
        *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadius(v47, &_R12->pos);
        __asm
        {
          vmovss  xmm3, dword ptr [r12+90h]
          vucomiss xmm3, xmm10
          vmulss  xmm1, xmm7, dword ptr [r14]
          vmovaps xmm9, xmm0
          vmulss  xmm2, xmm0, xmm0
          vmulss  xmm8, xmm1, xmm1
        }
        if ( v50 )
          goto LABEL_52;
        __asm { vcomiss xmm2, xmm3 }
        if ( v49 )
        {
LABEL_52:
          __asm { vcomiss xmm2, xmm8 }
          if ( !(v49 | v50) )
          {
            __asm
            {
              vsubss  xmm0, xmm2, xmm8
              vsqrtss xmm6, xmm0, xmm0
              vmovaps xmm2, xmm6; radius
            }
            CL_DebugMapOverlay::DrawCircle(context, &outCenter, *(float *)&_XMM2, &CL_DebugMapOverlay::WHITE_COLOR, Unclipped);
            if ( v47 )
            {
              _RBX = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1;
              if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl1") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(_RBX);
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+28h]
                vucomiss xmm0, xmm10
              }
              if ( !v70 )
              {
                __asm { vcomiss xmm6, xmm0 }
                if ( !(v69 | v70) )
                {
                  __asm { vsubss  xmm2, xmm6, xmm0; radius }
LABEL_42:
                  CL_DebugMapOverlay::DrawCircle(context, &outCenter, *(float *)&_XMM2, &colorBlue, Unclipped);
                }
              }
            }
            else
            {
              _RBX = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0;
              if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl0") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(_RBX);
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+28h]
                vucomiss xmm0, xmm10
              }
              if ( !v61 )
              {
                __asm { vcomiss xmm6, xmm0 }
                if ( !(v60 | v61) )
                {
                  __asm { vsubss  xmm2, xmm6, xmm0; radius }
                  CL_DebugMapOverlay::DrawCircle(context, &outCenter, *(float *)&_XMM2, &colorBlue, Unclipped);
                }
              }
              v64 = DVARFLT_cl_transientWorldVisibleHintLOD0Addition;
              if ( !DVARFLT_cl_transientWorldVisibleHintLOD0Addition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLOD0Addition") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v64);
              __asm
              {
                vaddss  xmm0, xmm9, dword ptr [rbx+28h]
                vmulss  xmm1, xmm0, xmm0
                vsubss  xmm2, xmm1, xmm8
                vsqrtss xmm2, xmm2, xmm2
                vucomiss xmm2, xmm10
              }
              if ( !v50 )
                goto LABEL_42;
            }
          }
        }
        ++v47;
        ++v48;
      }
      while ( v47 < 2 );
      __asm
      {
        vmovss  xmm0, dword ptr [r12+90h]
        vucomiss xmm0, xmm10
      }
      v19 = v83;
      if ( v47 != 2 )
      {
        __asm
        {
          vandps  xmm0, xmm0, xmm11
          vsqrtss xmm2, xmm0, xmm0; radius
        }
        CL_DebugMapOverlay::DrawCircle(context, &outCenter, *(float *)&_XMM2, &colorRed, Unclipped);
      }
      v13 = v82;
LABEL_48:
      v19 += 40i64;
      v50 = v84-- == 1;
      v83 = v19;
      if ( v50 )
      {
        __asm
        {
          vmovaps xmm13, [rsp+160h+var_B0]
          vmovaps xmm12, [rsp+160h+var_A0]
          vmovaps xmm11, [rsp+160h+var_90]
          vmovaps xmm10, [rsp+160h+var_80]
          vmovaps xmm9, [rsp+160h+var_70]
          vmovaps xmm8, [rsp+160h+var_60]
          vmovaps xmm7, [rsp+160h+var_50]
          vmovaps xmm6, [rsp+160h+var_40]
        }
        return;
      }
    }
  }
}

/*
==============
CL_TransientsWorldMP_EndListenServerStall
==============
*/
void CL_TransientsWorldMP_EndListenServerStall(void)
{
  if ( !Sys_IsServerThread() && !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3755, ASSERT_TYPE_ASSERT, "(Sys_IsServerThread() || Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsServerThread() || Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 0;
}

/*
==============
CL_TransientsWorldMP_ErrorCleanup
==============
*/
void CL_TransientsWorldMP_ErrorCleanup(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3763, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  *(_WORD *)&s_transientsWorldMP.lobbyPreloadStopped = 0;
}

/*
==============
CL_TransientsWorldMP_FillGridStreamingPosViewInfo
==============
*/
void CL_TransientsWorldMP_FillGridStreamingPosViewInfo(const LocalClientNum_t localClientNum, const bool streamRender, const bool mainCamera, WorldStreamPosition *worldStreamPos)
{
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v16; 
  bool IsUsingOffhandGestureWeaponADSSupport; 
  const Weapon *OffhandGestureWeapon; 
  const Weapon *v19; 
  __int64 p_weapFlags; 
  bool v21; 
  bool v23; 
  bool v26; 
  bool v27; 
  char v30; 
  CgHandler *Handler; 
  char v34; 
  char v35; 
  float v48; 
  float fmt; 
  float adsZoomInFrac; 
  float fovYPadding; 
  float adsZoomOutFrac; 
  ClientFov result; 
  vec3_t forward; 

  v7 = localClientNum;
  _RBX = worldStreamPos;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (int)v7 >= cg_t::ms_allocatedCount || !streamRender || !mainCamera )
  {
    *(_QWORD *)&_RBX->fovCurrent = 0i64;
    *(_WORD *)&_RBX->zoomVisibility = 0;
    _RBX->viewDir = 0i64;
    *(_QWORD *)_RBX->viewDir3D.v = 0i64;
    _RBX->viewDir3D.v[2] = 0.0;
    return;
  }
  __asm
  {
    vmovaps [rsp+0D8h+var_48], xmm6
    vmovaps [rsp+0D8h+var_58], xmm7
  }
  _RAX = CG_GetViewFovBySpace(&result, (const LocalClientNum_t)v7, CG_FovSpace_Scene, 1);
  __asm
  {
    vmovsd  xmm0, qword ptr [rax]
    vmovsd  [rsp+0D8h+var_70], xmm0
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3206, ASSERT_TYPE_ASSERT, "(predictedPlayerState)", (const char *)&queryFormat, "predictedPlayerState") )
    __debugbreak();
  _R13 = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v16 = CgWeaponMap::ms_instance[v7];
  IsUsingOffhandGestureWeaponADSSupport = BG_IsUsingOffhandGestureWeaponADSSupport(v16, p_predictedPlayerState);
  if ( IsUsingOffhandGestureWeaponADSSupport )
    OffhandGestureWeapon = BG_GetOffhandGestureWeapon(v16, p_predictedPlayerState);
  else
    OffhandGestureWeapon = BG_GetCurrentWeaponForPlayer(v16, p_predictedPlayerState);
  v19 = OffhandGestureWeapon;
  if ( p_predictedPlayerState )
  {
    p_weapFlags = (__int64)&p_predictedPlayerState->weapCommon.weapFlags;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x22u) )
      goto LABEL_18;
  }
  else
  {
    p_weapFlags = 1832i64;
  }
  if ( p_predictedPlayerState && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)p_weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)p_weapFlags, ACTIVE, 0x1Bu)) && !IsUsingOffhandGestureWeaponADSSupport )
  {
    v21 = 1;
    goto LABEL_26;
  }
LABEL_18:
  v21 = 0;
  if ( IsUsingOffhandGestureWeaponADSSupport )
  {
    *(double *)&_XMM0 = BG_GetOffhandAdsFrac(p_predictedPlayerState);
    __asm { vmovaps xmm6, xmm0 }
    goto LABEL_27;
  }
LABEL_26:
  __asm { vmovss  xmm6, dword ptr [r13+7C64Ch] }
LABEL_27:
  BG_GetADSZoomInFracs(v16, p_predictedPlayerState, v19, v21, 0, &fovYPadding, &adsZoomOutFrac);
  __asm
  {
    vmovss  xmm0, [rsp+0D8h+fovYPadding]
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
  }
  if ( !v23 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, [rsp+0D8h+var_94]
    vucomiss xmm0, xmm1
  }
  if ( v23 )
  {
    v26 = 1;
    v27 = 1;
  }
  else
  {
LABEL_30:
    __asm { vmovaps xmm2, xmm6; weapPosFrac }
    *(double *)&_XMM0 = CG_GetWeaponZoom(_R13, v19, *(const float *)&_XMM2, CG_FovSpace_Scene);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomCutoffLoad, "cl_transientWorldZoomCutoffLoad");
    __asm { vcomiss xmm6, xmm0 }
    v26 = !v30;
    *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomCutoffVisibility, "cl_transientWorldZoomCutoffVisibility");
    __asm { vcomiss xmm6, xmm0 }
    v27 = !v30;
  }
  AngleVectors(&_RBX->angles, &forward, NULL, NULL);
  Handler = CgHandler::getHandler((LocalClientNum_t)v7);
  *(double *)&_XMM0 = BG_ADSZoomFov(Handler, p_predictedPlayerState, v19, v21);
  __asm
  {
    vmovss  xmm1, dword ptr [rsp+0D8h+var_70]
    vmovss  dword ptr [rbx+30h], xmm1
    vmovss  dword ptr [rbx+34h], xmm0
    vmovaps xmm6, xmm0
  }
  if ( !v27 )
    goto LABEL_34;
  *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomVisibilityFovCutoff, "cl_transientWorldZoomVisibilityFovCutoff");
  __asm { vcomiss xmm6, xmm0 }
  if ( v30 | v23 )
    v34 = 1;
  else
LABEL_34:
    v34 = 0;
  _RBX->zoomVisibility = v34;
  if ( !v26 )
    goto LABEL_38;
  *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLoadFovCutoff, "cl_transientWorldZoomLoadFovCutoff");
  __asm { vcomiss xmm6, xmm0 }
  if ( v30 | v23 )
    v35 = 1;
  else
LABEL_38:
    v35 = 0;
  v23 = !_RBX->zoomVisibility;
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  _RBX->zoomLoad = v35;
  if ( !v23 )
  {
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_cl_transientWorldZoomFixedDist, "cl_transientWorldZoomFixedDist") )
    {
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD0FixedDist, "cl_transientWorldZoomLOD0FixedDist");
      __asm { vmovss  dword ptr [rbx+38h], xmm0 }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD1FixedDist, "cl_transientWorldZoomLOD1FixedDist");
    }
    else
    {
      __asm
      {
        vmovss  xmm2, cs:__real@43340000; max
        vmovaps xmm1, xmm7; min
        vmovaps xmm0, xmm6; val
      }
      I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  xmm1, cs:__real@42700000
        vdivss  xmm6, xmm1, xmm0
      }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD0Dist, "cl_transientWorldZoomLOD0Dist");
      __asm
      {
        vmulss  xmm1, xmm0, xmm6
        vmovss  dword ptr [rbx+38h], xmm1
      }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD1Dist, "cl_transientWorldZoomLOD1Dist");
      __asm { vmulss  xmm0, xmm0, xmm6 }
    }
    __asm { vmovss  dword ptr [rbx+3Ch], xmm0 }
    *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomFovYPadding, "cl_transientWorldZoomFovYPadding");
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomFovXPadding, "cl_transientWorldZoomFovXPadding");
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+3Ch]; farDistance
      vmovss  dword ptr [rsp+0D8h+adsZoomInFrac], xmm6
      vmovss  dword ptr [rsp+0D8h+fmt], xmm0
    }
    CL_TransientsWorldMP_GetFrustumPlanes(_R13, &_RBX->pos, &forward, *(float *)&_XMM3, fmt, adsZoomInFrac, _RBX->frustumPlanes);
  }
  __asm
  {
    vmovsd  xmm0, qword ptr [rsp+0D8h+forward]
    vmovss  xmm3, dword ptr [rsp+0D8h+forward]
    vmovss  xmm4, dword ptr [rsp+0D8h+forward+4]
  }
  v48 = forward.v[2];
  __asm
  {
    vmovaps xmm6, [rsp+0D8h+var_48]
    vmovsd  qword ptr [rbx+20h], xmm0
    vmulss  xmm0, xmm4, xmm4
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm1, xmm1, xmm0
    vsqrtss xmm2, xmm1, xmm1
    vcmpless xmm0, xmm2, cs:__real@80000000
    vblendvps xmm0, xmm2, xmm7, xmm0
    vdivss  xmm1, xmm7, xmm0
    vmovaps xmm7, [rsp+0D8h+var_58]
    vmulss  xmm0, xmm3, xmm1
  }
  _RBX->viewDir3D.v[2] = v48;
  __asm
  {
    vmulss  xmm1, xmm4, xmm1
    vmovss  dword ptr [rbx+1Ch], xmm1
    vmovss  dword ptr [rbx+18h], xmm0
  }
}

/*
==============
CL_TransientsWorldMP_FindProxyModel
==============
*/
XModel *CL_TransientsWorldMP_FindProxyModel(const unsigned int transientIndex)
{
  GfxWorld *world; 
  unsigned __int16 *v3; 
  unsigned __int16 v4; 
  unsigned __int64 v5; 
  unsigned int v6; 
  int v7; 
  GfxStaticModelCollection *v8; 
  __int64 v10; 
  __int64 v11; 

  world = rgp.world;
  if ( !rgp.world )
    return 0i64;
  v3 = &s_transientsWorldMP.debugProxyModelIndex[transientIndex];
  v4 = *v3;
  if ( *v3 == 0xFFFF )
  {
    if ( transientIndex )
    {
      if ( transientIndex >= 0x600 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", transientIndex, 1536) )
          __debugbreak();
        world = rgp.world;
      }
      v5 = (unsigned __int64)transientIndex >> 5;
      v6 = 0x80000000 >> (transientIndex & 0x1F);
      if ( (v6 & s_transientsWorldMP.loaded.array[v5]) != 0 )
        goto LABEL_14;
      if ( transientIndex >= 0x600 )
      {
        LODWORD(v11) = 1536;
        LODWORD(v10) = transientIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v10, v11) )
          __debugbreak();
        world = rgp.world;
      }
      if ( (v6 & s_transientsWorldMP.transientsHighestLOD.array[v5]) != 0 )
      {
LABEL_14:
        v7 = 0;
        *v3 = -2;
        v4 = -2;
        if ( !world->smodels.collectionCount )
          goto LABEL_28;
        while ( 1 )
        {
          v8 = &world->smodels.collections[v7];
          if ( v8->firstInstance >= world->smodels.instanceCount )
          {
            LODWORD(v11) = world->smodels.instanceCount;
            LODWORD(v10) = v8->firstInstance;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2385, ASSERT_TYPE_ASSERT, "(unsigned)( collection.firstInstance ) < (unsigned)( rgp.world->smodels.instanceCount )", "collection.firstInstance doesn't index rgp.world->smodels.instanceCount\n\t%i not in [0, %i)", v10, v11) )
              __debugbreak();
            world = rgp.world;
          }
          if ( world->smodels.modelStaticIndirection[v8->firstInstance].worldTransient == transientIndex )
            break;
          if ( ++v7 >= world->smodels.collectionCount )
            goto LABEL_27;
        }
        if ( v8->smodelIndex >= world->smodels.modelCount )
        {
          LODWORD(v11) = world->smodels.modelCount;
          LODWORD(v10) = v8->smodelIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2389, ASSERT_TYPE_ASSERT, "(unsigned)( collection.smodelIndex ) < (unsigned)( rgp.world->smodels.modelCount )", "collection.smodelIndex doesn't index rgp.world->smodels.modelCount\n\t%i not in [0, %i)", v10, v11) )
            __debugbreak();
          world = rgp.world;
        }
        *v3 = v8->smodelIndex;
      }
    }
LABEL_27:
    v4 = *v3;
    if ( *v3 == 0xFFFF )
      return 0i64;
  }
LABEL_28:
  if ( v4 == 0xFFFE )
    return 0i64;
  if ( v4 >= world->smodels.modelCount )
  {
    LODWORD(v11) = world->smodels.modelCount;
    LODWORD(v10) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2397, ASSERT_TYPE_ASSERT, "(unsigned)( foundModelIndex ) < (unsigned)( rgp.world->smodels.modelCount )", "foundModelIndex doesn't index rgp.world->smodels.modelCount\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
    world = rgp.world;
  }
  return world->smodels.models[*v3].model;
}

/*
==============
CL_TransientsWorldMP_GetBudgetBytes
==============
*/
unsigned __int64 CL_TransientsWorldMP_GetBudgetBytes()
{
  const dvar_t *v0; 
  unsigned __int64 result; 

  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    return s_transientsWorldMP.tileBudget;
  v0 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
  if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  result = v0->current.integer << 20;
  if ( !(_DWORD)result )
    return s_transientsWorldMP.tileBudget;
  return result;
}

/*
==============
CL_TransientsWorldMP_GetCellState
==============
*/
__int64 CL_TransientsWorldMP_GetCellState(const unsigned int transientIndex)
{
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 
  int v4; 
  unsigned int *v5; 
  unsigned int i; 
  int v7; 
  unsigned int *j; 
  __int64 result; 
  bool v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 

  v1 = transientIndex;
  if ( !transientIndex || !s_transientsWorldMP.ignoreTransientSkip && transientIndex < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, transientIndex) )
    return 0i64;
  if ( (unsigned int)v1 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v1, 1536) )
    __debugbreak();
  v2 = 0x80000000 >> (v1 & 0x1F);
  v3 = v1 >> 5;
  if ( (v2 & s_transientsWorldMP.missingModelTransients.array[v3]) != 0 )
    return 11i64;
  if ( (unsigned int)v1 >= 0x600 )
  {
    LODWORD(v13) = 1536;
    LODWORD(v12) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
      __debugbreak();
  }
  if ( (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
  {
    v4 = 0;
    v5 = &s_transientsWorldMP.visibleCurrent[0].array[v3];
    for ( i = 0; i < 2; ++i )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *v5) != 0 )
      {
        if ( (unsigned int)v1 < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v1) )
          return 11i64;
        if ( (unsigned int)v1 >= 0x600 )
        {
          LODWORD(v13) = 1536;
          LODWORD(v12) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
            __debugbreak();
        }
        if ( (v2 & s_transientsWorldMP.fallingHinted.array[v3]) != 0 )
          return 12i64;
        else
          return 10 - (unsigned int)Stream_TransientZoneStreamingQualitySufficient(v1);
      }
      v5 += 48;
    }
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v13) = 1536;
      LODWORD(v12) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
        __debugbreak();
    }
    if ( (v2 & s_transientsWorldMP.loaded.array[v3]) == 0 )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      v10 = (v2 & s_transientsWorldMP.wantVisibleButNotLoaded.array[v3]) == 0;
      result = 2i64;
      v11 = 6;
      goto LABEL_40;
    }
    v7 = 0;
    for ( j = &s_transientsWorldMP.visibleHint[0].array[v3]; ; j += 48 )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *(j - 96)) != 0 )
        break;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *j) != 0 )
      {
        LOBYTE(v4) = Stream_TransientZoneStreamingQualitySufficient(v1);
        return (unsigned int)(v4 + 4);
      }
      if ( (unsigned int)++v7 >= 2 )
        return 3i64;
    }
    return 8i64;
  }
  else
  {
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v13) = 1536;
      LODWORD(v12) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
        __debugbreak();
    }
    v10 = (v2 & s_transientsWorldMP.wantVisibleButNotLoaded.array[v3]) == 0;
    result = 1i64;
    v11 = 7;
LABEL_40:
    if ( !v10 )
      return v11;
  }
  return result;
}

/*
==============
CL_TransientsWorldMP_GetChangeVisible
==============
*/
bitarray<1536> *CL_TransientsWorldMP_GetChangeVisible()
{
  if ( s_transientsWorldMP.systemEnabled )
    return &s_transientsWorldMP.changedVisible;
  else
    return 0i64;
}

/*
==============
CL_TransientsWorldMP_GetFacingDistAdd
==============
*/
float CL_TransientsWorldMP_GetFacingDistAdd()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride;
  if ( !DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleRadiusOverride") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
  {
    _RBX = DCONST_DVARFLT_cl_transientWorldVisibleFacingDistAdd;
    if ( !DCONST_DVARFLT_cl_transientWorldVisibleFacingDistAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingDistAdd") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  else
  {
    __asm { vmovss  xmm0, cs:?comWorld@@3UComWorld@@A.trVisFacingDistAdd; ComWorld comWorld }
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_GetFrustumPlanes
==============
*/

void __fastcall CL_TransientsWorldMP_GetFrustumPlanes(const cg_t *const cgameGlob, const vec3_t *currentPos, const vec3_t *forwardDir, double farDistance, float fovXPadding, float fovYPadding, vec4_t *frustumPlanes)
{
  vec4_t result; 
  vec3_t dir; 
  vec3_t pt; 
  GfxCamera camera; 
  tmat44_t<vec4_t> in2; 
  tmat44_t<vec4_t> mtx; 
  tmat44_t<vec4_t> out; 
  char vars0; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm8
  }
  _RSI = frustumPlanes;
  __asm { vmovaps xmm8, xmm3 }
  _RBX = forwardDir;
  R_SetCameraForView(&cgameGlob->refdef.view, &camera);
  __asm { vmovss  xmm0, dword ptr [rbp+0B0h+camera.___u2]; X }
  *(float *)&_XMM0 = atanf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm0, xmm0, cs:__real@42652ee0
    vaddss  xmm1, xmm0, [rbp+0B0h+fovXPadding]
    vmulss  xmm0, xmm1, cs:__real@3c8efa35; X
  }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm
  {
    vmovss  dword ptr [rbp+0B0h+camera.___u2], xmm0
    vmovss  xmm0, dword ptr [rbp+0B0h+camera.___u3]; X
  }
  *(float *)&_XMM0 = atanf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@42652ee0
    vaddss  xmm2, xmm1, [rbp+0B0h+fovYPadding]
    vmulss  xmm0, xmm2, cs:__real@3c8efa35; X
  }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm { vmovss  dword ptr [rbp+0B0h+camera.___u3], xmm0 }
  MatrixForViewerOrthogonal(&camera.origin, &camera.axis, &mtx);
  __asm
  {
    vmovss  xmm2, [rbp+0B0h+camera.zPlanes+8]; zNear
    vmovss  xmm1, dword ptr [rbp+0B0h+camera.___u3]; tanHalfFovY
    vmovss  xmm0, dword ptr [rbp+0B0h+camera.___u2]; tanHalfFovX
  }
  InfinitePerspectiveMatrix(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, &in2);
  MatrixMultiply44Aligned(&mtx, &in2, &out);
  R_FrustumClipPlanes((const GfxMatrix *)&out, STANDARD_FRUSTUM_SIDE_PLANES, 4, (DpvsPlane *)frustumPlanes);
  __asm
  {
    vmovss  xmm4, dword ptr [rbx]
    vmovss  xmm3, dword ptr [rbx+4]
    vmovss  xmm2, dword ptr [rbx+8]
    vmovss  xmm6, dword ptr cs:__xmm@80000000800000008000000080000000
    vmulss  xmm0, xmm8, xmm4
    vaddss  xmm1, xmm0, dword ptr [rdi]
    vmovss  dword ptr [rsp+1B0h+pt], xmm1
    vmulss  xmm0, xmm8, xmm3
    vaddss  xmm1, xmm0, dword ptr [rdi+4]
    vmulss  xmm0, xmm8, xmm2
    vmovss  dword ptr [rsp+1B0h+pt+4], xmm1
    vaddss  xmm1, xmm0, dword ptr [rdi+8]
    vxorps  xmm0, xmm4, xmm6
    vmovss  dword ptr [rsp+1B0h+dir], xmm0
    vmovss  dword ptr [rsp+1B0h+pt+8], xmm1
    vxorps  xmm0, xmm2, xmm6
    vxorps  xmm1, xmm3, xmm6
    vmovss  dword ptr [rsp+1B0h+dir+8], xmm0
    vmovss  dword ptr [rsp+1B0h+dir+4], xmm1
  }
  _RAX = PlaneFromPoint(&result, &pt, &dir);
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vshufps xmm0, xmm1, xmm1, 0FFh
    vxorps  xmm0, xmm0, xmm6
    vmovups xmmword ptr [rsi+40h], xmm1
    vmovss  dword ptr [rsi+4Ch], xmm0
  }
  _R11 = &vars0;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-20h]
  }
}

/*
==============
CL_TransientsWorldMP_GetGridTransientMPIndex
==============
*/
__int64 CL_TransientsWorldMP_GetGridTransientMPIndex(const unsigned int worldMapIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = worldMapIndex;
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1792, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    v4 = 1536;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1793, ASSERT_TYPE_ASSERT, "(unsigned)( worldMapIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientToMPIndexMapping ) ) + 0 ) )", "worldMapIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientToMPIndexMapping )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return s_transientsWorldMP.transientToMPIndexMapping[v1];
}

/*
==============
CL_TransientsWorldMP_GetHighLODLookups
==============
*/
unsigned __int16 *CL_TransientsWorldMP_GetHighLODLookups(unsigned int baseTransientIndex)
{
  __int64 v2; 
  __int64 v4; 

  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1111, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  v2 = baseTransientIndex * s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  if ( (unsigned int)v2 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount )
  {
    LODWORD(v4) = baseTransientIndex * s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1113, ASSERT_TYPE_ASSERT, "(unsigned)( lodhighLodLookupIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount )", "lodhighLodLookupIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount\n\t%i not in [0, %i)", v4, s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount) )
      __debugbreak();
  }
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup[v2];
}

/*
==============
CL_TransientsWorldMP_GetLODFileCount
==============
*/
__int64 CL_TransientsWorldMP_GetLODFileCount(unsigned int lodLevel)
{
  __int64 v1; 
  int v4; 

  v1 = lodLevel;
  if ( lodLevel >= 3 )
  {
    v4 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3819, ASSERT_TYPE_ASSERT, "(unsigned)( lodLevel ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lodFileCount ) ) + 0 ) )", "lodLevel doesn't index ARRAY_COUNT( s_transientsWorldMP.lodFileCount )\n\t%i not in [0, %i)", lodLevel, v4) )
      __debugbreak();
  }
  return s_transientsWorldMP.lodFileCount[v1];
}

/*
==============
CL_TransientsWorldMP_GetLobbyStreamPositions
==============
*/
__int64 CL_TransientsWorldMP_GetLobbyStreamPositions(vec3_t *outPos, unsigned int outPosSize)
{
  unsigned int lobbyStreamPosCount; 
  const dvar_t *v5; 
  unsigned int v7; 

  lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  _RBX = outPos;
  if ( s_transientsWorldMP.lobbyStreamPosCount )
  {
    v7 = 0;
    if ( outPosSize )
    {
      _RDX = (char *)((char *)s_transientsWorldMP.lobbyStreamPos - (char *)_RBX);
      while ( v7 < lobbyStreamPosCount )
      {
        __asm
        {
          vmovsd  xmm0, qword ptr [rdx+rbx]
          vmovsd  qword ptr [rbx], xmm0
        }
        ++v7;
        _RBX->v[2] = *(float *)((char *)&_RBX->v[2] + (_QWORD)_RDX);
        ++_RBX;
        if ( v7 >= outPosSize )
          return 0i64;
        lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
      }
      return v7;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    if ( !outPosSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3443, ASSERT_TYPE_ASSERT, "(outPosSize >= 1)", (const char *)&queryFormat, "outPosSize >= 1") )
      __debugbreak();
    v5 = DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos;
    if ( !DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDefaultPos") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    LODWORD(_RBX->v[0]) = v5->current.integer;
    _RBX->v[1] = v5->current.vector.v[1];
    _RBX->v[2] = v5->current.vector.v[2];
    return 1i64;
  }
}

/*
==============
CL_TransientsWorldMP_GetMemoryMaxMB
==============
*/
__int64 CL_TransientsWorldMP_GetMemoryMaxMB(WorldStreamingQuality qualityLevel)
{
  __int64 v7; 
  __int64 v8; 

  _RDI = qualityLevel;
  if ( qualityLevel >= WORLD_STREAM_QUALITY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2250, ASSERT_TYPE_ASSERT, "(qualityLevel < 2)", (const char *)&queryFormat, "qualityLevel < 2") )
    __debugbreak();
  _RBX = DVARVEC2_cl_transientWorldMemoryMaxMB;
  if ( !DVARVEC2_cl_transientWorldMemoryMaxMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMaxMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmovss  xmm1, dword ptr [rbx+2Ch]
    vmovss  [rsp+58h+var_18], xmm0
    vmovss  [rsp+58h+var_14], xmm1
  }
  if ( (unsigned int)_RDI >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = _RDI;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  __asm { vcvttss2si rax, [rsp+rdi*4+58h+var_18] }
  return _RAX << 20;
}

/*
==============
CL_TransientsWorldMP_GetOverlayClipMode
==============
*/

_BOOL8 __fastcall CL_TransientsWorldMP_GetOverlayClipMode(double _XMM0_8)
{
  char v3; 

  _RBX = DVARFLT_cl_transientWorldOverlayZoom;
  if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm0, dword ptr [rbx+28h]
  }
  return v3 != 0;
}

/*
==============
CL_TransientsWorldMP_GetPriorityGraphValueY
==============
*/
double CL_TransientsWorldMP_GetPriorityGraphValueY(unsigned int transientIndex, TransientWorldPriorityGraphType graphType)
{
  unsigned int v7; 
  unsigned __int16 *priorityOrder; 
  unsigned int v13; 

  _R9 = transientIndex;
  _R11 = 0x140000000ui64;
  switch ( graphType )
  {
    case TRANSIENT_WORLD_PRIORITY_GRAPH_LOAD_DISTANCE:
      __asm
      {
        vmovss  xmm0, dword ptr rva s_transientsWorldMP.priorityList.loadDistanceSq[r11+r9*4]; jumptable 0000000140460267 case 1
        vsqrtss xmm0, xmm0, xmm0
      }
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_LOAD_ORDER:
      v7 = 0;
      priorityOrder = s_transientsWorldMP.priorityOrder;
      while ( *priorityOrder != (_DWORD)_R9 )
      {
        ++v7;
        ++priorityOrder;
        if ( v7 >= 0x600 )
        {
          __asm { vxorps  xmm0, xmm0, xmm0 }
          return *(double *)&_XMM0;
        }
      }
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, rax
      }
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_ZDIST:
      __asm { vmovss  xmm0, rva s_transientsWorldMP.priorityDistZ[r11+r9*4]; jumptable 0000000140460267 case 3 }
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_ZTOP:
      if ( transientIndex >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        goto LABEL_23;
      _RAX = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
      _RCX = 3i64 * transientIndex;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+rcx*8+14h]
        vaddss  xmm0, xmm0, dword ptr [rax+rcx*8+8]
      }
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_VIEW_DOT:
      __asm { vmovss  xmm0, rva s_transientsWorldMP.priorityViewDot[r11+r9*4]; jumptable 0000000140460267 case 5 }
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_BOOST_IN_AIR:
      if ( s_transientsWorldMP.transientLODIndex[transientIndex] != 1 )
        goto LABEL_23;
      v13 = 0;
      if ( !s_transientsWorldMP.numStreamPositions )
        goto LABEL_23;
      while ( 1 )
      {
        _RDX = v13;
        if ( s_transientsWorldMP.streamPositions[_RDX].localClientIndex == LOCAL_CLIENT_0 && s_transientsWorldMP.streamPositions[_RDX].streamRender )
          break;
        if ( ++v13 >= s_transientsWorldMP.numStreamPositions )
          goto LABEL_23;
      }
      __asm
      {
        vmovss  xmm0, rva s_transientsWorldMP.priorityDistXY[r11+r9*4]
        vmovss  xmm3, rva s_transientsWorldMP.priorityViewDot[r11+r9*4]
        vmovss  xmm1, dword ptr [rdx+r11+8D218F8h]
        vmulss  xmm2, xmm0, xmm0
        vmovss  xmm0, dword ptr [rdx+r11+8D218D8h]
      }
      *(float *)&_XMM0 = CL_TransientsWorldMP_CalcViewDotBoostInAir(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, *(double *)&_XMM3);
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_MEMORY:
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, rax
      }
      if ( (TransientCostCalc_GetCostToLoad(&s_transientsWorldMP.worldCost, transientIndex, 0) & 0x8000000000000000ui64) != 0i64 )
        __asm { vaddss  xmm0, xmm0, cs:__real@5f800000 }
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4921, ASSERT_TYPE_ASSERT, "(0)", (const char *)&queryFormat, "0") )
        __debugbreak();
LABEL_23:
      __asm { vxorps  xmm0, xmm0, xmm0 }
      break;
  }
  return *(double *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_GetTileBounds
==============
*/
Bounds *CL_TransientsWorldMP_GetTileBounds(const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v8; 
  __int64 v10; 
  __int64 v12; 
  unsigned int gridCountX; 

  if ( gridX >= tileMap->gridCountX )
  {
    gridCountX = tileMap->gridCountX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 797, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, gridCountX) )
      __debugbreak();
  }
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v12) = tileMap->gridCountY;
    LODWORD(v10) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 798, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  if ( lod >= tileMap->lodCount )
  {
    LODWORD(v12) = tileMap->lodCount;
    LODWORD(v10) = lod;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 799, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( tileMap.lodCount )", "lod doesn't index tileMap.lodCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v8 = tileMap->spaceToTransientIndex[lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY)];
  if ( (unsigned int)v8 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 803, ASSERT_TYPE_ASSERT, "(transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v8];
}

/*
==============
CL_TransientsWorldMP_GetTransientIndex
==============
*/
__int64 CL_TransientsWorldMP_GetTransientIndex(const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v8; 
  __int64 v10; 
  __int64 v12; 
  unsigned int gridCountX; 

  if ( gridX >= tileMap->gridCountX )
  {
    gridCountX = tileMap->gridCountX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 774, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, gridCountX) )
      __debugbreak();
  }
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v12) = tileMap->gridCountY;
    LODWORD(v10) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 775, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  if ( lod >= tileMap->lodCount )
  {
    LODWORD(v12) = tileMap->lodCount;
    LODWORD(v10) = lod;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 776, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( tileMap.lodCount )", "lod doesn't index tileMap.lodCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v8 = lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY);
  if ( (unsigned int)v8 >= tileMap->indexCount )
  {
    LODWORD(v12) = tileMap->indexCount;
    LODWORD(v10) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 779, ASSERT_TYPE_ASSERT, "(unsigned)( spaceIndex ) < (unsigned)( tileMap.indexCount )", "spaceIndex doesn't index tileMap.indexCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  return tileMap->spaceToTransientIndex[v8];
}

/*
==============
CL_TransientsWorldMP_GetVisibilityCenterPos
==============
*/
void CL_TransientsWorldMP_GetVisibilityCenterPos(const WorldStreamPosition *worldPos, vec3_t *outCenter)
{
  const dvar_t *v4; 
  float c; 
  float s[5]; 

  _RDI = outCenter;
  _RBX = worldPos;
  if ( !worldPos->mainCamera )
    goto LABEL_7;
  v4 = DVARBOOL_cl_transientWorldVisibleFacingCircleSweep;
  if ( !DVARBOOL_cl_transientWorldVisibleFacingCircleSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingCircleSweep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+10h]
      vmulss  xmm0, xmm0, cs:__real@3c8efa35; radians
    }
    FastSinCos(*(const float *)&_XMM0, s, &c);
    *(float *)&_XMM0 = CL_TransientsWorldMP_GetFacingDistAdd();
    __asm
    {
      vmulss  xmm1, xmm0, [rsp+58h+c]
      vaddss  xmm2, xmm1, dword ptr [rbx]
      vmulss  xmm0, xmm0, [rsp+58h+s]
      vmovss  dword ptr [rdi], xmm2
      vaddss  xmm1, xmm0, dword ptr [rbx+4]
    }
  }
  else
  {
LABEL_7:
    _RDI->v[0] = _RBX->pos.v[0];
    __asm { vmovss  xmm1, dword ptr [rbx+4] }
  }
  __asm { vmovss  dword ptr [rdi+4], xmm1 }
  _RDI->v[2] = _RBX->pos.v[2];
}

/*
==============
CL_TransientsWorldMP_GetVisibilityRadius
==============
*/
float CL_TransientsWorldMP_GetVisibilityRadius(const unsigned int level, const vec3_t *streamPos)
{
  char v11; 
  char v12; 
  const dvar_t *v16; 
  const dvar_t *v20; 
  const dvar_t *v22; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RDI = streamPos;
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(level);
  __asm { vmovaps xmm6, xmm0 }
  if ( level == 1 )
  {
    _RBX = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
    __asm
    {
      vmovaps [rsp+78h+var_38], xmm8
      vmovss  xmm8, dword ptr [rdi+8]
    }
    if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vcomiss xmm8, dword ptr [rbx+28h] }
    if ( v11 | v12 )
    {
      __asm { vmulss  xmm0, xmm6, cs:s_transientsWorldMP.radiusMultiplier }
    }
    else
    {
      _RBX = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd;
      __asm { vmovaps [rsp+78h+var_28], xmm7 }
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZEnd") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm7, dword ptr [rbx+28h] }
      _RBX = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vcomiss xmm7, dword ptr [rbx+28h] }
      if ( v11 | v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 634, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd, \"cl_transientWorldVisibleLOD1BoostInAirZEnd\" ) > Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart, \"cl_transientWorldVisibleLOD1BoostInAirZStart\" ))", (const char *)&queryFormat, "Dconst_GetFloat( cl_transientWorldVisibleLOD1BoostInAirZEnd ) > Dconst_GetFloat( cl_transientWorldVisibleLOD1BoostInAirZStart )") )
        __debugbreak();
      v16 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v16);
      __asm { vsubss  xmm8, xmm8, dword ptr [rbx+28h] }
      _RBX = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd;
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZEnd") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm7, dword ptr [rbx+28h] }
      v20 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v20);
      __asm { vsubss  xmm0, xmm7, dword ptr [rbx+28h] }
      v22 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirMaxAdd;
      __asm
      {
        vdivss  xmm1, xmm8, xmm0
        vminss  xmm7, xmm1, cs:__real@3f800000
      }
      if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirMaxAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirMaxAdd") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v22);
      __asm
      {
        vmulss  xmm0, xmm7, dword ptr [rbx+28h]
        vmovaps xmm7, [rsp+78h+var_28]
        vaddss  xmm2, xmm6, xmm0
        vmulss  xmm0, xmm2, cs:s_transientsWorldMP.radiusMultiplier
      }
    }
    __asm
    {
      vmovaps xmm8, [rsp+78h+var_38]
      vmovaps xmm6, [rsp+78h+var_18]
    }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm6, cs:s_transientsWorldMP.radiusMultiplier
      vmovaps xmm6, [rsp+78h+var_18]
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos
==============
*/
float CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(const unsigned int level)
{
  __int64 v2; 
  const dvar_t *v4; 
  const dvar_t *v9; 
  __int64 v12; 
  __int64 v13; 

  v2 = level;
  if ( level < 2 )
  {
    v4 = DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride;
    __asm { vmovaps [rsp+58h+var_18], xmm6 }
    if ( !DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleRadiusOverride") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    if ( v4->current.enabled )
    {
      if ( !TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 601, ASSERT_TYPE_ASSERT, "(TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level])", (const char *)&queryFormat, "TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level]") )
        __debugbreak();
      if ( !*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 602, ASSERT_TYPE_ASSERT, "(*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level])", (const char *)&queryFormat, "*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level]") )
        __debugbreak();
      _RCX = (__int64)*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v2];
      __asm { vmovss  xmm6, dword ptr [rcx+28h] }
    }
    else
    {
      if ( (unsigned int)v2 >= 5 )
      {
        LODWORD(v13) = 5;
        LODWORD(v12) = v2;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 610, ASSERT_TYPE_ASSERT, "(unsigned)( level ) < (unsigned)( ( sizeof( *array_counter( comWorld.trVisRadii ) ) + 0 ) )", "level doesn't index comWorld.trVisRadii\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      _RAX = v2;
      _RBX = 0x140000000ui64;
      __asm { vmovss  xmm6, rva ?comWorld@@3UComWorld@@A.trVisRadii[rbx+rax*4]; ComWorld comWorld }
    }
    v9 = DVARBOOL_cl_transientWorldVisibleFacingCircleSweep;
    if ( !DVARBOOL_cl_transientWorldVisibleFacingCircleSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingCircleSweep") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    if ( !v9->current.enabled )
    {
      CL_TransientsWorldMP_GetFacingDistAdd();
      __asm { vaddss  xmm6, xmm6, xmm0 }
    }
    __asm
    {
      vmovaps xmm0, xmm6
      vmovaps xmm6, [rsp+58h+var_18]
    }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@7f7fffff }
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_GetWorldStreamParamsInternal
==============
*/
void CL_TransientsWorldMP_GetWorldStreamParamsInternal(WorldStreamParameters *params, const vec3_t *streamPos)
{
  const dvar_t *v3; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  const dvar_t *v11; 
  char v20; 

  v3 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0;
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  _RBX = params;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  LODWORD(_RBX->visZMultipliers[0]) = v3->current.integer;
  v5 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  LODWORD(_RBX->visZMultipliers[1]) = v5->current.integer;
  v6 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vsubss  xmm1, xmm0, dword ptr [rdi+28h]
    vxorps  xmm6, xmm6, xmm6
    vmaxss  xmm0, xmm1, xmm6
    vmovss  dword ptr [rbx+1Ch], xmm0
  }
  v11 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  __asm
  {
    vmovss  xmm3, dword ptr [rbx+0Ch]
    vsubss  xmm0, xmm3, dword ptr [rdi+28h]
    vmovss  xmm1, dword ptr [rbx+8]
    vmaxss  xmm0, xmm0, xmm6
    vmovss  dword ptr [rbx+20h], xmm0
    vmulss  xmm0, xmm3, xmm3
    vmulss  xmm2, xmm1, xmm1
    vmovss  dword ptr [rbx+14h], xmm0
    vmovss  dword ptr [rbx+10h], xmm2
  }
  _RDI = DVARFLT_cl_transientWorldVisibleHintLOD0Addition;
  if ( !DVARFLT_cl_transientWorldVisibleHintLOD0Addition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLOD0Addition") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vucomiss xmm0, xmm6
  }
  if ( !v20 )
  {
    __asm
    {
      vaddss  xmm0, xmm0, dword ptr [rbx+8]
      vmulss  xmm6, xmm0, xmm0
    }
  }
  __asm
  {
    vmovss  dword ptr [rbx+18h], xmm6
    vmovss  xmm0, dword ptr [rbx+1Ch]
    vmovss  xmm2, dword ptr [rbx+20h]
    vmovaps xmm6, [rsp+58h+var_18]
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vmovss  dword ptr [rbx+28h], xmm0
    vmovss  xmm0, dword ptr [rbx+4]
    vminss  xmm2, xmm0, dword ptr [rbx]
    vmovss  dword ptr [rbx+24h], xmm1
    vmovss  xmm1, dword ptr [rbx+8]
    vmaxss  xmm3, xmm1, dword ptr [rbx+0Ch]
    vdivss  xmm1, xmm3, xmm2
    vmulss  xmm0, xmm1, xmm1
    vmovss  dword ptr [rbx+30h], xmm0
    vmovss  dword ptr [rbx+2Ch], xmm1
  }
}

/*
==============
CL_TransientsWorldMP_GetWorldTileBudgetMultiplier
==============
*/
float CL_TransientsWorldMP_GetWorldTileBudgetMultiplier()
{
  const char *v3; 
  const char *mapName; 
  __int64 v5; 
  signed __int64 v6; 
  int v7; 
  __int64 v8; 
  int v9; 
  int v10; 
  int v11; 
  const char *v13; 

  if ( s_transientsWorldMP.isBRMap )
  {
    if ( s_transientsWorldMP.inLobbyState )
    {
      _RBX = DVARFLT_cl_transientWorldMemoryFreeMulBRLobby;
      if ( !DVARFLT_cl_transientWorldMemoryFreeMulBRLobby && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFreeMulBRLobby") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm0, dword ptr [rbx+28h] }
    }
    else
    {
      _RBX = DVARFLT_cl_transientWorldMemoryFreeMulBR;
      if ( !DVARFLT_cl_transientWorldMemoryFreeMulBR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFreeMulBR") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm0, dword ptr [rbx+28h] }
    }
  }
  else
  {
    v3 = "cp_";
    mapName = s_transientsWorldMP.mapName;
    v5 = 3i64;
    if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    v6 = mapName - "cp_";
    while ( 1 )
    {
      v7 = (unsigned __int8)v3[v6];
      v8 = v5;
      v9 = *(unsigned __int8 *)v3++;
      --v5;
      if ( !v8 )
      {
LABEL_23:
        _RBX = DVARFLT_cl_transientWorldMemoryFreeMulCP;
        if ( DVARFLT_cl_transientWorldMemoryFreeMulCP )
          goto LABEL_27;
        v13 = "cl_transientWorldMemoryFreeMulCP";
        goto LABEL_25;
      }
      if ( v7 != v9 )
      {
        v10 = v7 + 32;
        if ( (unsigned int)(v7 - 65) > 0x19 )
          v10 = v7;
        v7 = v10;
        v11 = v9 + 32;
        if ( (unsigned int)(v9 - 65) > 0x19 )
          v11 = v9;
        if ( v7 != v11 )
          break;
      }
      if ( !v7 )
        goto LABEL_23;
    }
    _RBX = DVARFLT_cl_transientWorldMemoryFreeMulMP;
    if ( DVARFLT_cl_transientWorldMemoryFreeMulMP )
      goto LABEL_27;
    v13 = "cl_transientWorldMemoryFreeMulMP";
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v13) )
      __debugbreak();
LABEL_27:
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
CL_TransientsWorldMP_GetXB3BudgetBytes
==============
*/
unsigned __int64 CL_TransientsWorldMP_GetXB3BudgetBytes()
{
  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    return 0i64;
  else
    return 419430400i64;
}

/*
==============
CL_TransientsWorldMP_GridContainsPos
==============
*/
__int64 CL_TransientsWorldMP_GridContainsPos(const vec3_t *pos, const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v9; 
  __int64 v10; 
  __int64 result; 
  __int64 v17; 
  __int64 v18; 

  _RBP = pos;
  if ( gridX >= tileMap->gridCountX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 785, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, tileMap->gridCountX) )
    __debugbreak();
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v18) = tileMap->gridCountY;
    LODWORD(v17) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 786, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v17, v18) )
      __debugbreak();
  }
  v9 = lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY);
  if ( (unsigned int)v9 >= tileMap->indexCount )
  {
    LODWORD(v18) = tileMap->indexCount;
    LODWORD(v17) = v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 789, ASSERT_TYPE_ASSERT, "(unsigned)( spaceIndex ) < (unsigned)( tileMap.indexCount )", "spaceIndex doesn't index tileMap.indexCount\n\t%i not in [0, %i)", v17, v18) )
      __debugbreak();
  }
  v10 = tileMap->spaceToTransientIndex[v9];
  if ( (unsigned int)v10 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 791, ASSERT_TYPE_ASSERT, "(transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
  _RBX = &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v10];
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 510, ASSERT_TYPE_ASSERT, "(bounds)", (const char *)&queryFormat, "bounds") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vsubss  xmm1, xmm0, dword ptr [rbx]
    vmovss  xmm2, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vandps  xmm1, xmm1, xmm2
  }
  result = 0i64;
  __asm { vcomiss xmm1, dword ptr [rbx+0Ch] }
  return result;
}

/*
==============
CL_TransientsWorldMP_HasGridStreamingCompletedForPosition
==============
*/
_BOOL8 CL_TransientsWorldMP_HasGridStreamingCompletedForPosition(const LocalClientNum_t localClientNum, const vec3_t *pos)
{
  bool v4; 

  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3557, ASSERT_TYPE_ASSERT, "(CL_TransientsWorldMP_IsActive())", (const char *)&queryFormat, "CL_TransientsWorldMP_IsActive()", -2i64) )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFF808080, "CL_TransientsWorldMP_HasGridStreamingCompletedForPosition");
  v4 = CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded(localClientNum, pos);
  Sys_ProfEndNamedEvent();
  return v4;
}

/*
==============
CL_TransientsWorldMP_HasLobbyStreamPositions
==============
*/
bool CL_TransientsWorldMP_HasLobbyStreamPositions()
{
  return s_transientsWorldMP.lobbyStreamPosCount != 0;
}

/*
==============
CL_TransientsWorldMP_IsActive
==============
*/
bool CL_TransientsWorldMP_IsActive()
{
  return s_transientsWorldMP.worldGridInfo != NULL;
}

/*
==============
CL_TransientsWorldMP_IsBRMode
==============
*/
_BOOL8 CL_TransientsWorldMP_IsBRMode()
{
  return s_transientsWorldMP.isBRMap;
}

/*
==============
CL_TransientsWorldMP_IsLOD0
==============
*/
bool CL_TransientsWorldMP_IsLOD0(unsigned int transientIndex)
{
  const TransientInfo *worldGridInfo; 

  if ( !transientIndex )
    return 0;
  worldGridInfo = s_transientsWorldMP.worldGridInfo;
  if ( !s_transientsWorldMP.worldGridInfo )
    return 0;
  if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
      __debugbreak();
    worldGridInfo = s_transientsWorldMP.worldGridInfo;
  }
  return transientIndex < (unsigned int)(worldGridInfo->transientWorldGridHighLodLookupCount / worldGridInfo->transientWorldGridHighLodCount);
}

/*
==============
CL_TransientsWorldMP_IsZoomLoadActive
==============
*/
char CL_TransientsWorldMP_IsZoomLoadActive(const LocalClientNum_t localClientNum)
{
  unsigned int numStreamPositions; 
  unsigned int v3; 
  __int64 v4; 
  unsigned int v6; 

  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions > 0xE )
  {
    v6 = s_transientsWorldMP.numStreamPositions;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3283, ASSERT_TYPE_ASSERT, "( s_transientsWorldMP.numStreamPositions <= ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "NumStreamPositions %u is out of range %zu", v6, 0xEui64) )
      __debugbreak();
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
  }
  v3 = 0;
  if ( !numStreamPositions )
    return 0;
  while ( 1 )
  {
    v4 = v3;
    if ( s_transientsWorldMP.streamPositions[v4].localClientIndex == localClientNum && s_transientsWorldMP.streamPositions[v4].zoomLoad )
      break;
    if ( ++v3 >= numStreamPositions )
      return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_LoadIndex
==============
*/
void CL_TransientsWorldMP_LoadIndex(const unsigned int worldIndex, const unsigned int priority)
{
  unsigned __int64 v3; 
  unsigned __int16 GridTransientMPIndex; 
  unsigned int v5; 
  unsigned int *v6; 
  __int64 v7; 
  __int64 v8; 

  v3 = worldIndex;
  GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(worldIndex);
  if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1808, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v7) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v7, 1536) )
      __debugbreak();
  }
  v5 = 0x80000000 >> (v3 & 0x1F);
  v6 = &s_transientsWorldMP.requested.array[v3 >> 5];
  if ( (v5 & *v6) != 0 )
  {
    CL_TransientsMP_SetLoadPriorityByFileIndex(GridTransientMPIndex, priority);
  }
  else
  {
    ++s_transientsWorldMP.requestedCount;
    if ( (unsigned int)v3 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v3, 1536) )
      __debugbreak();
    *v6 |= v5;
    CL_TransientsMP_LoadByFileIndex(GridTransientMPIndex, priority);
    TransientCostCalc_Load(&s_transientsWorldMP.worldCost, v3);
  }
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v8) = 1536;
    LODWORD(v7) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1826, ASSERT_TYPE_ASSERT, "(unsigned)( worldIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lastTrPriority ) ) + 0 ) )", "worldIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.lastTrPriority )\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  s_transientsWorldMP.lastTrPriority[v3] = priority;
}

/*
==============
CL_TransientsWorldMP_OnFirstSnapshot
==============
*/
void CL_TransientsWorldMP_OnFirstSnapshot(void)
{
  if ( s_transientsWorldMP.worldGridInfo && !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3703, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyToGameStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3705, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyToGameStart)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyToGameStart") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyPreloadStopped && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3706, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyPreloadStopped)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyPreloadStopped") )
    __debugbreak();
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3707, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.preloadingBackToFE)", (const char *)&queryFormat, "!s_transientsWorldMP.preloadingBackToFE") )
    __debugbreak();
  s_transientsWorldMP.inLobbyState = 0;
}

/*
==============
CL_TransientsWorldMP_OnFrontendPreload
==============
*/
void CL_TransientsWorldMP_OnFrontendPreload(void)
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned __int16 *transientToMPIndexMapping; 
  unsigned int v3; 
  unsigned __int64 v4; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3567, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( CL_PlayAgain_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3568, ASSERT_TYPE_ASSERT, "(!CL_PlayAgain_IsActive())", (const char *)&queryFormat, "!CL_PlayAgain_IsActive()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v0 = 0;
    v1 = 0i64;
    transientToMPIndexMapping = s_transientsWorldMP.transientToMPIndexMapping;
    do
    {
      if ( *transientToMPIndexMapping )
      {
        v3 = 0x80000000 >> (v0 & 0x1F);
        v4 = v1 >> 5;
        if ( (v3 & s_transientsWorldMP.requested.array[v4]) != 0 && (v3 & s_transientsWorldMP.loaded.array[v4]) == 0 )
          CL_TransientsWorldMP_UnloadIndex(v0);
      }
      ++v0;
      ++v1;
      ++transientToMPIndexMapping;
    }
    while ( v0 < 0x600 );
    s_transientsWorldMP.preloadingBackToFE = 1;
    CL_TransientsWorldMP_ProcessFastfiles();
  }
}

/*
==============
CL_TransientsWorldMP_OnLevelLoad
==============
*/
void CL_TransientsWorldMP_OnLevelLoad(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3668, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadAllowed
==============
*/
void CL_TransientsWorldMP_OnLevelPreloadAllowed(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3648, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.lobbyPreloadStopped = 0;
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadCancel
==============
*/
void CL_TransientsWorldMP_OnLevelPreloadCancel(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3657, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_CancelInFlightLoads();
  s_transientsWorldMP.lobbyPreloadStopped = 1;
}

/*
==============
CL_TransientsWorldMP_OnLevelUnload
==============
*/
void CL_TransientsWorldMP_OnLevelUnload(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3681, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.systemEnabled = 0;
  CL_TransientsWorldMP_ClearLoadState();
}

/*
==============
CL_TransientsWorldMP_OnLobbyToGameStart
==============
*/
void CL_TransientsWorldMP_OnLobbyToGameStart(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3631, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
  CL_TransientsWorldMP_CancelInFlightLoads();
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 1;
}

/*
==============
CL_TransientsWorldMP_OnPlayAgainRestart
==============
*/
void CL_TransientsWorldMP_OnPlayAgainRestart(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3715, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo && !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3719, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyToGameStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3721, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyToGameStart)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyToGameStart") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyPreloadStopped && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3722, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyPreloadStopped)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyPreloadStopped") )
    __debugbreak();
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3723, ASSERT_TYPE_ASSERT, "( !s_transientsWorldMP.preloadingBackToFE )", "If this fires, you need to unload the preloaded UI+Frontend fastfiles, before we playagain.") )
    __debugbreak();
  CL_TransientsWorldMP_ClearVisibilityState();
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  cs:s_transientsWorldMP.radiusMultiplier, xmm0
  }
  s_transientsWorldMP.numStreamPositions = 0;
  s_transientsWorldMP.inLobbyState = 1;
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
}

/*
==============
CL_TransientsWorldMP_OnServerShutdown
==============
*/
void CL_TransientsWorldMP_OnServerShutdown(void)
{
  if ( !Sys_IsServerThread() && !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3693, ASSERT_TYPE_ASSERT, "(Sys_IsServerThread() || Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsServerThread() || Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 0;
}

/*
==============
CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading
==============
*/
void CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1927, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !s_transientsWorldMP.systemEnabled && s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1930, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName != nullptr)", (const char *)&queryFormat, "s_transientsWorldMP.mapName != nullptr") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  cs:s_transientsWorldMP.radiusMultiplier, xmm0
    }
    s_transientsWorldMP.systemEnabled = 1;
    s_transientsWorldMP.numStreamPositions = 0;
  }
}

/*
==============
CL_TransientsWorldMP_ProcessFastfiles
==============
*/
void CL_TransientsWorldMP_ProcessFastfiles(void)
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 
  unsigned int *v4; 
  unsigned __int16 GridTransientMPIndex; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3098, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_ProcessFastfiles");
  if ( !s_transientsWorldMP.finishedLoading )
    s_transientsWorldMP.finishedLoading = DB_Zones_IsFinishedLoadingByIndex(s_transientsWorldMP.zoneIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    if ( !r_lockPvs->current.enabled )
    {
      CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions();
      Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_CheckForLoadCompletion");
      v0 = 0;
      v1 = 0i64;
      do
      {
        v2 = 0x80000000 >> (v0 & 0x1F);
        v3 = v1 >> 5;
        v4 = &s_transientsWorldMP.loaded.array[v3];
        if ( (v2 & *v4) == 0 && (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
        {
          GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(v0);
          if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2934, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
            __debugbreak();
          if ( CL_TransientsMP_IsLoadedByFileIndex(GridTransientMPIndex) )
            *v4 |= v2;
        }
        ++v0;
        ++v1;
      }
      while ( v0 < 0x600 );
      Sys_ProfEndNamedEvent();
      if ( s_transientsWorldMP.numStreamPositions )
        CL_TransientsWorldMP_UpdateAllVisibility();
    }
    CL_TransientsWorldMP_UpdateIgnoreTransientSkip();
    if ( s_transientsWorldMP.anyMissingModelsDirty )
      CL_TransientsWorldMP_UpdateMissingModels();
    TransientCostCalc_ValidateUsage(&s_transientsWorldMP.worldCost);
    CL_TransientsWorldMP_SoakTestUpdate();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_RegisterFileIndex
==============
*/
void CL_TransientsWorldMP_RegisterFileIndex(unsigned __int16 mpSystemFileIndex, const char *name)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  unsigned int v8; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2141, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2142, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( mpSystemFileIndex == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2143, ASSERT_TYPE_ASSERT, "(mpSystemFileIndex != 0xffff)", (const char *)&queryFormat, "mpSystemFileIndex != USHRT_MAX") )
    __debugbreak();
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2144, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2145, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName)", (const char *)&queryFormat, "s_transientsWorldMP.mapName") )
    __debugbreak();
  v4 = -1i64;
  v5 = -1i64;
  do
    ++v5;
  while ( s_transientsWorldMP.mapName[v5] );
  do
    ++v4;
  while ( name[v4] );
  if ( (unsigned int)v4 <= (int)v5 + 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2148, ASSERT_TYPE_ASSERT, "( ( I_strlen( name ) > ( mapNameLen + CHARS_AFTER_MAPNAME ) ) )", "( name ) = %s", name) )
    __debugbreak();
  if ( j_sscanf_s(&name[(unsigned int)v5 + 1], "%05u_tr", &v8) != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2155, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Transient world file '%s' doesn't match our '%s' format", name, "%s_%05u_tr") )
    __debugbreak();
  if ( v8 >= 0x600 )
  {
    LODWORD(v7) = 1536;
    LODWORD(v6) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2158, ASSERT_TYPE_ASSERT, "(unsigned)( savedTransientIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientToMPIndexMapping ) ) + 0 ) )", "savedTransientIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientToMPIndexMapping )\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( s_transientsWorldMP.transientToMPIndexMapping[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2159, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.transientToMPIndexMapping[savedTransientIndex] == MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "s_transientsWorldMP.transientToMPIndexMapping[savedTransientIndex] == MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  s_transientsWorldMP.transientToMPIndexMapping[v8] = mpSystemFileIndex;
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfo
==============
*/
void CL_TransientsWorldMP_RegisterGridStreamingInfo(const char *name, const TransientInfo *transientInfo)
{
  __int64 v5; 
  bitarray<1536> *p_transientsHighestLOD; 
  __int64 v7; 
  bitarray<1536> *p_transientsBaseLOD; 
  __int64 v9; 
  bitarray<1536> *p_missingModelTransients; 
  unsigned int *v11; 
  __int64 v12; 
  int ZoneIndexFromName; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1956, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1957, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1958, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1960, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == nullptr)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == nullptr") )
    __debugbreak();
  s_transientsWorldMP.worldGridInfo = transientInfo;
  s_transientsWorldMP.mapName = name;
  if ( s_transientsWorldMP.isLowFlaggingMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1964, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isLowFlaggingMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isLowFlaggingMap == false") )
    __debugbreak();
  s_transientsWorldMP.isLowFlaggingMap = (transientInfo->transientInfoFlags & 2) != 0;
  if ( s_transientsWorldMP.isBRMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1967, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isBRMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isBRMap == false") )
    __debugbreak();
  s_transientsWorldMP.isBRMap = (transientInfo->transientInfoFlags & 4) != 0;
  if ( s_transientsWorldMP.isAlwaysloadedTRWorldMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1970, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isAlwaysloadedTRWorldMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isAlwaysloadedTRWorldMap == false") )
    __debugbreak();
  s_transientsWorldMP.isAlwaysloadedTRWorldMap = (transientInfo->transientInfoFlags & 8) != 0;
  if ( s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1974, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "!s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  CL_TransientsWorldMP_ClearLoadState();
  memset_0(s_transientsWorldMP.transientToMPIndexMapping, 0, sizeof(s_transientsWorldMP.transientToMPIndexMapping));
  __asm { vmovss  xmm0, cs:__real@7f7fffff }
  s_transientsWorldMP.tileBudget = 0i64;
  __asm { vmovss  cs:s_transientsWorldMP.lod1FalloffBeginSq, xmm0 }
  s_transientsWorldMP.preloadingBackToFE = 0;
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
  TransientCostCalc_Init(&s_transientsWorldMP.worldCost, &transientInfo->transientCosts);
  v5 = 3i64;
  p_transientsHighestLOD = &s_transientsWorldMP.transientsHighestLOD;
  v7 = 3i64;
  do
  {
    *(_QWORD *)p_transientsHighestLOD->array = 0i64;
    *(_QWORD *)&p_transientsHighestLOD->array[2] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD->array[4] = 0i64;
    p_transientsHighestLOD = (bitarray<1536> *)((char *)p_transientsHighestLOD + 64);
    *(_QWORD *)&p_transientsHighestLOD[-1].array[38] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[40] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[42] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[44] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[46] = 0i64;
    --v7;
  }
  while ( v7 );
  p_transientsBaseLOD = &s_transientsWorldMP.transientsBaseLOD;
  v9 = 3i64;
  do
  {
    *(_QWORD *)p_transientsBaseLOD->array = 0i64;
    *(_QWORD *)&p_transientsBaseLOD->array[2] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD->array[4] = 0i64;
    p_transientsBaseLOD = (bitarray<1536> *)((char *)p_transientsBaseLOD + 64);
    *(_QWORD *)&p_transientsBaseLOD[-1].array[38] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[40] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[42] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[44] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[46] = 0i64;
    --v9;
  }
  while ( v9 );
  memset_0(s_transientsWorldMP.transientLODIndex, 0, sizeof(s_transientsWorldMP.transientLODIndex));
  memset_0(s_transientsWorldMP.baseLODIndex, 0, sizeof(s_transientsWorldMP.baseLODIndex));
  *(_QWORD *)&s_transientsWorldMP.fileBackedTransientCount = 0i64;
  *(_DWORD *)s_transientsWorldMP.lodFileCount = 0;
  s_transientsWorldMP.lodFileCount[2] = 0;
  s_transientsWorldMP.ignoreTransientSkip = 0;
  memset_0(s_transientsWorldMP.debugProxyModelIndex, 255, sizeof(s_transientsWorldMP.debugProxyModelIndex));
  p_missingModelTransients = &s_transientsWorldMP.missingModelTransients;
  do
  {
    *(_QWORD *)p_missingModelTransients->array = 0i64;
    *(_QWORD *)&p_missingModelTransients->array[2] = 0i64;
    *(_QWORD *)&p_missingModelTransients->array[4] = 0i64;
    p_missingModelTransients = (bitarray<1536> *)((char *)p_missingModelTransients + 64);
    *(_QWORD *)&p_missingModelTransients[-1].array[38] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[40] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[42] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[44] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[46] = 0i64;
    --v5;
  }
  while ( v5 );
  *(_WORD *)&s_transientsWorldMP.anyMissingModels = 256;
  memset_0(s_transientsWorldMP.streamSyncDraw, 0, sizeof(s_transientsWorldMP.streamSyncDraw));
  if ( SLODWORD(cl_maxLocalClients) > 0 )
  {
    v11 = &s_transientsWorldMP.visibleCurrent[0].array[2];
    v12 = LODWORD(cl_maxLocalClients);
    do
    {
      *(v11 - 2) = s_transientsWorldMP.transientsHighestLOD.array[0];
      *(v11 - 1) = s_transientsWorldMP.transientsHighestLOD.array[1];
      *v11 = s_transientsWorldMP.transientsHighestLOD.array[2];
      v11[1] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v11[2] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v11[3] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v11[4] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v11[5] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v11[6] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v11[7] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v11[8] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v11[9] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v11[10] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v11[11] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v11[12] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v11[13] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v11[14] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v11[15] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v11[16] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v11[17] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v11[18] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v11[19] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v11[20] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v11[21] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v11[22] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v11[23] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v11[24] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v11[25] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v11[26] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v11[27] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v11[28] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v11[29] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v11[30] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v11[31] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v11[32] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v11[33] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v11[34] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v11[35] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v11[36] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v11[37] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v11[38] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v11[39] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v11[40] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v11[41] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v11[42] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v11[43] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v11[44] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v11[45] = s_transientsWorldMP.transientsHighestLOD.array[47];
      v11[94] = s_transientsWorldMP.transientsHighestLOD.array[0];
      v11[95] = s_transientsWorldMP.transientsHighestLOD.array[1];
      v11[96] = s_transientsWorldMP.transientsHighestLOD.array[2];
      v11[97] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v11[98] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v11[99] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v11[100] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v11[101] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v11[102] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v11[103] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v11[104] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v11[105] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v11[106] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v11[107] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v11[108] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v11[109] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v11[110] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v11[111] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v11[112] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v11[113] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v11[114] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v11[115] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v11[116] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v11[117] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v11[118] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v11[119] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v11[120] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v11[121] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v11[122] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v11[123] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v11[124] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v11[125] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v11[126] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v11[127] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v11[128] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v11[129] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v11[130] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v11[131] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v11[132] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v11[133] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v11[134] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v11[135] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v11[136] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v11[137] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v11[138] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v11[139] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v11[140] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v11[141] = s_transientsWorldMP.transientsHighestLOD.array[47];
      v11[190] = s_transientsWorldMP.transientsHighestLOD.array[0];
      v11[191] = s_transientsWorldMP.transientsHighestLOD.array[1];
      v11[192] = s_transientsWorldMP.transientsHighestLOD.array[2];
      v11[193] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v11[194] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v11[195] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v11[196] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v11[197] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v11[198] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v11[199] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v11[200] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v11[201] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v11[202] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v11[203] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v11[204] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v11[205] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v11[206] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v11[207] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v11[208] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v11[209] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v11[210] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v11[211] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v11[212] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v11[213] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v11[214] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v11[215] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v11 += 48;
      v11[168] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v11[169] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v11[170] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v11[171] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v11[172] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v11[173] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v11[174] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v11[175] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v11[176] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v11[177] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v11[178] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v11[179] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v11[180] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v11[181] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v11[182] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v11[183] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v11[184] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v11[185] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v11[186] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v11[187] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v11[188] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v11[189] = s_transientsWorldMP.transientsHighestLOD.array[47];
      --v12;
    }
    while ( v12 );
  }
  ZoneIndexFromName = DB_Zones_GetZoneIndexFromName(s_transientsWorldMP.mapName);
  s_transientsWorldMP.zoneIndex = ZoneIndexFromName;
  if ( ZoneIndexFromName == 0xFFFF )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2013, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != INVALID_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != INVALID_ZONE_INDEX") )
      __debugbreak();
    ZoneIndexFromName = s_transientsWorldMP.zoneIndex;
  }
  if ( !ZoneIndexFromName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2014, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX") )
    __debugbreak();
  s_transientsWorldMP.streamProgressCurrentFrame = 0;
  memset_0(s_transientsWorldMP.streamProgressStartTime, 0, sizeof(s_transientsWorldMP.streamProgressStartTime));
  memset_0(s_transientsWorldMP.streamProgressStartFrame, 0, sizeof(s_transientsWorldMP.streamProgressStartFrame));
  memset_0(s_transientsWorldMP.streamProgressTextureState, 0, sizeof(s_transientsWorldMP.streamProgressTextureState));
  *(_WORD *)&s_transientsWorldMP.inLobbyState = 1;
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles
==============
*/
void CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles(const char *name, const TransientInfo *transientInfo)
{
  unsigned int transientWorldGridHighLodCount; 
  unsigned int v5; 
  unsigned __int64 v6; 
  unsigned int v7; 
  unsigned __int64 v8; 
  unsigned int fileBackedTransientMax; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned __int16 *transientWorldGridHighLodLookup; 
  __int64 v14; 
  unsigned int v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  unsigned int v21; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2030, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2031, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2032, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo != transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2034, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == transientInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.mapName != name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2035, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName == name)", (const char *)&queryFormat, "s_transientsWorldMP.mapName == name") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2037, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount == 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount == 0") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2038, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientMax == 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientMax == 0") )
    __debugbreak();
  transientWorldGridHighLodCount = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  v20 = transientWorldGridHighLodCount;
  if ( transientWorldGridHighLodCount )
  {
    if ( transientWorldGridHighLodCount != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2043, ASSERT_TYPE_ASSERT, "( highLODCount ) == ( STREAMINGINFO_WORLD_LOD_COUNT - 1 )", "%s == %s\n\t%i, %i", "highLODCount", "STREAMINGINFO_WORLD_LOD_COUNT - 1", s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount, 2) )
      __debugbreak();
    v5 = 0;
    v21 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / transientWorldGridHighLodCount;
    if ( v21 )
    {
      v6 = 0i64;
      do
      {
        v7 = v5 + 1;
        v8 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup[transientWorldGridHighLodCount * (v5 + 1) - 1];
        if ( v5 >= 0x600 )
        {
          LODWORD(v19) = 1536;
          LODWORD(v18) = v5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
            __debugbreak();
        }
        s_transientsWorldMP.transientsBaseLOD.array[v6 >> 5] |= 0x80000000 >> (v5 & 0x1F);
        if ( (unsigned int)v8 >= 0x600 )
        {
          LODWORD(v19) = 1536;
          LODWORD(v18) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
            __debugbreak();
        }
        s_transientsWorldMP.transientsHighestLOD.array[v8 >> 5] |= 0x80000000 >> (v8 & 0x1F);
        s_transientsWorldMP.transientLODIndex[v6] = 0;
        if ( v5 )
        {
          if ( v5 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
          {
            LODWORD(v17) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
            LODWORD(v16) = v5;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2057, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "entryIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v16, v17) )
              __debugbreak();
          }
          if ( (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v5) )
          {
            fileBackedTransientMax = v5 + 1;
            if ( s_transientsWorldMP.fileBackedTransientMax > v7 )
              fileBackedTransientMax = s_transientsWorldMP.fileBackedTransientMax;
            s_transientsWorldMP.fileBackedTransientMax = fileBackedTransientMax;
            if ( s_transientsWorldMP.ignoreTransientSkip || v5 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v5) )
            {
              s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v5);
              ++s_transientsWorldMP.lodFileCount[0];
            }
          }
          if ( transientWorldGridHighLodCount != 1 )
          {
            v10 = transientWorldGridHighLodCount - 1;
            v11 = 1;
            do
            {
              v12 = transientWorldGridHighLodCount * v5 + v11 - 1;
              transientWorldGridHighLodLookup = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup;
              v14 = transientWorldGridHighLodLookup[v12];
              if ( transientWorldGridHighLodLookup[v12] )
              {
                if ( (unsigned int)v14 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
                {
                  LODWORD(v17) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
                  LODWORD(v16) = transientWorldGridHighLodLookup[v12];
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2078, ASSERT_TYPE_ASSERT, "(unsigned)( highLODTransient ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "highLODTransient doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v16, v17) )
                    __debugbreak();
                }
                if ( v11 > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)v11, "unsigned", v11) )
                  __debugbreak();
                s_transientsWorldMP.transientLODIndex[v14] = v11;
                if ( v5 > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)v5, "unsigned", v6) )
                  __debugbreak();
                s_transientsWorldMP.baseLODIndex[v14] = v5;
                if ( (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v14) )
                {
                  v15 = v14 + 1;
                  if ( s_transientsWorldMP.fileBackedTransientMax > (unsigned int)(v14 + 1) )
                    v15 = s_transientsWorldMP.fileBackedTransientMax;
                  s_transientsWorldMP.fileBackedTransientMax = v15;
                  if ( s_transientsWorldMP.ignoreTransientSkip || (unsigned int)v14 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v14) )
                  {
                    s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v14);
                    if ( v11 >= 3 )
                    {
                      LODWORD(v17) = 3;
                      LODWORD(v16) = v11;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2091, ASSERT_TYPE_ASSERT, "(unsigned)( highLODNum + 1 ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lodFileCount ) ) + 0 ) )", "highLODNum + 1 doesn't index s_transientsWorldMP.lodFileCount\n\t%i not in [0, %i)", v16, v17) )
                        __debugbreak();
                    }
                    ++s_transientsWorldMP.lodFileCount[v11];
                  }
                }
              }
              ++v11;
              --v10;
            }
            while ( v10 );
            transientWorldGridHighLodCount = v20;
            v7 = v5 + 1;
          }
        }
        ++v6;
        v5 = v7;
      }
      while ( v7 < v21 );
    }
  }
  if ( s_transientsWorldMP.fileBackedTransientCount > s_transientsWorldMP.fileBackedTransientMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2102, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount <= s_transientsWorldMP.fileBackedTransientMax)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount <= s_transientsWorldMP.fileBackedTransientMax") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientMax > s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2103, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientMax <= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientMax <= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
}

/*
==============
CL_TransientsWorldMP_ResetGridStreaming
==============
*/
void CL_TransientsWorldMP_ResetGridStreaming(bool useSplitscreenRadius)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3148, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) )
  {
    if ( s_transientsWorldMP.worldGridInfo )
    {
      if ( s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
      {
        s_transientsWorldMP.numStreamPositions = 0;
        __asm
        {
          vmovss  xmm0, cs:__real@3f800000
          vmovss  cs:s_transientsWorldMP.radiusMultiplier, xmm0
        }
        if ( useSplitscreenRadius )
        {
          _RBX = DCONST_DVARFLT_cl_transientWorldVisibleSplit2Multiplier;
          if ( !DCONST_DVARFLT_cl_transientWorldVisibleSplit2Multiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleSplit2Multiplier") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(_RBX);
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+28h]
            vmovss  cs:s_transientsWorldMP.radiusMultiplier, xmm0
          }
        }
      }
    }
  }
}

/*
==============
CL_TransientsWorldMP_ResetLobbyStreamPositions
==============
*/
void CL_TransientsWorldMP_ResetLobbyStreamPositions(void)
{
  s_transientsWorldMP.lobbyStreamPosCount = 0;
}

/*
==============
CL_TransientsWorldMP_SetGridStreamingClientStreamViews
==============
*/
void CL_TransientsWorldMP_SetGridStreamingClientStreamViews(LocalClientNum_t localClientNum)
{
  LocalClientNum_t v4; 
  unsigned __int64 v5; 
  const dvar_t *v7; 
  const dvar_t *v8; 
  unsigned __int8 v10; 
  char v12; 
  const vec3_t *ManualViewVelocity; 
  bool ManualViewStreamRender; 
  const vec3_t *ManualViewAngles; 
  const vec3_t *ManualViewOrigin; 
  __int64 v18; 
  BgWorldStreamingViewMode ManualViewMode; 
  const dvar_t *v20; 
  unsigned int numStreamPositions; 
  __int64 v22; 
  __int64 v23; 
  unsigned __int64 v24; 
  bool *p_streamRender; 
  const dvar_t *v26; 
  __int64 v29; 
  const dvar_t *v33; 
  int v34; 
  __int64 mainCamera; 
  __int64 nextCamera; 
  float v41; 
  _BYTE v42[128]; 
  int v45; 
  unsigned __int64 v49; 

  v4 = localClientNum;
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3338, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v5 = 0i64;
    __asm
    {
      vmovaps [rsp+138h+var_58], xmm7
      vmovaps [rsp+138h+var_48], xmm6
    }
    v49 = 0i64;
    __asm { vxorps  xmm7, xmm7, xmm7 }
    do
    {
      if ( CL_StreamViews_IsManualViewSet((StreamManualViewType)v5, v4) )
      {
        v7 = DCONST_DVARBOOL_cl_transientWorldIgnoreStreamHints;
        if ( !DCONST_DVARBOOL_cl_transientWorldIgnoreStreamHints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldIgnoreStreamHints") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v7);
        if ( !v7->current.enabled || !(_DWORD)v5 )
        {
          v8 = DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled;
          __asm { vmovaps xmm6, xmm7 }
          if ( !DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistEnabled") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v8);
          if ( v8->current.enabled )
          {
            v10 = CG_WorldStreaming_ConvertManualViewTypeToViewType((const StreamManualViewType)v5);
            *(double *)&_XMM0 = CG_WorldStreaming_GetLoadDist(v4, (const BgWorldStreamingViewType)v10);
            _RBX = DCONST_DVARFLT_cl_transientWorldLoadDistForceValue;
            __asm { vmovaps xmm6, xmm0 }
            if ( !DCONST_DVARFLT_cl_transientWorldLoadDistForceValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistForceValue") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(_RBX);
            __asm { vucomiss xmm7, dword ptr [rbx+28h] }
            if ( !v12 )
            {
              _RBX = DCONST_DVARFLT_cl_transientWorldLoadDistForceValue;
              if ( !DCONST_DVARFLT_cl_transientWorldLoadDistForceValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistForceValue") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(_RBX);
              __asm { vmovss  xmm6, dword ptr [rbx+28h] }
            }
          }
          ManualViewVelocity = CL_StreamViews_GetManualViewVelocity((StreamManualViewType)v5, v4);
          ManualViewStreamRender = CL_StreamViews_GetManualViewStreamRender((StreamManualViewType)v5, v4);
          ManualViewAngles = CL_StreamViews_GetManualViewAngles((StreamManualViewType)v5, v4);
          ManualViewOrigin = CL_StreamViews_GetManualViewOrigin((StreamManualViewType)v5, v4);
          __asm { vmovss  [rsp+138h+var_100], xmm6 }
          v18 = (unsigned int)CL_TransientsWorldMP_AddGridStreamingPosInternal(v4, ManualViewOrigin, ManualViewAngles, ManualViewStreamRender, ManualViewVelocity, (_DWORD)v5 == 0, (_DWORD)v5 == 2, v41);
          ManualViewMode = CL_StreamViews_GetManualViewMode((StreamManualViewType)v5, v4);
          if ( (_DWORD)v5 && ManualViewMode == EASE_OUT_QUAD )
          {
            v20 = DVARBOOL_cl_transientWorldFallingHintEnabled;
            if ( !DVARBOOL_cl_transientWorldFallingHintEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldFallingHintEnabled") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v20);
            if ( v20->current.enabled )
            {
              numStreamPositions = s_transientsWorldMP.numStreamPositions;
              v22 = v18;
              v23 = v18;
              v24 = 0i64;
              if ( s_transientsWorldMP.numStreamPositions )
              {
                p_streamRender = &s_transientsWorldMP.streamPositions[0].streamRender;
                do
                {
                  if ( *((_DWORD *)p_streamRender - 26) == s_transientsWorldMP.streamPositions[v23].localClientIndex && *p_streamRender )
                  {
                    if ( v24 == v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3394, ASSERT_TYPE_ASSERT, "(baseIndex != index)", (const char *)&queryFormat, "baseIndex != index") )
                      __debugbreak();
                    p_streamRender[5] = 1;
                    numStreamPositions = s_transientsWorldMP.numStreamPositions;
                  }
                  ++v24;
                  p_streamRender += 156;
                }
                while ( v24 < numStreamPositions );
                v5 = v49;
                v4 = localClientNum;
              }
            }
          }
        }
      }
      v49 = ++v5;
    }
    while ( v5 < 5 );
    v26 = DCONST_DVARBOOL_cl_transientWorldDebugHintPosActive;
    __asm
    {
      vmovaps xmm7, [rsp+138h+var_58]
      vmovaps xmm6, [rsp+138h+var_48]
    }
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugHintPosActive && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugHintPosActive") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v26);
    if ( v26->current.enabled )
    {
      v29 = s_transientsWorldMP.numStreamPositions;
      if ( s_transientsWorldMP.numStreamPositions >= 0xE )
      {
        LODWORD(nextCamera) = 14;
        LODWORD(mainCamera) = s_transientsWorldMP.numStreamPositions;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3407, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", mainCamera, nextCamera) )
          __debugbreak();
        v29 = s_transientsWorldMP.numStreamPositions;
      }
      _RBX = &s_transientsWorldMP.streamPositions[v29];
      memset_0(v42, 0, 0x9Cui64);
      __asm
      {
        vmovups ymm0, [rsp+138h+var_F8]
        vmovups ymm1, [rsp+138h+var_D8]
      }
      v33 = DCONST_DVARVEC3_cl_transientWorldDebugHintPos;
      v34 = v45;
      __asm
      {
        vmovups ymmword ptr [rbx], ymm0
        vmovups ymm0, [rsp+138h+var_B8]
        vmovups ymmword ptr [rbx+20h], ymm1
        vmovups ymm1, [rsp+138h+var_98]
        vmovups ymmword ptr [rbx+40h], ymm0
        vmovups xmm0, [rsp+138h+var_78]
        vmovups ymmword ptr [rbx+60h], ymm1
        vmovsd  xmm1, [rsp+138h+var_68]
        vmovups xmmword ptr [rbx+80h], xmm0
        vmovsd  qword ptr [rbx+90h], xmm1
      }
      *(_DWORD *)&_RBX->zoomLoad = v34;
      if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugHintPos") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v33);
      LODWORD(_RBX->pos.v[0]) = v33->current.integer;
      _RBX->pos.v[1] = v33->current.vector.v[1];
      _RBX->pos.v[2] = v33->current.vector.v[2];
      ++s_transientsWorldMP.numStreamPositions;
    }
  }
}

/*
==============
CL_TransientsWorldMP_ShouldDrawCellIndexLabel
==============
*/
char CL_TransientsWorldMP_ShouldDrawCellIndexLabel(const unsigned __int16 transientIndex)
{
  const dvar_t *v1; 
  const dvar_t *v3; 
  __int64 v4; 

  v1 = DVARBOOL_cl_transientWorldOverlayTransientIndex;
  if ( !DVARBOOL_cl_transientWorldOverlayTransientIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayTransientIndex") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( !v1->current.enabled || !transientIndex || !s_transientsWorldMP.ignoreTransientSkip && transientIndex < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, transientIndex) )
    return 0;
  v3 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawAllCellNumbers;
  if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawAllCellNumbers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawAllCellNumbers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled && !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues, "cl_transientWorldOverlayDrawDelayValues") )
  {
    if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers, "cl_transientWorldOverlayDrawCellNumbers") && bitarray_base<bitarray<1536>>::testBit(&s_transientsWorldMP.requested, transientIndex) )
    {
      v4 = 0i64;
      while ( !bitarray_base<bitarray<1536>>::testBit(&s_transientsWorldMP.visibleCurrent[v4], transientIndex) )
      {
        v4 = (unsigned int)(v4 + 1);
        if ( (unsigned int)v4 >= 2 )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_SoakTestUpdate
==============
*/

void __fastcall CL_TransientsWorldMP_SoakTestUpdate(double _XMM0_8)
{
  const dvar_t *v1; 
  unsigned int soakCurTileIndex; 
  unsigned __int64 v4; 
  bool v5; 
  __int64 v6; 
  unsigned int v12; 
  __int64 v13; 
  int v14; 
  unsigned int v15; 
  char *fmt; 
  __int64 v26; 
  __int64 v27; 
  char dest[128]; 

  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v1 = DCONST_DVARBOOL_cl_transientWorldSoakTest;
    if ( !DCONST_DVARBOOL_cl_transientWorldSoakTest && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSoakTest") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v1);
    if ( v1->current.enabled )
    {
      if ( s_transientsWorldMP.inSoakTest )
      {
        soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
      }
      else
      {
        Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, "ufo on\n", 1, 0);
        soakCurTileIndex = 0;
        s_transientsWorldMP.inSoakTest = 1;
        *(_QWORD *)&s_transientsWorldMP.soakCurTileIndex = 0i64;
        s_transientsWorldMP.soakLastTime = __rdtsc();
      }
      if ( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
      {
        if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridBounds )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3048, ASSERT_TYPE_ASSERT, "(cellBounds)", (const char *)&queryFormat, "cellBounds") )
            __debugbreak();
          soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
        }
        v4 = __rdtsc();
        v5 = v4 < s_transientsWorldMP.soakLastTime;
        v6 = v4 - s_transientsWorldMP.soakLastTime;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2sd xmm0, xmm0, rax
        }
        if ( v6 < 0 )
          __asm { vaddsd  xmm0, xmm0, cs:__real@43f0000000000000 }
        __asm
        {
          vmulsd  xmm1, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2sd xmm0, xmm0, rcx
          vcomisd xmm1, xmm0
        }
        if ( !v5 && v6 != 0 )
        {
          v12 = s_transientsWorldMP.lodFileCount[0];
          v13 = 0i64;
          v14 = 0;
          s_transientsWorldMP.soakLastTime = __rdtsc();
          if ( s_transientsWorldMP.lodFileCount[0] )
          {
            while ( 1 )
            {
              v15 = soakCurTileIndex + 1;
              s_transientsWorldMP.soakCurTileIndex = v15;
              if ( v15 == v12 )
              {
                v15 = 0;
                s_transientsWorldMP.soakCurTileIndex = 0;
                s_transientsWorldMP.soakPhase = (s_transientsWorldMP.soakPhase + 1) % 3ui64;
              }
              v13 = v15 + 1;
              if ( (unsigned int)v13 >= 0x600 )
              {
                LODWORD(v27) = 1536;
                LODWORD(v26) = v15 + 1;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3071, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientLODIndex ) ) + 0 ) )", "trIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientLODIndex )\n\t%i not in [0, %i)", v26, v27) )
                  __debugbreak();
              }
              if ( (unsigned int)v13 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
              {
                LODWORD(v27) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
                LODWORD(v26) = v13;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3072, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "trIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v26, v27) )
                  __debugbreak();
              }
              if ( (unsigned int)v13 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
                break;
              if ( !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v13) )
                break;
              if ( ++v14 >= v12 )
                break;
              soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
            }
          }
          _RCX = 3 * v13;
          __asm
          {
            vmovss  xmm3, dword ptr [rbp+rcx*8+4]
            vmovss  xmm2, dword ptr [rbp+rcx*8+0]
            vmovss  xmm0, dword ptr [rbp+rcx*8+8]
            vcvtss2sd xmm3, xmm3, xmm3
            vcvtss2sd xmm2, xmm2, xmm2
            vcvtss2sd xmm0, xmm0, xmm0
            vmovq   r9, xmm3
            vmovq   r8, xmm2
            vmovsd  [rsp+0F8h+fmt], xmm0
          }
          Com_sprintf<128>((char (*)[128])dest, "setviewpos %.2f %.2f %.2f 0\n", *(double *)&_XMM2, *(double *)&_XMM3, *(double *)&fmt);
          Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, dest, 1, 0);
        }
      }
    }
    else if ( s_transientsWorldMP.inSoakTest )
    {
      Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, "ufo off\n", 1, 0);
      s_transientsWorldMP.inSoakTest = 0;
    }
  }
}

/*
==============
CL_TransientsWorldMP_UnloadIndex
==============
*/
void CL_TransientsWorldMP_UnloadIndex(const unsigned int worldIndex)
{
  unsigned __int64 v1; 
  unsigned __int16 GridTransientMPIndex; 
  unsigned int v3; 
  unsigned __int64 v4; 
  int v5; 
  LocalClientNum_t v6; 
  unsigned int *v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 

  v1 = worldIndex;
  GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(worldIndex);
  if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1835, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    LODWORD(v8) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v8, 1536) )
      __debugbreak();
  }
  v3 = 0x80000000 >> (v1 & 0x1F);
  v4 = v1 >> 5;
  if ( (v3 & s_transientsWorldMP.requested.array[v4]) != 0 )
  {
    if ( !s_transientsWorldMP.requestedCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1839, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.requestedCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.requestedCount > 0") )
      __debugbreak();
    --s_transientsWorldMP.requestedCount;
    if ( (unsigned int)v1 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v1, 1536) )
      __debugbreak();
    v5 = ~v3;
    s_transientsWorldMP.requested.array[v4] &= v5;
    CL_TransientsMP_UnloadByFileIndex(GridTransientMPIndex);
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v10) = 1536;
      LODWORD(v9) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
        __debugbreak();
    }
    s_transientsWorldMP.loaded.array[v4] &= v5;
    TransientCostCalc_Unload(&s_transientsWorldMP.worldCost, v1);
    v6 = LOCAL_CLIENT_0;
    v7 = &s_transientsWorldMP.visibleTarget[0].array[v4];
    do
    {
      CL_TransientsWorld_SetVisibility(v6, v1, 0);
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      *(v7 - 96) &= v5;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      *v7 &= v5;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      v7[96] &= v5;
      ++v6;
      v7 += 48;
    }
    while ( (unsigned int)v6 < LOCAL_CLIENT_COUNT );
  }
}

/*
==============
CL_TransientsWorldMP_UnregisterGridStreamingInfo
==============
*/
void CL_TransientsWorldMP_UnregisterGridStreamingInfo(const TransientInfo *transientInfo)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2109, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2110, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo != transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2112, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == transientInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == transientInfo") )
    __debugbreak();
  *(_DWORD *)&s_transientsWorldMP.isLowFlaggingMap = 0x1000000;
  s_transientsWorldMP.worldGridInfo = NULL;
  s_transientsWorldMP.systemEnabled = 0;
  s_transientsWorldMP.mapName = NULL;
  s_transientsWorldMP.zoneIndex = 0;
  s_transientsWorldMP.finishedLoading = 0;
  s_transientsWorldMP.lobbyStreamPosCount = 0;
  *(_DWORD *)s_transientsWorldMP.lodFileCount = 0;
  s_transientsWorldMP.lodFileCount[2] = 0;
  memset_0(s_transientsWorldMP.lastTrPriority, 0, sizeof(s_transientsWorldMP.lastTrPriority));
  CL_TransientsWorldMP_ClearLoadState();
  memset_0(s_transientsWorldMP.transientToMPIndexMapping, 0, sizeof(s_transientsWorldMP.transientToMPIndexMapping));
  __asm
  {
    vmovss  xmm0, cs:__real@7f7fffff
    vmovss  cs:s_transientsWorldMP.lod1FalloffBeginSq, xmm0
  }
  s_transientsWorldMP.tileBudget = 0i64;
  s_transientsWorldMP.preloadingBackToFE = 0;
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
  CL_TransientsWorldMP_ClearVisibilityState();
  __asm { vmovss  xmm0, cs:__real@3f800000 }
  s_transientsWorldMP.numStreamPositions = 0;
  s_transientsWorldMP.listenServerStall = 0;
  __asm { vmovss  cs:s_transientsWorldMP.radiusMultiplier, xmm0 }
}

/*
==============
CL_TransientsWorldMP_UpdateAllVisibility
==============
*/
void CL_TransientsWorldMP_UpdateAllVisibility()
{
  bitarray<1536> *p_wantVisibleButNotLoaded; 
  __int64 v2; 
  __int64 v3; 
  bitarray<1536> *p_changedVisible; 
  int v6; 
  __int64 v9; 
  __int64 v10; 
  LocalClientNum_t v21; 
  __int64 v23; 
  __int64 v24; 
  __int64 v35; 
  __int128 v54[12]; 
  bitarray_base<bitarray<1536> > v55[200]; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateAllVisibility");
  _RDI = 0i64;
  p_wantVisibleButNotLoaded = &s_transientsWorldMP.wantVisibleButNotLoaded;
  v2 = 3i64;
  v3 = 3i64;
  do
  {
    *(_QWORD *)p_wantVisibleButNotLoaded->array = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded->array[2] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded->array[4] = 0i64;
    p_wantVisibleButNotLoaded = (bitarray<1536> *)((char *)p_wantVisibleButNotLoaded + 64);
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[38] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[40] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[42] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[44] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[46] = 0i64;
    --v3;
  }
  while ( v3 );
  if ( LODWORD(cl_maxLocalClients) )
  {
    bitarray_base<bitarray<1536>>::copyBitArray(v55, s_transientsWorldMP.visibleCurrent);
    _RBX = &s_transientsWorldMP.visibleCurrent[1].array[2];
    v6 = LODWORD(cl_maxLocalClients);
    if ( SLODWORD(cl_maxLocalClients) > 1 )
    {
      _RCX = &s_transientsWorldMP.visibleCurrent[1].array[2];
      _RDX = (char *)v54 - (char *)&s_transientsWorldMP.visibleCurrent[0].array[2];
      v9 = (unsigned int)(LODWORD(cl_maxLocalClients) - 1);
      do
      {
        v10 = 6i64;
        do
        {
          __asm
          {
            vmovd   xmm1, dword ptr [rcx-8]
            vpinsrd xmm1, xmm1, dword ptr [rcx-4], 1
            vpinsrd xmm1, xmm1, dword ptr [rcx], 2
            vpinsrd xmm1, xmm1, dword ptr [rcx+4], 3
            vpor    xmm1, xmm1, xmmword ptr [rdx+rcx]
            vmovdqu xmmword ptr [rdx+rcx], xmm1
            vmovd   xmm1, dword ptr [rcx+8]
            vpinsrd xmm1, xmm1, dword ptr [rcx+0Ch], 1
            vpinsrd xmm1, xmm1, dword ptr [rcx+10h], 2
            vpinsrd xmm1, xmm1, dword ptr [rcx+14h], 3
            vpor    xmm1, xmm1, xmmword ptr [rdx+rcx+10h]
            vmovdqu xmmword ptr [rdx+rcx+10h], xmm1
          }
          _RCX += 8;
          --v10;
        }
        while ( v10 );
        _RDX -= 192i64;
        --v9;
      }
      while ( v9 );
    }
    v21 = LOCAL_CLIENT_0;
    if ( v6 > 0 )
    {
      do
        CL_TransientsWorldMP_UpdateLocalClientVisibility(v21++);
      while ( v21 < SLODWORD(cl_maxLocalClients) );
    }
    bitarray_base<bitarray<1536>>::copyBitArray((bitarray_base<bitarray<1536> > *)v54, s_transientsWorldMP.visibleCurrent);
    if ( SLODWORD(cl_maxLocalClients) > 1 )
    {
      _RCX = (char *)v54 - (char *)&s_transientsWorldMP.visibleCurrent[0].array[2] - 192;
      v23 = (unsigned int)(LODWORD(cl_maxLocalClients) - 1);
      do
      {
        v24 = 6i64;
        do
        {
          __asm
          {
            vmovd   xmm1, dword ptr [rbx-8]
            vpinsrd xmm1, xmm1, dword ptr [rbx-4], 1
            vpinsrd xmm1, xmm1, dword ptr [rbx], 2
            vpinsrd xmm1, xmm1, dword ptr [rbx+4], 3
            vpor    xmm1, xmm1, xmmword ptr [rcx+rbx]
            vmovdqu xmmword ptr [rcx+rbx], xmm1
            vmovd   xmm1, dword ptr [rbx+8]
            vpinsrd xmm1, xmm1, dword ptr [rbx+0Ch], 1
            vpinsrd xmm1, xmm1, dword ptr [rbx+10h], 2
            vpinsrd xmm1, xmm1, dword ptr [rbx+14h], 3
            vpor    xmm1, xmm1, xmmword ptr [rcx+rbx+10h]
            vmovdqu xmmword ptr [rcx+rbx+10h], xmm1
          }
          _RBX += 8;
          --v24;
        }
        while ( v24 );
        _RCX -= 192i64;
        --v23;
      }
      while ( v23 );
    }
    bitarray_base<bitarray<1536>>::copyBitArray(&s_transientsWorldMP.changedVisible, v55);
    v35 = 3i64;
    _RCX = &s_transientsWorldMP;
    do
    {
      __asm
      {
        vmovdqu xmm1, [rsp+rdi+1C8h+var_198]
        vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AB0h]
        vmovdqu xmmword ptr [rdi+rcx+1AB0h], xmm1
        vmovdqu xmm1, [rsp+rdi+1C8h+var_188]
        vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AC0h]
        vmovdqu xmmword ptr [rdi+rcx+1AC0h], xmm1
        vmovdqu xmm1, [rsp+rdi+1C8h+var_178]
        vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AD0h]
        vmovdqu xmmword ptr [rdi+rcx+1AD0h], xmm1
        vmovdqu xmm1, [rsp+rdi+1C8h+var_168]
        vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AE0h]
        vmovdqu xmmword ptr [rdi+rcx+1AE0h], xmm1
      }
      _RDI += 64i64;
      --v35;
    }
    while ( v35 );
    _RAX = &s_transientsWorldMP.changedVisible.array[4];
    do
    {
      __asm
      {
        vmovdqu xmm1, xmmword ptr [rax+170h]
        vpand   xmm1, xmm1, xmmword ptr [rax-10h]
        vmovdqu xmmword ptr [rax-10h], xmm1
        vmovdqu xmm2, xmmword ptr [rax+180h]
        vpand   xmm1, xmm2, xmmword ptr [rax]
        vmovdqu xmmword ptr [rax], xmm1
        vmovdqu xmm1, xmmword ptr [rax+190h]
        vpand   xmm1, xmm1, xmmword ptr [rax+10h]
        vmovdqu xmmword ptr [rax+10h], xmm1
        vmovdqu xmm1, xmmword ptr [rax+1A0h]
        vpand   xmm1, xmm1, xmmword ptr [rax+20h]
        vmovdqu xmmword ptr [rax+20h], xmm1
      }
      _RAX += 16;
      --v2;
    }
    while ( v2 );
  }
  else
  {
    p_changedVisible = &s_transientsWorldMP.changedVisible;
    do
    {
      *(_QWORD *)p_changedVisible->array = 0i64;
      *(_QWORD *)&p_changedVisible->array[2] = 0i64;
      *(_QWORD *)&p_changedVisible->array[4] = 0i64;
      p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 64);
      *(_QWORD *)&p_changedVisible[-1].array[38] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[40] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[42] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[44] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[46] = 0i64;
      --v2;
    }
    while ( v2 );
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateIgnoreTransientSkip
==============
*/
void CL_TransientsWorldMP_UpdateIgnoreTransientSkip(void)
{
  const dvar_t *v0; 
  bool enabled; 
  unsigned int v2; 
  const TransientInfo *worldGridInfo; 
  unsigned int i; 
  const TransientInfo *v5; 
  unsigned int v6; 
  unsigned __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  __int64 v10; 

  v0 = DCONST_DVARBOOL_cl_transientWorldIgnoreTransientSkip;
  if ( !DCONST_DVARBOOL_cl_transientWorldIgnoreTransientSkip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldIgnoreTransientSkip") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  enabled = v0->current.enabled;
  if ( s_transientsWorldMP.ignoreTransientSkip != enabled )
  {
    v2 = 0;
    if ( enabled )
    {
      if ( s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
      {
        do
        {
          worldGridInfo = s_transientsWorldMP.worldGridInfo;
          if ( v2 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
          {
            LODWORD(v10) = s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount;
            LODWORD(v9) = v2;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v2 & 0x1F)) & worldGridInfo->transientSkipLoading.array[(unsigned __int64)v2 >> 5]) != 0 && (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v2) )
          {
            if ( s_transientsWorldMP.fileBackedTransientCount >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = s_transientsWorldMP.fileBackedTransientCount;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2961, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.fileBackedTransientCount ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "s_transientsWorldMP.fileBackedTransientCount doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v2);
          }
          ++v2;
        }
        while ( v2 < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount );
      }
    }
    else
    {
      for ( i = 0; i < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount; ++i )
      {
        v5 = s_transientsWorldMP.worldGridInfo;
        if ( i >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
        {
          LODWORD(v10) = s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount;
          LODWORD(v9) = i;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
            __debugbreak();
        }
        v6 = 0x80000000 >> (i & 0x1F);
        v7 = (unsigned __int64)i >> 5;
        if ( (v6 & v5->transientSkipLoading.array[v7]) != 0 && (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(i) )
        {
          if ( i >= 0x600 )
          {
            LODWORD(v10) = 1536;
            LODWORD(v9) = i;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
              __debugbreak();
          }
          if ( (v6 & s_transientsWorldMP.requested.array[v7]) != 0 )
            CL_TransientsWorldMP_UnloadIndex(i);
          v8 = 0;
          if ( !s_transientsWorldMP.fileBackedTransientCount )
            goto LABEL_37;
          while ( 1 )
          {
            if ( v8 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = v8;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2985, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "orderIndex doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            if ( s_transientsWorldMP.priorityOrder[v8] == i )
              break;
            if ( ++v8 >= s_transientsWorldMP.fileBackedTransientCount )
              goto LABEL_37;
          }
          if ( v8 >= s_transientsWorldMP.fileBackedTransientCount )
          {
LABEL_37:
            LODWORD(v10) = s_transientsWorldMP.fileBackedTransientCount;
            LODWORD(v9) = v8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2991, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( s_transientsWorldMP.fileBackedTransientCount )", "orderIndex doesn't index s_transientsWorldMP.fileBackedTransientCount\n\t%i not in [0, %i)", v9, v10) )
              __debugbreak();
          }
          if ( v8 < s_transientsWorldMP.fileBackedTransientCount - 1 )
          {
            if ( v8 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = v8;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2994, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "orderIndex doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            if ( s_transientsWorldMP.fileBackedTransientCount - 1 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = s_transientsWorldMP.fileBackedTransientCount - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2995, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.fileBackedTransientCount - 1 ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "s_transientsWorldMP.fileBackedTransientCount - 1 doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            s_transientsWorldMP.priorityOrder[v8] = s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount - 1];
          }
          if ( !s_transientsWorldMP.fileBackedTransientCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2999, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount > 0") )
            __debugbreak();
          --s_transientsWorldMP.fileBackedTransientCount;
        }
      }
    }
    s_transientsWorldMP.ignoreTransientSkip = enabled;
  }
}

/*
==============
CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions
==============
*/
void CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions()
{
  __int64 numStreamPositions; 
  __int64 v17; 
  char *v25; 
  const char *v37; 
  float *priorityDistXY; 
  __int64 v41; 
  __int64 v42; 
  float *v44; 
  __int64 v45; 
  float *priorityViewDot; 
  Bounds *transientWorldGridBounds; 
  unsigned int v51; 
  unsigned __int64 v52; 
  unsigned __int8 *transientLODIndex; 
  unsigned __int16 *baseLODIndex; 
  unsigned __int64 v68; 
  unsigned int v69; 
  int v70; 
  unsigned int *v71; 
  char v72; 
  char v74; 
  char v75; 
  bool v85; 
  bitarray<1536> *v86; 
  bool v99; 
  char v102; 
  const dvar_t *v105; 
  const dvar_t *v108; 
  bool lod1BoostBRMethod; 
  int v117; 
  unsigned int v118; 
  unsigned __int64 v119; 
  unsigned __int16 *transientToMPIndexMapping; 
  unsigned int v121; 
  int v122; 
  unsigned int fileBackedTransientCount; 
  unsigned __int64 BudgetBytes; 
  __int64 v126; 
  unsigned __int64 v127; 
  unsigned __int64 v128; 
  unsigned __int8 v129; 
  int v130; 
  signed __int64 v131; 
  bool v132; 
  bool v133; 
  signed __int64 v134; 
  bool v137; 
  const dvar_t *v138; 
  unsigned int v140; 
  unsigned int v141; 
  unsigned int v142; 
  unsigned int v143; 
  unsigned int v144; 
  unsigned __int64 v145; 
  bool v146; 
  unsigned __int64 CurCost; 
  unsigned __int16 v148; 
  unsigned __int64 v149; 
  int v150; 
  int v151; 
  int v152; 
  const dvar_t *v154; 
  const dvar_t *v155; 
  const dvar_t *v156; 
  int v157; 
  unsigned __int64 tileBudget; 
  unsigned __int64 v159; 
  const dvar_t *v160; 
  const char *v161; 
  const char *v162; 
  __int64 cellSize; 
  float cellSizea; 
  __int64 useZoomedDistances; 
  __int64 isStreamingHint; 
  __int64 lod0Missing; 
  float v179; 
  float v180; 
  float v181; 
  float v182; 
  bool v183; 
  char v184; 
  bool IsLoadModeInFrontend; 
  int value; 
  unsigned int lobbyStreamPosCount; 
  unsigned int fileBackedTransientMax; 
  unsigned int v189; 
  unsigned int lod; 
  unsigned int v191; 
  unsigned __int8 *v193; 
  unsigned __int64 v194; 
  InterleavedPriorities v195; 
  unsigned __int64 v196; 
  float *priorityDistZ; 
  unsigned int v198; 
  WorldStreamPosition *streamPositions; 
  __int64 v200; 
  unsigned __int16 *v201; 
  Bounds *bounds; 
  __int64 v203; 
  __m256i v204; 
  int v210; 
  vec3_t outPointToClosestVec; 
  vec3_t mins; 
  vec3_t maxs; 
  _BYTE v214[128]; 
  int v217; 
  char v218[328]; 
  char v219; 
  void *retaddr; 

  _RAX = &retaddr;
  v203 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
    vmovaps xmmword ptr [rax-0B8h], xmm14
    vmovaps xmmword ptr [rax-0C8h], xmm15
  }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions");
  value = 0;
  *(_DWORD *)&v195.nextEmptyTileIndex = 0;
  *(_DWORD *)&v195.nextLod1SubTileIndex = 190185472;
  v195.spilloverIndex = 0;
  IsLoadModeInFrontend = CL_TransientsMP_IsLoadModeInFrontend();
  CL_TransientsWorldMP_UpdatePageBudget();
  __asm { vxorps  xmm10, xmm10, xmm10 }
  if ( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )
  {
    _RCX = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps;
    __asm { vmovss  xmm12, dword ptr [rcx+1Ch] }
  }
  else
  {
    __asm { vxorps  xmm12, xmm12, xmm12 }
  }
  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  lobbyStreamPosCount = s_transientsWorldMP.numStreamPositions;
  streamPositions = s_transientsWorldMP.streamPositions;
  if ( !s_transientsWorldMP.numStreamPositions )
  {
    numStreamPositions = s_transientsWorldMP.lobbyStreamPosCount;
    lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
    if ( s_transientsWorldMP.lobbyStreamPosCount )
    {
      _RBX = v218;
      _RDI = s_transientsWorldMP.lobbyStreamPos;
      v17 = s_transientsWorldMP.lobbyStreamPosCount;
      do
      {
        memset_0(&v204, 0, 0x9Cui64);
        __asm
        {
          vmovups ymm0, [rbp+370h+var_380]
          vmovups ymmword ptr [rbx], ymm0
          vmovups ymm1, [rbp+370h+var_360]
          vmovups ymmword ptr [rbx+20h], ymm1
          vmovups ymm0, [rbp+370h+var_340]
          vmovups ymmword ptr [rbx+40h], ymm0
          vmovups ymm1, [rbp+370h+var_320]
          vmovups ymmword ptr [rbx+60h], ymm1
          vmovups xmm0, [rbp+370h+var_300]
          vmovups xmmword ptr [rbx+80h], xmm0
          vmovsd  xmm1, [rbp+370h+var_2F0]
          vmovsd  qword ptr [rbx+90h], xmm1
        }
        *((_DWORD *)_RBX + 38) = v210;
        __asm
        {
          vmovsd  xmm0, qword ptr [rdi]
          vmovsd  qword ptr [rbx], xmm0
        }
        *((_DWORD *)_RBX + 2) = LODWORD(_RDI->v[2]);
        ++_RDI;
        _RBX += 156;
        --v17;
      }
      while ( v17 );
      v25 = v218;
    }
    else
    {
      memset_0(&v204, 0, 0x9Cui64);
      __asm
      {
        vmovups ymm0, [rbp+370h+var_380]
        vmovups [rbp+370h+var_2B0], ymm0
        vmovups ymm1, [rbp+370h+var_360]
        vmovups [rbp+370h+var_290], ymm1
        vmovups ymm0, [rbp+370h+var_340]
        vmovups [rbp+370h+var_270], ymm0
        vmovups ymm1, [rbp+370h+var_320]
        vmovups [rbp+370h+var_250], ymm1
        vmovups xmm0, [rbp+370h+var_300]
        vmovups [rbp+370h+var_230], xmm0
        vmovsd  xmm1, [rbp+370h+var_2F0]
        vmovsd  [rbp+370h+var_220], xmm1
      }
      v217 = v210;
      _RBX = DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos;
      if ( !DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDefaultPos") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  dword ptr [rbp+370h+var_2B0], xmm0
        vmovss  xmm1, dword ptr [rbx+2Ch]
        vmovss  dword ptr [rbp+370h+var_2B0+4], xmm1
        vmovss  xmm0, dword ptr [rbx+30h]
        vmovss  dword ptr [rbp+370h+var_2B0+8], xmm0
      }
      numStreamPositions = 1i64;
      lobbyStreamPosCount = 1;
      v25 = v214;
    }
    streamPositions = (WorldStreamPosition *)v25;
  }
  if ( !s_transientsWorldMP.isBRMap )
  {
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBegin;
    if ( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBegin )
      goto LABEL_24;
    v37 = "cl_transientWorldLoadXYLOD1FalloffBegin";
LABEL_22:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v37) )
      __debugbreak();
    goto LABEL_24;
  }
  if ( !s_transientsWorldMP.inLobbyState )
  {
    _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBR;
    if ( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBR )
      goto LABEL_24;
    v37 = "cl_transientWorldLoadXYLOD1FalloffBeginBR";
    goto LABEL_22;
  }
  _RBX = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRLobby;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRLobby )
  {
    v37 = "cl_transientWorldLoadXYLOD1FalloffBeginBRLobby";
    goto LABEL_22;
  }
LABEL_24:
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmulss  xmm1, xmm0, xmm0
    vmovss  cs:s_transientsWorldMP.lod1FalloffBeginSq, xmm1
  }
  priorityDistXY = s_transientsWorldMP.priorityDistXY;
  v41 = 96i64;
  v42 = 96i64;
  do
  {
    *(_QWORD *)priorityDistXY = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY + 1) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY + 2) = 0x7F7FFFFF7F7FFFFFi64;
    priorityDistXY += 16;
    *((_QWORD *)priorityDistXY - 5) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 4) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 3) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 2) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 1) = 0x7F7FFFFF7F7FFFFFi64;
    --v42;
  }
  while ( v42 );
  _RBX = s_transientsWorldMP.priorityDistZ;
  priorityDistZ = s_transientsWorldMP.priorityDistZ;
  v44 = s_transientsWorldMP.priorityDistZ;
  v45 = 96i64;
  do
  {
    *(_QWORD *)v44 = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 + 1) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 + 2) = 0x7F7FFFFF7F7FFFFFi64;
    v44 += 16;
    *((_QWORD *)v44 - 5) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 - 4) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 - 3) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 - 2) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v44 - 1) = 0x7F7FFFFF7F7FFFFFi64;
    --v45;
  }
  while ( v45 );
  priorityViewDot = s_transientsWorldMP.priorityViewDot;
  do
  {
    *(_QWORD *)priorityViewDot = 0i64;
    *((_QWORD *)priorityViewDot + 1) = 0i64;
    *((_QWORD *)priorityViewDot + 2) = 0i64;
    priorityViewDot += 16;
    *((_QWORD *)priorityViewDot - 5) = 0i64;
    *((_QWORD *)priorityViewDot - 4) = 0i64;
    *((_QWORD *)priorityViewDot - 3) = 0i64;
    *((_QWORD *)priorityViewDot - 2) = 0i64;
    *((_QWORD *)priorityViewDot - 1) = 0i64;
    --v41;
  }
  while ( v41 );
  __asm
  {
    vmulss  xmm0, xmm12, xmm12
    vmulss  xmm6, xmm0, cs:__real@40800000
    vmovss  [rbp+370h+var_3E8], xmm6
  }
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos((unsigned __int8)v41);
  __asm { vmulss  xmm14, xmm0, xmm0 }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldPopulatePriorityList");
  transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
  fileBackedTransientMax = s_transientsWorldMP.fileBackedTransientMax;
  v51 = 0;
  v191 = 0;
  if ( !s_transientsWorldMP.fileBackedTransientMax )
    goto LABEL_96;
  v52 = 0i64;
  v196 = 0i64;
  transientLODIndex = s_transientsWorldMP.transientLODIndex;
  v193 = s_transientsWorldMP.transientLODIndex;
  baseLODIndex = s_transientsWorldMP.baseLODIndex;
  v201 = s_transientsWorldMP.baseLODIndex;
  _RCX = (__int64)&transientWorldGridBounds->halfSize.z;
  v200 = _RCX;
  __asm
  {
    vmovss  xmm15, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovss  xmm13, cs:__real@3f800000
  }
  do
  {
    lod = *transientLODIndex;
    __asm { vmovss  xmm11, cs:__real@7f7fffff }
    bounds = (Bounds *)(_RCX - 20);
    __asm
    {
      vmovss  xmm6, dword ptr [r8]
      vsubss  xmm0, xmm6, dword ptr [rcx-8]
      vmovss  dword ptr [rbp+370h+mins], xmm0
      vmovss  xmm5, dword ptr [rcx-10h]
      vsubss  xmm0, xmm5, dword ptr [rcx-4]
      vmovss  dword ptr [rbp+370h+mins+4], xmm0
      vmovss  xmm3, dword ptr [rcx-0Ch]
      vsubss  xmm0, xmm3, dword ptr [rcx]
      vmovss  dword ptr [rbp+370h+mins+8], xmm0
      vaddss  xmm1, xmm6, dword ptr [rcx-8]
      vmovss  dword ptr [rbp+370h+maxs], xmm1
      vaddss  xmm0, xmm5, dword ptr [rcx-4]
      vmovss  dword ptr [rbp+370h+maxs+4], xmm0
      vaddss  xmm1, xmm3, dword ptr [rcx]
      vmovss  dword ptr [rbp+370h+maxs+8], xmm1
    }
    v183 = 0;
    if ( lod )
    {
      v68 = *baseLODIndex;
      if ( *baseLODIndex )
      {
        if ( (unsigned int)v68 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = *baseLODIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        v69 = 0x80000000 >> (v68 & 0x1F);
        v183 = 1;
        if ( (v69 & s_transientsWorldMP.loaded.array[v68 >> 5]) != 0 )
        {
          v70 = 0;
          v183 = 1;
          if ( SLODWORD(cl_maxLocalClients) > 0 )
          {
            v71 = &s_transientsWorldMP.visibleCurrent[0].array[v68 >> 5];
            while ( 1 )
            {
              if ( (unsigned int)v68 >= 0x600 )
              {
                LODWORD(useZoomedDistances) = 1536;
                LODWORD(cellSize) = v68;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                  __debugbreak();
              }
              if ( (v69 & *v71) != 0 )
                break;
              ++v70;
              v71 += 48;
              if ( v70 >= SLODWORD(cl_maxLocalClients) )
              {
                v183 = 1;
                goto LABEL_48;
              }
            }
            v183 = 0;
LABEL_48:
            _RBX = priorityDistZ;
          }
        }
        _RCX = v200;
        v52 = v196;
        baseLODIndex = v201;
      }
      else
      {
        v183 = 1;
      }
    }
    if ( !(_DWORD)numStreamPositions )
      goto LABEL_94;
    v72 = v51 & 0x1F;
    v198 = v51 & 0x1F;
    _RDI = &streamPositions->loadDistLimitSq;
    do
    {
      PointToClosestAABBPoint(&mins, &maxs, (const vec3_t *)_RDI - 12, &outPointToClosestVec);
      __asm
      {
        vmovss  xmm4, dword ptr [rbp+370h+outPointToClosestVec+4]
        vmulss  xmm1, xmm4, xmm4
        vmovss  xmm3, dword ptr [rbp+370h+outPointToClosestVec]
        vmulss  xmm0, xmm3, xmm3
        vaddss  xmm9, xmm1, xmm0
        vmovss  xmm8, dword ptr [rbp+370h+outPointToClosestVec+8]
        vmulss  xmm0, xmm8, xmm8
        vaddss  xmm2, xmm0, xmm9
        vmovss  xmm1, dword ptr [rdi]
        vucomiss xmm1, xmm10
      }
      if ( !v75 )
      {
        __asm { vcomiss xmm2, xmm1 }
        if ( !(v74 | v75) )
          goto LABEL_92;
      }
      v85 = 0;
      if ( *((_BYTE *)_RDI + 8) )
      {
        if ( *((_DWORD *)_RDI - 25) >= 2u )
        {
          LODWORD(useZoomedDistances) = 2;
          *(float *)&cellSize = *(_RDI - 25);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2667, ASSERT_TYPE_ASSERT, "(unsigned)( streamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.zoomTransients ) ) + 0 ) )", "streamPos.localClientIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.zoomTransients )\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
          __asm
          {
            vmovss  xmm3, dword ptr [rbp+370h+outPointToClosestVec]
            vmovss  xmm4, dword ptr [rbp+370h+outPointToClosestVec+4]
          }
        }
        v86 = &s_transientsWorldMP.zoomTransients[*((int *)_RDI - 25)];
        if ( v51 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
          __asm
          {
            vmovss  xmm3, dword ptr [rbp+370h+outPointToClosestVec]
            vmovss  xmm4, dword ptr [rbp+370h+outPointToClosestVec+4]
          }
        }
        v85 = ((0x80000000 >> v72) & v86->array[v196 >> 5]) != 0;
      }
      __asm { vmovaps xmm7, xmm10 }
      if ( lod == 1 )
      {
        __asm
        {
          vmulss  xmm1, xmm4, xmm4
          vmulss  xmm0, xmm3, xmm3
          vaddss  xmm1, xmm1, xmm0
          vsqrtss xmm2, xmm1, xmm1
          vcmpless xmm0, xmm2, cs:__real@80000000
          vblendvps xmm1, xmm2, xmm13, xmm0
          vdivss  xmm0, xmm13, xmm1
          vmulss  xmm3, xmm0, xmm3
          vmulss  xmm1, xmm0, xmm4
          vmulss  xmm2, xmm1, dword ptr [rdi-74h]
          vmulss  xmm0, xmm3, dword ptr [rdi-78h]
          vaddss  xmm7, xmm2, xmm0
        }
      }
      v99 = *((_BYTE *)_RDI + 5) == 0;
      if ( s_transientsWorldMP.isBRMap )
      {
        _RBX = DVARFLT_cl_transientWorldBRPlaneZThreshold;
        if ( !DVARFLT_cl_transientWorldBRPlaneZThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBRPlaneZThreshold") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+28h]
          vcomiss xmm0, dword ptr [rdi-88h]
        }
        v102 = v74 | v75;
      }
      else
      {
        v102 = 0;
      }
      __asm { vmovss  xmm6, cs:s_transientsWorldMP.lod1FalloffBeginSq }
      if ( v85 )
      {
        __asm { vmovss  xmm0, dword ptr [rdi-54h] }
      }
      else
      {
        v105 = DVARBOOL_cl_transientWorldLoadXYLOD1FalloffPlaneEnabled;
        if ( !DVARBOOL_cl_transientWorldLoadXYLOD1FalloffPlaneEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffPlaneEnabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v105);
        if ( !v105->current.enabled || !v102 )
          goto LABEL_84;
        _RBX = DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRPlane;
        if ( !DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRPlane && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffBeginBRPlane") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm0, dword ptr [rbx+28h] }
      }
      __asm
      {
        vmulss  xmm1, xmm0, xmm0
        vmaxss  xmm6, xmm1, xmm6
      }
LABEL_84:
      v108 = DVARBOOL_cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled;
      if ( !DVARBOOL_cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v108);
      lod1BoostBRMethod = v108->current.enabled && v102;
      __asm
      {
        vmovss  dword ptr [rsp+470h+var_410], xmm6
        vmovss  [rsp+470h+var_418], xmm14
        vmovss  xmm0, [rbp+370h+var_3E8]
        vmovss  [rsp+470h+var_420], xmm0
        vmovss  [rsp+470h+var_428], xmm7
        vmovss  [rsp+470h+cellSize], xmm12
        vmovaps xmm2, xmm8; distZ
        vmovaps xmm1, xmm9; distSqXY
      }
      *(float *)&_XMM0 = CL_TransientsWorldMP_CalcLoadPriorityDistance((const WorldStreamPosition *)(_RDI - 36), *(double *)&_XMM1, *(double *)&_XMM2, lod, bounds, cellSizea, v85, v99, v183, v179, v180, v181, v182, lod1BoostBRMethod);
      __asm
      {
        vminss  xmm11, xmm0, xmm11
        vsqrtss xmm1, xmm9, xmm9
      }
      _RBX = priorityDistZ;
      __asm
      {
        vminss  xmm0, xmm1, dword ptr [rbx-1800h]
        vmovss  dword ptr [rbx-1800h], xmm0
        vandps  xmm8, xmm8, xmm15
        vminss  xmm0, xmm8, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm0
        vmovss  dword ptr [rbx+1800h], xmm7
      }
      v72 = v198;
      v51 = v191;
LABEL_92:
      _RDI += 39;
      --numStreamPositions;
    }
    while ( numStreamPositions );
    _RCX = v200;
    v52 = v196;
    numStreamPositions = lobbyStreamPosCount;
    baseLODIndex = v201;
LABEL_94:
    __asm { vmovss  dword ptr [rbx-6628h], xmm11 }
    v191 = ++v51;
    v196 = ++v52;
    transientLODIndex = ++v193;
    _RCX += 24i64;
    v200 = _RCX;
    v201 = ++baseLODIndex;
    priorityDistZ = ++_RBX;
  }
  while ( v51 < fileBackedTransientMax );
  __asm { vmovss  xmm6, [rbp+370h+var_3E8] }
LABEL_96:
  Sys_ProfEndNamedEvent();
  v117 = 0;
  v118 = 0;
  v119 = 0i64;
  transientToMPIndexMapping = s_transientsWorldMP.transientToMPIndexMapping;
  do
  {
    if ( *transientToMPIndexMapping )
    {
      if ( ((0x80000000 >> (v118 & 0x1F)) & s_transientsWorldMP.requested.array[v119 >> 5]) != 0 )
        ++v117;
    }
    else
    {
      v121 = 0x80000000 >> (v118 & 0x1F);
      s_transientsWorldMP.loaded.array[v119 >> 5] |= v121;
      s_transientsWorldMP.requested.array[v119 >> 5] |= v121;
    }
    ++v118;
    ++v119;
    ++transientToMPIndexMapping;
  }
  while ( v118 < 0x600 );
  v122 = 0;
  if ( v117 != s_transientsWorldMP.requestedCount )
  {
    LODWORD(lod0Missing) = s_transientsWorldMP.requestedCount;
    LODWORD(isStreamingHint) = v117;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2738, ASSERT_TYPE_ASSERT, "( validateCount ) == ( s_transientsWorldMP.requestedCount )", "%s == %s\n\t%u, %u", "validateCount", "s_transientsWorldMP.requestedCount", isStreamingHint, lod0Missing) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldSortPriorityList");
  std::_Sort_unchecked<unsigned short *,WorldStreamOrderSort>(s_transientsWorldMP.priorityOrder, &s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount], s_transientsWorldMP.fileBackedTransientCount, (WorldStreamOrderSort)IsLoadModeInFrontend);
  Sys_ProfEndNamedEvent();
  fileBackedTransientCount = s_transientsWorldMP.fileBackedTransientCount;
  _R12 = s_transientsWorldMP.lastTrPriority;
  if ( s_transientsWorldMP.fileBackedTransientCount )
  {
    Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldIssueLoadAndUnloads");
    BudgetBytes = CL_TransientsWorldMP_GetBudgetBytes();
    v194 = BudgetBytes;
    v126 = fileBackedTransientCount - 1;
    if ( (unsigned int)v126 < fileBackedTransientCount )
    {
      v127 = BudgetBytes;
      do
      {
        if ( TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend) <= v127 )
          break;
        if ( (unsigned int)v126 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v126;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2764, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "i doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        v128 = s_transientsWorldMP.priorityOrder[v126];
        v129 = s_transientsWorldMP.transientLODIndex[v128];
        if ( v129 >= 3u )
        {
          LODWORD(useZoomedDistances) = 3;
          LODWORD(cellSize) = v129;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2766, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.transientLODIndex[freeWorldIndex] ) < (unsigned)( STREAMINGINFO_WORLD_LOD_COUNT )", "s_transientsWorldMP.transientLODIndex[freeWorldIndex] doesn't index STREAMINGINFO_WORLD_LOD_COUNT\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        if ( (unsigned int)v128 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v128;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        if ( ((0x80000000 >> (v128 & 0x1F)) & s_transientsWorldMP.requested.array[v128 >> 5]) != 0 )
          CL_TransientsWorldMP_UnloadIndex(v128);
        v126 = (unsigned int)(v126 - 1);
      }
      while ( (unsigned int)v126 < fileBackedTransientCount );
      _R12 = s_transientsWorldMP.lastTrPriority;
      v122 = 0;
    }
    v189 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
    if ( !s_transientsWorldMP.inLobbyState || (v184 = 1, !s_transientsWorldMP.isBRMap) )
      v184 = 0;
    v130 = fileBackedTransientCount - 1;
    memset_0(s_transientsWorldMP.lastTrPriority, 0, sizeof(s_transientsWorldMP.lastTrPriority));
    if ( !s_transientsWorldMP.preloadingBackToFE )
    {
      v131 = v130;
      v132 = 0;
      v133 = v130 == 0;
      if ( v130 >= 0 )
      {
        v134 = 0i64;
        _R12 = &s_transientsWorldMP;
        while ( 1 )
        {
          _RSI = s_transientsWorldMP.priorityOrder[v134];
          __asm { vcomiss xmm6, dword ptr [r12+rsi*4+0D29Ch] }
          v137 = !v132 && !v133;
          v138 = DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled;
          if ( !DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistEnabled") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v138);
          if ( v138->current.enabled )
          {
            __asm
            {
              vmovss  xmm0, cs:__real@7f7fffff
              vcomiss xmm0, dword ptr [r12+rsi*4+0D29Ch]
            }
            if ( !v138->current.enabled )
            {
              if ( (unsigned int)_RSI >= 0x600 )
              {
                LODWORD(useZoomedDistances) = 1536;
                LODWORD(cellSize) = _RSI;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                  __debugbreak();
              }
              v140 = 0x80000000 >> (_RSI & 0x1F);
              if ( (v140 & s_transientsWorldMP.loaded.array[_RSI >> 5]) == 0 )
              {
                if ( (unsigned int)_RSI >= 0x600 )
                {
                  LODWORD(useZoomedDistances) = 1536;
                  LODWORD(cellSize) = _RSI;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                    __debugbreak();
                }
                if ( (v140 & s_transientsWorldMP.requested.array[_RSI >> 5]) != 0 )
                  CL_TransientsWorldMP_UnloadIndex(_RSI);
                _R12 = &s_transientsWorldMP;
                goto LABEL_143;
              }
              _R12 = &s_transientsWorldMP;
            }
          }
          if ( (unsigned int)_RSI >= 0x600 )
          {
            LODWORD(useZoomedDistances) = 1536;
            LODWORD(cellSize) = _RSI;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (_RSI & 0x1F)) & s_transientsWorldMP.requested.array[_RSI >> 5]) == 0 && ((CurCost = TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend), TransientCostCalc_GetCostToLoad(&s_transientsWorldMP.worldCost, _RSI, IsLoadModeInFrontend) + CurCost > v194) || s_transientsWorldMP.requestedCount >= 0x400 || (unsigned int)_RSI < v189 && v184) )
          {
            if ( v131 > v134 )
            {
              while ( 1 )
              {
                v149 = s_transientsWorldMP.priorityOrder[v131];
                if ( (unsigned int)v149 >= 0x600 )
                {
                  LODWORD(useZoomedDistances) = 1536;
                  LODWORD(cellSize) = s_transientsWorldMP.priorityOrder[v131];
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                    __debugbreak();
                }
                if ( ((0x80000000 >> (v149 & 0x1F)) & s_transientsWorldMP.requested.array[v149 >> 5]) != 0 )
                  break;
                if ( --v131 <= v134 )
                  goto LABEL_143;
              }
              CL_TransientsWorldMP_UnloadIndex(v149);
              goto LABEL_144;
            }
          }
          else
          {
            v148 = InterleavedPriorities::Insert(&v195, _RSI, v137);
            CL_TransientsWorldMP_LoadIndex(_RSI, v148);
          }
LABEL_143:
          ++v134;
LABEL_144:
          v132 = v134 < (unsigned __int64)v131;
          v133 = v134 == v131;
          if ( v134 > v131 )
          {
            _R12 = s_transientsWorldMP.lastTrPriority;
            v122 = 0;
            break;
          }
        }
      }
    }
    Sys_ProfEndNamedEvent();
  }
  v141 = 0;
  v142 = 0;
  v143 = 0;
  while ( 2 )
  {
    if ( *_R12 <= 0xB56 )
      goto LABEL_191;
    v144 = 0x80000000 >> (v143 & 0x1F);
    v145 = (unsigned __int64)v143 >> 5;
    if ( (v144 & s_transientsWorldMP.requested.array[v145]) != 0 )
    {
      if ( *_R12 > 0x1389 )
      {
        ++v141;
        if ( (v144 & s_transientsWorldMP.loaded.array[v145]) != 0 )
          ++v142;
      }
      if ( v143 && s_transientsWorldMP.worldGridInfo )
      {
        if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
          __debugbreak();
        v146 = v143 < (unsigned int)(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount);
      }
      else
      {
        v146 = 0;
      }
      v150 = v122 + 1;
      if ( !v146 )
        v150 = v122;
      v122 = v150;
      v151 = value + 1;
      if ( !v146 )
        v151 = value;
      v152 = v151;
      value = v151;
      goto LABEL_192;
    }
    __asm
    {
      vmovss  xmm0, cs:__real@7f7fffff
      vcomiss xmm0, dword ptr [r12-3624h]
    }
    if ( (v144 & s_transientsWorldMP.requested.array[v145]) == 0 || !v143 || !s_transientsWorldMP.worldGridInfo )
    {
LABEL_191:
      v152 = value;
      goto LABEL_192;
    }
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
      __debugbreak();
    v152 = value;
    if ( v143 < (unsigned int)(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount) )
      v152 = ++value;
LABEL_192:
    ++v143;
    ++_R12;
    if ( v143 < 0x600 )
      continue;
    break;
  }
  v154 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
  if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v154);
  if ( v122 < v154->current.integer )
  {
    v155 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
    if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v155);
    if ( v152 >= v155->current.integer )
    {
      if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
        goto LABEL_207;
      v156 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
      if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v156);
      v157 = v156->current.integer << 20;
      tileBudget = v157;
      if ( !v157 )
LABEL_207:
        tileBudget = s_transientsWorldMP.tileBudget;
      v159 = tileBudget >> 20;
      v160 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
      if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v160);
      v161 = j_va("LOD0 tiles we'd want are too large, we can only load %d. %d target. %d total wanted. %zumb tilemem.", (unsigned int)v122, v160->current.unsignedInt, (unsigned int)v152, v159);
      StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_TRWORLD_MEMORY, 166, v161, v152);
    }
  }
  if ( v142 < v141 )
  {
    v162 = j_va("High priority tiles around the player are struggling to load in time, %u loaded, %u target, %u loading.", v142, v141, v141 - v142);
    StatMon_Warning(STATMON_CLASS_WARNING, STATMON_TYPE_TRWORLD_LOADED, 166, v162, v142);
  }
  Sys_ProfEndNamedEvent();
  _R11 = &v219;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
CL_TransientsWorldMP_UpdateLocalClientVisibility
==============
*/
void CL_TransientsWorldMP_UpdateLocalClientVisibility(const LocalClientNum_t localClient)
{
  signed __int64 v1; 
  void *v11; 
  __int64 v12; 
  bitarray_base<bitarray<1536> > *v13; 
  bitarray_base<bitarray<1536> > *v14; 
  bitarray<1536> *v15; 
  TransientZoneIntArray *v16; 
  bitarray<1536> *v17; 
  __int64 v18; 
  __int64 v19; 
  bitarray<1536> *p_fallingHinted; 
  __int64 v21; 
  char v22; 
  unsigned int v23; 
  __int64 v24; 
  char *v25; 
  const dvar_t *v26; 
  int integer; 
  bitarray_base<bitarray<1536> > *v28; 
  __int64 v29; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v33; 
  __int64 v34; 
  unsigned int v35; 
  unsigned __int64 v36; 
  unsigned int i; 
  WorldStreamPosition *v38; 
  const dvar_t *v39; 
  bitarray<1536> *p_visibleHintBitArray; 
  __int64 v41; 
  bitarray<1536> *v42; 
  __int64 v43; 
  __int64 v48; 
  const dvar_t *v57; 
  bitarray_base<bitarray<1536> > *v58; 
  __int64 v59; 
  const dvar_t *v60; 
  const dvar_t *v63; 
  const dvar_t *v69; 
  const dvar_t *v71; 
  const dvar_t *v77; 
  const dvar_t *v79; 
  const dvar_t *v85; 
  const dvar_t *v87; 
  int *v94; 
  int *v95; 
  int *v96; 
  const dvar_t *v97; 
  const dvar_t *v100; 
  unsigned int v101; 
  unsigned int v102; 
  __int64 v103; 
  unsigned __int16 *v110; 
  unsigned int v111; 
  __int64 v112; 
  unsigned int v113; 
  int v114; 
  unsigned int v115; 
  bool v121; 
  bool v122; 
  bool v123; 
  bool v124; 
  bool v132; 
  bool v137; 
  bool v146; 
  char v162; 
  char v163; 
  char v166; 
  char v167; 
  int v168; 
  unsigned int v169; 
  unsigned int v170; 
  unsigned int v171; 
  unsigned int v172; 
  unsigned __int64 v173; 
  unsigned __int64 v174; 
  unsigned int v175; 
  unsigned int v176; 
  unsigned int v177; 
  char v178; 
  unsigned int *v179; 
  bitarray<1536> *v180; 
  __int64 v181; 
  __int64 v182; 
  __int64 v183; 
  __int64 v186; 
  bitarray<1536> *v195; 
  bitarray<1536> *v196; 
  __int64 v217; 
  __int64 v218; 
  __int64 v219; 
  double v220; 
  double v221; 
  double v222; 
  double v223; 
  __int64 v224; 
  double v225; 
  double v226; 
  double v227; 
  bool enabled; 
  bool v229; 
  unsigned int v230; 
  char v231; 
  int v232; 
  unsigned int v234; 
  bitarray<1536> *visibleBitArray; 
  int v236; 
  unsigned int v237; 
  TransientZoneIntArray *v238; 
  bitarray_base<bitarray<1536> > *v239; 
  int v240; 
  unsigned int v241; 
  __int64 v242; 
  __int64 v243; 
  bitarray<1536> *v244; 
  int *v245; 
  int *v246; 
  unsigned __int16 *v247; 
  int v248; 
  unsigned int v249; 
  int *v250; 
  int v251[2]; 
  int v252[2]; 
  int v253[2]; 
  int v254[2]; 
  int v255[2]; 
  int v256[2]; 
  int v257[2]; 
  int v258[2]; 
  int *v259; 
  unsigned __int64 v260; 
  __int64 v261; 
  bitarray<1536> v262; 
  bitarray<1536> visibleHintBitArray; 
  float distanceSqToStreamPos; 
  char v265; 
  char v275; 

  v11 = alloca(v1);
  v261 = -2i64;
  __asm
  {
    vmovaps [rsp+1B70h+var_30], xmm6
    vmovaps [rsp+1B70h+var_40], xmm7
    vmovaps [rsp+1B70h+var_50], xmm8
    vmovaps [rsp+1B70h+var_60], xmm9
    vmovaps [rsp+1B70h+var_70], xmm10
    vmovaps [rsp+1B70h+var_80], xmm11
    vmovaps [rsp+1B70h+var_90], xmm12
    vmovaps [rsp+1B70h+var_A0], xmm13
    vmovaps [rsp+1B70h+var_B0], xmm14
  }
  v12 = localClient;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLocalClientVisibility");
  v13 = &s_transientsWorldMP.visibleTarget[v12];
  visibleBitArray = (bitarray<1536> *)v13;
  v14 = &s_transientsWorldMP.visibleCurrent[v12];
  v239 = v14;
  v15 = &s_transientsWorldMP.visibleHint[v12];
  v244 = v15;
  v16 = &s_transientsWorldMP.switchDelayStarted[v12];
  v238 = v16;
  bitarray_base<bitarray<1536>>::copyBitArray(v13, &s_transientsWorldMP.transientsHighestLOD);
  *(_DWORD *)v13 |= 0x80000000;
  v17 = v15;
  v18 = 3i64;
  do
  {
    *(_QWORD *)v17->array = 0i64;
    *(_QWORD *)&v17->array[2] = 0i64;
    *(_QWORD *)&v17->array[4] = 0i64;
    v17 = (bitarray<1536> *)((char *)v17 + 64);
    *(_QWORD *)&v17[-1].array[38] = 0i64;
    *(_QWORD *)&v17[-1].array[40] = 0i64;
    *(_QWORD *)&v17[-1].array[42] = 0i64;
    *(_QWORD *)&v17[-1].array[44] = 0i64;
    *(_QWORD *)&v17[-1].array[46] = 0i64;
    --v18;
  }
  while ( v18 );
  v19 = v12;
  *(_QWORD *)s_transientsWorldMP.zoomTransients[v19].array = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[2] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[4] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[6] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[8] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[10] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[12] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[14] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[16] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[18] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[20] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[22] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[24] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[26] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[28] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[30] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[32] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[34] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[36] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[38] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[40] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[42] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[44] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v19].array[46] = 0i64;
  p_fallingHinted = &s_transientsWorldMP.fallingHinted;
  v21 = 3i64;
  do
  {
    *(_QWORD *)p_fallingHinted->array = 0i64;
    *(_QWORD *)&p_fallingHinted->array[2] = 0i64;
    *(_QWORD *)&p_fallingHinted->array[4] = 0i64;
    p_fallingHinted = (bitarray<1536> *)((char *)p_fallingHinted + 64);
    *(_QWORD *)&p_fallingHinted[-1].array[38] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[40] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[42] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[44] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[46] = 0i64;
    --v21;
  }
  while ( v21 );
  v22 = 0;
  v23 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  v241 = v23;
  if ( v23 > 1 )
  {
    v24 = v23 - 1;
    v25 = &v265;
    while ( v24 )
    {
      *(_DWORD *)v25 = 2139095039;
      v25 += 4;
      --v24;
    }
  }
  v26 = DCONST_DVARINT_cl_transientWorldForceVisibleLOD;
  if ( !DCONST_DVARINT_cl_transientWorldForceVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldForceVisibleLOD") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  integer = v26->current.integer;
  if ( integer < 0 )
  {
    for ( i = 0; i < s_transientsWorldMP.numStreamPositions; ++i )
    {
      v38 = &s_transientsWorldMP.streamPositions[i];
      if ( v38->localClientIndex == localClient )
      {
        if ( v38->streamRender )
        {
          v22 |= v38->zoomVisibility;
          CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(localClient, visibleBitArray, v15, &s_transientsWorldMP.streamPositions[i], &distanceSqToStreamPos);
        }
        else
        {
          v39 = DVARBOOL_cl_transientWorldHintPredictedStreamPositions;
          if ( !DVARBOOL_cl_transientWorldHintPredictedStreamPositions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldHintPredictedStreamPositions") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v39);
          if ( v39->current.enabled )
          {
            v262.array[1] = s_transientsWorldMP.transientsHighestLOD.array[1];
            v262.array[2] = s_transientsWorldMP.transientsHighestLOD.array[2];
            v262.array[3] = s_transientsWorldMP.transientsHighestLOD.array[3];
            v262.array[4] = s_transientsWorldMP.transientsHighestLOD.array[4];
            v262.array[5] = s_transientsWorldMP.transientsHighestLOD.array[5];
            v262.array[6] = s_transientsWorldMP.transientsHighestLOD.array[6];
            v262.array[7] = s_transientsWorldMP.transientsHighestLOD.array[7];
            v262.array[8] = s_transientsWorldMP.transientsHighestLOD.array[8];
            v262.array[9] = s_transientsWorldMP.transientsHighestLOD.array[9];
            v262.array[10] = s_transientsWorldMP.transientsHighestLOD.array[10];
            v262.array[11] = s_transientsWorldMP.transientsHighestLOD.array[11];
            v262.array[12] = s_transientsWorldMP.transientsHighestLOD.array[12];
            v262.array[13] = s_transientsWorldMP.transientsHighestLOD.array[13];
            v262.array[14] = s_transientsWorldMP.transientsHighestLOD.array[14];
            v262.array[15] = s_transientsWorldMP.transientsHighestLOD.array[15];
            v262.array[16] = s_transientsWorldMP.transientsHighestLOD.array[16];
            v262.array[17] = s_transientsWorldMP.transientsHighestLOD.array[17];
            v262.array[18] = s_transientsWorldMP.transientsHighestLOD.array[18];
            v262.array[19] = s_transientsWorldMP.transientsHighestLOD.array[19];
            v262.array[20] = s_transientsWorldMP.transientsHighestLOD.array[20];
            v262.array[21] = s_transientsWorldMP.transientsHighestLOD.array[21];
            v262.array[22] = s_transientsWorldMP.transientsHighestLOD.array[22];
            v262.array[23] = s_transientsWorldMP.transientsHighestLOD.array[23];
            v262.array[24] = s_transientsWorldMP.transientsHighestLOD.array[24];
            v262.array[25] = s_transientsWorldMP.transientsHighestLOD.array[25];
            v262.array[26] = s_transientsWorldMP.transientsHighestLOD.array[26];
            v262.array[27] = s_transientsWorldMP.transientsHighestLOD.array[27];
            v262.array[28] = s_transientsWorldMP.transientsHighestLOD.array[28];
            v262.array[29] = s_transientsWorldMP.transientsHighestLOD.array[29];
            v262.array[30] = s_transientsWorldMP.transientsHighestLOD.array[30];
            v262.array[31] = s_transientsWorldMP.transientsHighestLOD.array[31];
            v262.array[32] = s_transientsWorldMP.transientsHighestLOD.array[32];
            v262.array[33] = s_transientsWorldMP.transientsHighestLOD.array[33];
            v262.array[34] = s_transientsWorldMP.transientsHighestLOD.array[34];
            v262.array[35] = s_transientsWorldMP.transientsHighestLOD.array[35];
            v262.array[36] = s_transientsWorldMP.transientsHighestLOD.array[36];
            v262.array[37] = s_transientsWorldMP.transientsHighestLOD.array[37];
            v262.array[38] = s_transientsWorldMP.transientsHighestLOD.array[38];
            v262.array[39] = s_transientsWorldMP.transientsHighestLOD.array[39];
            v262.array[40] = s_transientsWorldMP.transientsHighestLOD.array[40];
            v262.array[41] = s_transientsWorldMP.transientsHighestLOD.array[41];
            v262.array[42] = s_transientsWorldMP.transientsHighestLOD.array[42];
            v262.array[43] = s_transientsWorldMP.transientsHighestLOD.array[43];
            v262.array[44] = s_transientsWorldMP.transientsHighestLOD.array[44];
            v262.array[45] = s_transientsWorldMP.transientsHighestLOD.array[45];
            v262.array[46] = s_transientsWorldMP.transientsHighestLOD.array[46];
            v262.array[47] = s_transientsWorldMP.transientsHighestLOD.array[47];
            v262.array[0] = s_transientsWorldMP.transientsHighestLOD.array[0] | 0x80000000;
            p_visibleHintBitArray = &visibleHintBitArray;
            v41 = 3i64;
            do
            {
              *(_QWORD *)p_visibleHintBitArray->array = 0i64;
              *(_QWORD *)&p_visibleHintBitArray->array[2] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray->array[4] = 0i64;
              p_visibleHintBitArray = (bitarray<1536> *)((char *)p_visibleHintBitArray + 64);
              *(_QWORD *)&p_visibleHintBitArray[-1].array[38] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[40] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[42] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[44] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[46] = 0i64;
              --v41;
            }
            while ( v41 );
            if ( v38->zoomVisibility && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1459, ASSERT_TYPE_ASSERT, "( !worldStreamPos.zoomVisibility )", "Zoom visibility is not supported for predicted transient world hinting") )
              __debugbreak();
            CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(localClient, &v262, &visibleHintBitArray, v38, NULL);
            v15 = v244;
            if ( v244 > (bitarray<1536> *)&v262.array[47] || &v244->array[47] < (unsigned int *)&v262 )
            {
              _RAX = &v244->array[4];
              _RDI = (char *)((char *)&v262.array[4] - (char *)v244);
              _R8 = (char *)((char *)&v262.array[8] - (char *)v244);
              _RCX = (char *)((char *)&v262 - (char *)v244);
              v48 = 3i64;
              do
              {
                __asm
                {
                  vmovdqu xmm1, xmmword ptr [rcx+rax-10h]
                  vpor    xmm1, xmm1, xmmword ptr [rax-10h]
                  vmovdqu xmmword ptr [rax-10h], xmm1
                  vmovdqu xmm2, xmmword ptr [rcx+rax]
                  vpor    xmm1, xmm2, xmmword ptr [rax]
                  vmovdqu xmmword ptr [rax], xmm1
                  vmovdqu xmm1, xmmword ptr [rdi+rax]
                  vpor    xmm1, xmm1, xmmword ptr [rax+10h]
                  vmovdqu xmmword ptr [rax+10h], xmm1
                  vmovdqu xmm1, xmmword ptr [r8+rax]
                  vpor    xmm1, xmm1, xmmword ptr [rax+20h]
                  vmovdqu xmmword ptr [rax+20h], xmm1
                }
                _RAX += 16;
                --v48;
              }
              while ( v48 );
            }
            else
            {
              v42 = v244;
              v43 = 48i64;
              do
              {
                v42->array[0] |= *(unsigned int *)((char *)v42->array + (char *)&v262 - (char *)v244);
                v42 = (bitarray<1536> *)((char *)v42 + 4);
                --v43;
              }
              while ( v43 );
            }
          }
          else
          {
            v15 = v244;
          }
        }
      }
    }
    v13 = visibleBitArray;
  }
  else
  {
    v28 = v13;
    v29 = 3i64;
    do
    {
      *(_QWORD *)v28 = 0i64;
      *(_QWORD *)&v28[8] = 0i64;
      *(_QWORD *)&v28[16] = 0i64;
      v28 += 64;
      *(_QWORD *)&v28[-40] = 0i64;
      *(_QWORD *)&v28[-32] = 0i64;
      *(_QWORD *)&v28[-24] = 0i64;
      *(_QWORD *)&v28[-16] = 0i64;
      *(_QWORD *)&v28[-8] = 0i64;
      --v29;
    }
    while ( v29 );
    *(_DWORD *)v13 = 0x80000000;
    if ( (unsigned int)integer <= 2 )
    {
      v30 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
      v31 = 1;
      if ( v30 > 1 )
      {
        do
        {
          HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v31);
          v33 = v31;
          if ( integer > 0 )
          {
            v34 = (unsigned int)(integer - 1);
            if ( (unsigned int)v34 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
            {
              LODWORD(v218) = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
              LODWORD(v217) = integer - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1377, ASSERT_TYPE_ASSERT, "(unsigned)( highLodLookupIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )", "highLodLookupIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount\n\t%i not in [0, %i)", v217, v218) )
                __debugbreak();
            }
            v33 = HighLODLookups[v34];
          }
          if ( v33 )
          {
            if ( v33 >= 0x600 )
            {
              LODWORD(v218) = 1536;
              LODWORD(v217) = v33;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                __debugbreak();
            }
            v35 = 0x80000000 >> (v33 & 0x1F);
            v36 = (unsigned __int64)v33 >> 5;
            if ( (v35 & s_transientsWorldMP.loaded.array[v36]) != 0 )
            {
              if ( v33 >= 0x600 )
              {
                LODWORD(v224) = 1536;
                LODWORD(v219) = v33;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v219, v224) )
                  __debugbreak();
              }
              visibleBitArray->array[v36] |= v35;
            }
          }
          ++v31;
        }
        while ( v31 < v30 );
        v22 = 0;
        v16 = v238;
        v15 = v244;
      }
      v13 = visibleBitArray;
      v14 = v239;
    }
    bitarray_base<bitarray<1536>>::copyBitArray(v15, v13);
  }
  if ( *(_DWORD *)v13 >= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1470, ASSERT_TYPE_ASSERT, "(visibleTargetBitArray.testBit( TRANSIENT_ZONE_ALWAYSLOADED ))", (const char *)&queryFormat, "visibleTargetBitArray.testBit( TRANSIENT_ZONE_ALWAYSLOADED )") )
    __debugbreak();
  v57 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
  if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v57);
  if ( v57->current.integer >= 3u )
  {
    v58 = v13;
    v59 = 3i64;
    do
    {
      *(_QWORD *)v58 = 0i64;
      *(_QWORD *)&v58[8] = 0i64;
      *(_QWORD *)&v58[16] = 0i64;
      v58 += 64;
      *(_QWORD *)&v58[-40] = 0i64;
      *(_QWORD *)&v58[-32] = 0i64;
      *(_QWORD *)&v58[-24] = 0i64;
      *(_QWORD *)&v58[-16] = 0i64;
      *(_QWORD *)&v58[-8] = 0i64;
      --v59;
    }
    while ( v59 );
    *(_DWORD *)v13 = 0x80000000;
  }
  v60 = DVARFLT_cl_transientWorldSwitchDelayLOD0Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v60);
  __asm
  {
    vmovss  xmm6, cs:__real@447a0000
    vmulss  xmm0, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A98], xmm0
  }
  v63 = DVARFLT_cl_transientWorldSwitchDelayLOD1Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v63);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A94], xmm1
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayLOD0MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A78], xmm0
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayLOD1MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A74], xmm0
  }
  v69 = DVARFLT_cl_transientWorldSwitchDelayLOD0Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v69);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A88], xmm1
  }
  v71 = DVARFLT_cl_transientWorldSwitchDelayLOD1Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v71);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A84], xmm1
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayLOD0MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A68], xmm0
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayLOD1MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A64], xmm0
  }
  v77 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v77);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1AA0], xmm1
  }
  v79 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v79);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A9C], xmm1
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A80], xmm0
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A7C], xmm0
  }
  v85 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v85);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A90], xmm1
  }
  v87 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v87);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A8C], xmm1
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A70], xmm0
  }
  _RDI = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmovss  [rbp+1A70h+var_1A6C], xmm0
  }
  _RSI = v251;
  if ( !v22 )
    _RSI = v252;
  v246 = _RSI;
  v94 = v253;
  if ( !v22 )
    v94 = v254;
  v245 = v94;
  v95 = v255;
  if ( !v22 )
    v95 = v256;
  v250 = v95;
  v96 = v257;
  if ( !v22 )
    v96 = v258;
  v259 = v96;
  v97 = DVARFLT_cl_transientWorldSwitchDelayLowerLod;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLowerLod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLowerLod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v97);
  __asm { vmulss  xmm0, xmm6, dword ptr [rdi+28h]; val }
  v248 = float_to_integral_cast<int,float>(*(float *)&_XMM0);
  if ( integer >= 0 )
  {
    v195 = visibleBitArray;
    bitarray_base<bitarray<1536>>::copyBitArray(v14, visibleBitArray);
    bitarray_base<bitarray<1536>>::orAllBits(v15, visibleBitArray);
    memset_0(v16, 0, sizeof(TransientZoneIntArray));
  }
  else
  {
    __asm
    {
      vxorps  xmm11, xmm11, xmm11
      vucomiss xmm11, dword ptr [rsi]
    }
    v240 = Sys_Milliseconds();
    v100 = DCONST_DVARBOOL_cl_transientWorldDebugDelay;
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v100);
    enabled = v100->current.enabled;
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1554, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount > 0") )
      __debugbreak();
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1555, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0") )
      __debugbreak();
    v229 = !Stream_CanStreamMore();
    v101 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount + 1;
    v230 = v101;
    v102 = 1;
    v232 = 1;
    if ( v241 > 1 )
    {
      v103 = 1i64;
      v243 = 1i64;
      __asm
      {
        vxorpd  xmm14, xmm14, xmm14
        vmovss  xmm13, cs:__real@3f800000
        vmovss  xmm12, cs:__real@cb800000
        vmovss  xmm8, cs:__real@4b800000
        vmovss  xmm9, cs:__real@cf000000
        vmovss  xmm10, cs:__real@4f000000
      }
      while ( 1 )
      {
        v231 = 0;
        v110 = CL_TransientsWorldMP_GetHighLODLookups(v102);
        v247 = v110;
        v111 = 0;
        v237 = 0;
        if ( !v101 )
          goto LABEL_268;
        v112 = 0i64;
        v242 = 0i64;
        do
        {
          if ( v111 )
          {
            v113 = v110[v111 - 1];
            v234 = v113;
            v112 = v242;
          }
          else
          {
            v113 = v102;
            v234 = v102;
          }
          if ( v113 )
          {
            if ( v113 >= 0x600 )
            {
              LODWORD(v218) = 1536;
              LODWORD(v217) = v113;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1570, ASSERT_TYPE_ASSERT, "(unsigned)( curTransient ) < (unsigned)( ( sizeof( *array_counter( switchDelayStartedArray.data ) ) + 0 ) )", "curTransient doesn't index ARRAY_COUNT( switchDelayStartedArray.data )\n\t%i not in [0, %i)", v217, v218) )
                __debugbreak();
            }
            if ( v113 >= 0x600 )
            {
              LODWORD(v218) = 1536;
              LODWORD(v217) = v113;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                __debugbreak();
            }
            v249 = 0x80000000 >> (v113 & 0x1F);
            v260 = (unsigned __int64)v113 >> 5;
            v114 = *(_DWORD *)&v14[4 * v260] & v249;
            v236 = v114;
            if ( v113 >= 0x600 )
            {
              LODWORD(v218) = 1536;
              LODWORD(v217) = v113;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                __debugbreak();
              v114 = v236;
            }
            v115 = (0x80000000 >> (v113 & 0x1F)) & visibleBitArray->array[(unsigned __int64)v113 >> 5];
            if ( !enabled && (!v115 || v114) )
            {
              v238->data[v113] = 0;
              goto LABEL_262;
            }
            if ( v111 != 2 )
            {
              if ( v111 && v231 )
                goto LABEL_165;
              if ( v111 >= 2 )
              {
                LODWORD(v218) = 2;
                LODWORD(v217) = v111;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1601, ASSERT_TYPE_ASSERT, "(unsigned)( curLod ) < (unsigned)( ( sizeof( *array_counter( switchPeriodMinDistance ) ) + 0 ) )", "curLod doesn't index switchPeriodMinDistance\n\t%i not in [0, %i)", v217, v218) )
                  __debugbreak();
              }
              _RDI = v242;
              _RAX = v250;
              __asm
              {
                vmovss  xmm0, dword ptr [rax+rdi*4]
                vmulss  xmm6, xmm0, xmm0
              }
              v121 = v102 < 0x600;
              v122 = v102 == 1536;
              v123 = v102 <= 0x600;
              if ( v102 >= 0x600 )
              {
                LODWORD(v218) = 1536;
                LODWORD(v217) = v102;
                v124 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1608, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransient ) < (unsigned)( ( sizeof( *array_counter( distanceSqToStreamPos ) ) + 0 ) )", "baseTransient doesn't index distanceSqToStreamPos\n\t%i not in [0, %i)", v217, v218);
                v121 = 0;
                v122 = !v124;
                v123 = !v124;
                if ( v124 )
                  __debugbreak();
              }
              _RAX = v243;
              __asm { vcomiss xmm6, [rbp+rax*4+1A70h+distanceSqToStreamPos] }
              _RAX = v246;
              if ( !v121 )
                goto LABEL_193;
              __asm { vmovss  xmm0, dword ptr [rax+rdi*4] }
              _RCX = v245;
              __asm
              {
                vmovss  xmm6, dword ptr [rcx+rdi*4]
                vucomiss xmm0, xmm6
              }
              if ( v122 )
              {
LABEL_193:
                __asm
                {
                  vmovss  xmm0, dword ptr [rax+rdi*4]
                  vcvttss2si edi, xmm0
                  vcomiss xmm0, xmm12
                }
                if ( v121 )
                  goto LABEL_196;
                __asm { vcomiss xmm0, xmm8 }
                if ( !v123 )
                {
LABEL_196:
                  v166 = 0;
                  v123 = 1;
                }
                else
                {
                  v166 = 1;
                }
                __asm
                {
                  vcomiss xmm0, xmm9
                  vcomiss xmm0, xmm10
                }
                v167 = v123;
                if ( v166 && v167 )
                  goto LABEL_205;
                __asm { vcvtss2sd xmm0, xmm0, xmm0 }
              }
              else
              {
                __asm
                {
                  vmovaps xmm7, xmm0
                  vcomiss xmm0, xmm11
                }
                if ( v121 )
                {
                  __asm
                  {
                    vcvtss2sd xmm0, xmm0, xmm0
                    vmovsd  [rsp+1B70h+var_1B30], xmm14
                    vmovsd  [rsp+1B70h+var_1B38], xmm0
                  }
                  v132 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1611, ASSERT_TYPE_ASSERT, "( switchPeriodMsMin[curLod] ) >= ( 0.0f )", "%s >= %s\n\t%g, %g", "switchPeriodMsMin[curLod]", "0.0f", v220, v225);
                  v121 = 0;
                  v123 = !v132;
                  if ( v132 )
                  {
                    __debugbreak();
                    _RAX = v246;
                    __asm { vmovss  xmm7, dword ptr [rax+rdi*4] }
                    _RAX = v245;
                    __asm { vmovss  xmm6, dword ptr [rax+rdi*4] }
                  }
                }
                __asm { vcomiss xmm7, xmm6 }
                if ( !v121 )
                {
                  __asm
                  {
                    vcvtss2sd xmm0, xmm6, xmm6
                    vcvtss2sd xmm1, xmm7, xmm7
                    vmovsd  [rsp+1B70h+var_1B30], xmm0
                    vmovsd  [rsp+1B70h+var_1B38], xmm1
                  }
                  v137 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1612, ASSERT_TYPE_ASSERT, "( switchPeriodMsMin[curLod] ) < ( switchPeriodMsMax[curLod] )", "%s < %s\n\t%g, %g", "switchPeriodMsMin[curLod]", "switchPeriodMsMax[curLod]", v221, v226);
                  v121 = 0;
                  v123 = !v137;
                  if ( v137 )
                    __debugbreak();
                }
                _RAX = v250;
                __asm { vmovss  xmm1, dword ptr [rax+rdi*4] }
                _RAX = (__int64)v259;
                __asm
                {
                  vmovss  xmm0, dword ptr [rax+rdi*4]
                  vmovaps xmm6, xmm1
                  vmovaps xmm7, xmm0
                  vcomiss xmm1, xmm0
                }
                if ( !v121 )
                {
                  __asm
                  {
                    vcvtss2sd xmm0, xmm0, xmm0
                    vcvtss2sd xmm1, xmm1, xmm1
                    vmovsd  [rsp+1B70h+var_1B30], xmm0
                    vmovsd  [rsp+1B70h+var_1B38], xmm1
                  }
                  v146 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1613, ASSERT_TYPE_ASSERT, "( switchPeriodMinDistance[curLod] ) < ( switchPeriodMaxDistance[curLod] )", "%s < %s\n\t%g, %g", "switchPeriodMinDistance[curLod]", "switchPeriodMaxDistance[curLod]", v222, v227);
                  v121 = 0;
                  v123 = !v146;
                  if ( v146 )
                  {
                    __debugbreak();
                    _RAX = v250;
                    __asm { vmovss  xmm6, dword ptr [rax+rdi*4] }
                    _RAX = (__int64)v259;
                    __asm { vmovss  xmm7, dword ptr [rax+rdi*4] }
                  }
                }
                _RAX = v243;
                __asm
                {
                  vmovss  xmm0, [rbp+rax*4+1A70h+distanceSqToStreamPos]
                  vsqrtss xmm0, xmm0, xmm0
                  vsubss  xmm2, xmm0, xmm6
                  vsubss  xmm1, xmm7, xmm6
                  vdivss  xmm3, xmm2, xmm1
                  vmaxss  xmm0, xmm3, xmm11
                  vminss  xmm4, xmm0, xmm13
                  vsubss  xmm1, xmm13, xmm4
                  vmulss  xmm2, xmm1, dword ptr [rax+rdi*4]
                  vmulss  xmm0, xmm4, dword ptr [rax+rdi*4]
                  vaddss  xmm1, xmm2, xmm0
                  vcvttss2si edi, xmm1
                  vcomiss xmm1, xmm12
                }
                if ( v121 )
                  goto LABEL_186;
                __asm { vcomiss xmm1, xmm8 }
                if ( !v123 )
                {
LABEL_186:
                  v162 = 0;
                  v123 = 1;
                }
                else
                {
                  v162 = 1;
                }
                __asm
                {
                  vcomiss xmm1, xmm9
                  vcomiss xmm1, xmm10
                }
                v163 = v123;
                if ( v162 && v163 )
                  goto LABEL_205;
                __asm { vcvtss2sd xmm0, xmm1, xmm1 }
              }
              __asm { vmovsd  [rsp+1B70h+var_1B38], xmm0 }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 437, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (IntegralType) 0x%jx == (FloatType) %f", "int __cdecl float_to_integral_cast<int,float>(float)", _EDI, v223) )
                __debugbreak();
              goto LABEL_205;
            }
            if ( !v231 )
            {
              _EDI = 0;
              goto LABEL_208;
            }
LABEL_165:
            _EDI = v248;
LABEL_205:
            if ( _EDI < 0 )
            {
              LODWORD(v219) = _EDI;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1625, ASSERT_TYPE_ASSERT, "( desiredSwitchPeriod ) >= ( 0 )", "%s >= %s\n\t%i, %i", "desiredSwitchPeriod", "0", v219, 0i64) )
                __debugbreak();
            }
LABEL_208:
            s_transientsWorldMP.switchDelayTarget[localClient].data[v113] = _EDI;
            if ( enabled && !v115 )
              goto LABEL_265;
            if ( !_EDI )
            {
              v238->data[v113] = 0;
LABEL_241:
              if ( v113 >= 0x600 )
              {
                LODWORD(v218) = 1536;
                LODWORD(v217) = v113;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                  __debugbreak();
              }
              v174 = v260;
              if ( (v249 & s_transientsWorldMP.loaded.array[v260]) == 0 )
              {
                LODWORD(v217) = v113;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1704, ASSERT_TYPE_ASSERT, "( ( s_transientsWorldMP.loaded.testBit( curTransient ) ) )", "( curTransient ) = %u", v217) )
                  __debugbreak();
              }
              if ( v113 >= 0x600 )
              {
                LODWORD(v224) = 1536;
                LODWORD(v219) = v113;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v219, v224) )
                  __debugbreak();
              }
              v14 = v239;
              *(_DWORD *)&v239[4 * v174] |= v249;
              v175 = 0;
              v111 = v237;
              v176 = v230;
              do
              {
                if ( v175 != v237 )
                {
                  if ( v175 )
                    v177 = v247[v175 - 1];
                  else
                    v177 = v232;
                  if ( v177 )
                  {
                    if ( v177 >= 0x600 )
                    {
                      LODWORD(v224) = 1536;
                      LODWORD(v219) = v177;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v219, v224) )
                        __debugbreak();
                    }
                    *(_DWORD *)&v239[4 * ((unsigned __int64)v177 >> 5)] &= ~(0x80000000 >> (v177 & 0x1F));
                  }
                  v176 = v230;
                }
                ++v175;
              }
              while ( v175 < v176 );
LABEL_262:
              v178 = v231;
              if ( v236 )
                v178 = 1;
              v231 = v178;
              v102 = v232;
LABEL_265:
              v110 = v247;
              v112 = v242;
              goto LABEL_266;
            }
            v168 = v238->data[v113];
            if ( !v168 )
            {
              v238->data[v113] = v240;
              if ( !v240 )
                v238->data[v113] = -1;
              goto LABEL_215;
            }
            if ( v240 - v168 < _EDI )
            {
LABEL_215:
              if ( !v229 && !Stream_TransientZoneStreamingQualitySufficient(v113) )
              {
                v169 = 0;
                v170 = 0;
                do
                {
                  if ( v170 )
                    v171 = v247[v170 - 1];
                  else
                    v171 = v232;
                  if ( v171 )
                  {
                    if ( v171 >= 0x600 )
                    {
                      LODWORD(v218) = 1536;
                      LODWORD(v217) = v171;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                        __debugbreak();
                    }
                    v172 = 0x80000000 >> (v171 & 0x1F);
                    v173 = (unsigned __int64)v171 >> 5;
                    if ( (v172 & *(_DWORD *)&v239[4 * v173]) != 0 )
                    {
                      if ( v171 >= 0x600 )
                      {
                        LODWORD(v218) = 1536;
                        LODWORD(v217) = v171;
                        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v217, v218) )
                          __debugbreak();
                      }
                      if ( (v172 & s_transientsWorldMP.loaded.array[v173]) != 0 )
                        ++v169;
                    }
                  }
                  ++v170;
                }
                while ( v170 < v230 );
                v113 = v234;
                if ( v169 > 1 )
                {
                  LODWORD(v224) = 1;
                  LODWORD(v219) = v169;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1692, ASSERT_TYPE_ASSERT, "( visibleCount ) <= ( 1 )", "%s <= %s\n\t%u, %u", "visibleCount", "1", v219, v224) )
                    __debugbreak();
                }
                if ( !v169 )
                {
                  v238->data[v234] = 0;
                  goto LABEL_241;
                }
                v111 = v237;
                v14 = v239;
                if ( !v238->data[v234] )
                  goto LABEL_241;
                goto LABEL_262;
              }
            }
            v238->data[v113] = 0;
            goto LABEL_241;
          }
LABEL_266:
          v237 = ++v111;
          v242 = ++v112;
          v101 = v230;
        }
        while ( v111 < v230 );
        v103 = v243;
LABEL_268:
        v232 = ++v102;
        v243 = ++v103;
        if ( v102 >= v241 )
        {
          v15 = v244;
          break;
        }
      }
    }
    v179 = &v15->array[47];
    if ( v15 > &v14[188] || v179 < (unsigned int *)v14 )
    {
      _RAX = &v15->array[4];
      _RCX = (bitarray<1536> *)v14 - v15;
      v183 = 3i64;
      v186 = 3i64;
      do
      {
        __asm
        {
          vmovdqu xmm1, xmmword ptr [rcx+rax-10h]
          vpor    xmm1, xmm1, xmmword ptr [rax-10h]
          vmovdqu xmmword ptr [rax-10h], xmm1
          vmovdqu xmm2, xmmword ptr [rcx+rax]
          vpor    xmm1, xmm2, xmmword ptr [rax]
          vmovdqu xmmword ptr [rax], xmm1
          vmovdqu xmm1, xmmword ptr [rcx+rax+10h]
          vpor    xmm1, xmm1, xmmword ptr [rax+10h]
          vmovdqu xmmword ptr [rax+10h], xmm1
          vmovdqu xmm1, xmmword ptr [rcx+rax+20h]
          vpor    xmm1, xmm1, xmmword ptr [rax+20h]
          vmovdqu xmmword ptr [rax+20h], xmm1
        }
        _RAX += 16;
        --v186;
      }
      while ( v186 );
      v181 = 48i64;
    }
    else
    {
      v180 = v15;
      v181 = 48i64;
      v182 = 48i64;
      do
      {
        v180->array[0] |= *(unsigned int *)((char *)v180->array + (bitarray<1536> *)v14 - v15);
        v180 = (bitarray<1536> *)((char *)v180 + 4);
        --v182;
      }
      while ( v182 );
      v183 = 3i64;
    }
    v195 = visibleBitArray;
    if ( v15 > (bitarray<1536> *)&visibleBitArray->array[47] || v179 < (unsigned int *)visibleBitArray )
    {
      _RAX = &v15->array[4];
      _RCX = (char *)visibleBitArray - (char *)v15;
      do
      {
        __asm
        {
          vmovdqu xmm1, xmmword ptr [rcx+rax-10h]
          vpor    xmm1, xmm1, xmmword ptr [rax-10h]
          vmovdqu xmmword ptr [rax-10h], xmm1
          vmovdqu xmm2, xmmword ptr [rcx+rax]
          vpor    xmm1, xmm2, xmmword ptr [rax]
          vmovdqu xmmword ptr [rax], xmm1
          vmovdqu xmm1, xmmword ptr [rcx+rax+10h]
          vpor    xmm1, xmm1, xmmword ptr [rax+10h]
          vmovdqu xmmword ptr [rax+10h], xmm1
          vmovdqu xmm1, xmmword ptr [rcx+rax+20h]
          vpor    xmm1, xmm1, xmmword ptr [rax+20h]
          vmovdqu xmmword ptr [rax+20h], xmm1
        }
        _RAX += 16;
        --v183;
      }
      while ( v183 );
    }
    else
    {
      v196 = v15;
      do
      {
        v196->array[0] |= *(unsigned int *)((char *)v196->array + (char *)visibleBitArray - (char *)v15);
        v196 = (bitarray<1536> *)((char *)v196 + 4);
        --v181;
      }
      while ( v181 );
    }
  }
  *(_DWORD *)v14 |= 0x80000000;
  v195->array[0] |= 0x80000000;
  v15->array[0] |= 0x80000000;
  CL_TransientsWorld_SetVisibilityBitArray(localClient, (const bitarray<1536> *)v14, v15);
  Sys_ProfEndNamedEvent();
  _R11 = &v275;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
CL_TransientsWorldMP_UpdateLocalClientVisibilityPos
==============
*/
void CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(const LocalClientNum_t localClient, bitarray<1536> *visibleBitArray, bitarray<1536> *visibleHintBitArray, const WorldStreamPosition *streamPos, float *distanceSqToStreamPos)
{
  signed __int64 v5; 
  void *v17; 
  __int64 v20; 
  SpatialPartition_Tree *transientWorldGridSpatial; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned int v32; 
  __int64 v60; 
  unsigned int v63; 
  unsigned int v64; 
  unsigned int v65; 
  __int64 v81; 
  bitarray<1536> *v82; 
  unsigned int v83; 
  unsigned __int64 v84; 
  bitarray<1536> *v85; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v97; 
  const dvar_t *v99; 
  unsigned int v100; 
  unsigned int v101; 
  unsigned __int64 v102; 
  bool v114; 
  __int64 v126; 
  __int64 v127; 
  __int64 v128; 
  __int64 v129; 
  __int64 v130; 
  char v131[9104]; 
  __int64 v132; 
  char v143; 

  v17 = alloca(v5);
  v132 = -2i64;
  __asm
  {
    vmovaps [rsp+24F8h+var_58], xmm6
    vmovaps [rsp+24F8h+var_68], xmm7
    vmovaps [rsp+24F8h+var_78], xmm8
    vmovaps [rsp+24F8h+var_88], xmm9
    vmovaps [rsp+24F8h+var_98], xmm10
    vmovaps [rsp+24F8h+var_A8], xmm11
    vmovaps [rsp+24F8h+var_B8], xmm12
    vmovaps [rsp+24F8h+var_C8], xmm13
    vmovaps [rsp+24F8h+var_D8], xmm14
    vmovaps [rsp+24F8h+var_E8], xmm15
  }
  _RBP = (unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_QWORD *)(_RBP + 9096) = (unsigned __int64)&v126 ^ _security_cookie;
  _RBX = streamPos;
  *(_QWORD *)(_RBP + 16) = streamPos;
  *(_QWORD *)(_RBP + 32) = visibleHintBitArray;
  *(_QWORD *)(_RBP + 24) = visibleBitArray;
  v20 = localClient;
  _RSI = distanceSqToStreamPos;
  *(_QWORD *)(_RBP + 8) = distanceSqToStreamPos;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLocalClientVisibilityPos");
  CL_TransientsWorldMP_GetVisibilityCenterPos(_RBX, (vec3_t *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 88));
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0);
  __asm
  {
    vmulss  xmm0, xmm0, cs:s_transientsWorldMP.radiusMultiplier
    vmovss  dword ptr [rbp+70h], xmm0
  }
  *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadius(1u, &_RBX->pos);
  __asm { vmovss  dword ptr [rbp+74h], xmm0 }
  CL_TransientsWorldMP_GetWorldStreamParamsInternal((WorldStreamParameters *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 104), &_RBX->pos);
  transientWorldGridSpatial = s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial;
  if ( transientWorldGridSpatial )
  {
    if ( _RBX->zoomVisibility )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+38h]
        vmulss  xmm2, xmm0, xmm0
        vmovss  dword ptr [rbp+0], xmm2
        vmovss  xmm1, dword ptr [rbx+3Ch]
        vmulss  xmm0, xmm1, xmm1
        vmovss  dword ptr [rbp+4], xmm0
        vmaxss  xmm15, xmm0, xmm2
      }
      *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) = 0i64;
      *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248) = 0;
      *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) = 0i64;
      *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) = 0i64;
      SpatialPartition_Tree_FrustumIterator::Init((SpatialPartition_Tree_FrustumIterator *)(_RBP + 4480), transientWorldGridSpatial, _RBX->frustumPlanes, 5u);
      if ( SpatialPartition_Tree_FrustumIterator::Advance((SpatialPartition_Tree_FrustumIterator *)(_RBP + 4480)) )
      {
        __asm { vmovss  xmm14, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff }
        do
        {
          if ( !*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
            __debugbreak();
          v30 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) + 20i64);
          v31 = *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248);
          if ( v31 == v30 )
          {
            if ( !*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
              __debugbreak();
            if ( (**(_BYTE **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
              __debugbreak();
            if ( *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) >= **(unsigned __int8 **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
              __debugbreak();
            v32 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) + 4i64 * *(unsigned int *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) + 4);
          }
          else
          {
            if ( v31 >= v30 )
            {
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
                __debugbreak();
              v31 = *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248);
            }
            v32 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) + 8i64) + 4i64 * v31);
          }
          if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1141, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
            __debugbreak();
          if ( v32 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
          {
            LODWORD(v128) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
            LODWORD(v127) = v32;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1142, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v127, v128) )
              __debugbreak();
          }
          _RCX = 3i64 * v32;
          _RDX = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
          _RAX = _RBX->frustumPlanes;
          __asm
          {
            vmovss  xmm8, dword ptr [rdx+rcx*8]
            vmovss  xmm9, dword ptr [rdx+rcx*8+4]
            vmovss  xmm10, dword ptr [rdx+rcx*8+8]
            vmovss  xmm11, dword ptr [rdx+rcx*8+0Ch]
            vmovss  xmm12, dword ptr [rdx+rcx*8+10h]
            vmovss  xmm13, dword ptr [rdx+rcx*8+14h]
            vmovss  xmm6, dword ptr [rax+8]
            vandps  xmm7, xmm6, xmm14
            vmovss  xmm4, dword ptr [rax+4]
            vandps  xmm5, xmm4, xmm14
            vmovss  xmm0, dword ptr [rax]
            vandps  xmm1, xmm0, xmm14
            vmulss  xmm0, xmm8, xmm0
            vaddss  xmm2, xmm0, dword ptr [rax+0Ch]
            vmulss  xmm1, xmm11, xmm1
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm9, xmm4
            vaddss  xmm4, xmm3, xmm0
            vmulss  xmm1, xmm5, xmm12
            vaddss  xmm2, xmm4, xmm1
            vmulss  xmm0, xmm10, xmm6
            vaddss  xmm3, xmm2, xmm0
            vmulss  xmm1, xmm7, xmm13
            vaddss  xmm4, xmm3, xmm1
            vcomiss xmm4, cs:__real@00000000
          }
        }
        while ( SpatialPartition_Tree_FrustumIterator::Advance((SpatialPartition_Tree_FrustumIterator *)(_RBP + 4480)) );
        _RSI = *(float **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
      }
    }
    *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) = 0i64;
    *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168) = 0;
    *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) = 0i64;
    *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) = 0i64;
    __asm { vmovss  xmm3, dword ptr [rbp+94h]; radius }
    SpatialPartition_Tree_SphereIterator::Init((SpatialPartition_Tree_SphereIterator *)(_RBP + 160), s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial, (const vec3_t *)(_RBP + 88), *(float *)&_XMM3);
    if ( SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(_RBP + 160)) )
    {
      v60 = v20;
      *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = v20;
      __asm
      {
        vmovss  xmm9, dword ptr [rbp+98h]
        vmovss  xmm8, dword ptr [rbp+80h]
      }
      do
      {
        if ( !*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
          __debugbreak();
        v63 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) + 20i64);
        v64 = *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168);
        if ( v64 == v63 )
        {
          if ( !*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
            __debugbreak();
          if ( (**(_BYTE **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
            __debugbreak();
          if ( *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) >= **(unsigned __int8 **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
            __debugbreak();
          v65 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) + 4i64 * *(unsigned int *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) + 4);
        }
        else
        {
          if ( v64 >= v63 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
              __debugbreak();
            v64 = *(_DWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168);
          }
          v65 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) + 8i64) + 4i64 * v64);
        }
        if ( !v65 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1209, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
          __debugbreak();
        if ( v65 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        {
          LODWORD(v128) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
          LODWORD(v127) = v65;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1210, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v127, v128) )
            __debugbreak();
        }
        _R15 = v65;
        _RDX = 3i64 * v65;
        _RCX = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
        __asm
        {
          vmovss  xmm0, dword ptr [rcx+rdx*8]
          vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+0Ch]
          vmovss  dword ptr [rbp+40h], xmm1
          vmovss  xmm0, dword ptr [rcx+rdx*8+4]
          vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+10h]
          vmovss  dword ptr [rbp+44h], xmm1
          vmovss  xmm0, dword ptr [rcx+rdx*8+8]
          vsubss  xmm1, xmm0, dword ptr [rcx+rdx*8+14h]
          vmovss  dword ptr [rbp+48h], xmm1
          vmovss  xmm0, dword ptr [rcx+rdx*8]
          vaddss  xmm1, xmm0, dword ptr [rcx+rdx*8+0Ch]
          vmovss  dword ptr [rbp+4Ch], xmm1
          vmovss  xmm2, dword ptr [rcx+rdx*8+10h]
          vaddss  xmm0, xmm2, dword ptr [rcx+rdx*8+4]
          vmovss  dword ptr [rbp+50h], xmm0
          vmovss  xmm1, dword ptr [rcx+rdx*8+14h]
          vaddss  xmm2, xmm1, dword ptr [rcx+rdx*8+8]
          vmovss  dword ptr [rbp+54h], xmm2
        }
        PointToClosestAABBPoint((const vec3_t *)(_RBP + 64), (const vec3_t *)(_RBP + 76), (const vec3_t *)(_RBP + 88), (vec3_t *)(_RBP + 48));
        if ( _RBX->fallingHint )
        {
          v81 = v60;
          v82 = &s_transientsWorldMP.visibleCurrent[v60];
          if ( v65 >= 0x600 )
          {
            LODWORD(v128) = 1536;
            LODWORD(v127) = v65;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v127, v128) )
              __debugbreak();
          }
          v83 = 0x80000000 >> (v65 & 0x1F);
          v84 = (unsigned __int64)v65 >> 5;
          if ( (v83 & v82->array[v84]) != 0 )
            goto LABEL_68;
          v85 = &s_transientsWorldMP.visibleTarget[v81];
          if ( v65 >= 0x600 )
          {
            LODWORD(v128) = 1536;
            LODWORD(v127) = v65;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v127, v128) )
              __debugbreak();
          }
          if ( (v83 & v85->array[v84]) != 0 )
          {
LABEL_68:
            __asm
            {
              vxorps  xmm10, xmm10, xmm10
              vmovss  dword ptr [rbp+38h], xmm10
            }
            if ( v65 >= 0x600 )
            {
              LODWORD(v130) = 1536;
              LODWORD(v129) = v65;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v129, v130) )
                __debugbreak();
            }
            s_transientsWorldMP.fallingHinted.array[v84] |= v83;
          }
          else
          {
            __asm { vxorps  xmm10, xmm10, xmm10 }
          }
          _RSI = *(float **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
        }
        else
        {
          __asm { vxorps  xmm10, xmm10, xmm10 }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+34h]
          vmulss  xmm3, xmm0, xmm0
          vmovss  xmm1, dword ptr [rbp+30h]
          vmulss  xmm2, xmm1, xmm1
          vaddss  xmm7, xmm3, xmm2
          vmovss  xmm0, dword ptr [rbp+38h]
          vmulss  xmm1, xmm0, xmm0
          vaddss  xmm2, xmm1, xmm7
        }
        if ( _RSI )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rsi+r15*4]
            vminss  xmm1, xmm0, xmm2
            vmovss  dword ptr [rsi+r15*4], xmm1
          }
        }
        __asm { vcomiss xmm2, xmm9 }
        if ( !_RSI )
        {
          HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v65);
          *(_QWORD *)_RBP = HighLODLookups;
          v97 = 0;
          _R15 = _RBP + 120;
          while ( 1 )
          {
            v99 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
            if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v99);
            if ( (signed int)v97 >= v99->current.integer )
            {
              v100 = v97 ? HighLODLookups[v97 - 1] : v65;
              if ( v100 )
              {
                if ( v100 >= 0x600 )
                {
                  LODWORD(v128) = 1536;
                  LODWORD(v127) = v100;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v127, v128) )
                    __debugbreak();
                }
                v101 = 0x80000000 >> (v100 & 0x1F);
                v102 = (unsigned __int64)v100 >> 5;
                if ( (v101 & *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) + 4 * v102)) != 0 )
                {
LABEL_107:
                  _RSI = *(float **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
                  break;
                }
                if ( v100 >= 0x600 )
                {
                  LODWORD(v128) = 1536;
                  LODWORD(v127) = v100;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v127, v128) )
                    __debugbreak();
                }
                if ( (v101 & s_transientsWorldMP.loaded.array[v102]) != 0 && (s_transientsWorldMP.ignoreTransientSkip || v100 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v100)) )
                {
                  __asm
                  {
                    vmovss  xmm0, dword ptr [r15-10h]
                    vmulss  xmm1, xmm0, dword ptr [rbp+38h]
                    vmulss  xmm2, xmm1, xmm1
                    vaddss  xmm6, xmm2, xmm7
                    vmovss  xmm0, dword ptr [r15]
                    vcomiss xmm0, xmm6
                  }
                  if ( *(_BYTE *)(*(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) + 149i64) && !v97 )
                    __asm { vucomiss xmm8, xmm10 }
                }
                else
                {
                  _RBX = *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10);
                  if ( *(_BYTE *)(_RBX + 149) )
                  {
                    if ( *(_BYTE *)(_RBX + 148) )
                    {
                      __asm { vcomiss xmm10, dword ptr [rbx+90h] }
                      if ( !*(_BYTE *)(_RBX + 148) )
                      {
                        __asm
                        {
                          vmovss  xmm0, dword ptr [r15-10h]
                          vmulss  xmm1, xmm0, dword ptr [rbp+38h]
                          vmulss  xmm2, xmm1, xmm1
                          vaddss  xmm6, xmm2, xmm7
                          vmovss  xmm0, dword ptr [r15]
                          vcomiss xmm0, xmm6
                        }
                      }
                    }
                  }
                }
                HighLODLookups = *(unsigned __int16 **)_RBP;
              }
            }
            ++v97;
            _R15 += 4i64;
            if ( v97 >= 2 )
              goto LABEL_107;
          }
        }
        v114 = SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(_RBP + 160));
        _RBX = *(const WorldStreamPosition **)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10);
        v60 = *(_QWORD *)(((unsigned __int64)v131 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
      }
      while ( v114 );
    }
  }
  Sys_ProfEndNamedEvent();
  _R11 = &v143;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
    vmovaps xmm15, xmmword ptr [r11-0A8h]
  }
}

/*
==============
CL_TransientsWorldMP_UpdateMissingModels
==============
*/
void CL_TransientsWorldMP_UpdateMissingModels(void)
{
  __int64 v0; 
  bitarray<1536> *p_missingModelTransients; 
  unsigned int v2; 
  unsigned __int64 v3; 
  const char *v4; 
  unsigned int v5; 
  unsigned __int64 v6; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v8; 
  XModel *ProxyModel; 
  const char *name; 
  __int64 v11; 
  signed __int64 v12; 
  char v13; 
  __int64 v14; 
  char v15; 
  __int64 v16; 
  unsigned __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  __int64 v21; 

  if ( rgp.world )
  {
    v0 = 3i64;
    p_missingModelTransients = &s_transientsWorldMP.missingModelTransients;
    *(_WORD *)&s_transientsWorldMP.anyMissingModels = 0;
    do
    {
      *(_QWORD *)p_missingModelTransients->array = 0i64;
      *(_QWORD *)&p_missingModelTransients->array[2] = 0i64;
      *(_QWORD *)&p_missingModelTransients->array[4] = 0i64;
      p_missingModelTransients = (bitarray<1536> *)((char *)p_missingModelTransients + 64);
      *(_QWORD *)&p_missingModelTransients[-1].array[38] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[40] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[42] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[44] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[46] = 0i64;
      --v0;
    }
    while ( v0 );
    v20 = 0;
    v2 = 0;
    v21 = 0i64;
    v3 = 0i64;
    v4 = "default_static_model";
    do
    {
      v5 = 0x80000000 >> (v2 & 0x1F);
      v6 = v3 >> 5;
      if ( (v5 & s_transientsWorldMP.transientsBaseLOD.array[v6]) != 0 )
      {
        HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v2);
        if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2422, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0") )
          __debugbreak();
        v8 = HighLODLookups[s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount - 1];
        ProxyModel = CL_TransientsWorldMP_FindProxyModel(v8);
        if ( ProxyModel )
        {
          name = ProxyModel->name;
          v11 = 0x7FFFFFFFi64;
          if ( !ProxyModel->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
            __debugbreak();
          v12 = name - "default_static_model";
          do
          {
            v13 = v4[v12];
            v14 = v11;
            v15 = *v4++;
            --v11;
            if ( !v14 )
              break;
            if ( v13 != v15 )
              goto LABEL_23;
          }
          while ( v13 );
          Com_PrintWarning(16, "Proxy for transient %u is using default model, need to recompile d3dbsp!\n", v8);
          s_transientsWorldMP.anyMissingModels = 1;
          v16 = 0i64;
          s_transientsWorldMP.missingModelTransients.array[v6] |= v5;
          if ( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
          {
            do
            {
              v17 = HighLODLookups[v16];
              if ( (unsigned int)v17 >= 0x600 )
              {
                LODWORD(v19) = 1536;
                LODWORD(v18) = HighLODLookups[v16];
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
                  __debugbreak();
              }
              v16 = (unsigned int)(v16 + 1);
              s_transientsWorldMP.missingModelTransients.array[v17 >> 5] |= 0x80000000 >> (v17 & 0x1F);
            }
            while ( (unsigned int)v16 < s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount );
            v2 = v20;
          }
LABEL_23:
          v4 = "default_static_model";
        }
      }
      v3 = v21 + 1;
      v20 = ++v2;
      ++v21;
    }
    while ( v2 < 0x600 );
  }
}

/*
==============
CL_TransientsWorldMP_UpdatePageBudget
==============
*/
void CL_TransientsWorldMP_UpdatePageBudget()
{
  signed __int64 v0; 
  void *v2; 
  int v3; 
  bool inLobbyState; 
  unsigned int ZoneFlagsFromIndex; 
  char IsAnyLocalServerRunning; 
  char finishedLoading; 
  char v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  const dvar_t *v11; 
  __int64 v17; 
  const dvar_t *v18; 
  __int64 v19; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  const dvar_t *v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 uiSize; 
  __int64 v34; 
  __int64 v35; 
  int v36[2]; 
  MemBudget_PollData outPoll; 
  char v39; 

  v2 = alloca(v0);
  __asm { vmovaps [rsp+4088h+var_38], xmm6 }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdatePageBudget");
  v3 = 0;
  v36[0] = 0;
  inLobbyState = 0;
  if ( s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.zoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 532, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX") )
      __debugbreak();
    ZoneFlagsFromIndex = DB_Zones_GetZoneFlagsFromIndex(s_transientsWorldMP.zoneIndex);
    IsAnyLocalServerRunning = Com_IsAnyLocalServerRunning();
    HIBYTE(v36[0]) = IsAnyLocalServerRunning;
    if ( (ZoneFlagsFromIndex & 0x100000) != 0 )
    {
      finishedLoading = s_transientsWorldMP.finishedLoading;
    }
    else
    {
      finishedLoading = 1;
      BYTE2(v36[0]) = s_transientsWorldMP.finishedLoading;
    }
    BYTE1(v36[0]) = finishedLoading;
    if ( Com_FrontEndScene_IsActive() || Com_FrontEnd_IsInFrontEnd() || !s_transientsWorldMP.preloadingBackToFE )
    {
      v8 = 0;
      LOBYTE(v36[0]) = 0;
      inLobbyState = s_transientsWorldMP.inLobbyState;
      v3 = v36[0];
    }
    else
    {
      v8 = 1;
      LOBYTE(v36[0]) = 1;
      inLobbyState = s_transientsWorldMP.inLobbyState;
      v3 = v36[0];
    }
  }
  else
  {
    IsAnyLocalServerRunning = HIBYTE(v36[0]);
    finishedLoading = BYTE1(v36[0]);
    v8 = v36[0];
  }
  if ( finishedLoading != s_transientsWorldMP.lastFastfileState.preloaded || BYTE2(v36[0]) != s_transientsWorldMP.lastFastfileState.loaded || IsAnyLocalServerRunning != s_transientsWorldMP.lastFastfileState.hasServer || v8 != s_transientsWorldMP.lastFastfileState.backtoFE || inLobbyState != s_transientsWorldMP.lastFastfileState.inLobbyState )
  {
    v9 = 0i64;
    v10 = 0i64;
    MemBudget_BudgetFile_Update();
    if ( !s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    {
      MemBudget_Poll_Oneoff(&outPoll);
      v11 = DVARINT_cl_worldStreamingQuality;
      if ( !DVARINT_cl_worldStreamingQuality && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_worldStreamingQuality") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      _RSI = v11->current.integer;
      if ( (int)_RSI >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2250, ASSERT_TYPE_ASSERT, "(qualityLevel < 2)", (const char *)&queryFormat, "qualityLevel < 2") )
        __debugbreak();
      _RBX = DVARVEC2_cl_transientWorldMemoryMaxMB;
      if ( !DVARVEC2_cl_transientWorldMemoryMaxMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMaxMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  [rsp+4088h+var_4030], xmm0
        vmovss  xmm1, dword ptr [rbx+2Ch]
        vmovss  [rsp+4088h+var_402C], xmm1
      }
      if ( (unsigned int)_RSI >= 2 )
      {
        LODWORD(v35) = 2;
        LODWORD(v34) = _RSI;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v34, v35) )
          __debugbreak();
      }
      __asm { vcvttss2si rbp, [rsp+rsi*4+4088h+var_4030] }
      v17 = _RBP << 20;
      v18 = DVARINT_cl_transientWorldMemoryMinMB;
      if ( !DVARINT_cl_transientWorldMemoryMinMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMinMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v18);
      v19 = v18->current.integer << 20;
      *(float *)&_XMM0 = CL_TransientsWorldMP_GetWorldTileBudgetMultiplier();
      __asm { vmovaps xmm6, xmm0 }
      v21 = outPoll.readings.pollValues[2];
      v22 = MemBudget_BudgetFile_GetCurrentBudgets()->pollValues[27];
      if ( Com_FrontEndScene_IsActive() || Com_FrontEnd_IsInFrontEnd() )
      {
        uiSize = outPoll.readings.pollValues[22];
        if ( s_transientsWorldMP.uiSize > (unsigned __int64)outPoll.readings.pollValues[22] )
          uiSize = s_transientsWorldMP.uiSize;
        s_transientsWorldMP.uiSize = uiSize;
      }
      else if ( s_transientsWorldMP.preloadingBackToFE )
      {
        v23 = s_transientsWorldMP.uiSize;
        if ( !s_transientsWorldMP.uiSize )
        {
          v24 = DCONST_DVARINT_cl_transientWorldMemoryFrontendEstimateMB;
          if ( !DCONST_DVARINT_cl_transientWorldMemoryFrontendEstimateMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFrontendEstimateMB") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v24);
          v23 = v24->current.integer << 20;
        }
        v25 = v23 - (outPoll.readings.pollValues[20] + outPoll.readings.pollValues[22]);
        v26 = 0i64;
        if ( v25 > 0 )
          v26 = v25;
        v21 -= v26;
      }
      _RBX = v22 - v19 + v21;
      if ( _RBX > 0 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rbx
          vmulss  xmm1, xmm0, xmm6
          vcvttss2si rbx, xmm1
        }
      }
      v10 = v19 + _RBX;
      if ( v19 > v17 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 773, ASSERT_TYPE_SANITY, "( min <= max )", (const char *)&queryFormat, "min <= max") )
        __debugbreak();
      if ( v17 < v10 )
        v10 = v17;
      if ( v19 > v10 )
        v10 = v19;
    }
    if ( v10 > 0 )
      v9 = v10;
    if ( v9 != s_transientsWorldMP.tileBudget )
    {
      s_transientsWorldMP.tileBudget = v9;
      MemBudget_BudgetFile_Update();
    }
    *(_DWORD *)&s_transientsWorldMP.lastFastfileState.backtoFE = v3;
    s_transientsWorldMP.lastFastfileState.inLobbyState = inLobbyState;
  }
  Sys_ProfEndNamedEvent();
  _R11 = &v39;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
CL_TransientsWorldMP_UpdateStreamProgress
==============
*/
void CL_TransientsWorldMP_UpdateStreamProgress(bool printProgress)
{
  unsigned int v3; 
  unsigned __int64 v5; 
  unsigned int v6; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v8; 
  unsigned __int64 v9; 
  unsigned int v10; 
  unsigned __int64 v11; 
  XModel *ProxyModel; 
  Material **materialHandles; 
  __int64 v14; 
  Material *v15; 
  unsigned int v16; 
  const char **v17; 
  __int64 v18; 
  unsigned __int8 *v19; 
  const GfxImage *image; 
  int v21; 
  int v22; 
  unsigned __int8 v23; 
  bool v36; 
  __int64 v38; 
  double v39; 
  double v40; 
  double v41; 
  __int64 v42; 
  int v43; 
  XModel *v44; 
  unsigned __int16 *v45; 
  __int64 v46; 
  Material **v47; 
  __int64 v48[3]; 
  unsigned int v51; 
  unsigned int v52; 
  unsigned int v53; 

  v3 = 1;
  __asm
  {
    vmovaps [rsp+0D8h+var_58], xmm6
    vmovsd  xmm6, cs:__real@43f0000000000000
  }
  v53 = 1;
  v46 = 1i64;
  v5 = 1i64;
  do
  {
    if ( ((0x80000000 >> (v3 & 0x1F)) & s_transientsWorldMP.transientsBaseLOD.array[v5 >> 5]) != 0 )
    {
      v6 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount + 1;
      v51 = v6;
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v3);
      v8 = 1;
      v45 = HighLODLookups;
      v52 = 1;
      if ( v6 > 1 )
      {
        while ( 1 )
        {
          v9 = *HighLODLookups;
          if ( !*HighLODLookups )
            goto LABEL_52;
          if ( (unsigned int)v9 >= 0x600 )
          {
            LODWORD(v42) = 1536;
            LODWORD(v38) = *HighLODLookups;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v38, v42) )
              __debugbreak();
          }
          v10 = 0x80000000 >> (v9 & 0x1F);
          v11 = v9;
          if ( (v10 & s_transientsWorldMP.loaded.array[v9 >> 5]) == 0 )
            break;
          if ( (unsigned int)v9 >= 0x600 )
          {
            LODWORD(v42) = 1536;
            LODWORD(v38) = v9;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v38, v42) )
              __debugbreak();
          }
          if ( (v10 & s_transientsWorldMP.visibleHint[0].array[v9 >> 5]) == 0 )
            break;
          if ( !s_transientsWorldMP.streamProgressStartTime[v9] )
          {
            s_transientsWorldMP.streamProgressStartTime[v9] = __rdtsc();
            s_transientsWorldMP.streamProgressStartFrame[v9] = s_transientsWorldMP.streamProgressCurrentFrame;
          }
          ProxyModel = CL_TransientsWorldMP_FindProxyModel(v9);
          v44 = ProxyModel;
          if ( ProxyModel )
          {
            materialHandles = ProxyModel->materialHandles;
            v14 = 0i64;
            v43 = 0;
            v47 = materialHandles;
            if ( ProxyModel->numsurfs )
            {
              do
              {
                v15 = materialHandles[v14];
                if ( v15 )
                {
                  v16 = 0;
                  v48[0] = (__int64)"color";
                  v17 = (const char **)v48;
                  v18 = 0i64;
                  v48[1] = (__int64)"normal";
                  v19 = s_transientsWorldMP.streamProgressTextureState[v11];
                  do
                  {
                    if ( v16 < v15->textureCount )
                    {
                      image = v15->textureTable[v18].image;
                      if ( image )
                      {
                        v21 = Stream_Debug_CalcWantedBytesForImage(image);
                        v22 = Stream_Debug_CalcBytesLoadedForImage(v15->textureTable[v18].image);
                        if ( v21 > 0 )
                        {
                          v23 = *v19;
                          if ( (*v19 & 1) == 0 )
                          {
                            if ( printProgress )
                            {
                              __asm
                              {
                                vxorps  xmm0, xmm0, xmm0
                                vcvtsi2sd xmm0, xmm0, rax
                              }
                              if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v11]) < 0 )
                                __asm { vaddsd  xmm0, xmm0, xmm6 }
                              __asm { vmulsd  xmm0, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick }
                              LODWORD(v42) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v11];
                              __asm
                              {
                                vcvtsd2ss xmm1, xmm0, xmm0
                                vcvtss2sd xmm2, xmm1, xmm1
                                vmovsd  [rsp+0D8h+var_B0], xmm2
                              }
                              Sys_Printf("Transient %u lod %u (%u) %s wanted data after %.3f ms (%d frames)\n", v53, v52, (unsigned int)v11, *v17, v39, v42);
                              v23 = *v19;
                            }
                            v23 |= 1u;
                            *v19 = v23;
                          }
                          if ( v22 == v21 )
                          {
                            if ( (v23 & 4) == 0 )
                            {
                              if ( printProgress )
                              {
                                __asm
                                {
                                  vxorps  xmm0, xmm0, xmm0
                                  vcvtsi2sd xmm0, xmm0, rax
                                }
                                if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v11]) < 0 )
                                  __asm { vaddsd  xmm0, xmm0, xmm6 }
                                __asm { vmulsd  xmm0, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick }
                                LODWORD(v42) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v11];
                                __asm
                                {
                                  vcvtsd2ss xmm1, xmm0, xmm0
                                  vcvtss2sd xmm2, xmm1, xmm1
                                  vmovsd  [rsp+0D8h+var_B0], xmm2
                                }
                                Sys_Printf("Transient %u lod %u (%u) %s completed data after %.3f ms (%d frames)\n", v53, v52, (unsigned int)v11, *v17, v40, v42);
                                v23 = *v19;
                              }
                              *v19 = v23 | 6;
                            }
                          }
                          else if ( v22 > 0 && (v23 & 2) == 0 )
                          {
                            if ( printProgress )
                            {
                              __asm
                              {
                                vxorps  xmm0, xmm0, xmm0
                                vcvtsi2sd xmm0, xmm0, rax
                              }
                              if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v11]) < 0 )
                                __asm { vaddsd  xmm0, xmm0, xmm6 }
                              __asm { vmulsd  xmm0, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick }
                              LODWORD(v42) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v11];
                              __asm
                              {
                                vcvtsd2ss xmm1, xmm0, xmm0
                                vcvtss2sd xmm2, xmm1, xmm1
                                vmovsd  [rsp+0D8h+var_B0], xmm2
                              }
                              Sys_Printf("Transient %u lod %u (%u) %s got some data after %.3f ms (%d frames)\n", v53, v52, (unsigned int)v11, *v17, v41, v42);
                              v23 = *v19;
                            }
                            *v19 = v23 | 2;
                          }
                        }
                      }
                    }
                    ++v16;
                    ++v18;
                    ++v19;
                    ++v17;
                  }
                  while ( v16 < 2 );
                  ProxyModel = v44;
                  materialHandles = v47;
                }
                v14 = (unsigned int)(v43 + 1);
                v36 = (unsigned int)v14 < ProxyModel->numsurfs;
                ++v43;
                ProxyModel = v44;
              }
              while ( v36 );
              v8 = v52;
            }
          }
          v6 = v51;
LABEL_47:
          HighLODLookups = v45 + 1;
          v52 = ++v8;
          ++v45;
          if ( v8 >= v6 )
          {
            v3 = v53;
            v5 = v46;
            goto LABEL_49;
          }
        }
        v6 = v51;
LABEL_52:
        if ( s_transientsWorldMP.streamProgressStartTime[v9] )
        {
          s_transientsWorldMP.streamProgressStartTime[v9] = 0i64;
          s_transientsWorldMP.streamProgressStartFrame[v9] = 0;
          *(_WORD *)&s_transientsWorldMP.streamProgressTextureState[v9][0] = 0;
        }
        goto LABEL_47;
      }
    }
LABEL_49:
    ++v3;
    ++v5;
    v53 = v3;
    v46 = v5;
  }
  while ( v3 < 0x600 );
  __asm { vmovaps xmm6, [rsp+0D8h+var_58] }
}

/*
==============
CL_TransientsWorldMP_UseLowAlwaysloadedFlagging
==============
*/
_BOOL8 CL_TransientsWorldMP_UseLowAlwaysloadedFlagging()
{
  return s_transientsWorldMP.isLowFlaggingMap;
}

/*
==============
CL_TransientsWorldMP_ValidateGameStartAssumptions
==============
*/
char CL_TransientsWorldMP_ValidateGameStartAssumptions()
{
  char result; 
  unsigned int numStreamPositions; 

  if ( s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3618, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
      __debugbreak();
    if ( !s_transientsWorldMP.inLobbyState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3619, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.inLobbyState)", (const char *)&queryFormat, "s_transientsWorldMP.inLobbyState") )
      __debugbreak();
  }
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3621, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.preloadingBackToFE)", (const char *)&queryFormat, "!s_transientsWorldMP.preloadingBackToFE") )
    __debugbreak();
  CL_TransientsWorldMPValidateVisibilityState();
  result = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions )
  {
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
    result = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3625, ASSERT_TYPE_ASSERT, "( s_transientsWorldMP.numStreamPositions ) == ( 0 )", "%s == %s\n\t%u, %u", "s_transientsWorldMP.numStreamPositions", "0", numStreamPositions, 0i64);
    if ( result )
      __debugbreak();
  }
  return result;
}

/*
==============
DB_TransientsWorldMP_GetCellDelayRemaining
==============
*/
__int64 DB_TransientsWorldMP_GetCellDelayRemaining(const unsigned int clientNum, const unsigned int baseTransient, int *outLodNumber)
{
  __int64 v3; 
  __int64 v5; 
  int v6; 
  int v7; 
  TransientZoneIntArray *v8; 
  bitarray_base<bitarray<1536> > *v9; 
  unsigned __int16 *HighLODLookups; 
  int v11; 
  unsigned __int16 v12; 
  unsigned __int64 v13; 
  int v14; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  TransientZoneIntArray *v20; 

  v3 = baseTransient;
  v5 = clientNum;
  if ( clientNum >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4067, ASSERT_TYPE_ASSERT, "(unsigned)( clientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.switchDelayStarted ) ) + 0 ) )", "clientNum doesn't index s_transientsWorldMP.switchDelayStarted\n\t%i not in [0, %i)", clientNum, 2) )
    __debugbreak();
  *outLodNumber = -1;
  v6 = 0;
  v7 = 0;
  v20 = &s_transientsWorldMP.switchDelayTarget[v5];
  v8 = &s_transientsWorldMP.switchDelayStarted[v5];
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v18) = 1536;
    LODWORD(v16) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4078, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransient ) < (unsigned)( ( sizeof( *array_counter( delayStartedArray.data ) ) + 0 ) )", "baseTransient doesn't index ARRAY_COUNT( delayStartedArray.data )\n\t%i not in [0, %i)", v16, v18) )
      __debugbreak();
  }
  v9 = &s_transientsWorldMP.visibleTarget[v5];
  if ( bitarray_base<bitarray<1536>>::testBit(v9, v3) )
  {
    *outLodNumber = 0;
    v6 = v8->data[v3];
    v7 = s_transientsWorldMP.switchDelayTarget[v5].data[v3];
  }
  else
  {
    HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v3);
    v11 = 0;
    if ( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
    {
      while ( 1 )
      {
        v12 = HighLODLookups[v11];
        if ( v12 )
        {
          v13 = v12;
          if ( v12 >= 0x600u )
          {
            LODWORD(v18) = 1536;
            LODWORD(v16) = v12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4094, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( ( sizeof( *array_counter( delayStartedArray.data ) ) + 0 ) )", "transientIndex doesn't index ARRAY_COUNT( delayStartedArray.data )\n\t%i not in [0, %i)", v16, v18) )
              __debugbreak();
            LODWORD(v19) = 1536;
            LODWORD(v17) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v17, v19) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v13 & 0x1F)) & *(_DWORD *)&v9[4 * (v13 >> 5)]) != 0 )
            break;
        }
        if ( ++v11 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
          goto LABEL_20;
      }
      *outLodNumber = v11 + 1;
      v6 = v8->data[v13];
      v7 = v20->data[v13];
    }
LABEL_20:
    if ( *outLodNumber < 0 )
      return 0i64;
  }
  v14 = Sys_Milliseconds() - v6;
  if ( v14 > 0 && v14 < v7 )
    return (unsigned int)(v7 - v14);
  return 0i64;
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds
==============
*/
Bounds *CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  unsigned int m_currentTransientIndex; 
  unsigned int v4; 
  unsigned int transientWorldGridBoundsCount; 

  m_currentTransientIndex = this->m_currentTransientIndex;
  if ( m_currentTransientIndex >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
  {
    transientWorldGridBoundsCount = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
    v4 = m_currentTransientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3878, ASSERT_TYPE_ASSERT, "(unsigned)( m_currentTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "m_currentTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v4, transientWorldGridBoundsCount) )
      __debugbreak();
  }
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[this->m_currentTransientIndex];
}

/*
==============
InterleavedPriorities::GetPriority
==============
*/
unsigned __int16 InterleavedPriorities::GetPriority(InterleavedPriorities *this, const unsigned __int64 tileIndex, const unsigned __int16 lod1Index, const bool insideLod0Cell)
{
  unsigned __int16 v8; 
  const dvar_t *v9; 
  unsigned __int16 v10; 
  unsigned __int16 spilloverIndex; 
  unsigned __int16 result; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  int v16; 

  if ( (unsigned int)tileIndex >= 0x15 )
  {
    v16 = 21;
    v14 = tileIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 433, ASSERT_TYPE_ASSERT, "(unsigned)( tileIndex ) < (unsigned)( ( sizeof( *array_counter( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES ) ) + 0 ) )", "tileIndex doesn't index ARRAY_COUNT( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES )\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  if ( lod1Index >= 4u )
  {
    LODWORD(v15) = 4;
    LODWORD(v13) = lod1Index;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 434, ASSERT_TYPE_ASSERT, "(unsigned)( lod1Index ) < (unsigned)( TRWORLD_LOD1TILES_IN_SLOT )", "lod1Index doesn't index TRWORLD_LOD1TILES_IN_SLOT\n\t%i not in [0, %i)", v13, v15) )
      __debugbreak();
  }
  v8 = truncate_cast<unsigned short,unsigned int>(CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES[tileIndex] - lod1Index);
  v9 = DCONST_DVARBOOL_cl_transientWorldSpilloverPriorities;
  v10 = v8;
  if ( !DCONST_DVARBOOL_cl_transientWorldSpilloverPriorities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSpilloverPriorities") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( !v9->current.enabled || !insideLod0Cell )
    return v10;
  if ( lod1Index && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 440, ASSERT_TYPE_ASSERT, "(lod1Index == 0)", (const char *)&queryFormat, "lod1Index == 0") )
    __debugbreak();
  if ( v10 > 0xF9Fu )
    return v10;
  spilloverIndex = this->spilloverIndex;
  if ( spilloverIndex >= 6u )
    return v10;
  result = truncate_cast<unsigned short,unsigned int>(CL_TRANSIENT_WORLD_CLOSE_SPILLOVER_PRIORITIES[spilloverIndex]);
  ++this->spilloverIndex;
  return result;
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Init
==============
*/
void CL_TransientsWorldMP_TransientChangedVisibleIterator::Init(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  if ( s_transientsWorldMP.systemEnabled )
  {
    this->m_wordIndex = 0;
    *(_QWORD *)&this->m_wordCount = 48i64;
    this->m_currentBits = s_transientsWorldMP.changedVisible.array[0];
  }
  else
  {
    *(_QWORD *)&this->m_wordIndex = 0i64;
    *(_QWORD *)&this->m_currentTransientIndex = 0i64;
  }
}

/*
==============
InterleavedPriorities::Insert
==============
*/
unsigned __int16 InterleavedPriorities::Insert(InterleavedPriorities *this, const unsigned int trIndex, const bool insideCell)
{
  __int64 v3; 
  bool v6; 
  unsigned __int16 result; 
  unsigned __int16 curLod1TileIndex; 
  unsigned __int16 Priority; 
  unsigned __int16 nextEmptyTileIndex; 
  __int64 v11; 
  __int64 v12; 

  v3 = trIndex;
  if ( trIndex )
  {
    if ( trIndex < 0x600 )
      goto LABEL_7;
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 462, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientLODIndex ) ) + 0 ) )", "trIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientLODIndex )\n\t%i not in [0, %i)", trIndex, 1536);
  }
  else
  {
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 460, ASSERT_TYPE_ASSERT, "(trIndex != TRANSIENT_ZONE_ALWAYSLOADED)", (const char *)&queryFormat, "trIndex != TRANSIENT_ZONE_ALWAYSLOADED");
  }
  if ( v6 )
    __debugbreak();
LABEL_7:
  if ( !s_transientsWorldMP.transientLODIndex[v3] )
  {
    if ( this->nextEmptyTileIndex < 0x15u )
    {
      result = InterleavedPriorities::GetPriority(this, this->nextEmptyTileIndex, 0, insideCell);
      ++this->nextEmptyTileIndex;
      return result;
    }
    goto LABEL_27;
  }
  if ( !this->nextLod1SubTileIndex )
  {
    if ( this->nextEmptyTileIndex < 0x15u )
    {
      Priority = InterleavedPriorities::GetPriority(this, this->nextEmptyTileIndex, 0, 0);
      if ( this->curLod1TileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 498, ASSERT_TYPE_ASSERT, "(curLod1TileIndex == 0)", (const char *)&queryFormat, "curLod1TileIndex == 0") )
        __debugbreak();
      if ( this->nextLod1SubTileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 499, ASSERT_TYPE_ASSERT, "(nextLod1SubTileIndex == 0)", (const char *)&queryFormat, "nextLod1SubTileIndex == 0") )
        __debugbreak();
      nextEmptyTileIndex = this->nextEmptyTileIndex;
      this->curLod1TileIndex = this->nextEmptyTileIndex;
      this->nextEmptyTileIndex = nextEmptyTileIndex + 1;
      this->nextLod1SubTileIndex = 1;
      return Priority;
    }
LABEL_27:
    Priority = this->nextFarIndex;
    if ( Priority < 0x356u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 512, ASSERT_TYPE_ASSERT, "( priority ) >= ( TRANSIENT_PRIORITY_VERY_FAR_GFX_TILES_LOW )", "%s >= %s\n\t%u, %u", "priority", "TRANSIENT_PRIORITY_VERY_FAR_GFX_TILES_LOW", Priority, 854) )
      __debugbreak();
    --this->nextFarIndex;
    return Priority;
  }
  curLod1TileIndex = this->curLod1TileIndex;
  if ( curLod1TileIndex >= 0x15u )
  {
    LODWORD(v12) = 21;
    LODWORD(v11) = curLod1TileIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 480, ASSERT_TYPE_ASSERT, "(unsigned)( curLod1TileIndex ) < (unsigned)( ( sizeof( *array_counter( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES ) ) + 0 ) )", "curLod1TileIndex doesn't index ARRAY_COUNT( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES )\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( this->curLod1TileIndex >= this->nextEmptyTileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 481, ASSERT_TYPE_ASSERT, "(curLod1TileIndex < nextEmptyTileIndex)", (const char *)&queryFormat, "curLod1TileIndex < nextEmptyTileIndex") )
    __debugbreak();
  result = InterleavedPriorities::GetPriority(this, this->curLod1TileIndex, this->nextLod1SubTileIndex, 0);
  if ( ++this->nextLod1SubTileIndex == 4 )
    *(_DWORD *)&this->curLod1TileIndex = 0;
  return result;
}

/*
==============
LinearRamp
==============
*/

float __fastcall LinearRamp(double value, double rampStart, double rampEnd)
{
  bool v9; 

  __asm
  {
    vcomiss xmm1, xmm2
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
    vmovaps xmm8, xmm2
    vmovaps xmm6, xmm1
    vmovaps xmm7, xmm0
  }
  v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 813, ASSERT_TYPE_ASSERT, "(rampStart <= rampEnd)", (const char *)&queryFormat, "rampStart <= rampEnd");
  if ( v9 )
    __debugbreak();
  __asm { vcomiss xmm7, xmm6 }
  if ( v9 )
  {
    __asm
    {
      vcomiss xmm7, xmm8
      vmovss  xmm0, cs:__real@3f800000
    }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  return *(float *)&_XMM0;
}

/*
==============
LinearRampSq
==============
*/

float __fastcall LinearRampSq(double valueSq, double rampStart, double rampEnd)
{
  bool v9; 

  __asm
  {
    vcomiss xmm1, xmm2
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
    vmovaps xmm8, xmm0
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm1
  }
  v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 831, ASSERT_TYPE_ASSERT, "(rampStart <= rampEnd)", (const char *)&queryFormat, "rampStart <= rampEnd");
  if ( v9 )
    __debugbreak();
  __asm
  {
    vmulss  xmm0, xmm6, xmm6
    vcomiss xmm8, xmm0
  }
  if ( v9 )
  {
    __asm
    {
      vmulss  xmm0, xmm7, xmm7
      vcomiss xmm8, xmm0
      vmovss  xmm0, cs:__real@3f800000
    }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  return *(float *)&_XMM0;
}

