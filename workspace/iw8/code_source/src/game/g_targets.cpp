/*
==============
Scr_Target_SetMinSize
==============
*/

void __fastcall Scr_Target_SetMinSize(scrContext_t *scrContext)
{
  ?Scr_Target_SetMinSize@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetShader
==============
*/

void __fastcall Scr_Target_SetShader(scrContext_t *scrContext)
{
  ?Scr_Target_SetShader@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Flush
==============
*/

void __fastcall Scr_Target_Flush(scrContext_t *scrContext)
{
  ?Scr_Target_Flush@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_IsTarget
==============
*/

void __fastcall Scr_Target_IsTarget(scrContext_t *scrContext)
{
  ?Scr_Target_IsTarget@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_AttackProfileTop
==============
*/

bool __fastcall G_Targets_AttackProfileTop(const gentity_s *ent)
{
  return ?G_Targets_AttackProfileTop@@YA_NPEBUgentity_s@@@Z(ent);
}

/*
==============
Scr_Target_IsInRect
==============
*/

void __fastcall Scr_Target_IsInRect(scrContext_t *scrContext)
{
  ?Scr_Target_IsInRect@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawCornersOnly
==============
*/

void __fastcall Scr_Target_DrawCornersOnly(scrContext_t *scrContext)
{
  ?Scr_Target_DrawCornersOnly@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Load
==============
*/

void G_Targets_Load(void)
{
  ?G_Targets_Load@@YAXXZ();
}

/*
==============
Scr_Target_StartLockOn
==============
*/

void __fastcall Scr_Target_StartLockOn(scrContext_t *scrContext)
{
  ?Scr_Target_StartLockOn@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetScaledRenderMode
==============
*/

void __fastcall Scr_Target_SetScaledRenderMode(scrContext_t *scrContext)
{
  ?Scr_Target_SetScaledRenderMode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_RemoveAll
==============
*/

void G_Targets_RemoveAll(void)
{
  ?G_Targets_RemoveAll@@YAXXZ();
}

/*
==============
G_Targets_GetOffset
==============
*/

bool __fastcall G_Targets_GetOffset(const gentity_s *targ, vec3_t *result)
{
  return ?G_Targets_GetOffset@@YA_NPEBUgentity_s@@AEATvec3_t@@@Z(targ, result);
}

/*
==============
Scr_Target_SetOffscreenShader
==============
*/

void __fastcall Scr_Target_SetOffscreenShader(scrContext_t *scrContext)
{
  ?Scr_Target_SetOffscreenShader@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawRotated
==============
*/

void __fastcall Scr_Target_DrawRotated(scrContext_t *scrContext)
{
  ?Scr_Target_DrawRotated@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetMaxSize
==============
*/

void __fastcall Scr_Target_SetMaxSize(scrContext_t *scrContext)
{
  ?Scr_Target_SetMaxSize@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawSingle
==============
*/

void __fastcall Scr_Target_DrawSingle(scrContext_t *scrContext)
{
  ?Scr_Target_DrawSingle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Remove
==============
*/

bool __fastcall G_Targets_Remove(gentity_s *ent)
{
  return ?G_Targets_Remove@@YA_NPEAUgentity_s@@@Z(ent);
}

/*
==============
Scr_Target_DrawOnRadar
==============
*/

void __fastcall Scr_Target_DrawOnRadar(scrContext_t *scrContext)
{
  ?Scr_Target_DrawOnRadar@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_ClearLockOn
==============
*/

void __fastcall Scr_Target_ClearLockOn(scrContext_t *scrContext)
{
  ?Scr_Target_ClearLockOn@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_IsInCircle
==============
*/

void __fastcall Scr_Target_IsInCircle(scrContext_t *scrContext)
{
  ?Scr_Target_IsInCircle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawSquare
==============
*/

void __fastcall Scr_Target_DrawSquare(scrContext_t *scrContext)
{
  ?Scr_Target_DrawSquare@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_OffsetLocalSpace
==============
*/

void __fastcall Scr_Target_OffsetLocalSpace(scrContext_t *scrContext)
{
  ?Scr_Target_OffsetLocalSpace@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Remove
==============
*/

void __fastcall Scr_Target_Remove(scrContext_t *scrContext)
{
  ?Scr_Target_Remove@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Set
==============
*/

void __fastcall Scr_Target_Set(scrContext_t *scrContext)
{
  ?Scr_Target_Set@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_ShowToPlayer
==============
*/

void __fastcall Scr_Target_ShowToPlayer(scrContext_t *scrContext)
{
  ?Scr_Target_ShowToPlayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Init
==============
*/

void G_Targets_Init(void)
{
  ?G_Targets_Init@@YAXXZ();
}

/*
==============
Scr_Target_GetArray
==============
*/

void __fastcall Scr_Target_GetArray(scrContext_t *scrContext)
{
  ?Scr_Target_GetArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetJavelinOnly
==============
*/

void __fastcall Scr_Target_SetJavelinOnly(scrContext_t *scrContext)
{
  ?Scr_Target_SetJavelinOnly@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_HideFromPlayer
==============
*/

void __fastcall Scr_Target_HideFromPlayer(scrContext_t *scrContext)
{
  ?Scr_Target_HideFromPlayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Alloc
==============
*/

void __fastcall Scr_Target_Alloc(scrContext_t *scrContext)
{
  ?Scr_Target_Alloc@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetColor
==============
*/

void __fastcall Scr_Target_SetColor(scrContext_t *scrContext)
{
  ?Scr_Target_SetColor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_GetTargetAtIndex
==============
*/

void __fastcall Scr_Target_GetTargetAtIndex(scrContext_t *scrContext)
{
  ?Scr_Target_GetTargetAtIndex@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_GetIndexOfTarget
==============
*/

void __fastcall Scr_Target_GetIndexOfTarget(scrContext_t *scrContext)
{
  ?Scr_Target_GetIndexOfTarget@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetRadarCenter
==============
*/

void __fastcall Scr_Target_SetRadarCenter(scrContext_t *scrContext)
{
  ?Scr_Target_SetRadarCenter@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetDelay
==============
*/

void __fastcall Scr_Target_SetDelay(scrContext_t *scrContext)
{
  ?Scr_Target_SetDelay@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetAttackMode
==============
*/

void __fastcall Scr_Target_SetAttackMode(scrContext_t *scrContext)
{
  ?Scr_Target_SetAttackMode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_AttackProfileTop
==============
*/
bool G_Targets_AttackProfileTop(const gentity_s *ent)
{
  unsigned int TargetIdx; 

  TargetIdx = GetTargetIdx(ent);
  return TargetIdx != 64 && (s_targGlob.targets[(unsigned __int64)TargetIdx].flags & 1) != 0;
}

/*
==============
G_Targets_GetOffset
==============
*/
char G_Targets_GetOffset(const gentity_s *targ, vec3_t *result)
{
  unsigned int TargetIdx; 
  char v4; 
  unsigned __int64 v5; 
  const vec3_t *v6; 
  gentity_s *v7; 
  tmat33_t<vec3_t> axis; 

  TargetIdx = GetTargetIdx(targ);
  if ( TargetIdx == 64 )
  {
    v4 = 0;
    *(_QWORD *)result->v = 0i64;
    result->v[2] = 0.0;
  }
  else
  {
    v5 = (unsigned __int64)TargetIdx << 6;
    v6 = (vec3_t *)((char *)&s_targGlob.targets[0].offset + v5);
    if ( (*(_DWORD *)&s_targGlob.targets[0].color[v5 + 4] & 0x4000) != 0 )
    {
      v7 = EntHandle::ent((EntHandle *)((char *)&s_targGlob + v5));
      AnglesToAxis(&v7->r.currentAngles, &axis);
      MatrixTransformVector(v6, &axis, result);
    }
    else
    {
      result->v[0] = v6->v[0];
      result->v[1] = *(float *)((char *)&s_targGlob.targets[0].offset.v[1] + v5);
      result->v[2] = *(float *)((char *)&s_targGlob.targets[0].offset.v[2] + v5);
    }
    return 1;
  }
  return v4;
}

/*
==============
G_Targets_Init
==============
*/
void G_Targets_Init(void)
{
  GTargetGlobals *v0; 
  unsigned int v1; 
  unsigned __int16 number; 
  __int64 v3; 
  unsigned int v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 47, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  s_targGlob.targetCount = 0;
  v0 = &s_targGlob;
  v1 = 4014;
  do
  {
    number = v0->targets[0].ent.number;
    if ( v0->targets[0].ent.number )
    {
      v3 = number;
      v4 = number - 1;
      if ( v4 >= 0x800 )
      {
        LODWORD(v7) = 2048;
        LODWORD(v6) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v5 = v3 - 1;
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v5] )
      {
        LODWORD(v7) = v0->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v7) )
          __debugbreak();
      }
      if ( v0->targets[0].ent.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 53, ASSERT_TYPE_ASSERT, "(!s_targGlob.targets[i].ent.isDefined())", (const char *)&queryFormat, "!s_targGlob.targets[i].ent.isDefined()") )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
    {
      LODWORD(v7) = 4014;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v7) )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( v1 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
    {
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v7) )
        __debugbreak();
    }
    SV_SetConfigstring(v1++, NULL);
    v0 = (GTargetGlobals *)((char *)v0 + 64);
  }
  while ( (__int64)v0 < (__int64)&s_targGlob.targetCount );
}

/*
==============
G_Targets_Load
==============
*/

void __fastcall G_Targets_Load(double _XMM0_8)
{
  vec3_t *p_offset; 
  unsigned int v2; 
  const char *v3; 
  const gentity_s *v4; 
  int v5; 
  __int64 v6; 
  const char *v7; 
  const char *v8; 
  int v9; 
  const char *v10; 
  int v11; 
  const char *v12; 
  const char *v14; 
  int v15; 
  const char *v16; 
  int v17; 
  const char *v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  const char *v23; 
  const char *v24; 
  int v25; 
  __int64 v26; 
  __int64 v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  char v32; 
  char v33; 
  char v34; 
  char v35; 
  char buffer[1024]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 67, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  p_offset = &s_targGlob.targets[0].offset;
  s_targGlob.targetCount = 0;
  v2 = 4014;
  do
  {
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
    {
      LODWORD(v27) = 4014;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v27) )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( v2 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
    {
      LODWORD(v27) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v27) )
        __debugbreak();
    }
    SV_GetConfigstring(v2, buffer, 1024);
    if ( buffer[0] )
    {
      ++s_targGlob.targetCount;
      v3 = Info_ValueForKey(buffer, "ent");
      if ( *v3 )
      {
        v5 = atoi(v3);
        v6 = v5;
        if ( (unsigned int)v5 >= 0x800 )
        {
          LODWORD(v27) = 2048;
          LODWORD(v26) = v5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 92, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v26, v27) )
            __debugbreak();
        }
        v4 = &level.gentities[v6];
      }
      else
      {
        v4 = NULL;
      }
      EntHandle::setEnt((EntHandle *)&p_offset[-1].y, v4);
      v7 = Info_ValueForKey(buffer, "offs");
      p_offset->v[0] = 0.0;
      *(_QWORD *)&p_offset->y = 0i64;
      if ( *v7 )
        j_sscanf(v7, "%f %f %f", p_offset, &p_offset->y, &p_offset->z);
      v8 = Info_ValueForKey(buffer, "mat");
      if ( *v8 )
        v9 = atoi(v8);
      else
        v9 = -1;
      LODWORD(p_offset[1].v[0]) = v9;
      v10 = Info_ValueForKey(buffer, "offmat");
      if ( *v10 )
        v11 = atoi(v10);
      else
        v11 = -1;
      LODWORD(p_offset[1].v[1]) = v11;
      v12 = Info_ValueForKey(buffer, "entradius");
      if ( *v12 )
      {
        _XMM0_8 = atof(v12);
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      }
      else
      {
        *(float *)&_XMM1 = FLOAT_N1_0;
      }
      p_offset[1].v[2] = *(float *)&_XMM1;
      v14 = Info_ValueForKey(buffer, "minsize");
      if ( *v14 )
        v15 = atoi(v14);
      else
        v15 = -1;
      LODWORD(p_offset[2].v[0]) = v15;
      v16 = Info_ValueForKey(buffer, "maxsize");
      if ( *v16 )
        v17 = atoi(v16);
      else
        v17 = -1;
      LODWORD(p_offset[2].v[1]) = v17;
      v18 = Info_ValueForKey(buffer, "delay");
      if ( *v18 )
      {
        j_sscanf(v18, "%i %i %i %i", &v31, &v30, &v29, &v28);
        v19 = (float)v28 * 0.001;
        *(&_XMM0_8 + 1) = 0.0;
        v20 = (float)v29;
        v21 = (float)v30;
        v22 = (float)v31 * 0.001;
      }
      else
      {
        v19 = 0.0;
        v20 = 0.0;
        v21 = 0.0;
        v22 = FLOAT_N1_0;
      }
      p_offset[2].v[2] = v22;
      p_offset[3].v[1] = v21;
      p_offset[3].v[2] = v20;
      p_offset[3].v[0] = v19;
      v23 = Info_ValueForKey(buffer, "color");
      if ( *v23 )
      {
        j_sscanf(v23, "%d %d %d %d", &v32, &v33, &v34, &v35);
        LOBYTE(p_offset[4].v[0]) = v32;
        BYTE1(p_offset[4].v[0]) = v33;
        BYTE2(p_offset[4].x) = v34;
        HIBYTE(p_offset[4].x) = v35;
      }
      v24 = Info_ValueForKey(buffer, "flags");
      if ( *v24 )
        v25 = atoi(v24);
      else
        v25 = 0;
      LODWORD(p_offset[4].v[1]) = v25;
    }
    else
    {
      EntHandle::setEnt((EntHandle *)&p_offset[-1].y, NULL);
    }
    ++v2;
    p_offset = (vec3_t *)((char *)p_offset + 64);
  }
  while ( (__int64)p_offset < (__int64)&unk_14A6BC9B8 );
}

/*
==============
G_Targets_Remove
==============
*/
char G_Targets_Remove(gentity_s *ent)
{
  unsigned int v2; 
  EntHandle *p_ent; 
  unsigned int v5; 
  unsigned int v6; 

  v2 = 0;
  while ( 1 )
  {
    p_ent = &s_targGlob.targets[(unsigned __int64)v2].ent;
    if ( EntHandle::isDefined(p_ent) )
    {
      if ( EntHandle::ent(p_ent) == ent )
        break;
    }
    if ( ++v2 >= 0x40 )
      return 0;
  }
  EntHandle::setEnt(p_ent, NULL);
  v5 = s_targGlob.targetCount - 1;
  s_targGlob.targetCount = v5;
  if ( v5 >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 515, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v5, 64) )
    __debugbreak();
  v6 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v2);
  SV_SetConfigstring(v6, (const char *)&queryFormat.fmt + 3);
  return 1;
}

/*
==============
G_Targets_RemoveAll
==============
*/
void G_Targets_RemoveAll(void)
{
  GTargetGlobals *v0; 
  unsigned int v1; 
  unsigned __int16 number; 
  __int64 v3; 
  unsigned int v4; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  __int64 v8; 

  v0 = &s_targGlob;
  v1 = 4014;
  do
  {
    number = v0->targets[0].ent.number;
    if ( v0->targets[0].ent.number )
    {
      v3 = number;
      v4 = number - 1;
      if ( v4 >= 0x800 )
      {
        LODWORD(v8) = 2048;
        LODWORD(v7) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v5 = v3 - 1;
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v5] )
      {
        LODWORD(v8) = v0->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v8) )
          __debugbreak();
      }
      if ( v0->targets[0].ent.number )
      {
        EntHandle::setEnt(&s_targGlob.targets[(unsigned __int64)(v1 - 4014)].ent, NULL);
        v6 = s_targGlob.targetCount - 1;
        s_targGlob.targetCount = v6;
        if ( v6 >= 0x40 )
        {
          LODWORD(v8) = 64;
          LODWORD(v7) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 536, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v7, v8) )
            __debugbreak();
        }
        if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
          __debugbreak();
        if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
        {
          LODWORD(v8) = 4014;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v8) )
            __debugbreak();
        }
        if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
          __debugbreak();
        if ( v1 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
        {
          LODWORD(v8) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v8) )
            __debugbreak();
        }
        SV_SetConfigstring(v1, (const char *)&queryFormat.fmt + 3);
      }
    }
    ++v1;
    v0 = (GTargetGlobals *)((char *)v0 + 64);
  }
  while ( v1 - 4014 < 0x40 );
}

/*
==============
GetTargetIdx
==============
*/
__int64 GetTargetIdx(const gentity_s *ent)
{
  unsigned int v2; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 158, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  if ( !ent )
    return 64i64;
  v2 = 0;
  while ( !EntHandle::isDefined(&s_targGlob.targets[(unsigned __int64)v2].ent) || EntHandle::ent(&s_targGlob.targets[(unsigned __int64)v2].ent) != ent )
  {
    if ( ++v2 >= 0x40 )
      return 64i64;
  }
  return v2;
}

/*
==============
ScrGetTargetScreenPos
==============
*/
char ScrGetTargetScreenPos(scrContext_t *scrContext, vec2_t *screenPos)
{
  const gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  const char *v7; 
  double Float; 
  unsigned int TargetIdx; 
  __int64 v10; 
  const char *v11; 
  __int64 v12; 
  bool v13; 
  vec3_t *p_offset; 
  gentity_s *v15; 
  float v16; 
  float v17; 
  float v18; 
  gentity_s *v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float v27; 
  float v28; 
  float v29; 
  vec3_t out; 
  tmat33_t<vec3_t> axis; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1637, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v5 = GScr_GetEntity(1u);
  v6 = v5;
  if ( !v5->client )
  {
    v7 = j_va("entity %i is not a player", (unsigned int)v5->s.number);
    Scr_ObjectError(COM_ERR_1638, scrContext, v7);
  }
  Float = Scr_GetFloat(scrContext, 2u);
  if ( *(float *)&Float <= 0.0 )
    Scr_ParamError(COM_ERR_1639, scrContext, 2u, "FOV must be positive");
  TargetIdx = GetTargetIdx(Entity);
  v10 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v11 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1640, scrContext, v11);
  }
  v12 = v10 << 6;
  v13 = (s_targGlob.targets[v10].flags & 0x4000) == 0;
  p_offset = &s_targGlob.targets[v10].offset;
  if ( v13 )
  {
    v18 = p_offset->v[0];
    v17 = p_offset->v[1];
    v16 = p_offset->v[2];
  }
  else
  {
    v15 = EntHandle::ent((EntHandle *)((char *)&s_targGlob + v12));
    AnglesToAxis(&v15->r.currentAngles, &axis);
    MatrixTransformVector(p_offset, &axis, &out);
    v16 = out.v[2];
    v17 = out.v[1];
    v18 = out.v[0];
  }
  v19 = EntHandle::ent((EntHandle *)((char *)&s_targGlob + v12));
  v20 = (float)(v18 + v19->r.currentOrigin.v[0]) - v6->r.currentOrigin.v[0];
  v22 = (float)(v17 + v19->r.currentOrigin.v[1]) - v6->r.currentOrigin.v[1];
  v21 = v22;
  v23 = (float)((float)(v16 + v19->r.currentOrigin.v[2]) - v6->r.currentOrigin.v[2]) - v6->client->ps.viewHeightCurrent;
  if ( *(float *)&Float <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 576, ASSERT_TYPE_ASSERT, "(fov_x > 0)", (const char *)&queryFormat, "fov_x > 0") )
    __debugbreak();
  AnglesToAxis(&v6->s.lerp.apos.trBase, &axis);
  v24 = (float)((float)(v22 * axis.m[0].v[1]) + (float)(v20 * axis.m[0].v[0])) + (float)(v23 * axis.m[0].v[2]);
  v25 = (float)((float)(v22 * axis.m[2].v[1]) + (float)(v20 * axis.m[2].v[0])) + (float)(v23 * axis.m[2].v[2]);
  if ( v24 <= 0.0 )
    return 0;
  v27 = (float)((float)((float)(v21 * axis.m[1].v[1]) + (float)(v20 * axis.m[1].v[0])) + (float)(v23 * axis.m[1].v[2])) / v24;
  v28 = v25 / v24;
  v29 = tanf_0(*(float *)&Float * 0.0087266462);
  if ( v29 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 589, ASSERT_TYPE_SANITY, "( tanHalfFovX > 0 )", (const char *)&queryFormat, "tanHalfFovX > 0") )
    __debugbreak();
  if ( (float)(v29 * 0.75) <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 590, ASSERT_TYPE_SANITY, "( tanHalfFovY > 0 )", (const char *)&queryFormat, "tanHalfFovY > 0") )
    __debugbreak();
  screenPos->v[1] = (float)(v28 * -240.0) / (float)(v29 * 0.75);
  screenPos->v[0] = (float)(v27 * -320.0) / v29;
  return 1;
}

/*
==============
Scr_Target_Alloc
==============
*/
void Scr_Target_Alloc(scrContext_t *scrContext)
{
  s_targGlob.targets[(unsigned __int64)Target_Alloc(scrContext)].delayFlush = 1;
}

/*
==============
Scr_Target_ClearLockOn
==============
*/
void Scr_Target_ClearLockOn(scrContext_t *scrContext)
{
  const char *v1; 

  v1 = j_va("ret_lock_on %i %i", 2047i64, 0i64);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v1);
}

/*
==============
Scr_Target_DrawCornersOnly
==============
*/
void Scr_Target_DrawCornersOnly(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1651, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1652, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFF7F;
  if ( Int )
    v8 = *p_flags | 0x80;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawOnRadar
==============
*/
void Scr_Target_DrawOnRadar(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1670, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1671, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x1000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFFEFFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawRotated
==============
*/
void Scr_Target_DrawRotated(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1676, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1677, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x8000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFF7FFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawSingle
==============
*/
void Scr_Target_DrawSingle(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  unsigned int v8; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1655, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1656, scrContext, v5);
  }
  s_targGlob.targets[v4].flags |= 0x800u;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v6 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v6, buffer, 1024);
    v7 = j_va("%i", (unsigned int)s_targGlob.targets[v4].flags);
    Info_SetValueForKey(buffer, "flags", v7);
    v8 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v8, buffer);
  }
}

/*
==============
Scr_Target_DrawSquare
==============
*/
void Scr_Target_DrawSquare(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  __int64 v6; 
  double Float; 
  bool v8; 
  unsigned int v9; 
  const char *v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1653, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1654, scrContext, v5);
  }
  v6 = v4 << 6;
  s_targGlob.targets[v4].flags = s_targGlob.targets[v4].flags & 0xFFFFFBBF | 0x400;
  if ( Scr_GetNumParam(scrContext) <= 1 )
    *(float *)&Float = FLOAT_N1_0;
  else
    Float = Scr_GetFloat(scrContext, 1u);
  v8 = !*(&s_targGlob.targets[0].delayFlush + v6);
  *(float *)((char *)&s_targGlob.targets[0].entRadius + v6) = *(float *)&Float;
  if ( v8 )
  {
    v9 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v9, buffer, 1024);
    v10 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v6 + 4]);
    Info_SetValueForKey(buffer, "flags", v10);
    v11 = j_va("%.2f", *(float *)((char *)&s_targGlob.targets[0].entRadius + v6));
    Info_SetValueForKey(buffer, "entradius", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_Flush
==============
*/
void Scr_Target_Flush(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  const char *v4; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1633, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
  {
    v4 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1634, scrContext, v4);
  }
  Target_Flush(TargetIdx);
}

/*
==============
Scr_Target_GetArray
==============
*/
void Scr_Target_GetArray(scrContext_t *scrContext)
{
  GTargetGlobals *v2; 
  __int64 v3; 
  unsigned __int16 number; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  Scr_MakeArray(scrContext);
  v2 = &s_targGlob;
  v3 = 64i64;
  do
  {
    number = v2->targets[0].ent.number;
    if ( v2->targets[0].ent.number )
    {
      v5 = number;
      v6 = number - 1;
      if ( v6 >= 0x800 )
      {
        LODWORD(v12) = 2048;
        LODWORD(v11) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = v5 - 1;
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v7] )
      {
        LODWORD(v12) = v2->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v12) )
          __debugbreak();
      }
      v8 = v2->targets[0].ent.number;
      if ( v2->targets[0].ent.number )
      {
        if ( (unsigned int)v8 - 1 >= 0x7FF )
        {
          LODWORD(v12) = 2047;
          LODWORD(v11) = v8 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v11, v12) )
            __debugbreak();
        }
        v9 = v2->targets[0].ent.number;
        if ( (unsigned int)(v9 - 1) >= 0x800 )
        {
          LODWORD(v12) = 2048;
          LODWORD(v11) = v9 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v11, v12) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v10 = v9 - 1;
        if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v10] )
        {
          LODWORD(v12) = v2->targets[0].ent.number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v12) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[v2->targets[0].ent.number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    v2 = (GTargetGlobals *)((char *)v2 + 64);
    --v3;
  }
  while ( v3 );
}

/*
==============
Scr_Target_GetIndexOfTarget
==============
*/
void Scr_Target_GetIndexOfTarget(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  int TargetIdx; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1629, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
    TargetIdx = -1;
  Scr_AddInt(scrContext, TargetIdx);
}

/*
==============
Scr_Target_GetTargetAtIndex
==============
*/
void Scr_Target_GetTargetAtIndex(scrContext_t *scrContext)
{
  int Int; 
  __int64 v3; 
  EntHandle *p_ent; 
  const gentity_s *v5; 
  __int64 v6; 
  int v7; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1628, scrContext, "Too few arguments\n");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Int;
  if ( Int < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 297, ASSERT_TYPE_ASSERT, "(targIdx >= 0)", "%s\n\tIndex passed in to Target_GetTargetAtIndex() must be >= 0", "targIdx >= 0") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x40 )
  {
    v7 = 64;
    LODWORD(v6) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 298, ASSERT_TYPE_ASSERT, "(unsigned)( targIdx ) < (unsigned)( 64 )", "targIdx doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  p_ent = &s_targGlob.targets[v3].ent;
  if ( EntHandle::isDefined(p_ent) )
  {
    v5 = EntHandle::ent(p_ent);
    GScr_AddEntity(v5);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_Target_HideFromPlayer
==============
*/
void Scr_Target_HideFromPlayer(scrContext_t *scrContext)
{
  Scr_Target_SetPlayerVisibility(scrContext, 0);
}

/*
==============
Scr_Target_IsInCircle
==============
*/
void Scr_Target_IsInCircle(scrContext_t *scrContext)
{
  double Float; 
  char TargetScreenPos; 
  int v4; 
  vec2_t screenPos; 

  Float = Scr_GetFloat(scrContext, 3u);
  TargetScreenPos = ScrGetTargetScreenPos(scrContext, &screenPos);
  v4 = 0;
  if ( TargetScreenPos )
    LOBYTE(v4) = (float)(*(float *)&Float * *(float *)&Float) > (float)((float)(screenPos.v[0] * screenPos.v[0]) + (float)(screenPos.v[1] * screenPos.v[1]));
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_Target_IsInRect
==============
*/
void Scr_Target_IsInRect(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  int v5; 
  vec2_t screenPos; 

  Float = Scr_GetFloat(scrContext, 3u);
  v3 = *(float *)&Float;
  v4 = Scr_GetFloat(scrContext, 4u);
  v5 = ScrGetTargetScreenPos(scrContext, &screenPos) && COERCE_FLOAT(LODWORD(screenPos.v[0]) & _xmm) < v3 && COERCE_FLOAT(LODWORD(screenPos.v[1]) & _xmm) < *(float *)&v4;
  Scr_AddBool(scrContext, v5);
}

/*
==============
Scr_Target_IsTarget
==============
*/
void Scr_Target_IsTarget(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  int TargetIdx; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1630, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  Scr_AddBool(scrContext, TargetIdx != 64);
}

/*
==============
Scr_Target_OffsetLocalSpace
==============
*/
void Scr_Target_OffsetLocalSpace(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1674, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1675, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x4000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFFBFFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_Remove
==============
*/
void Scr_Target_Remove(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  unsigned int v3; 
  EntHandle *p_ent; 
  const char *v5; 
  unsigned int v6; 
  unsigned int v7; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1635, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = 0;
  while ( 1 )
  {
    p_ent = &s_targGlob.targets[(unsigned __int64)v3].ent;
    if ( EntHandle::isDefined(p_ent) )
    {
      if ( EntHandle::ent(p_ent) == Entity )
        break;
    }
    if ( ++v3 >= 0x40 )
    {
      v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1636, scrContext, v5);
      return;
    }
  }
  EntHandle::setEnt(p_ent, NULL);
  v6 = s_targGlob.targetCount - 1;
  s_targGlob.targetCount = v6;
  if ( v6 >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 515, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v6, 64) )
    __debugbreak();
  v7 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v3);
  SV_SetConfigstring(v7, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_Target_Set
==============
*/
void Scr_Target_Set(scrContext_t *scrContext)
{
  unsigned int v1; 

  v1 = Target_Alloc(scrContext);
  Target_Flush(v1);
}

/*
==============
Scr_Target_SetAttackMode
==============
*/
void Scr_Target_SetAttackMode(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  scr_string_t ConstString; 
  unsigned int v7; 
  const char *v8; 
  unsigned int v9; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1641, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1642, scrContext, v5);
  }
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( ConstString == scr_const.top )
  {
    s_targGlob.targets[v4].flags |= 1u;
  }
  else if ( ConstString == scr_const.direct )
  {
    s_targGlob.targets[v4].flags &= ~1u;
  }
  else
  {
    Scr_Error(COM_ERR_1643, scrContext, "Incorrect mode name passed to target_setAttackMode().\n");
  }
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v7 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v7, buffer, 1024);
    v8 = j_va("%i", (unsigned int)s_targGlob.targets[v4].flags);
    Info_SetValueForKey(buffer, "flags", v8);
    v9 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v9, buffer);
  }
}

/*
==============
Scr_Target_SetColor
==============
*/
void Scr_Target_SetColor(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  double Float; 
  int v9; 
  __int64 v11; 
  bool v12; 
  unsigned __int8 v13; 
  int v14; 
  unsigned __int8 v15; 
  int v17; 
  unsigned __int8 v18; 
  int v20; 
  unsigned __int8 v21; 
  unsigned int v22; 
  const char *v23; 
  const char *v24; 
  unsigned int v25; 
  int v26; 
  vec3_t vectorValue; 
  float v28; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1661, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1662, scrContext, v5);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v28 = FLOAT_1_0;
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    v28 = *(float *)&Float;
  }
  _XMM6 = 0i64;
  __asm { vroundss xmm3, xmm6, xmm2, 1 }
  v9 = (int)*(float *)&_XMM3;
  __asm { vroundss xmm1, xmm6, xmm3, 1 }
  v11 = v4 << 6;
  if ( (int)*(float *)&_XMM3 > 255 )
    v9 = 255;
  v12 = v9 < 0;
  v13 = v9;
  v14 = (int)*(float *)&_XMM1;
  if ( v12 )
    v13 = 0;
  s_targGlob.targets[0].color[v11] = v13;
  if ( v14 > 255 )
    v14 = 255;
  v15 = v14;
  if ( v14 < 0 )
    v15 = 0;
  s_targGlob.targets[0].color[v11 + 1] = v15;
  __asm { vroundss xmm1, xmm6, xmm3, 1 }
  v17 = (int)*(float *)&_XMM1;
  if ( (int)*(float *)&_XMM1 > 255 )
    v17 = 255;
  v18 = v17;
  if ( v17 < 0 )
    v18 = 0;
  s_targGlob.targets[0].color[v11 + 2] = v18;
  __asm { vroundss xmm0, xmm6, xmm2, 1 }
  v20 = (int)*(float *)&_XMM0;
  if ( (int)*(float *)&_XMM0 > 255 )
    v20 = 255;
  v21 = v20;
  if ( v20 < 0 )
    v21 = 0;
  s_targGlob.targets[0].color[v11 + 3] = v21;
  *(_DWORD *)&s_targGlob.targets[0].color[v11 + 4] |= 0x200u;
  if ( !*(&s_targGlob.targets[0].delayFlush + v11) )
  {
    v22 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v22, buffer, 1024);
    v26 = s_targGlob.targets[0].color[v11 + 3];
    v23 = j_va("%i %i %i %i", s_targGlob.targets[0].color[v11], s_targGlob.targets[0].color[v11 + 1], s_targGlob.targets[0].color[v11 + 2], v26);
    Info_SetValueForKey(buffer, "color", v23);
    v24 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v11 + 4]);
    Info_SetValueForKey(buffer, "flags", v24);
    v25 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v25, buffer);
  }
}

/*
==============
Scr_Target_SetDelay
==============
*/
void Scr_Target_SetDelay(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  double Float; 
  __int64 v7; 
  const char *v8; 
  double v9; 
  const char *v10; 
  double v11; 
  const char *v12; 
  float v13; 
  const char *v14; 
  double v15; 
  const char *v16; 
  unsigned int v17; 
  const char *v18; 
  unsigned int v19; 
  int v20; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1663, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1664, scrContext, v5);
  }
  Float = Scr_GetFloat(scrContext, 1u);
  v7 = v4 << 6;
  s_targGlob.targets[v4].delay = *(float *)&Float;
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
  {
    v8 = j_va("Delay value out of range (0 .. 1) %f", *(float *)&Float);
    Scr_Error(COM_ERR_1665, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) <= 2 )
    LODWORD(v9) = 0;
  else
    v9 = Scr_GetFloat(scrContext, 2u);
  *(float *)((char *)&s_targGlob.targets[0].popRadiusInner + v7) = *(float *)&v9;
  if ( *(float *)&v9 < 0.0 || *(float *)&v9 > 1000.0 )
  {
    v10 = j_va("Pause inner radius out of range (0 .. 1000) %f", *(float *)&v9);
    Scr_Error(COM_ERR_1666, scrContext, v10);
  }
  if ( Scr_GetNumParam(scrContext) <= 3 )
    LODWORD(v11) = 0;
  else
    v11 = Scr_GetFloat(scrContext, 3u);
  *(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v7) = *(float *)&v11;
  if ( *(float *)&v11 < 0.0 || *(float *)&v11 > 1000.0 )
  {
    v12 = j_va("Pause outer radius out of range (0 .. 1000) %f", *(float *)&v11);
    Scr_Error(COM_ERR_1667, scrContext, v12);
    *(float *)&v11 = *(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v7);
  }
  v13 = *(float *)((char *)&s_targGlob.targets[0].popRadiusInner + v7);
  if ( *(float *)&v11 < v13 )
  {
    v14 = j_va("Pause outer radius must be >= the inner radius (%f < %f)", *(float *)&v11, v13);
    Scr_Error(COM_ERR_1668, scrContext, v14);
  }
  if ( Scr_GetNumParam(scrContext) <= 4 )
    LODWORD(v15) = 0;
  else
    v15 = Scr_GetFloat(scrContext, 4u);
  *(float *)((char *)&s_targGlob.targets[0].popRadiusInnerWaitTime + v7) = *(float *)&v15;
  if ( *(float *)&v15 < 0.0 || *(float *)&v15 > 1000.0 )
  {
    v16 = j_va("Pause inner radius wait time out of range (0 .. 1000) %f", *(float *)&v15);
    Scr_Error(COM_ERR_1669, scrContext, v16);
  }
  if ( !*(&s_targGlob.targets[0].delayFlush + v7) )
  {
    v17 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v17, buffer, 1024);
    v20 = (int)(float)(1000.0 * *(float *)((char *)&s_targGlob.targets[0].popRadiusInnerWaitTime + v7));
    v18 = j_va("%i %i %i %i", (unsigned int)(int)(float)(1000.0 * *(float *)((char *)&s_targGlob.targets[0].delay + v7)), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].popRadiusInner + v7), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v7), v20);
    Info_SetValueForKey(buffer, "delay", v18);
    v19 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v19, buffer);
  }
}

/*
==============
Scr_Target_SetJavelinOnly
==============
*/
void Scr_Target_SetJavelinOnly(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1644, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1645, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFFFD;
  if ( Int )
    v8 = *p_flags | 2;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_SetMaxSize
==============
*/
void Scr_Target_SetMaxSize(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  bool v7; 
  unsigned int v8; 
  const char *v9; 
  unsigned int v10; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1659, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1660, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  v7 = !s_targGlob.targets[v4].delayFlush;
  s_targGlob.targets[v4].maxSize = Int;
  if ( v7 )
  {
    v8 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v8, buffer, 1024);
    v9 = j_va("%i", (unsigned int)s_targGlob.targets[v4].maxSize);
    Info_SetValueForKey(buffer, "maxsize", v9);
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v10, buffer);
  }
}

/*
==============
Scr_Target_SetMinSize
==============
*/
void Scr_Target_SetMinSize(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  __int64 v6; 
  int Int; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  const char *v12; 
  unsigned int v13; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 3 )
    Scr_Error(COM_ERR_1657, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1658, scrContext, v5);
  }
  v6 = v4 << 6;
  s_targGlob.targets[v4].minSize = Scr_GetInt(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  v8 = s_targGlob.targets[v4].flags & 0xFFFFFEFF;
  if ( Int )
    v8 = s_targGlob.targets[v4].flags | 0x100;
  v9 = !*(&s_targGlob.targets[0].delayFlush + v6);
  *(_DWORD *)&s_targGlob.targets[0].color[v6 + 4] = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].minSize + v6));
    Info_SetValueForKey(buffer, "minsize", v11);
    v12 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v6 + 4]);
    Info_SetValueForKey(buffer, "flags", v12);
    v13 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v13, buffer);
  }
}

/*
==============
Scr_Target_SetOffscreenShader
==============
*/
void Scr_Target_SetOffscreenShader(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  const char *String; 
  GConfigStrings *v7; 
  unsigned int (__fastcall *GetMaterialIndex)(GConfigStrings *, const char *); 
  const char *v9; 
  int v10; 
  unsigned int *p_offscreenMaterialIndex; 
  unsigned int v12; 
  const char *v13; 
  unsigned int v14; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1626, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1627, scrContext, v5);
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings;
  if ( *String )
  {
    GetMaterialIndex = GConfigStrings::ms_gConfigStrings->GetMaterialIndex;
    v9 = Scr_GetString(scrContext, 1u);
    v10 = GetMaterialIndex(v7, v9);
  }
  else
  {
    v10 = -1;
  }
  p_offscreenMaterialIndex = (unsigned int *)&s_targGlob.targets[v4].offscreenMaterialIndex;
  *p_offscreenMaterialIndex = v10;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v12, buffer, 1024);
    v13 = j_va("%i", *p_offscreenMaterialIndex);
    Info_SetValueForKey(buffer, "offmat", v13);
    v14 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v14, buffer);
  }
}

/*
==============
Scr_Target_SetPlayerVisibility
==============
*/
void Scr_Target_SetPlayerVisibility(scrContext_t *scrContext, bool makingVisible)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v6; 
  const char *v7; 
  gentity_s *v8; 
  gentity_s *v9; 
  const char *v10; 
  int v11; 
  int flags; 
  unsigned int *p_flags; 
  int v14; 
  bool v15; 
  unsigned int v16; 
  const char *v17; 
  unsigned int v18; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1646, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v6 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v7 = j_va("Entity %i is not a target.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1647, scrContext, v7);
  }
  v8 = GScr_GetEntity(1u);
  v9 = v8;
  if ( v8->s.eType != ET_PLAYER )
  {
    v10 = j_va("Entity %i is not a player entity.", (unsigned int)v8->s.number);
    Scr_Error(COM_ERR_1648, scrContext, v10);
  }
  if ( SV_Game_GetClientCount() > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 902, ASSERT_TYPE_ASSERT, "(SV_Game_GetClientCount() <= 4)", "%s\n\tIf we support more clients in SP, we need a more precise target flag system", "SV_Game_GetClientCount() <= 4") )
    __debugbreak();
  switch ( v9->s.number )
  {
    case 1:
      v11 = 8;
      break;
    case 2:
      v11 = 16;
      break;
    case 3:
      v11 = 32;
      break;
    default:
      if ( v9->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 916, ASSERT_TYPE_ASSERT, "( playerEnt->s.number == 0 )", (const char *)&queryFormat, "playerEnt->s.number == 0") )
        __debugbreak();
      v11 = 4;
      break;
  }
  flags = s_targGlob.targets[v6].flags;
  p_flags = (unsigned int *)&s_targGlob.targets[v6].flags;
  if ( makingVisible )
    v14 = flags & ~v11;
  else
    v14 = flags | v11;
  v15 = !s_targGlob.targets[v6].delayFlush;
  *p_flags = v14;
  if ( v15 )
  {
    v16 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v6);
    SV_GetConfigstring(v16, buffer, 1024);
    v17 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v17);
    v18 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v6);
    SV_SetConfigstring(v18, buffer);
  }
}

/*
==============
Scr_Target_SetRadarCenter
==============
*/
void Scr_Target_SetRadarCenter(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  int i; 
  unsigned __int16 v9; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned int v13; 
  const char *v14; 
  unsigned int v15; 
  unsigned int v16; 
  const char *v17; 
  unsigned int v18; 
  __int64 v19; 
  __int64 v20; 
  unsigned int offset; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1672, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  offset = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1673, scrContext, v6);
  }
  if ( v3 )
  {
    p_flags = (unsigned int *)&s_targGlob.targets[0].flags;
    for ( i = 0; i < 64; ++i )
    {
      v9 = *((_WORD *)p_flags - 30);
      if ( v9 )
      {
        v10 = v9;
        v11 = v9 - 1;
        if ( v11 >= 0x800 )
        {
          LODWORD(v20) = 2048;
          LODWORD(v19) = v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v19, v20) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v12 = v10 - 1;
        if ( g_entities[v12].r.isInUse != g_entityIsInUse[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v12] )
        {
          LODWORD(v20) = *((unsigned __int16 *)p_flags - 30) - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v20) )
            __debugbreak();
        }
        if ( *((_WORD *)p_flags - 30) && (*p_flags & 0x2000) != 0 )
        {
          *p_flags &= ~0x2000u;
          v13 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, i);
          SV_GetConfigstring(v13, buffer, 1024);
          v14 = j_va("%i", *p_flags);
          Info_SetValueForKey(buffer, "flags", v14);
          v15 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, i);
          SV_SetConfigstring(v15, buffer);
        }
      }
      p_flags += 16;
    }
    v5 = offset;
    s_targGlob.targets[(unsigned __int64)offset].flags |= 0x2000u;
  }
  else
  {
    s_targGlob.targets[v5].flags &= ~0x2000u;
  }
  if ( !s_targGlob.targets[v5].delayFlush )
  {
    v16 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v16, buffer, 1024);
    v17 = j_va("%i", (unsigned int)s_targGlob.targets[v5].flags);
    Info_SetValueForKey(buffer, "flags", v17);
    v18 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v18, buffer);
  }
}

/*
==============
Scr_Target_SetScaledRenderMode
==============
*/
void Scr_Target_SetScaledRenderMode(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1649, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1650, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFFBF;
  if ( Int )
    v8 = *p_flags | 0x40;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_SetShader
==============
*/
void Scr_Target_SetShader(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  const char *String; 
  GConfigStrings *v7; 
  unsigned int (__fastcall *GetMaterialIndex)(GConfigStrings *, const char *); 
  const char *v9; 
  int v10; 
  unsigned int *p_materialIndex; 
  unsigned int v12; 
  const char *v13; 
  unsigned int v14; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1624, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1625, scrContext, v5);
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings;
  if ( *String )
  {
    GetMaterialIndex = GConfigStrings::ms_gConfigStrings->GetMaterialIndex;
    v9 = Scr_GetString(scrContext, 1u);
    v10 = GetMaterialIndex(v7, v9);
  }
  else
  {
    v10 = -1;
  }
  p_materialIndex = (unsigned int *)&s_targGlob.targets[v4].materialIndex;
  *p_materialIndex = v10;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v12, buffer, 1024);
    v13 = j_va("%i", *p_materialIndex);
    Info_SetValueForKey(buffer, "mat", v13);
    v14 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v14, buffer);
  }
}

/*
==============
Scr_Target_ShowToPlayer
==============
*/
void Scr_Target_ShowToPlayer(scrContext_t *scrContext)
{
  Scr_Target_SetPlayerVisibility(scrContext, 1);
}

/*
==============
Scr_Target_StartLockOn
==============
*/
void Scr_Target_StartLockOn(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  double Float; 
  const char *v4; 

  Entity = GScr_GetEntity(0);
  Float = Scr_GetFloat(scrContext, 1u);
  v4 = j_va("ret_lock_on %i %i", (unsigned int)Entity->s.number, (unsigned int)(int)(float)(*(float *)&Float * 1000.0));
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v4);
}

/*
==============
Target_Alloc
==============
*/
__int64 Target_Alloc(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  unsigned int TargetIdx; 
  GTargetGlobals *v4; 
  unsigned __int16 number; 
  __int64 v6; 
  unsigned int v7; 
  __int64 v8; 
  unsigned __int64 v9; 
  vec3_t *p_offset; 
  __int64 result; 
  __int64 v12; 
  __int64 v13; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1631, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
  {
    if ( s_targGlob.targetCount >= 0x40 )
      Scr_Error(COM_ERR_1632, scrContext, "Maximum number of targets exceeded");
    TargetIdx = 0;
    v4 = &s_targGlob;
    while ( 1 )
    {
      number = v4->targets[0].ent.number;
      if ( !v4->targets[0].ent.number )
        break;
      v6 = number;
      v7 = number - 1;
      if ( v7 >= 0x800 )
      {
        LODWORD(v13) = 2048;
        LODWORD(v12) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v8 = v6 - 1;
      if ( g_entities[v8].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v8] )
      {
        LODWORD(v13) = v4->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v13) )
          __debugbreak();
      }
      if ( !v4->targets[0].ent.number )
        break;
      ++TargetIdx;
      v4 = (GTargetGlobals *)((char *)v4 + 64);
      if ( TargetIdx >= 0x40 )
      {
        LODWORD(v13) = 64;
        LODWORD(v12) = TargetIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 390, ASSERT_TYPE_ASSERT, "(unsigned)( targetIndex ) < (unsigned)( 64 )", "targetIndex doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
        break;
      }
    }
    v9 = (unsigned __int64)TargetIdx << 6;
    EntHandle::setEnt((EntHandle *)((char *)&s_targGlob + v9), Entity);
    Entity->flags.m_flags[1] |= 32 * GameModeFlagValues::ms_spValue;
    *(_QWORD *)((char *)&s_targGlob.targets[0].materialIndex + v9) = -1i64;
    *(_QWORD *)((char *)s_targGlob.targets[0].offset.v + v9) = 0i64;
    *(float *)((char *)&s_targGlob.targets[0].offset.v[2] + v9) = 0.0;
    *(_QWORD *)((char *)&s_targGlob.targets[0].entRadius + v9) = -1082130432i64;
    *(int *)((char *)&s_targGlob.targets[0].maxSize + v9) = -1;
    *(float *)((char *)&s_targGlob.targets[0].delay + v9) = -1.0;
    *(_QWORD *)((char *)&s_targGlob.targets[0].popRadiusInnerWaitTime + v9) = 0i64;
    *(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v9) = 0.0;
    *(_DWORD *)&s_targGlob.targets[0].color[v9 + 4] = 0;
    ++s_targGlob.targetCount;
  }
  p_offset = &s_targGlob.targets[(unsigned __int64)TargetIdx].offset;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)p_offset->v = 0i64;
    result = TargetIdx;
    s_targGlob.targets[(unsigned __int64)TargetIdx].offset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, p_offset);
    return TargetIdx;
  }
  return result;
}

/*
==============
Target_Flush
==============
*/
void Target_Flush(unsigned int targetIndex)
{
  __int64 v1; 
  __int64 v2; 
  unsigned __int16 number; 
  __int64 v4; 
  unsigned int v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  __int64 v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  const char *v19; 
  unsigned int v20; 
  char *fmt; 
  char *fmta; 
  __int64 v23; 
  __int64 v25; 
  int v26; 
  char s[1024]; 

  v1 = targetIndex;
  if ( targetIndex >= 0x40 )
  {
    v26 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 420, ASSERT_TYPE_ASSERT, "(unsigned)( targetIndex ) < (unsigned)( 64 )", "targetIndex doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", targetIndex, v26) )
      __debugbreak();
  }
  v2 = v1 << 6;
  number = s_targGlob.targets[v1].ent.number;
  if ( !number )
    goto LABEL_38;
  v4 = number;
  v5 = number - 1;
  if ( v5 >= 0x800 )
  {
    LODWORD(v25) = 2048;
    LODWORD(v23) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v23, v25) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v6 = v4 - 1;
  if ( g_entities[v6].r.isInUse != g_entityIsInUse[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[v6] )
  {
    LODWORD(v25) = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2) - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v25) )
      __debugbreak();
  }
  if ( !*(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2) )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 421, ASSERT_TYPE_ASSERT, "(s_targGlob.targets[targetIndex].ent.isDefined())", "%s\n\tTarget entity is not defined", "s_targGlob.targets[targetIndex].ent.isDefined()") )
      __debugbreak();
  }
  v7 = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2);
  s[0] = 0;
  if ( (unsigned int)(v7 - 1) >= 0x7FF )
  {
    LODWORD(v25) = 2047;
    LODWORD(v23) = v7 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 231, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v23, v25) )
      __debugbreak();
  }
  v8 = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2);
  if ( (unsigned int)(v8 - 1) >= 0x800 )
  {
    LODWORD(v25) = 2048;
    LODWORD(v23) = v8 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v23, v25) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v9 = v8 - 1;
  if ( g_entities[v9].r.isInUse != g_entityIsInUse[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[v9] )
  {
    LODWORD(v25) = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2) - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 232, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v25) )
      __debugbreak();
  }
  v10 = j_va("%i", (unsigned int)(__int16)(*(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + v2) - 1));
  Info_SetValueForKey(s, "ent", v10);
  v11 = j_va("%i %i %i", (unsigned int)(int)*(float *)((char *)s_targGlob.targets[0].offset.v + v2), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].offset.v[1] + v2), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].offset.v[2] + v2));
  Info_SetValueForKey(s, "offs", v11);
  v12 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].materialIndex + v2));
  Info_SetValueForKey(s, "mat", v12);
  v13 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].offscreenMaterialIndex + v2));
  Info_SetValueForKey(s, "offmat", v13);
  v14 = j_va("%.2f", *(float *)((char *)&s_targGlob.targets[0].entRadius + v2));
  Info_SetValueForKey(s, "entradius", v14);
  v15 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].minSize + v2));
  Info_SetValueForKey(s, "minsize", v15);
  v16 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].maxSize + v2));
  Info_SetValueForKey(s, "maxsize", v16);
  LODWORD(fmt) = (int)(float)(1000.0 * *(float *)((char *)&s_targGlob.targets[0].popRadiusInnerWaitTime + v2));
  v17 = j_va("%i %i %i %i", (unsigned int)(int)(float)(1000.0 * *(float *)((char *)&s_targGlob.targets[0].delay + v2)), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].popRadiusInner + v2), (unsigned int)(int)*(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v2), fmt);
  Info_SetValueForKey(s, "delay", v17);
  LODWORD(fmta) = s_targGlob.targets[0].color[v2 + 3];
  v18 = j_va("%i %i %i %i", s_targGlob.targets[0].color[v2], s_targGlob.targets[0].color[v2 + 1], s_targGlob.targets[0].color[v2 + 2], fmta);
  Info_SetValueForKey(s, "color", v18);
  v19 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v2 + 4]);
  Info_SetValueForKey(s, "flags", v19);
  v20 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v1);
  SV_SetConfigstring(v20, s);
  *(&s_targGlob.targets[0].delayFlush + v2) = 0;
}

