/*
==============
ParticleModuleInitMaterial::InitParticles
==============
*/

void __fastcall ParticleModuleInitMaterial::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitMaterial@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSound::InitParticles
==============
*/

void __fastcall ParticleModuleInitSound::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSound@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawn::Init
==============
*/

void __fastcall ParticleModuleInitSpawn::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawn@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitParticleSim::Init
==============
*/

void __fastcall ParticleModuleInitParticleSim::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitParticleSim@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitVolumetric::InitParticles
==============
*/

void __fastcall ParticleModuleInitVolumetric::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitVolumetric@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeBox@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::GetDimensions(ParticleModuleInitSpawnShapeCylinder *this, const ParticleState *pParticleState, float *halfHeight, float *radiusMin, float *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeCylinder@@QEBAXPEBVParticleState@@AEAM11@Z(this, pParticleState, halfHeight, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitOcclusionQuery::InitParticles
==============
*/

void __fastcall ParticleModuleInitOcclusionQuery::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitOcclusionQuery@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRunner::Init
==============
*/

void __fastcall ParticleModuleInitRunner::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitRunner@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeSphere@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitVolumetric::Init
==============
*/

void __fastcall ParticleModuleInitVolumetric::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitVolumetric@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitParticleSim::InitParticles
==============
*/

void __fastcall ParticleModuleInitParticleSim::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitParticleSim@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::GetDimensions(ParticleModuleInitSpawnShapeBox *this, const ParticleState *pParticleState, float4 *dimensionsMin, float4 *dimensionsMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeBox@@QEBAXPEBVParticleState@@AEAUfloat4@@1@Z(this, pParticleState, dimensionsMin, dimensionsMax);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeSphere@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitBeam::Init
==============
*/

void __fastcall ParticleModuleInitBeam::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitBeam@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitOrientedSprite::InitParticles
==============
*/

void __fastcall ParticleModuleInitOrientedSprite::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitOrientedSprite@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeBox@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitFlare::Init
==============
*/

void __fastcall ParticleModuleInitFlare::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitFlare@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, float4 *outOffset)
{
  ?GetOffsetForShape@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleEmitter@@AEAUfloat4@@@Z(this, pEmitter, outOffset);
}

/*
==============
ParticleModuleInitGeoTrail::Init
==============
*/

void __fastcall ParticleModuleInitGeoTrail::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitGeoTrail@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeCylinder::GetVolumeSize(ParticleModuleInitSpawnShapeCylinder *this, const float halfHeight, const float radiusMin, const float radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeCylinder@@QEBAMMMM@Z(this, halfHeight, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitAtlas::Init
==============
*/

void __fastcall ParticleModuleInitAtlas::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitAtlas@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitFlare::InitParticles
==============
*/

void __fastcall ParticleModuleInitFlare::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitFlare@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRunner::InitParticles
==============
*/

void __fastcall ParticleModuleInitRunner::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRunner@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitLightSpot::InitParticles
==============
*/

void __fastcall ParticleModuleInitLightSpot::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitLightSpot@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeBox@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitBeam::DebugDraw
==============
*/

void __fastcall ParticleModuleInitBeam::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitBeam@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitPlayerFacing::InitParticles
==============
*/

void __fastcall ParticleModuleInitPlayerFacing::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitPlayerFacing@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, float4 *outOffset)
{
  ?GetOffsetForShape@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleState@@AEAUfloat4@@@Z(this, pParticleState, outOffset);
}

/*
==============
ParticleModuleInitVolumetric::DebugDraw
==============
*/

void __fastcall ParticleModuleInitVolumetric::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitVolumetric@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeCylinder@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitLightOmni::InitParticles
==============
*/

void __fastcall ParticleModuleInitLightOmni::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitLightOmni@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticleSize
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleSize(const ParticleModuleInitAttributes *pModule, float4 *sizeArray, const int *randomSeedArray, unsigned int particleCountEmit)
{
  ?InitParticleSize@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHI@Z(pModule, sizeArray, randomSeedArray, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShape::GetVolumeSize(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShape@@QEBAMPEBVParticleState@@@Z(this, pParticleState);
  return result;
}

/*
==============
ParticleModuleInitLightOmni::DebugDraw
==============
*/

void __fastcall ParticleModuleInitLightOmni::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitLightOmni@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitModel::InitPhysicsParticles
==============
*/

void __fastcall ParticleModuleInitModel::InitPhysicsParticles(ParticleModuleInitModel *this, ParticleData *pParticleData, const unsigned int particleCountEmit, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, FxPhysics *physicsInstanceIDList)
{
  ?InitPhysicsParticles@ParticleModuleInitModel@@QEBAXPEAUParticleData@@IPEBVParticleEmitter@@PEBVParticleState@@PEAUFxPhysics@@@Z(this, pParticleData, particleCountEmit, pEmitterOwner, pParticleState, physicsInstanceIDList);
}

/*
==============
ParticleModuleInitDecal::InitParticles
==============
*/

void __fastcall ParticleModuleInitDecal::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitDecal@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitModel::InitParticles
==============
*/

void __fastcall ParticleModuleInitModel::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitModel@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticleColor
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleColor(const ParticleModuleInitAttributes *pModule, float4 *colorArray, const int *randomSeedArray, unsigned int particleCountEmit)
{
  ?InitParticleColor@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHI@Z(pModule, colorArray, randomSeedArray, particleCountEmit);
}

/*
==============
ParticleModuleInitOcclusionQuery::Init
==============
*/

void __fastcall ParticleModuleInitOcclusionQuery::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitOcclusionQuery@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawn::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawn::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawn@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeCylinder@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitKillWrapBox::InitParticles
==============
*/

void __fastcall ParticleModuleInitKillWrapBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitKillWrapBox@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitMirrorTexture::InitParticles
==============
*/

void __fastcall ParticleModuleInitMirrorTexture::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitMirrorTexture@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRotation::InitParticles
==============
*/

void __fastcall ParticleModuleInitRotation::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRotation@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitTail::InitParticles
==============
*/

void __fastcall ParticleModuleInitTail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitTail@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitDismember::InitParticles
==============
*/

void __fastcall ParticleModuleInitDismember::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitDismember@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCloud::InitParticles
==============
*/

void __fastcall ParticleModuleInitCloud::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitCloud@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitLightOmni::Init
==============
*/

void __fastcall ParticleModuleInitLightOmni::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitLightOmni@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeMesh::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeMesh::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeMesh@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCameraOffset::InitParticles
==============
*/

void __fastcall ParticleModuleInitCameraOffset::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitCameraOffset@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetRandomSeed
==============
*/

int __fastcall ParticleModuleInitSpawnShape::GetRandomSeed(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, ParticleData *pParticleData, const int particleIndex)
{
  return ?GetRandomSeed@ParticleModuleInitSpawnShape@@QEBAHPEBVParticleState@@PEAUParticleData@@H@Z(this, pParticleState, pParticleData, particleIndex);
}

/*
==============
ParticleModuleInitBeam::InitParticles
==============
*/

void __fastcall ParticleModuleInitBeam::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitBeam@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitOrientedSprite::Init
==============
*/

void __fastcall ParticleModuleInitOrientedSprite::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitOrientedSprite@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeSphere::GetVolumeSize(ParticleModuleInitSpawnShapeSphere *this, const float radiusMin, const float radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeSphere@@QEBAMMM@Z(this, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitDecal::Init
==============
*/

void __fastcall ParticleModuleInitDecal::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitDecal@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeSphere@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize(ParticleModuleInitSpawnShapeEllipsoid *this, const float4 *radiusMin, const float4 *radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeEllipsoid@@QEBAMAEBUfloat4@@0@Z(this, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitAtlas::InitParticles
==============
*/

void __fastcall ParticleModuleInitAtlas::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitAtlas@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetCalculationOffset
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetCalculationOffset(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, const ParticleState *pParticleState, float4 *outCalculationOffset)
{
  ?GetCalculationOffset@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleEmitter@@PEBVParticleState@@AEAUfloat4@@@Z(this, pEmitter, pParticleState, outCalculationOffset);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::GetDimensions(ParticleModuleInitSpawnShapeSphere *this, const ParticleState *pParticleState, float *radiusMin, float *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeSphere@@QEBAXPEBVParticleState@@AEAM1@Z(this, pParticleState, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitRelativeVelocity::InitParticles
==============
*/

void __fastcall ParticleModuleInitRelativeVelocity::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRelativeVelocity@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticles
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitAttributes@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCloud::Init
==============
*/

void __fastcall ParticleModuleInitCloud::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitCloud@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitGeoTrail::InitParticles
==============
*/

void __fastcall ParticleModuleInitGeoTrail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitGeoTrail@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitKillWrapBox::DebugDraw
==============
*/

void __fastcall ParticleModuleInitKillWrapBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitKillWrapBox@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitSpawnShapeMesh::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeMesh::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeMesh@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitLightSpot::DebugDraw
==============
*/

void __fastcall ParticleModuleInitLightSpot::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitLightSpot@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitRotation3D::InitParticles
==============
*/

void __fastcall ParticleModuleInitRotation3D::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRotation3D@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeCylinder@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitDismember::Init
==============
*/

void __fastcall ParticleModuleInitDismember::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitDismember@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitAttributes::InitParticleVelocity
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleVelocity(const ParticleModuleInitAttributes *pModule, float4 *velocityArray, const int *randomSeedArray, const ParticleState *pParticleState, const unsigned int particleCountEmit)
{
  ?InitParticleVelocity@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHPEBVParticleState@@I@Z(pModule, velocityArray, randomSeedArray, pParticleState, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeBox::GetVolumeSize(ParticleModuleInitSpawnShapeBox *this, const float4 *dimensions)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeBox@@QEBAMAEBUfloat4@@@Z(this, dimensions);
  return result;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::GetDimensions(ParticleModuleInitSpawnShapeEllipsoid *this, const ParticleState *pParticleState, float4 *radiusMin, float4 *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeEllipsoid@@QEBAXPEBVParticleState@@AEAUfloat4@@1@Z(this, pParticleState, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitLightSpot::Init
==============
*/

void __fastcall ParticleModuleInitLightSpot::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitLightSpot@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitVectorField::InitParticles
==============
*/

void __fastcall ParticleModuleInitVectorField::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitVectorField@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::Init
==============
*/

void __fastcall ParticleModuleInitAttributes::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitAttributes@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitBeam::DebugDraw
==============
*/
void ParticleModuleInitBeam::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  const float4 *EmitterPos; 
  const ParticleSystem *SystemOwner; 
  __m128 *p_v; 
  vec3_t center; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 717, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 718, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 719, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 720, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    EmitterPos = ParticleEmitter::GetEmitterPos((ParticleEmitter *)pEmitterOwner, pParticleState);
    SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
    _XMM2 = _mm128_add_ps(EmitterPos->v, SystemOwner->m_beamData.m_beamStartPos.v);
    _XMM6 = _mm128_add_ps(EmitterPos->v, SystemOwner->m_beamData.m_beamEndPos.v);
    p_v = &SystemOwner->m_systemTransform.x.v;
    center.v[0] = _XMM2.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+98h+center+4], xmm2, 1
      vextractps dword ptr [rsp+98h+center+8], xmm2, 2
    }
    Particle_DebugSphere(&center, 10.0, &colorBlueHeat, 1, 0);
    center.v[0] = _XMM6.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+98h+center+4], xmm6, 1
      vextractps dword ptr [rsp+98h+center+8], xmm6, 2
    }
    Particle_DebugSphere(&center, 10.0, &colorBlueHeat, 1, 0);
    if ( p_v[19].m128_i8[12] )
    {
      _XMM2 = _mm128_add_ps(EmitterPos->v, p_v[17]);
      _XMM6 = _mm128_add_ps(EmitterPos->v, p_v[18]);
      center.v[0] = _XMM2.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rsp+98h+center+4], xmm2, 1
        vextractps dword ptr [rsp+98h+center+8], xmm2, 2
      }
      Particle_DebugSphere(&center, 10.0, &colorBlueHeat, 1, 0);
      center.v[0] = _XMM6.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rsp+98h+center+4], xmm6, 1
        vextractps dword ptr [rsp+98h+center+8], xmm6, 2
      }
      Particle_DebugSphere(&center, 10.0, &colorBlueHeat, 1, 0);
    }
  }
}

/*
==============
ParticleModuleInitKillWrapBox::DebugDraw
==============
*/
void ParticleModuleInitKillWrapBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  float4 outShapeOrigin; 
  vec3_t origin; 
  Bounds bounds; 
  vec3_t outAngles; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 798, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 799, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 800, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 801, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_wrap_bounds->current.enabled )
  {
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, (const float4 *)&pModuleBase[4], &outShapeOrigin, &outAngles, (pModuleBase->m_flags & 0x80) != 0);
    _XMM1 = outShapeOrigin.v;
    origin.v[0] = outShapeOrigin.v.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+0A8h+origin+4], xmm1, 1
      vextractps dword ptr [rsp+0A8h+origin+8], xmm1, 2
    }
    _XMM1 = *(_OWORD *)&pModuleBase[2].m_type;
    LODWORD(bounds.halfSize.v[0]) = _XMM1;
    __asm
    {
      vextractps dword ptr [rsp+0A8h+bounds.halfSize+4], xmm1, 1
      vextractps dword ptr [rsp+0A8h+bounds.halfSize+8], xmm1, 2
    }
    bounds.midPoint.v[0] = 0.0;
    bounds.midPoint.v[1] = 0.0;
    bounds.midPoint.v[2] = 0.0;
    Particle_DebugBox(&origin, &bounds, &outAngles, &colorLtPurple, 1, 0);
  }
}

/*
==============
ParticleModuleInitLightOmni::DebugDraw
==============
*/
void ParticleModuleInitLightOmni::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  const vector4 *EmitterTransform; 
  ParticleState::ElementTypeModule v9; 
  bool v10; 
  __int64 m_particleCountRunning; 
  const float4 *PositionArray; 
  float4 *ColorArray; 
  float4 *SizeArray; 
  float4 *v15; 
  signed __int64 v16; 
  float4 posWorld; 
  vec3_t center; 
  vec4_t color; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 833, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 834, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 835, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 836, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_lights->current.enabled )
  {
    v9.pModule = (const ParticleModule *)pParticleState->m_elementTypeModule;
    v10 = v9.pModule && (v9.pModule->m_flags & 1) == 0;
    if ( pParticleState->m_pStateDef->elementType == 5 && v10 )
    {
      m_particleCountRunning = pParticleData->m_particleCountRunning;
      PositionArray = Particle_GetPositionArray(pParticleData);
      ColorArray = Particle_GetColorArray(pParticleData);
      SizeArray = Particle_GetSizeArray(pParticleData);
      v15 = SizeArray;
      if ( (_DWORD)m_particleCountRunning )
      {
        v16 = (char *)ColorArray - (char *)SizeArray;
        do
        {
          ParticleEmitter::GetWorldPos((ParticleEmitter *)pEmitterOwner, PositionArray, &posWorld, pParticleState, EmitterTransform);
          _XMM1 = posWorld.v;
          center.v[0] = posWorld.v.m128_f32[0];
          __asm
          {
            vextractps dword ptr [rsp+0C8h+center+4], xmm1, 1
            vextractps dword ptr [rsp+0C8h+center+8], xmm1, 2
          }
          color = *(vec4_t *)((char *)v15 + v16);
          Particle_DebugSphere(&center, COERCE_FLOAT(*v15), &color, 1, 0);
          Particle_DebugSphere(&center, 3.0, &colorOrange, 1, 0);
          ++PositionArray;
          ++v15;
          --m_particleCountRunning;
        }
        while ( m_particleCountRunning );
      }
    }
  }
}

/*
==============
ParticleModuleInitLightSpot::DebugDraw
==============
*/
void ParticleModuleInitLightSpot::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  __int128 v4; 
  __int128 v5; 
  ParticleState::ElementTypeModule v9; 
  bool v10; 
  __int64 m_particleCountRunning; 
  const vector4 *EmitterTransform; 
  float4 *SizeArray; 
  float4 *RotationAngleArray; 
  float4 *ColorArray; 
  const ParticleStateDef *m_pStateDef; 
  float4 v17; 
  int v18; 
  signed __int64 v19; 
  signed __int64 v20; 
  __int64 v21; 
  __m128 v22; 
  const float4 *v23; 
  float4 *v24; 
  const vector4 *v25; 
  __int128 v26; 
  __int128 v27; 
  __int128 v28; 
  __m128 v; 
  const float4 *v30; 
  vector3 *v31; 
  const vector4 *v32; 
  const vector4 *v33; 
  __m256i v34; 
  __m256i v35; 
  __m128 v36; 
  float4 v37; 
  float v40; 
  float v41; 
  __m128 v42; 
  __m128 v43; 
  float v44; 
  vec4_t v48; 
  float4 *PositionArray; 
  __int64 v50; 
  vector4 M1; 
  __m256i v52; 
  __m256i v53; 
  __m256i v54; 
  __m256i v55; 
  __m256i v56; 
  __m256i v57; 
  __m256i v58; 
  vector4 result; 
  vec3_t center; 
  vec3_t start; 
  vec4_t color; 
  tmat33_t<vec3_t> rotation; 

  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_lights->current.enabled )
  {
    v9.pModule = (const ParticleModule *)pParticleState->m_elementTypeModule;
    v10 = v9.pModule && (v9.pModule->m_flags & 1) == 0;
    if ( pParticleState->m_pStateDef->elementType == 6 && v10 )
    {
      m_particleCountRunning = pParticleData->m_particleCountRunning;
      EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
      PositionArray = Particle_GetPositionArray(pParticleData);
      SizeArray = Particle_GetSizeArray(pParticleData);
      RotationAngleArray = Particle_GetRotationAngleArray(pParticleData);
      ColorArray = Particle_GetColorArray(pParticleData);
      m_pStateDef = pParticleState->m_pStateDef;
      v17.v = (__m128)LODWORD(FLOAT_1_5707964);
      *(_QWORD *)center.v = ColorArray;
      v18 = m_pStateDef->flags & 0xF0;
      color = (vec4_t)g_0100.v;
      Float4x4RotationAroundUnitAxis(&result, (const float4 *)&color, 1.5707964);
      if ( (_DWORD)m_particleCountRunning )
      {
        v19 = (char *)SizeArray - (char *)RotationAngleArray;
        v20 = (char *)PositionArray - (char *)RotationAngleArray;
        *(_QWORD *)center.v -= RotationAngleArray;
        v50 = m_particleCountRunning;
        v21 = *(_QWORD *)center.v;
        do
        {
          v22 = *(__m128 *)((char *)&RotationAngleArray->v + v19);
          M1.w = (float4)g_unit.v;
          v26 = *(unsigned int *)&v9.pModule[3].m_type;
          *(float *)&v26 = tanf_0(*(float *)&v26);
          v28 = v26;
          *(float *)&v28 = *(float *)&v26 * v22.m128_f32[0];
          v27 = v28;
          if ( v18 )
          {
            v = RotationAngleArray->v;
            Float4RadianToQuat(v24, v23);
            Float4UnitQuatToAxis(v31, v30);
            *(_OWORD *)&v58.m256i_u64[2] = v4;
            *(__m128 *)v58.m256i_i8 = v;
            *(__m256i *)M1.x.v.m128_f32 = v58;
            M1.z = (float4)v17.v;
            Float4x4Mul(&result, &M1, v32);
            *(float4 *)v53.m256i_i8 = (float4)v17.v;
            *(__m128 *)v52.m256i_i8 = v;
            *(float4 *)&v53.m256i_u64[2] = (float4)v17.v;
            *(_OWORD *)&v52.m256i_u64[2] = v4;
            *(__m256i *)M1.x.v.m128_f32 = v52;
            *(__m256i *)M1.z.v.m128_f32 = v53;
            Float4x4Mul(&M1, EmitterTransform, v33);
            *(float4 *)v55.m256i_i8 = (float4)v17.v;
            *(__m128 *)v54.m256i_i8 = v;
            *(float4 *)&v55.m256i_u64[2] = (float4)v17.v;
            v34 = v55;
            *(_OWORD *)&v54.m256i_u64[2] = v4;
            v35 = v54;
          }
          else
          {
            Float4x4Mul(&result, EmitterTransform, v25);
            *(float4 *)v57.m256i_i8 = (float4)v17.v;
            *(_OWORD *)v56.m256i_i8 = v26;
            *(_OWORD *)&v57.m256i_u64[2] = v5;
            v34 = v57;
            *(_OWORD *)&v56.m256i_u64[2] = v4;
            v35 = v56;
          }
          v36 = *(__m128 *)((char *)&RotationAngleArray->v + v20);
          *(__m256i *)M1.z.v.m128_f32 = v34;
          v37.v = (__m128)M1.z;
          *(__m256i *)M1.x.v.m128_f32 = v35;
          _XMM1.v = (__m128)M1.x;
          _XMM2.v = (__m128)M1.y;
          rotation.m[0].v[0] = M1.x.v.m128_f32[0];
          __asm
          {
            vextractps dword ptr [rsp+2F8h+rotation+4], xmm1, 1
            vextractps dword ptr [rsp+2F8h+rotation+8], xmm1, 2
          }
          rotation.m[1].v[0] = M1.y.v.m128_f32[0];
          __asm
          {
            vextractps dword ptr [rsp+2F8h+rotation+10h], xmm2, 1
            vextractps dword ptr [rsp+2F8h+rotation+14h], xmm2, 2
          }
          v40 = _mm_shuffle_ps(v36, v36, 85).m128_f32[0];
          v41 = _mm_shuffle_ps(v36, v36, 170).m128_f32[0];
          v42 = _mm_shuffle_ps(v37.v, v37.v, 85);
          v43 = v42;
          v44 = _mm_shuffle_ps(v37.v, v37.v, 170).m128_f32[0];
          v43.m128_f32[0] = fsqrt((float)((float)(v42.m128_f32[0] * v42.m128_f32[0]) + (float)(v37.v.m128_f32[0] * v37.v.m128_f32[0])) + (float)(v44 * v44));
          _XMM3 = v43;
          __asm
          {
            vcmpless xmm0, xmm3, cs:__real@80000000
            vblendvps xmm0, xmm3, xmm14, xmm0
          }
          _XMM2.v.m128_f32[0] = (float)((float)(M1.z.v.m128_f32[0] * (float)(1.0 / *(float *)&_XMM0)) * COERCE_FLOAT(v22.m128_i32[0] ^ _xmm)) + v36.m128_f32[0];
          start.v[0] = v36.m128_f32[0];
          v36.m128_f32[0] = (float)((float)(v42.m128_f32[0] * (float)(1.0 / *(float *)&_XMM0)) * COERCE_FLOAT(v22.m128_i32[0] ^ _xmm)) + v40;
          v43.m128_f32[0] = (float)(v44 * (float)(1.0 / *(float *)&_XMM0)) * COERCE_FLOAT(v22.m128_i32[0] ^ _xmm);
          v48 = *(vec4_t *)((char *)RotationAngleArray + v21);
          center.v[1] = v36.m128_f32[0];
          center.v[0] = _XMM2.v.m128_f32[0];
          v5 = v27;
          v17.v = v22;
          center.v[2] = v43.m128_f32[0] + v41;
          rotation.m[2].v[0] = M1.z.v.m128_f32[0];
          rotation.m[2].v[1] = v42.m128_f32[0];
          rotation.m[2].v[2] = v44;
          start.v[1] = v40;
          start.v[2] = v41;
          color = v48;
          Particle_DebugCone(&center, &rotation, v22.m128_f32[0], *(float *)&v27, &color, 1, 0);
          Particle_DebugLine(&start, &center, &colorOrange, 1, 0);
          Particle_DebugSphere(&start, 3.0, &color, 1, 0);
          v4 = LODWORD(FLOAT_3_0);
          Particle_DebugSphere(&center, 3.0, &colorOrange, 1, 0);
          ++RotationAngleArray;
          --v50;
        }
        while ( v50 );
      }
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeBox::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  bool useWorldSpace; 
  float4 dimensionsMax; 
  float4 dimensionsMin; 
  vec3_t origin; 
  Bounds bounds; 
  vec3_t outAngles; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1479, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1480, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1481, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1482, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)pModuleBase, pParticleState, &dimensionsMin, &dimensionsMax);
    _XMM6 = _mm128_mul_ps(_mm128_sub_ps(dimensionsMax.v, dimensionsMin.v), (__m128)_xmm);
    useWorldSpace = (pModuleBase->m_flags & 0x80) != 0;
    dimensionsMin.v = _mm128_sub_ps(dimensionsMax.v, _XMM6);
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &dimensionsMin, &dimensionsMax, &outAngles, useWorldSpace);
    _XMM1 = dimensionsMax.v;
    origin.v[0] = dimensionsMax.v.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+0C8h+origin+4], xmm1, 1
      vextractps dword ptr [rsp+0C8h+origin+8], xmm1, 2
    }
    bounds.midPoint.v[0] = 0.0;
    bounds.midPoint.v[1] = 0.0;
    bounds.midPoint.v[2] = 0.0;
    bounds.halfSize.v[0] = _XMM6.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+0C8h+bounds.halfSize+4], xmm6, 1
      vextractps dword ptr [rsp+0C8h+bounds.halfSize+8], xmm6, 2
    }
    Particle_DebugBox(&origin, &bounds, &outAngles, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeCylinder::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  __m128 v4; 
  float4 v5; 
  __int128 v6; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  bool v12; 
  __m128 v13; 
  ParticleRelativeVelocityType m_velocityType; 
  bool v15; 
  const vector4 *EmitterTransform; 
  const float4 *v17; 
  vector3 *v18; 
  __int128 v19; 
  const vector4 *v20; 
  __m128 v; 
  __m128 v22; 
  ParticleEmitter *EmitterOwner; 
  const vector4 *EmitterTransformTranspose; 
  float4 outOffset; 
  __m256i v26; 
  __m256i v27; 
  vector4 result; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1873, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1874, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1875, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1876, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    v12 = (pModuleBase->m_flags & 0x80) != 0;
    v13 = 0i64;
    v15 = 0;
    if ( m_pModuleInitRelativeVelocity )
    {
      if ( (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 )
      {
        m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
        if ( m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
          v15 = 1;
      }
    }
    result.w = (float4)g_unit.v;
    EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
    if ( v15 )
    {
      v4 = _mm_shuffle_ps(*(__m128 *)&pModuleBase[2].m_type, _mm_shuffle_ps(*(__m128 *)&pModuleBase[2].m_type, (__m128)0i64, 250), 132);
      v13 = _mm128_add_ps(v4, *(__m128 *)&pModuleBase[4].m_type);
    }
    v19 = *(_OWORD *)&pModuleBase[8].m_type;
    Float4UnitQuatToAxis(v18, v17);
    *(__m128 *)&v26.m256i_u64[2] = v4;
    *(_OWORD *)v26.m256i_i8 = v19;
    *(__m256i *)result.x.v.m128_f32 = v26;
    result.z = (float4)v5.v;
    if ( v12 )
    {
      v = outOffset.v;
    }
    else
    {
      Float4x4Mul(&result, EmitterTransform, v20);
      *(float4 *)v27.m256i_i8 = (float4)v5.v;
      *(_OWORD *)v26.m256i_i8 = v19;
      *(__m128 *)&v26.m256i_u64[2] = v4;
      *(__m256i *)result.x.v.m128_f32 = v26;
      *(_OWORD *)&v27.m256i_u64[2] = v6;
      *(__m256i *)result.z.v.m128_f32 = v27;
      v = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 85), EmitterTransform->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 170), EmitterTransform->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 0), EmitterTransform->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
      if ( v15 )
        v13 = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v13, v13, 85), EmitterTransform->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v13, v13, 170), EmitterTransform->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v13, v13, 0), EmitterTransform->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
    }
    v22 = _mm128_add_ps(v, EmitterTransform->w.v);
    outOffset.v = v22;
    if ( v12 )
    {
      EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
      EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
      outOffset.v = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v22, v22, 85), EmitterTransformTranspose->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v22, v22, 170), EmitterTransformTranspose->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v22, v22, 0), EmitterTransformTranspose->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
    }
    Particle_SpawnShapeDrawCylinder(&outOffset, &result, &colorLtGreen, pParticleState, (const ParticleModuleInitSpawnShapeCylinder *)pModuleBase);
    if ( v15 )
    {
      outOffset.v = _mm128_add_ps(v13, EmitterTransform->w.v);
      Particle_SpawnShapeDrawCylinder(&outOffset, &result, &colorLtBlue, pParticleState, (const ParticleModuleInitSpawnShapeCylinder *)pModuleBase);
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  bool v8; 
  float4 *p_outShapeOrigin; 
  float4 outShapeOrigin; 
  vec3_t center; 
  float4 outOffset; 
  vec3_t outAngles; 
  float4 radiusMax; 
  float4 radiusMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2031, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2032, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2033, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2034, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
    ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &outOffset, &outShapeOrigin, &outAngles, (pModuleBase->m_flags & 0x80) != 0);
    v8 = (HIBYTE(pModuleBase[1].m_type) & 1) == 0;
    _XMM1 = outShapeOrigin.v;
    center.v[0] = outShapeOrigin.v.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbp+57h+center+4], xmm1, 1
      vextractps dword ptr [rbp+57h+center+8], xmm1, 2
    }
    p_outShapeOrigin = &outShapeOrigin;
    if ( v8 )
    {
      _XMM1 = radiusMin.v;
      _XMM2 = radiusMax.v;
      outShapeOrigin.v.m128_f32[0] = radiusMin.v.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+4], xmm1, 1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+8], xmm1, 2
      }
      outOffset.v.m128_f32[0] = radiusMax.v.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rbp+57h+outOffset.v+4], xmm2, 1
        vextractps dword ptr [rbp+57h+outOffset.v+8], xmm2, 2
      }
      Particle_DebugEllipsoid(&center, &outAngles, (const vec3_t *)&outShapeOrigin, &colorLtGreen, 1, 0);
      p_outShapeOrigin = &outOffset;
    }
    else
    {
      _XMM1 = radiusMax.v;
      outShapeOrigin.v.m128_f32[0] = radiusMax.v.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+4], xmm1, 1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+8], xmm1, 2
      }
    }
    Particle_DebugEllipsoid(&center, &outAngles, (const vec3_t *)p_outShapeOrigin, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeSphere::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  float radiusMax; 
  float radiusMin[3]; 
  float4 outOffset; 
  float4 outShapeOrigin; 
  vec3_t center; 
  vec3_t outAngles; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2342, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2343, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2344, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2345, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
    ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)pModuleBase, pParticleState, radiusMin, &radiusMax);
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &outOffset, &outShapeOrigin, &outAngles, (pModuleBase->m_flags & 0x80) != 0);
    _XMM1 = outShapeOrigin.v;
    center.v[0] = outShapeOrigin.v.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+0B8h+center+4], xmm1, 1
      vextractps dword ptr [rsp+0B8h+center+8], xmm1, 2
    }
    if ( (HIBYTE(pModuleBase[1].m_type) & 1) == 0 )
      Particle_DebugSphere(&center, radiusMin[0], &colorLtGreen, 1, 0);
    Particle_DebugSphere(&center, radiusMax, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleInitVolumetric::DebugDraw
==============
*/
void ParticleModuleInitVolumetric::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  __int64 m_particleCountRunning; 
  float4 *PositionArray; 
  unsigned __int8 *ParticleDataArray; 
  ParticleEmitter *v11; 
  const vector4 *EmitterTransform; 
  const ParticleSystem *SystemOwner; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  ParticleRelativeVelocityType m_velocityType; 
  const float4 *v16; 
  signed __int64 v17; 
  const ParticleModuleInitRelativeVelocity *v18; 
  __m128 v; 
  const ParticleStateDef *m_pStateDef; 
  float4 *v22; 
  const ParticleSystem *v23; 
  __m128 v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  const dvar_t *v33; 
  char v34; 
  float4 *RotationAngleArray; 
  const float4 *v36; 
  float4 *SizeArray; 
  signed __int64 v38; 
  __int64 v40; 
  vec4_t v41; 
  vec3_t center; 
  vec4_t quat; 
  vec3_t size; 
  vec3_t angles; 
  tmat33_t<vec3_t> axis; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2396, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2397, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2398, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2399, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    m_particleCountRunning = pParticleData->m_particleCountRunning;
    PositionArray = Particle_GetPositionArray(pParticleData);
    SizeArray = Particle_GetSizeArray(pParticleData);
    RotationAngleArray = Particle_GetRotationAngleArray(pParticleData);
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    ParticleDataArray = ParticleData::GetParticleDataArray((ParticleData *)pParticleData, PARTICLE_DATA_SPAWN_QUAT);
    v11 = (ParticleEmitter *)pEmitterOwner;
    v40 = pParticleState->m_pStateDef->flags & 0xA0;
    EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    v34 = SystemOwner->m_flags & 1;
    if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
      m_velocityType = PARTICLE_RELATIVE_VELOCITY_TYPE_LOCAL;
    else
      m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
    Particle_RotMatrixToQuatVec(EmitterTransform, &quat);
    v41 = quat;
    if ( (_DWORD)m_particleCountRunning )
    {
      v38 = (char *)SizeArray - (char *)PositionArray;
      v16 = (const float4 *)((char *)RotationAngleArray - (char *)PositionArray);
      v17 = ParticleDataArray - (unsigned __int8 *)PositionArray;
      v36 = (const float4 *)((char *)RotationAngleArray - (char *)PositionArray);
      do
      {
        v18 = pParticleState->m_pModuleInitRelativeVelocity;
        if ( !v18 || (v18->m_flags & 1) != 0 || ((v18->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
        {
          _XMM6 = PositionArray->v;
        }
        else
        {
          v = PositionArray->v;
          _XMM6 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), EmitterTransform->x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), EmitterTransform->y.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), EmitterTransform->z.v), EmitterTransform->w.v)));
        }
        m_pStateDef = pParticleState->m_pStateDef;
        v22 = (float4 *)((unsigned __int64)LODWORD(m_pStateDef->flags) >> 28);
        if ( (m_pStateDef->flags & 0x10000000) != 0 )
        {
          v23 = ParticleEmitter::GetSystemOwner(v11);
          v16 = v36;
          _XMM6 = _mm128_add_ps(_XMM6, v23->m_systemTransform.w.v);
        }
        center.v[0] = _XMM6.m128_f32[0];
        __asm
        {
          vextractps dword ptr [rbp+0E0h+center+4], xmm6, 1
          vextractps dword ptr [rbp+0E0h+center+8], xmm6, 2
        }
        _XMM2 = *(__int128 *)((char *)PositionArray + v38);
        LODWORD(size.v[0]) = _XMM2;
        __asm
        {
          vextractps dword ptr [rbp+0E0h+size+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+size+8], xmm2, 2
        }
        if ( v40 )
        {
          v25 = *(__m128 *)((char *)&PositionArray->v + (_QWORD)v16);
          Float4RadianToQuat(v22, v16);
          v26 = _mm_shuffle_ps(v25, v25, 255).m128_f32[0];
          v27 = _mm_shuffle_ps(v25, v25, 170).m128_f32[0];
          v28 = _mm_shuffle_ps(v25, v25, 85).m128_f32[0];
          v29 = (float)((float)((float)(quat.v[0] * v26) + (float)(quat.v[3] * v25.m128_f32[0])) + (float)(quat.v[1] * v27)) - (float)(quat.v[2] * v28);
          v30 = (float)((float)((float)(v28 * quat.v[3]) - (float)(v27 * quat.v[0])) + (float)(quat.v[1] * v26)) + (float)(quat.v[2] * v25.m128_f32[0]);
          v31 = (float)((float)((float)(v28 * quat.v[0]) + (float)(v27 * quat.v[3])) - (float)(quat.v[1] * v25.m128_f32[0])) + (float)(quat.v[2] * v26);
          v32 = (float)((float)((float)(v26 * quat.v[3]) - (float)(quat.v[0] * v25.m128_f32[0])) - (float)(v28 * quat.v[1])) - (float)(quat.v[2] * v27);
          v41.v[3] = v32;
          v41.v[0] = v29;
          v41.v[1] = v30;
          v41.v[2] = v31;
        }
        else
        {
          if ( m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO || v34 && m_velocityType != PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
          {
            v41 = *(vec4_t *)((char *)PositionArray + v17);
            LODWORD(v32) = _mm_shuffle_ps((__m128)v41, (__m128)v41, 255).m128_u32[0];
          }
          else
          {
            v32 = v41.v[3];
          }
          v31 = v41.v[2];
          v30 = v41.v[1];
          v29 = v41.v[0];
        }
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)((float)(v29 * v29) + (float)(v30 * v30)) + (float)(v31 * v31)) + (float)(v32 * v32)) - 1.0) & _xmm) >= 0.0040000002 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 698, ASSERT_TYPE_ASSERT, "(Particle_Vec4IsNormalized( outQuat ))", "%s\n\t%g %g %g %g", "Particle_Vec4IsNormalized( outQuat )", v29, v30, v31, v32) )
          __debugbreak();
        QuatToAxis(&v41, &axis);
        AxisToAngles(&axis, &angles);
        Particle_DebugEllipsoid(&center, &angles, &size, &colorRedHeat, 1, 0);
        v33 = particle_show_axes;
        if ( !particle_show_axes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 620, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v33);
        if ( v33->current.enabled )
          Particle_DebugAxis(&axis, &center, particle_axes_length->current.value, 1, 0);
        v11 = (ParticleEmitter *)pEmitterOwner;
        ++PositionArray;
        v16 = v36;
        --m_particleCountRunning;
      }
      while ( m_particleCountRunning );
    }
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetCalculationOffset
==============
*/
void ParticleModuleInitSpawnShape::GetCalculationOffset(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, const ParticleState *pParticleState, float4 *outCalculationOffset)
{
  float4 v5; 
  const vector4 *EmitterTransformTranspose; 
  __m128 v7; 
  __m128 v8; 
  __m128 v9; 
  __m128 v10; 
  __m128 v; 
  __m128 v12; 
  __m128 v13; 
  __m128 v14; 
  __m128 v15; 

  v5.v = _mm_shuffle_ps(this->m_calculationOffset.v, _mm_shuffle_ps(this->m_calculationOffset.v, (__m128)0i64, 250), 132);
  if ( (this->m_flags & 0x80) != 0 )
  {
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose((ParticleEmitter *)pEmitter, pParticleState);
    v7 = _mm_shuffle_ps(v5.v, v5.v, 0);
    v8 = _mm_shuffle_ps(v5.v, v5.v, 85);
    v9 = _mm_shuffle_ps(v5.v, v5.v, 170);
    v10 = _mm_shuffle_ps(EmitterTransformTranspose->x.v, EmitterTransformTranspose->y.v, 238);
    v = EmitterTransformTranspose->z.v;
    v12 = _mm_shuffle_ps(v, EmitterTransformTranspose->w.v, 68);
    v13 = _mm_shuffle_ps(v, EmitterTransformTranspose->w.v, 238);
    v14 = _mm_shuffle_ps(v5.v, v5.v, 255);
    v15 = _mm_shuffle_ps(EmitterTransformTranspose->x.v, EmitterTransformTranspose->y.v, 68);
    outCalculationOffset->v = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(v14, _mm_shuffle_ps(v10, v13, 221)), _mm128_add_ps(_mm128_mul_ps(v8, _mm_shuffle_ps(v15, v12, 221)), g_negativeZero.v)), _mm128_add_ps(_mm128_mul_ps(v9, _mm_shuffle_ps(v10, v13, 136)), _mm128_add_ps(_mm128_mul_ps(v7, _mm_shuffle_ps(v15, v12, 136)), g_negativeZero.v)));
  }
  else
  {
    *outCalculationOffset = (float4)v5.v;
  }
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeBox::GetDimensions(ParticleModuleInitSpawnShapeBox *this, const ParticleState *pParticleState, float4 *dimensionsMin, float4 *dimensionsMax)
{
  ParticleEmitter *m_pEmitterOwner; 
  const ParticleSystem *SystemOwner; 
  ParticleSpawnFlags m_spawnFlags; 
  ParticleSystem *v11; 
  bool v12; 
  char v17; 
  float m_emitterLifeNormalized; 
  __m128 v; 
  __m128 v20; 
  float4 *v21; 
  float4 result; 
  float4 v23; 
  float4 v24; 

  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1338, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  m_spawnFlags = this->m_spawnFlags;
  v11 = (ParticleSystem *)SystemOwner;
  v12 = (m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0;
  if ( this->m_useBeamInfo && (SystemOwner->m_flags & 0x100) != 0 )
  {
    ParticleEmitter::GetBeamLength(m_pEmitterOwner, pParticleState);
    _XMM2.v = (__m128)this->m_dimensionsMin;
    _XMM3.v = (__m128)this->m_dimensionsMax;
    __asm
    {
      vinsertps xmm2, xmm2, xmm1, 10h
      vinsertps xmm3, xmm3, xmm0, 10h
    }
    *dimensionsMin = (float4)_XMM2.v;
    *dimensionsMax = (float4)_XMM3.v;
  }
  else
  {
    v17 = m_spawnFlags & 2;
    if ( v17 || v12 )
    {
      if ( v17 )
      {
        m_emitterLifeNormalized = m_pEmitterOwner->m_emitterLifeNormalized;
        v = Particle_GetCurveValueFloat4(&result, this->m_curves, m_emitterLifeNormalized)->v;
        v20 = Particle_GetCurveValueFloat4(&result, &this->m_curves[3], m_emitterLifeNormalized)->v;
      }
      else
      {
        v = this->m_offset.v;
        v20 = _mm128_sub_ps(this->m_dimensionsMax.v, v);
      }
      v23.v = v20;
      if ( v12 )
      {
        result.v = 0i64;
        *dimensionsMin = (float4)ParticleSystem::ApplyScaleModifiers(v11, &v24, &v23, -1, &result, 0)->v;
        result.v = g_one.v;
        v21 = ParticleSystem::ApplyScaleModifiers(v11, &v24, &v23, -1, &result, 0);
        *dimensionsMax = (float4)v21->v;
        v20 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(v21->v, dimensionsMin->v), g_oneHalf.v), dimensionsMin->v);
      }
      dimensionsMax->v = _mm128_add_ps(v20, v);
      dimensionsMin->v = _mm128_add_ps(_mm128_sub_ps((__m128)0i64, v20), v);
    }
    else
    {
      *dimensionsMin = this->m_dimensionsMin;
      *dimensionsMax = this->m_dimensionsMax;
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeCylinder::GetDimensions(ParticleModuleInitSpawnShapeCylinder *this, const ParticleState *pParticleState, float *halfHeight, float *radiusMin, float *radiusMax)
{
  ParticleEmitter *m_pEmitterOwner; 
  ParticleSystem *SystemOwner; 
  float m_emitterLifeNormalized; 
  double CurveValue; 
  double v13; 
  float4 *v22; 
  __m128 v; 
  __m128 v26; 
  float4 v29; 
  float4 v30; 
  float4 v31; 
  float4 v32; 

  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    m_emitterLifeNormalized = m_pEmitterOwner->m_emitterLifeNormalized;
    CurveValue = Particle_GetCurveValue(&this->m_curves[4], m_emitterLifeNormalized);
    *radiusMin = *(float *)&CurveValue;
    *radiusMax = *(float *)&CurveValue;
    v13 = Particle_GetCurveValue(&this->m_curves[3], m_emitterLifeNormalized);
    *halfHeight = *(float *)&v13;
  }
  else
  {
    *halfHeight = this->m_halfHeight;
    *radiusMin = this->m_radius.min;
    *radiusMax = this->m_radius.max;
  }
  if ( (this->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    _XMM1 = _xmm;
    __asm { vinsertps xmm1, xmm1, dword ptr [rsi], 0 }
    _XMM2 = _xmm;
    __asm
    {
      vinsertps xmm2, xmm2, dword ptr [r14], 0
      vinsertps xmm1, xmm1, dword ptr [rsi], 10h
      vinsertps xmm2, xmm2, dword ptr [r14], 10h
      vinsertps xmm1, xmm1, dword ptr [rdi], 20h ; ' '
      vinsertps xmm2, xmm2, dword ptr [rdi], 20h ; ' '
    }
    v30.v = _XMM1;
    v31.v = _XMM2;
    v29.v = 0i64;
    v30.v = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v32, &v30, -1, &v29, 0)->v;
    v29.v = g_one.v;
    v22 = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v32, &v31, -1, &v29, 0);
    v = v30.v;
    _XMM0 = _mm_shuffle_ps(v, v, 85);
    __asm { vminss  xmm0, xmm0, xmm3 }
    v26 = v22->v;
    *radiusMin = *(float *)&_XMM0;
    _XMM1 = _mm_shuffle_ps(v26, v26, 85);
    __asm { vmaxss  xmm0, xmm1, xmm2 }
    *radiusMax = *(float *)&_XMM0;
    *halfHeight = (float)(_mm_shuffle_ps(v26, v26, 170).m128_f32[0] + _mm_shuffle_ps(v, v, 170).m128_f32[0]) * 0.5;
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::GetDimensions(ParticleModuleInitSpawnShapeEllipsoid *this, const ParticleState *pParticleState, float4 *radiusMin, float4 *radiusMax)
{
  ParticleEmitter *m_pEmitterOwner; 
  ParticleSystem *SystemOwner; 
  float4 *CurveValueFloat4; 
  float4 v11; 
  float4 result; 
  float4 v13; 

  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    CurveValueFloat4 = Particle_GetCurveValueFloat4(&result, &this->m_curves[3], m_pEmitterOwner->m_emitterLifeNormalized);
    v11.v = CurveValueFloat4->v;
    *radiusMin = (float4)CurveValueFloat4->v;
    *radiusMax = (float4)v11.v;
  }
  else
  {
    *radiusMin = this->m_radiusMin;
    *radiusMax = this->m_radiusMax;
  }
  if ( (this->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    result.v = 0i64;
    *radiusMin = (float4)ParticleSystem::ApplyScaleModifiers(SystemOwner, &v13, radiusMin, -1, &result, 0)->v;
    result.v = g_one.v;
    *radiusMax = (float4)ParticleSystem::ApplyScaleModifiers(SystemOwner, &v13, radiusMax, -1, &result, 0)->v;
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeSphere::GetDimensions(ParticleModuleInitSpawnShapeSphere *this, const ParticleState *pParticleState, float *radiusMin, float *radiusMax)
{
  ParticleEmitter *m_pEmitterOwner; 
  ParticleSystem *SystemOwner; 
  double CurveValue; 
  float4 *v19; 
  __m128 v; 
  __m128 v23; 
  float4 v28; 
  float4 v29; 
  float4 v30; 
  float4 v31; 
  float4 v32; 
  float4 v33; 

  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    CurveValue = Particle_GetCurveValue(&this->m_curves[3], m_pEmitterOwner->m_emitterLifeNormalized);
    *radiusMin = *(float *)&CurveValue;
  }
  else
  {
    *radiusMin = this->m_radius.min;
    *(float *)&CurveValue = this->m_radius.max;
  }
  *radiusMax = *(float *)&CurveValue;
  if ( (this->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    _XMM1 = _xmm;
    _XMM2 = _xmm;
    __asm
    {
      vinsertps xmm1, xmm1, xmm0, 0
      vinsertps xmm1, xmm1, xmm0, 10h
      vinsertps xmm1, xmm1, xmm0, 20h ; ' '
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm0, 10h
      vinsertps xmm2, xmm2, xmm0, 20h ; ' '
    }
    v28.v = 0i64;
    v30.v = _XMM1;
    v31.v = _XMM2;
    v30.v = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v32, &v30, -1, &v28, 0)->v;
    v29.v = g_one.v;
    v19 = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v33, &v31, -1, &v29, 0);
    v = v30.v;
    _XMM0 = _mm_shuffle_ps(v, v, 85);
    __asm { vminss  xmm0, xmm0, xmm1 }
    v23 = v19->v;
    _mm_shuffle_ps(v, v, 170);
    __asm { vminss  xmm1, xmm0, xmm2 }
    *radiusMin = *(float *)&_XMM1;
    _XMM0 = _mm_shuffle_ps(v23, v23, 85);
    __asm { vmaxss  xmm0, xmm0, xmm4 }
    _mm_shuffle_ps(v23, v23, 170);
    __asm { vmaxss  xmm1, xmm0, xmm3 }
    *radiusMax = *(float *)&_XMM1;
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/
void ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, float4 *outOffset)
{
  float m_emitterLifeNormalized; 
  const ParticleCurveDef *ModuleCurveList; 
  float4 result; 

  if ( (this->m_spawnFlags & 2) != 0 )
  {
    m_emitterLifeNormalized = pEmitter->m_emitterLifeNormalized;
    ModuleCurveList = ParticleModule::GetModuleCurveList(this);
    *outOffset = (float4)Particle_GetCurveValueFloat4(&result, ModuleCurveList, m_emitterLifeNormalized)->v;
  }
  else
  {
    *outOffset = this->m_offset;
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/
void ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, float4 *outOffset)
{
  float m_emitterLifeNormalized; 
  const ParticleCurveDef *ModuleCurveList; 
  float4 v8; 
  float4 result; 

  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    m_emitterLifeNormalized = pParticleState->m_pEmitterOwner->m_emitterLifeNormalized;
    ModuleCurveList = ParticleModule::GetModuleCurveList(this);
    v8.v = Particle_GetCurveValueFloat4(&result, ModuleCurveList, m_emitterLifeNormalized)->v;
  }
  else
  {
    v8.v = (__m128)this->m_offset;
  }
  *outOffset = (float4)v8.v;
}

/*
==============
ParticleModuleInitSpawnShape::GetRandomSeed
==============
*/
__int64 ParticleModuleInitSpawnShape::GetRandomSeed(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, ParticleData *pParticleData, const int particleIndex)
{
  unsigned __int8 v4; 
  ParticleEmitter *EmitterOwner; 

  v4 = particleIndex;
  if ( (this->m_spawnFlags & 8) == 0 )
    return (unsigned int)Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[particleIndex];
  EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
  return (ParticleEmitter::GetEmitterDef(EmitterOwner)->randomSeed + EmitterOwner->m_lifetimeParticleCount + 10111 * v4) % 0x3FE9;
}

/*
==============
ParticleModuleInitSpawnShape::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShape::GetVolumeSize(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState)
{
  const ParticleSystem *SystemOwner; 
  ParticleSpawnFlags m_spawnFlags; 
  double VolumeSize; 
  __m128 v8; 
  float v9; 
  float radiusMax; 
  float radiusMin; 
  float v12; 
  float4 dimensionsMin; 
  float4 dimensionsMax; 

  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1237, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pParticleState->m_pEmitterOwner);
  m_spawnFlags = this->m_spawnFlags;
  if ( ((m_spawnFlags & 4) == 0 || (SystemOwner->m_flags & 0x40000000) == 0) && (m_spawnFlags & 2) == 0 )
    return this->m_volumeCubeRoot;
  if ( this->m_spawnType )
  {
    switch ( this->m_spawnType )
    {
      case PARTICLE_SPAWN_SHAPE_CYLINDER:
        ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)this, pParticleState, &radiusMax, &v12, &radiusMin);
        if ( (this->m_spawnFlags & 1) != 0 || COERCE_FLOAT(COERCE_UNSIGNED_INT(radiusMin - v12) & _xmm) < 0.001 )
          *(float *)&VolumeSize = (float)(radiusMin * radiusMax) * 12.566371;
        else
          LODWORD(VolumeSize) = COERCE_UNSIGNED_INT((float)((float)(radiusMin * radiusMin) * (float)((float)(radiusMax * 3.1415927) * 2.0)) - (float)((float)(v12 * v12) * (float)((float)(radiusMax * 3.1415927) * 2.0))) & _xmm;
        break;
      case PARTICLE_SPAWN_SHAPE_ELLIPSOID:
        ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)this, pParticleState, &dimensionsMax, &dimensionsMin);
        VolumeSize = ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize((ParticleModuleInitSpawnShapeEllipsoid *)this, &dimensionsMax, &dimensionsMin);
        break;
      case PARTICLE_SPAWN_SHAPE_SPHERE:
        ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)this, pParticleState, &radiusMin, &radiusMax);
        if ( (this->m_spawnFlags & 1) != 0 || COERCE_FLOAT(COERCE_UNSIGNED_INT(radiusMax - radiusMin) & _xmm) < 0.001 )
          *(float *)&VolumeSize = (float)(radiusMax * 12.566371) * radiusMax;
        else
          LODWORD(VolumeSize) = COERCE_UNSIGNED_INT((float)((float)((float)(radiusMax * radiusMax) * radiusMax) * 4.1887903) - (float)((float)((float)(radiusMin * radiusMin) * radiusMin) * 4.1887903)) & _xmm;
        break;
      default:
        return FLOAT_1_0;
    }
  }
  else
  {
    ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)this, pParticleState, &dimensionsMin, &dimensionsMax);
    v8 = _mm128_sub_ps(dimensionsMax.v, dimensionsMin.v);
    if ( (this->m_spawnFlags & 1) != 0 )
    {
      v9 = _mm_shuffle_ps(v8, v8, 85).m128_f32[0];
      *(float *)&VolumeSize = (float)((float)((float)(v9 + v8.m128_f32[0]) * _mm_shuffle_ps(v8, v8, 170).m128_f32[0]) + (float)(v9 * v8.m128_f32[0])) * 2.0;
    }
    else
    {
      *(float *)&VolumeSize = (float)(_mm_shuffle_ps(v8, v8, 85).m128_f32[0] * v8.m128_f32[0]) * _mm_shuffle_ps(v8, v8, 170).m128_f32[0];
    }
  }
  return cbrtf(*(float *)&VolumeSize);
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeBox::GetVolumeSize(ParticleModuleInitSpawnShapeBox *this, const float4 *dimensions)
{
  if ( (this->m_spawnFlags & 1) != 0 )
    return (float)((float)((float)(COERCE_FLOAT(*dimensions) + dimensions->v.m128_f32[1]) * dimensions->v.m128_f32[2]) + (float)(COERCE_FLOAT(*dimensions) * dimensions->v.m128_f32[1])) * 2.0;
  else
    return (float)(COERCE_FLOAT(*dimensions) * dimensions->v.m128_f32[1]) * dimensions->v.m128_f32[2];
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeCylinder::GetVolumeSize(ParticleModuleInitSpawnShapeCylinder *this, const float halfHeight, const float radiusMin, const float radiusMax)
{
  float result; 

  if ( (this->m_spawnFlags & 1) != 0 || COERCE_FLOAT(COERCE_UNSIGNED_INT(radiusMax - radiusMin) & _xmm) < 0.001 )
    return (float)(halfHeight * radiusMax) * 12.566371;
  LODWORD(result) = COERCE_UNSIGNED_INT((float)((float)(radiusMax * radiusMax) * (float)((float)(halfHeight * 3.1415927) * 2.0)) - (float)((float)(radiusMin * radiusMin) * (float)((float)(halfHeight * 3.1415927) * 2.0))) & _xmm;
  return result;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize(ParticleModuleInitSpawnShapeEllipsoid *this, const float4 *radiusMin, const float4 *radiusMax)
{
  float v3; 
  __m128 v4; 
  float v8; 
  float result; 

  v3 = (float)((float)(COERCE_FLOAT(*radiusMax) * radiusMax->v.m128_f32[1]) * _mm_shuffle_ps(radiusMax->v, radiusMax->v, 170).m128_f32[0]) * 4.1887903;
  v4 = _mm128_sub_ps(radiusMax->v, radiusMin->v);
  _XMM2 = _mm128_mul_ps(v4, v4);
  __asm { vhaddps xmm0, xmm2, xmm2 }
  if ( (this->m_spawnFlags & 1) != 0 )
    goto LABEL_4;
  __asm { vhaddps xmm0, xmm0, xmm0 }
  if ( COERCE_FLOAT(_mm_sqrt_ps(_XMM0).m128_u32[0] & _xmm) < 0.001 )
LABEL_4:
    v8 = (float)((float)(radiusMax->v.m128_f32[1] - 1.0) * (float)((float)(COERCE_FLOAT(*radiusMax) - 1.0) * 4.1887903)) * (float)(radiusMax->v.m128_f32[2] - 1.0);
  else
    v8 = (float)((float)(COERCE_FLOAT(*radiusMin) * radiusMin->v.m128_f32[1]) * radiusMin->v.m128_f32[2]) * 4.1887903;
  LODWORD(result) = COERCE_UNSIGNED_INT(v3 - v8) & _xmm;
  return result;
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeSphere::GetVolumeSize(ParticleModuleInitSpawnShapeSphere *this, const float radiusMin, const float radiusMax)
{
  float result; 

  if ( (this->m_spawnFlags & 1) != 0 || COERCE_FLOAT(COERCE_UNSIGNED_INT(radiusMax - radiusMin) & _xmm) < 0.001 )
    return (float)(radiusMax * 12.566371) * radiusMax;
  LODWORD(result) = COERCE_UNSIGNED_INT((float)((float)((float)(radiusMax * radiusMax) * radiusMax) * 4.1887903) - (float)((float)((float)(radiusMin * radiusMin) * radiusMin) * 4.1887903)) & _xmm;
  return result;
}

/*
==============
ParticleModuleInitAtlas::Init
==============
*/
void ParticleModuleInitAtlas::Init(ParticleModule *pModuleBase)
{
  pModuleBase[1].m_flags = -1;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitAttributes::Init
==============
*/
void ParticleModuleInitAttributes::Init(ParticleModule *pModuleBase)
{
  *(__m256i *)&pModuleBase[2].m_type = _ymm;
  *(__m256i *)&pModuleBase[10].m_type = _ymm;
  *(__m256i *)&pModuleBase[6].m_type = _ymm;
}

/*
==============
ParticleModuleInitBeam::Init
==============
*/
void ParticleModuleInitBeam::Init(ParticleModule *pModuleBase)
{
  *(_OWORD *)&pModuleBase[2].m_type = 0i64;
  *(_OWORD *)&pModuleBase[4].m_type = _xmm;
  pModuleBase[1].m_flags = 1092616192;
}

/*
==============
ParticleModuleInitCloud::Init
==============
*/
void ParticleModuleInitCloud::Init(ParticleModule *pModuleBase)
{
  ;
}

/*
==============
ParticleModuleInitDecal::Init
==============
*/
void ParticleModuleInitDecal::Init(ParticleModule *pModuleBase)
{
  *(_OWORD *)&pModuleBase[4].m_type = _xmm;
  *((_BYTE *)&pModuleBase[6].m_type + 3) = 5;
}

/*
==============
ParticleModuleInitDismember::Init
==============
*/
void ParticleModuleInitDismember::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 50;
  LOBYTE(pModuleBase[1].m_flags) = 0;
}

/*
==============
ParticleModuleInitFlare::Init
==============
*/
void ParticleModuleInitFlare::Init(ParticleModule *pModuleBase)
{
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
  pModuleBase[5] = 0i64;
  pModuleBase[6] = 0i64;
  *(_DWORD *)&pModuleBase[8].m_type = 1065353216;
  pModuleBase[8].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[9].m_type = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[7] = 0i64;
  pModuleBase[4] = 0i64;
  *(_OWORD *)&pModuleBase[2].m_type = _xmm;
}

/*
==============
ParticleModuleInitGeoTrail::Init
==============
*/
void ParticleModuleInitGeoTrail::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 16;
  pModuleBase[2].m_flags = 0;
  *(_QWORD *)&pModuleBase[1].m_flags = 1112014848i64;
  *(_DWORD *)&pModuleBase[3].m_type = 1;
  *(_QWORD *)&pModuleBase[4].m_flags = 1112014848i64;
  pModuleBase[5].m_flags = 0;
}

/*
==============
ParticleModuleInitLightOmni::Init
==============
*/
void ParticleModuleInitLightOmni::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3] = (ParticleModule)1061752795i64;
  *(_QWORD *)&pModuleBase[6].m_flags = 0i64;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
  pModuleBase[4].m_flags = 998277249;
  *(_DWORD *)&pModuleBase[5].m_type = 1056964608;
  *(_QWORD *)&pModuleBase[5].m_flags = 1065353216i64;
  pModuleBase[7].m_flags = 1057803469;
  *(_DWORD *)&pModuleBase[8].m_type = 1053609165;
  pModuleBase[8].m_flags = 1016296636;
  *(_DWORD *)&pModuleBase[9].m_type = 1065353216;
  pModuleBase[9].m_flags = 16842752;
}

/*
==============
ParticleModuleInitLightSpot::Init
==============
*/
void ParticleModuleInitLightSpot::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3] = (ParticleModule)1061752795i64;
  pModuleBase[7] = 0i64;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
  pModuleBase[4].m_flags = 998277249;
  *(_DWORD *)&pModuleBase[5].m_type = 1045220557;
  pModuleBase[5].m_flags = 1070141403;
  pModuleBase[6] = (ParticleModule)1092616192i64;
  *(_DWORD *)&pModuleBase[8].m_type = 1057803469;
  pModuleBase[8].m_flags = 1053609165;
  *(_DWORD *)&pModuleBase[9].m_type = 1016296636;
  pModuleBase[9].m_flags = 1090519040;
  *(_DWORD *)&pModuleBase[10].m_type = 1065353216;
  pModuleBase[10].m_flags = 0x1000000;
}

/*
==============
ParticleModuleInitOcclusionQuery::Init
==============
*/
void ParticleModuleInitOcclusionQuery::Init(ParticleModule *pModuleBase)
{
  pModuleBase[2].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[3].m_type = 1065353216;
  pModuleBase[3].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
}

/*
==============
ParticleModuleInitOrientedSprite::Init
==============
*/
void ParticleModuleInitOrientedSprite::Init(ParticleModule *pModuleBase)
{
  *(float4 *)&pModuleBase[2].m_type = (float4)g_unit.v;
}

/*
==============
ParticleModuleInitParticleSim::Init
==============
*/
void ParticleModuleInitParticleSim::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[3].m_type = 1065353216;
  pModuleBase[3].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitRunner::Init
==============
*/
void ParticleModuleInitRunner::Init(ParticleModule *pModuleBase)
{
  *(__m256i *)&pModuleBase[2].m_type = _ymm;
  *(__m256i *)&pModuleBase[6].m_type = _ymm;
}

/*
==============
ParticleModuleInitSpawn::Init
==============
*/
void ParticleModuleInitSpawn::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeBox::Init
==============
*/
void ParticleModuleInitSpawnShapeBox::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::Init
==============
*/
void ParticleModuleInitSpawnShapeCylinder::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::Init
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeMesh::Init
==============
*/
void ParticleModuleInitSpawnShapeMesh::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeSphere::Init
==============
*/
void ParticleModuleInitSpawnShapeSphere::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitVolumetric::Init
==============
*/
void ParticleModuleInitVolumetric::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1028443341;
  pModuleBase[1].m_flags = 1066192077;
  pModuleBase[2] = (ParticleModule)1065353216i64;
}

/*
==============
ParticleModuleInitAttributes::InitParticleColor
==============
*/
void ParticleModuleInitAttributes::InitParticleColor(const ParticleModuleInitAttributes *pModule, float4 *colorArray, const int *randomSeedArray, __int64 particleCountEmit)
{
  float4 v6; 
  __m128 v7; 

  if ( (_DWORD)particleCountEmit )
  {
    particleCountEmit = (unsigned int)particleCountEmit;
    _R10 = fx_randomTable;
    do
    {
      _RAX = *randomSeedArray;
      v6.v = (__m128)pModule->m_colorMax;
      if ( pModule->m_useNonUniformInterpolationForColor )
      {
        _XMM1 = LODWORD(fx_randomTable[_RAX + 25]);
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+70h], 30h ; '0'
        }
        colorArray->v = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v6.v, pModule->m_colorMin.v)), pModule->m_colorMin.v);
      }
      else
      {
        v7 = _mm128_sub_ps(v6.v, pModule->m_colorMin.v);
        __asm { vbroadcastss xmm0, dword ptr [r10+rax*4+60h] }
        colorArray->v = _mm128_add_ps(_mm128_mul_ps(v7, _XMM0), pModule->m_colorMin.v);
      }
      ++randomSeedArray;
      ++colorArray;
      --particleCountEmit;
    }
    while ( particleCountEmit );
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticleSize
==============
*/
void ParticleModuleInitAttributes::InitParticleSize(const ParticleModuleInitAttributes *pModule, float4 *sizeArray, const int *randomSeedArray, __int64 particleCountEmit)
{
  __int64 v5; 
  float4 v8; 
  __m128 v9; 

  if ( (_DWORD)particleCountEmit )
  {
    v5 = 0i64;
    particleCountEmit = (unsigned int)particleCountEmit;
    _R11 = fx_randomTable;
    do
    {
      _RDX = *randomSeedArray;
      v8.v = (__m128)pModule->m_sizeMax;
      if ( pModule->m_useNonUniformInterpolationForSize )
      {
        _XMM1 = 0i64;
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A0h], 0
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A4h], 10h
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A8h], 20h ; ' '
        }
        sizeArray[v5].v = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v8.v, pModule->m_sizeMin.v)), pModule->m_sizeMin.v);
      }
      else
      {
        v9 = _mm128_sub_ps(v8.v, pModule->m_sizeMin.v);
        __asm { vbroadcastss xmm0, dword ptr [r11+rdx*4+0A0h] }
        sizeArray[v5].v = _mm128_add_ps(_mm128_mul_ps(v9, _XMM0), pModule->m_sizeMin.v);
      }
      ++randomSeedArray;
      ++v5;
      --particleCountEmit;
    }
    while ( particleCountEmit );
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticleVelocity
==============
*/
void ParticleModuleInitAttributes::InitParticleVelocity(const ParticleModuleInitAttributes *pModule, float4 *velocityArray, const int *randomSeedArray, const ParticleState *pParticleState, const unsigned int particleCountEmit)
{
  ParticleEmitter *m_pEmitterOwner; 
  const ParticleSystem *SystemOwner; 
  char v11; 
  const vector4 *EmitterTransformTranspose; 
  __m128 v; 
  float4 v14; 
  float4 v15; 
  __int64 v16; 
  float4 v17; 
  float4 v22; 
  float4 v23; 
  float4 lookAtInput; 
  vector3 outMatrix; 

  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  if ( !SystemOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 572, ASSERT_TYPE_ASSERT, "(pParticleSystem)", (const char *)&queryFormat, "pParticleSystem") )
    __debugbreak();
  if ( (SystemOwner->m_flags & 0x4000) != 0 && (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->flags & 0x100) != 0 )
  {
    v11 = 1;
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(m_pEmitterOwner, pParticleState);
    v = SystemOwner->m_scriptedVelocity.v;
    lookAtInput.v = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), EmitterTransformTranspose->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), EmitterTransformTranspose->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), EmitterTransformTranspose->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
    Particle_GenerateMatrixFromLookAt(&lookAtInput, &outMatrix);
  }
  else
  {
    v11 = 0;
  }
  if ( particleCountEmit )
  {
    v14.v = (__m128)outMatrix.z;
    v15.v = (__m128)outMatrix.y;
    v16 = particleCountEmit;
    v17.v = (__m128)outMatrix.x;
    do
    {
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4], 0
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4+4], 10h
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4+8], 20h ; ' '
      }
      v22.v = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(pModule->m_velocityMax.v, pModule->m_velocityMin.v)), pModule->m_velocityMin.v);
      *velocityArray = (float4)v22.v;
      if ( v11 )
      {
        v23.v = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(v15.v, _mm_shuffle_ps(v22.v, v22.v, 85)), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(v14.v, _mm_shuffle_ps(v22.v, v22.v, 170)), _mm128_add_ps(_mm128_mul_ps(v17.v, _mm_shuffle_ps(v22.v, v22.v, 0)), g_negativeZero.v)));
        *velocityArray = (float4)v23.v;
        *velocityArray = (float4)(*(_OWORD *)&v23.v & *(_OWORD *)&g_keepXYZ.v);
      }
      ++randomSeedArray;
      ++velocityArray;
      --v16;
    }
    while ( v16 );
  }
}

/*
==============
ParticleModuleInitAtlas::InitParticles
==============
*/
void ParticleModuleInitAtlas::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  __int64 m_particleCountRunning; 
  unsigned __int8 *v9; 
  int *RandomSeedArrayNextFreeElem; 
  int entryCount; 
  __int64 v12; 
  int *v13; 
  unsigned __int8 *v14; 
  signed __int64 v15; 
  unsigned int v16; 
  __int64 v17; 
  int v18; 
  signed __int64 v19; 
  unsigned __int8 *v20; 
  __int64 v21; 
  int v22; 
  __int64 v23; 
  __m128 v26; 
  unsigned int v27; 
  __int64 v28; 
  __int64 v29; 
  unsigned int v30; 
  __int64 v31; 
  unsigned __int8 *v32; 
  __int64 v33; 
  __int64 v34; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v34) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v34, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v9 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_ATLAS_INDEX)[4 * m_particleCountRunning];
  if ( LOBYTE(pModuleBase[2].m_type) )
  {
    RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
    entryCount = pParticleState->m_atlasData.entryCount;
    v12 = 0i64;
    v13 = RandomSeedArrayNextFreeElem;
    if ( particleCountEmit >= 4 )
    {
      v14 = v9 + 4;
      v15 = (char *)RandomSeedArrayNextFreeElem - (char *)v9;
      v16 = ((particleCountEmit - 4) >> 2) + 1;
      v17 = v16;
      v12 = 4 * v16;
      do
      {
        v18 = *(_DWORD *)&v14[v15 - 4];
        v14 += 16;
        *((float *)v14 - 5) = (float)((entryCount * LOWORD(fx_randomTable[v18 + 23])) >> 16);
        *((float *)v14 - 4) = (float)((entryCount * LOWORD(fx_randomTable[*(_DWORD *)&v14[v15 - 16] + 23])) >> 16);
        *((float *)v14 - 3) = (float)((entryCount * LOWORD(fx_randomTable[*(_DWORD *)&v14[v15 - 12] + 23])) >> 16);
        *((float *)v14 - 2) = (float)((entryCount * LOWORD(fx_randomTable[*(_DWORD *)&v14[v15 - 8] + 23])) >> 16);
        --v17;
      }
      while ( v17 );
    }
    if ( (unsigned int)v12 < particleCountEmit )
    {
      v19 = (char *)v13 - (char *)v9;
      v20 = &v9[4 * v12];
      v21 = particleCountEmit - (unsigned int)v12;
      do
      {
        v22 = *(_DWORD *)&v20[v19];
        v20 += 4;
        *((float *)v20 - 1) = (float)((entryCount * LOWORD(fx_randomTable[v22 + 23])) >> 16);
        --v21;
      }
      while ( v21 );
    }
  }
  else
  {
    v23 = 0i64;
    if ( particleCountEmit )
    {
      if ( particleCountEmit >= 0x10 )
      {
        _XMM0 = *(unsigned int *)&pModuleBase[1].m_type;
        __asm { vpshufd xmm0, xmm0, 0 }
        if ( v9 > (unsigned __int8 *)&pModuleBase[1] || &v9[4 * particleCountEmit - 4] < (unsigned __int8 *)&pModuleBase[1] )
        {
          v26 = _mm_cvtepi32_ps(_XMM0);
          v27 = 8;
          do
          {
            *(__m128 *)&v9[4 * v23] = v26;
            v23 = (unsigned int)(v23 + 16);
            *(__m128 *)&v9[4 * v27 - 16] = v26;
            *(__m128 *)&v9[4 * v27] = v26;
            v28 = v27 + 4;
            v27 += 16;
            *(__m128 *)&v9[4 * v28] = v26;
          }
          while ( (unsigned int)v23 < (particleCountEmit & 0xFFFFFFF0) );
        }
      }
      if ( (unsigned int)v23 < particleCountEmit )
      {
        if ( particleCountEmit - (unsigned int)v23 >= 4 )
        {
          v29 = (__int64)&v9[4 * v23 + 8];
          v30 = ((particleCountEmit - (unsigned int)v23 - 4) >> 2) + 1;
          v31 = v30;
          v23 = (unsigned int)v23 + 4 * v30;
          do
          {
            v29 += 16i64;
            *(float *)(v29 - 24) = (float)*(int *)&pModuleBase[1].m_type;
            *(float *)(v29 - 20) = (float)*(int *)&pModuleBase[1].m_type;
            *(float *)(v29 - 16) = (float)*(int *)&pModuleBase[1].m_type;
            *(float *)(v29 - 12) = (float)*(int *)&pModuleBase[1].m_type;
            --v31;
          }
          while ( v31 );
        }
        if ( (unsigned int)v23 < particleCountEmit )
        {
          v32 = &v9[4 * v23];
          v33 = particleCountEmit - (unsigned int)v23;
          do
          {
            v32 += 4;
            *((float *)v32 - 1) = (float)*(int *)&pModuleBase[1].m_type;
            --v33;
          }
          while ( v33 );
        }
      }
    }
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticles
==============
*/
void ParticleModuleInitAttributes::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  const int *RandomSeedArrayNextFreeElem; 
  float4 *VelocityArrayAtIndex; 
  float4 *SizeArrayAtIndex; 
  __int64 m_particleCountRunning; 
  __m128 *v12; 
  __m128 *p_v; 
  const int *v15; 
  __int64 v16; 
  __int64 v17; 
  __m128 v19; 
  __m128 v20; 
  const int *v26; 
  __m128 v28; 
  __m128 v29; 
  ParticleSystem *v35; 
  const float4 *v36; 
  signed __int64 v37; 
  __int64 v38; 
  int v39; 
  float4 *v40; 
  __int64 v41; 
  float4 v42; 
  float4 result; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  result.v.m128_u64[0] = (unsigned __int64)pParticleState->m_pEmitterOwner;
  v42.v.m128_u64[0] = (unsigned __int64)ParticleEmitter::GetSystemOwner((ParticleEmitter *)result.v.m128_u64[0]);
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 342, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 348, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  SizeArrayAtIndex = Particle_GetSizeArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v41) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v41, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v12 = (__m128 *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_COLOR)[16 * m_particleCountRunning];
  ParticleModuleInitAttributes::InitParticleVelocity((const ParticleModuleInitAttributes *)pModuleBase, VelocityArrayAtIndex, RandomSeedArrayNextFreeElem, pParticleState, particleCountEmit);
  if ( particleCountEmit )
  {
    p_v = &SizeArrayAtIndex->v;
    _R10 = fx_randomTable;
    v15 = RandomSeedArrayNextFreeElem;
    v16 = particleCountEmit;
    v17 = particleCountEmit;
    do
    {
      _RDX = *v15;
      v19 = *(__m128 *)&pModuleBase[4].m_type;
      if ( HIBYTE(pModuleBase[1].m_type) )
      {
        _XMM1 = 0i64;
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A0h], 0
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A4h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A8h], 20h ; ' '
        }
        *p_v = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v19, *(__m128 *)&pModuleBase[2].m_type)), *(__m128 *)&pModuleBase[2].m_type);
      }
      else
      {
        v20 = _mm128_sub_ps(v19, *(__m128 *)&pModuleBase[2].m_type);
        __asm { vbroadcastss xmm0, dword ptr [r10+rdx*4+0A0h] }
        *p_v = _mm128_add_ps(_mm128_mul_ps(v20, _XMM0), *(__m128 *)&pModuleBase[2].m_type);
      }
      ++v15;
      ++p_v;
      --v17;
    }
    while ( v17 );
    v26 = RandomSeedArrayNextFreeElem;
    do
    {
      _RAX = *v26;
      v28 = *(__m128 *)&pModuleBase[8].m_type;
      if ( LOBYTE(pModuleBase[1].m_type) )
      {
        _XMM1 = LODWORD(fx_randomTable[_RAX + 25]);
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+70h], 30h ; '0'
        }
        *v12 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v28, *(__m128 *)&pModuleBase[6].m_type)), *(__m128 *)&pModuleBase[6].m_type);
      }
      else
      {
        v29 = _mm128_sub_ps(v28, *(__m128 *)&pModuleBase[6].m_type);
        __asm { vbroadcastss xmm0, dword ptr [r10+rax*4+60h] }
        *v12 = _mm128_add_ps(_mm128_mul_ps(v29, _XMM0), *(__m128 *)&pModuleBase[6].m_type);
      }
      ++v26;
      ++v12;
      --v16;
    }
    while ( v16 );
  }
  v35 = (ParticleSystem *)v42.v.m128_u64[0];
  if ( (*(_DWORD *)(v42.v.m128_u64[0] + 416) & 0x40000000) != 0 && (ParticleEmitter::GetEmitterDef((ParticleEmitter *)result.v.m128_u64[0])->flags & 0x800000) == 0 && particleCountEmit )
  {
    v36 = SizeArrayAtIndex;
    v37 = (char *)VelocityArrayAtIndex - (char *)SizeArrayAtIndex;
    v38 = particleCountEmit;
    do
    {
      v39 = *RandomSeedArrayNextFreeElem;
      *(float4 *)((char *)SizeArrayAtIndex + v37) = (float4)ParticleSystem::ApplyVelocityModifiers(v35, &result, (const float4 *)((char *)v36 + v37), *RandomSeedArrayNextFreeElem)->v;
      v40 = ParticleSystem::ApplyScaleModifiers(v35, &v42, v36++, v39, 1);
      ++SizeArrayAtIndex;
      ++RandomSeedArrayNextFreeElem;
      SizeArrayAtIndex[-1] = (float4)v40->v;
      --v38;
    }
    while ( v38 );
  }
}

/*
==============
ParticleModuleInitBeam::InitParticles
==============
*/
void ParticleModuleInitBeam::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ParticleEmitter *m_pEmitterOwner; 
  float4 *PositionArrayNextFreeElem; 
  __int64 v10; 
  float4 outStartPos; 
  float4 outEndPos; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  if ( (ParticleEmitter::GetSystemOwner(m_pEmitterOwner)->m_flags & 0x100) == 0 )
  {
    PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
    ParticleEmitter::GetBeamPos(m_pEmitterOwner, pParticleState, &outStartPos, &outEndPos);
    if ( particleCountEmit )
    {
      v10 = particleCountEmit;
      do
      {
        ++PositionArrayNextFreeElem;
        PositionArrayNextFreeElem[-1].v = _mm128_add_ps(*(__m128 *)&pModuleBase[6].m_type, outStartPos.v);
        --v10;
      }
      while ( v10 );
    }
  }
}

/*
==============
ParticleModuleInitCameraOffset::InitParticles
==============
*/
void ParticleModuleInitCameraOffset::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitCloud::InitParticles
==============
*/
void ParticleModuleInitCloud::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitDecal::InitParticles
==============
*/
void ParticleModuleInitDecal::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitDismember::InitParticles
==============
*/
void ParticleModuleInitDismember::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitFlare::InitParticles
==============
*/
void ParticleModuleInitFlare::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitGeoTrail::InitParticles
==============
*/
void ParticleModuleInitGeoTrail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitKillWrapBox::InitParticles
==============
*/
void ParticleModuleInitKillWrapBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitLightOmni::InitParticles
==============
*/
void ParticleModuleInitLightOmni::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitLightSpot::InitParticles
==============
*/
void ParticleModuleInitLightSpot::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitMaterial::InitParticles
==============
*/
void ParticleModuleInitMaterial::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitMirrorTexture::InitParticles
==============
*/
void ParticleModuleInitMirrorTexture::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitModel::InitParticles
==============
*/
void ParticleModuleInitModel::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitOcclusionQuery::InitParticles
==============
*/
void ParticleModuleInitOcclusionQuery::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitOrientedSprite::InitParticles
==============
*/
void ParticleModuleInitOrientedSprite::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitParticleSim::InitParticles
==============
*/
void ParticleModuleInitParticleSim::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitPlayerFacing::InitParticles
==============
*/
void ParticleModuleInitPlayerFacing::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitRelativeVelocity::InitParticles
==============
*/
void ParticleModuleInitRelativeVelocity::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitRotation3D::InitParticles
==============
*/
void ParticleModuleInitRotation3D::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  int *RandomSeedArrayNextFreeElem; 
  float4 *RotationAngleArrayNextFreeElem; 
  float4 *RotationRateArrayNextFreeElem; 
  float4 *v11; 
  __m128 v12; 
  __m128 v13; 
  __m128 v14; 
  __m128 v15; 
  signed __int64 v16; 
  __int64 v17; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  RotationAngleArrayNextFreeElem = Particle_GetRotationAngleArrayNextFreeElem(pParticleData);
  RotationRateArrayNextFreeElem = Particle_GetRotationRateArrayNextFreeElem(pParticleData);
  v11 = RotationRateArrayNextFreeElem;
  v12 = *(__m128 *)&pModuleBase[2].m_type;
  v13 = *(__m128 *)&pModuleBase[6].m_type;
  if ( particleCountEmit )
  {
    v14 = _mm128_sub_ps(*(__m128 *)&pModuleBase[4].m_type, v12);
    v15 = _mm128_sub_ps(*(__m128 *)&pModuleBase[8].m_type, v13);
    v16 = (char *)RotationAngleArrayNextFreeElem - (char *)RotationRateArrayNextFreeElem;
    v17 = particleCountEmit;
    do
    {
      ++v11;
      ++RandomSeedArrayNextFreeElem;
      _XMM0 = 0i64;
      __asm
      {
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+88h], 0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+8Ch], 10h
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+90h], 20h ; ' '
      }
      *(__m128 *)((char *)&v11[-1].v + v16) = _mm128_add_ps(_mm128_mul_ps(_XMM0, v14), v12);
      _XMM0 = 0i64;
      __asm
      {
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+94h], 0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+98h], 10h
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+9Ch], 20h ; ' '
      }
      v11[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, v15), v13);
      --v17;
    }
    while ( v17 );
  }
}

/*
==============
ParticleModuleInitRotation::InitParticles
==============
*/
void ParticleModuleInitRotation::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  int *RandomSeedArrayNextFreeElem; 
  float4 *RotationAngleArrayNextFreeElem; 
  float4 *RotationRateArrayNextFreeElem; 
  float4 *v11; 
  signed __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __m128 v15; 
  __m128 v16; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  RotationAngleArrayNextFreeElem = Particle_GetRotationAngleArrayNextFreeElem(pParticleData);
  RotationRateArrayNextFreeElem = Particle_GetRotationRateArrayNextFreeElem(pParticleData);
  v11 = RotationRateArrayNextFreeElem;
  if ( particleCountEmit )
  {
    v12 = (char *)RotationAngleArrayNextFreeElem - (char *)RotationRateArrayNextFreeElem;
    v13 = particleCountEmit;
    do
    {
      v14 = *RandomSeedArrayNextFreeElem;
      ++v11;
      ++RandomSeedArrayNextFreeElem;
      v15 = (__m128)LODWORD(FLOAT_1_0);
      v15.m128_f32[0] = (float)((float)(1.0 - fx_randomTable[v14 + 34]) * *(float *)&pModuleBase[2].m_type) + (float)(fx_randomTable[v14 + 34] * *(float *)&pModuleBase[2].m_flags);
      *(__m128 *)((char *)&v11[-1].v + v12) = _mm_shuffle_ps(v15, v15, 0);
      v16 = (__m128)LODWORD(FLOAT_1_0);
      v16.m128_f32[0] = (float)((float)(1.0 - fx_randomTable[v14 + 37]) * *(float *)&pModuleBase[3].m_type) + (float)(fx_randomTable[v14 + 37] * *(float *)&pModuleBase[3].m_flags);
      v11[-1].v = _mm_shuffle_ps(v16, v16, 0);
      --v13;
    }
    while ( v13 );
  }
}

/*
==============
ParticleModuleInitRunner::InitParticles
==============
*/
void ParticleModuleInitRunner::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSound::InitParticles
==============
*/
void ParticleModuleInitSound::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSpawn::InitParticles
==============
*/
void ParticleModuleInitSpawn::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSpawnShapeBox::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  float4 *PositionArrayNextFreeElem; 
  float4 *SpawnPosArrayNextFreeElem; 
  unsigned int v10; 
  __m128 v; 
  __m128 v12; 
  ParticleEmitter *m_pEmitterOwner; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  __m128 v28; 
  __m128 v29; 
  __m128 v30; 
  signed __int64 v31; 
  __m128 v36; 
  __int64 v37; 
  __int64 v38; 
  signed __int64 v39; 
  signed __int64 v40; 
  float4 dimensionsMax; 
  float4 dimensionsMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)pModuleBase, pParticleState, &dimensionsMin, &dimensionsMax);
  v10 = 0;
  if ( (HIBYTE(pModuleBase[1].m_type) & 1) != 0 )
  {
    if ( particleCountEmit )
    {
      v = dimensionsMin.v;
      v12 = dimensionsMax.v;
      v39 = (char *)PositionArrayNextFreeElem - (char *)SpawnPosArrayNextFreeElem;
      while ( 1 )
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v14 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v10) % 0x3FE9;
        }
        else
        {
          v14 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v10];
        }
        v15 = (6 * *((unsigned __int16 *)fx_randomTable + (int)(2 * v14 + 16))) >> 16;
        if ( v15 >= 6 )
        {
          LODWORD(v38) = 6;
          LODWORD(v37) = (6 * *((unsigned __int16 *)fx_randomTable + (int)(2 * v14 + 16))) >> 16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v37, v38) )
            __debugbreak();
        }
        if ( !v15 )
          break;
        v16 = v15 - 1;
        if ( !v16 )
        {
          _XMM1 = _xmm;
LABEL_42:
          __asm { vinsertps xmm1, xmm1, xmm6, 10h }
          goto LABEL_43;
        }
        v17 = v16 - 1;
        if ( v17 )
        {
          v18 = v17 - 1;
          if ( v18 )
          {
            if ( v18 == 1 )
            {
              _XMM1 = 0i64;
              __asm
              {
                vinsertps xmm1, xmm1, xmm6, 0
                vinsertps xmm1, xmm1, xmm7, 10h
              }
            }
            else
            {
              _XMM1 = _xmm;
              __asm
              {
                vinsertps xmm1, xmm1, xmm6, 0
                vinsertps xmm1, xmm1, xmm7, 10h
              }
            }
            goto LABEL_44;
          }
          _XMM1 = _xmm;
          __asm { vinsertps xmm1, xmm1, xmm6, 0 }
        }
        else
        {
          _XMM1 = 0i64;
          __asm { vinsertps xmm1, xmm1, xmm6, 0 }
        }
LABEL_43:
        __asm { vinsertps xmm1, xmm1, xmm7, 20h ; ' ' }
LABEL_44:
        ++v10;
        v28 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(v12, v), _XMM1), v);
        *(__m128 *)((char *)SpawnPosArrayNextFreeElem + v39) = v28;
        *SpawnPosArrayNextFreeElem++ = (float4)v28;
        if ( v10 >= particleCountEmit )
          return;
      }
      _XMM1 = 0i64;
      goto LABEL_42;
    }
  }
  else if ( particleCountEmit )
  {
    v29 = dimensionsMax.v;
    v30 = dimensionsMin.v;
    v31 = (char *)PositionArrayNextFreeElem - (char *)SpawnPosArrayNextFreeElem;
    v40 = v31;
    do
    {
      if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
      {
        if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        ParticleEmitter::GetEmitterDef((ParticleEmitter *)pParticleState->m_pEmitterOwner);
        v31 = v40;
      }
      else
      {
        Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
      }
      ++v10;
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+18h], 0
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+1Ch], 10h
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+20h], 20h ; ' '
      }
      v36 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v29, v30)), v30);
      *(__m128 *)((char *)SpawnPosArrayNextFreeElem + v31) = v36;
      *SpawnPosArrayNextFreeElem++ = (float4)v36;
    }
    while ( v10 < particleCountEmit );
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeCylinder::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  __m128 v5; 
  __m128 v6; 
  __m128 v7; 
  ParticleData *v8; 
  ParticleState *v9; 
  float4 *SpawnPosArrayNextFreeElem; 
  char m_type; 
  unsigned int v13; 
  __int64 v14; 
  const float4 *v15; 
  vector3 *v16; 
  char v17; 
  ParticleEmitter *EmitterOwner; 
  const vector4 *EmitterTransformTranspose; 
  __m128 v; 
  __m128 v21; 
  __int128 v22; 
  __m128 v23; 
  ParticleEmitter *v24; 
  const vector4 *v25; 
  const vector4 *v26; 
  unsigned int v27; 
  float v28; 
  float v29; 
  int v30; 
  float v31; 
  ParticleEmitter *m_pEmitterOwner; 
  signed int v33; 
  __int64 v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  __m128 v41; 
  __m128 v44; 
  __m128 v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  __int128 v52; 
  __int128 v53; 
  __m128 v55; 
  __int128 v58; 
  __int128 v63; 
  __int128 v71; 
  __int128 v72; 
  unsigned int v77; 
  unsigned __int8 *ParticleDataArray; 
  unsigned int v79; 
  unsigned __int8 *v80; 
  unsigned int v82; 
  __m128 v83; 
  __m128 v84; 
  int v85; 
  float v86; 
  float4 v87; 
  ParticleModuleAxesFlags v88; 
  __int64 v89; 
  float v90; 
  __m128 v92; 
  __m128 v96; 
  __m128 *v97; 
  __int64 v98; 
  __m128 v99; 
  __m128 v100; 
  ParticleModuleAxesFlags v105; 
  float v106; 
  __m128 v108; 
  __m128 v111; 
  char m_type_high; 
  char v113; 
  char v114; 
  char v115; 
  float halfHeight; 
  int v117; 
  float radiusMax; 
  unsigned int v119; 
  float4 *PositionArrayNextFreeElem; 
  float radiusMin; 
  float v122; 
  float c; 
  float s; 
  float v125; 
  float v126[3]; 
  float4 outOffset; 
  __int64 v128; 
  const FxCamera *v129; 
  ParticleData *v130; 
  const ParticleState *v131; 
  __int64 v132; 
  vector4 result; 
  __m256i v134; 
  __m256i v135; 
  vec3_t outPos; 
  vec3_t v137; 
  __int64 v138; 
  __m128 v139; 
  __m128 v140; 
  __m128 v141; 

  v129 = pCamera;
  v8 = pParticleData;
  v130 = pParticleData;
  v9 = (ParticleState *)pParticleState;
  v131 = pParticleState;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + v8->m_particleCountRunning > v8->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_type_high = HIBYTE(pModuleBase[1].m_type);
  v115 = m_type_high & 1;
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(v8);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(v8);
  m_type = pModuleBase[6].m_type;
  v114 = m_type;
  v13 = pModuleBase->m_flags >> 7;
  v14 = (__int64)SpawnPosArrayNextFreeElem;
  v128 = (__int64)SpawnPosArrayNextFreeElem;
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, v9, &outOffset);
  ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)pModuleBase, v9, &halfHeight, &radiusMin, &radiusMax);
  v17 = v13 & 1;
  if ( v17 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner(v9);
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, v9);
    v = outOffset.v;
    v7 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), EmitterTransformTranspose->x.v), g_negativeZero.v);
    v5 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), EmitterTransformTranspose->z.v), v7);
    v6 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), EmitterTransformTranspose->y.v), g_negativeZero.v), v5);
    v21 = (__m128)(*(_OWORD *)&v6 & *(_OWORD *)&g_keepXYZ.v);
  }
  else
  {
    v21 = outOffset.v;
  }
  result.w = (float4)g_unit.v;
  if ( m_type )
  {
    v22 = *(_OWORD *)&pModuleBase[8].m_type;
    Float4UnitQuatToAxis(v16, v15);
    *(__m128 *)&v134.m256i_u64[2] = v5;
    *(_OWORD *)v134.m256i_i8 = v22;
    *(__m256i *)result.x.v.m128_f32 = v134;
    v23 = v6;
    outOffset.v = v6;
    result.z.v = v6;
    if ( !v17 )
      goto LABEL_26;
    v24 = (ParticleEmitter *)ParticleState::GetEmitterOwner(v9);
    v25 = ParticleEmitter::GetEmitterTransformTranspose(v24, v9);
    Float4x4Mul(&result, v25, v26);
    *(__m128 *)v135.m256i_i8 = v6;
    *(_OWORD *)v134.m256i_i8 = v22;
    *(__m128 *)&v135.m256i_u64[2] = v7;
    *(__m128 *)&v134.m256i_u64[2] = v5;
    *(__m256i *)result.x.v.m128_f32 = v134;
    *(__m256i *)result.z.v.m128_f32 = v135;
  }
  v23 = result.z.v;
  outOffset.v = (__m128)result.z;
LABEL_26:
  v27 = 0;
  v119 = 0;
  if ( particleCountEmit )
  {
    v113 = m_type_high & 0x10;
    PositionArrayNextFreeElem = (float4 *)((char *)PositionArrayNextFreeElem - v14);
    v28 = radiusMax;
    v29 = FLOAT_6_2831855;
    v30 = _xmm;
    v31 = halfHeight;
    do
    {
      if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
      {
        if ( !v9->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        m_pEmitterOwner = (ParticleEmitter *)v9->m_pEmitterOwner;
        v33 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v27) % 0x3FE9;
      }
      else
      {
        v33 = Particle_GetRandomSeedArrayNextFreeElem(v8)[v27];
      }
      v117 = v33;
      v34 = v33;
      if ( v115 )
        v35 = v28;
      else
        v35 = (float)((float)(1.0 - fx_randomTable[v33 + 11]) * radiusMin) + (float)(v28 * fx_randomTable[v33 + 11]);
      if ( v113 )
      {
        v36 = v29;
        v37 = *(float *)&pModuleBase[3].m_flags;
        v38 = 0.0;
        if ( v37 > 0.0 )
        {
          v39 = v129->origin.v[0];
          v139.m128_i32[3] = 0;
          v41 = v139;
          v41.m128_f32[0] = v39;
          _XMM6 = v41;
          __asm
          {
            vinsertps xmm6, xmm6, xmm1, 10h
            vinsertps xmm6, xmm6, xmm2, 20h ; ' '
          }
          v139 = _XMM6;
          if ( !v9->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          v44 = _mm128_sub_ps(_XMM6, ParticleEmitter::GetEmitterTransform((ParticleEmitter *)v9->m_pEmitterOwner, v9)->w.v);
          v45 = _mm_shuffle_ps(v44, v44, 85);
          v46 = (float)(v44.m128_f32[0] * v44.m128_f32[0]) + (float)(v45.m128_f32[0] * v45.m128_f32[0]);
          v47 = fsqrt(v46);
          if ( v47 <= (float)(v37 + v35) && v47 >= COERCE_FLOAT(COERCE_UNSIGNED_INT(v35 - v37) & _xmm) && (v47 > 0.00000011920929 || COERCE_FLOAT(COERCE_UNSIGNED_INT(v35 - v37) & _xmm) >= 0.00000011920929) )
          {
            if ( v47 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 652, ASSERT_TYPE_SANITY, "( val != 0.0f )", (const char *)&queryFormat, "val != 0.0f") )
              __debugbreak();
            v48 = 1.0 / v47;
            v49 = (float)((float)((float)(v35 * v35) - (float)(v37 * v37)) + v46) * v48;
            v50 = (float)(v49 * 0.5) * v48;
            v51 = fsqrt((float)(v35 * v35) - (float)((float)(v49 * v49) * 0.25)) * v48;
            *(float *)&v132 = (float)(v45.m128_f32[0] * v51) + (float)(v44.m128_f32[0] * v50);
            *((float *)&v132 + 1) = (float)(v45.m128_f32[0] * v50) - (float)(v44.m128_f32[0] * v51);
            if ( v46 > 0.00000011920929 )
            {
              v53 = *(_OWORD *)&v45 & _xmm;
              *(float *)&v53 = COERCE_FLOAT(v45.m128_i32[0] & _xmm) + 1.0e-10;
              v52 = v53;
              v55 = v44;
              v55.m128_f32[0] = v44.m128_f32[0] + *(float *)&v52;
              _XMM4 = v55;
              _XMM10 = 0i64;
              v58 = v52;
              *(float *)&v58 = *(float *)&v52 - v44.m128_f32[0];
              _XMM2 = v58;
              __asm
              {
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm3, xmm4, xmm1, xmm0
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm0, xmm2, xmm4, xmm0
              }
              v63 = _XMM3;
              _XMM2 = LODWORD(FLOAT_2_3561945);
              *(float *)&v63 = (float)((float)((float)((float)(*(float *)&_XMM3 / *(float *)&_XMM0) * 0.1963) * (float)(*(float *)&_XMM3 / *(float *)&_XMM0)) - 0.9817) * (float)(*(float *)&_XMM3 / *(float *)&_XMM0);
              __asm
              {
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm0, xmm2, xmm1, xmm0
              }
              *(float *)&v63 = *(float *)&v63 + *(float *)&_XMM0;
              _XMM1 = v63 ^ _xmm;
              __asm
              {
                vcmpless xmm0, xmm10, xmm9
                vblendvps xmm0, xmm1, xmm2, xmm0
              }
              v122 = *(float *)&_XMM0;
              if ( v46 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 639, ASSERT_TYPE_SANITY, "( val > 0 )", (const char *)&queryFormat, "val > 0") )
                __debugbreak();
              v138 = v132;
              v71 = 0i64;
              *(float *)&v71 = v46;
              _XMM6 = v71;
              v72 = HIDWORD(v132);
              *(float *)&v72 = fsqrt((float)(*(float *)&v72 * *(float *)&v72) + (float)(*(float *)&v132 * *(float *)&v132));
              _XMM2 = v72;
              __asm
              {
                vcmpless xmm0, xmm2, cs:__real@80000000
                vblendvps xmm0, xmm2, xmm8, xmm0
                vrsqrtss xmm6, xmm6, xmm6
              }
              *(double *)&_XMM0 = I_fclamp((float)((float)(v45.m128_f32[0] * *(float *)&_XMM6) * (float)(*((float *)&v132 + 1) * (float)(1.0 / *(float *)&_XMM0))) + (float)((float)(v44.m128_f32[0] * *(float *)&_XMM6) * (float)(*(float *)&v132 * (float)(1.0 / *(float *)&_XMM0))), -1.0, 1.0);
              *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
              v36 = *(float *)&_XMM0 * 2.0;
              v38 = v122 - *(float *)&_XMM0;
            }
          }
          v30 = _xmm;
        }
        v77 = v27 + v8->m_particleCountRunning;
        if ( !v8->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 344, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
          __debugbreak();
        ParticleDataArray = ParticleData::GetParticleDataArray(v8, PARTICLE_DATA_SPAWN_POS);
        v31 = halfHeight;
        v79 = v77 + 1;
        v80 = ParticleDataArray;
        LODWORD(_XMM6) = 0;
        if ( v77 + 1 > 8 )
          v79 = 8;
        v82 = 0;
        v83 = 0i64;
        if ( v79 )
        {
          v84 = outOffset.v;
          v85 = LODWORD(halfHeight) ^ v30;
          v86 = halfHeight - COERCE_FLOAT(LODWORD(halfHeight) ^ v30);
          v87.v = (__m128)result.y;
          do
          {
            v88 = pModuleBase[1].m_type;
            v89 = (v82 + v117) % 0x3FE9;
            FastSinCos((float)(v36 * fx_randomTable[v89 + 9]) + v38, &s, &c);
            v90 = c * v35;
            outPos.v[2] = (float)(v86 * fx_randomTable[v89 + 10]) + *(float *)&v85;
            outPos.v[0] = c * v35;
            outPos.v[1] = s * v35;
            if ( v88 != PARTICLE_MODULE_AXES_FLAG_ALL )
            {
              Particle_SpawnShapeConvertPos(v88, &outPos);
              v90 = outPos.v[0];
            }
            v140.m128_i32[3] = 0;
            v92 = v140;
            v92.m128_f32[0] = v90;
            _XMM1 = v92;
            __asm
            {
              vinsertps xmm1, xmm1, xmm3, 10h
              vinsertps xmm1, xmm1, xmm4, 20h ; ' '
            }
            v140 = _XMM1;
            if ( v114 )
              _XMM1 = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(v87.v, _mm_shuffle_ps(_XMM1, _XMM1, 85)), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(v84, _mm_shuffle_ps(_XMM1, _XMM1, 170)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM1, _XMM1, 0), result.x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
            _XMM3 = LODWORD(FLOAT_3_4028235e38);
            v96 = _mm128_add_ps(v21, _XMM1);
            if ( v77 )
            {
              v97 = (__m128 *)v80;
              v98 = v77;
              do
              {
                v99 = *v97++;
                v100 = _mm128_sub_ps(v99, v96);
                _XMM2 = _mm128_mul_ps(v100, v100);
                __asm
                {
                  vinsertps xmm0, xmm2, xmm2, 8
                  vhaddps xmm1, xmm0, xmm0
                  vhaddps xmm2, xmm1, xmm1
                  vminss  xmm3, xmm2, xmm3
                }
                --v98;
              }
              while ( v98 );
            }
            if ( *(float *)&_XMM3 > *(float *)&_XMM6 )
              v83 = v96;
            ++v82;
            __asm { vmaxss  xmm6, xmm3, xmm6 }
          }
          while ( v82 < v79 );
          v31 = halfHeight;
        }
        v14 = v128;
        v30 = _xmm;
        v29 = FLOAT_6_2831855;
        v27 = v119;
        v8 = v130;
        m_type = v114;
        *(__m128 *)((char *)PositionArrayNextFreeElem + v128) = v83;
        *(__m128 *)v14 = v83;
        v28 = radiusMax;
      }
      else
      {
        v105 = pModuleBase[1].m_type;
        FastSinCos(v29 * fx_randomTable[v33 + 9], v126, &v125);
        v106 = v125 * v35;
        v137.v[2] = (float)((float)(v31 - COERCE_FLOAT(LODWORD(v31) ^ v30)) * fx_randomTable[v34 + 10]) + COERCE_FLOAT(LODWORD(v31) ^ v30);
        v137.v[0] = v125 * v35;
        v137.v[1] = v126[0] * v35;
        if ( v105 != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(v105, &v137);
          v106 = v137.v[0];
        }
        v141.m128_i32[3] = 0;
        v108 = v141;
        v108.m128_f32[0] = v106;
        _XMM1 = v108;
        __asm
        {
          vinsertps xmm1, xmm1, xmm4, 10h
          vinsertps xmm1, xmm1, xmm5, 20h ; ' '
        }
        v141 = _XMM1;
        if ( m_type )
          _XMM1 = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM1, _XMM1, 85), result.y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(v23, _mm_shuffle_ps(_XMM1, _XMM1, 170)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM1, _XMM1, 0), result.x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
        v111 = _mm128_add_ps(v21, _XMM1);
        *(__m128 *)((char *)PositionArrayNextFreeElem + v14) = v111;
        *(__m128 *)v14 = v111;
      }
      v23 = outOffset.v;
      v9 = (ParticleState *)v131;
      ++v27;
      v14 += 16i64;
      v119 = v27;
      v128 = v14;
    }
    while ( v27 < particleCountEmit );
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  char m_type_high; 
  float4 *PositionArrayNextFreeElem; 
  unsigned int v10; 
  __m128 v; 
  ParticleEmitter *m_pEmitterOwner; 
  signed int v13; 
  ParticleModuleAxesFlags m_type; 
  __int64 v15; 
  float v16; 
  float v17; 
  float v18; 
  float4 *v19; 
  __m128 v21; 
  __m128 v24; 
  unsigned int v25; 
  ParticleEmitter *v26; 
  signed int v27; 
  ParticleModuleAxesFlags v28; 
  __int64 v29; 
  float v30; 
  float v31; 
  float v32; 
  __m128 v35; 
  float4 *v41; 
  __m128 v42; 
  float c; 
  float s; 
  float4 *SpawnPosArrayNextFreeElem; 
  float4 outOffset; 
  vec3_t outPos; 
  __m128 v48; 
  float4 radiusMax; 
  float4 radiusMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_type_high = HIBYTE(pModuleBase[1].m_type);
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
  ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
  if ( (m_type_high & 1) != 0 )
  {
    v10 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)PositionArrayNextFreeElem);
      v = outOffset.v;
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v13 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v10) % 0x3FE9;
        }
        else
        {
          v13 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v10];
        }
        m_type = pModuleBase[1].m_type;
        v15 = v13;
        v16 = (float)(2.0 * fx_randomTable[v13 + 10]) - 1.0;
        if ( (v16 < -1.0 || v16 > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v16) )
          __debugbreak();
        v17 = fsqrt(1.0 - (float)(v16 * v16));
        FastSinCos(6.2831855 * fx_randomTable[v15 + 9], &s, &c);
        v18 = c * v17;
        outPos.v[0] = v18;
        outPos.v[1] = s * v17;
        outPos.v[2] = v16;
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)(outPos.v[1] * outPos.v[1]) + (float)(v18 * v18)) + (float)(v16 * v16)) - 1.0) & _xmm) >= 0.0000010000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
          __debugbreak();
        if ( m_type != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(m_type, &outPos);
          v18 = outPos.v[0];
        }
        ++v10;
        v48.m128_i32[3] = 0;
        v19 = SpawnPosArrayNextFreeElem;
        v21 = v48;
        v21.m128_f32[0] = v18;
        _XMM1 = v21;
        __asm
        {
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm8, 20h ; ' '
        }
        *PositionArrayNextFreeElem = (float4)_XMM1;
        v48 = _XMM1;
        v24 = _mm128_add_ps(v, _mm128_mul_ps(_XMM1, radiusMax.v));
        *PositionArrayNextFreeElem = (float4)v24;
        *(__m128 *)((char *)&PositionArrayNextFreeElem->v + (_QWORD)v19) = v24;
        ++PositionArrayNextFreeElem;
      }
      while ( v10 < particleCountEmit );
    }
  }
  else
  {
    v25 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)PositionArrayNextFreeElem);
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          v26 = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v27 = (ParticleEmitter::GetEmitterDef(v26)->randomSeed + v26->m_lifetimeParticleCount + 10111 * (unsigned __int8)v25) % 0x3FE9;
        }
        else
        {
          v27 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v25];
        }
        v28 = pModuleBase[1].m_type;
        v29 = v27;
        v30 = (float)(2.0 * fx_randomTable[v27 + 10]) - 1.0;
        if ( (v30 < -1.0 || v30 > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v30) )
          __debugbreak();
        v31 = fsqrt(1.0 - (float)(v30 * v30));
        FastSinCos(6.2831855 * fx_randomTable[v29 + 9], &c, &s);
        v32 = s * v31;
        outPos.v[0] = v32;
        outPos.v[1] = c * v31;
        outPos.v[2] = v30;
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)(outPos.v[1] * outPos.v[1]) + (float)(v32 * v32)) + (float)(v30 * v30)) - 1.0) & _xmm) >= 0.0000010000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
          __debugbreak();
        if ( v28 != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(v28, &outPos);
          v32 = outPos.v[0];
        }
        ++v25;
        v48.m128_i32[3] = 0;
        _XMM2 = 0i64;
        v35 = v48;
        v35.m128_f32[0] = v32;
        _XMM4 = v35;
        __asm
        {
          vinsertps xmm4, xmm4, xmm6, 10h
          vinsertps xmm4, xmm4, xmm8, 20h ; ' '
        }
        *PositionArrayNextFreeElem = (float4)_XMM4;
        __asm
        {
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A0h], 0
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A4h], 10h
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A8h], 20h ; ' '
        }
        v41 = SpawnPosArrayNextFreeElem;
        v42 = _mm128_add_ps(_mm128_mul_ps(_XMM4, _mm128_add_ps(_mm128_mul_ps(_XMM2, _mm128_sub_ps(radiusMax.v, radiusMin.v)), radiusMin.v)), outOffset.v);
        *PositionArrayNextFreeElem = (float4)v42;
        *(__m128 *)((char *)&v41->v + (_QWORD)PositionArrayNextFreeElem++) = v42;
        v48 = _XMM4;
      }
      while ( v25 < particleCountEmit );
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeMesh::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeMesh::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ParticleData *v5; 
  ParticleState *v6; 
  ParticleModule *v7; 
  float4 *v8; 
  __int64 v9; 
  XSurface *v10; 
  __int64 v11; 
  __int64 v12; 
  const XModel *v13; 
  ParticleModule v14; 
  bool v15; 
  _DWORD *v16; 
  unsigned int v17; 
  int v18; 
  int v19; 
  XSurface *v20; 
  __int64 v21; 
  __int64 v22; 
  XSurface *v23; 
  const char *VFXName; 
  unsigned int v25; 
  __m128 v; 
  ParticleEmitter *m_pEmitterOwner; 
  int v29; 
  __int64 v30; 
  const XModel *v31; 
  int *v32; 
  int v33; 
  unsigned int v34; 
  int v35; 
  unsigned int v36; 
  unsigned int v37; 
  unsigned int v38; 
  XSurface *v39; 
  unsigned int v40; 
  const char *v41; 
  const char *XModelSurfsName; 
  unsigned int v43; 
  XSurfaceShared *shared; 
  unsigned __int8 *data; 
  __int128 v47; 
  float4 *v50; 
  __m128 v51; 
  int v52; 
  unsigned int v53; 
  unsigned int v54; 
  unsigned int v55; 
  XSurface *v56; 
  unsigned int v57; 
  const char *v58; 
  const char *v59; 
  unsigned int v60; 
  XSurfaceShared *v61; 
  unsigned __int8 *v62; 
  unsigned __int8 *v63; 
  XSurfaceShared *v64; 
  unsigned __int8 *v65; 
  unsigned __int8 *v66; 
  const Bounds *p_surfBounds; 
  __int64 v68; 
  __int64 v69; 
  __int64 v70; 
  ParticleModuleAxesFlags m_type; 
  __m128 v78; 
  __m128 v81; 
  const char *v84; 
  __int64 v85; 
  __int64 v86; 
  char m_flags; 
  float4 *PositionArrayNextFreeElem; 
  __int64 v91; 
  unsigned int v92; 
  XSurface *v93; 
  __int64 v94; 
  float4 *SpawnPosArrayNextFreeElem; 
  ParticleModule *v96; 
  ParticleData *v97; 
  vec3_t outPos; 
  vec3_t result; 
  XSurface *surfaces[2]; 
  float4 outOffset; 
  float4 v102; 
  float4 v103; 
  float4 v104; 

  v97 = pParticleData;
  v5 = pParticleData;
  v6 = (ParticleState *)pParticleState;
  v7 = (ParticleModule *)pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + v5->m_particleCountRunning > v5->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (v7->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = v7[6].m_flags;
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(v5);
  v8 = PositionArrayNextFreeElem;
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(v5);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)v7, v6, &outOffset);
  if ( *(_DWORD *)&v7[8].m_type )
  {
    v9 = (__int64)&v7[7];
    v10 = (XSurface *)*(int *)&v7[8].m_type;
    v96 = v7 + 7;
    v93 = v10;
    if ( (__int64)v10 > 0 )
    {
      v11 = 0i64;
      v12 = 0i64;
      v91 = 0i64;
      v94 = 0i64;
      do
      {
        v13 = *(const XModel **)(v12 + *(_QWORD *)v9);
        *(_QWORD *)result.v = v13;
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2101, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
          __debugbreak();
        v14 = v7[9];
        v15 = v11 + *(_QWORD *)&v14 == 0;
        v16 = (_DWORD *)(v11 + *(_QWORD *)&v14);
        *(_QWORD *)outPos.v = v16;
        if ( v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2104, ASSERT_TYPE_ASSERT, "(pMeshData)", (const char *)&queryFormat, "pMeshData") )
          __debugbreak();
        if ( (v13->flags & 0x8000) == 0 )
        {
          v17 = XModelGetSurfaces(v13, surfaces, 0);
          v18 = 0;
          v19 = 0;
          if ( v17 )
          {
            v20 = surfaces[0];
            v21 = 0i64;
            v22 = v17;
            do
            {
              v23 = &v20[v21];
              if ( !&v20[v21] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2121, ASSERT_TYPE_ASSERT, "(pSurface)", (const char *)&queryFormat, "pSurface") )
                __debugbreak();
              ++v21;
              v18 += v23->vertCount;
              v19 += v23->triCount;
              --v22;
            }
            while ( v22 );
            v13 = *(const XModel **)result.v;
            v16 = *(_DWORD **)outPos.v;
            v12 = v94;
            v11 = v91;
            v10 = v93;
          }
          if ( *v16 == v18 && v16[1] == v19 )
          {
            v6 = (ParticleState *)pParticleState;
          }
          else
          {
            v6 = (ParticleState *)pParticleState;
            VFXName = ParticleState::GetVFXName((ParticleState *)pParticleState);
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2129, ASSERT_TYPE_ASSERT, "(pMeshData->m_numVertsTotal == numVertsTotal && pMeshData->m_numTrisTotal == numTrisTotal)", "%s\n\tERROR: There is a vertex/triangle count mismatch for the model %s, referenced by the effect %s. This may be due to an incorrectly patched model/vfx reference.\n", "pMeshData->m_numVertsTotal == numVertsTotal && pMeshData->m_numTrisTotal == numTrisTotal", v13->name, VFXName) )
              __debugbreak();
          }
          v9 = (__int64)v96;
        }
        v7 = (ParticleModule *)pModuleBase;
        v12 += 32i64;
        v11 += 16i64;
        v94 = v12;
        v10 = (XSurface *)((char *)v10 - 1);
        v91 = v11;
        v93 = v10;
      }
      while ( v10 );
      v8 = PositionArrayNextFreeElem;
      v5 = v97;
    }
    v25 = 0;
    v92 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)v8);
      v = outOffset.v;
      _XMM8 = LODWORD(FLOAT_1_0);
      while ( 1 )
      {
        if ( (HIBYTE(v7[1].m_type) & 8) != 0 )
        {
          if ( !v6->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)v6->m_pEmitterOwner;
          v29 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v25) % 0x3FE9;
        }
        else
        {
          v29 = Particle_GetRandomSeedArrayNextFreeElem(v5)[v25];
        }
        if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 215, ASSERT_TYPE_ASSERT, "(pLinkedAssetList)", (const char *)&queryFormat, "pLinkedAssetList") )
          __debugbreak();
        if ( !*(_QWORD *)v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 216, ASSERT_TYPE_ASSERT, "(pLinkedAssetList->assetList)", (const char *)&queryFormat, "pLinkedAssetList->assetList") )
          __debugbreak();
        if ( *(int *)(v9 + 8) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 217, ASSERT_TYPE_ASSERT, "(pLinkedAssetList->numAssets > 0)", (const char *)&queryFormat, "pLinkedAssetList->numAssets > 0") )
          __debugbreak();
        v30 = Particle_RandomIndex(v29, FXRAND_VISUAL, *(_DWORD *)(v9 + 8));
        v31 = *(const XModel **)(32 * v30 + *(_QWORD *)v9);
        if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2143, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
          __debugbreak();
        v32 = (int *)(*(_QWORD *)&pModuleBase[9] + 16 * v30);
        if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2146, ASSERT_TYPE_ASSERT, "(pMeshData)", (const char *)&queryFormat, "pMeshData") )
          __debugbreak();
        v33 = XModelGetSurfaces(v31, &v93, 0);
        v34 = v33;
        if ( m_flags )
          goto LABEL_93;
        v35 = *v32;
        if ( !*v32 || !v33 )
          break;
        v36 = 0;
        if ( v35 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 74, ASSERT_TYPE_ASSERT, "(count > 0)", (const char *)&queryFormat, "count > 0") )
          __debugbreak();
        v37 = abs32((v35 * LOWORD(fx_randomTable[v29 + 6])) >> 16);
        if ( v37 >= v35 )
        {
          LODWORD(v86) = v35;
          LODWORD(v85) = v37;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v85, v86) )
            __debugbreak();
        }
        v38 = 0;
        if ( v34 )
        {
          v39 = v93;
          while ( 1 )
          {
            v40 = v36 + v39->vertCount;
            if ( v40 > v37 )
              break;
            ++v38;
            ++v39;
            v36 = v40;
            if ( v38 >= v34 )
              goto LABEL_80;
          }
          v43 = v37 - v36;
          if ( v39->sharedVertDataOffset >= v39->shared->dataSize )
          {
            LODWORD(v86) = v39->shared->dataSize;
            LODWORD(v85) = v39->sharedVertDataOffset;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 33, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedVertDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedVertDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v85, v86) )
              __debugbreak();
          }
          shared = v39->shared;
          if ( (shared->flags & 1) != 0 )
            data = Stream_AddressSpace_ResolveHandle(&v39->shared->data.streamedDataHandle);
          else
            data = (unsigned __int8 *)shared->data.streamedDataHandle.data;
          XSurfaceUnpackPosition(*(const PackedPosition *)&data[20 * v43 + v39->sharedVertDataOffset], &v39->surfBounds, &result);
          v8 = PositionArrayNextFreeElem;
          HIDWORD(surfaces[1]) = 0;
          v47 = *(_OWORD *)surfaces;
          *(float *)&v47 = result.v[0];
          _XMM3 = v47;
          __asm
          {
            vinsertps xmm3, xmm3, dword ptr [rbp+70h+result+4], 70h+var_60
            vinsertps xmm3, xmm3, dword ptr [rbp+70h+result+8], 70h+var_50
          }
          *(float4 *)surfaces = (float4)_XMM3.v;
          *PositionArrayNextFreeElem = (float4)_XMM3.v;
LABEL_88:
          v7 = (ParticleModule *)pModuleBase;
          goto LABEL_89;
        }
LABEL_80:
        v8 = PositionArrayNextFreeElem;
        v6 = (ParticleState *)pParticleState;
        *PositionArrayNextFreeElem = 0i64;
        v41 = ParticleState::GetVFXName((ParticleState *)pParticleState);
        XModelSurfsName = XModelGetXModelSurfsName(v31, 0);
        Com_PrintWarning(21, "Could not find vertex index %d on model %s (lod model info %s) in effect %s. This may be due to transients loading the default FX model.\n", v37, v31->name, XModelSurfsName, v41);
        v7 = (ParticleModule *)pModuleBase;
LABEL_90:
        v50 = SpawnPosArrayNextFreeElem;
        v9 = (__int64)v96;
        v25 = v92 + 1;
        v5 = v97;
        v51 = _mm128_add_ps(v, v8->v);
        *v8 = (float4)v51;
        *(__m128 *)((char *)&v8->v + (_QWORD)v50) = v51;
        ++v8;
        v92 = v25;
        PositionArrayNextFreeElem = v8;
        if ( v25 >= particleCountEmit )
          return;
      }
      v8 = PositionArrayNextFreeElem;
LABEL_93:
      v52 = v32[1];
      if ( !v52 || !v33 )
      {
        if ( !v31->name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2245, ASSERT_TYPE_ASSERT, "(pModel->name)", (const char *)&queryFormat, "pModel->name") )
          __debugbreak();
        if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2246, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
          __debugbreak();
        if ( !ParticleState::GetVFXName(v6) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2247, ASSERT_TYPE_ASSERT, "(pParticleState->GetVFXName())", (const char *)&queryFormat, "pParticleState->GetVFXName()") )
          __debugbreak();
        v84 = ParticleState::GetVFXName(v6);
        R_WarnOncePerFrame(R_WARN_FX_INVALID_SHAPE_MESH, v31->name, v84);
        v7 = (ParticleModule *)pModuleBase;
        *v8 = 0i64;
        goto LABEL_90;
      }
      v53 = 0;
      if ( v52 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 74, ASSERT_TYPE_ASSERT, "(count > 0)", (const char *)&queryFormat, "count > 0") )
        __debugbreak();
      v54 = abs32((v52 * LOWORD(fx_randomTable[v29 + 22])) >> 16);
      if ( v54 >= v52 )
      {
        LODWORD(v86) = v52;
        LODWORD(v85) = v54;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v85, v86) )
          __debugbreak();
      }
      v55 = 0;
      v56 = v93;
      while ( 1 )
      {
        v57 = v53 + v56->triCount;
        if ( v57 > v54 )
          break;
        ++v55;
        ++v56;
        v53 = v57;
        if ( v55 >= v34 )
        {
          *v8 = 0i64;
          v58 = ParticleState::GetVFXName((ParticleState *)pParticleState);
          v59 = XModelGetXModelSurfsName(v31, 0);
          Com_PrintWarning(21, "Could not find tri index %d on model %s (lod model info %s) in effect %s. This may be due to transients loading the default FX model", v54, v31->name, v59, v58);
          goto LABEL_88;
        }
      }
      v60 = v54 - v53;
      if ( v56->sharedVertDataOffset >= v56->shared->dataSize )
      {
        LODWORD(v86) = v56->shared->dataSize;
        LODWORD(v85) = v56->sharedVertDataOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 33, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedVertDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedVertDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v85, v86) )
          __debugbreak();
      }
      v61 = v56->shared;
      if ( (v61->flags & 1) != 0 )
      {
        v62 = Stream_AddressSpace_ResolveHandle(&v56->shared->data.streamedDataHandle);
        v61 = v56->shared;
      }
      else
      {
        v62 = (unsigned __int8 *)v61->data.streamedDataHandle.data;
      }
      v63 = &v62[v56->sharedVertDataOffset];
      if ( v56->sharedIndexDataOffset >= v61->dataSize )
      {
        LODWORD(v86) = v61->dataSize;
        LODWORD(v85) = v56->sharedIndexDataOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 46, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedIndexDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedIndexDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v85, v86) )
          __debugbreak();
      }
      v64 = v56->shared;
      if ( (v64->flags & 1) != 0 )
        v65 = Stream_AddressSpace_ResolveHandle(&v56->shared->data.streamedDataHandle);
      else
        v65 = (unsigned __int8 *)v64->data.streamedDataHandle.data;
      v66 = &v65[v56->sharedIndexDataOffset];
      if ( ((unsigned __int8)v66 & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 48, ASSERT_TYPE_ASSERT, "(IsAligned( indices, 16 ))", (const char *)&queryFormat, "IsAligned( indices, 16 )") )
        __debugbreak();
      p_surfBounds = &v56->surfBounds;
      v68 = 3 * v60;
      v69 = 5i64 * *(unsigned __int16 *)&v66[2 * v68 + 2];
      v70 = 5i64 * *(unsigned __int16 *)&v66[2 * v68 + 4];
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v63[20 * *(unsigned __int16 *)&v66[2 * v68]], p_surfBounds, &v102);
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v63[4 * v69], p_surfBounds, &v103);
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v63[4 * v70], p_surfBounds, &v104);
      v7 = (ParticleModule *)pModuleBase;
      v8 = PositionArrayNextFreeElem;
      m_type = pModuleBase[1].m_type;
      _XMM2 = LODWORD(fx_randomTable[v29 + 7]);
      _XMM4 = LODWORD(fx_randomTable[v29 + 6]);
      __asm
      {
        vcmpltss xmm0, xmm8, xmm3
        vblendvps xmm6, xmm2, xmm1, xmm0
        vcmpltss xmm0, xmm8, xmm3
        vblendvps xmm5, xmm4, xmm1, xmm0
      }
      v78 = (__m128)LODWORD(FLOAT_1_0);
      v78.m128_f32[0] = (float)(1.0 - _XMM5.m128_f32[0]) - _XMM6.m128_f32[0];
      _XMM0 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v78, v78, 0), v104.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM6, _XMM6, 0), v103.v), _mm128_mul_ps(_mm_shuffle_ps(_XMM5, _XMM5, 0), v102.v)));
      *PositionArrayNextFreeElem = (float4)_XMM0;
      *(float *)&v94 = _XMM6.m128_f32[0];
      if ( m_type != PARTICLE_MODULE_AXES_FLAG_ALL )
      {
        outPos.v[0] = _XMM0.m128_f32[0];
        __asm
        {
          vextractps dword ptr [rbp+70h+outPos+4], xmm0, 1
          vextractps dword ptr [rbp+70h+outPos+8], xmm0, 2
        }
        Particle_SpawnShapeConvertPos(m_type, &outPos);
        outOffset.v.m128_i32[3] = 0;
        v81 = outOffset.v;
        v81.m128_f32[0] = outPos.v[0];
        _XMM3 = v81;
        __asm
        {
          vinsertps xmm3, xmm3, dword ptr [rbp+70h+outPos+4], 70h+var_60
          vinsertps xmm3, xmm3, dword ptr [rbp+70h+outPos+8], 70h+var_50
        }
        outOffset.v = _XMM3;
        *PositionArrayNextFreeElem = (float4)_XMM3;
      }
LABEL_89:
      v6 = (ParticleState *)pParticleState;
      goto LABEL_90;
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeSphere::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  char v8; 
  float4 *PositionArrayNextFreeElem; 
  ParticleEmitter *EmitterOwner; 
  const vector4 *EmitterTransformTranspose; 
  __m128 v; 
  unsigned int v13; 
  float v14; 
  __m128 *p_v; 
  ParticleEmitter *m_pEmitterOwner; 
  int v17; 
  __m128 v18; 
  float v19; 
  __m128 *v20; 
  float v21; 
  ParticleEmitter *v22; 
  int v23; 
  __m128 v24; 
  float4 *SpawnPosArrayNextFreeElem; 
  signed __int64 v26; 
  signed __int64 v27; 
  float radiusMax; 
  float radiusMin; 
  float4 outOffset; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v8 = HIBYTE(pModuleBase[1].m_type) & 1;
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
  ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
  if ( (pModuleBase->m_flags & 0x80) != 0 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
    v = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 85), EmitterTransformTranspose->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 170), EmitterTransformTranspose->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(outOffset.v, outOffset.v, 0), EmitterTransformTranspose->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
  }
  else
  {
    v = outOffset.v;
  }
  v13 = 0;
  if ( v8 )
  {
    if ( particleCountEmit )
    {
      v26 = (char *)SpawnPosArrayNextFreeElem - (char *)PositionArrayNextFreeElem;
      v14 = radiusMax;
      p_v = &PositionArrayNextFreeElem->v;
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v17 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v13) % 0x3FE9;
        }
        else
        {
          v17 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v13];
        }
        Particle_RandomPointOnSphere(v17, &PositionArrayNextFreeElem[v13], v14, pModuleBase[1].m_type);
        v18 = _mm128_add_ps(v, *p_v);
        ++v13;
        *p_v = v18;
        *(__m128 *)((char *)p_v++ + v26) = v18;
      }
      while ( v13 < particleCountEmit );
    }
  }
  else if ( particleCountEmit )
  {
    v27 = (char *)SpawnPosArrayNextFreeElem - (char *)PositionArrayNextFreeElem;
    v19 = radiusMax;
    v20 = &PositionArrayNextFreeElem->v;
    v21 = radiusMin;
    do
    {
      if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
      {
        if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        v22 = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
        v23 = (ParticleEmitter::GetEmitterDef(v22)->randomSeed + v22->m_lifetimeParticleCount + 10111 * (unsigned __int8)v13) % 0x3FE9;
      }
      else
      {
        v23 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v13];
      }
      Particle_RandomPointOnSphere(v23, &PositionArrayNextFreeElem[v13], (float)((float)(1.0 - fx_randomTable[v23 + 11]) * v21) + (float)(v19 * fx_randomTable[v23 + 11]), pModuleBase[1].m_type);
      v24 = _mm128_add_ps(v, *v20);
      ++v13;
      *v20 = v24;
      *(__m128 *)((char *)v20++ + v27) = v24;
    }
    while ( v13 < particleCountEmit );
  }
}

/*
==============
ParticleModuleInitTail::InitParticles
==============
*/
void ParticleModuleInitTail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitVectorField::InitParticles
==============
*/
void ParticleModuleInitVectorField::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitVolumetric::InitParticles
==============
*/
void ParticleModuleInitVolumetric::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitModel::InitPhysicsParticles
==============
*/
void ParticleModuleInitModel::InitPhysicsParticles(ParticleModuleInitModel *this, ParticleData *pParticleData, const unsigned int particleCountEmit, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, FxPhysics *physicsInstanceIDList)
{
  __int64 m_particleCountRunning; 
  float4 *PositionArrayAtIndex; 
  __int64 v12; 
  unsigned __int8 *ParticleDataArray; 
  __int64 v14; 
  ParticleEmitter *v15; 
  __int64 m_localClientNum; 
  unsigned __int64 flags; 
  void (__fastcall *v18)(Physics_SimpleCollisionCallback_Data *); 
  const ParticleSystem *SystemOwner; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  ParticleRelativeVelocityType m_velocityType; 
  unsigned int *p_createListIndex; 
  ParticleLinkedAssetListDef *p_m_linkedAssetList; 
  signed __int64 v24; 
  signed __int64 v25; 
  _DWORD *v26; 
  unsigned __int8 *v27; 
  int *v28; 
  Material *material; 
  ParticleSystem *v30; 
  const ParticleSystemDef *v31; 
  unsigned __int32 v32; 
  double FixedMemoryPoolUsage; 
  ParticleSystem *v34; 
  const ParticleSystemDef *Def; 
  const ParticleState *v36; 
  const ParticleModuleInitRelativeVelocity *v37; 
  __m128 v; 
  const ParticleStateDef *m_pStateDef; 
  float4 *v41; 
  __m128 v42; 
  float v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  const ParticleSystem *m_pSystemOwner; 
  int v53; 
  __int64 v54; 
  volatile signed __int32 *v55; 
  __m128 v56; 
  __int64 v57; 
  __int128 v59; 
  bool v60; 
  __int64 v61; 
  __int64 v62; 
  char v63; 
  unsigned int v64; 
  ParticleRelativeVelocityType v65; 
  Physics_WorldId worldId; 
  unsigned int v68; 
  float4 *RotationAngleArrayAtIndex; 
  signed __int64 v70; 
  float4 *VelocityArrayAtIndex; 
  signed __int64 v72; 
  float4 *RotationRateArrayAtIndex; 
  signed __int64 v74; 
  unsigned __int8 *v75; 
  signed __int64 v76; 
  unsigned __int8 *v77; 
  unsigned __int8 *v78; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v80; 
  int outAssetIndex; 
  vector3 *rotMatrix; 
  __int64 v83; 
  ParticleEmitter *v84; 
  __int128 v85; 
  __int64 v86; 
  __int64 v87; 
  void (__fastcall *v88)(Physics_SimpleCollisionCallback_Data *); 
  ParticleLinkedAssetListDef *v89; 
  __m128 v90; 
  vec4_t quat; 
  __m128 v92; 

  v84 = (ParticleEmitter *)pEmitterOwner;
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 974, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 975, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 976, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 977, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 978, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !this->m_usePhysics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 979, ASSERT_TYPE_ASSERT, "(m_usePhysics)", (const char *)&queryFormat, "m_usePhysics") )
    __debugbreak();
  if ( !physicsInstanceIDList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 980, ASSERT_TYPE_ASSERT, "(physicsInstanceIDList)", (const char *)&queryFormat, "physicsInstanceIDList") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, m_particleCountRunning);
  Particle_GetSizeArrayAtIndex(pParticleData, m_particleCountRunning);
  RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, m_particleCountRunning);
  RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, m_particleCountRunning);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v61) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v61, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v75 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_SPAWN_QUAT)[16 * m_particleCountRunning];
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v62) = pParticleData->m_particleCountMax;
    LODWORD(v61) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v61, v62) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v12 = 4 * m_particleCountRunning;
  v77 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_HANDLE)[4 * m_particleCountRunning];
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v62) = pParticleData->m_particleCountMax;
    LODWORD(v61) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v61, v62) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  ParticleDataArray = ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_FLAGS);
  v14 = m_particleCountRunning;
  v15 = v84;
  v83 = (__int64)&ParticleDataArray[v12];
  m_localClientNum = v84->m_pSystemOwner->m_localClientNum;
  v68 = m_localClientNum;
  worldId = 3 * m_localClientNum + 3;
  flags = pParticleState->m_pStateDef->flags;
  v18 = NULL;
  if ( (flags & 0x10000) != 0 )
    v18 = ParticleState::OnImpactCB;
  v88 = v18;
  v86 = (unsigned __int8)flags & 0xA0;
  rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform(v84, pParticleState);
  SystemOwner = ParticleEmitter::GetSystemOwner(v84);
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  v63 = SystemOwner->m_flags & 1;
  if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
    m_velocityType = PARTICLE_RELATIVE_VELOCITY_TYPE_LOCAL;
  else
    m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
  v65 = m_velocityType;
  Particle_RotMatrixToQuatVec(rotMatrix, &quat);
  v90 = (__m128)quat;
  v64 = 0;
  if ( particleCountEmit )
  {
    p_createListIndex = &physicsInstanceIDList[v14].createListIndex;
    p_m_linkedAssetList = &this->m_linkedAssetList;
    v24 = (char *)RandomSeedArrayAtIndex - (char *)v77;
    v25 = v75 - (unsigned __int8 *)PositionArrayAtIndex;
    v70 = (char *)RotationAngleArrayAtIndex - (char *)PositionArrayAtIndex;
    v26 = (_DWORD *)v83;
    v72 = (char *)VelocityArrayAtIndex - (char *)PositionArrayAtIndex;
    v74 = (char *)RotationRateArrayAtIndex - (char *)PositionArrayAtIndex;
    v27 = &v77[-v83];
    v87 = m_localClientNum;
    v89 = &this->m_linkedAssetList;
    v80 = (char *)RandomSeedArrayAtIndex - (char *)v77;
    v76 = v75 - (unsigned __int8 *)PositionArrayAtIndex;
    v78 = &v77[-v83];
    do
    {
      v28 = (_DWORD *)((char *)v26 + (_QWORD)v27);
      material = Particle_GetRandomAssetWithIndex(p_m_linkedAssetList, *(_DWORD *)((char *)v26 + (_QWORD)v27 + v24), FXRAND_VISUAL, &outAssetIndex)->material;
      if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1038, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
        __debugbreak();
      if ( *(_QWORD *)&material[5].cameraRegion )
      {
        FixedMemoryPoolUsage = Physics_GetFixedMemoryPoolUsage(worldId);
        if ( *(float *)&FixedMemoryPoolUsage <= particle_physics_memory_threshold->current.value )
        {
          v36 = pParticleState;
          v37 = pParticleState->m_pModuleInitRelativeVelocity;
          if ( !v37 || (v37->m_flags & 1) != 0 || ((v37->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
          {
            _XMM15 = PositionArrayAtIndex->v;
          }
          else
          {
            v = PositionArrayAtIndex->v;
            _XMM15 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), rotMatrix->x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), rotMatrix->y.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), rotMatrix->z.v), rotMatrix[1].x.v)));
          }
          m_pStateDef = pParticleState->m_pStateDef;
          v41 = (float4 *)((unsigned __int64)LODWORD(m_pStateDef->flags) >> 28);
          if ( (m_pStateDef->flags & 0x10000000) != 0 )
            _XMM15 = _mm128_add_ps(_XMM15, ParticleEmitter::GetSystemOwner(v15)->m_systemTransform.w.v);
          if ( v86 )
          {
            v42 = *(__m128 *)((char *)&PositionArrayAtIndex->v + v70);
            Float4RadianToQuat(v41, &v36->m_moduleGraphLengthData.color);
            v43 = _mm_shuffle_ps(v42, v42, 255).m128_f32[0];
            v44 = _mm_shuffle_ps(v42, v42, 170).m128_f32[0];
            v92 = v42;
            v45 = _mm_shuffle_ps(v42, v42, 85).m128_f32[0];
            v46 = (float)((float)((float)(quat.v[0] * v43) + (float)(quat.v[3] * v42.m128_f32[0])) + (float)(quat.v[1] * v44)) - (float)(quat.v[2] * v45);
            v47 = (float)((float)((float)(v45 * quat.v[3]) - (float)(v44 * quat.v[0])) + (float)(quat.v[1] * v43)) + (float)(quat.v[2] * v42.m128_f32[0]);
            v48 = (float)((float)((float)(v45 * quat.v[0]) + (float)(v44 * quat.v[3])) - (float)(quat.v[1] * v42.m128_f32[0])) + (float)(quat.v[2] * v43);
            v49 = (float)((float)((float)(v43 * quat.v[3]) - (float)(quat.v[0] * v42.m128_f32[0])) - (float)(v45 * quat.v[1])) - (float)(quat.v[2] * v44);
            v90.m128_f32[3] = v49;
            v90.m128_f32[0] = v46;
            v90.m128_f32[1] = v47;
            v90.m128_f32[2] = v48;
          }
          else
          {
            if ( v65 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || v65 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO || v63 && v65 != PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
            {
              v90 = *(__m128 *)((char *)&PositionArrayAtIndex->v + v25);
              LODWORD(v49) = _mm_shuffle_ps(v90, v90, 255).m128_u32[0];
            }
            else
            {
              v49 = v90.m128_f32[3];
            }
            v48 = v90.m128_f32[2];
            v47 = v90.m128_f32[1];
            v46 = v90.m128_f32[0];
          }
          if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)((float)(v46 * v46) + (float)(v47 * v47)) + (float)(v48 * v48)) + (float)(v49 * v49)) - 1.0) & _xmm) >= 0.0040000002 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 698, ASSERT_TYPE_ASSERT, "(Particle_Vec4IsNormalized( outQuat ))", "%s\n\t%g %g %g %g", "Particle_Vec4IsNormalized( outQuat )", v46, v47, v48, v49) )
            __debugbreak();
          _XMM6 = *(__int128 *)((char *)PositionArrayAtIndex + v72);
          _XMM7 = *(__int128 *)((char *)PositionArrayAtIndex + v74);
          if ( !v15->m_pSystemOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 204, ASSERT_TYPE_ASSERT, "(m_pSystemOwner)", (const char *)&queryFormat, "m_pSystemOwner") )
            __debugbreak();
          m_pSystemOwner = v15->m_pSystemOwner;
          if ( m_pSystemOwner->m_systemHandle == PARTICLE_SYSTEM_INVALID_HANDLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlesystem.h", 196, ASSERT_TYPE_ASSERT, "(m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE)", (const char *)&queryFormat, "m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE") )
            __debugbreak();
          LODWORD(v85) = m_pSystemOwner->m_systemHandle;
          DWORD1(v85) = v15->m_emitterIndex;
          DWORD2(v85) = pParticleState->m_stateIndex;
          v53 = *v28;
          *v26 |= 2u;
          HIDWORD(v85) = v53;
          if ( v68 >= 2 )
          {
            LODWORD(v62) = 2;
            LODWORD(v61) = v68;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 419, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v61, v62) )
              __debugbreak();
          }
          v54 = v87;
          v55 = &g_particleDeferredPhysicsCreateListCount[v87];
          if ( ((unsigned __int8)v55 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&g_particleDeferredPhysicsCreateListCount[v87]) )
            __debugbreak();
          v32 = _InterlockedExchangeAdd(v55, 1u);
          if ( v32 >= 0x800 )
          {
            LODWORD(v62) = 2048;
            LODWORD(v61) = v32;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 422, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( PARTICLE_DEFERRED_PHYSICS_LIST_MAX )", "index doesn't index PARTICLE_DEFERRED_PHYSICS_LIST_MAX\n\t%i not in [0, %i)", v61, v62) )
              __debugbreak();
          }
          v56 = v90;
          v15 = v84;
          v57 = v83;
          _RDX = &g_particleDeferredPhysicsCreateList[v54][v32];
          _RDX->pModel = (const XModel *)material;
          _RDX->physicsRefId = 0;
          _RDX->position.v[0] = _XMM15.m128_f32[0];
          __asm
          {
            vextractps dword ptr [rdx+14h], xmm15, 1
            vextractps dword ptr [rdx+18h], xmm15, 2
          }
          _RDX->velocity.v[0] = *(float *)&_XMM6;
          __asm
          {
            vextractps dword ptr [rdx+20h], xmm6, 1
            vextractps dword ptr [rdx+24h], xmm6, 2
          }
          _RDX->angularVelocity.v[0] = *(float *)&_XMM7;
          __asm
          {
            vextractps dword ptr [rdx+2Ch], xmm7, 1
            vextractps dword ptr [rdx+30h], xmm7, 2
          }
          _RDX->quat = (vec4_t)v56;
          v59 = v85;
          _RDX->physicsInstanceID = (FxPhysics *)(p_createListIndex - 2);
          *(p_createListIndex - 2) = -1;
          _RDX->physicsInstanceID->detailInstanceId = -1;
          _RDX->onImpactData = (Particle_OnImpactCBData)v59;
          _RDX->state = PARTICLE_DEFERRED_PHYSICS_PENDING_CREATION;
          _RDX->onImpactCB = v88;
          _RDX->flags = (unsigned int *)(v57 + 4i64 * v64);
          goto LABEL_100;
        }
        v34 = (ParticleSystem *)ParticleEmitter::GetSystemOwner(v15);
        Def = ParticleSystem::GetDef(v34);
        Com_PrintWarning(21, "FX Model %s used by Particle FX %s won't create physics asset because we are close to memory limits\n", material->name, Def->name);
      }
      else
      {
        v30 = (ParticleSystem *)ParticleEmitter::GetSystemOwner(v15);
        v31 = ParticleSystem::GetDef(v30);
        Com_PrintWarning(21, "FX Model %s used by Particle FX %s has no physics asset\n", material->name, v31->name);
      }
      *((_QWORD *)p_createListIndex - 1) = -1i64;
      v32 = -1;
LABEL_100:
      ++PositionArrayAtIndex;
      v24 = v80;
      p_m_linkedAssetList = v89;
      ++v26;
      *p_createListIndex = v32;
      p_createListIndex += 3;
      v60 = v64 + 1 < particleCountEmit;
      v25 = v76;
      ++v64;
      v27 = v78;
    }
    while ( v60 );
  }
}

/*
==============
Particle_GetShapeOffsetAndAngles
==============
*/
void Particle_GetShapeOffsetAndAngles(const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, const float4 *offset, float4 *outShapeOrigin, vec3_t *outAngles, bool useWorldSpace)
{
  const vector4 *EmitterTransform; 
  __m128 v; 
  tmat33_t<vec3_t> axis; 

  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 188, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 189, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( useWorldSpace )
  {
    outShapeOrigin->v = _mm128_add_ps(EmitterTransform->w.v, offset->v);
    *(_QWORD *)outAngles->v = 0i64;
    outAngles->v[2] = 0.0;
  }
  else
  {
    v = offset->v;
    outShapeOrigin->v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), EmitterTransform->x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), EmitterTransform->y.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), EmitterTransform->z.v), EmitterTransform->w.v)));
    _XMM2 = EmitterTransform->x.v;
    LODWORD(axis.m[0].v[0]) = EmitterTransform->x;
    __asm
    {
      vextractps dword ptr [rsp+88h+axis+4], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+8], xmm2, 2
    }
    _XMM2.v = (__m128)EmitterTransform->y;
    LODWORD(axis.m[1].v[0]) = _XMM2.v.m128_i32[0];
    __asm
    {
      vextractps dword ptr [rsp+88h+axis+10h], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+14h], xmm2, 2
    }
    _XMM2.v = (__m128)EmitterTransform->z;
    LODWORD(axis.m[2].v[0]) = _XMM2.v.m128_i32[0];
    __asm
    {
      vextractps dword ptr [rsp+88h+axis+1Ch], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+20h], xmm2, 2
    }
    AxisToAngles(&axis, outAngles);
  }
}

/*
==============
Particle_RandomPointOnSphere
==============
*/
void Particle_RandomPointOnSphere(int seed, float4 *outPos, const float radius, ParticleModuleAxesFlags spawnAxes)
{
  __int64 v4; 
  float v7; 
  float v8; 
  float v9; 
  __int128 v11; 
  float c; 
  float s[3]; 
  __int128 v16; 

  v4 = seed;
  v7 = (float)((float)(radius * fx_randomTable[seed + 10]) * 2.0) - radius;
  if ( (v7 < COERCE_FLOAT(LODWORD(radius) ^ _xmm) || v7 > radius) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v7) )
    __debugbreak();
  v8 = fsqrt((float)(radius * radius) - (float)(v7 * v7));
  FastSinCos(fx_randomTable[v4 + 9] * 6.2831855, s, &c);
  v9 = c * v8;
  *(float *)&v16 = c * v8;
  *((float *)&v16 + 1) = s[0] * v8;
  *((float *)&v16 + 2) = v7;
  if ( (float)(radius * radius) != 0.0 && (float)(COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)((float)(s[0] * v8) * (float)(s[0] * v8)) + (float)(v9 * v9)) + (float)(v7 * v7)) - (float)(radius * radius)) & _xmm) / (float)(radius * radius)) >= 0.0000010000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
    __debugbreak();
  if ( spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL )
  {
    Particle_SpawnShapeConvertPos(spawnAxes, (vec3_t *)&v16);
    v9 = *(float *)&v16;
  }
  HIDWORD(v16) = 0;
  v11 = v16;
  *(float *)&v11 = v9;
  _XMM0 = v11;
  __asm
  {
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm7, 20h ; ' '
  }
  *outPos = (float4)_XMM0.v;
}

/*
==============
Particle_SpawnShapeConvertPos
==============
*/
void Particle_SpawnShapeConvertPos(ParticleModuleAxesFlags spawnAxes, vec3_t *outPos)
{
  if ( spawnAxes == PARTICLE_MODULE_AXES_FLAG_ALL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 54, ASSERT_TYPE_ASSERT, "(spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL)", (const char *)&queryFormat, "spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL") )
    __debugbreak();
  if ( (spawnAxes & 3) != 0 )
  {
    if ( (spawnAxes & 2) != 0 )
    {
      if ( (spawnAxes & 1) == 0 )
        outPos->v[0] = COERCE_FLOAT(LODWORD(outPos->v[0]) & _xmm ^ _xmm);
    }
    else
    {
      outPos->v[0] = COERCE_FLOAT(LODWORD(outPos->v[0]) & _xmm);
    }
  }
  else
  {
    outPos->v[0] = 0.0;
  }
  if ( (spawnAxes & 0xC) != 0 )
  {
    if ( (spawnAxes & 8) != 0 )
    {
      if ( (spawnAxes & 4) == 0 )
        outPos->v[1] = COERCE_FLOAT(LODWORD(outPos->v[1]) & _xmm ^ _xmm);
    }
    else
    {
      outPos->v[1] = COERCE_FLOAT(LODWORD(outPos->v[1]) & _xmm);
    }
  }
  else
  {
    outPos->v[1] = 0.0;
  }
  if ( (spawnAxes & 0x30) != 0 )
  {
    if ( (spawnAxes & 0x20) != 0 )
    {
      if ( (spawnAxes & 0x10) == 0 )
        outPos->v[2] = COERCE_FLOAT(LODWORD(outPos->v[2]) & _xmm ^ _xmm);
    }
    else
    {
      outPos->v[2] = COERCE_FLOAT(LODWORD(outPos->v[2]) & _xmm);
    }
  }
  else
  {
    outPos->v[2] = 0.0;
  }
}

/*
==============
Particle_SpawnShapeDrawCylinder
==============
*/
void Particle_SpawnShapeDrawCylinder(const float4 *offset, const vector4 *axis, const vec4_t *color, const ParticleState *pParticleState, const ParticleModuleInitSpawnShapeCylinder *pModule)
{
  float v9; 
  float radiusMax; 
  float radiusMin; 
  float halfHeight; 
  vec3_t angles; 
  vec3_t start; 
  vec3_t end; 
  tmat33_t<vec3_t> axisa; 

  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1787, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)pModule, pParticleState, &halfHeight, &radiusMin, &radiusMax);
  v9 = halfHeight;
  _XMM2 = 0i64;
  __asm { vinsertps xmm2, xmm2, xmm0, 20h ; ' ' }
  _XMM7 = 0i64;
  __asm { vinsertps xmm7, xmm7, xmm9, 20h ; ' ' }
  _XMM2 = _mm128_add_ps((__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM2, _XMM2, 85), axis->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM2, _XMM2, 170), axis->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM2, _XMM2, 0), axis->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v), offset->v);
  _XMM3 = _mm128_add_ps((__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM7, _XMM7, 85), axis->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM7, _XMM7, 170), axis->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM7, _XMM7, 0), axis->x.v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v), offset->v);
  start.v[0] = _XMM2.m128_f32[0];
  __asm
  {
    vextractps dword ptr [rbp+4Fh+start+4], xmm2, 1
    vextractps dword ptr [rbp+4Fh+start+8], xmm2, 2
  }
  end.v[0] = _XMM3.m128_f32[0];
  __asm
  {
    vextractps dword ptr [rbp+4Fh+end+4], xmm3, 1
    vextractps dword ptr [rbp+4Fh+end+8], xmm3, 2
  }
  if ( halfHeight <= 0.0 )
  {
    _XMM2.v = (__m128)axis->y;
    _XMM1.v = (__m128)axis->x;
    LODWORD(axisa.m[1].v[0]) = _XMM2.v.m128_i32[0];
    __asm
    {
      vextractps dword ptr [rbp+4Fh+axis+10h], xmm2, 1
      vextractps dword ptr [rbp+4Fh+axis+14h], xmm2, 2
    }
    _XMM2.v = (__m128)axis->z;
    LODWORD(axisa.m[2].v[0]) = _XMM2.v.m128_i32[0];
    __asm
    {
      vextractps dword ptr [rbp+4Fh+axis+1Ch], xmm2, 1
      vextractps dword ptr [rbp+4Fh+axis+20h], xmm2, 2
    }
    axisa.m[0].v[0] = _XMM1.v.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbp+4Fh+axis+4], xmm1, 1
      vextractps dword ptr [rbp+4Fh+axis+8], xmm1, 2
    }
    AxisToAngles(&axisa, &angles);
  }
  else
  {
    angles.v[2] = 0.0;
    angles.v[1] = 0.0;
    angles.v[0] = 0.0;
  }
  if ( (pModule->m_spawnFlags & 1) != 0 )
  {
    if ( v9 > 0.0 )
    {
      Particle_DebugCylinder(&start, &end, radiusMax, &angles, color, 1, 0);
      return;
    }
  }
  else
  {
    if ( v9 > 0.0 )
    {
      Particle_DebugCylinder(&start, &end, radiusMin, &angles, color, 1, 0);
      Particle_DebugCylinder(&start, &end, radiusMax, &angles, color, 1, 0);
      return;
    }
    Particle_DebugCircle(&start, radiusMin, &angles, color, 1, 0);
  }
  Particle_DebugCircle(&start, radiusMax, &angles, color, 1, 0);
}

