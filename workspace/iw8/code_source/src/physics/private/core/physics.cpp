/*
==============
Physics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/

void __fastcall Physics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyId, const vec3_t *instancePosition, const vec4_t *instanceOrientationAsQuat, vec3_t *bodyPosition, vec4_t *bodyOrientationAsQuat)
{
  ?Physics_GetRigidBodyTransformAfterWarpInstanceTo@@YAXW4Physics_WorldId@@IIAEBTvec3_t@@AEBTvec4_t@@AEAT2@AEAT3@@Z(worldId, instanceId, bodyId, instancePosition, instanceOrientationAsQuat, bodyPosition, bodyOrientationAsQuat);
}

/*
==============
Physics_DeferredRaycast
==============
*/

void __fastcall Physics_DeferredRaycast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredRaycast@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, start, end, extendedData, data);
}

/*
==============
Physics_RemoveShapeList
==============
*/

void __fastcall Physics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  ?Physics_RemoveShapeList@@YAXPEADI@Z(rawShapeData, rawShapeDataSize);
}

/*
==============
Physics_GetRigidBodyAABB
==============
*/

void __fastcall Physics_GetRigidBodyAABB(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax, bool worldSpace)
{
  ?Physics_GetRigidBodyAABB@@YAXW4Physics_WorldId@@IAEATvec3_t@@1_N@Z(worldId, bodyId, aabbMin, aabbMax, worldSpace);
}

/*
==============
Physics_DeferredQueryPoint
==============
*/

void __fastcall Physics_DeferredQueryPoint(Physics_WorldId worldId, const vec3_t *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredQueryPoint@@YAXW4Physics_WorldId@@AEBTvec3_t@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, point, maxDistance, extendedData, data);
}

/*
==============
Physics_DecodeSubShapeKey
==============
*/

void __fastcall Physics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, unsigned __int16 *shapeInstanceId)
{
  ?Physics_DecodeSubShapeKey@@YAXW4Physics_WorldId@@I_KPEAHPEAG@Z(worldId, instanceId, key, bodyIdx, shapeInstanceId);
}

/*
==============
Physics_SetRigidBodyContents
==============
*/

void __fastcall Physics_SetRigidBodyContents(Physics_WorldId worldId, unsigned int bodyId, int contents, bool forceCacheRebuild)
{
  ?Physics_SetRigidBodyContents@@YAXW4Physics_WorldId@@IH_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
Physics_GetInstantiatiationPenetrationDepthForAsset
==============
*/

double __fastcall Physics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const vec3_t *position, const vec4_t *orientationAsQuat, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  double result; 

  *(float *)&result = ?Physics_GetInstantiatiationPenetrationDepthForAsset@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@AEBTvec3_t@@AEBTvec4_t@@PEAUPhysics_InstantiateShapeOverride@@H@Z(worldId, physicsAsset, position, orientationAsQuat, shapeOverride, ignoreSystems);
  return result;
}

/*
==============
Physics_TransientZoneLoaded
==============
*/

void __fastcall Physics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  ?Physics_TransientZoneLoaded@@YAXI_N@Z(worldTransientIndex, fullLoad);
}

/*
==============
Physics_GetRendererThreadId
==============
*/

unsigned int __fastcall Physics_GetRendererThreadId()
{
  return ?Physics_GetRendererThreadId@@YAIXZ();
}

/*
==============
Physics_AddDeferredKeyframeInstance
==============
*/

void __fastcall Physics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  ?Physics_AddDeferredKeyframeInstance@@YAXW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@@Z(worldId, instanceId, origin, orientationAsQuat);
}

/*
==============
Physics_HasVFXEventAsset
==============
*/

bool __fastcall Physics_HasVFXEventAsset(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_HasVFXEventAsset@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_UpdateVDB
==============
*/

void Physics_UpdateVDB(void)
{
  ?Physics_UpdateVDB@@YAXXZ();
}

/*
==============
Physics_DoDeferredQueries
==============
*/

void __fastcall Physics_DoDeferredQueries(Physics_WorldId worldId)
{
  ?Physics_DoDeferredQueries@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_AddXModelDetailCollisionAsset
==============
*/

void __fastcall Physics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  ?Physics_AddXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
Physics_MoveXModelAsset
==============
*/

void __fastcall Physics_MoveXModelAsset(XModel *from, XModel *to)
{
  ?Physics_MoveXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
Physics_IsQueryWorld
==============
*/

bool __fastcall Physics_IsQueryWorld(Physics_WorldId worldId)
{
  return ?Physics_IsQueryWorld@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_Raycast
==============
*/

void __fastcall Physics_Raycast(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_Raycast@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, start, end, extendedData, result);
}

/*
==============
Physics_StepWorld
==============
*/

void __fastcall Physics_StepWorld(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?Physics_StepWorld@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
Physics_ConvertShapeQueryResultToLegacyTrace
==============
*/

void __fastcall Physics_ConvertShapeQueryResultToLegacyTrace(HavokPhysics_CollisionQueryResult *traceResult, HavokPhysics_CollisionQueryResult *queryResult, trace_t *trace)
{
  ?Physics_ConvertShapeQueryResultToLegacyTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@0PEAUtrace_t@@@Z(traceResult, queryResult, trace);
}

/*
==============
Physics_IsPhysicsAssetBodyDynamic
==============
*/

bool __fastcall Physics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?Physics_IsPhysicsAssetBodyDynamic@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
Physics_IsDebugCodeReadingServer
==============
*/

bool __fastcall Physics_IsDebugCodeReadingServer()
{
  return ?Physics_IsDebugCodeReadingServer@@YA_NXZ();
}

/*
==============
Physics_DrawDebugString
==============
*/

void __fastcall Physics_DrawDebugString(const ScreenPlacement *scrPlace, float x, float y, const char *string, const vec4_t *setColor, int forceColor, int shadow, float charHeight, int adjust)
{
  ?Physics_DrawDebugString@@YAXPEBUScreenPlacement@@MMPEBDAEBTvec4_t@@HHMH@Z(scrPlace, x, y, string, setColor, forceColor, shadow, charHeight, adjust);
}

/*
==============
Physics_DrawDebug
==============
*/

void __fastcall Physics_DrawDebug(const ScreenPlacement *scrPlace)
{
  ?Physics_DrawDebug@@YAXPEBUScreenPlacement@@@Z(scrPlace);
}

/*
==============
Physics_RenderDebugEnabled
==============
*/

bool __fastcall Physics_RenderDebugEnabled()
{
  return ?Physics_RenderDebugEnabled@@YA_NXZ();
}

/*
==============
Physics_DoCmd_StepWorldEnd
==============
*/

void __fastcall Physics_DoCmd_StepWorldEnd(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldEnd@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_ReleaseShape
==============
*/

void __fastcall Physics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  ?Physics_ReleaseShape@@YAXW4Physics_WorldId@@PEAVhknpShape@@_N@Z(worldId, shape, finalReference);
}

/*
==============
Physics_SetInstanceContents
==============
*/

void __fastcall Physics_SetInstanceContents(Physics_WorldId worldId, unsigned int instanceId, int contents)
{
  ?Physics_SetInstanceContents@@YAXW4Physics_WorldId@@IH@Z(worldId, instanceId, contents);
}

/*
==============
Physics_SwapXModelDetailCollisionAsset
==============
*/

void __fastcall Physics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?Physics_SwapXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
Physics_IsRigidBodyStatic
==============
*/

bool __fastcall Physics_IsRigidBodyStatic(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_IsRigidBodyStatic@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_SetThreadHeapAllocationGeneral
==============
*/

void __fastcall Physics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  ?Physics_SetThreadHeapAllocationGeneral@@YAXI@Z(threadId);
}

/*
==============
Physics_CreateDevGui
==============
*/

void __fastcall Physics_CreateDevGui(LocalClientNum_t localClientNum)
{
  ?Physics_CreateDevGui@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Physics_DestroyClientWorlds
==============
*/

void Physics_DestroyClientWorlds(void)
{
  ?Physics_DestroyClientWorlds@@YAXXZ();
}

/*
==============
Physics_ProcessDeferredForce
==============
*/

void __fastcall Physics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  ?Physics_ProcessDeferredForce@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_SetCGDynEntAuthoritativeDebugData
==============
*/

void __fastcall Physics_SetCGDynEntAuthoritativeDebugData(LocalClientNum_t localClientNum, int dynEntCount, int dynEntSimpleCount, int dynEntSimpleAdditionalBoneCount, int dynEntComplexCount, int dynEntComplexBodyCount, int dynEntComplexAdditionalBoneCount)
{
  ?Physics_SetCGDynEntAuthoritativeDebugData@@YAXW4LocalClientNum_t@@HHHHHH@Z(localClientNum, dynEntCount, dynEntSimpleCount, dynEntSimpleAdditionalBoneCount, dynEntComplexCount, dynEntComplexBodyCount, dynEntComplexAdditionalBoneCount);
}

/*
==============
Physics_CreateShapeCapsuleUpAxis
==============
*/

hknpShape *__fastcall Physics_CreateShapeCapsuleUpAxis(Physics_WorldId worldId, const vec3_t *center, float halfHeight, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?Physics_CreateShapeCapsuleUpAxis@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBTvec3_t@@MMPEADHW4Physics_ShapeStorage@@@Z(worldId, center, halfHeight, radius, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
Physics_SetCGFXOldDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGFXOldDetailPropagationDebugData(LocalClientNum_t localClientNum, int numOldElems, int numOldElemsWithPhysics)
{
  ?Physics_SetCGFXOldDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numOldElems, numOldElemsWithPhysics);
}

/*
==============
Physics_InstantiateHingeConstraint
==============
*/

bool __fastcall Physics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, const vec3_t *position, const vec3_t *direction, float friction, float angleMin, float angleMax, float breakingThreshold, unsigned int *outConstraintId)
{
  return ?Physics_InstantiateHingeConstraint@@YA_NW4Physics_WorldId@@IIAEBTvec3_t@@1MMMMPEAI@Z(worldId, instanceId, bodyIdx, position, direction, friction, angleMin, angleMax, breakingThreshold, outConstraintId);
}

/*
==============
Physics_IsAssetBodyAnimationDriven
==============
*/

bool __fastcall Physics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?Physics_IsAssetBodyAnimationDriven@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
Physics_ReleasePhysicsAsset
==============
*/

void __fastcall Physics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  ?Physics_ReleasePhysicsAsset@@YAXPEAUPhysicsAsset@@_N@Z(physicsAsset, unloadPackFileData);
}

/*
==============
Physics_SetCGPhysicsObjectAuthoritativeDebugData
==============
*/

void __fastcall Physics_SetCGPhysicsObjectAuthoritativeDebugData(LocalClientNum_t localClientNum, int physicsObjectDynamicBoneMappingHavingCount, int physicsObjectDynamicBoneMappingCount)
{
  ?Physics_SetCGPhysicsObjectAuthoritativeDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, physicsObjectDynamicBoneMappingHavingCount, physicsObjectDynamicBoneMappingCount);
}

/*
==============
Physics_ProcessDeferredKeyframe
==============
*/

void __fastcall Physics_ProcessDeferredKeyframe(const Physics_WorldId worldId, const float velocityScale)
{
  ?Physics_ProcessDeferredKeyframe@@YAXW4Physics_WorldId@@M@Z(worldId, velocityScale);
}

/*
==============
Physics_SetCGFXSystemsDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGFXSystemsDetailPropagationDebugData(LocalClientNum_t localClientNum, int numSystems, int numPhysicsSystems)
{
  ?Physics_SetCGFXSystemsDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numSystems, numPhysicsSystems);
}

/*
==============
Physics_ReleaseMapLocalAllocatorBuffer
==============
*/

void Physics_ReleaseMapLocalAllocatorBuffer(void)
{
  ?Physics_ReleaseMapLocalAllocatorBuffer@@YAXXZ();
}

/*
==============
Physics_GetRigidBodyMaxLinSpeed
==============
*/

void __fastcall Physics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxLinSpeed)
{
  ?Physics_GetRigidBodyMaxLinSpeed@@YAXW4Physics_WorldId@@IPEAM@Z(worldId, bodyId, maxLinSpeed);
}

/*
==============
Physics_GetInstanceXModel
==============
*/

const XModel *__fastcall Physics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?Physics_GetInstanceXModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
Physics_UpdateLoosenedConstraint
==============
*/

bool __fastcall Physics_UpdateLoosenedConstraint(Physics_WorldId worldId, unsigned int constraintId, const vec4_t *bodyAOrientation, const vec3_t *bodyAPosition, const vec4_t *bodyBOrientation, const vec3_t *bodyBPosition, PhysicsConstraintLooseningResult *result)
{
  return ?Physics_UpdateLoosenedConstraint@@YA_NW4Physics_WorldId@@IAEBTvec4_t@@AEBTvec3_t@@12PEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, bodyAOrientation, bodyAPosition, bodyBOrientation, bodyBPosition, result);
}

/*
==============
Physics_AddPhysicsAsset
==============
*/

void __fastcall Physics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  ?Physics_AddPhysicsAsset@@YAXPEAUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_RenderDebug
==============
*/

void __fastcall Physics_RenderDebug(GfxCmdBufContext *gfxContext)
{
  ?Physics_RenderDebug@@YAXUGfxCmdBufContext@@@Z(gfxContext);
}

/*
==============
Physics_GetSFXEventAsset
==============
*/

int __fastcall Physics_GetSFXEventAsset(Physics_WorldId worldId, unsigned int bodyId0, unsigned int bodyId1, PhysicsSFXEventAsset **asset)
{
  return ?Physics_GetSFXEventAsset@@YAHW4Physics_WorldId@@IIPEAPEAUPhysicsSFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
Physics_GetEntityNum
==============
*/

int __fastcall Physics_GetEntityNum(int ref)
{
  return ?Physics_GetEntityNum@@YAHH@Z(ref);
}

/*
==============
Physics_GetHitTypeByEntId
==============
*/

TraceHitType __fastcall Physics_GetHitTypeByEntId(const unsigned int entId)
{
  return ?Physics_GetHitTypeByEntId@@YA?AW4TraceHitType@@I@Z(entId);
}

/*
==============
Physics_DeferredShapecast
==============
*/

void __fastcall Physics_DeferredShapecast(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredShapecast@@YAXW4Physics_WorldId@@IPEAVhknpShape@@AEBTvec3_t@@2AEBTvec4_t@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, start, end, rotation, extendedData, data);
}

/*
==============
Physics_UnlockWorld
==============
*/

void __fastcall Physics_UnlockWorld(Physics_WorldId worldId)
{
  ?Physics_UnlockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_WarpDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall Physics_WarpDetailRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphase, bool activate)
{
  return ?Physics_WarpDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@_N3@Z(worldId, bodyId, position, orientationAsQuat, updateBroadphase, activate);
}

/*
==============
Physics_DoCmd_UpdatePredictiveWorldPre
==============
*/

void __fastcall Physics_DoCmd_UpdatePredictiveWorldPre(const void *const cmdInfo)
{
  ?Physics_DoCmd_UpdatePredictiveWorldPre@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_InstantiateAssetBodySphere
==============
*/

bool __fastcall Physics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?Physics_InstantiateAssetBodySphere@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBTvec3_t@@AEBTvec4_t@@_N44MW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientationAsQuat, add, tryStartDeactivated, neverDeactivate, radius, forceType, filterType, forQueryOnly);
}

/*
==============
Physics_FlushMovedStatics
==============
*/

void __fastcall Physics_FlushMovedStatics(Physics_WorldId worldId)
{
  ?Physics_FlushMovedStatics@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_SetWorkerError
==============
*/

void Physics_SetWorkerError(void)
{
  ?Physics_SetWorkerError@@YAXXZ();
}

/*
==============
Physics_GetNumConvexCountsInShapeList
==============
*/

int __fastcall Physics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumConvexCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_IsClientEntitylessScriptable
==============
*/

bool __fastcall Physics_IsClientEntitylessScriptable(const int ref)
{
  return ?Physics_IsClientEntitylessScriptable@@YA_NH@Z(ref);
}

/*
==============
Physics_SetNoQueriesAllowed
==============
*/

void __fastcall Physics_SetNoQueriesAllowed(Physics_WorldId worldId, bool noQueriesAllowed)
{
  ?Physics_SetNoQueriesAllowed@@YAXW4Physics_WorldId@@_N@Z(worldId, noQueriesAllowed);
}

/*
==============
Physics_KeyframeRigidBodyToFast
==============
*/

Physics_MovementType __fastcall Physics_KeyframeRigidBodyToFast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?Physics_KeyframeRigidBodyToFast@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@M_N3M@Z(worldId, bodyId, position, orientationAsQuat, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
Physics_CalcRigidBodyShapeAABBWorld
==============
*/

void __fastcall Physics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax)
{
  ?Physics_CalcRigidBodyShapeAABBWorld@@YAXW4Physics_WorldId@@IAEATvec3_t@@1@Z(worldId, bodyId, aabbMin, aabbMax);
}

/*
==============
Physics_IsShapeCacheDisabled
==============
*/

bool __fastcall Physics_IsShapeCacheDisabled(unsigned int threadId)
{
  return ?Physics_IsShapeCacheDisabled@@YA_NI@Z(threadId);
}

/*
==============
Physics_TightenConstraint
==============
*/

void __fastcall Physics_TightenConstraint(Physics_WorldId worldId, unsigned int constraintId, PhysicsConstraintLooseningResult *values, float proportion)
{
  ?Physics_TightenConstraint@@YAXW4Physics_WorldId@@IPEAUPhysicsConstraintLooseningResult@@M@Z(worldId, constraintId, values, proportion);
}

/*
==============
Physics_GetWorkerThreadId
==============
*/

unsigned int __fastcall Physics_GetWorkerThreadId(unsigned int index)
{
  return ?Physics_GetWorkerThreadId@@YAII@Z(index);
}

/*
==============
Physics_DoCmd_StepWorldStart
==============
*/

void __fastcall Physics_DoCmd_StepWorldStart(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldStart@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_DeferredQueryPoint
==============
*/

void __fastcall Physics_DeferredQueryPoint(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredQueryPoint@@YAXW4Physics_WorldId@@IAEBTvec3_t@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, point, maxDistance, extendedData, data);
}

/*
==============
Physics_SetCGPhysicsObjectPropagatedDebugData
==============
*/

void __fastcall Physics_SetCGPhysicsObjectPropagatedDebugData(LocalClientNum_t localClientNum, int numPropagatedPhysicsObjects, int numPropagatedBodies)
{
  ?Physics_SetCGPhysicsObjectPropagatedDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numPropagatedPhysicsObjects, numPropagatedBodies);
}

/*
==============
Physics_ApplyBulletForceBody
==============
*/

void __fastcall Physics_ApplyBulletForceBody(const Physics_WorldId worldId, const unsigned int bodyId, const vec3_t *position, const vec3_t *direction, const unsigned int inflictorEntNum, const bool isMelee)
{
  ?Physics_ApplyBulletForceBody@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1I_N@Z(worldId, bodyId, position, direction, inflictorEntNum, isMelee);
}

/*
==============
Physics_ProcessDeferredForceCallbacks
==============
*/

void __fastcall Physics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  ?Physics_ProcessDeferredForceCallbacks@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_ReleaseXModelAsset
==============
*/

void __fastcall Physics_ReleaseXModelAsset(XModel *xmodel)
{
  ?Physics_ReleaseXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
Physics_AddRigidBodyContents
==============
*/

void __fastcall Physics_AddRigidBodyContents(Physics_WorldId worldId, unsigned int bodyId, int contents, bool forceCacheRebuild)
{
  ?Physics_AddRigidBodyContents@@YAXW4Physics_WorldId@@IH_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
Physics_GetErrorString
==============
*/

const char *__fastcall Physics_GetErrorString()
{
  return ?Physics_GetErrorString@@YAPEBDXZ();
}

/*
==============
Physics_GetDetailCollisionShape
==============
*/

const hknpShape *__fastcall Physics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?Physics_GetDetailCollisionShape@@YAPEBVhknpShape@@PEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
Physics_CreateShapeCompound
==============
*/

hknpShape *__fastcall Physics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?Physics_CreateShapeCompound@@YAPEAVhknpShape@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(instanceArray);
}

/*
==============
Physics_MovePhysicsVFXEventAsset
==============
*/

void __fastcall Physics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?Physics_MovePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_InstantiateAssetConstraint
==============
*/

bool __fastcall Physics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  return ?Physics_InstantiateAssetConstraint@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HH_N@Z(instanceId, worldId, physicsAsset, constraintIdx, instanceRef, deepCloneConstraintData);
}

/*
==============
Physics_MovePhysicsSFXEventAsset
==============
*/

void __fastcall Physics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?Physics_MovePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_ToggleCGDynEntAuthoritativeDebugData
==============
*/

void __fastcall Physics_ToggleCGDynEntAuthoritativeDebugData(LocalClientNum_t localClientNum)
{
  ?Physics_ToggleCGDynEntAuthoritativeDebugData@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Physics_SwapPhysicsSFXEventAsset
==============
*/

void __fastcall Physics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?Physics_SwapPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_SwapXModelAsset
==============
*/

void __fastcall Physics_SwapXModelAsset(XModel *from, XModel *to)
{
  ?Physics_SwapXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
Physics_GetRigidBodyAABB
==============
*/

void __fastcall Physics_GetRigidBodyAABB(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax)
{
  ?Physics_GetRigidBodyAABB@@YAXW4Physics_WorldId@@IAEATvec3_t@@1@Z(worldId, bodyId, aabbMin, aabbMax);
}

/*
==============
Physics_SetMassPropertiesMass
==============
*/

void __fastcall Physics_SetMassPropertiesMass(hkMassProperties *massProperties, float mass)
{
  ?Physics_SetMassPropertiesMass@@YAXPEAUhkMassProperties@@M@Z(massProperties, mass);
}

/*
==============
Physics_IsServerEntitylessScriptable
==============
*/

bool __fastcall Physics_IsServerEntitylessScriptable(const int ref)
{
  return ?Physics_IsServerEntitylessScriptable@@YA_NH@Z(ref);
}

/*
==============
Physics_GetWorldName
==============
*/

const char *__fastcall Physics_GetWorldName(Physics_WorldId worldId)
{
  return ?Physics_GetWorldName@@YAPEBDW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_GetInstanceDetailModel
==============
*/

const XModel *__fastcall Physics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?Physics_GetInstanceDetailModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
Physics_AddClipMap
==============
*/

void __fastcall Physics_AddClipMap(clipMap_t *clipMap)
{
  ?Physics_AddClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
Physics_AreDetailModelsInterchangeable
==============
*/

bool __fastcall Physics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  return ?Physics_AreDetailModelsInterchangeable@@YA_NQEBUXModel@@0@Z(detailModelA, detailModelB);
}

/*
==============
Physics_CreateShapeCapsule
==============
*/

hknpShape *__fastcall Physics_CreateShapeCapsule(Physics_WorldId worldId, const vec3_t *center, float halfHeight, float radius, const vec3_t *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?Physics_CreateShapeCapsule@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBTvec3_t@@MM1PEADHW4Physics_ShapeStorage@@@Z(worldId, center, halfHeight, radius, majorAxis, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
Physics_ApplyAngularImpulse
==============
*/

void __fastcall Physics_ApplyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec3_t *normalizedDirection, float magnitude)
{
  ?Physics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1M@Z(worldId, bodyId, position, normalizedDirection, magnitude);
}

/*
==============
Physics_SetCGFXEmittersDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGFXEmittersDetailPropagationDebugData(LocalClientNum_t localClientNum, int numEmitters, int numPhysicsEmitters)
{
  ?Physics_SetCGFXEmittersDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numEmitters, numPhysicsEmitters);
}

/*
==============
Physics_IsInitialized
==============
*/

bool __fastcall Physics_IsInitialized()
{
  return ?Physics_IsInitialized@@YA_NXZ();
}

/*
==============
Physics_IsInstanceDeactivated
==============
*/

bool __fastcall Physics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?Physics_IsInstanceDeactivated@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
Physics_ConvertClosestPointsToLegacyTrace
==============
*/

void __fastcall Physics_ConvertClosestPointsToLegacyTrace(HavokPhysics_CollisionQueryResult *queryResult, trace_t *trace)
{
  ?Physics_ConvertClosestPointsToLegacyTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@PEAUtrace_t@@@Z(queryResult, trace);
}

/*
==============
Physics_DeactivateBody
==============
*/

void __fastcall Physics_DeactivateBody(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_DeactivateBody@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetFilterSubGroupIdNoCollideIdFromUserData
==============
*/

char __fastcall Physics_GetFilterSubGroupIdNoCollideIdFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetFilterSubGroupIdNoCollideIdFromUserData@@YAD_K@Z(userData);
}

/*
==============
Physics_AddDeferredRadiusForce
==============
*/

void __fastcall Physics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, const float radius, const float innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  ?Physics_AddDeferredRadiusForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@MMMM1HM@Z(worldId, position, radius, innerDamage, outerDamage, impulseOverride, impulseVecOverride, randSeed, forceScalar);
}

/*
==============
Physics_GetLocalClientForWorld
==============
*/

LocalClientNum_t __fastcall Physics_GetLocalClientForWorld(Physics_WorldId worldId)
{
  return ?Physics_GetLocalClientForWorld@@YA?AW4LocalClientNum_t@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_GetRigidBodyContents
==============
*/

int __fastcall Physics_GetRigidBodyContents(const Physics_WorldId worldId, const unsigned int instanceId, const unsigned int bodyIdx)
{
  return ?Physics_GetRigidBodyContents@@YAHW4Physics_WorldId@@II@Z(worldId, instanceId, bodyIdx);
}

/*
==============
Physics_GetVFXEventAsset
==============
*/

int __fastcall Physics_GetVFXEventAsset(Physics_WorldId worldId, unsigned int bodyId0, unsigned int bodyId1, PhysicsVFXEventAsset **asset)
{
  return ?Physics_GetVFXEventAsset@@YAHW4Physics_WorldId@@IIPEAPEAUPhysicsVFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
Physics_OnThreadInit
==============
*/

void __fastcall Physics_OnThreadInit(unsigned int threadId)
{
  ?Physics_OnThreadInit@@YAXI@Z(threadId);
}

/*
==============
Physics_SetCGCharacterProxyPredictiveDebugData
==============
*/

void __fastcall Physics_SetCGCharacterProxyPredictiveDebugData(LocalClientNum_t localClientNum, int numCharacterProxies)
{
  ?Physics_SetCGCharacterProxyPredictiveDebugData@@YAXW4LocalClientNum_t@@H@Z(localClientNum, numCharacterProxies);
}

/*
==============
Physics_SetMassPropertiesCenterOfMass
==============
*/

void __fastcall Physics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, const vec3_t *centerOfMass)
{
  ?Physics_SetMassPropertiesCenterOfMass@@YAXPEAUhkMassProperties@@AEBTvec3_t@@@Z(massProperties, centerOfMass);
}

/*
==============
Physics_FreeIgnoreBodies
==============
*/

void __fastcall Physics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  ?Physics_FreeIgnoreBodies@@YAXPEAVHavokPhysics_IgnoreBodies@@@Z(ignoreBodies);
}

/*
==============
Physics_AABBQuery
==============
*/

void __fastcall Physics_AABBQuery(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_AABBQuery@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, min, max, extendedData, result);
}

/*
==============
Physics_DoGarbageCollectionClient
==============
*/

void Physics_DoGarbageCollectionClient(void)
{
  ?Physics_DoGarbageCollectionClient@@YAXXZ();
}

/*
==============
Physics_Write
==============
*/

void __fastcall Physics_Write(MemoryFile *memFile)
{
  ?Physics_Write@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
Physics_GetConstraintBodyIds
==============
*/

void __fastcall Physics_GetConstraintBodyIds(Physics_WorldId worldId, unsigned int constraintId, unsigned int *bodyIdA, unsigned int *bodyIdB)
{
  ?Physics_GetConstraintBodyIds@@YAXW4Physics_WorldId@@IPEAI1@Z(worldId, constraintId, bodyIdA, bodyIdB);
}

/*
==============
Physics_AddShapeReference
==============
*/

void __fastcall Physics_AddShapeReference(hknpShape *shape)
{
  ?Physics_AddShapeReference@@YAXPEAVhknpShape@@@Z(shape);
}

/*
==============
Physics_AddPhysicsSFXEventAsset
==============
*/

void __fastcall Physics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?Physics_AddPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
Physics_IsInBroadphase
==============
*/

bool __fastcall Physics_IsInBroadphase(Physics_WorldId worldId, const vec3_t *position)
{
  return ?Physics_IsInBroadphase@@YA_NW4Physics_WorldId@@AEBTvec3_t@@@Z(worldId, position);
}

/*
==============
Physics_LoosenConstraint
==============
*/

bool __fastcall Physics_LoosenConstraint(Physics_WorldId worldId, unsigned int constraintId, PhysicsConstraintLooseningResult *result)
{
  return ?Physics_LoosenConstraint@@YA_NW4Physics_WorldId@@IPEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, result);
}

/*
==============
Physics_AddRigidBodyContents
==============
*/

void __fastcall Physics_AddRigidBodyContents(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, int contents, bool forceCacheRebuild)
{
  ?Physics_AddRigidBodyContents@@YAXW4Physics_WorldId@@IIH_N@Z(worldId, instanceId, bodyIdx, contents, forceCacheRebuild);
}

/*
==============
Physics_CopyXModelAsset
==============
*/

void __fastcall Physics_CopyXModelAsset(XModel *from, XModel *to)
{
  ?Physics_CopyXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
Physics_SetRigidBodyStatic
==============
*/

void __fastcall Physics_SetRigidBodyStatic(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_SetRigidBodyStatic@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_RemoveInstanceFromWorld
==============
*/

void __fastcall Physics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?Physics_RemoveInstanceFromWorld@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
Physics_GetRelationshipSystem
==============
*/

Physics_RelationshipSystem __fastcall Physics_GetRelationshipSystem(int ref)
{
  return ?Physics_GetRelationshipSystem@@YA?AW4Physics_RelationshipSystem@@H@Z(ref);
}

/*
==============
Physics_DoCmd_StepWorldPhysicsObjects
==============
*/

void __fastcall Physics_DoCmd_StepWorldPhysicsObjects(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldPhysicsObjects@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_GetRefSystem
==============
*/

Physics_RefSystem __fastcall Physics_GetRefSystem(int ref)
{
  return ?Physics_GetRefSystem@@YA?AW4Physics_RefSystem@@H@Z(ref);
}

/*
==============
Physics_RemoveClipMap
==============
*/

void __fastcall Physics_RemoveClipMap(clipMap_t *clipMap)
{
  ?Physics_RemoveClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
Physics_SetRigidBodyVelocity
==============
*/

void __fastcall Physics_SetRigidBodyVelocity(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *linearVelocity, const vec3_t *angularVelocity)
{
  ?Physics_SetRigidBodyVelocity@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1@Z(worldId, bodyId, linearVelocity, angularVelocity);
}

/*
==============
Physics_FreeCollisionQueryResult
==============
*/

void __fastcall Physics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_FreeCollisionQueryResult@@YAXPEAVHavokPhysics_CollisionQueryResult@@@Z(result);
}

/*
==============
Physics_CreateShapeConvexHull
==============
*/

hknpShape *__fastcall Physics_CreateShapeConvexHull(const vec3_t *verts, unsigned int numVertices, unsigned int maxNumGeneratedVertices, bool useCache)
{
  return ?Physics_CreateShapeConvexHull@@YAPEAVhknpShape@@PEBTvec3_t@@II_N@Z(verts, numVertices, maxNumGeneratedVertices, useCache);
}

/*
==============
Physics_GetDetailCollisionShapeTag
==============
*/

unsigned __int16 __fastcall Physics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?Physics_GetDetailCollisionShapeTag@@YAGPEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
Physics_IsRigidBodyValid
==============
*/

bool __fastcall Physics_IsRigidBodyValid(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_IsRigidBodyValid@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetShapeFromShapeList
==============
*/

hknpShape *__fastcall Physics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetShapeFromShapeList@@YAPEAVhknpShape@@PEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_SwapPhysicsAsset
==============
*/

void __fastcall Physics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?Physics_SwapPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
Physics_SetMainShapeList
==============
*/

void __fastcall Physics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  ?Physics_SetMainShapeList@@YAXPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_ReleasePhysicsLibrary
==============
*/

void __fastcall Physics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?Physics_ReleasePhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
Physics_GetRigidBodyDefaultMass
==============
*/

double __fastcall Physics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  double result; 

  *(float *)&result = ?Physics_GetRigidBodyDefaultMass@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@@Z(worldId, physAsset);
  return result;
}

/*
==============
Physics_AABBQuery
==============
*/

void __fastcall Physics_AABBQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_AABBQuery@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, min, max, extendedData, result);
}

/*
==============
Physics_DeferredGetClosestPoints
==============
*/

void __fastcall Physics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBTvec3_t@@AEBTvec4_t@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
Physics_IsRigidBodyDynamic
==============
*/

bool __fastcall Physics_IsRigidBodyDynamic(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_IsRigidBodyDynamic@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_DestroyConstraint
==============
*/

void __fastcall Physics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  ?Physics_DestroyConstraint@@YAXW4Physics_WorldId@@IH_N@Z(worldId, instanceId, constraintIdx, activate);
}

/*
==============
Physics_GetRigidBodyMaxAngSpeed
==============
*/

void __fastcall Physics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxAngSpeed)
{
  ?Physics_GetRigidBodyMaxAngSpeed@@YAXW4Physics_WorldId@@IPEAM@Z(worldId, bodyId, maxAngSpeed);
}

/*
==============
Physics_DirtyBroadphase
==============
*/

void __fastcall Physics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  ?Physics_DirtyBroadphase@@YAXW4Physics_WorldId@@PEBV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@@Z(worldId, array);
}

/*
==============
Physics_GetPhysicsAssetBodyTransform
==============
*/

void __fastcall Physics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, vec3_t *bodyPosition, vec4_t *bodyOrientationAsQuat)
{
  ?Physics_GetPhysicsAssetBodyTransform@@YAXPEBUPhysicsAsset@@HAEATvec3_t@@AEATvec4_t@@@Z(physicsAsset, bodyIdx, bodyPosition, bodyOrientationAsQuat);
}

/*
==============
Physics_SetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall Physics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, unsigned int bodyId, const vec4_t *invInertia)
{
  ?Physics_SetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@IAEBTvec4_t@@@Z(worldId, bodyId, invInertia);
}

/*
==============
Physics_AntilagWarpInstanceTo
==============
*/

bool __fastcall Physics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, vec3_t *restorePosition, vec4_t *restoreOrientationAsQuat)
{
  return ?Physics_AntilagWarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@AEAT2@AEAT3@@Z(worldId, instanceId, position, orientationAsQuat, restorePosition, restoreOrientationAsQuat);
}

/*
==============
Physics_MyChangesInitAndLoad
==============
*/

void Physics_MyChangesInitAndLoad(void)
{
  ?Physics_MyChangesInitAndLoad@@YAXXZ();
}

/*
==============
Physics_InstantiateStaticBody
==============
*/

unsigned int __fastcall Physics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int contents, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?Physics_InstantiateStaticBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBTvec3_t@@AEBTvec4_t@@_N55@Z(worldId, shape, ref, name, physicsMaterial, contents, position, orientationAsQuat, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
Physics_Shapecast
==============
*/

void __fastcall Physics_Shapecast(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?Physics_Shapecast@@YAXW4Physics_WorldId@@IPEAVhknpShape@@AEBTvec3_t@@2AEBTvec4_t@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@5@Z(worldId, bodyId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
Physics_DoCmd_StepWorldPrep
==============
*/

void __fastcall Physics_DoCmd_StepWorldPrep(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldPrep@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_ReleaseXModelDetailCollisionAsset
==============
*/

void __fastcall Physics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  ?Physics_ReleaseXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@_N@Z(detailCollision, unloadPackFileData);
}

/*
==============
Physics_GetIsClutterFromUserData
==============
*/

bool __fastcall Physics_GetIsClutterFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetIsClutterFromUserData@@YA_N_K@Z(userData);
}

/*
==============
Physics_GetContentsFromShapeList
==============
*/

int __fastcall Physics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetContentsFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_GetNumTriCountsInShapeList
==============
*/

int __fastcall Physics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumTriCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_QueryPoint
==============
*/

void __fastcall Physics_QueryPoint(Physics_WorldId worldId, const vec3_t *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_QueryPoint@@YAXW4Physics_WorldId@@AEBTvec3_t@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, point, maxDistance, extendedData, result);
}

/*
==============
Physics_ApplyBulletForceInstance
==============
*/

void __fastcall Physics_ApplyBulletForceInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *position, const vec3_t *direction, const unsigned int inflictorEntNum, const bool isMelee)
{
  ?Physics_ApplyBulletForceInstance@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1I_N@Z(worldId, instanceId, position, direction, inflictorEntNum, isMelee);
}

/*
==============
Physics_IsRigidBodyActive
==============
*/

bool __fastcall Physics_IsRigidBodyActive(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_IsRigidBodyActive@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetRefEntityType
==============
*/

__int16 __fastcall Physics_GetRefEntityType(Physics_WorldId worldId, Physics_RefSystem refSystem, int ref)
{
  return ?Physics_GetRefEntityType@@YAFW4Physics_WorldId@@W4Physics_RefSystem@@H@Z(worldId, refSystem, ref);
}

/*
==============
Physics_GetRefId
==============
*/

unsigned __int16 __fastcall Physics_GetRefId(int ref)
{
  return ?Physics_GetRefId@@YAGH@Z(ref);
}

/*
==============
Physics_GetMainThreadId
==============
*/

unsigned int __fastcall Physics_GetMainThreadId()
{
  return ?Physics_GetMainThreadId@@YAIXZ();
}

/*
==============
Physics_GetSaveGameSecondarySaveStateThreadId
==============
*/

unsigned int __fastcall Physics_GetSaveGameSecondarySaveStateThreadId()
{
  return ?Physics_GetSaveGameSecondarySaveStateThreadId@@YAIXZ();
}

/*
==============
Physics_AccumulateAngularImpulse
==============
*/

void __fastcall Physics_AccumulateAngularImpulse(const vec3_t *impulseWs, const vec3_t *atPointWs, const vec3_t *comWs, const tmat33_t<vec3_t> *invInertiaWs, vec3_t *outAngularVelWs)
{
  ?Physics_AccumulateAngularImpulse@@YAXAEBTvec3_t@@00AEBT?$tmat33_t@Tvec3_t@@@@AEAT1@@Z(impulseWs, atPointWs, comWs, invInertiaWs, outAngularVelWs);
}

/*
==============
Physics_GetRigidBodyCenterOfMass
==============
*/

void __fastcall Physics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, unsigned int bodyId, vec3_t *centerOfMass)
{
  ?Physics_GetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@IAEATvec3_t@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
Physics_AddXModelAsset
==============
*/

void __fastcall Physics_AddXModelAsset(XModel *xmodel)
{
  ?Physics_AddXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
Physics_GetDetailCollisionShapeTransform
==============
*/

void __fastcall Physics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, vec3_t *shapePosition, vec4_t *shapeOrientationAsQuat)
{
  ?Physics_GetDetailCollisionShapeTransform@@YAXPEBUXModelDetailCollision@@HAEATvec3_t@@AEATvec4_t@@@Z(detailCollision, shapeIdx, shapePosition, shapeOrientationAsQuat);
}

/*
==============
Physics_ApplyImpulse
==============
*/

void __fastcall Physics_ApplyImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec3_t *normalizedDirection, float magnitude)
{
  ?Physics_ApplyImpulse@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1M@Z(worldId, bodyId, position, normalizedDirection, magnitude);
}

/*
==============
Physics_GetNumShapesInShapeList
==============
*/

int __fastcall Physics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumShapesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_AddDetailTrace
==============
*/

void __fastcall Physics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  ?Physics_AddDetailTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@PEAE@Z(result, detailPriorityMap);
}

/*
==============
Physics_GetBrushBasisFromUserData
==============
*/

bool __fastcall Physics_GetBrushBasisFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetBrushBasisFromUserData@@YA_N_K@Z(userData);
}

/*
==============
Physics_GetDebugMemorySize
==============
*/

unsigned __int64 __fastcall Physics_GetDebugMemorySize()
{
  return ?Physics_GetDebugMemorySize@@YA_KXZ();
}

/*
==============
Physics_GetDBThreadId
==============
*/

unsigned int __fastcall Physics_GetDBThreadId()
{
  return ?Physics_GetDBThreadId@@YAIXZ();
}

/*
==============
Physics_SetCGPhysicsObjectDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGPhysicsObjectDetailPropagationDebugData(LocalClientNum_t localClientNum, int detailBoundedCount, int duplicationCount, int duplicationBodyCount)
{
  ?Physics_SetCGPhysicsObjectDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HHH@Z(localClientNum, detailBoundedCount, duplicationCount, duplicationBodyCount);
}

/*
==============
Physics_DoCmd_UpdatePredictiveWorld
==============
*/

void __fastcall Physics_DoCmd_UpdatePredictiveWorld(const void *const cmdInfo)
{
  ?Physics_DoCmd_UpdatePredictiveWorld@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_AreClientWorldsCreated
==============
*/

bool __fastcall Physics_AreClientWorldsCreated()
{
  return ?Physics_AreClientWorldsCreated@@YA_NXZ();
}

/*
==============
Physics_GetNumContentsInShapeList
==============
*/

int __fastcall Physics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumContentsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_CreateShapeConvexHullFromAABB
==============
*/

hknpShape *__fastcall Physics_CreateShapeConvexHullFromAABB(const vec3_t *mins, const vec3_t *maxs)
{
  return ?Physics_CreateShapeConvexHullFromAABB@@YAPEAVhknpShape@@AEBTvec3_t@@0@Z(mins, maxs);
}

/*
==============
Physics_DestroyServerWorlds
==============
*/

void Physics_DestroyServerWorlds(void)
{
  ?Physics_DestroyServerWorlds@@YAXXZ();
}

/*
==============
Physics_IsDetailWorld
==============
*/

bool __fastcall Physics_IsDetailWorld(Physics_WorldId worldId)
{
  return ?Physics_IsDetailWorld@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_FreeBroadphaseCollisionQueryResult
==============
*/

void __fastcall Physics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?Physics_FreeBroadphaseCollisionQueryResult@@YAXPEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(result);
}

/*
==============
Physics_PrepareForDetailCollisionAssetChange
==============
*/

void __fastcall Physics_PrepareForDetailCollisionAssetChange(XModelDetailCollision *detailCollision)
{
  ?Physics_PrepareForDetailCollisionAssetChange@@YAXPEAUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
Physics_InstantiateKeyframedBody
==============
*/

unsigned int __fastcall Physics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int contents, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?Physics_InstantiateKeyframedBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBTvec3_t@@AEBTvec4_t@@_N55@Z(worldId, shape, ref, name, physicsMaterial, contents, position, orientationAsQuat, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
Physics_DoCmd_StepWorldCollide
==============
*/

void __fastcall Physics_DoCmd_StepWorldCollide(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldCollide@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_CheckShapecastConstraints
==============
*/

void __fastcall Physics_CheckShapecastConstraints(const hknpShape *shape, const vec3_t *start, const vec3_t *end)
{
  ?Physics_CheckShapecastConstraints@@YAXPEBVhknpShape@@AEBTvec3_t@@1@Z(shape, start, end);
}

/*
==============
Physics_AddPhysicsVFXEventAsset
==============
*/

void __fastcall Physics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?Physics_AddPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
Physics_TakeSnapshot
==============
*/

void __fastcall Physics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  ?Physics_TakeSnapshot@@YAXW4Physics_WorldId@@PEBD_N@Z(worldId, filename, humanReadable);
}

/*
==============
Physics_GetRefDetailFlag
==============
*/

bool __fastcall Physics_GetRefDetailFlag(int ref)
{
  return ?Physics_GetRefDetailFlag@@YA_NH@Z(ref);
}

/*
==============
Physics_SetErrorString
==============
*/

void __fastcall Physics_SetErrorString(const char *string)
{
  ?Physics_SetErrorString@@YAXPEBD@Z(string);
}

/*
==============
Physics_GetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall Physics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, unsigned int bodyId, vec4_t *invInertia)
{
  ?Physics_GetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@IAEATvec4_t@@@Z(worldId, bodyId, invInertia);
}

/*
==============
Physics_DestroyInstance
==============
*/

void __fastcall Physics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?Physics_DestroyInstance@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
Physics_SetRigidBodyMass
==============
*/

void __fastcall Physics_SetRigidBodyMass(Physics_WorldId worldId, unsigned int bodyId, float mass)
{
  ?Physics_SetRigidBodyMass@@YAXW4Physics_WorldId@@IM@Z(worldId, bodyId, mass);
}

/*
==============
Physics_ApplyRadiusForce
==============
*/

void __fastcall Physics_ApplyRadiusForce(const Physics_WorldId worldId, const vec3_t *position, const float radius, const float innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, unsigned int randSeed, float forceScalar)
{
  ?Physics_ApplyRadiusForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@MMMM1IM@Z(worldId, position, radius, innerDamage, outerDamage, impulseOverride, impulseVecOverride, randSeed, forceScalar);
}

/*
==============
Physics_GetShapeNameFromShapeList
==============
*/

const char *__fastcall Physics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetShapeNameFromShapeList@@YAPEBDPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_AddToScene
==============
*/

void __fastcall Physics_AddToScene(LocalClientNum_t localClientNum)
{
  ?Physics_AddToScene@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Physics_CalcShapeRadius
==============
*/

void __fastcall Physics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  ?Physics_CalcShapeRadius@@YAXPEBVhknpShape@@AEAM@Z(shape, radiusOut);
}

/*
==============
Physics_IsChildOfShape
==============
*/

bool __fastcall Physics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  return ?Physics_IsChildOfShape@@YA_NPEBVhknpShape@@0@Z(possibleParent, possibleChild);
}

/*
==============
Physics_CopyPhysicsVFXEventAsset
==============
*/

void __fastcall Physics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?Physics_CopyPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_DeferredShapecast
==============
*/

void __fastcall Physics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredShapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBTvec3_t@@2AEBTvec4_t@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, start, end, rotation, extendedData, data);
}

/*
==============
Physics_GetAssetByName
==============
*/

const PhysicsAsset *__fastcall Physics_GetAssetByName(const char *name)
{
  return ?Physics_GetAssetByName@@YAPEBUPhysicsAsset@@PEBD@Z(name);
}

/*
==============
Physics_UnsubscribeFromTriggerEvent
==============
*/

void __fastcall Physics_UnsubscribeFromTriggerEvent(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_UnsubscribeFromTriggerEvent@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_SetupBootDvars
==============
*/

void Physics_SetupBootDvars(void)
{
  ?Physics_SetupBootDvars@@YAXXZ();
}

/*
==============
Physics_SetRigidBodyDynamic
==============
*/

void __fastcall Physics_SetRigidBodyDynamic(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_SetRigidBodyDynamic@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_ResetWorkerError
==============
*/

void Physics_ResetWorkerError(void)
{
  ?Physics_ResetWorkerError@@YAXXZ();
}

/*
==============
Physics_DeferredRaycast
==============
*/

void __fastcall Physics_DeferredRaycast(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredRaycast@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, start, end, extendedData, data);
}

/*
==============
Physics_GetServerThreadId
==============
*/

unsigned int __fastcall Physics_GetServerThreadId()
{
  return ?Physics_GetServerThreadId@@YAIXZ();
}

/*
==============
Physics_SetMassPropertiesInertiaTensor
==============
*/

void __fastcall Physics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, const vec3_t *inertiaTensor)
{
  ?Physics_SetMassPropertiesInertiaTensor@@YAXPEAUhkMassProperties@@AEBTvec3_t@@@Z(massProperties, inertiaTensor);
}

/*
==============
Physics_WaitForPredictiveWorldUpdateCommandToFinish
==============
*/

void Physics_WaitForPredictiveWorldUpdateCommandToFinish(void)
{
  ?Physics_WaitForPredictiveWorldUpdateCommandToFinish@@YAXXZ();
}

/*
==============
Physics_AreServerWorldsCreated
==============
*/

bool __fastcall Physics_AreServerWorldsCreated()
{
  return ?Physics_AreServerWorldsCreated@@YA_NXZ();
}

/*
==============
Physics_QueryPoint
==============
*/

void __fastcall Physics_QueryPoint(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_QueryPoint@@YAXW4Physics_WorldId@@IAEBTvec3_t@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, point, maxDistance, extendedData, result);
}

/*
==============
Physics_GetNoQueriesAllowed
==============
*/

bool __fastcall Physics_GetNoQueriesAllowed(Physics_WorldId worldId)
{
  return ?Physics_GetNoQueriesAllowed@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_AllocateMemoryBuffer
==============
*/

char *__fastcall Physics_AllocateMemoryBuffer(const unsigned __int64 size, const char *name)
{
  return ?Physics_AllocateMemoryBuffer@@YAPEAD_KPEBD@Z(size, name);
}

/*
==============
Physics_GetDetailHitData
==============
*/

const Physics_DetailHitData *__fastcall Physics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  return ?Physics_GetDetailHitData@@YAPEBUPhysics_DetailHitData@@PEBVHavokPhysics_CollisionQueryResult@@HH@Z(result, modifierIndex, hitIndex);
}

/*
==============
Physics_TransientZoneUnloading
==============
*/

void __fastcall Physics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  ?Physics_TransientZoneUnloading@@YAXI_N@Z(worldTransientIndex, fullUnload);
}

/*
==============
Physics_AddDeferredBulletForce
==============
*/

void __fastcall Physics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  ?Physics_AddDeferredBulletForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@1I_NAEBUWeapon@@_NHP6AXW4LocalClientNum_t@@II11H1PEBW4scr_string_t@@I34H@Z@Z(worldId, start, end, inflictorEntNum, isMelee, weapon, isAlternate, mod, effectCallback);
}

/*
==============
Physics_GetRigidBodyMaxLinAngSpeed
==============
*/

void __fastcall Physics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  ?Physics_GetRigidBodyMaxLinAngSpeed@@YAXW4Physics_WorldId@@IPEAM1@Z(worldId, bodyId, maxLinSpeed, maxAngSpeed);
}

/*
==============
Physics_CheckForGarbageCollectionServer
==============
*/

void __fastcall Physics_CheckForGarbageCollectionServer(float timeStep)
{
  ?Physics_CheckForGarbageCollectionServer@@YAXM@Z(timeStep);
}

/*
==============
Physics_Shapecast
==============
*/

void __fastcall Physics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?Physics_Shapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBTvec3_t@@2AEBTvec4_t@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@5@Z(worldId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
Physics_GetNumVertCountsInShapeList
==============
*/

int __fastcall Physics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumVertCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_GetRef
==============
*/

int __fastcall Physics_GetRef(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_GetRef@@YAHW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_DeferredAABBQuery
==============
*/

void __fastcall Physics_DeferredAABBQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredAABBQuery@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, min, max, extendedData, data);
}

/*
==============
Physics_CopyXModelDetailCollisionAsset
==============
*/

void __fastcall Physics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?Physics_CopyXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
Physics_WarpInstanceTo
==============
*/

bool __fastcall Physics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphaseIfNecessary)
{
  return ?Physics_WarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@_N@Z(worldId, instanceId, position, orientationAsQuat, updateBroadphaseIfNecessary);
}

/*
==============
Physics_AddPendingBodies
==============
*/

void __fastcall Physics_AddPendingBodies(Physics_WorldId worldId)
{
  ?Physics_AddPendingBodies@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_WaitForAllCommandsToFinish
==============
*/

void Physics_WaitForAllCommandsToFinish(void)
{
  ?Physics_WaitForAllCommandsToFinish@@YAXXZ();
}

/*
==============
Physics_GetPhysicsAssetContents
==============
*/

int __fastcall Physics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  return ?Physics_GetPhysicsAssetContents@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_MakeRef
==============
*/

int __fastcall Physics_MakeRef(Physics_RefSystem system, Physics_RelationshipSystem relationSystem, unsigned __int8 subSystem, unsigned __int16 id)
{
  return ?Physics_MakeRef@@YAHW4Physics_RefSystem@@W4Physics_RelationshipSystem@@EG@Z(system, relationSystem, subSystem, id);
}

/*
==============
Physics_AntilagRestoreInstanceTo
==============
*/

void __fastcall Physics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat)
{
  ?Physics_AntilagRestoreInstanceTo@@YAXW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@@Z(worldId, instanceId, position, orientationAsQuat);
}

/*
==============
Physics_Load
==============
*/

void __fastcall Physics_Load(SaveGame *save)
{
  ?Physics_Load@@YAXPEAUSaveGame@@@Z(save);
}

/*
==============
Physics_SetBroadphaseNeedsRefresh
==============
*/

void __fastcall Physics_SetBroadphaseNeedsRefresh(const Physics_WorldId worldId, const bool needsRefresh)
{
  ?Physics_SetBroadphaseNeedsRefresh@@YAXW4Physics_WorldId@@_N@Z(worldId, needsRefresh);
}

/*
==============
Physics_CheckWorldReplayDeterminism
==============
*/

void __fastcall Physics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  ?Physics_CheckWorldReplayDeterminism@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_GetPhysicsAssetBodyBounds
==============
*/

void __fastcall Physics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, vec3_t *min, vec3_t *max)
{
  ?Physics_GetPhysicsAssetBodyBounds@@YAXPEBUPhysicsAsset@@HAEATvec3_t@@1@Z(physicsAsset, bodyIdx, min, max);
}

/*
==============
Physics_GetDetailCollisionContents
==============
*/

int __fastcall Physics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  return ?Physics_GetDetailCollisionContents@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
Physics_SetCGDynEntDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGDynEntDetailPropagationDebugData(LocalClientNum_t localClientNum, int detailBoundedCount, int duplicationCount, int duplicationBodyCount)
{
  ?Physics_SetCGDynEntDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HHH@Z(localClientNum, detailBoundedCount, duplicationCount, duplicationBodyCount);
}

/*
==============
Physics_InstantiateAssetBody
==============
*/

bool __fastcall Physics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?Physics_InstantiateAssetBody@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBTvec3_t@@AEBTvec4_t@@_N44HW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientationAsQuat, add, tryStartDeactivated, neverDeactivate, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
Physics_DoCmd_Task
==============
*/

void __fastcall Physics_DoCmd_Task(const void *const cmdInfo)
{
  ?Physics_DoCmd_Task@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_GetDontCollideWithClutterFromUserData
==============
*/

bool __fastcall Physics_GetDontCollideWithClutterFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetDontCollideWithClutterFromUserData@@YA_N_K@Z(userData);
}

/*
==============
Physics_WaitForPredictiveWorldUpdatePreCommandToFinish
==============
*/

void Physics_WaitForPredictiveWorldUpdatePreCommandToFinish(void)
{
  ?Physics_WaitForPredictiveWorldUpdatePreCommandToFinish@@YAXXZ();
}

/*
==============
Physics_GetFilterSubGroupIdFromUserData
==============
*/

char __fastcall Physics_GetFilterSubGroupIdFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetFilterSubGroupIdFromUserData@@YAD_K@Z(userData);
}

/*
==============
Physics_SetCGFXStatesDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGFXStatesDetailPropagationDebugData(LocalClientNum_t localClientNum, int numState, int numPhysicsState)
{
  ?Physics_SetCGFXStatesDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numState, numPhysicsState);
}

/*
==============
Physics_GetShapeOverrideContents
==============
*/

int __fastcall Physics_GetShapeOverrideContents(int shapeOverride)
{
  return ?Physics_GetShapeOverrideContents@@YAHH@Z(shapeOverride);
}

/*
==============
Physics_SetRigidBodyToDefault
==============
*/

void __fastcall Physics_SetRigidBodyToDefault(Physics_WorldId worldId, unsigned int bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  ?Physics_SetRigidBodyToDefault@@YAXW4Physics_WorldId@@IPEBUPhysicsAsset@@I@Z(worldId, bodyId, asset, assetIndex);
}

/*
==============
Physics_GetClosestPoints
==============
*/

void __fastcall Physics_GetClosestPoints(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_GetClosestPoints@@YAXW4Physics_WorldId@@IPEAVhknpShape@@AEBTvec3_t@@AEBTvec4_t@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
Physics_ConvertRefSystemToString
==============
*/

void __fastcall Physics_ConvertRefSystemToString(int ref, Physics_WorldId worldId, char *string, int stringLen)
{
  ?Physics_ConvertRefSystemToString@@YAXHW4Physics_WorldId@@PEADH@Z(ref, worldId, string, stringLen);
}

/*
==============
Physics_CreateShapeCylinder
==============
*/

hknpShape *__fastcall Physics_CreateShapeCylinder(const vec3_t *center, float halfHeight, float radius, int numVertices, bool useCache)
{
  return ?Physics_CreateShapeCylinder@@YAPEAVhknpShape@@AEBTvec3_t@@MMH_N@Z(center, halfHeight, radius, numVertices, useCache);
}

/*
==============
Physics_GetShapeVertCountFromShapeList
==============
*/

int __fastcall Physics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetShapeVertCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_GetPhysicsAssetBodyName
==============
*/

const char *__fastcall Physics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?Physics_GetPhysicsAssetBodyName@@YAPEBDPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
Physics_SetRigidBodyCenterOfMass
==============
*/

void __fastcall Physics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *centerOfMass)
{
  ?Physics_SetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@IAEBTvec3_t@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
Physics_IsInstanceInWorld
==============
*/

bool __fastcall Physics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  return ?Physics_IsInstanceInWorld@@YA_NW4Physics_WorldId@@I_N@Z(worldId, instanceId, checkPending);
}

/*
==============
Physics_TakeMemorySnapshot
==============
*/

void __fastcall Physics_TakeMemorySnapshot(const char *filename)
{
  ?Physics_TakeMemorySnapshot@@YAXPEBD@Z(filename);
}

/*
==============
Physics_EnableDeactivationForBody
==============
*/

void __fastcall Physics_EnableDeactivationForBody(Physics_WorldId worldId, unsigned int bodyId, bool enableDeactivation)
{
  ?Physics_EnableDeactivationForBody@@YAXW4Physics_WorldId@@I_N@Z(worldId, bodyId, enableDeactivation);
}

/*
==============
Physics_DecodeShapeKeyIntoShapes
==============
*/

unsigned int __fastcall Physics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, unsigned int bodyId, unsigned int key, const hknpShape **shapes)
{
  return ?Physics_DecodeShapeKeyIntoShapes@@YAIW4Physics_WorldId@@IIQEAPEBVhknpShape@@@Z(worldId, bodyId, key, shapes);
}

/*
==============
Physics_ActivateBody
==============
*/

void __fastcall Physics_ActivateBody(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_ActivateBody@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_DeferredAABBQuery
==============
*/

void __fastcall Physics_DeferredAABBQuery(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredAABBQuery@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, min, max, extendedData, data);
}

/*
==============
Physics_InverseInertiaFromLocalToWorld
==============
*/

void __fastcall Physics_InverseInertiaFromLocalToWorld(const vec3_t *invInertiaLocal, const tmat33_t<vec3_t> *rotation, tmat33_t<vec3_t> *invInertiaWs)
{
  ?Physics_InverseInertiaFromLocalToWorld@@YAXAEBTvec3_t@@AEBT?$tmat33_t@Tvec3_t@@@@AEAT2@@Z(invInertiaLocal, rotation, invInertiaWs);
}

/*
==============
Physics_AllocateCollisionQueryResult
==============
*/

HavokPhysics_CollisionQueryResult *__fastcall Physics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  return ?Physics_AllocateCollisionQueryResult@@YAPEAVHavokPhysics_CollisionQueryResult@@W4Physics_WorldId@@W4Physics_CollisionQueryCollectionType@@@Z(worldId, type);
}

/*
==============
Physics_DisableShapeCache
==============
*/

void __fastcall Physics_DisableShapeCache(unsigned int threadId, bool disable)
{
  ?Physics_DisableShapeCache@@YAXI_N@Z(threadId, disable);
}

/*
==============
Physics_GetNumServerRigidBodysInAsset
==============
*/

int __fastcall Physics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  return ?Physics_GetNumServerRigidBodysInAsset@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_ClearAntilagFlags
==============
*/

void __fastcall Physics_ClearAntilagFlags(Physics_WorldId worldId)
{
  ?Physics_ClearAntilagFlags@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_StepVDB
==============
*/

void __fastcall Physics_StepVDB(Physics_WorldId worldId, float time, bool updateStats)
{
  ?Physics_StepVDB@@YAXW4Physics_WorldId@@M_N@Z(worldId, time, updateStats);
}

/*
==============
Physics_PreStepWorld
==============
*/

void __fastcall Physics_PreStepWorld(Physics_WorldId worldId, float timeStep)
{
  ?Physics_PreStepWorld@@YAXW4Physics_WorldId@@M@Z(worldId, timeStep);
}

/*
==============
Physics_GetRigidBodyCenterOfMassLocal
==============
*/

void __fastcall Physics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, unsigned int bodyId, vec3_t *centerOfMassLocal)
{
  ?Physics_GetRigidBodyCenterOfMassLocal@@YAXW4Physics_WorldId@@IAEATvec3_t@@@Z(worldId, bodyId, centerOfMassLocal);
}

/*
==============
Physics_LockWorld
==============
*/

void __fastcall Physics_LockWorld(Physics_WorldId worldId)
{
  ?Physics_LockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_AllocateBroadphaseCollisionQueryResult
==============
*/

HavokPhysics_BroadphaseCollisionQueryResult *__fastcall Physics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  return ?Physics_AllocateBroadphaseCollisionQueryResult@@YAPEAVHavokPhysics_BroadphaseCollisionQueryResult@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_AddDetailCollisionShapesToInstanceList
==============
*/

unsigned int __fastcall Physics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const vec3_t *origin, const float scale, const vec4_t *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?Physics_AddDetailCollisionShapesToInstanceList@@YAIPEBUXModelDetailCollision@@AEBTvec3_t@@MAEBTvec4_t@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(detailCollision, origin, scale, orientation, instanceArray);
}

/*
==============
Physics_KeyframeInstanceTo
==============
*/

Physics_MovementType __fastcall Physics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?Physics_KeyframeInstanceTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@M_N3M@Z(worldId, instanceId, position, orientationAsQuat, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
Physics_SetInstanceXModel
==============
*/

void __fastcall Physics_SetInstanceXModel(const Physics_WorldId worldId, const unsigned int instanceId, const XModel *const xmodel)
{
  ?Physics_SetInstanceXModel@@YAXW4Physics_WorldId@@IQEBUXModel@@@Z(worldId, instanceId, xmodel);
}

/*
==============
Physics_DoGarbageCollectionServer
==============
*/

void Physics_DoGarbageCollectionServer(void)
{
  ?Physics_DoGarbageCollectionServer@@YAXXZ();
}

/*
==============
Physics_ReleasePhysicsSFXEventAsset
==============
*/

void __fastcall Physics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?Physics_ReleasePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
Physics_RemoveRigidBodiesFromWorld
==============
*/

void __fastcall Physics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, unsigned int *bodyIds, int numBodies, bool activate)
{
  ?Physics_RemoveRigidBodiesFromWorld@@YAXW4Physics_WorldId@@PEAIH_N@Z(worldId, bodyIds, numBodies, activate);
}

/*
==============
Physics_RenderDebugOverlays
==============
*/

void __fastcall Physics_RenderDebugOverlays(GfxCmdBufContext *gfxContext)
{
  ?Physics_RenderDebugOverlays@@YAXUGfxCmdBufContext@@@Z(gfxContext);
}

/*
==============
Physics_SwapPhysicsVFXEventAsset
==============
*/

void __fastcall Physics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?Physics_SwapPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_SetMapLocalAllocatorBuffer
==============
*/

void __fastcall Physics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  ?Physics_SetMapLocalAllocatorBuffer@@YAXPEAXI@Z(buffer, size);
}

/*
==============
Physics_CopyPhysicsAsset
==============
*/

void __fastcall Physics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?Physics_CopyPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
Physics_SetCGGlassDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGGlassDetailPropagationDebugData(LocalClientNum_t localClientNum, int glassPieceCount, int glassPhysicsCount, int glassBodyCount)
{
  ?Physics_SetCGGlassDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HHH@Z(localClientNum, glassPieceCount, glassPhysicsCount, glassBodyCount);
}

/*
==============
Physics_AddInstanceToWorld
==============
*/

void __fastcall Physics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  ?Physics_AddInstanceToWorld@@YAXW4Physics_WorldId@@I_N1@Z(worldId, instanceId, immediate, tryStartDeactivated);
}

/*
==============
Physics_IsInstanceStatic
==============
*/

bool __fastcall Physics_IsInstanceStatic(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?Physics_IsInstanceStatic@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
Physics_GetRigidBodyMass
==============
*/

void __fastcall Physics_GetRigidBodyMass(Physics_WorldId worldId, unsigned int bodyId, float *mass)
{
  ?Physics_GetRigidBodyMass@@YAXW4Physics_WorldId@@IPEAM@Z(worldId, bodyId, mass);
}

/*
==============
Physics_WarpRigidBodyToRelative
==============
*/

void __fastcall Physics_WarpRigidBodyToRelative(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *startPosition, const vec4_t *startOrientationAsQuat, const vec3_t *endPosition, const vec4_t *endOrientationAsQuat)
{
  ?Physics_WarpRigidBodyToRelative@@YAXW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@12@Z(worldId, bodyId, startPosition, startOrientationAsQuat, endPosition, endOrientationAsQuat);
}

/*
==============
Physics_ApplyLinearImpulse
==============
*/

void __fastcall Physics_ApplyLinearImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *normalizedDirection, float magnitude)
{
  ?Physics_ApplyLinearImpulse@@YAXW4Physics_WorldId@@IAEBTvec3_t@@M@Z(worldId, bodyId, normalizedDirection, magnitude);
}

/*
==============
Physics_GetShape
==============
*/

hknpShape *__fastcall Physics_GetShape(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_GetShape@@YAPEAVhknpShape@@W4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_MoveXModelDetailCollisionAsset
==============
*/

void __fastcall Physics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?Physics_MoveXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
Physics_CheckForGarbageCollectionClient
==============
*/

void __fastcall Physics_CheckForGarbageCollectionClient(float timeStep)
{
  ?Physics_CheckForGarbageCollectionClient@@YAXM@Z(timeStep);
}

/*
==============
Physics_WarpLeafDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall Physics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphase, bool activate)
{
  return ?Physics_WarpLeafDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@_N3@Z(worldId, bodyId, position, orientationAsQuat, updateBroadphase, activate);
}

/*
==============
Physics_AABBBroadphaseQuery
==============
*/

void __fastcall Physics_AABBBroadphaseQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?Physics_AABBBroadphaseQuery@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(worldId, min, max, extendedData, result);
}

/*
==============
Physics_GetPhysicsAssetShape
==============
*/

const hknpShape *__fastcall Physics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?Physics_GetPhysicsAssetShape@@YAPEBVhknpShape@@PEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
Physics_CalculateMassProperties
==============
*/

void __fastcall Physics_CalculateMassProperties(hknpShape *shape, float mass, hkMassProperties *massProperties)
{
  ?Physics_CalculateMassProperties@@YAXPEAVhknpShape@@MPEAUhkMassProperties@@@Z(shape, mass, massProperties);
}

/*
==============
Physics_IsRigidBodyKeyframed
==============
*/

bool __fastcall Physics_IsRigidBodyKeyframed(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_IsRigidBodyKeyframed@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetRigidBodyContents
==============
*/

int __fastcall Physics_GetRigidBodyContents(const Physics_WorldId worldId, const unsigned int bodyId)
{
  return ?Physics_GetRigidBodyContents@@YAHW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_SetCGFXParticlesDetailPropagationDebugData
==============
*/

void __fastcall Physics_SetCGFXParticlesDetailPropagationDebugData(LocalClientNum_t localClientNum, int numParticles, int numPhysicsParticles)
{
  ?Physics_SetCGFXParticlesDetailPropagationDebugData@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, numParticles, numPhysicsParticles);
}

/*
==============
Physics_GetShapeUserData
==============
*/

unsigned __int64 __fastcall Physics_GetShapeUserData(hknpShape *inShape)
{
  return ?Physics_GetShapeUserData@@YA_KPEAVhknpShape@@@Z(inShape);
}

/*
==============
Physics_CreateServerWorlds
==============
*/

void __fastcall Physics_CreateServerWorlds(const unsigned int maxClients)
{
  ?Physics_CreateServerWorlds@@YAXI@Z(maxClients);
}

/*
==============
Physics_GetBroadphaseNeedsRefresh
==============
*/

bool __fastcall Physics_GetBroadphaseNeedsRefresh(const Physics_WorldId worldId)
{
  return ?Physics_GetBroadphaseNeedsRefresh@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_IsAssetRagdoll
==============
*/

bool __fastcall Physics_IsAssetRagdoll(const PhysicsAsset *physicsAsset)
{
  return ?Physics_IsAssetRagdoll@@YA_NPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_GetShapeTypeName
==============
*/

const char *__fastcall Physics_GetShapeTypeName(const hknpShape *shape)
{
  return ?Physics_GetShapeTypeName@@YAPEBDPEBVhknpShape@@@Z(shape);
}

/*
==============
Physics_CreateClientWorlds
==============
*/

void __fastcall Physics_CreateClientWorlds(LocalClientNum_t localClientNum)
{
  ?Physics_CreateClientWorlds@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Physics_ReleasePhysicsVFXEventAsset
==============
*/

void __fastcall Physics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?Physics_ReleasePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
Physics_MyChangesSaveAndShutdown
==============
*/

void Physics_MyChangesSaveAndShutdown(void)
{
  ?Physics_MyChangesSaveAndShutdown@@YAXXZ();
}

/*
==============
Physics_HasSFXEventAsset
==============
*/

bool __fastcall Physics_HasSFXEventAsset(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_HasSFXEventAsset@@YA_NW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetShapeConvexCountFromShapeList
==============
*/

int __fastcall Physics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetShapeConvexCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_Init
==============
*/

void Physics_Init(void)
{
  ?Physics_Init@@YAXXZ();
}

/*
==============
Physics_InstantiateAssetBodyCylinder
==============
*/

bool __fastcall Physics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?Physics_InstantiateAssetBodyCylinder@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBTvec3_t@@AEBTvec4_t@@_N44MMW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientationAsQuat, add, tryStartDeactivated, neverDeactivate, radius, height, forceType, filterType, forQueryOnly);
}

/*
==============
Physics_SetCGPhysicsObjectPredictiveDebugData
==============
*/

void __fastcall Physics_SetCGPhysicsObjectPredictiveDebugData(LocalClientNum_t localClientNum, int numPhysicsObjects, int numPhysicsObjectsNeedingUpdate, int numPhysicsObjectsNeedingFullUpdate, int physicsObjectChildHavingCount, int physicsObjectChildCount, int physicsObjectDynamicBoneMappingHavingCount, int physicsObjectDynamicBoneMappingCount, int physicsObjectKeyframedBoneMappingHavingCount, int physicsObjectKeyframedBoneMappingCount, int physicsObjectKeyframedBoneMappingHavingCountUpdated, int physicsObjectKeyframedBoneMappingCountUpdated, int physicsObjectKeyframedOffsetMappingHavingCount, int physicsObjectKeyframedOffsetMappingCount, int physicsObjectKeyframedOffsetMappingHavingCountUpdated, int physicsObjectKeyframedOffsetMappingCountUpdated)
{
  ?Physics_SetCGPhysicsObjectPredictiveDebugData@@YAXW4LocalClientNum_t@@HHHHHHHHHHHHHHH@Z(localClientNum, numPhysicsObjects, numPhysicsObjectsNeedingUpdate, numPhysicsObjectsNeedingFullUpdate, physicsObjectChildHavingCount, physicsObjectChildCount, physicsObjectDynamicBoneMappingHavingCount, physicsObjectDynamicBoneMappingCount, physicsObjectKeyframedBoneMappingHavingCount, physicsObjectKeyframedBoneMappingCount, physicsObjectKeyframedBoneMappingHavingCountUpdated, physicsObjectKeyframedBoneMappingCountUpdated, physicsObjectKeyframedOffsetMappingHavingCount, physicsObjectKeyframedOffsetMappingCount, physicsObjectKeyframedOffsetMappingHavingCountUpdated, physicsObjectKeyframedOffsetMappingCountUpdated);
}

/*
==============
Physics_AccumulateRigidBodyAngularImpulse
==============
*/

void __fastcall Physics_AccumulateRigidBodyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *impulseWs, const vec3_t *atPointWs, vec3_t *outAngularVelWs)
{
  ?Physics_AccumulateRigidBodyAngularImpulse@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1AEAT2@@Z(worldId, bodyId, impulseWs, atPointWs, outAngularVelWs);
}

/*
==============
Physics_ValidateWorld
==============
*/

void __fastcall Physics_ValidateWorld(Physics_WorldId worldId)
{
  ?Physics_ValidateWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_Shapecast
==============
*/

void __fastcall Physics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?Physics_Shapecast@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBTvec3_t@@3AEBTvec4_t@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@6@Z(worldId, numBodies, bodyIds, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
Physics_GetDecalTypeFromUserData
==============
*/

bool __fastcall Physics_GetDecalTypeFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetDecalTypeFromUserData@@YA_N_K@Z(userData);
}

/*
==============
Physics_AddPhysicsLibrary
==============
*/

void __fastcall Physics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?Physics_AddPhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
Physics_SetInstanceDetailModel
==============
*/

void __fastcall Physics_SetInstanceDetailModel(const Physics_WorldId worldId, const unsigned int instanceId, const XModel *const xmodel)
{
  ?Physics_SetInstanceDetailModel@@YAXW4Physics_WorldId@@IQEBUXModel@@@Z(worldId, instanceId, xmodel);
}

/*
==============
Physics_GetPhysicsAssetShapeTag
==============
*/

unsigned __int16 __fastcall Physics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?Physics_GetPhysicsAssetShapeTag@@YAGPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
Physics_AllocateIgnoreBodies
==============
*/

HavokPhysics_IgnoreBodies *__fastcall Physics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  return ?Physics_AllocateIgnoreBodies@@YAPEAVHavokPhysics_IgnoreBodies@@HH@Z(minEntities, minBodies);
}

/*
==============
Physics_CreateInstance
==============
*/

unsigned int __fastcall Physics_CreateInstance(Physics_WorldId worldId)
{
  return ?Physics_CreateInstance@@YAIW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_MovePhysicsAsset
==============
*/

void __fastcall Physics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?Physics_MovePhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
Physics_GetThreadId
==============
*/

unsigned int __fastcall Physics_GetThreadId()
{
  return ?Physics_GetThreadId@@YAIXZ();
}

/*
==============
Physics_AddRigidBodyIdToArray
==============
*/

void __fastcall Physics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, unsigned int bodyId)
{
  ?Physics_AddRigidBodyIdToArray@@YAXPEAV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@I@Z(array, bodyId);
}

/*
==============
Physics_AddShapeList
==============
*/

HavokPhysicsShapeList *__fastcall Physics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  return ?Physics_AddShapeList@@YAPEAVHavokPhysicsShapeList@@PEAPEADPEAIPEBDH@Z(rawShapeData, rawShapeDataSize, name, type);
}

/*
==============
Physics_GetRefSubSystem
==============
*/

unsigned __int8 __fastcall Physics_GetRefSubSystem(int ref)
{
  return ?Physics_GetRefSubSystem@@YAEH@Z(ref);
}

/*
==============
Physics_DeferredAABBBroadphaseQuery
==============
*/

void __fastcall Physics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  ?Physics_DeferredAABBBroadphaseQuery@@YAXW4Physics_WorldId@@AEBTvec3_t@@1PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAUPhysics_DeferredBroadphaseCollisionQueryData@@@Z(worldId, min, max, extendedData, data);
}

/*
==============
Physics_ApplyAngularImpulse
==============
*/

void __fastcall Physics_ApplyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *torqueVector, float magnitude)
{
  ?Physics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@IAEBTvec3_t@@M@Z(worldId, bodyId, torqueVector, magnitude);
}

/*
==============
Physics_ClearShapeCache
==============
*/

void Physics_ClearShapeCache(void)
{
  ?Physics_ClearShapeCache@@YAXXZ();
}

/*
==============
Physics_SetRigidBodyKeyframed
==============
*/

void __fastcall Physics_SetRigidBodyKeyframed(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_SetRigidBodyKeyframed@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_GetRigidBodyDynamicMass
==============
*/

void __fastcall Physics_GetRigidBodyDynamicMass(Physics_WorldId worldId, unsigned int bodyId, float *mass)
{
  ?Physics_GetRigidBodyDynamicMass@@YAXW4Physics_WorldId@@IPEAM@Z(worldId, bodyId, mass);
}

/*
==============
Physics_AddPhysicsAssetShapesToInstanceList
==============
*/

unsigned int __fastcall Physics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const vec3_t *origin, const float scale, const vec4_t *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?Physics_AddPhysicsAssetShapesToInstanceList@@YAIPEBUPhysicsAsset@@AEBTvec3_t@@MAEBTvec4_t@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(physicsAsset, origin, scale, orientation, instanceArray);
}

/*
==============
Physics_CreateShapeSphere
==============
*/

hknpShape *__fastcall Physics_CreateShapeSphere(const vec3_t *center, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  return ?Physics_CreateShapeSphere@@YAPEAVhknpShape@@AEBTvec3_t@@MPEADH@Z(center, radius, optionalInplaceBuffer, optionalInplaceBufferSize);
}

/*
==============
Physics_GetGlassIdFromUserData
==============
*/

unsigned __int16 __fastcall Physics_GetGlassIdFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetGlassIdFromUserData@@YAG_K@Z(userData);
}

/*
==============
Physics_CopyPhysicsSFXEventAsset
==============
*/

void __fastcall Physics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?Physics_CopyPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
Physics_SetNoBroadphaseQueriesAllowed
==============
*/

void __fastcall Physics_SetNoBroadphaseQueriesAllowed(Physics_WorldId worldId, bool noQueriesAllowed)
{
  ?Physics_SetNoBroadphaseQueriesAllowed@@YAXW4Physics_WorldId@@_N@Z(worldId, noQueriesAllowed);
}

/*
==============
Physics_UpdateBroadphase
==============
*/

void __fastcall Physics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  ?Physics_UpdateBroadphase@@YAXW4Physics_WorldId@@_N@Z(worldId, updateAll);
}

/*
==============
Physics_AddInstanceContents
==============
*/

void __fastcall Physics_AddInstanceContents(Physics_WorldId worldId, unsigned int instanceId, int contents)
{
  ?Physics_AddInstanceContents@@YAXW4Physics_WorldId@@IH@Z(worldId, instanceId, contents);
}

/*
==============
Physics_OnThreadShutdown
==============
*/

void __fastcall Physics_OnThreadShutdown(unsigned int threadId)
{
  ?Physics_OnThreadShutdown@@YAXI@Z(threadId);
}

/*
==============
Physics_AreClientWorldsCreated
==============
*/

bool __fastcall Physics_AreClientWorldsCreated(LocalClientNum_t localClientNum)
{
  return ?Physics_AreClientWorldsCreated@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
Physics_GetWireframeGeometry
==============
*/

void __fastcall Physics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  ?Physics_GetWireframeGeometry@@YAXPEAVhknpShape@@PEATvec3_t@@HPEAH@Z(shape, pointArray, pointArraySize, numLines);
}

/*
==============
Physics_GetPhysicsAssetConstraintCount
==============
*/

int __fastcall Physics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  return ?Physics_GetPhysicsAssetConstraintCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_GetFixedMemoryPoolUsage
==============
*/

double __fastcall Physics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  double result; 

  *(float *)&result = ?Physics_GetFixedMemoryPoolUsage@@YAMW4Physics_WorldId@@@Z(worldId);
  return result;
}

/*
==============
Physics_IsPredictiveWorld
==============
*/

bool __fastcall Physics_IsPredictiveWorld(Physics_WorldId worldId)
{
  return ?Physics_IsPredictiveWorld@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_DeferredGetClosestPoints
==============
*/

void __fastcall Physics_DeferredGetClosestPoints(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?Physics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@IPEAVhknpShape@@AEBTvec3_t@@AEBTvec4_t@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
Physics_IsPhysicsAssetDynamic
==============
*/

bool __fastcall Physics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  return ?Physics_IsPhysicsAssetDynamic@@YA_NPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_GetPhysicsAssetConstraintBodyIds
==============
*/

void __fastcall Physics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  ?Physics_GetPhysicsAssetConstraintBodyIds@@YAXPEBUPhysicsAsset@@HPEAH1@Z(physicsAsset, constraintIdx, bodyId1, bodyId2);
}

/*
==============
Physics_GetClosestPoints
==============
*/

void __fastcall Physics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_GetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBTvec3_t@@AEBTvec4_t@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
Physics_DoCmd_StepWorldDetail
==============
*/

void __fastcall Physics_DoCmd_StepWorldDetail(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldDetail@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_SetDebugCameras
==============
*/

void __fastcall Physics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  ?Physics_SetDebugCameras@@YAXPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
Physics_InstantiateAsset
==============
*/

unsigned int __fastcall Physics_InstantiateAsset(Physics_WorldId worldId, const XModel *baseModel, const PhysicsAsset *physicsAsset, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?Physics_InstantiateAsset@@YAIW4Physics_WorldId@@PEBUXModel@@PEBUPhysicsAsset@@HAEBTvec3_t@@AEBTvec4_t@@_N55PEAUPhysics_InstantiateShapeOverride@@W4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@5@Z(worldId, baseModel, physicsAsset, ref, position, orientationAsQuat, add, forceAddImmediate, tryStartDeactivated, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
Physics_ApplyBulletForce
==============
*/

void __fastcall Physics_ApplyBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  ?Physics_ApplyBulletForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@1I_NAEBUWeapon@@_NHP6AXW4LocalClientNum_t@@II11H1PEBW4scr_string_t@@I34H@Z@Z(worldId, start, end, inflictorEntNum, isMelee, weapon, isAlternate, mod, effectCallback);
}

/*
==============
Physics_DoCmd_StepWorldFX
==============
*/

void __fastcall Physics_DoCmd_StepWorldFX(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldFX@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_GetNumShapeNamesInShapeList
==============
*/

int __fastcall Physics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?Physics_GetNumShapeNamesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
Physics_GetSurfaceFlagsFromUserData
==============
*/

unsigned int __fastcall Physics_GetSurfaceFlagsFromUserData(unsigned __int64 userData)
{
  return ?Physics_GetSurfaceFlagsFromUserData@@YAI_K@Z(userData);
}

/*
==============
Physics_Raycast
==============
*/

void __fastcall Physics_Raycast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_Raycast@@YAXW4Physics_WorldId@@IAEBTvec3_t@@1PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, start, end, extendedData, result);
}

/*
==============
Physics_GetShapeTriCountFromShapeList
==============
*/

int __fastcall Physics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?Physics_GetShapeTriCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
Physics_UpdateWorld
==============
*/

void __fastcall Physics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  ?Physics_UpdateWorld@@YAXW4Physics_WorldId@@_N@Z(worldId, syncStats);
}

/*
==============
Physics_GetNoBroadphaseQueriesAllowed
==============
*/

bool __fastcall Physics_GetNoBroadphaseQueriesAllowed(Physics_WorldId worldId)
{
  return ?Physics_GetNoBroadphaseQueriesAllowed@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_GetInstanceAsset
==============
*/

const PhysicsAsset *__fastcall Physics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?Physics_GetInstanceAsset@@YAPEBUPhysicsAsset@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
Physics_GetDetailCollisionShapeCount
==============
*/

int __fastcall Physics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  return ?Physics_GetDetailCollisionShapeCount@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
Physics_CreateShapeCube
==============
*/

hknpShape *__fastcall Physics_CreateShapeCube(const vec3_t *center, float halfSize)
{
  return ?Physics_CreateShapeCube@@YAPEAVhknpShape@@AEBTvec3_t@@M@Z(center, halfSize);
}

/*
==============
Physics_IsAuthoritativeWorld
==============
*/

bool __fastcall Physics_IsAuthoritativeWorld(Physics_WorldId worldId)
{
  return ?Physics_IsAuthoritativeWorld@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
Physics_EnableShapeInstance
==============
*/

void __fastcall Physics_EnableShapeInstance(Physics_WorldId worldId, unsigned int bodyId, unsigned __int16 shapeInstanceId, bool enabled)
{
  ?Physics_EnableShapeInstance@@YAXW4Physics_WorldId@@IG_N@Z(worldId, bodyId, shapeInstanceId, enabled);
}

/*
==============
Physics_SetThreadHeapAllocationMapLocal
==============
*/

void __fastcall Physics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  ?Physics_SetThreadHeapAllocationMapLocal@@YAXI@Z(threadId);
}

/*
==============
Physics_GetRigidBodyName
==============
*/

const char *__fastcall Physics_GetRigidBodyName(Physics_WorldId worldId, unsigned int bodyId)
{
  return ?Physics_GetRigidBodyName@@YAPEBDW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_KeyframeRigidBodyTo
==============
*/

Physics_MovementType __fastcall Physics_KeyframeRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?Physics_KeyframeRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@M_N3M@Z(worldId, bodyId, position, orientationAsQuat, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
Physics_SetRigidBodyContents
==============
*/

void __fastcall Physics_SetRigidBodyContents(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, int contents, bool forceCacheRebuild)
{
  ?Physics_SetRigidBodyContents@@YAXW4Physics_WorldId@@IIH_N@Z(worldId, instanceId, bodyIdx, contents, forceCacheRebuild);
}

/*
==============
Physics_GetPhysicsAssetBodyCount
==============
*/

int __fastcall Physics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  return ?Physics_GetPhysicsAssetBodyCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
Physics_DoCmd_StepWorldSolve
==============
*/

void __fastcall Physics_DoCmd_StepWorldSolve(const void *const cmdInfo)
{
  ?Physics_DoCmd_StepWorldSolve@@YAXQEBX@Z(cmdInfo);
}

/*
==============
Physics_ConvertRayQueryResultToLegacyTrace
==============
*/

void __fastcall Physics_ConvertRayQueryResultToLegacyTrace(HavokPhysics_CollisionQueryResult *traceResult, HavokPhysics_CollisionQueryResult *queryResult, const Physics_DetailHitData *detailHitData, trace_t *trace)
{
  ?Physics_ConvertRayQueryResultToLegacyTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@0PEBUPhysics_DetailHitData@@PEAUtrace_t@@@Z(traceResult, queryResult, detailHitData, trace);
}

/*
==============
Physics_BatchRaycast
==============
*/

void __fastcall Physics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const vec3_t *starts, const vec3_t *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  ?Physics_BatchRaycast@@YAXW4Physics_WorldId@@IPEBTvec3_t@@1PEAUPhysics_RaycastExtendedData@@PEAPEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numRays, starts, ends, extendedData, results);
}

/*
==============
Physics_SubscribeToTriggerEvent
==============
*/

void __fastcall Physics_SubscribeToTriggerEvent(Physics_WorldId worldId, unsigned int bodyId)
{
  ?Physics_SubscribeToTriggerEvent@@YAXW4Physics_WorldId@@I@Z(worldId, bodyId);
}

/*
==============
Physics_AddDebugLine
==============
*/

void __fastcall Physics_AddDebugLine(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const vec4_t *color)
{
  ?Physics_AddDebugLine@@YAXW4Physics_WorldId@@AEBTvec3_t@@1AEBTvec4_t@@@Z(worldId, start, end, color);
}

/*
==============
Physics_Shutdown
==============
*/

void Physics_Shutdown(void)
{
  ?Physics_Shutdown@@YAXXZ();
}

/*
==============
Physics_GetClosestPoints
==============
*/

void __fastcall Physics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?Physics_GetClosestPoints@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBTvec3_t@@AEBTvec4_t@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numBodies, bodyIds, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
Physics_InstantiateDetailModel
==============
*/

unsigned int __fastcall Physics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  return ?Physics_InstantiateDetailModel@@YAIW4Physics_WorldId@@PEBUXModel@@HAEBTvec3_t@@AEBTvec4_t@@_N444@Z(worldId, detailModel, ref, position, orientationAsQuat, add, tryStartDeactivated, forQueryOnly, allowSingleBodyAddToWorld);
}

/*
==============
Physics_BroadphaseUpdateServerMain
==============
*/

void __fastcall Physics_BroadphaseUpdateServerMain(Physics_WorldId worldId)
{
  GPlayerTraceInfo::ClearServerCages();
}

/*
==============
Physics_WorldBodyListChangedServerMain
==============
*/

void __fastcall Physics_WorldBodyListChangedServerMain(Physics_WorldId worldId)
{
  GPlayerTraceInfo::ClearServerCages();
}

/*
==============
Physics_PreStepWorldServerMain
==============
*/
void Physics_PreStepWorldServerMain(Physics_WorldId worldId)
{
  PhysPerfTrack_PMoveServerTimeStore();
  PhysPerfTrack_PMoveServerCountStore();
  PhysPerfTrack_PMoveServerTraceTimeStore();
  PhysPerfTrack_PMoveServerTraceCountStore();
  PhysPerfTrack_BulletServerTimeStore();
  PhysPerfTrack_BulletServerEventCountStore();
  PhysPerfTrack_BulletServerPelletCountStore();
  PhysPerfTrack_BulletServerTraceTimeStore();
  PhysPerfTrack_BulletServerTraceCountStore();
  WorldCollision_SetupTileCollision(worldId);
  StaticModels_SetupTileCollision(worldId);
  if ( !GVehicles::ms_gVehiclesSystem )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2413, ASSERT_TYPE_ASSERT, "(GVehicles::IsVehicleSystemAllocated())", "%s\n\tPhysics_PreStepWorldServerMain, we assume a valid GVehicles system created for this world", "GVehicles::IsVehicleSystemAllocated()") )
      __debugbreak();
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
  }
  GVehicles::PhysicsBeforeWorldStep(GVehicles::ms_gVehiclesSystem, worldId);
}

/*
==============
Physics_PreStepWorldClientPredictive
==============
*/
void Physics_PreStepWorldClientPredictive(Physics_WorldId worldId)
{
  LocalClientNum_t v2; 
  LocalClientNum_t v3; 
  int numVertsGeneral; 
  int v5; 
  int value; 
  int v7; 
  int v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  CgVehicleSystem *VehicleSystem; 

  Profile_Begin(641);
  v2 = LOCAL_CLIENT_INVALID;
  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
LABEL_19:
    v3 = LOCAL_CLIENT_INVALID;
    goto LABEL_20;
  }
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v3 = LOCAL_CLIENT_1;
      goto LABEL_20;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
    goto LABEL_19;
  }
  v3 = LOCAL_CLIENT_0;
  PhysPerfTrack_PMoveClientTimeStore();
  PhysPerfTrack_PMoveClientTraceTimeStore();
  PhysPerfTrack_PMoveClientCountStore();
  PhysPerfTrack_PMoveClientTraceCountStore();
  PhysPerfTrack_BulletClientTimeStore();
  PhysPerfTrack_BulletClientEventCountStore();
  PhysPerfTrack_BulletClientPelletCountStore();
  PhysPerfTrack_BulletClientTraceCountStore();
  if ( g_PhysPerfTrack_DebugData && !CL_TransientsCollisionMP_HasStreamingTiles() )
  {
    numVertsGeneral = g_PhysPerfTrack_DebugData->worldMeshDebugData.numVertsGeneral;
    v5 = numVertsGeneral + g_PhysPerfTrack_DebugData->worldMeshDebugData.numVertsCharacter;
    value = g_PhysPerfTrack_DebugData->worldMeshDebugData.numVertsTotal;
    v7 = numVertsGeneral + g_PhysPerfTrack_DebugData->worldMeshDebugData.numVertsWeapon;
    v8 = numVertsGeneral + g_PhysPerfTrack_DebugData->worldMeshDebugData.numVertsItem;
    if ( value <= 350000 )
    {
      if ( v5 <= 130000 )
      {
        if ( v7 <= 300000 )
        {
          if ( v8 > 150000 )
          {
            v12 = j_va("Sim WorldColl verts:%i max:%i", (unsigned int)v8, 150000i64);
            StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_PHYS_WORLD_GEO_SIMULATION, 3000, v12, v8);
          }
        }
        else
        {
          v11 = j_va("Weapon WorldColl verts:%i max:%i", (unsigned int)v7, 300000i64);
          StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_PHYS_WORLD_GEO_WEAPON, 3000, v11, v7);
        }
      }
      else
      {
        v10 = j_va("Player WorldColl verts:%i max:%i", (unsigned int)v5, 130000i64);
        StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_PHYS_WORLD_GEO_PMOVE, 3000, v10, v5);
      }
    }
    else
    {
      v9 = j_va("WorldColl verts:%i max:%i", (unsigned int)value, 350000i64);
      StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_PHYS_WORLD_GEO_ALL, 3000, v9, value);
    }
  }
  if ( CL_TransientsCollisionMP_HasStreamingTiles() )
  {
    WorldCollision_CheckTransientBudgets(LOCAL_CLIENT_0);
    StaticModels_CheckTransientBudgets(LOCAL_CLIENT_0);
  }
LABEL_20:
  WorldCollision_SetupTileCollision(worldId);
  StaticModels_SetupTileCollision(worldId);
  Physics_UpdateClientGravity(worldId, v3);
  Profile_Begin(642);
  CG_PhysicsObject_PreUpdatePredictiveWorld(worldId, v3);
  Profile_EndInternal(NULL);
  Profile_Begin(643);
  CG_PhysicsCharacterProxy_Update(v3, worldId, (Physics_WorldId)(3 * v3 + 3), (Physics_WorldId)(3 * v3 + 4));
  Profile_EndInternal(NULL);
  Profile_EndInternal(NULL);
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
    {
      if ( worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
          __debugbreak();
      }
      else
      {
        v2 = LOCAL_CLIENT_1;
      }
    }
    else
    {
      v2 = LOCAL_CLIENT_0;
    }
  }
  CgPlayerTraceInfo::ClearCage(v2);
  if ( !CgVehicleSystem::IsVehicleSystemAllocated(v3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2501, ASSERT_TYPE_ASSERT, "(CgVehicleSystem::IsVehicleSystemAllocated( localClientNum ))", "%s\n\tPhysics_PreStepWorldClientPredictive, we assume a valid CgVehicleSystem create for this world", "CgVehicleSystem::IsVehicleSystemAllocated( localClientNum )") )
    __debugbreak();
  VehicleSystem = CgVehicleSystem::GetVehicleSystem(v3);
  CgVehicleSystem::PhysicsBeforeWorldStep(VehicleSystem, worldId);
}

/*
==============
Physics_PreStepWorldClientAuthoritative
==============
*/
void Physics_PreStepWorldClientAuthoritative(Physics_WorldId worldId)
{
  Sys_ProfBeginNamedEvent(0xFF008008, "ClientPhysicsBeforeAuthoritative");
  WorldCollision_SetupTileCollision(worldId);
  StaticModels_SetupTileCollision(worldId);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_BeforeStepWorldServerMain
==============
*/
void Physics_BeforeStepWorldServerMain(Physics_WorldId worldId, int timePostStep, int stepIndex, int numStepsPlanned)
{
  unsigned int DebugWorldPersistantMemoryPeak; 
  int value; 
  const char *v6; 

  Profile_Begin(621);
  DebugWorldPersistantMemoryPeak = HavokPhysics_GetDebugWorldPersistantMemoryPeak(PHYSICS_WORLD_ID_FIRST);
  value = DebugWorldPersistantMemoryPeak;
  if ( DebugWorldPersistantMemoryPeak > 0x700000 )
  {
    v6 = j_va("Havok server world %i bytes - budget %i", DebugWorldPersistantMemoryPeak, 7340032i64);
    StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_HAVOKSERVERMEM, 3000, v6, value);
  }
  Profile_EndInternal(NULL);
  G_GameInterface_PhysicsBodyCapacityChecks();
}

/*
==============
Physics_BeforeUpdateWorldServerDetail
==============
*/
void Physics_BeforeUpdateWorldServerDetail(Physics_WorldId worldId)
{
  Profile_Begin(629);
  WorldCollision_SetupTileCollision(worldId);
  StaticModels_SetupTileCollision(worldId);
  Profile_Begin(630);
  G_PhysicsObject_PropagateToDetailWorld(PHYSICS_WORLD_ID_FIRST, PHYSICS_WORLD_ID_SERVER_DETAIL);
  Profile_EndInternal(NULL);
  Profile_Begin(631);
  G_PhysicsCharacterProxy_PropagateToDetailWorld();
  Profile_EndInternal(NULL);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_BeforeUpdateWorldClientDetail
==============
*/
void Physics_BeforeUpdateWorldClientDetail(Physics_WorldId worldId)
{
  LocalClientNum_t v2; 

  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v2 = LOCAL_CLIENT_1;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v2 = LOCAL_CLIENT_INVALID;
    goto LABEL_9;
  }
  v2 = LOCAL_CLIENT_0;
LABEL_9:
  Profile_Begin(666);
  WorldCollision_SetupTileCollision(worldId);
  StaticModels_SetupTileCollision(worldId);
  Profile_Begin(667);
  CG_PhysicsObject_PropagateToDetailWorld((Physics_WorldId)(3 * v2 + 3), worldId, v2);
  Profile_EndInternal(NULL);
  Profile_Begin(532);
  DynEnt_PropagateToDetailWorld(v2);
  Profile_EndInternal(NULL);
  Profile_Begin(668);
  FX_PropagateToDetailWorld(v2);
  Profile_EndInternal(NULL);
  Profile_Begin(671);
  Glass_PropagateToDetailWorld(v2);
  Profile_EndInternal(NULL);
  CG_ClientModel_Physics_PropagateToDetailWorld(v2);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_BeforeStepWorldClientAuthoritative
==============
*/
void Physics_BeforeStepWorldClientAuthoritative(Physics_WorldId worldId, int timePostStep, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  signed int v6; 
  Physics_WorldId v7; 

  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v6 = 1;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v6 = -1;
    goto LABEL_9;
  }
  v6 = 0;
LABEL_9:
  Profile_Begin(658);
  Profile_Begin(659);
  Physics_UpdateClientGravity(worldId, (LocalClientNum_t)v6);
  Profile_EndInternal(NULL);
  Profile_Begin(660);
  CG_PhysicsObject_Propagate((Physics_WorldId)(3 * v6 + 2), worldId, (LocalClientNum_t)v6, 1);
  Profile_EndInternal(NULL);
  CG_ClientModel_Physics_PreStepWorld((const LocalClientNum_t)v6);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7737, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to process deferred force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v7 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7738, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to process deferred force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
      __debugbreak();
  }
  HavokPhysics_ProcessDeferredForce(worldId);
  DynEnt_PrePhysicsUpdate((LocalClientNum_t)v6);
  Cloth_Update_PhysicsProxies(v6);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_AfterStepWorldServerMain
==============
*/
void Physics_AfterStepWorldServerMain(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  if ( stepIndex >= numStepsPlanned - 1 )
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "ServerPhysicsStepWorldEndClearCaches");
    PhysicsGravityModifier_ClearCache(worldId);
    PhysicsForceAction_ClearCache(worldId);
    Sys_ProfEndNamedEvent();
    if ( !GVehicles::ms_gVehiclesSystem )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2664, ASSERT_TYPE_ASSERT, "(GVehicles::IsVehicleSystemAllocated())", "%s\n\tPhysics_AfterStepWorldServerMain, we assume a valid GVehicles system created for this world", "GVehicles::IsVehicleSystemAllocated()") )
        __debugbreak();
      if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
        __debugbreak();
    }
    GVehicles::PhysicsAfterWorldStep(GVehicles::ms_gVehiclesSystem, worldId);
  }
}

/*
==============
Physics_AfterStepWorldClientAuthoritative
==============
*/
void Physics_AfterStepWorldClientAuthoritative(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  PhysicsGravityModifier_ClearCache(worldId);
  PhysicsForceAction_ClearCache(worldId);
}

/*
==============
Physics_AfterStepWorldClientPredictive
==============
*/
void Physics_AfterStepWorldClientPredictive(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  LocalClientNum_t v4; 
  CgVehicleSystem *VehicleSystem; 

  PhysicsGravityModifier_ClearCache(worldId);
  PhysicsForceAction_ClearCache(worldId);
  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v4 = LOCAL_CLIENT_1;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v4 = LOCAL_CLIENT_INVALID;
    goto LABEL_9;
  }
  v4 = LOCAL_CLIENT_0;
LABEL_9:
  if ( !CgVehicleSystem::IsVehicleSystemAllocated(v4) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2690, ASSERT_TYPE_ASSERT, "(CgVehicleSystem::IsVehicleSystemAllocated( localClientNum ))", "%s\n\tPhysics_AfterStepWorldClientPredictive, we assume a valid CgVehicleSystem create for this world", "CgVehicleSystem::IsVehicleSystemAllocated( localClientNum )") )
    __debugbreak();
  VehicleSystem = CgVehicleSystem::GetVehicleSystem(v4);
  CgVehicleSystem::PhysicsAfterWorldStep(VehicleSystem, worldId);
}

/*
==============
Physics_StepWorldPhysicsObjectsClientAuthoritative
==============
*/
void Physics_StepWorldPhysicsObjectsClientAuthoritative(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  LocalClientNum_t v4; 

  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v4 = LOCAL_CLIENT_1;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v4 = LOCAL_CLIENT_INVALID;
    goto LABEL_9;
  }
  v4 = LOCAL_CLIENT_0;
LABEL_9:
  Profile_Begin(663);
  CG_PhysicsObject_PostUpdateAuthoritativeWorld(worldId, v4);
  Profile_EndInternal(NULL);
  CG_ClientModel_Physics_PostStepWorld(v4);
}

/*
==============
Physics_StepWorldPhysicsObjectsClientPredictive
==============
*/
void Physics_StepWorldPhysicsObjectsClientPredictive(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  LocalClientNum_t v4; 

  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v4 = LOCAL_CLIENT_1;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v4 = LOCAL_CLIENT_INVALID;
    goto LABEL_9;
  }
  v4 = LOCAL_CLIENT_0;
LABEL_9:
  Profile_Begin(664);
  CG_PhysicsObject_PostUpdatePredictiveWorld(worldId, v4);
  Profile_EndInternal(NULL);
  CG_ClientModel_Physics_PostStepWorld(v4);
}

/*
==============
Physics_StepWorldDetailClientAuthoritative
==============
*/
void Physics_StepWorldDetailClientAuthoritative(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  Physics_WorldId v4; 

  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    goto LABEL_8;
  if ( worldId > PHYSICS_WORLD_ID_CLIENT0_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v4 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
      goto LABEL_9;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_8:
    v4 = PHYSICS_WORLD_ID_SERVER_DETAIL;
    goto LABEL_9;
  }
  v4 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
LABEL_9:
  Profile_Begin(665);
  *(double *)&_XMM0 = Com_GetTimeScale();
  __asm { vmulss  xmm1, xmm0, cs:__real@3c888889; timeStep }
  Physics_PreStepWorld(v4, *(float *)&_XMM1);
  Physics_UpdateWorld(v4, 0);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_AABBBroadphaseQuery
==============
*/
void Physics_AABBBroadphaseQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  __int64 v9; 
  const dvar_t *v16; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  hkAabb v32; 

  _RBP = max;
  _R14 = min;
  v9 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8436, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire AABB Broadphase Query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8437, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
LABEL_49:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8438, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire aabb broadphase query with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8439, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire aabb broadphase query with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8440, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8441, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire aabb broadphase query with invalid result", "result") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v9] )
  {
    v16 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8442, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  if ( g_physicsQueriesNotAllowedForWorld[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8443, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v9] )
    Physics_UpdateBroadphase((Physics_WorldId)v9, 1);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [r14]
    vmulss  xmm2, xmm4, dword ptr [r14+4]
    vmulss  xmm1, xmm4, dword ptr [r14+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0B8h+var_68], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbp+4]
    vmovss  dword ptr [rsp+0B8h+var_68+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbp+8]
    vmovss  dword ptr [rsp+0B8h+var_68+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbp+0]
    vmovss  dword ptr [rsp+0B8h+var_68+10h], xmm1
    vmovss  dword ptr [rsp+0B8h+var_68+14h], xmm0
    vmovss  dword ptr [rsp+0B8h+var_68+18h], xmm2
    vmovss  dword ptr [rsp+0B8h+var_68+0Ch], xmm3
    vmovss  dword ptr [rsp+0B8h+var_68+1Ch], xmm3
  }
  switch ( (int)v9 )
  {
    case 0:
      Profile_Begin(692);
      break;
    case 1:
      Profile_Begin(693);
      break;
    case 2:
    case 5:
      Profile_Begin(694);
      break;
    case 3:
    case 6:
      Profile_Begin(695);
      break;
    case 4:
    case 7:
      Profile_Begin(696);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8499, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm
  {
    vmovups ymm0, [rsp+0B8h+var_68]
    vmovups [rsp+0B8h+var_68], ymm0
  }
  HavokPhysics_AABBBroadphaseQuery((Physics_WorldId)v9, &v32, extendedData, result);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_AABBQuery
==============
*/
void Physics_AABBQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v9; 
  const dvar_t *v16; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  hkAabb v32; 

  _RBP = max;
  _R14 = min;
  v9 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8538, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire AABB Query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8539, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_46;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_46;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
LABEL_46:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8540, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire aabb query with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_47;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_47;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_47:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8541, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire aabb query with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8542, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8543, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire aabb query with invalid result", "result") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v9] )
  {
    v16 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8544, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v9] )
    Physics_UpdateBroadphase((Physics_WorldId)v9, 1);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [r14]
    vmulss  xmm2, xmm4, dword ptr [r14+4]
    vmulss  xmm1, xmm4, dword ptr [r14+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0B8h+var_68], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbp+4]
    vmovss  dword ptr [rsp+0B8h+var_68+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbp+8]
    vmovss  dword ptr [rsp+0B8h+var_68+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbp+0]
    vmovss  dword ptr [rsp+0B8h+var_68+10h], xmm1
    vmovss  dword ptr [rsp+0B8h+var_68+14h], xmm0
    vmovss  dword ptr [rsp+0B8h+var_68+18h], xmm2
    vmovss  dword ptr [rsp+0B8h+var_68+0Ch], xmm3
    vmovss  dword ptr [rsp+0B8h+var_68+1Ch], xmm3
  }
  switch ( (int)v9 )
  {
    case 0:
      Profile_Begin(697);
      break;
    case 1:
      Profile_Begin(698);
      break;
    case 2:
    case 5:
      Profile_Begin(699);
      break;
    case 3:
    case 6:
      Profile_Begin(700);
      break;
    case 4:
    case 7:
      Profile_Begin(701);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8600, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm
  {
    vmovups ymm0, [rsp+0B8h+var_68]
    vmovups [rsp+0B8h+var_68], ymm0
  }
  HavokPhysics_AABBQuery((Physics_WorldId)v9, &v32, extendedData, result);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_AABBQuery
==============
*/
void Physics_AABBQuery(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v10; 
  __int64 v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  hkAabb v33; 

  _RDI = max;
  _RSI = min;
  v10 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9187, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire AABB Query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v10 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9188, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire aabb query against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v26) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9189, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire aabb query against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v26) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
  {
LABEL_43:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9190, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire aabb query against body with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v32 & 0x7F800000) == 2139095040 )
  {
LABEL_44:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9191, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire aabb query against body with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9192, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire aabb query against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9193, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire aabb query against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9194, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire aabb query against body with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9195, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rsi]
    vmulss  xmm2, xmm4, dword ptr [rsi+4]
    vmulss  xmm1, xmm4, dword ptr [rsi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+var_58], xmm0
    vmulss  xmm0, xmm4, dword ptr [rdi+4]
    vmovss  dword ptr [rsp+0A8h+var_58+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+var_58+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rdi]
    vmovss  dword ptr [rsp+0A8h+var_58+10h], xmm1
    vmovss  dword ptr [rsp+0A8h+var_58+14h], xmm0
    vmovss  dword ptr [rsp+0A8h+var_58+18h], xmm2
    vmovss  dword ptr [rsp+0A8h+var_58+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+1Ch], xmm3
  }
  switch ( (int)v10 )
  {
    case 0:
      Profile_Begin(727);
      break;
    case 1:
      Profile_Begin(728);
      break;
    case 2:
    case 5:
      Profile_Begin(729);
      break;
    case 3:
    case 6:
      Profile_Begin(730);
      break;
    case 4:
    case 7:
      Profile_Begin(731);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9245, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm
  {
    vmovups ymm0, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
  }
  HavokPhysics_AABBQuery((Physics_WorldId)v10, (hknpBodyId)bodyId, &v33, extendedData, result);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_AccumulateAngularImpulse
==============
*/
void Physics_AccumulateAngularImpulse(const vec3_t *impulseWs, const vec3_t *atPointWs, const vec3_t *comWs, const tmat33_t<vec3_t> *invInertiaWs, vec3_t *outAngularVelWs)
{
  vec3_t mulVec; 
  vec3_t solution; 
  char v39; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps [rsp+98h+var_28], xmm7
    vmovaps xmmword ptr [r11-38h], xmm8
    vmovss  xmm0, dword ptr [rdx]
    vsubss  xmm6, xmm0, dword ptr [r8]
    vmovss  xmm0, dword ptr [rdx+8]
    vmovss  xmm1, dword ptr [rdx+4]
    vsubss  xmm8, xmm0, dword ptr [r8+8]
  }
  _RDI = outAngularVelWs;
  __asm { vsubss  xmm7, xmm1, dword ptr [r8+4] }
  if ( impulseWs == &mulVec && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 1668, ASSERT_TYPE_ASSERT, "( &v1 != &cross )", (const char *)&queryFormat, "&v1 != &cross") )
    __debugbreak();
  __asm
  {
    vmulss  xmm1, xmm7, dword ptr [rbx+8]
    vmulss  xmm0, xmm8, dword ptr [rbx+4]
    vmulss  xmm2, xmm8, dword ptr [rbx]
    vmulss  xmm3, xmm6, dword ptr [rbx+4]
    vsubss  xmm1, xmm1, xmm0
    vmulss  xmm0, xmm6, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+98h+mulVec], xmm1
    vsubss  xmm1, xmm2, xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx]
    vmovss  dword ptr [rsp+98h+mulVec+4], xmm1
    vsubss  xmm1, xmm3, xmm0
    vmovss  dword ptr [rsp+98h+mulVec+8], xmm1
  }
  MatrixVecMultiply(invInertiaWs, &mulVec, &solution);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+98h+solution]
    vaddss  xmm1, xmm0, dword ptr [rdi]
    vmovss  xmm0, dword ptr [rsp+98h+solution+4]
    vmovss  dword ptr [rdi], xmm1
    vaddss  xmm1, xmm0, dword ptr [rdi+4]
    vmovss  xmm0, dword ptr [rsp+98h+solution+8]
    vmovss  dword ptr [rdi+4], xmm1
    vaddss  xmm1, xmm0, dword ptr [rdi+8]
    vmovss  dword ptr [rdi+8], xmm1
  }
  _R11 = &v39;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
Physics_AccumulateRigidBodyAngularImpulse
==============
*/
void Physics_AccumulateRigidBodyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *impulseWs, const vec3_t *atPointWs, vec3_t *outAngularVelWs)
{
  __int64 v22; 
  Physics_WorldId v23; 
  hkVector4f atPointWsa; 
  hkVector4f impulseWsa; 
  hkVector4f v26; 

  _RSI = outAngularVelWs;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6361, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to accumulate angular impulse form Rigid Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v23 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6362, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to accumulate angular impulse form Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v23) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6363, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to accumulate angular impulse form Rigid Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v22) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [r14]
    vmulss  xmm2, xmm4, dword ptr [r14+4]
    vmulss  xmm1, xmm4, dword ptr [r14+8]
    vmovss  dword ptr [rsp+98h+impulseWs.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbp+4]
    vmovss  dword ptr [rsp+98h+atPointWs.m_quad+4], xmm0
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, dword ptr [rsi], 0
    vinsertps xmm0, xmm0, dword ptr [rsi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rsi+8], 20h ; ' '
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+98h+impulseWs.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbp+8]
    vmovss  dword ptr [rsp+98h+impulseWs.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbp+0]
    vmovups xmmword ptr [rsp+98h+var_38.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+impulseWs.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+98h+atPointWs.m_quad], xmm1
    vmovss  dword ptr [rsp+98h+atPointWs.m_quad+8], xmm2
    vmovss  dword ptr [rsp+98h+atPointWs.m_quad+0Ch], xmm3
  }
  HavokPhysics_AccumulateAngularImpulse(worldId, (hknpBodyId)bodyId, &impulseWsa, &atPointWsa, &v26);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+98h+var_38.m_quad]
    vmovlps qword ptr [rsi], xmm0
    vextractps dword ptr [rsi+8], xmm0, 2
  }
}

/*
==============
Physics_ActivateBody
==============
*/
void Physics_ActivateBody(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v4; 
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7830, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to activate a body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7831, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to activate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7832, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to activate a body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v4) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_ActivateBody(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_AddClipMap
==============
*/
void Physics_AddClipMap(clipMap_t *clipMap)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4042, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add ClipMap when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddClipMap(clipMap);
}

/*
==============
Physics_AddDebugLine
==============
*/
void Physics_AddDebugLine(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const vec4_t *color)
{
  unsigned int colora[4]; 
  hkVector4f enda; 
  hkVector4f starta; 

  _RBX = color;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 12940, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add Debug Line when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rsi]
    vmulss  xmm2, xmm4, dword ptr [rsi+4]
    vmulss  xmm1, xmm4, dword ptr [rsi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+88h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rdi+4]
    vmovss  dword ptr [rsp+88h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+88h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rdi]
    vmovss  dword ptr [rsp+88h+end.m_quad], xmm1
    vmovss  xmm1, dword ptr [rbx+4]; green
    vmovss  dword ptr [rsp+88h+end.m_quad+4], xmm0
    vmovss  xmm0, dword ptr [rbx]; red
    vmovss  dword ptr [rsp+88h+end.m_quad+8], xmm2
    vmovss  xmm2, dword ptr [rbx+8]; blue
    vmovss  dword ptr [rsp+88h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+88h+end.m_quad+0Ch], xmm3
    vmovss  xmm3, dword ptr [rbx+0Ch]; alpha
  }
  colora[0] = hkColor::rgbFromFloats(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2, *(const float *)&_XMM3);
  HavokPhysics_AddDebugLine(worldId, &starta, &enda, colora);
}

/*
==============
Physics_AddDeferredBulletForce
==============
*/
void Physics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  Physics_WorldId v19; 
  int v20; 
  int v21; 
  int v22; 
  int v23; 
  int v24; 
  int v25; 

  _RBX = end;
  _RDI = start;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7693, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add deferred bullet force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v19 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7694, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add deferred bullet force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v19) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v20 & 0x7F800000) == 2139095040 )
    goto LABEL_20;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v21 & 0x7F800000) == 2139095040 )
    goto LABEL_20;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
  {
LABEL_20:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7695, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to Add deferred bullet force with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
    goto LABEL_21;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
    goto LABEL_21;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+58h+arg_0], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
  {
LABEL_21:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7696, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to Add deferred bullet force with invalid end", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddDeferredBulletForce(worldId, _RDI, _RBX, inflictorEntNum, isMelee, weapon, isAlternate, mod, effectCallback);
}

/*
==============
Physics_AddDeferredKeyframeInstance
==============
*/
void Physics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  __int64 v15; 
  Physics_WorldId v16; 
  int v17; 
  int v18; 
  int v19; 
  int v20; 
  int v21; 
  int v22; 
  int v23; 

  _RDI = orientationAsQuat;
  _RSI = origin;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7678, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add deferred keyframe when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( worldId )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      v16 = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2123, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsAuthoritativeWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v16) )
        __debugbreak();
    }
    if ( worldId != PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE && worldId != PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE )
    {
      LODWORD(v15) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7679, ASSERT_TYPE_ASSERT, "(worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId ))", "%s\n\tPhysics: Trying to Add deferred keyframe with invalid world index %i", "worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId )", v15) )
        __debugbreak();
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v17 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v18 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v19 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7680, ASSERT_TYPE_ASSERT, "(!IS_NAN( origin[0] ) && !IS_NAN( origin[1] ) && !IS_NAN( origin[2] ))", "%s\n\tPhysics: Trying to Add deferred keyframe with invalid origin", "!IS_NAN( origin[0] ) && !IS_NAN( origin[1] ) && !IS_NAN( origin[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v20 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v21 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+48h+arg_0], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7681, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Add deferred keyframe with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddDeferredKeyframeInstance(worldId, instanceId, _RSI, _RDI);
}

/*
==============
Physics_AddDeferredRadiusForce
==============
*/

void __fastcall Physics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, double radius, double innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  Physics_WorldId v22; 
  int v25; 
  int v26; 
  int v27; 

  _RBX = position;
  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps [rsp+78h+var_28], xmm7
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm3
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7708, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add deferred radius force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v22 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7709, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add deferred radius force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v22) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+78h+arg_0], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_15;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+78h+arg_0], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_15;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+78h+arg_0], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_15:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7710, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Add deferred radius force with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovaps xmm3, xmm6; innerDamage
    vmovaps xmm2, xmm7; radius
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm7, [rsp+78h+var_28]
  }
  HavokPhysics_AddDeferredRadiusForce(worldId, _RBX, *(const float *)&_XMM2, *(const float *)&_XMM3, outerDamage, impulseOverride, impulseVecOverride, randSeed, forceScalar);
}

/*
==============
Physics_AddDetailCollisionShapesToInstanceList
==============
*/

unsigned int __fastcall Physics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const vec3_t *origin, double scale, const vec4_t *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  unsigned int result; 
  hkQuaternionf orientationa; 
  hkVector4f origina; 

  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  _RBX = orientation;
  __asm { vmovaps xmm6, xmm2 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10096, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_AddDetailCollisionShapesToInstanceList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+88h+origin.m_quad], xmm0
    vmovups xmm0, xmmword ptr [rbx]
    vmovss  dword ptr [rsp+88h+origin.m_quad+4], xmm2
    vxorps  xmm3, xmm3, xmm3
    vmovaps xmm2, xmm6; scale
    vmovaps xmmword ptr [rsp+88h+orientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+origin.m_quad+8], xmm1
    vmovss  dword ptr [rsp+88h+origin.m_quad+0Ch], xmm3
  }
  result = HavokPhysics_AddDetailCollisionShapesToInstanceList(detailCollision, &origina, *(const float *)&_XMM2, &orientationa, instanceArray);
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
  return result;
}

/*
==============
Physics_AddDetailTrace
==============
*/
void Physics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8082, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to AddDetailTrace when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8083, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to AddDetailTrace for invalid result", "result") )
    __debugbreak();
  HavokPhysics_AddDetailTrace(result, detailPriorityMap);
}

/*
==============
Physics_AddInstanceContents
==============
*/
void Physics_AddInstanceContents(Physics_WorldId worldId, unsigned int instanceId, int contents)
{
  signed int v6; 
  int NumRigidBodys; 
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6530, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add Instance contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6531, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add Instance contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6532, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Add Instance contents with invalid instance %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  v6 = 0;
  NumRigidBodys = Physics_GetNumRigidBodys(worldId, instanceId);
  if ( NumRigidBodys > 0 )
  {
    do
      Physics_AddRigidBodyContents(worldId, instanceId, v6++, contents, 0);
    while ( v6 < NumRigidBodys );
  }
}

/*
==============
Physics_AddInstanceToWorld
==============
*/
void Physics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5926, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to add instance to world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5927, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to add instance to world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5928, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to add instance to world with invalid instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddInstanceToWorld(worldId, instanceId, immediate, tryStartDeactivated);
}

/*
==============
Physics_AddPendingBodies
==============
*/
void Physics_AddPendingBodies(Physics_WorldId worldId)
{
  __int64 v2; 
  Physics_WorldId v3; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5785, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add Pending Bodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5786, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v3) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v2) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5787, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v2) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v2) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5788, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v2) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddPendingBodies(worldId);
}

/*
==============
Physics_AddPhysicsAsset
==============
*/
void Physics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3665, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddPhysicsAsset(physicsAsset);
}

/*
==============
Physics_AddPhysicsAssetShapesToInstanceList
==============
*/

unsigned int __fastcall Physics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const vec3_t *origin, double scale, const vec4_t *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  unsigned int result; 
  hkQuaternionf orientationa; 
  hkVector4f origina; 

  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  _RBX = orientation;
  __asm { vmovaps xmm6, xmm2 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10079, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_AddPhysicsAssetShapesToInstanceList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+88h+origin.m_quad], xmm0
    vmovups xmm0, xmmword ptr [rbx]
    vmovss  dword ptr [rsp+88h+origin.m_quad+4], xmm2
    vxorps  xmm3, xmm3, xmm3
    vmovaps xmm2, xmm6; scale
    vmovaps xmmword ptr [rsp+88h+orientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+origin.m_quad+8], xmm1
    vmovss  dword ptr [rsp+88h+origin.m_quad+0Ch], xmm3
  }
  result = HavokPhysics_AddPhysicsAssetShapesToInstanceList(physicsAsset, &origina, *(const float *)&_XMM2, &orientationa, instanceArray);
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
  return result;
}

/*
==============
Physics_AddPhysicsLibrary
==============
*/
void Physics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3530, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add PhysicsLibary when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddPhysicsLibrary(physicsLibrary);
}

/*
==============
Physics_AddPhysicsSFXEventAsset
==============
*/
void Physics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3553, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add physicsSFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddPhysicsSFXEventAsset(physicsSFXEventAsset);
}

/*
==============
Physics_AddPhysicsVFXEventAsset
==============
*/
void Physics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3608, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add physicsVFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddPhysicsVFXEventAsset(physicsVFXEventAsset);
}

/*
==============
Physics_AddRigidBodyContents
==============
*/
void Physics_AddRigidBodyContents(Physics_WorldId worldId, unsigned int bodyId, int contents, bool forceCacheRebuild)
{
  Physics_WorldId v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6571, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v8 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6572, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddRigidBodyContents(worldId, (hknpBodyId)bodyId, contents, forceCacheRebuild);
}

/*
==============
Physics_AddRigidBodyContents
==============
*/
void Physics_AddRigidBodyContents(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, int contents, bool forceCacheRebuild)
{
  hknpBodyId v9; 
  __int64 v10; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6553, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6554, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6555, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Add RigidBody contents with invalid instance %i", "instanceId != PHYSICSINSTANCEID_INVALID", v10) )
      __debugbreak();
  }
  if ( bodyIdx >= Physics_GetNumRigidBodys(worldId, instanceId) )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6556, ASSERT_TYPE_ASSERT, "(bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId ))", "%s\n\tPhysics: Trying to Add RigidBody contents with invalid bodyIdx %i %i", "bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId )", v10, bodyIdx) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  v9.m_serialAndIndex = Physics_GetRigidBodyID(worldId, instanceId, bodyIdx);
  if ( (v9.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6562, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6571, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6572, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddRigidBodyContents(worldId, v9, contents, forceCacheRebuild);
}

/*
==============
Physics_AddRigidBodyIdToArray
==============
*/
void Physics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, unsigned int bodyId)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6416, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_AddRigidBodyIdToArray when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !array && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6417, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array") )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6418, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
    __debugbreak();
  HavokPhysics_AddRigidBodyIdToArray(array, (hknpBodyId)bodyId);
}

/*
==============
Physics_AddShapeList
==============
*/
HavokPhysicsShapeList *Physics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3816, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add ShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !rawShapeData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3818, ASSERT_TYPE_ASSERT, "(rawShapeData)", (const char *)&queryFormat, "rawShapeData") )
    __debugbreak();
  if ( !rawShapeDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3819, ASSERT_TYPE_ASSERT, "(rawShapeDataSize)", (const char *)&queryFormat, "rawShapeDataSize") )
    __debugbreak();
  if ( !*rawShapeData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3820, ASSERT_TYPE_ASSERT, "(*rawShapeData)", (const char *)&queryFormat, "*rawShapeData") )
    __debugbreak();
  if ( !*rawShapeDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3821, ASSERT_TYPE_ASSERT, "(*rawShapeDataSize > 0)", (const char *)&queryFormat, "*rawShapeDataSize > 0") )
    __debugbreak();
  return HavokPhysics_AddShapeList(rawShapeData, rawShapeDataSize, name, type);
}

/*
==============
Physics_AddShapeReference
==============
*/

void __fastcall Physics_AddShapeReference(hknpShape *shape)
{
  HavokPhysics_AddShapeReference(shape);
}

/*
==============
Physics_AddToScene
==============
*/

void __fastcall Physics_AddToScene(LocalClientNum_t localClientNum)
{
  DynEnt_AddToScene(localClientNum);
}

/*
==============
Physics_AddXModelAsset
==============
*/
void Physics_AddXModelAsset(XModel *xmodel)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4152, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add XModel Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_AddXModelAsset(xmodel);
}

/*
==============
Physics_AddXModelDetailCollisionAsset
==============
*/
void Physics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  const char *name; 
  const char *v3; 
  __int64 v4; 
  signed __int64 v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  if ( detailCollision->physicsLODDataSize )
  {
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4072, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add XModel Physics LOD Asset when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    HavokPhysics_AddXModelDetailCollisionAsset(detailCollision);
  }
  else
  {
    name = detailCollision->name;
    v3 = "void";
    v4 = 0x7FFFFFFFi64;
    if ( !detailCollision->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    v5 = name - "void";
    do
    {
      v6 = v3[v5];
      v7 = v4;
      v8 = *v3++;
      --v4;
      if ( !v7 )
        break;
      if ( v6 != v8 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4066, ASSERT_TYPE_ASSERT, "(I_strcmp( detailCollision->name, \"void\" ) == 0)", "%s\n\tPhysics: only default 'void' physicslod should be zero sized", "I_strcmp( detailCollision->name, \"void\" ) == 0") )
          __debugbreak();
        return;
      }
    }
    while ( v6 );
  }
}

/*
==============
Physics_AllocateBroadphaseCollisionQueryResult
==============
*/
HavokPhysics_BroadphaseCollisionQueryResult *Physics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8041, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to AllocateBroadphaseCollisionQueryResult when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  return HavokPhysics_AllocateBroadphaseCollisionQueryResult(worldId);
}

/*
==============
Physics_AllocateCollisionQueryResult
==============
*/
HavokPhysics_CollisionQueryResult *Physics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8067, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to AllocateCollisionQueryResult when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)type > PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8068, ASSERT_TYPE_ASSERT, "(type >= 0 && type < PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_COUNT)", "%s\n\tPhysics: Trying to AllocateCollisionQueryResult for invalid type", "type >= 0 && type < PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_COUNT") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  return HavokPhysics_AllocateCollisionQueryResult(worldId, type);
}

/*
==============
Physics_AllocateIgnoreBodies
==============
*/
HavokPhysics_IgnoreBodies *Physics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8120, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to AllocateIgnoreBodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  return HavokPhysics_AllocateIgnoreBodies(minEntities, minBodies);
}

/*
==============
Physics_AllocateMemoryBuffer
==============
*/
char *Physics_AllocateMemoryBuffer(const unsigned __int64 size, const char *name)
{
  return (char *)PMem_Alloc(size, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, name);
}

/*
==============
Physics_AntilagRestoreInstanceTo
==============
*/
void Physics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat)
{
  __int64 v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6715, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6716, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v24) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6717, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Warp Instance with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v24) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6718, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6719, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+98h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+0Ch], xmm2
  }
  HavokPhysics_AntilagRestoreInstanceTo(worldId, instanceId, &hkPosition, &hkOrientation);
}

/*
==============
Physics_AntilagWarpInstanceTo
==============
*/
bool Physics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, vec3_t *restorePosition, vec4_t *restoreOrientationAsQuat)
{
  bool result; 
  __int64 v34; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  hkVector4f hkPosition; 
  hkQuaternionf hkRestoreOrientation; 
  hkVector4f hkRestorePosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _R14 = restorePosition;
  _RDI = position;
  _RBP = restoreOrientationAsQuat;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6680, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6681, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v34) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6682, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Warp Instance with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v34) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v35 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6683, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6684, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0C8h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0C8h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+0C8h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+0C8h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0C8h+hkPosition.m_quad+0Ch], xmm2
  }
  result = HavokPhysics_AntilagWarpInstanceTo(worldId, instanceId, &hkPosition, &hkOrientation, &hkRestorePosition, &hkRestoreOrientation);
  if ( result )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@42000000
      vmulss  xmm0, xmm3, dword ptr [rsp+0C8h+hkRestorePosition.m_quad+4]
      vmulss  xmm1, xmm3, dword ptr [rsp+0C8h+hkRestorePosition.m_quad]
      vmulss  xmm2, xmm3, dword ptr [rsp+0C8h+hkRestorePosition.m_quad+8]
      vmovss  dword ptr [r14+4], xmm0
      vmovaps xmm0, xmmword ptr [rsp+0C8h+var_68.m_vec.m_quad]
      vmovss  dword ptr [r14], xmm1
      vmovss  dword ptr [r14+8], xmm2
      vmovups xmmword ptr [rbp+0], xmm0
    }
  }
  return result;
}

/*
==============
Physics_ApplyAngularImpulse
==============
*/
void Physics_ApplyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec3_t *normalizedDirection, float magnitude)
{
  bool v18; 
  bool v19; 
  bool v20; 
  float fmt; 
  __int64 v46; 
  Physics_WorldId v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  hkVector4f hkPosition; 
  hkVector4f hkDirection; 
  char v56; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RBX = normalizedDirection;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7067, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply angular impulse to a Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v47 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7068, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v47) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v46) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7069, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v46) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
  {
LABEL_29:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7070, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  v18 = (v53 & 0x7F800000u) < 0x7F800000;
  v19 = (v53 & 0x7F800000) == 2139095040;
  if ( (v53 & 0x7F800000) == 2139095040 )
  {
LABEL_30:
    v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7071, ASSERT_TYPE_ASSERT, "(!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid direction", "!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] )");
    v18 = 0;
    v19 = !v20;
    if ( v20 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm7, [rsp+0A8h+magnitude]
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm7, xmm6
  }
  if ( !v19 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  xmm2, dword ptr [rbx+4]
      vmovss  xmm3, dword ptr [rbx+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsubss  xmm0, xmm2, cs:__real@3f800000
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm0, cs:__real@3b03126f
    }
    if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7072, ASSERT_TYPE_ASSERT, "(magnitude == 0.f || Vec3IsNormalized( normalizedDirection ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with non normal direction", "magnitude == 0.f || Vec3IsNormalized( normalizedDirection )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm { vucomiss xmm7, xmm6 }
  if ( !v19 )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@3d000000
      vmulss  xmm0, xmm3, dword ptr [rdi]
      vmulss  xmm2, xmm3, dword ptr [rdi+4]
      vmulss  xmm1, xmm3, dword ptr [rdi+8]
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad], xmm0
      vxorps  xmm0, xmm0, xmm0
      vinsertps xmm0, xmm0, dword ptr [rbx], 0
      vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
      vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
      vmovups xmmword ptr [rsp+0A8h+hkDirection.m_quad], xmm0
      vmulss  xmm0, xmm7, xmm3
      vmovss  dword ptr [rsp+0A8h+fmt], xmm0
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+4], xmm2
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+8], xmm1
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+0Ch], xmm6
    }
    HavokPhysics_ApplyAngularImpulse(worldId, (hknpBodyId)bodyId, &hkPosition, &hkDirection, fmt);
  }
  _R11 = &v56;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Physics_ApplyAngularImpulse
==============
*/

void __fastcall Physics_ApplyAngularImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *torqueVector, double magnitude)
{
  bool v12; 
  bool v13; 
  __int64 v23; 
  Physics_WorldId v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  hkVector4f hkTorqueVector; 
  char v31; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RBX = torqueVector;
  __asm { vmovaps xmm7, xmm3 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7100, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply angular impulse to a Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v24 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7101, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v24) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7102, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v23) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7103, ASSERT_TYPE_ASSERT, "(!IS_NAN( torqueVector[0] ) && !IS_NAN( torqueVector[1] ) && !IS_NAN( torqueVector[2] ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid torque vector", "!IS_NAN( torqueVector[0] ) && !IS_NAN( torqueVector[1] ) && !IS_NAN( torqueVector[2] )") )
      __debugbreak();
  }
  __asm { vmovss  [rsp+98h+var_58], xmm7 }
  v12 = (v28 & 0x7F800000) == 2139095040;
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7104, ASSERT_TYPE_ASSERT, "(!IS_NAN( magnitude ))", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with invalid magnitude", "!IS_NAN( magnitude )");
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm7, xmm6
  }
  if ( v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7105, ASSERT_TYPE_ASSERT, "(magnitude != 0.f)", "%s\n\tPhysics: Trying to Apply angular impulse to a Body with 0 magnitude", "magnitude != 0.f") )
    __debugbreak();
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm { vucomiss xmm7, xmm6 }
  if ( !v12 )
  {
    __asm
    {
      vmulss  xmm3, xmm7, cs:__real@3d000000; magnitude
      vxorps  xmm0, xmm0, xmm0
      vinsertps xmm0, xmm0, dword ptr [rbx], 0
      vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
      vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
      vmovups xmmword ptr [rsp+98h+hkTorqueVector.m_quad], xmm0
    }
    HavokPhysics_ApplyAngularImpulse(worldId, (hknpBodyId)bodyId, &hkTorqueVector, *(float *)&_XMM3);
  }
  _R11 = &v31;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
  }
}

/*
==============
Physics_ApplyBulletForce
==============
*/
void Physics_ApplyBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  unsigned int HitBody; 
  hknpBodyId v19; 
  scr_string_t partName; 
  int hitSurfaceFlags; 
  unsigned int shapeKey; 
  vec3_t position; 
  vec3_t hitNormal; 
  vec3_t direction; 

  __asm { vmovaps [rsp+128h+var_68], xmm7 }
  _R15 = end;
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_ApplyBulletForce");
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+128h+position], xmm0
    vmovss  dword ptr [rsp+128h+position+4], xmm0
    vmovss  dword ptr [rsp+128h+position+8], xmm0
    vmovss  dword ptr [rsp+128h+var_98], xmm0
    vmovss  dword ptr [rsp+128h+var_98+4], xmm0
    vmovss  dword ptr [rsp+128h+var_98+8], xmm7
  }
  HitBody = Physics_ApplyBulletForce_GetHitBody(worldId, start, _R15, inflictorEntNum, isMelee, &position, &hitSurfaceFlags, &hitNormal, &partName, &shapeKey);
  v19.m_serialAndIndex = HitBody;
  if ( (HitBody & 0xFFFFFF) != 0xFFFFFF )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r15]
      vsubss  xmm4, xmm0, dword ptr [rbx]
      vmovss  xmm1, dword ptr [r15+4]
      vsubss  xmm5, xmm1, dword ptr [rbx+4]
      vmovss  xmm0, dword ptr [r15+8]
      vmulss  xmm2, xmm5, xmm5
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vmovaps [rsp+128h+var_58], xmm6
      vsubss  xmm6, xmm0, dword ptr [rbx+8]
      vmulss  xmm0, xmm6, xmm6
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm1, xmm2, xmm2
      vcmpless xmm0, xmm1, cs:__real@80000000
      vblendvps xmm0, xmm1, xmm7, xmm0
      vdivss  xmm2, xmm7, xmm0
      vmulss  xmm0, xmm4, xmm2
      vmovss  dword ptr [rsp+128h+direction], xmm0
      vmulss  xmm0, xmm6, xmm2
      vmulss  xmm1, xmm5, xmm2
      vmovss  dword ptr [rsp+128h+direction+8], xmm0
      vmovss  dword ptr [rsp+128h+direction+4], xmm1
    }
    Physics_ApplyBulletForceBody(worldId, HitBody, &position, &direction, inflictorEntNum, isMelee);
    __asm { vmovaps xmm6, [rsp+128h+var_58] }
    if ( effectCallback )
      HavokPhysics_AddDeferredBulletEffectCallback(effectCallback, worldId, v19, shapeKey, start, &position, hitSurfaceFlags, &hitNormal, &partName, inflictorEntNum, weapon, isAlternate, mod);
  }
  Sys_ProfEndNamedEvent();
  __asm { vmovaps xmm7, [rsp+128h+var_68] }
}

/*
==============
Physics_ApplyBulletForceBody
==============
*/
void Physics_ApplyBulletForceBody(const Physics_WorldId worldId, const unsigned int bodyId, const vec3_t *position, const vec3_t *direction)
{
  bool v21; 
  bool v27; 
  char v44; 
  int Ref; 
  int v51; 
  int v54; 
  unsigned __int16 v55; 
  Ragdoll *Ragdoll; 
  float fmt; 
  float fmta; 
  __int64 v63; 
  double v64; 
  double v65; 
  double v66; 
  double v67; 
  double v68; 
  double v69; 
  double v70; 
  double v71; 
  double v72; 
  float mass; 
  int v76; 

  __asm
  {
    vmovaps [rsp+0A8h+var_48], xmm6
    vmovaps [rsp+0A8h+var_58], xmm7
  }
  _RDI = direction;
  _RBP = position;
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_ApplyBulletForceBody");
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7317, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply bullet force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7318, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Apply bullet force with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v63) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7319, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply bullet force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v63) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbp+0]
    vmovss  [rsp+0A8h+arg_8], xmm2
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0A8h+arg_8], xmm0
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0A8h+arg_8], xmm0
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
  {
LABEL_51:
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+8]
      vmovss  xmm1, dword ptr [rbp+4]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0A8h+var_68], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+0A8h+var_70], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0A8h+var_78], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7320, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Apply bullet force with invalid position (%f %f %f)", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )", v64, v67, v70) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rdi]
    vmovss  [rsp+0A8h+arg_8], xmm2
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+arg_8], xmm0
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+arg_8], xmm0
  }
  v21 = (v76 & 0x7F800000u) < 0x7F800000;
  if ( (v76 & 0x7F800000) == 2139095040 )
  {
LABEL_52:
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+8]
      vmovss  xmm1, dword ptr [rdi+4]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0A8h+var_68], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+0A8h+var_70], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0A8h+var_78], xmm2
    }
    v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7321, ASSERT_TYPE_ASSERT, "(!IS_NAN( direction[0] ) && !IS_NAN( direction[1] ) && !IS_NAN( direction[2] ))", "%s\n\tPhysics: Trying to Apply bullet force with invalid direction (%f %f %f)", "!IS_NAN( direction[0] ) && !IS_NAN( direction[1] ) && !IS_NAN( direction[2] )", v65, v68, v71);
    v21 = 0;
    if ( v27 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm4, dword ptr [rdi+4]
    vmovss  xmm5, dword ptr [rdi]
    vmovss  xmm6, dword ptr [rdi+8]
    vmovss  xmm7, cs:__real@3f800000
    vmulss  xmm1, xmm5, xmm5
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm1
    vsubss  xmm0, xmm3, xmm7
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm0, cs:__real@3b03126f
  }
  if ( !v21 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+0A8h+var_68], xmm0
      vcvtss2sd xmm1, xmm4, xmm4
      vmovsd  [rsp+0A8h+var_70], xmm1
      vcvtss2sd xmm2, xmm5, xmm5
      vmovsd  [rsp+0A8h+var_78], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7322, ASSERT_TYPE_ASSERT, "(Vec3IsNormalized( direction ))", "%s\n\tPhysics: Trying to Apply bullet force with non normal direction (%f %f %f)", "Vec3IsNormalized( direction )", v66, v69, v72) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  if ( Physics_IsRigidBodyDynamic(worldId, bodyId) )
  {
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vmovss  [rsp+0A8h+mass], xmm6
    }
    Physics_GetRigidBodyMass(worldId, bodyId, &mass);
    __asm
    {
      vmovss  xmm0, [rsp+0A8h+mass]
      vcomiss xmm0, xmm6
    }
    if ( v21 | v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7335, ASSERT_TYPE_ASSERT, "(bodyMass > 0.f)", (const char *)&queryFormat, "bodyMass > 0.f") )
      __debugbreak();
    _RBX = DCONST_DVARFLT_physics_BulletForceMassLimit;
    if ( !DCONST_DVARFLT_physics_BulletForceMassLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_BulletForceMassLimit") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmovss  xmm1, [rsp+0A8h+mass]
      vcomiss xmm1, xmm0
    }
    if ( v21 )
      __asm { vdivss  xmm7, xmm1, xmm0 }
    Ref = Physics_GetRef(worldId, bodyId);
    _RBX = DCONST_DVARFLT_physics_BulletForceDefault;
    v51 = Ref;
    if ( !DCONST_DVARFLT_physics_BulletForceDefault && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_BulletForceDefault") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    if ( (v51 & 0x3E000000) == 201326592 )
    {
      _RBX = DCONST_DVARFLT_physics_BulletForceRagdoll;
      if ( !DCONST_DVARFLT_physics_BulletForceRagdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_BulletForceRagdoll") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    }
    if ( (v51 & 0x3E000000) != 201326592 )
    {
      __asm { vmulss  xmm6, xmm6, xmm7 }
      goto LABEL_47;
    }
    v54 = v51 >> 16;
    v55 = truncate_cast<unsigned short,int>((unsigned __int16)v51);
    Ragdoll = Ragdoll_GetRagdoll((unsigned int)(unsigned __int8)v54 + 1);
    if ( !Ragdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7363, ASSERT_TYPE_ASSERT, "(ragdoll)", (const char *)&queryFormat, "ragdoll") )
      __debugbreak();
    if ( Ragdoll_CheckApplyBulletForce(Ragdoll, v55) )
    {
      __asm
      {
        vmulss  xmm6, xmm6, xmm7
        vdivss  xmm0, xmm6, [rsp+0A8h+mass]
        vmovss  dword ptr [rsp+0A8h+fmt], xmm0
      }
      Ragdoll_SetDebugBulletImpulse(Ragdoll, v55, _RBP, _RDI, fmt);
LABEL_47:
      __asm { vmovss  dword ptr [rsp+0A8h+fmt], xmm6 }
      Physics_ApplyImpulse(worldId, bodyId, _RBP, _RDI, fmta);
    }
  }
  Sys_ProfEndNamedEvent();
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_48]
    vmovaps xmm7, [rsp+0A8h+var_58]
  }
}

/*
==============
Physics_ApplyBulletForceInstance
==============
*/
void Physics_ApplyBulletForceInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *position, const vec3_t *direction, const unsigned int inflictorEntNum, const bool isMelee)
{
  bool v21; 
  bool v27; 
  unsigned int v41; 
  unsigned int NumRigidBodys; 
  bool v43; 
  unsigned int m_serialAndIndex; 
  __int64 v45; 
  double v46; 
  double v47; 
  double v48; 
  double v49; 
  double v50; 
  double v51; 
  double v52; 
  double v53; 
  double v54; 
  hknpBodyId result; 

  _RSI = direction;
  _RBP = position;
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_ApplyBulletForceInstance");
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7389, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply bullet force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7390, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply bullet force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v45) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7391, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Apply bullet force with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", v45) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbp+0]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm2
  }
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm0
  }
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm0
  }
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_49:
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+8]
      vmovss  xmm1, dword ptr [rbp+4]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+78h+var_38], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+78h+var_40], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+78h+var_48], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7392, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Apply bullet force with invalid position (%f %f %f)", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )", v46, v49, v52) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rsi]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm2
  }
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm0
  }
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+78h+result.m_serialAndIndex], xmm0
  }
  v21 = (result.m_serialAndIndex & 0x7F800000) < 0x7F800000;
  if ( (result.m_serialAndIndex & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+8]
      vmovss  xmm1, dword ptr [rsi+4]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+78h+var_38], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+78h+var_40], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+78h+var_48], xmm2
    }
    v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7393, ASSERT_TYPE_ASSERT, "(!IS_NAN( direction[0] ) && !IS_NAN( direction[1] ) && !IS_NAN( direction[2] ))", "%s\n\tPhysics: Trying to Apply bullet force with invalid direction (%f %f %f)", "!IS_NAN( direction[0] ) && !IS_NAN( direction[1] ) && !IS_NAN( direction[2] )", v47, v50, v53);
    v21 = 0;
    if ( v27 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm3, dword ptr [rsi+4]
    vmovss  xmm4, dword ptr [rsi]
    vmovss  xmm5, dword ptr [rsi+8]
    vmulss  xmm1, xmm4, xmm4
    vmulss  xmm0, xmm3, xmm3
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm2, xmm1
    vsubss  xmm0, xmm2, cs:__real@3f800000
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm0, cs:__real@3b03126f
  }
  if ( !v21 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm5, xmm5
      vmovsd  [rsp+78h+var_38], xmm0
      vcvtss2sd xmm1, xmm3, xmm3
      vmovsd  [rsp+78h+var_40], xmm1
      vcvtss2sd xmm2, xmm4, xmm4
      vmovsd  [rsp+78h+var_48], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7394, ASSERT_TYPE_ASSERT, "(Vec3IsNormalized( direction ))", "%s\n\tPhysics: Trying to Apply bullet force with non normal direction (%f %f %f)", "Vec3IsNormalized( direction )", v48, v51, v54) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  v41 = 0;
  NumRigidBodys = Physics_GetNumRigidBodys(worldId, instanceId);
  if ( NumRigidBodys )
  {
    v43 = isMelee;
    do
    {
      if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 105, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body ID when system is not initialized", "g_physicsInitialized") )
        __debugbreak();
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(v45) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 106, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v45) )
          __debugbreak();
      }
      if ( instanceId == -1 )
      {
        LODWORD(v45) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 107, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v45) )
          __debugbreak();
      }
      if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
      {
        LODWORD(v45) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 108, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v45) )
          __debugbreak();
      }
      if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
      {
        LODWORD(v45) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 109, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v45) )
          __debugbreak();
      }
      m_serialAndIndex = HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, v41)->m_serialAndIndex;
      if ( (m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7403, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
        __debugbreak();
      Physics_ApplyBulletForceBody(worldId, m_serialAndIndex, _RBP, _RSI, inflictorEntNum, v43);
      ++v41;
    }
    while ( v41 < NumRigidBodys );
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_ApplyBulletForce_GetHitBody
==============
*/
__int64 Physics_ApplyBulletForce_GetHitBody(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, vec3_t *hitPos, int *hitSurfaceFlags, vec3_t *hitNormal, scr_string_t *partName, unsigned int *shapeKey)
{
  __int64 v19; 
  int v22; 
  __int32 v24; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  HavokPhysics_CollisionQueryResult *v26; 
  const vec3_t *v30; 
  const vec3_t *v31; 
  char v64; 
  unsigned int physicsSystemDetailId; 
  unsigned int physicsSystemId; 
  int Ref; 
  int v74; 
  const char *RagdollBoneName; 
  int v76; 
  int v77; 
  int v78; 
  int v79; 
  unsigned int v80; 
  LocalClientNum_t v81; 
  int v82; 
  LocalClientNum_t v83; 
  CgHandler *Handler; 
  PhysicsObject *Base; 
  unsigned __int16 v86; 
  __int64 LocalClientForWorld; 
  DynEntityBasis v88; 
  unsigned __int16 v89; 
  __int64 v90; 
  unsigned __int16 v91; 
  DynEntityClient *v92; 
  const XModel *InstanceXModel; 
  unsigned int RaycastHitBodyId; 
  hkMemoryAllocator *v99; 
  hkMemoryAllocator *v100; 
  hkMemoryAllocator *v101; 
  hkMemoryAllocator *v102; 
  __int64 result; 
  unsigned int NumRigidBodys; 
  const char *name; 
  const char *v113; 
  unsigned int v114; 
  unsigned int RaycastHitShapeKey; 
  const char *RigidBodyName; 
  __int64 parent; 
  __int64 siblings; 
  DynEntityBasis basisOut[8]; 
  unsigned int *v126; 
  int *v127; 
  scr_string_t *v128; 
  HavokPhysics_IgnoreBodies v129; 
  HavokPhysics_CollisionQueryResult *v130; 
  HavokPhysics_IgnoreBodies v131; 
  Physics_RaycastExtendedData extendedData; 
  Physics_RaycastExtendedData v133; 
  Physics_QueryPointExtendedData v134; 
  __int64 v135; 
  vec3_t starta; 
  vec3_t pos; 
  PhysicsQuery_QueryPointHit hit; 
  char v139; 
  void *retaddr; 

  _RAX = &retaddr;
  v135 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
  }
  _R13 = end;
  *(_QWORD *)starta.v = start;
  v19 = worldId;
  _R15 = hitPos;
  v127 = hitSurfaceFlags;
  _R14 = hitNormal;
  v128 = partName;
  v126 = shapeKey;
  v22 = inflictorEntNum != 2047;
  HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(&v131, v22, 0);
  HavokPhysics_IgnoreBodies::SetIgnoreRefs(&v131, -2241);
  HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(&v129, v22, 0);
  HavokPhysics_IgnoreBodies::SetIgnoreRefs(&v129, -1559);
  if ( inflictorEntNum != 2047 )
  {
    HavokPhysics_IgnoreBodies::SetIgnoreEntity(&v131, 0, inflictorEntNum, 1, 1, 0, 0, 0);
    HavokPhysics_IgnoreBodies::SetIgnoreEntity(&v129, 0, inflictorEntNum, 1, 1, 0, 0, 0);
  }
  if ( (unsigned int)v19 > 1 && isMelee )
  {
    HavokPhysics_IgnoreBodies::SetIgnoreRefs(&v131, -193);
    HavokPhysics_IgnoreBodies::SetIgnoreRefs(&v129, -3);
  }
  extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm
  {
    vxorps  xmm11, xmm11, xmm11
    vmovss  [rbp+170h+extendedData.collisionBuffer], xmm11
  }
  extendedData.phaseSelection = All;
  extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  *(_WORD *)&extendedData.collectInsideHits = 256;
  v133.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm { vmovss  [rbp+170h+var_170.collisionBuffer], xmm11 }
  v133.phaseSelection = All;
  v133.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  *(_WORD *)&v133.collectInsideHits = 256;
  extendedData.contents = 41969969;
  v133.contents = 41969969;
  extendedData.ignoreBodies = &v131;
  v133.ignoreBodies = &v129;
  v24 = 1;
  if ( (unsigned int)v19 > 1 )
    v24 = 3 * Physics_GetLocalClientForWorld((Physics_WorldId)v19) + 4;
  ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v19);
  v26 = PhysicsQuery_GetClosestResult((Physics_WorldId)v24);
  v130 = v26;
  HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
  HavokPhysics_CollisionQueryResult::Reset(v26, 1);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8082, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to AddDetailTrace when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8083, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to AddDetailTrace for invalid result", "result") )
    __debugbreak();
  HavokPhysics_AddDetailTrace(v26, NULL);
  __asm
  {
    vmovss  xmm0, dword ptr [r13+0]
    vmovss  dword ptr [rbp+170h+pos], xmm0
    vmovss  xmm1, dword ptr [r13+4]
    vmovss  dword ptr [rbp+170h+pos+4], xmm1
    vmovss  xmm0, dword ptr [r13+8]
    vmovss  dword ptr [rbp+170h+pos+8], xmm0
  }
  v30 = _R13;
  v31 = *(const vec3_t **)starta.v;
  Physics_Raycast((Physics_WorldId)v19, *(const vec3_t **)starta.v, v30, &extendedData, ClosestResult);
  if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
  {
    HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(ClosestResult, 0, &pos);
    __asm
    {
      vmovss  xmm0, dword ptr [r15]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_137;
    __asm
    {
      vmovss  xmm0, dword ptr [r15+4]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_137;
    __asm
    {
      vmovss  xmm0, dword ptr [r15+8]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    {
LABEL_137:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7465, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] )") )
        __debugbreak();
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+170h+pos]
    vsubss  xmm7, xmm0, dword ptr [r13+0]
    vmovss  xmm1, dword ptr [rbp+170h+pos+4]
    vsubss  xmm8, xmm1, dword ptr [r13+4]
    vmovss  xmm0, dword ptr [rbp+170h+pos+8]
    vsubss  xmm10, xmm0, dword ptr [r13+8]
    vmulss  xmm2, xmm8, xmm8
    vmulss  xmm1, xmm7, xmm7
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm10, xmm10
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm9, xmm2, xmm2
    vcmpless xmm0, xmm9, cs:__real@80000000
    vmovss  xmm2, cs:__real@3f800000
    vblendvps xmm1, xmm9, xmm2, xmm0
    vmovss  dword ptr [rbp+170h+start], xmm1
    vdivss  xmm6, xmm2, xmm1
  }
  *(double *)&_XMM0 = HavokPhysics_GetDetailBoundingSphereMax((Physics_WorldId)v24);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@42000000
    vmulss  xmm3, xmm1, cs:__real@40000000
    vmulss  xmm2, xmm6, xmm7
    vmulss  xmm0, xmm2, xmm3
    vaddss  xmm1, xmm0, dword ptr [rbp+170h+pos]
    vmovss  dword ptr [rbp+170h+start], xmm1
    vmulss  xmm2, xmm6, xmm8
    vmulss  xmm0, xmm2, xmm3
    vaddss  xmm1, xmm0, dword ptr [rbp+170h+pos+4]
    vmovss  dword ptr [rbp+170h+start+4], xmm1
    vmulss  xmm2, xmm6, xmm10
    vmulss  xmm0, xmm2, xmm3
    vaddss  xmm1, xmm0, dword ptr [rbp+170h+pos+8]
    vmovss  [rbp+170h+var_118], xmm1
    vaddss  xmm2, xmm9, xmm3
    vdivss  xmm6, xmm9, xmm2
  }
  Physics_Raycast((Physics_WorldId)v24, v31, &starta, &v133, v26);
  if ( !HavokPhysics_CollisionQueryResult::HasHit(v26) )
    goto LABEL_117;
  *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(v26, 0);
  __asm { vcomiss xmm0, xmm6 }
  if ( !v64 )
  {
LABEL_117:
    if ( !HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
      goto LABEL_92;
    HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(ClosestResult, 0, hitPos);
    __asm
    {
      vmovss  xmm0, dword ptr [r15]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_133;
    __asm
    {
      vmovss  xmm0, dword ptr [r15+4]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_133;
    __asm
    {
      vmovss  xmm0, dword ptr [r15+8]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    {
LABEL_133:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7609, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] )") )
        __debugbreak();
    }
    *v127 = HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(ClosestResult, 0);
    HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(ClosestResult, 0, hitNormal);
    __asm
    {
      vmovss  xmm0, dword ptr [r14]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_134;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+4]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
      goto LABEL_134;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+8]
      vmovss  dword ptr [rbp+170h+start], xmm0
    }
    if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    {
LABEL_134:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7612, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] )") )
        __debugbreak();
    }
    RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(ClosestResult, 0);
    RigidBodyName = Physics_GetRigidBodyName((Physics_WorldId)v19, RaycastHitBodyId);
    if ( (Physics_GetRef((Physics_WorldId)v19, RaycastHitBodyId) & 0x3E000000) == 201326592 )
      RigidBodyName = Physics_GetRagdollBoneName(RigidBodyName);
    *v128 = SL_FindString(RigidBodyName);
    *v126 = HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(ClosestResult, 0);
    goto LABEL_93;
  }
  HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(v26, 0, hitPos);
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    goto LABEL_135;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    goto LABEL_135;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
  {
LABEL_135:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7488, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] )") )
      __debugbreak();
  }
  *v127 = HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(v26, 0);
  HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(v26, 0, hitNormal);
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    goto LABEL_136;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
    goto LABEL_136;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  dword ptr [rbp+170h+start], xmm0
  }
  if ( (LODWORD(starta.v[0]) & 0x7F800000) == 2139095040 )
  {
LABEL_136:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7491, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] )") )
      __debugbreak();
  }
  physicsSystemDetailId = -1;
  physicsSystemId = -1;
  LODWORD(starta.v[0]) = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(v26, 0);
  Ref = Physics_GetRef((Physics_WorldId)v24, LODWORD(starta.v[0]));
  v74 = (Ref >> 25) & 0x1F;
  RagdollBoneName = Physics_GetRigidBodyName((Physics_WorldId)v24, LODWORD(starta.v[0]));
  if ( v74 == 6 )
    RagdollBoneName = Physics_GetRagdollBoneName(RagdollBoneName);
  *v128 = SL_FindString(RagdollBoneName);
  if ( PhysicsCoverWall_IsCoverWall((Physics_WorldId)v19, Ref) )
    goto LABEL_92;
  v76 = v74 - 1;
  if ( !v76 )
  {
    LocalClientForWorld = Physics_GetLocalClientForWorld((Physics_WorldId)v19);
    DynEnt_GetBasisAndDynEntClientId(Ref, basisOut, (unsigned __int16 *)&basisOut[4]);
    v88 = basisOut[0];
    v89 = *(_WORD *)&basisOut[4];
    if ( (unsigned int)LocalClientForWorld >= 2 )
    {
      LODWORD(siblings) = 2;
      LODWORD(parent) = LocalClientForWorld;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 322, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", parent, siblings) )
        __debugbreak();
    }
    if ( (unsigned __int8)v88 >= DYNENT_BASIS_COUNT )
    {
      LODWORD(siblings) = 2;
      LODWORD(parent) = (unsigned __int8)v88;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 323, ASSERT_TYPE_ASSERT, "(unsigned)( basis ) < (unsigned)( DYNENT_BASIS_COUNT )", "basis doesn't index DYNENT_BASIS_COUNT\n\t%i not in [0, %i)", parent, siblings) )
        __debugbreak();
    }
    v90 = (unsigned __int8)v88 + 2 * LocalClientForWorld;
    v91 = g_dynEntClientEntsAllocCount[0][v90];
    if ( v89 >= v91 )
    {
      LODWORD(siblings) = v91;
      LODWORD(parent) = v89;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 324, ASSERT_TYPE_ASSERT, "(unsigned)( clientId ) < (unsigned)( g_dynEntClientEntsAllocCount[localClientNum][basis] )", "clientId doesn't index g_dynEntClientEntsAllocCount[localClientNum][basis]\n\t%i not in [0, %i)", parent, siblings) )
        __debugbreak();
    }
    if ( !g_dynEntClientLists[0][v90] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 325, ASSERT_TYPE_ASSERT, "(g_dynEntClientLists[localClientNum][basis])", (const char *)&queryFormat, "g_dynEntClientLists[localClientNum][basis]") )
      __debugbreak();
    v92 = &g_dynEntClientLists[0][v90][v89];
    if ( !v92 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7548, ASSERT_TYPE_ASSERT, "(dynEntClient)", (const char *)&queryFormat, "dynEntClient") )
      __debugbreak();
    physicsSystemDetailId = v92->physicsSystemDetailId;
    physicsSystemId = v92->physicsSystemId;
LABEL_66:
    if ( physicsSystemDetailId != -1 )
      goto LABEL_69;
    goto LABEL_67;
  }
  v77 = v76 - 1;
  if ( !v77 )
    goto LABEL_47;
  v78 = v77 - 2;
  if ( !v78 )
  {
    v82 = truncate_cast<unsigned short,int>((unsigned __int16)Ref);
    v83 = Physics_GetLocalClientForWorld((Physics_WorldId)v19);
    Handler = CgHandler::getHandler(v83);
    Base = (PhysicsObject *)Handler->GetPhysicsObject(Handler, v82, v83);
    if ( !Base && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7524, ASSERT_TYPE_ASSERT, "(physObj)", (const char *)&queryFormat, "physObj") )
      __debugbreak();
    goto LABEL_46;
  }
  v79 = v78 - 5;
  if ( !v79 )
  {
LABEL_47:
    v86 = truncate_cast<unsigned short,int>((unsigned __int16)Ref);
    Base = G_PhysicsObject_GetBase(v86, LOCAL_CLIENT_INVALID);
    if ( !Base && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7535, ASSERT_TYPE_ASSERT, "(physObj)", (const char *)&queryFormat, "physObj") )
    {
      __debugbreak();
      physicsSystemDetailId = *(_DWORD *)(4i64 * v24 + 4);
      physicsSystemId = *(_DWORD *)(4 * v19 + 4);
      goto LABEL_66;
    }
LABEL_46:
    physicsSystemDetailId = Base->physicsInstances[v24];
    physicsSystemId = Base->physicsInstances[v19];
    goto LABEL_66;
  }
  if ( v79 == 1 )
  {
    v80 = truncate_cast<unsigned short,int>((unsigned __int16)Ref);
    v81 = Physics_GetLocalClientForWorld((Physics_WorldId)v19);
    physicsSystemId = CG_ClientModel_Physics_GetInstanceId(v81, v80);
    physicsSystemDetailId = CG_ClientModel_Physics_GetDetailInstanceId(v81, v80);
    goto LABEL_66;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7565, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported ref system") )
    __debugbreak();
LABEL_67:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7567, ASSERT_TYPE_ASSERT, "(detailInstanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "detailInstanceId != PHYSICSINSTANCEID_INVALID") )
    __debugbreak();
LABEL_69:
  if ( physicsSystemId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7568, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != PHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5832, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Instance model Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v19 > 7 )
  {
    LODWORD(siblings) = v19;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5833, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", siblings) )
      __debugbreak();
  }
  if ( physicsSystemId == -1 )
  {
    LODWORD(siblings) = v19;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5834, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Instance model Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", siblings) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v19 - 2) <= 5 )
  {
    LODWORD(siblings) = v19;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5835, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", siblings) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v19 <= 1 )
  {
    LODWORD(siblings) = v19;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5836, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", siblings) )
      __debugbreak();
  }
  InstanceXModel = HavokPhysics_GetInstanceXModel((Physics_WorldId)v19, physicsSystemId);
  if ( InstanceXModel )
  {
    v134.simplify = 0;
    v134.ignoreBodies = NULL;
    v134.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
    __asm { vmovss  [rbp+170h+var_148.collisionBuffer], xmm11 }
    v134.phaseSelection = All;
    v134.contents = 41969969;
    __asm { vmovss  xmm3, cs:maxRange; radius }
    PhysicsQuery_ImmediateQueryPointWorst((Physics_WorldId)v19, physicsSystemId, hitPos, *(const float *)&_XMM3, &v134, &hit);
    if ( !hit.isValid )
    {
      __asm
      {
        vmovss  xmm3, cs:maxRange
        vcvtss2sd xmm3, xmm3, xmm3
        vmovq   r9, xmm3
      }
      Com_PrintWarning(14, "Probable bad art asset - %s: No dynamic body in range %.2f of detail body. Check ColLod and physics asset for this model\n", InstanceXModel->name, _R9);
LABEL_92:
      RaycastHitBodyId = 0xFFFFFF;
      goto LABEL_93;
    }
    *v126 = hit.shapeKey;
    RaycastHitBodyId = hit.bodyId;
  }
  else
  {
    NumRigidBodys = Physics_GetNumRigidBodys((const Physics_WorldId)v24, physicsSystemDetailId);
    name = "Unknown";
    if ( NumRigidBodys != Physics_GetNumRigidBodys((const Physics_WorldId)v19, physicsSystemId) )
    {
      v113 = Physics_GetInstanceAsset((Physics_WorldId)v19, physicsSystemId) ? Physics_GetInstanceAsset((Physics_WorldId)v19, physicsSystemId)->name : "Unknown";
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7591, ASSERT_TYPE_ASSERT, "(numBodies == Physics_GetNumRigidBodys( worldId, instanceId ))", "%s\n\tDetail and Simulation physics body count mismatch for %s", "numBodies == Physics_GetNumRigidBodys( worldId, instanceId )", v113) )
        __debugbreak();
    }
    v114 = 0;
    if ( !NumRigidBodys )
    {
LABEL_112:
      if ( Physics_GetInstanceAsset((Physics_WorldId)v19, physicsSystemId) )
        name = Physics_GetInstanceAsset((Physics_WorldId)v19, physicsSystemId)->name;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7602, ASSERT_TYPE_ASSERT, "(false)", "%s\n\tCouldn't find Detail body for %s", "false", name) )
        __debugbreak();
      goto LABEL_92;
    }
    while ( Physics_GetRigidBodyID((const Physics_WorldId)v24, physicsSystemDetailId, v114) != LODWORD(starta.v[0]) )
    {
      if ( ++v114 >= NumRigidBodys )
        goto LABEL_112;
    }
    RaycastHitShapeKey = HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(v130, 0);
    *v126 = RaycastHitShapeKey;
    RaycastHitBodyId = Physics_GetRigidBodyID((const Physics_WorldId)v19, physicsSystemId, v114);
  }
LABEL_93:
  v99 = hkMemHeapAllocator();
  v129.m_ignoreBodies.m_size = 0;
  if ( v129.m_ignoreBodies.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v99, v129.m_ignoreBodies.m_data, 4, v129.m_ignoreBodies.m_capacityAndFlags & 0x3FFFFFFF);
  v129.m_ignoreBodies.m_data = NULL;
  v129.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
  v100 = hkMemHeapAllocator();
  v129.m_ignoreEntities.m_size = 0;
  if ( v129.m_ignoreEntities.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v100, v129.m_ignoreEntities.m_data, 8, v129.m_ignoreEntities.m_capacityAndFlags & 0x3FFFFFFF);
  v129.m_ignoreEntities.m_data = NULL;
  v129.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
  v101 = hkMemHeapAllocator();
  v131.m_ignoreBodies.m_size = 0;
  if ( v131.m_ignoreBodies.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v101, v131.m_ignoreBodies.m_data, 4, v131.m_ignoreBodies.m_capacityAndFlags & 0x3FFFFFFF);
  v131.m_ignoreBodies.m_data = NULL;
  v131.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
  v102 = hkMemHeapAllocator();
  v131.m_ignoreEntities.m_size = 0;
  if ( v131.m_ignoreEntities.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v102, v131.m_ignoreEntities.m_data, 8, v131.m_ignoreEntities.m_capacityAndFlags & 0x3FFFFFFF);
  result = RaycastHitBodyId;
  _R11 = &v139;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
  }
  return result;
}

/*
==============
Physics_ApplyImpulse
==============
*/
void Physics_ApplyImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec3_t *normalizedDirection, float magnitude)
{
  bool v18; 
  bool v19; 
  bool v20; 
  float fmt; 
  __int64 v46; 
  Physics_WorldId v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  hkVector4f hkPosition; 
  hkVector4f hkDirection; 
  char v56; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RBX = normalizedDirection;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7004, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply impulse to a Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v47 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7005, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v47) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v46) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7006, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v46) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
  {
LABEL_29:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7007, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  v18 = (v53 & 0x7F800000u) < 0x7F800000;
  v19 = (v53 & 0x7F800000) == 2139095040;
  if ( (v53 & 0x7F800000) == 2139095040 )
  {
LABEL_30:
    v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7008, ASSERT_TYPE_ASSERT, "(!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid direction", "!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] )");
    v18 = 0;
    v19 = !v20;
    if ( v20 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm7, [rsp+0A8h+magnitude]
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm7, xmm6
  }
  if ( !v19 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  xmm2, dword ptr [rbx+4]
      vmovss  xmm3, dword ptr [rbx+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsubss  xmm0, xmm2, cs:__real@3f800000
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm0, cs:__real@3b03126f
    }
    if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7009, ASSERT_TYPE_ASSERT, "(magnitude == 0.f || Vec3IsNormalized( normalizedDirection ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with non normal direction", "magnitude == 0.f || Vec3IsNormalized( normalizedDirection )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm { vucomiss xmm7, xmm6 }
  if ( !v19 )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@3d000000
      vmulss  xmm0, xmm3, dword ptr [rdi]
      vmulss  xmm2, xmm3, dword ptr [rdi+4]
      vmulss  xmm1, xmm3, dword ptr [rdi+8]
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad], xmm0
      vxorps  xmm0, xmm0, xmm0
      vinsertps xmm0, xmm0, dword ptr [rbx], 0
      vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
      vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
      vmovups xmmword ptr [rsp+0A8h+hkDirection.m_quad], xmm0
      vmulss  xmm0, xmm7, xmm3
      vmovss  dword ptr [rsp+0A8h+fmt], xmm0
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+4], xmm2
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+8], xmm1
      vmovss  dword ptr [rsp+0A8h+hkPosition.m_quad+0Ch], xmm6
    }
    HavokPhysics_ApplyImpulse(worldId, (hknpBodyId)bodyId, &hkPosition, &hkDirection, fmt);
  }
  _R11 = &v56;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Physics_ApplyLinearImpulse
==============
*/

void __fastcall Physics_ApplyLinearImpulse(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *normalizedDirection, double magnitude)
{
  bool v12; 
  bool v13; 
  bool v14; 
  __int64 v33; 
  Physics_WorldId v34; 
  int v35; 
  int v36; 
  int v37; 
  hkVector4f hkDirection; 
  char v40; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RBX = normalizedDirection;
  __asm { vmovaps xmm7, xmm3 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7037, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply impulse to a Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v34 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7038, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v34) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7039, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v33) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v35 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  v12 = (v37 & 0x7F800000u) < 0x7F800000;
  v13 = (v37 & 0x7F800000) == 2139095040;
  if ( (v37 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7040, ASSERT_TYPE_ASSERT, "(!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with invalid direction", "!IS_NAN( normalizedDirection[0] ) && !IS_NAN( normalizedDirection[1] ) && !IS_NAN( normalizedDirection[2] )");
    v12 = 0;
    v13 = !v14;
    if ( v14 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm7, xmm6
  }
  if ( !v13 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  xmm2, dword ptr [rbx+4]
      vmovss  xmm3, dword ptr [rbx+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsubss  xmm0, xmm2, cs:__real@3f800000
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm0, cs:__real@3b03126f
    }
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7041, ASSERT_TYPE_ASSERT, "(magnitude == 0.f || Vec3IsNormalized( normalizedDirection ))", "%s\n\tPhysics: Trying to Apply impulse to a Body with non normal direction", "magnitude == 0.f || Vec3IsNormalized( normalizedDirection )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm { vucomiss xmm7, xmm6 }
  if ( !v13 )
  {
    __asm
    {
      vmulss  xmm3, xmm7, cs:__real@3d000000; magnitude
      vxorps  xmm0, xmm0, xmm0
      vinsertps xmm0, xmm0, dword ptr [rbx], 0
      vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
      vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
      vmovups xmmword ptr [rsp+98h+hkDirection.m_quad], xmm0
    }
    HavokPhysics_ApplyLinearImpulse(worldId, (hknpBodyId)bodyId, &hkDirection, *(float *)&_XMM3);
  }
  _R11 = &v40;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
  }
}

/*
==============
Physics_ApplyRadiusForce
==============
*/

void __fastcall Physics_ApplyRadiusForce(const Physics_WorldId worldId, const vec3_t *position, double radius, double innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, unsigned int randSeed, float forceScalar)
{
  bool v28; 
  bool v29; 
  bool v30; 
  char v35; 
  HavokPhysics_CollisionQueryResult *AllResult; 
  const dvar_t *v91; 
  int integer; 
  signed int NumHits; 
  int v94; 
  int v95; 
  HavokPhysics_CollisionQueryResult *v96; 
  unsigned int AABBQueryHitBodyId; 
  int Ref; 
  int v100; 
  Ragdoll *Ragdoll; 
  char v103; 
  const dvar_t *v126; 
  const dvar_t *v130; 
  unsigned int v184; 
  bool v185; 
  int v190; 
  unsigned __int16 v191; 
  unsigned int v194; 
  hkMemoryAllocator *v195; 
  hkMemoryAllocator *v196; 
  float fmt; 
  float fmta; 
  float v210; 
  __int64 v211; 
  double v212; 
  __int64 v213; 
  double v214; 
  bool v215; 
  int v216; 
  int v217; 
  int v218; 
  unsigned int v219; 
  float mass; 
  int v221; 
  HavokPhysics_CollisionQueryResult *v228; 
  Physics_AABBQueryExtendedData extendedData; 
  HavokPhysics_IgnoreBodies v230; 
  __int64 v231; 
  vec3_t min; 
  vec3_t positiona; 
  vec3_t max; 
  vec3_t impulseDirOverride; 
  vec4_t orientation; 
  char v237; 
  void *retaddr; 

  _RAX = &retaddr;
  v231 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
    vmovaps xmmword ptr [rax-0B8h], xmm12
    vmovaps xmmword ptr [rax-0C8h], xmm13
    vmovaps xmmword ptr [rax-0D8h], xmm14
    vmovaps xmmword ptr [rax-0E8h], xmm15
    vmovaps xmm13, xmm3
    vmovss  [rsp+200h+var_1B0], xmm3
    vmovaps xmm15, xmm2
  }
  _R12 = position;
  _RBX = impulseVecOverride;
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_ApplyRadiusForce");
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7133, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Apply radius force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7134, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Apply radius force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r12]
    vmovss  [rsp+200h+var_1BC], xmm0
  }
  if ( (v216 & 0x7F800000) == 2139095040 )
    goto LABEL_95;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+4]
    vmovss  [rsp+200h+var_1BC], xmm0
  }
  if ( (v217 & 0x7F800000) == 2139095040 )
    goto LABEL_95;
  __asm
  {
    vmovss  xmm0, dword ptr [r12+8]
    vmovss  [rsp+200h+var_1BC], xmm0
  }
  v28 = (v218 & 0x7F800000u) < 0x7F800000;
  v29 = (v218 & 0x7F800000u) <= 0x7F800000;
  if ( (v218 & 0x7F800000) == 2139095040 )
  {
LABEL_95:
    v30 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7135, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Apply radius force with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )");
    v28 = 0;
    v29 = !v30;
    if ( v30 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vmovss  xmm6, [rbp+100h+forceScalar]
    vcomiss xmm6, xmm9
  }
  if ( v28 )
    goto LABEL_96;
  __asm { vcomiss xmm6, cs:__real@40000000 }
  if ( !v29 )
  {
LABEL_96:
    __asm
    {
      vcvtss2sd xmm1, xmm6, xmm6
      vmovsd  xmm0, cs:__real@4000000000000000
      vmovsd  [rsp+200h+var_1C8], xmm0
      vmovsd  [rsp+200h+var_1D0], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7136, ASSERT_TYPE_ASSERT, "(forceScalar >= 0.0f && forceScalar <= PHYSICS_MAX_RADIUSFORCE_SCALAR)", "%s\n\tPhysics: forceScalar=%.2f is out of allowed range [0, %.2f]", "forceScalar >= 0.0f && forceScalar <= PHYSICS_MAX_RADIUSFORCE_SCALAR", v212, v214) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmulss  xmm0, xmm6, cs:__real@41200000
    vmovss  [rsp+200h+var_1A4], xmm0
    vmovss  xmm4, dword ptr [rbx+4]
    vmovss  xmm3, dword ptr [rbx]
    vmovss  xmm5, dword ptr [rbx+8]
    vmulss  xmm1, xmm3, xmm3
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm6, xmm2, xmm2
    vmovss  [rsp+200h+var_1A8], xmm6
    vmovss  xmm11, cs:__real@80000000
    vcmpless xmm0, xmm6, xmm11
    vmovss  xmm10, cs:__real@3f800000
    vblendvps xmm1, xmm6, xmm10, xmm0
    vmovss  [rsp+200h+var_1AC], xmm1
    vdivss  xmm2, xmm10, xmm1
    vmulss  xmm0, xmm3, xmm2
    vmovss  dword ptr [rbp+100h+impulseDirOverride], xmm0
    vmulss  xmm1, xmm4, xmm2
    vmovss  dword ptr [rbp+100h+impulseDirOverride+4], xmm1
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rbp+100h+impulseDirOverride+8], xmm0
    vucomiss xmm13, xmm9
  }
  if ( !v35 )
    goto LABEL_18;
  __asm { vucomiss xmm6, xmm9 }
  v215 = 1;
  if ( v35 )
LABEL_18:
    v215 = 0;
  BG_srand(&randSeed);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 42, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Gravity when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v211) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Gravity with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v211) )
      __debugbreak();
    LODWORD(v213) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 95, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Gravity with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v213) )
      __debugbreak();
  }
  _RCX = HavokPhysics_GetConstWorld(worldId)->world;
  __asm
  {
    vmovups xmm2, xmmword ptr [rcx+0AC0h]
    vmovss  xmm1, cs:__real@42000000
    vmulss  xmm6, xmm2, xmm1
    vshufps xmm0, xmm2, xmm2, 55h ; 'U'
    vmulss  xmm5, xmm0, xmm1
    vshufps xmm2, xmm2, xmm2, 0AAh ; ''
    vmulss  xmm4, xmm2, xmm1
    vmulss  xmm1, xmm5, xmm5
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm4, xmm4
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm3, xmm2, xmm2
    vcmpless xmm0, xmm3, xmm11
    vblendvps xmm1, xmm3, xmm10, xmm0
    vmovss  [rsp+200h+var_1AC], xmm1
    vdivss  xmm0, xmm10, xmm1
    vmulss  xmm6, xmm6, xmm0
    vmulss  xmm7, xmm5, xmm0
    vmulss  xmm8, xmm4, xmm0
  }
  _RBX = DCONST_DVARFLT_physics_RadiusForceUpBias;
  if ( !DCONST_DVARFLT_physics_RadiusForceUpBias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_RadiusForceUpBias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vmulss  xmm0, xmm6, xmm1
    vmovss  dword ptr [rsp+200h+var_1A0], xmm0
    vmulss  xmm0, xmm7, xmm1
    vmovss  dword ptr [rsp+200h+var_1A0+4], xmm0
    vmulss  xmm0, xmm8, xmm1
    vmovss  [rsp+200h+var_1AC], xmm0
    vmulss  xmm6, xmm15, xmm15
    vmovss  xmm4, dword ptr [r12]
    vsubss  xmm0, xmm4, xmm15
    vmovss  dword ptr [rbp+100h+min], xmm0
    vmovss  xmm3, dword ptr [r12+4]
    vsubss  xmm0, xmm3, xmm15
    vmovss  dword ptr [rbp+100h+min+4], xmm0
    vmovss  xmm2, dword ptr [r12+8]
    vsubss  xmm0, xmm2, xmm15
    vmovss  dword ptr [rbp+100h+min+8], xmm0
    vaddss  xmm1, xmm15, xmm4
    vmovss  dword ptr [rbp+100h+max], xmm1
    vaddss  xmm0, xmm15, xmm3
    vmovss  dword ptr [rbp+100h+max+4], xmm0
    vaddss  xmm1, xmm15, xmm2
    vmovss  dword ptr [rbp+100h+max+8], xmm1
  }
  HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(&v230, 0, 0);
  HavokPhysics_IgnoreBodies::SetIgnoreRefs(&v230, -1751);
  __asm { vmovss  [rbp+100h+extendedData.collisionBuffer], xmm9 }
  extendedData.phaseSelection = All;
  extendedData.contents = 41969969;
  extendedData.simplify = 1;
  extendedData.ignoreBodies = &v230;
  AllResult = PhysicsQuery_GetAllResult(worldId);
  v228 = AllResult;
  HavokPhysics_CollisionQueryResult::Reset(AllResult, 1);
  Physics_AABBQuery(worldId, &min, &max, &extendedData, AllResult);
  HavokPhysics_CollisionQueryResult::SortResults(AllResult);
  v91 = DVARINT_physics_RadiusForceHitLimit;
  if ( !DVARINT_physics_RadiusForceHitLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_RadiusForceHitLimit") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v91);
  integer = v91->current.integer;
  NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(AllResult);
  if ( NumHits < integer )
    integer = NumHits;
  v221 = integer;
  v94 = 0;
  v95 = 0;
  v219 = 0;
  v96 = v228;
  if ( HavokPhysics_CollisionQueryResult::GetNumHits(v228) )
  {
    __asm { vmovss  xmm8, cs:__real@bf800000 }
    do
    {
      if ( v94 >= integer )
        break;
      AABBQueryHitBodyId = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(v96, v95);
      if ( (AABBQueryHitBodyId & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7189, ASSERT_TYPE_ASSERT, "( Physics_IsRigidBodyIdValid( bodyId ) )", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
        __debugbreak();
      if ( Physics_IsRigidBodyDynamic(worldId, AABBQueryHitBodyId) )
      {
        Ref = Physics_GetRef(worldId, AABBQueryHitBodyId);
        v100 = Ref;
        Ragdoll = NULL;
        if ( (Ref & 0x3E000000) != 201326592 )
          goto LABEL_47;
        Ragdoll = Ragdoll_GetRagdoll((unsigned int)BYTE2(Ref) + 1);
        if ( !Ragdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7204, ASSERT_TYPE_ASSERT, "(ragdoll)", (const char *)&queryFormat, "ragdoll") )
          __debugbreak();
        __asm { vmovaps xmm1, xmm15; radius }
        if ( Ragdoll_CheckApplyRadiusForce(Ragdoll, *(const float *)&_XMM1) )
        {
LABEL_47:
          Physics_GetRigidBodyTransform(worldId, AABBQueryHitBodyId, &max, &orientation);
          __asm
          {
            vmovss  xmm0, dword ptr [r12]
            vmovss  xmm11, dword ptr [rbp+100h+max]
            vsubss  xmm4, xmm0, xmm11
            vmovss  xmm1, dword ptr [r12+4]
            vmovss  xmm12, dword ptr [rbp+100h+max+4]
            vsubss  xmm2, xmm1, xmm12
            vmovss  xmm0, dword ptr [r12+8]
            vmovss  xmm14, dword ptr [rbp+100h+max+8]
            vsubss  xmm3, xmm0, xmm14
            vmulss  xmm1, xmm2, xmm2
            vmulss  xmm0, xmm4, xmm4
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm3, xmm3
            vaddss  xmm2, xmm2, xmm1
            vdivss  xmm0, xmm2, xmm6
            vsubss  xmm1, xmm10, xmm0
            vcomiss xmm1, xmm9
          }
          if ( !(v28 | v103) )
          {
            __asm { vucomiss xmm13, xmm9 }
            if ( v103 )
            {
              __asm
              {
                vmulss  xmm0, xmm1, [rbp+100h+impulseOverride]
                vmaxss  xmm2, xmm0, [rsp+200h+var_1A8]
              }
            }
            else
            {
              __asm
              {
                vsubss  xmm0, xmm10, xmm1
                vmulss  xmm2, xmm0, [rbp+100h+outerDamage]
                vmulss  xmm1, xmm1, xmm13
                vaddss  xmm2, xmm2, xmm1
              }
            }
            __asm { vmulss  xmm6, xmm2, [rsp+200h+var_1A4] }
            v126 = DCONST_DVARFLT_physics_RadiusForceMax;
            if ( !DCONST_DVARFLT_physics_RadiusForceMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_RadiusForceMax") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v126);
            __asm { vminss  xmm13, xmm6, dword ptr [rbx+28h] }
            if ( (v100 & 0x3E000000) != 201326592 )
              goto LABEL_59;
            if ( !Ragdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7239, ASSERT_TYPE_ASSERT, "(ragdoll)", (const char *)&queryFormat, "ragdoll") )
              __debugbreak();
            __asm
            {
              vmovss  [rsp+200h+var_1D8], xmm13
              vmovaps xmm2, xmm15; radius
            }
            if ( !Ragdoll_ApplyFullBodyRadiusForce(Ragdoll, _R12, *(const float *)&_XMM2, v215, &impulseDirOverride, v210) )
            {
LABEL_59:
              __asm
              {
                vunpcklps xmm0, xmm11, xmm12
                vmovsd  qword ptr [rbp+100h+max], xmm0
                vmovsd  qword ptr [rbp+100h+position], xmm0
              }
              positiona.v[2] = max.v[2];
              v130 = DCONST_DVARFLT_physics_RadiusForceUpOffset;
              if ( !DCONST_DVARFLT_physics_RadiusForceUpOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_RadiusForceUpOffset") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v130);
              __asm
              {
                vmovss  xmm0, dword ptr [rbp+100h+position+8]
                vaddss  xmm1, xmm0, dword ptr [rbx+28h]
                vmovss  dword ptr [rbp+100h+position+8], xmm1
                vmovaps xmm1, xmm10; max
                vmovaps xmm0, xmm8; min
              }
              *(double *)&_XMM0 = BG_flrand(*(float *)&_XMM0, *(float *)&_XMM1, &randSeed);
              __asm
              {
                vmovaps xmm6, xmm0
                vmovaps xmm1, xmm10; max
                vmovaps xmm0, xmm8; min
              }
              *(double *)&_XMM0 = BG_flrand(*(float *)&_XMM0, *(float *)&_XMM1, &randSeed);
              __asm
              {
                vmovaps xmm7, xmm0
                vmovaps xmm1, xmm10; max
                vmovaps xmm0, xmm8; min
              }
              *(double *)&_XMM0 = BG_flrand(*(float *)&_XMM0, *(float *)&_XMM1, &randSeed);
              __asm { vmovaps xmm8, xmm0 }
              _RBX = DCONST_DVARFLT_physics_RadiusForceRandomOffset;
              if ( !DCONST_DVARFLT_physics_RadiusForceRandomOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_RadiusForceRandomOffset") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(_RBX);
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+28h]
                vmulss  xmm1, xmm8, xmm0
                vmulss  xmm3, xmm0, xmm7
                vmulss  xmm4, xmm0, xmm6
                vaddss  xmm1, xmm1, dword ptr [rbp+100h+position]
                vmovss  dword ptr [rbp+100h+position], xmm1
                vaddss  xmm0, xmm3, dword ptr [rbp+100h+position+4]
                vmovss  dword ptr [rbp+100h+position+4], xmm0
                vaddss  xmm2, xmm4, dword ptr [rbp+100h+position+8]
                vmovss  dword ptr [rbp+100h+position+8], xmm2
              }
              if ( v215 )
              {
                __asm
                {
                  vmovsd  xmm0, qword ptr [rbp+100h+impulseDirOverride]
                  vmovsd  qword ptr [rbp+100h+min], xmm0
                }
                min.v[2] = impulseDirOverride.v[2];
              }
              else
              {
                __asm
                {
                  vsubss  xmm4, xmm11, dword ptr [r12]
                  vsubss  xmm5, xmm12, dword ptr [r12+4]
                  vsubss  xmm6, xmm14, dword ptr [r12+8]
                  vmulss  xmm1, xmm5, xmm5
                  vmulss  xmm0, xmm4, xmm4
                  vaddss  xmm2, xmm1, xmm0
                  vmulss  xmm1, xmm6, xmm6
                  vaddss  xmm2, xmm2, xmm1
                  vsqrtss xmm3, xmm2, xmm2
                  vcmpless xmm0, xmm3, cs:__real@80000000
                  vblendvps xmm1, xmm3, xmm10, xmm0
                  vmovss  [rsp+200h+mass], xmm1
                  vdivss  xmm2, xmm10, xmm1
                  vmulss  xmm0, xmm2, xmm4
                  vaddss  xmm7, xmm0, dword ptr [rsp+200h+var_1A0]
                  vmulss  xmm1, xmm2, xmm5
                  vaddss  xmm5, xmm1, dword ptr [rsp+200h+var_1A0+4]
                  vmulss  xmm0, xmm2, xmm6
                  vaddss  xmm6, xmm0, [rsp+200h+var_1AC]
                  vmulss  xmm2, xmm5, xmm5
                  vmulss  xmm1, xmm7, xmm7
                  vaddss  xmm3, xmm2, xmm1
                  vmulss  xmm0, xmm6, xmm6
                  vaddss  xmm2, xmm3, xmm0
                  vsqrtss xmm4, xmm2, xmm2
                  vcmpless xmm0, xmm4, cs:__real@80000000
                  vblendvps xmm1, xmm4, xmm10, xmm0
                  vmovss  [rsp+200h+mass], xmm1
                  vdivss  xmm2, xmm10, xmm1
                  vmulss  xmm0, xmm2, xmm7
                  vmovss  dword ptr [rbp+100h+min], xmm0
                  vmulss  xmm1, xmm2, xmm5
                  vmovss  dword ptr [rbp+100h+min+4], xmm1
                  vmulss  xmm0, xmm2, xmm6
                  vmovss  dword ptr [rbp+100h+min+8], xmm0
                  vucomiss xmm4, xmm9
                  vmovss  dword ptr [rbp+100h+min], xmm9
                  vmovss  dword ptr [rbp+100h+min+4], xmm9
                  vmovss  dword ptr [rbp+100h+min+8], xmm10
                }
              }
              __asm { vmovss  [rsp+200h+mass], xmm9 }
              Physics_GetRigidBodyMass(worldId, AABBQueryHitBodyId, &mass);
              __asm
              {
                vmovss  xmm0, [rsp+200h+mass]
                vcomiss xmm0, xmm9
              }
              if ( v28 | v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7276, ASSERT_TYPE_ASSERT, "(bodyMass > 0.f)", (const char *)&queryFormat, "bodyMass > 0.f") )
                __debugbreak();
              __asm { vmovaps xmm6, xmm10 }
              v184 = *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64);
              v185 = dword_14B804C40 < v184;
              if ( dword_14B804C40 > (int)v184 )
              {
                j__Init_thread_header(&dword_14B804C40);
                v185 = dword_14B804C40 != -1;
                if ( dword_14B804C40 == -1 )
                {
                  *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_physics_RadiusForceMassLimit, "physics_RadiusForceMassLimit");
                  __asm { vmovss  cs:massLimit, xmm0 }
                  j__Init_thread_footer(&dword_14B804C40);
                }
              }
              __asm
              {
                vmovss  xmm0, cs:massLimit
                vmovss  xmm1, [rsp+200h+mass]
                vcomiss xmm1, xmm0
              }
              if ( v185 )
                __asm { vdivss  xmm6, xmm1, xmm0 }
              __asm
              {
                vmulss  xmm6, xmm13, xmm6
                vmovss  dword ptr [rsp+200h+fmt], xmm6
              }
              Physics_ApplyImpulse(worldId, AABBQueryHitBodyId, &positiona, &min, fmt);
              v190 = v94 + 1;
              if ( (v100 & 0x3E000000) == 201326592 )
                v190 = v94;
              v94 = v190;
              if ( (v100 & 0x3E000000) == 201326592 )
              {
                if ( !Ragdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7300, ASSERT_TYPE_ASSERT, "(ragdoll)", (const char *)&queryFormat, "ragdoll") )
                  __debugbreak();
                v191 = truncate_cast<unsigned short,int>((unsigned __int16)v100);
                __asm
                {
                  vdivss  xmm0, xmm6, [rsp+200h+mass]
                  vmovss  dword ptr [rsp+200h+fmt], xmm0
                }
                Ragdoll_SetDebugExplosionImpulse(Ragdoll, v191, &positiona, &min, fmta);
              }
              __asm { vmovss  xmm8, cs:__real@bf800000 }
            }
            __asm
            {
              vmulss  xmm6, xmm15, xmm15
              vmovss  xmm13, [rsp+200h+var_1B0]
            }
          }
        }
        integer = v221;
      }
      v95 = ++v219;
      v194 = HavokPhysics_CollisionQueryResult::GetNumHits(v228);
      v96 = v228;
    }
    while ( v219 < v194 );
  }
  Sys_ProfEndNamedEvent();
  v195 = hkMemHeapAllocator();
  v230.m_ignoreBodies.m_size = 0;
  if ( v230.m_ignoreBodies.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v195, v230.m_ignoreBodies.m_data, 4, v230.m_ignoreBodies.m_capacityAndFlags & 0x3FFFFFFF);
  v230.m_ignoreBodies.m_data = NULL;
  v230.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
  v196 = hkMemHeapAllocator();
  v230.m_ignoreEntities.m_size = 0;
  if ( v230.m_ignoreEntities.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v196, v230.m_ignoreEntities.m_data, 8, v230.m_ignoreEntities.m_capacityAndFlags & 0x3FFFFFFF);
  _R11 = &v237;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
    vmovaps xmm15, xmmword ptr [r11-0A8h]
  }
}

/*
==============
Physics_AreClientWorldsCreated
==============
*/
unsigned __int8 Physics_AreClientWorldsCreated(LocalClientNum_t localClientNum)
{
  int v2; 
  int v5; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v5 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2081, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( LOCAL_CLIENT_COUNT )", "localClientNum doesn't index LOCAL_CLIENT_COUNT\n\t%i not in [0, %i)", localClientNum, v5) )
      __debugbreak();
  }
  v2 = g_physicsClientWorldsCreated;
  return _bittest(&v2, localClientNum);
}

/*
==============
Physics_AreClientWorldsCreated
==============
*/
bool Physics_AreClientWorldsCreated()
{
  return g_physicsClientWorldsCreated != 0;
}

/*
==============
Physics_AreDetailModelsInterchangeable
==============
*/
bool Physics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  if ( !detailModelA && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5442, ASSERT_TYPE_ASSERT, "(detailModelA)", "%s\n\tPhysics: Trying to query NULL Detail Model", "detailModelA") )
    __debugbreak();
  if ( !detailModelA->detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5443, ASSERT_TYPE_ASSERT, "(detailModelA->detailCollision)", "%s\n\tPhysics: Trying to query Detail Model with no detail physics data", "detailModelA->detailCollision") )
    __debugbreak();
  if ( !detailModelB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5444, ASSERT_TYPE_ASSERT, "(detailModelB)", "%s\n\tPhysics: Trying to query NULL Detail Model", "detailModelB") )
    __debugbreak();
  if ( !detailModelB->detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5445, ASSERT_TYPE_ASSERT, "(detailModelB->detailCollision)", "%s\n\tPhysics: Trying to query Detail Model with no detail physics data", "detailModelB->detailCollision") )
    __debugbreak();
  return HavokPhysics_AreDetailModelsInterchangeable(detailModelA, detailModelB);
}

/*
==============
Physics_AreServerWorldsCreated
==============
*/
_BOOL8 Physics_AreServerWorldsCreated()
{
  return g_physicsServerWorldsCreated;
}

/*
==============
Physics_BatchRaycast
==============
*/
void Physics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const vec3_t *starts, const vec3_t *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  Physics_RaycastExtendedData *v7; 
  __int64 v10; 
  const dvar_t *v12; 
  unsigned int v13; 
  unsigned int v14; 
  __int64 v32; 
  int v33; 
  int v34; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  hkVector4f endsa[64]; 
  hkVector4f startsa[64]; 

  v7 = extendedData;
  v10 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8719, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire BatchRaycast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v10 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8720, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire BatchRaycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
    __debugbreak();
  if ( !starts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8721, ASSERT_TYPE_ASSERT, "(starts)", "%s\n\tPhysics: Trying to fire BatchRaycast with null starts", "starts") )
    __debugbreak();
  if ( !ends && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8722, ASSERT_TYPE_ASSERT, "(ends)", "%s\n\tPhysics: Trying to fire BatchRaycast with null ends", "ends") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8723, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire BatchRaycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !results && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8724, ASSERT_TYPE_ASSERT, "(results)", "%s\n\tPhysics: Trying to fire BatchRaycast with invalid results", "results") )
    __debugbreak();
  if ( numRays <= 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8725, ASSERT_TYPE_ASSERT, "(numRays > 1)", "%s\n\tPhysics: Trying to fire BatchRaycast with too few rays", "numRays > 1") )
    __debugbreak();
  if ( numRays > 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8726, ASSERT_TYPE_ASSERT, "(numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS)", "%s\n\tPhysics: Trying to fire BatchRaycast with too many rays", "numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v10] )
  {
    v12 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    if ( v12->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8727, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  if ( g_physicsQueriesNotAllowedForWorld[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8728, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  v13 = 64;
  if ( (int)numRays < 64 )
    v13 = numRays;
  if ( (unsigned int)v10 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v10] )
    Physics_UpdateBroadphase((Physics_WorldId)v10, 1);
  v14 = 0;
  if ( v13 )
  {
    _RDI = (char *)ends - (char *)starts;
    __asm
    {
      vmovaps [rsp+8B8h+var_48], xmm6
      vmovss  xmm6, cs:__real@3d000000
    }
    _RBX = &starts->v[2];
    _RBP = 0i64;
    do
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx-8]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v33 & 0x7F800000) == 2139095040 )
        goto LABEL_67;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx-4]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v34 & 0x7F800000) == 2139095040 )
        goto LABEL_67;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v35 & 0x7F800000) == 2139095040 )
      {
LABEL_67:
        LODWORD(v32) = v14;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8747, ASSERT_TYPE_ASSERT, "(!IS_NAN( starts[rayIdx][0] ) && !IS_NAN( starts[rayIdx][1] ) && !IS_NAN( starts[rayIdx][2] ))", "%s\n\tPhysics: Trying to fire BatchRaycast with invalid start %i", "!IS_NAN( starts[rayIdx][0] ) && !IS_NAN( starts[rayIdx][1] ) && !IS_NAN( starts[rayIdx][2] )", v32) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+rbx-8]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v36 & 0x7F800000) == 2139095040 )
        goto LABEL_68;
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+rbx-4]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v37 & 0x7F800000) == 2139095040 )
        goto LABEL_68;
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+rbx]
        vmovss  [rsp+8B8h+var_878], xmm0
      }
      if ( (v38 & 0x7F800000) == 2139095040 )
      {
LABEL_68:
        LODWORD(v32) = v14;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8748, ASSERT_TYPE_ASSERT, "(!IS_NAN( ends[rayIdx][0] ) && !IS_NAN( ends[rayIdx][1] ) && !IS_NAN( ends[rayIdx][2] ))", "%s\n\tPhysics: Trying to fire BatchRaycast with invalid end %i", "!IS_NAN( ends[rayIdx][0] ) && !IS_NAN( ends[rayIdx][1] ) && !IS_NAN( ends[rayIdx][2] )", v32) )
          __debugbreak();
      }
      __asm
      {
        vmulss  xmm1, xmm6, dword ptr [rbx-8]
        vmulss  xmm0, xmm6, dword ptr [rbx]
        vmulss  xmm2, xmm6, dword ptr [rdi+rbx]
        vmovss  dword ptr [rsp+rbp+8B8h+starts.m_quad], xmm1
        vmulss  xmm1, xmm6, dword ptr [rbx-4]
        vmovss  dword ptr [rsp+rbp+8B8h+starts.m_quad+4], xmm1
        vmulss  xmm1, xmm6, dword ptr [rdi+rbx-4]
        vmovss  dword ptr [rsp+rbp+8B8h+starts.m_quad+8], xmm0
        vmulss  xmm0, xmm6, dword ptr [rdi+rbx-8]
        vmovss  dword ptr [rsp+rbp+8B8h+ends.m_quad+4], xmm1
        vmovss  dword ptr [rsp+rbp+8B8h+ends.m_quad], xmm0
        vmovss  dword ptr [rsp+rbp+8B8h+ends.m_quad+8], xmm2
      }
      startsa[_RBP].m_quad.m128_i32[3] = 0;
      endsa[_RBP++].m_quad.m128_i32[3] = 0;
      ++v14;
      _RBX += 3;
    }
    while ( v14 < v13 );
    LODWORD(v10) = worldId;
    v7 = extendedData;
    __asm { vmovaps xmm6, [rsp+8B8h+var_48] }
  }
  switch ( (int)v10 )
  {
    case 0:
      Profile_Begin(707);
      break;
    case 1:
      Profile_Begin(708);
      break;
    case 2:
    case 5:
      Profile_Begin(709);
      break;
    case 3:
    case 6:
      Profile_Begin(710);
      break;
    case 4:
    case 7:
      Profile_Begin(711);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8793, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_BatchRaycast((Physics_WorldId)v10, v13, startsa, endsa, v7, results);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_CalcRigidBodyShapeAABBWorld
==============
*/
void Physics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax)
{
  __int64 v15; 
  Physics_WorldId v16; 
  hkAabb aabb; 

  _RSI = aabbMax;
  _RDI = aabbMin;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6274, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body aabb when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v16 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6275, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v16) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6276, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v15) )
      __debugbreak();
  }
  if ( _RDI == _RSI )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6277, ASSERT_TYPE_ASSERT, "(&aabbMin != &aabbMax)", "%s\n\tPhysics: Trying to Get Rigid Body aabb in world %i with aabbMin == aabbMax", "&aabbMin != &aabbMax", v15) )
      __debugbreak();
  }
  HavokPhysics_CalcRigidBodyShapeAABBWorld(worldId, (hknpBodyId)bodyId, &aabb);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+8]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad]
    vmovss  dword ptr [rdi+4], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+4]
    vmovss  dword ptr [rdi+8], xmm2
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_CalcShapeRadius
==============
*/
void Physics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  float radiusOuta; 

  _RDI = radiusOut;
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9555, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to calculate shape radius with an invalid shape", "shape") )
    __debugbreak();
  HavokPhysics_CalcShapeRadius(shape, &radiusOuta);
  __asm
  {
    vmovss  xmm0, [rsp+38h+radiusOut]
    vmulss  xmm1, xmm0, cs:__real@42000000
    vmovss  dword ptr [rdi], xmm1
  }
}

/*
==============
Physics_CalculateMassProperties
==============
*/

void __fastcall Physics_CalculateMassProperties(hknpShape *shape, double mass, hkMassProperties *massProperties)
{
  bool v8; 
  bool v9; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10143, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CalculateMassPropertiesForConvexHull when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  v8 = shape == NULL;
  if ( !shape )
  {
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10144, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to CalculateMassPropertiesForConvexHull with null shape", "shape");
    v8 = !v9;
    if ( v9 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10145, ASSERT_TYPE_ASSERT, "(mass > 0)", "%s\n\tPhysics: Trying to CalculateMassPropertiesForConvexHull with 0 or negative mass", "mass > 0") )
    __debugbreak();
  if ( !massProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10146, ASSERT_TYPE_ASSERT, "(massProperties)", "%s\n\tPhysics: Trying to CalculateMassPropertiesForConvexHull with NULL mass properties", "massProperties") )
    __debugbreak();
  __asm
  {
    vmovaps xmm1, xmm6; mass
    vmovaps xmm6, [rsp+48h+var_18]
  }
  HavokPhysics_CalculateMassProperties(shape, *(float *)&_XMM1, massProperties);
}

/*
==============
Physics_CheckForGarbageCollectionClient
==============
*/

void __fastcall Physics_CheckForGarbageCollectionClient(double timeStep)
{
  char v1; 

  __asm
  {
    vaddss  xmm2, xmm0, cs:s_garbageCollectionTimer_Client
    vcomiss xmm2, cs:__real@45610000
    vmovss  cs:s_garbageCollectionTimer_Client, xmm2
  }
  if ( !v1 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  cs:s_garbageCollectionTimer_Client, xmm0
    }
    HavokPhysics_DoGarbageCollectionClient();
  }
}

/*
==============
Physics_CheckForGarbageCollectionServer
==============
*/

void __fastcall Physics_CheckForGarbageCollectionServer(double timeStep)
{
  char v1; 

  __asm
  {
    vaddss  xmm2, xmm0, cs:s_garbageCollectionTimer_Server
    vcomiss xmm2, cs:__real@45610000
    vmovss  cs:s_garbageCollectionTimer_Server, xmm2
  }
  if ( !v1 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  cs:s_garbageCollectionTimer_Server, xmm0
    }
    HavokPhysics_DoGarbageCollectionServer();
  }
}

/*
==============
Physics_CheckShapecastConstraints
==============
*/
void Physics_CheckShapecastConstraints(const hknpShape *shape, const vec3_t *start, const vec3_t *end)
{
  char v8; 
  char v9; 
  double v32; 
  double v33; 
  float radiusOut[4]; 

  _RBX = DVARFLT_physics_shapecastMaxDist;
  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  _RSI = end;
  __asm { vmovaps [rsp+88h+var_38], xmm7 }
  if ( !DVARFLT_physics_shapecastMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_shapecastMaxDist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm5, dword ptr [rbx+28h]
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm5, xmm7
  }
  if ( !(v8 | v9) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vsubss  xmm3, xmm0, dword ptr [rbp+0]
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm2, xmm1, dword ptr [rbp+4]
      vmovss  xmm0, dword ptr [rsi+8]
      vsubss  xmm4, xmm0, dword ptr [rbp+8]
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm2, xmm2, xmm2
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm4, xmm3, xmm0
      vmulss  xmm1, xmm5, xmm5
      vcomiss xmm4, xmm1
    }
    if ( !(v8 | v9) )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm5, xmm5
        vmovsd  [rsp+88h+var_60], xmm0
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8843, ASSERT_TYPE_ASSERT, "( Vec3DistanceSq( start, end ) <= SQR( maxDist ) )", "Physics: Shapecast exceeded the maximum distance of %f.", v32) )
        __debugbreak();
    }
  }
  _RBX = DVARFLT_physics_shapecastMaxRadius;
  if ( !DVARFLT_physics_shapecastMaxRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_shapecastMaxRadius") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vcomiss xmm6, xmm7
  }
  if ( !(v8 | v9) )
  {
    if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9555, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to calculate shape radius with an invalid shape", "shape") )
      __debugbreak();
    HavokPhysics_CalcShapeRadius(shape, radiusOut);
    __asm
    {
      vmovss  xmm0, [rsp+88h+radiusOut]
      vmulss  xmm1, xmm0, cs:__real@42000000
      vcomiss xmm1, xmm6
    }
    if ( !(v8 | v9) )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+88h+var_60], xmm0
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8852, ASSERT_TYPE_ASSERT, "( radius <= maxRadius )", "Physics: Shapecast exceeded the radius of %f.", v33) )
        __debugbreak();
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_28]
    vmovaps xmm7, [rsp+88h+var_38]
  }
}

/*
==============
Physics_CheckWorldReplayDeterminism
==============
*/
void Physics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  hkMonitorStream *Value; 
  hkMonitorStream *v3; 
  Physics_WorldId v4; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2304, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check world for replay determinism when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v4 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2305, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check world for replay determinism with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v4) )
      __debugbreak();
  }
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  v3 = Value;
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtPhysics_CheckWorldReplayDeterminism");
  HavokPhysics_CheckWorldReplayDeterminism(worldId);
  if ( v3 )
    hkMonitorStream::timerEnd(v3, "Et");
}

/*
==============
Physics_ClearAntilagFlags
==============
*/
void Physics_ClearAntilagFlags(Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7803, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to ClearAntilagFlags when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7804, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to ClearAntilagFlags with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  HavokPhysics_ClearAntilagFlags(worldId);
}

/*
==============
Physics_ClearShapeCache
==============
*/
void Physics_ClearShapeCache(void)
{
  if ( g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10112, ASSERT_TYPE_ASSERT, "(!Physics_AreServerWorldsCreated())", (const char *)&queryFormat, "!Physics_AreServerWorldsCreated()") )
    __debugbreak();
  if ( g_physicsClientWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10113, ASSERT_TYPE_ASSERT, "(!Physics_AreClientWorldsCreated())", (const char *)&queryFormat, "!Physics_AreClientWorldsCreated()") )
    __debugbreak();
  HavokPhysics_ClearShapeCache();
}

/*
==============
Physics_ConvertClosestPointsToLegacyTrace
==============
*/
void Physics_ConvertClosestPointsToLegacyTrace(HavokPhysics_CollisionQueryResult *queryResult, trace_t *trace)
{
  int ClosestPointHitRef; 
  int v6; 
  unsigned __int16 ClosestPointHitHitGlassId; 
  char v9; 
  bool v10; 
  TraceHitType HitTypeByEntId; 
  int EntityNum; 
  unsigned __int16 v13; 

  _RBX = trace;
  memset_0(&trace->position, 0, 0x54ui64);
  _RBX->fraction = 1.0;
  if ( HavokPhysics_CollisionQueryResult::HasHit(queryResult) )
  {
    ClosestPointHitRef = HavokPhysics_CollisionQueryResult::GetClosestPointHitRef(queryResult, 0);
    _RBX->fraction = 0.0;
    v6 = ClosestPointHitRef;
    *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(queryResult, 0);
    __asm
    {
      vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
      vmovss  dword ptr [rbx+48h], xmm1
    }
    HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(queryResult, 0, &_RBX->position);
    HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal(queryResult, 0, &_RBX->normal);
    _RBX->surfaceFlags = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(queryResult, 0);
    _RBX->contents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(queryResult, 0);
    ClosestPointHitHitGlassId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId(queryResult, 0);
    v9 = 0;
    v10 = ClosestPointHitHitGlassId == 0;
    if ( ClosestPointHitHitGlassId )
    {
      _RBX->hitId = ClosestPointHitHitGlassId;
      HitTypeByEntId = TRACE_HITTYPE_GLASS;
    }
    else
    {
      EntityNum = Physics_GetEntityNum(v6);
      v13 = truncate_cast<unsigned short,int>(EntityNum);
      _RBX->hitId = v13;
      HitTypeByEntId = Physics_GetHitTypeByEntId(v13);
    }
    _RBX->hitType = HitTypeByEntId;
    __asm { vmovss  xmm0, cs:__real@3f333333 }
    *(_WORD *)&_RBX->allsolid = 257;
    __asm { vcomiss xmm0, dword ptr [rbx+18h] }
    _RBX->walkable = v9 | v10;
  }
}

/*
==============
Physics_ConvertRayQueryResultToLegacyTrace
==============
*/
void Physics_ConvertRayQueryResultToLegacyTrace(HavokPhysics_CollisionQueryResult *traceResult, HavokPhysics_CollisionQueryResult *queryResult, const Physics_DetailHitData *detailHitData, trace_t *trace)
{
  int RaycastHitRef; 
  unsigned __int16 RaycastHitCoverWallId; 
  unsigned __int16 RaycastHitGlassId; 
  char v12; 
  TraceHitType HitTypeByEntId; 
  int v14; 
  const ScriptableDef *def; 
  bool IsStandaloneRequested; 
  int EntityNum; 
  unsigned __int16 v18; 
  bool HasHit; 
  bool v21; 
  char v22; 
  unsigned int RaycastHitBodyId; 
  const char *RigidBodyName; 

  _RBX = trace;
  memset_0(&trace->position, 0, 0x54ui64);
  _RBX->fraction = 1.0;
  if ( !HavokPhysics_CollisionQueryResult::HasHit(traceResult) )
    return;
  RaycastHitRef = HavokPhysics_CollisionQueryResult::GetRaycastHitRef(traceResult, 0);
  RaycastHitCoverWallId = HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId(traceResult, 0);
  *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(traceResult, 0);
  __asm { vmovss  dword ptr [rbx], xmm0 }
  HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(traceResult, 0, &_RBX->position);
  HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(traceResult, 0, &_RBX->normal);
  _RBX->surfaceFlags = HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(traceResult, 0);
  _RBX->contents = HavokPhysics_CollisionQueryResult::GetRaycastHitContents(traceResult, 0);
  RaycastHitGlassId = HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId(traceResult, 0);
  v12 = 0;
  if ( RaycastHitGlassId )
  {
    _RBX->hitId = RaycastHitGlassId;
    HitTypeByEntId = TRACE_HITTYPE_GLASS;
    goto LABEL_12;
  }
  if ( (RaycastHitRef & 0x3E000000) != 0x10000000 || ((RaycastHitRef >> 22) & 3) != 0 || (v14 = RaycastHitRef & 0x3FFFFF, (def = ScriptableSv_GetInstanceCommonContext(RaycastHitRef & 0x3FFFFF)->def) == NULL) || (IsStandaloneRequested = ScriptableDef_IsStandaloneRequested(def), v12 = 0, !IsStandaloneRequested) )
  {
    if ( !Physics_IsClientEntitylessScriptable(RaycastHitRef) )
    {
      EntityNum = Physics_GetEntityNum(RaycastHitRef);
      v18 = truncate_cast<unsigned short,int>(EntityNum);
      _RBX->hitId = v18;
      HitTypeByEntId = Physics_GetHitTypeByEntId(v18);
      goto LABEL_12;
    }
    v12 = 0;
    v14 = RaycastHitRef & 0x3FFFFF;
  }
  _RBX->hitId = v14;
  HitTypeByEntId = TRACE_HITTYPE_SCRIPTABLE;
LABEL_12:
  _RBX->hitType = HitTypeByEntId;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm0, dword ptr [rbx]
  }
  _RBX->allsolid = 0;
  if ( !v12 && queryResult && (HasHit = HavokPhysics_CollisionQueryResult::HasHit(queryResult), v21 = !HasHit, HasHit) )
  {
    v22 = 1;
  }
  else
  {
    v22 = 0;
    v21 = 1;
  }
  __asm { vmovss  xmm0, cs:__real@3f333333 }
  _RBX->startsolid = v22;
  __asm { vcomiss xmm0, dword ptr [rbx+18h] }
  _RBX->walkable = v21;
  if ( detailHitData && detailHitData->isValid )
  {
    _RBX->surfaceFlags = detailHitData->surfaceflags;
    _RBX->modelIndex = detailHitData->modelIndex;
    _RBX->partName = detailHitData->partName;
    _RBX->partGroup = detailHitData->partGroup;
  }
  else
  {
    RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(traceResult, 0);
    RigidBodyName = Physics_GetRigidBodyName(traceResult->m_worldId, RaycastHitBodyId);
    _RBX->partName = SL_FindString(RigidBodyName);
  }
  if ( RaycastHitCoverWallId != 0xFFFF )
  {
    _RBX->hitSubType = TRACE_HITSUBTYPE_COVERWALL;
    _RBX->subTypeData.coverWall.id = RaycastHitCoverWallId;
  }
}

/*
==============
Physics_ConvertRefSystemToString
==============
*/
void Physics_ConvertRefSystemToString(int ref, Physics_WorldId worldId, char *string, int stringLen)
{
  unsigned __int64 v4; 
  int v8; 
  unsigned __int16 v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  char *v13; 
  LocalClientNum_t LocalClientForWorld; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  const char *v19; 
  const char *v20; 
  int v21; 
  int v22; 
  int v23; 
  int v24; 
  const char *v25; 
  const char *v26; 
  const char *v27; 
  const char *v28; 
  char *fmt; 
  __int64 v30; 
  DynEntityBasis basisOut; 
  unsigned int dynEntIdOut; 

  v4 = stringLen;
  if ( !string && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4969, ASSERT_TYPE_ASSERT, "(string)", (const char *)&queryFormat, "string") )
    __debugbreak();
  if ( (int)v4 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4970, ASSERT_TYPE_ASSERT, "(stringLen > 0)", (const char *)&queryFormat, "stringLen > 0") )
    __debugbreak();
  v8 = ref >> 30;
  v9 = truncate_cast<unsigned short,int>((unsigned __int16)ref);
  switch ( (ref >> 25) & 0x1F )
  {
    case 0:
      v10 = "StaticModel";
      if ( !BYTE2(ref) )
        v10 = "World";
      v11 = (char *)&queryFormat.fmt + 3;
      fmt = (char *)v10;
      v12 = "%s%s";
      v13 = string;
      if ( v8 )
        v11 = "Detail ";
      goto LABEL_39;
    case 1:
      LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
      if ( LocalClientForWorld == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4993, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", (const char *)&queryFormat, "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      DynEnt_GetBasisAndDynEntId(ref, LocalClientForWorld, &basisOut, &dynEntIdOut);
      v15 = "Brush";
      if ( basisOut == DYNENT_BASIS_MODEL )
        v15 = "Model";
      v16 = "%sDynent %s %u";
      LODWORD(v30) = dynEntIdOut;
      fmt = (char *)v15;
      goto LABEL_56;
    case 2:
      LODWORD(fmt) = v9;
      v17 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v17 = "Detail ";
      Com_sprintf(string, v4, "%sServer Entity %u", v17, fmt);
      return;
    case 3:
      LODWORD(fmt) = v9;
      v18 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v18 = "Detail ";
      Com_sprintf(string, v4, "%sServer Character for Entity %u", v18, fmt);
      return;
    case 4:
      LODWORD(fmt) = v9;
      v19 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v19 = "Detail ";
      Com_sprintf(string, v4, "%sClient Entity %u", v19, fmt);
      return;
    case 5:
      LODWORD(fmt) = v9;
      v20 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v20 = "Detail ";
      Com_sprintf(string, v4, "%sClient Character for Entity %u", v20, fmt);
      return;
    case 6:
      v21 = v9;
      v16 = "%sRagdoll %i Body %u";
      v22 = BYTE2(ref);
      goto LABEL_55;
    case 7:
      v11 = (char *)&queryFormat.fmt + 3;
      if ( !(BYTE2(ref) >> 6) )
      {
        v23 = v9;
        v12 = "%sFX Element %i";
        LODWORD(fmt) = v23 | ((BYTE2(ref) & 0x3F) << 16);
        v13 = string;
        if ( v8 )
          v11 = "Detail ";
LABEL_39:
        Com_sprintf(v13, v4, v12, v11, fmt);
        return;
      }
      if ( BYTE2(ref) >> 6 == 1 )
      {
        v24 = v9;
        v12 = "%sFunc Glass piece %i";
        LODWORD(fmt) = v24 | ((BYTE2(ref) & 0x3F) << 16);
        v13 = string;
        if ( v8 )
          v11 = "Detail ";
        goto LABEL_39;
      }
      if ( v8 )
        v11 = "Detail ";
      Com_sprintf(string, v4, "%sUnknown Particle", v11);
      return;
    case 8:
      v25 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v25 = "Detail ";
      LODWORD(fmt) = ref & 0x3FFFFF;
      Com_sprintf(string, v4, "%sScriptable Collision %i", v25, fmt);
      return;
    case 9:
      LODWORD(fmt) = v9;
      v26 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v26 = "Detail ";
      Com_sprintf(string, v4, "%sServer Item %u", v26, fmt);
      return;
    case 0xA:
      LODWORD(fmt) = v9;
      v27 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v27 = "Detail ";
      Com_sprintf(string, v4, "%sClient Model %u ", v27, fmt);
      return;
    case 0xB:
      v22 = v9;
      v16 = "%sCloth Proxy %u:%u";
      goto LABEL_54;
    case 0xC:
      v22 = v9;
      v16 = "%sLightweightParticle proxy %u:%u";
LABEL_54:
      v21 = BYTE2(ref);
LABEL_55:
      LODWORD(v30) = v21;
      LODWORD(fmt) = v22;
LABEL_56:
      v28 = (char *)&queryFormat.fmt + 3;
      if ( v8 )
        v28 = "Detail ";
      Com_sprintf(string, v4, v16, v28, fmt, v30);
      return;
    default:
      return;
  }
}

/*
==============
Physics_ConvertShapeQueryResultToLegacyTrace
==============
*/
void Physics_ConvertShapeQueryResultToLegacyTrace(HavokPhysics_CollisionQueryResult *traceResult, HavokPhysics_CollisionQueryResult *queryResult, trace_t *trace)
{
  int ShapecastHitRef; 
  unsigned __int16 ShapecastHitHitGlassId; 
  char v9; 
  TraceHitType HitTypeByEntId; 
  const ScriptableDef *def; 
  int EntityNum; 
  unsigned __int16 v13; 
  bool HasHit; 
  bool v16; 
  char v17; 
  unsigned int ShapecastHitBodyId; 
  const char *RigidBodyName; 

  _RBX = trace;
  memset_0(&trace->position, 0, 0x54ui64);
  _RBX->fraction = 1.0;
  if ( HavokPhysics_CollisionQueryResult::HasHit(traceResult) )
  {
    ShapecastHitRef = HavokPhysics_CollisionQueryResult::GetShapecastHitRef(traceResult, 0);
    *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetShapecastHitFraction(traceResult, 0);
    __asm { vmovss  dword ptr [rbx], xmm0 }
    HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition(traceResult, 0, &_RBX->position);
    HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal(traceResult, 0, &_RBX->normal);
    _RBX->surfaceFlags = HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(traceResult, 0);
    _RBX->contents = HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents(traceResult, 0);
    ShapecastHitHitGlassId = HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId(traceResult, 0);
    v9 = 0;
    if ( ShapecastHitHitGlassId )
    {
      _RBX->hitId = ShapecastHitHitGlassId;
      HitTypeByEntId = TRACE_HITTYPE_GLASS;
    }
    else if ( (ShapecastHitRef & 0x3E000000) == 0x10000000 && ((ShapecastHitRef >> 22) & 3) == 0 && (def = ScriptableSv_GetInstanceCommonContext(ShapecastHitRef & 0x3FFFFF)->def) != NULL && ScriptableDef_IsStandaloneRequested(def) || Physics_IsClientEntitylessScriptable(ShapecastHitRef) )
    {
      _RBX->hitId = truncate_cast<unsigned short,int>((unsigned __int16)ShapecastHitRef);
      HitTypeByEntId = TRACE_HITTYPE_SCRIPTABLE;
    }
    else
    {
      EntityNum = Physics_GetEntityNum(ShapecastHitRef);
      v13 = truncate_cast<unsigned short,int>(EntityNum);
      _RBX->hitId = v13;
      HitTypeByEntId = Physics_GetHitTypeByEntId(v13);
    }
    _RBX->hitType = HitTypeByEntId;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rbx]
    }
    _RBX->allsolid = 0;
    if ( !v9 && queryResult && (HasHit = HavokPhysics_CollisionQueryResult::HasHit(queryResult), v16 = !HasHit, HasHit) )
    {
      v17 = 1;
    }
    else
    {
      v17 = 0;
      v16 = 1;
    }
    __asm { vmovss  xmm0, cs:__real@3f333333 }
    _RBX->startsolid = v17;
    __asm { vcomiss xmm0, dword ptr [rbx+18h] }
    _RBX->walkable = v16;
    ShapecastHitBodyId = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(traceResult, 0);
    RigidBodyName = Physics_GetRigidBodyName(traceResult->m_worldId, ShapecastHitBodyId);
    _RBX->partName = SL_FindString(RigidBodyName);
    if ( queryResult )
    {
      if ( HavokPhysics_CollisionQueryResult::HasHit(queryResult) )
      {
        *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(queryResult, 0);
        __asm
        {
          vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
          vmovss  dword ptr [rbx+48h], xmm1
        }
      }
    }
  }
}

/*
==============
Physics_CopyPhysicsAsset
==============
*/
void Physics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3783, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Copy PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (to->usageCounter.serverEnt || to->usageCounter.clientEnt || to->usageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( to->usageCounter.serverEnt )
      G_Utils_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.dynEnt )
      DynEnt_PrepareForPhysicsAssetChange(to);
  }
  HavokPhysics_CopyPhysicsAsset(from, to);
}

/*
==============
Physics_CopyPhysicsSFXEventAsset
==============
*/
void Physics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3597, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to copy PhysicsSFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_CopyPhysicsSFXEventAsset(from, to);
}

/*
==============
Physics_CopyPhysicsVFXEventAsset
==============
*/
void Physics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3652, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to copy PhysicsVFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_CopyPhysicsVFXEventAsset(from, to);
}

/*
==============
Physics_CopyXModelAsset
==============
*/
void Physics_CopyXModelAsset(XModel *from, XModel *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4297, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Copy XModel Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (to->physicsUsageCounter.serverEnt || to->physicsUsageCounter.clientEnt || to->physicsUsageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( to->physicsUsageCounter.serverEnt )
      G_Utils_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.dynEnt )
      DynEnt_PrepareForXModelChange(to);
  }
  HavokPhysics_CopyXModelAsset(from, to);
}

/*
==============
Physics_CopyXModelDetailCollisionAsset
==============
*/
void Physics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4139, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Copy XModelDetailCollision Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    G_Utils_PhysicsPrepareForXModelDetailCollisionChange(to);
    CG_Entity_PhysicsPrepareForXModelDetailCollisionChange(to);
    DynEnt_PrepareForXModelDetailCollisionChange(to);
  }
  HavokPhysics_CopyXModelDetailCollisionAsset(from, to);
}

/*
==============
Physics_CreateClientWorlds
==============
*/
void Physics_CreateClientWorlds(LocalClientNum_t localClientNum)
{
  __int64 v2; 
  int v3; 
  const dvar_t *v4; 
  int v5; 
  Physics_WorldId v6; 
  Physics_WorldId v7; 
  int integer; 
  float v9; 
  unsigned int v10; 
  __int64 v11; 
  int v12; 
  __int64 v13; 
  unsigned int IndexByName; 
  unsigned int v15; 
  unsigned int v16; 
  OmnvarData *Data; 
  OmnvarData *v18; 
  OmnvarData *v19; 
  OmnvarData *v20; 
  float value; 
  Physics_WorldId v22; 
  __int64 v24; 

  v2 = localClientNum;
  Sys_EnterCriticalSection(CRITSECT_PHYS_WORLDCREATE);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1842, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateServerWorlds when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  v3 = g_physicsClientWorldsCreated;
  if ( _bittest(&v3, v2) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1843, ASSERT_TYPE_ASSERT, "(( g_physicsClientWorldsCreated & ( 1 << localClientNum ) ) == 0)", "%s\n\tPhysics: Trying to CreateClientWorlds twice for the same client", "( g_physicsClientWorldsCreated & ( 1 << localClientNum ) ) == 0") )
    __debugbreak();
  Physics_SetupClientWorldCInfos();
  v4 = DCONST_DVARINT_physics_ExtraClientAuthFixedMemory;
  v5 = 3 * v2;
  v6 = 3 * v2 + 2;
  v7 = 3 * v2 + 4;
  if ( !DCONST_DVARINT_physics_ExtraClientAuthFixedMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraClientAuthFixedMemory") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  integer = v4->current.integer;
  v9 = cl_maxLocalClients;
  v10 = 0x700000u / LODWORD(cl_maxLocalClients);
  v24 = 16 * (5i64 * v5 + 10);
  v11 = 2 * (5i64 * v5 + 15);
  *(int *)((char *)&s_physicsWorldCInfos[0].persistentBufferSize + v24) = 0x700000u / LODWORD(cl_maxLocalClients);
  *(char **)((char *)&s_physicsWorldCInfos[0].persistentBuffer + v24) = &s_physicsWorldPersistentBufferSizeClientPredictive[(int)(v2 * v10)];
  v12 = (integer + 13631488) / SLODWORD(v9);
  v13 = 2 * (5i64 * v5 + 20);
  *(&s_physicsWorldCInfos[0].persistentBufferSize + 2 * v11) = v12;
  *((_QWORD *)&s_physicsWorldCInfos[0].persistentBuffer + v11) = &s_physicsWorldPersistentBufferSizeClientAuthoritative[(int)v2 * v12];
  *(&s_physicsWorldCInfos[0].persistentBufferSize + 2 * v13) = 0x40000u / LODWORD(v9);
  *((_QWORD *)&s_physicsWorldCInfos[0].persistentBuffer + v13) = &s_physicsWorldPersistentBufferSizeClientDetail[(int)(v2 * (0x40000u / LODWORD(v9)))];
  s_physicsClientWorldGravityOmnvarIdxX = BG_Omnvar_GetIndexByName("physics_gravity_x");
  s_physicsClientWorldGravityOmnvarIdxY = BG_Omnvar_GetIndexByName("physics_gravity_y");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_z");
  s_physicsClientWorldGravityOmnvarIdxZ = IndexByName;
  if ( (s_physicsClientWorldGravityOmnvarIdxX == -1 || s_physicsClientWorldGravityOmnvarIdxY == -1 || IndexByName == -1) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1866, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Physics Client World Init can't find gravity omnvars - check omnvar.csv") )
    __debugbreak();
  s_physicsClientWorldGravityRagdollOmnvarIdx = BG_Omnvar_GetIndexByName("physics_gravity_ragdoll");
  s_physicsClientWorldGravityDynentOmnvarIdx = BG_Omnvar_GetIndexByName("physics_gravity_dynent");
  v15 = BG_Omnvar_GetIndexByName("physics_gravity_particle");
  v16 = s_physicsClientWorldGravityRagdollOmnvarIdx;
  s_physicsClientWorldGravityParticleOmnvarIdx = v15;
  if ( s_physicsClientWorldGravityRagdollOmnvarIdx == -1 || s_physicsClientWorldGravityDynentOmnvarIdx == -1 || v15 == -1 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1874, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Physics Client World Init can't find gravity modifier omnvars - check omnvar.csv") )
      __debugbreak();
    v16 = s_physicsClientWorldGravityRagdollOmnvarIdx;
  }
  Data = CG_Omnvar_GetData((LocalClientNum_t)v2, v16);
  v18 = CG_Omnvar_GetData((LocalClientNum_t)v2, s_physicsClientWorldGravityDynentOmnvarIdx);
  v19 = CG_Omnvar_GetData((LocalClientNum_t)v2, s_physicsClientWorldGravityParticleOmnvarIdx);
  v20 = v19;
  if ( (!Data || !v18 || !v19) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1881, ASSERT_TYPE_ASSERT, "(ragdollScalarValue && dynentScalarValue && particleScalarValue)", (const char *)&queryFormat, "ragdollScalarValue && dynentScalarValue && particleScalarValue") )
    __debugbreak();
  g_physicsClientWorldGravityScalars[0][v2] = 1.0;
  g_physicsClientWorldGravityScalars[1][v2] = 1.0;
  g_physicsClientWorldGravityScalars[2][v2] = 1.0;
  g_physicsClientWorldGravityScalars[3][v2] = 1.0;
  g_physicsClientWorldGravityScalars[4][v2] = 1.0;
  g_physicsClientWorldGravityScalars[5][v2] = 1.0;
  g_physicsClientWorldGravityScalars[6][v2] = 1.0;
  g_physicsClientWorldGravityScalars[7][v2] = 1.0;
  g_physicsClientWorldGravityScalars[8][v2] = 1.0;
  g_physicsClientWorldGravityScalars[9][v2] = 1.0;
  g_physicsClientWorldGravityScalars[10][v2] = 1.0;
  g_physicsClientWorldGravityScalars[11][v2] = 1.0;
  g_physicsClientWorldGravityScalars[12][v2] = 1.0;
  LODWORD(g_physicsClientWorldGravityScalars[6][v2]) = Data->current.integer;
  value = v18->current.value;
  v22 = 3 * v2 + 2;
  g_physicsClientWorldGravityScalars[1][v2] = value;
  LODWORD(g_physicsClientWorldGravityScalars[7][v2]) = v20->current.integer;
  if ( v6 <= v7 )
  {
    do
      Physics_CreateWorld(v22++);
    while ( v22 <= v7 );
  }
  PhysicsForceAction_Init(v6, *(int *)((char *)&s_physicsWorldCInfos[0].bodyCountMax + v24));
  PhysicsForceAction_Init((const Physics_WorldId)(v5 + 3), s_physicsWorldCInfos[v5 + 3].bodyCountMax);
  PhysicsGravityModifier_Init(v6, *(int *)((char *)&s_physicsWorldCInfos[0].motionCountMax + v24));
  PhysicsGravityModifier_Init((const Physics_WorldId)(v5 + 3), s_physicsWorldCInfos[v5 + 3].motionCountMax);
  CG_PhysicsVolume_Init((LocalClientNum_t)v2);
  PhysicsSVFX_RegisterWorld((Physics_WorldId)(v5 + 3), (LocalClientNum_t)v2, s_physicsWorldCInfos[v5 + 3].bodyCountMax);
  __asm { vxorps  xmm0, xmm0, xmm0 }
  g_physicsClientWorldsCreated |= 1 << v2;
  __asm { vmovss  cs:s_garbageCollectionTimer_Client, xmm0 }
  Sys_LeaveCriticalSection(CRITSECT_PHYS_WORLDCREATE);
}

/*
==============
Physics_CreateDevGui
==============
*/
void Physics_CreateDevGui(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  int v2; 
  int cmdsize; 
  int v4; 
  __int64 i; 

  v1 = localClientNum;
  Sys_EnterCriticalSection(CRITSECT_CBUF);
  v2 = truncate_cast<int,unsigned __int64>(0x14ui64);
  cmdsize = s_cmd_superUser_textArray[v1].cmdsize;
  v4 = v2 + 1;
  if ( cmdsize + v2 + 1 <= s_cmd_superUser_textArray[v1].maxsize )
  {
    for ( i = cmdsize - 1; i >= 0; --i )
      s_cmd_superUser_textArray[v1].data[v4 + i] = s_cmd_superUser_textArray[v1].data[i];
    memcpy_0(s_cmd_superUser_textArray[v1].data, "exec devgui_physics\n", v4 - 1);
    s_cmd_superUser_textArray[v1].data[v4 - 1] = 10;
    s_cmd_superUser_textArray[v1].cmdsize += v4;
  }
  else
  {
    Com_PrintError(1, "Cbuf_InsertText overflowed\n");
  }
  Sys_LeaveCriticalSection(CRITSECT_CBUF);
}

/*
==============
Physics_CreateInstance
==============
*/
unsigned int Physics_CreateInstance(Physics_WorldId worldId)
{
  Physics_WorldId v3; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5206, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to create an instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5207, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to create an instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v3) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  return HavokPhysics_CreateInstance(worldId);
}

/*
==============
Physics_CreateServerWorlds
==============
*/
void Physics_CreateServerWorlds(const unsigned int maxClients)
{
  int i; 
  hkMonitorStream *Value; 
  hkMonitorStream *v5; 
  __int64 v7; 

  Sys_EnterCriticalSection(CRITSECT_PHYS_WORLDCREATE);
  if ( maxClients - 1 > 0xC7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1797, ASSERT_TYPE_ASSERT, "((maxClients > 0) && (maxClients <= ((1 >= 200) ? 1 : 200)))", (const char *)&queryFormat, "(maxClients > 0) && (maxClients <= MAX_CLIENTS_STATIC)") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1801, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateServerWorlds when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1802, ASSERT_TYPE_ASSERT, "(!g_physicsServerWorldsCreated)", "%s\n\tPhysics: Trying to CreateServerWorlds twice", "!g_physicsServerWorldsCreated") )
    __debugbreak();
  Physics_SetupServerWorldCInfos(maxClients);
  for ( i = 0; i <= 1; ++i )
  {
    Physics_CreateWorld((Physics_WorldId)i);
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2304, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check world for replay determinism when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( (unsigned int)i > 7 )
    {
      LODWORD(v7) = i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2305, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check world for replay determinism with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
        __debugbreak();
    }
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v5 = Value;
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtPhysics_CheckWorldReplayDeterminism");
    HavokPhysics_CheckWorldReplayDeterminism((Physics_WorldId)i);
    if ( v5 )
      hkMonitorStream::timerEnd(v5, "Et");
  }
  PhysicsForceAction_Init(PHYSICS_WORLD_ID_FIRST, s_physicsWorldCInfos[0].bodyCountMax);
  PhysicsGravityModifier_Init(PHYSICS_WORLD_ID_FIRST, s_physicsWorldCInfos[0].motionCountMax);
  G_PhysicsVolume_Init();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  cs:s_garbageCollectionTimer_Server, xmm0
  }
  g_physicsServerWorldsCreated = 1;
  Sys_LeaveCriticalSection(CRITSECT_PHYS_WORLDCREATE);
}

/*
==============
Physics_CreateShapeCapsule
==============
*/

hknpShape *__fastcall Physics_CreateShapeCapsule(Physics_WorldId worldId, const vec3_t *center, double halfHeight, double radius, const vec3_t *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  bool v19; 
  bool v20; 
  bool v21; 
  bool v23; 
  bool v28; 
  bool v29; 
  char v38; 
  bool v39; 
  bool v43; 
  bool v44; 
  hknpShape *result; 
  int v66; 
  int v67; 
  int v68; 
  int v69; 
  int v70; 
  int v71; 
  int v72; 
  int v73; 
  int v74; 
  hkVector4f centera; 
  hkVector4f v76; 
  char v77; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _RBX = center;
  __asm
  {
    vmovaps xmm7, xmm3
    vmovaps xmm8, xmm2
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9923, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeCapsule when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  if ( (v66 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  if ( (v67 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  v19 = (v68 & 0x7F800000u) < 0x7F800000;
  v20 = (v68 & 0x7F800000u) <= 0x7F800000;
  if ( (v68 & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9924, ASSERT_TYPE_ASSERT, "(!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] ))", "%s\n\tPhysics: Trying to CreateShapeCapsule with invalid center", "!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] )");
    v19 = 0;
    v20 = !v21;
    if ( v21 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm8, xmm6
  }
  if ( v19 )
  {
    v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9925, ASSERT_TYPE_ASSERT, "(halfHeight >= 0.f)", "%s\n\tPhysics: Trying to CreateShapeCapsule with bad halfheight", "halfHeight >= 0.f");
    v20 = !v23;
    if ( v23 )
      __debugbreak();
  }
  __asm { vcomiss xmm7, xmm6 }
  if ( v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9926, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to CreateShapeCapsule with bad radius", "radius > 0.f") )
    __debugbreak();
  _RDI = majorAxis;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  if ( (v69 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  if ( (v70 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  v28 = (v71 & 0x7F800000) == 2139095040;
  if ( (v71 & 0x7F800000) == 2139095040 )
  {
LABEL_51:
    v29 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9927, ASSERT_TYPE_ASSERT, "(!IS_NAN( majorAxis[0] ) && !IS_NAN( majorAxis[1] ) && !IS_NAN( majorAxis[2] ))", "%s\n\tPhysics: Trying to CreateShapeCapsule with invalid majorAxis", "!IS_NAN( majorAxis[0] ) && !IS_NAN( majorAxis[1] ) && !IS_NAN( majorAxis[2] )");
    v28 = !v29;
    if ( v29 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  xmm2, dword ptr [rdi+4]
    vmovss  xmm3, dword ptr [rdi+8]
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm2, xmm2, xmm1
    vucomiss xmm2, cs:__real@3f800000
  }
  if ( !v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9928, ASSERT_TYPE_ASSERT, "(Vec3LengthSq( majorAxis ) == 1.f)", "%s\n\tPhysics: Trying to CreateShapeCapsule with non normal majorAxis", "Vec3LengthSq( majorAxis ) == 1.f") )
    __debugbreak();
  if ( optionalInplaceBuffer && optionalInplaceBufferSize <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9929, ASSERT_TYPE_ASSERT, "(!optionalInplaceBuffer || optionalInplaceBufferSize > 0)", "%s\n\tPhysics: Trying to CreateShapeCapsule with bad inplace buffer data", "!optionalInplaceBuffer || optionalInplaceBufferSize > 0") )
    __debugbreak();
  v38 = 0;
  v39 = shapeStorage == Permanent;
  if ( shapeStorage == Permanent )
    CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm { vcomiss xmm8, cs:__real@3c23d70a }
  if ( v38 | v39 )
  {
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9900, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeSphere when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  [rsp+0E8h+var_A8], xmm0
    }
    if ( (v72 & 0x7F800000) == 2139095040 )
      goto LABEL_52;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  [rsp+0E8h+var_A8], xmm0
    }
    if ( (v73 & 0x7F800000) == 2139095040 )
      goto LABEL_52;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+8]
      vmovss  [rsp+0E8h+var_A8], xmm0
    }
    v43 = (v74 & 0x7F800000u) <= 0x7F800000;
    if ( (v74 & 0x7F800000) == 2139095040 )
    {
LABEL_52:
      v44 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9901, ASSERT_TYPE_ASSERT, "(!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] ))", "%s\n\tPhysics: Trying to CreateShapeSphere with invalid center", "!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] )");
      v43 = !v44;
      if ( v44 )
        __debugbreak();
    }
    __asm { vcomiss xmm7, xmm6 }
    if ( v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9902, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to CreateShapeSphere with bad radius", "radius > 0.f") )
      __debugbreak();
    if ( optionalInplaceBuffer && optionalInplaceBufferSize <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9903, ASSERT_TYPE_ASSERT, "(!optionalInplaceBuffer || optionalInplaceBufferSize > 0)", "%s\n\tPhysics: Trying to CreateShapeSphere with bad inplace buffer data", "!optionalInplaceBuffer || optionalInplaceBufferSize > 0") )
      __debugbreak();
    __asm
    {
      vmovss  xmm3, cs:__real@3d000000
      vmulss  xmm1, xmm3, dword ptr [rbx+8]
      vmulss  xmm0, xmm3, dword ptr [rbx]
      vmulss  xmm2, xmm3, dword ptr [rbx+4]
      vmovss  dword ptr [rsp+0E8h+center.m_quad+8], xmm1
      vmulss  xmm1, xmm7, xmm3; radius
      vmovss  dword ptr [rsp+0E8h+center.m_quad], xmm0
      vmovss  dword ptr [rsp+0E8h+center.m_quad+4], xmm2
      vmovss  dword ptr [rsp+0E8h+center.m_quad+0Ch], xmm6
    }
    result = HavokPhysics_CreateShapeSphere(&centera, *(float *)&_XMM1, optionalInplaceBuffer, optionalInplaceBufferSize);
  }
  else
  {
    __asm
    {
      vmovss  xmm4, cs:__real@3d000000
      vmulss  xmm2, xmm4, dword ptr [rbx+4]
      vmulss  xmm0, xmm4, dword ptr [rbx]
      vmulss  xmm1, xmm4, dword ptr [rbx+8]
      vmovss  [rsp+0E8h+var_84], xmm2
      vmovss  xmm2, dword ptr [rdi]
      vinsertps xmm2, xmm2, dword ptr [rdi+4], 10h
      vinsertps xmm2, xmm2, dword ptr [rdi+8], 20h ; ' '
      vinsertps xmm2, xmm2, xmm6, 30h ; '0'
      vmovups xmmword ptr [rsp+0E8h+center.m_quad], xmm2
      vmovdqa xmmword ptr [rsp+0E8h+center.m_quad], xmm2
      vmulss  xmm2, xmm8, xmm4
      vmulss  xmm3, xmm7, xmm4
      vmovss  [rsp+0E8h+var_88], xmm0
      vmovss  [rsp+0E8h+var_80], xmm1
      vmovss  [rsp+0E8h+var_7C], xmm6
    }
    result = HavokPhysics_CreateShapeCapsuleCenterHeight(worldId, &v76, *(float *)&_XMM2, *(float *)&_XMM3, &centera, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
  }
  _R11 = &v77;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return result;
}

/*
==============
Physics_CreateShapeCapsuleUpAxis
==============
*/
hknpShape *Physics_CreateShapeCapsuleUpAxis(Physics_WorldId worldId, const vec3_t *center, float halfHeight, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  vec3_t majorAxis; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+68h+var_28], xmm0
    vmovss  dword ptr [rsp+68h+var_28+4], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  dword ptr [rsp+68h+var_28+8], xmm0
  }
  return Physics_CreateShapeCapsule(worldId, center, halfHeight, radius, &majorAxis, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
Physics_CreateShapeCompound
==============
*/
hknpShape *Physics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10066, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_CreateShapeCompound when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  return HavokPhysics_CreateShapeCompound(instanceArray);
}

/*
==============
Physics_CreateShapeConvexHull
==============
*/
hknpShape *Physics_CreateShapeConvexHull(const vec3_t *verts, unsigned int numVertices, unsigned int maxNumGeneratedVertices, bool useCache)
{
  __int64 v8; 
  float *v11; 
  hkMemoryAllocator *v16; 
  int m_size; 
  hknpShape *v20; 
  hkMemoryAllocator *v21; 
  hknpShape *result; 
  hkArray<hkVector4f,hkContainerHeapAllocator> array; 
  __int64 v25; 

  v25 = -2i64;
  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  v8 = numVertices;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10024, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeConvexHull when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v8 < 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10025, ASSERT_TYPE_ASSERT, "(numVertices >= 3)", "%s\n\tPhysics: Trying to CreateShapeConvexHull with bad vertex count", "numVertices >= 3") )
    __debugbreak();
  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  if ( (_DWORD)v8 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+98h+var_48+0Ch], xmm0
    }
    v11 = &verts->v[2];
    __asm { vmovss  xmm6, cs:__real@3d000000 }
    do
    {
      __asm
      {
        vmulss  xmm1, xmm6, dword ptr [rbx-8]
        vmovss  dword ptr [rsp+98h+var_48], xmm1
        vmulss  xmm0, xmm6, dword ptr [rbx-4]
        vmovss  dword ptr [rsp+98h+var_48+4], xmm0
        vmulss  xmm2, xmm6, dword ptr [rbx]
        vmovss  dword ptr [rsp+98h+var_48+8], xmm2
      }
      v16 = hkMemHeapAllocator();
      m_size = array.m_size;
      if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v16, &array, 16);
        m_size = array.m_size;
      }
      _RAX = &array.m_data[m_size];
      __asm
      {
        vmovups xmm0, [rsp+98h+var_48]
        vmovups xmmword ptr [rax], xmm0
      }
      ++array.m_size;
      v11 += 3;
      --v8;
    }
    while ( v8 );
  }
  v20 = HavokPhysics_CreateShapeConvexHull(&array, maxNumGeneratedVertices, useCache);
  v21 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v21, array.m_data, 16, array.m_capacityAndFlags & 0x3FFFFFFF);
  result = v20;
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
  return result;
}

/*
==============
Physics_CreateShapeConvexHullFromAABB
==============
*/

hknpShape *__fastcall Physics_CreateShapeConvexHullFromAABB(const vec3_t *mins, const vec3_t *maxs, __int64 a3, double _XMM3_8)
{
  hkVector4f maxsa; 
  hkVector4f minsa; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10046, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_CreateShapeCuboid when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+68h+mins.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+68h+mins.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+68h+mins.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vmovss  dword ptr [rsp+68h+maxs.m_quad], xmm1
    vmovss  dword ptr [rsp+68h+maxs.m_quad+4], xmm0
    vmovss  dword ptr [rsp+68h+maxs.m_quad+8], xmm2
    vmovss  dword ptr [rsp+68h+mins.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+68h+maxs.m_quad+0Ch], xmm3
  }
  return HavokPhysics_CreateShapeConvexHullFromAABB(&minsa, &maxsa);
}

/*
==============
Physics_CreateShapeCube
==============
*/

hknpShape *__fastcall Physics_CreateShapeCube(const vec3_t *center, double halfSize)
{
  bool v9; 
  bool v10; 
  hknpShape *result; 
  int v20; 
  int v21; 
  int v22; 
  hkVector4f centera; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
  }
  _RBX = center;
  __asm { vmovaps xmm7, xmm1 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9976, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeCylinder when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+88h+var_58], xmm0
  }
  if ( (v20 & 0x7F800000) == 2139095040 )
    goto LABEL_15;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+88h+var_58], xmm0
  }
  if ( (v21 & 0x7F800000) == 2139095040 )
    goto LABEL_15;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+88h+var_58], xmm0
  }
  v9 = (v22 & 0x7F800000u) < 0x7F800000;
  if ( (v22 & 0x7F800000) == 2139095040 )
  {
LABEL_15:
    v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9977, ASSERT_TYPE_ASSERT, "(!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] ))", "%s\n\tPhysics: Trying to CreateShapeCube with invalid center", "!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] )");
    v9 = 0;
    if ( v10 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm7, xmm6
  }
  if ( v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9978, ASSERT_TYPE_ASSERT, "(halfSize >= 0.f)", "%s\n\tPhysics: Trying to CreateShapeCube with bad halfSize", "halfSize >= 0.f") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm1, xmm3, dword ptr [rbx+8]
    vmulss  xmm0, xmm3, dword ptr [rbx]
    vmulss  xmm2, xmm3, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+88h+center.m_quad+8], xmm1
    vmulss  xmm1, xmm7, xmm3; halfSize
    vmovss  dword ptr [rsp+88h+center.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+center.m_quad+4], xmm2
    vmovss  dword ptr [rsp+88h+center.m_quad+0Ch], xmm6
  }
  result = HavokPhysics_CreateShapeCube(&centera, *(float *)&_XMM1);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
  return result;
}

/*
==============
Physics_CreateShapeCylinder
==============
*/

hknpShape *__fastcall Physics_CreateShapeCylinder(const vec3_t *center, double halfHeight, double radius, int numVertices, bool useCache)
{
  bool v15; 
  bool v16; 
  bool v17; 
  bool v19; 
  hknpShape *result; 
  int v30; 
  int v31; 
  int v32; 
  hkVector4f centera; 

  __asm
  {
    vmovaps [rsp+0A8h+var_28], xmm6
    vmovaps [rsp+0A8h+var_38], xmm7
    vmovaps [rsp+0A8h+var_48], xmm8
  }
  _RBX = center;
  __asm
  {
    vmovaps xmm8, xmm2
    vmovaps xmm7, xmm1
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9998, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeCylinder when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_78], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_22;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_78], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
    goto LABEL_22;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_78], xmm0
  }
  v15 = (v32 & 0x7F800000u) < 0x7F800000;
  v16 = (v32 & 0x7F800000u) <= 0x7F800000;
  if ( (v32 & 0x7F800000) == 2139095040 )
  {
LABEL_22:
    v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9999, ASSERT_TYPE_ASSERT, "(!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] ))", "%s\n\tPhysics: Trying to CreateShapeCylinder with invalid center", "!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] )");
    v15 = 0;
    v16 = !v17;
    if ( v17 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm7, xmm6
  }
  if ( v15 )
  {
    v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10000, ASSERT_TYPE_ASSERT, "(halfHeight >= 0.f)", "%s\n\tPhysics: Trying to CreateShapeCylinder with bad halfheight", "halfHeight >= 0.f");
    v16 = !v19;
    if ( v19 )
      __debugbreak();
  }
  __asm { vcomiss xmm8, xmm6 }
  if ( v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10001, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to CreateShapeCylinder with bad radius", "radius > 0.f") )
    __debugbreak();
  if ( (numVertices < 8 || (numVertices & 1) != 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10002, ASSERT_TYPE_ASSERT, "(numVertices >= 8 && !(numVertices & 1))", "%s\n\tPhysics: Trying to CreateShapeCylinder with bad vertex count", "numVertices >= 8 && !(numVertices & 1)") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rbx+4]
    vmulss  xmm1, xmm3, dword ptr [rbx+8]
    vmulss  xmm0, xmm3, dword ptr [rbx]
    vmovss  dword ptr [rsp+0A8h+center.m_quad+4], xmm2
    vmovss  dword ptr [rsp+0A8h+center.m_quad+8], xmm1
    vmulss  xmm2, xmm8, xmm3; radius
    vmulss  xmm1, xmm7, xmm3; halfHeight
    vmovss  dword ptr [rsp+0A8h+center.m_quad], xmm0
    vmovss  dword ptr [rsp+0A8h+center.m_quad+0Ch], xmm6
  }
  result = HavokPhysics_CreateShapeCylinder(&centera, *(float *)&_XMM1, *(float *)&_XMM2, numVertices, useCache);
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_28]
    vmovaps xmm7, [rsp+0A8h+var_38]
    vmovaps xmm8, [rsp+0A8h+var_48]
  }
  return result;
}

/*
==============
Physics_CreateShapeSphere
==============
*/

hknpShape *__fastcall Physics_CreateShapeSphere(const vec3_t *center, double radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  bool v13; 
  bool v14; 
  hknpShape *result; 
  int v24; 
  int v25; 
  int v26; 
  hkVector4f centera; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  _RBX = center;
  __asm { vmovaps xmm7, xmm1 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9900, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateShapeSphere when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_68], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
    goto LABEL_19;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_68], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_19;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_68], xmm0
  }
  v13 = (v26 & 0x7F800000u) <= 0x7F800000;
  if ( (v26 & 0x7F800000) == 2139095040 )
  {
LABEL_19:
    v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9901, ASSERT_TYPE_ASSERT, "(!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] ))", "%s\n\tPhysics: Trying to CreateShapeSphere with invalid center", "!IS_NAN( center[0] ) && !IS_NAN( center[1] ) && !IS_NAN( center[2] )");
    v13 = !v14;
    if ( v14 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm7, xmm6
  }
  if ( v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9902, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to CreateShapeSphere with bad radius", "radius > 0.f") )
    __debugbreak();
  if ( optionalInplaceBuffer && optionalInplaceBufferSize <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9903, ASSERT_TYPE_ASSERT, "(!optionalInplaceBuffer || optionalInplaceBufferSize > 0)", "%s\n\tPhysics: Trying to CreateShapeSphere with bad inplace buffer data", "!optionalInplaceBuffer || optionalInplaceBufferSize > 0") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm1, xmm3, dword ptr [rbx+8]
    vmulss  xmm0, xmm3, dword ptr [rbx]
    vmulss  xmm2, xmm3, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+98h+center.m_quad+8], xmm1
    vmulss  xmm1, xmm7, xmm3; radius
    vmovss  dword ptr [rsp+98h+center.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+center.m_quad+4], xmm2
    vmovss  dword ptr [rsp+98h+center.m_quad+0Ch], xmm6
  }
  result = HavokPhysics_CreateShapeSphere(&centera, *(float *)&_XMM1, optionalInplaceBuffer, optionalInplaceBufferSize);
  __asm
  {
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
  return result;
}

/*
==============
Physics_CreateWorld
==============
*/
void Physics_CreateWorld(Physics_WorldId worldId)
{
  unsigned __int64 v1; 
  Physics_WorldCInfo *v2; 
  Physics_WorldInfo *v3; 
  bool isMultiThreaded; 
  GVehicles *VehicleSystem; 
  int LocalClientForWorld; 
  CgVehicleSystem *v7; 
  int v8; 

  v1 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1653, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateWorld when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v1 > 7 )
  {
    v8 = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1654, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to CreateWorld with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
      __debugbreak();
  }
  if ( v1 >= 8 )
  {
    j___report_rangecheckfailure(v1);
    JUMPOUT(0x140EA776Fi64);
  }
  v2 = &s_physicsWorldCInfos[v1];
  v3 = &s_physicsWorldInfos[v1];
  g_physicsBroadphaseQueriesNotAllowedForWorld[v1] = 0;
  isMultiThreaded = v2->isMultiThreaded;
  g_physicsQueriesNotAllowedForWorld[v1] = 0;
  v3->isMultiThreaded = isMultiThreaded;
  v3->defaultTimestep = v2->defaultTimeStep;
  *(_QWORD *)&v3->timePreStep = 0i64;
  g_physicsBroadphaseRefreshNeeded[v1] = 0;
  HavokPhysics_CreateWorld((Physics_WorldId)v1, v2);
  PhysicsQuery_InitForWorld((Physics_WorldId)v1);
  if ( v2->hasFXSupport )
    PhysicsFX_RegisterWorld((Physics_WorldId)v1);
  Physics_SimpleCollisionCallback_InitForWorld((Physics_WorldId)v1);
  Physics_ManifoldCallback_InitForWorld((Physics_WorldId)v1);
  if ( GVehicles::ms_gVehiclesSystem )
  {
    VehicleSystem = GVehicles::GetVehicleSystem();
    PhysicsVehicle_CreateWorld((Physics_WorldId)v1, VehicleSystem);
  }
  LocalClientForWorld = Physics_GetLocalClientForWorld((Physics_WorldId)v1);
  if ( LocalClientForWorld >= 0 && LocalClientForWorld < CgVehicleSystem::ms_allocatedCount )
  {
    if ( CgVehicleSystem::ms_vehicleSystemArray[LocalClientForWorld] )
    {
      v7 = CgVehicleSystem::GetVehicleSystem((const LocalClientNum_t)LocalClientForWorld);
      PhysicsVehicle_CreateWorld((Physics_WorldId)v1, v7);
    }
  }
}

/*
==============
Physics_DeactivateBody
==============
*/
void Physics_DeactivateBody(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v4; 
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7844, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to deactivate a body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7845, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to deactivate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7846, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to deactivate a body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v4) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_DeactivateBody(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_DecodeShapeKeyIntoShapes
==============
*/

unsigned int __fastcall Physics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, unsigned int bodyId, unsigned int key, const hknpShape **shapes)
{
  return HavokPhysics_DecodeShapeKeyIntoShapes(worldId, (hknpBodyId)bodyId, (hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant>)key, shapes);
}

/*
==============
Physics_DecodeSubShapeKey
==============
*/
void Physics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, unsigned __int16 *shapeInstanceId)
{
  hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *v9; 
  __int64 v10; 
  hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> v11; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10233, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DecodeSubShapeKey when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10234, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DecodeSubShapeKey with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10235, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to DecodeSubShapeKey with invalid InstanceId in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v10) )
      __debugbreak();
  }
  if ( !bodyIdx )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10236, ASSERT_TYPE_ASSERT, "(bodyIdx)", "%s\n\tPhysics: Trying to DecodeSubShapeKey with invalid bodyIdx in world %i", "bodyIdx", v10) )
      __debugbreak();
  }
  v9 = (hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *)shapeInstanceId;
  if ( !shapeInstanceId )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10237, ASSERT_TYPE_ASSERT, "(shapeInstanceId)", "%s\n\tPhysics: Trying to DecodeSubShapeKey with invalid shapeInstanceId in world %i", "shapeInstanceId", v10) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_DecodeSubShapeKey(worldId, instanceId, key, bodyIdx, &v11);
  v9->m_value = v11.m_value;
}

/*
==============
Physics_DeferredAABBBroadphaseQuery
==============
*/
void Physics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  hkAabb v31; 

  _RBX = max;
  _RDI = min;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8412, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8413, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8414, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8415, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8416, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8417, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred aabb broadphase query with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+var_58], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+0A8h+var_58+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+0A8h+var_58+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+10h], xmm1
    vmovss  dword ptr [rsp+0A8h+var_58+14h], xmm0
    vmovss  dword ptr [rsp+0A8h+var_58+18h], xmm2
    vmovss  dword ptr [rsp+0A8h+var_58+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+1Ch], xmm3
    vmovups ymm0, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
  }
  HavokPhysics_DeferredAABBBroadphaseQuery(worldId, &v31, extendedData, data);
}

/*
==============
Physics_DeferredAABBQuery
==============
*/
void Physics_DeferredAABBQuery(Physics_WorldId worldId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  hkAabb v31; 

  _RBX = max;
  _RDI = min;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8514, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred aabb query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8515, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8516, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb query with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8517, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb query with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8518, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8519, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred aabb query with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+var_58], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+0A8h+var_58+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+0A8h+var_58+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+10h], xmm1
    vmovss  dword ptr [rsp+0A8h+var_58+14h], xmm0
    vmovss  dword ptr [rsp+0A8h+var_58+18h], xmm2
    vmovss  dword ptr [rsp+0A8h+var_58+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+1Ch], xmm3
    vmovups ymm0, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
  }
  HavokPhysics_DeferredAABBQuery(worldId, &v31, extendedData, data);
}

/*
==============
Physics_DeferredAABBQuery
==============
*/
void Physics_DeferredAABBQuery(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *min, const vec3_t *max, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  __int64 v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  hkAabb v33; 

  _RBX = max;
  _RDI = min;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9161, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred aabb query when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9162, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9163, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v26) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
  {
LABEL_32:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9164, ASSERT_TYPE_ASSERT, "(!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid start", "!IS_NAN( min[0] ) && !IS_NAN( min[1] ) && !IS_NAN( min[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_33;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
    goto LABEL_33;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v32 & 0x7F800000) == 2139095040 )
  {
LABEL_33:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9165, ASSERT_TYPE_ASSERT, "(!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] ))", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid start", "!IS_NAN( max[0] ) && !IS_NAN( max[1] ) && !IS_NAN( max[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9166, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9167, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire deferred aabb query against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9168, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred aabb query against body with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+var_58], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+0A8h+var_58+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+0A8h+var_58+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+10h], xmm1
    vmovss  dword ptr [rsp+0A8h+var_58+14h], xmm0
    vmovss  dword ptr [rsp+0A8h+var_58+18h], xmm2
    vmovss  dword ptr [rsp+0A8h+var_58+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+var_58+1Ch], xmm3
    vmovups ymm0, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
  }
  HavokPhysics_DeferredAABBQuery(worldId, (hknpBodyId)bodyId, &v33, extendedData, data);
}

/*
==============
Physics_DeferredGetClosestPoints
==============
*/
void Physics_DeferredGetClosestPoints(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  float v42; 
  Physics_GetClosestPointsExtendedData *v43; 
  int v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  hkVector4f pointa; 
  hkQuaternionf v52; 
  char v54; 

  __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
  _RDI = point;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9672, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9673, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v43) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9674, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v43) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9675, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
  {
LABEL_39:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9676, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  _RBX = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
  {
LABEL_40:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9677, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9678, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9679, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9680, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9681, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints against body with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rdi]
    vmulss  xmm2, xmm6, dword ptr [rdi+4]
    vmulss  xmm1, xmm6, dword ptr [rdi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0B8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0B8h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+0B8h+point.m_quad+0Ch], xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+0B8h+point.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmulss  xmm2, xmm6, [rsp+0B8h+maxDistance]
    vmovss  [rsp+0B8h+var_90], xmm2
    vmovups xmmword ptr [rsp+0B8h+var_58.m_vec.m_quad], xmm1
  }
  HavokPhysics_DeferredGetClosestPoints(worldId, (hknpBodyId)bodyId, shape, &pointa, &v52, v42, extendedData, data);
  _R11 = &v54;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
Physics_DeferredGetClosestPoints
==============
*/
void Physics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  float fmt; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  int v45; 
  int v46; 
  hkVector4f pointa; 
  hkQuaternionf rotationa; 

  __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
  _RBX = rotation;
  _RDI = point;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9049, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9050, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9051, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire deferred Shapecast with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
  {
LABEL_30:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9052, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_31;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
    goto LABEL_31;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_31;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
  {
LABEL_31:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9053, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9054, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9055, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred GetClosestPoints with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rdi]
    vmulss  xmm2, xmm6, dword ptr [rdi+4]
    vmulss  xmm1, xmm6, dword ptr [rdi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0B8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0B8h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+0B8h+point.m_quad+0Ch], xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+0B8h+point.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmulss  xmm2, xmm6, [rsp+0B8h+maxDistance]
    vmovss  dword ptr [rsp+0B8h+fmt], xmm2
    vmovups xmmword ptr [rsp+0B8h+rotation.m_vec.m_quad], xmm1
  }
  HavokPhysics_DeferredGetClosestPoints(worldId, shape, &pointa, &rotationa, fmt, extendedData, data);
  __asm { vmovaps xmm6, [rsp+0B8h+var_38] }
}

/*
==============
Physics_DeferredQueryPoint
==============
*/

void __fastcall Physics_DeferredQueryPoint(Physics_WorldId worldId, const vec3_t *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  int v20; 
  int v21; 
  int v22; 
  hkVector4f pointa; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  _RBX = point;
  __asm { vmovaps xmm6, xmm2 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8947, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred QueryPoint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8948, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred QueryPoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v20 & 0x7F800000) == 2139095040 )
    goto LABEL_21;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v21 & 0x7F800000) == 2139095040 )
    goto LABEL_21;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
  {
LABEL_21:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8949, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire deferred QueryPoint with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8950, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred QueryPoint with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8951, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred QueryPoint with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rbx+4]
    vmulss  xmm0, xmm3, dword ptr [rbx]
    vmulss  xmm1, xmm3, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+98h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+98h+point.m_quad+0Ch], xmm2
    vmulss  xmm2, xmm6, xmm3; maxDistance
    vmovss  dword ptr [rsp+98h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+point.m_quad+8], xmm1
  }
  HavokPhysics_DeferredQueryPoint(worldId, &pointa, *(float *)&_XMM2, extendedData, data);
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
}

/*
==============
Physics_DeferredQueryPoint
==============
*/

void __fastcall Physics_DeferredQueryPoint(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  __int64 v21; 
  int v22; 
  int v23; 
  int v24; 
  hkVector4f pointa; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  _RBX = point;
  __asm { vmovaps xmm6, xmm3 }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9571, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9572, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v21) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9573, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v21) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
  {
LABEL_30:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9574, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9575, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9576, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9577, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9578, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred QueryPoint against body with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rbx+4]
    vmulss  xmm0, xmm3, dword ptr [rbx]
    vmulss  xmm1, xmm3, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+98h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmulss  xmm3, xmm6, xmm3; maxDistance
    vmovss  dword ptr [rsp+98h+point.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+98h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+point.m_quad+8], xmm1
  }
  HavokPhysics_DeferredQueryPoint(worldId, (hknpBodyId)bodyId, &pointa, *(float *)&_XMM3, extendedData, data);
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
}

/*
==============
Physics_DeferredRaycast
==============
*/
void Physics_DeferredRaycast(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  int v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  hkVector4f enda; 
  hkVector4f starta; 

  _RBX = end;
  _RDI = start;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8615, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred Raycast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8616, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred Raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
  {
LABEL_26:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8617, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire deferred Raycast with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8618, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire deferred Raycast with invalid start", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8619, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred Raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8620, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred Raycast with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vmovss  dword ptr [rsp+0A8h+end.m_quad], xmm1
    vmovss  dword ptr [rsp+0A8h+end.m_quad+4], xmm0
    vmovss  dword ptr [rsp+0A8h+end.m_quad+8], xmm2
    vmovss  dword ptr [rsp+0A8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+end.m_quad+0Ch], xmm3
  }
  HavokPhysics_DeferredRaycast(worldId, &starta, &enda, extendedData, data);
}

/*
==============
Physics_DeferredRaycast
==============
*/
void Physics_DeferredRaycast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  __int64 v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  hkVector4f enda; 
  hkVector4f starta; 

  _RBX = end;
  _RDI = start;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9260, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred Raycast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred Raycast against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9262, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire deferred raycast against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v25) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
LABEL_32:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9263, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire deferred Raycast against body with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_33;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_33;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_33:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9264, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire deferred Raycast against body with invalid start", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9265, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred Raycast against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9266, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire deferred Raycast against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9267, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred Raycast against body with invalid data", "data") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rdi]
    vmulss  xmm2, xmm4, dword ptr [rdi+4]
    vmulss  xmm1, xmm4, dword ptr [rdi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbx]
    vmovss  dword ptr [rsp+0A8h+end.m_quad], xmm1
    vmovss  dword ptr [rsp+0A8h+end.m_quad+4], xmm0
    vmovss  dword ptr [rsp+0A8h+end.m_quad+8], xmm2
    vmovss  dword ptr [rsp+0A8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+end.m_quad+0Ch], xmm3
  }
  HavokPhysics_DeferredRaycast(worldId, (hknpBodyId)bodyId, &starta, &enda, extendedData, data);
}

/*
==============
Physics_DeferredShapecast
==============
*/
void Physics_DeferredShapecast(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  Physics_ShapecastExtendedData *v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  int v58; 
  hkVector4f v59; 
  hkVector4f starta; 
  hkQuaternionf v61; 

  __asm { vmovaps [rsp+0D8h+var_48], xmm6 }
  _RSI = start;
  _RBP = extendedData;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9361, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9362, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v48) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9363, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire deferred shapecast against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v48) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9364, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
  {
LABEL_44:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9365, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  _RDI = end;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_45;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
    goto LABEL_45;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
  {
LABEL_45:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9366, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid start", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  _RBX = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_46;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
    goto LABEL_46;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v57 & 0x7F800000) == 2139095040 )
    goto LABEL_46;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v58 & 0x7F800000) == 2139095040 )
  {
LABEL_46:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9367, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9368, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9369, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9370, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with invalid data", "data") )
    __debugbreak();
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( data->startResult )
  {
    __asm { vcomiss xmm6, dword ptr [rbp+4] }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9371, ASSERT_TYPE_ASSERT, "(!data->startResult || extendedData->startTolerance > 0.f)", "%s\n\tPhysics: Trying to fire deferred Shapecast against body with startResult and bad tolerance", "!data->startResult || extendedData->startTolerance > 0.f") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0D8h+start.m_quad], xmm0
    vmulss  xmm0, xmm3, dword ptr [rdi+4]
    vmovss  dword ptr [rsp+0D8h+var_88.m_quad+4], xmm0
    vmovss  dword ptr [rsp+0D8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0D8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm3, dword ptr [rdi]
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm4, xmm0
    vmovss  dword ptr [rsp+0D8h+var_88.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0D8h+var_88.m_quad+8], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0D8h+var_68.m_vec.m_quad], xmm1
    vmovss  dword ptr [rsp+0D8h+start.m_quad+0Ch], xmm6
    vmovss  dword ptr [rsp+0D8h+var_88.m_quad+0Ch], xmm6
  }
  HavokPhysics_DeferredShapecast(worldId, (hknpBodyId)bodyId, shape, &starta, &v59, &v61, extendedData, data);
  __asm { vmovaps xmm6, [rsp+0D8h+var_48] }
}

/*
==============
Physics_DeferredShapecast
==============
*/
void Physics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  hkVector4f enda; 
  hkVector4f starta; 
  hkQuaternionf v59; 
  char v61; 

  __asm { vmovaps [rsp+0C8h+var_38], xmm6 }
  _RDI = end;
  _R14 = extendedData;
  _RSI = start;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8808, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire deferred Shapecast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8809, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8810, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire deferred Shapecast with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8811, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
  {
LABEL_39:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8812, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid end", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  _RBX = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
  {
LABEL_40:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8813, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8814, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8815, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tPhysics: Trying to fire deferred Shapecast with invalid data", "data") )
    __debugbreak();
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( data->startResult )
  {
    __asm { vcomiss xmm6, dword ptr [r14+4] }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8816, ASSERT_TYPE_ASSERT, "(!data->startResult || extendedData->startTolerance > 0.f)", "%s\n\tPhysics: Trying to fire deferred Shapecast with startResult and bad tolerance", "!data->startResult || extendedData->startTolerance > 0.f") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0C8h+start.m_quad], xmm0
    vmulss  xmm0, xmm3, dword ptr [rdi+4]
    vmovss  dword ptr [rsp+0C8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0C8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm3, dword ptr [rdi]
    vmovss  dword ptr [rsp+0C8h+end.m_quad+4], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmovss  dword ptr [rsp+0C8h+end.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0C8h+end.m_quad+8], xmm2
    vmulps  xmm0, xmm4, xmm0
    vmulps  xmm2, xmm0, xmm4
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmulps  xmm1, xmm3, xmm2
    vmulps  xmm3, xmm1, xmm5
    vmovups xmmword ptr [rsp+0C8h+var_58.m_vec.m_quad], xmm3
    vmovss  dword ptr [rsp+0C8h+start.m_quad+0Ch], xmm6
    vmovss  dword ptr [rsp+0C8h+end.m_quad+0Ch], xmm6
  }
  HavokPhysics_DeferredShapecast(worldId, shape, &starta, &enda, &v59, extendedData, data);
  _R11 = &v61;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
Physics_DestroyClientWorlds
==============
*/
void Physics_DestroyClientWorlds(void)
{
  LocalClientNum_t v0; 
  int i; 
  int v2; 
  int j; 
  Physics_WorldId v4; 

  Sys_EnterCriticalSection(CRITSECT_PHYS_WORLDCREATE);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1988, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateServerWorlds when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !g_physicsClientWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1989, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated)", "%s\n\tPhysics: Trying to DestroyClientWorlds that weren't created", "g_physicsClientWorldsCreated") )
    __debugbreak();
  v0 = LOCAL_CLIENT_0;
  for ( i = 3; i <= 6; i += 3 )
  {
    if ( CG_PhysicsVolume_IsInitialized(v0) )
      CG_PhysicsVolume_Shutdown(v0);
    if ( PhysicsSVFX_IsWorldRegistered((Physics_WorldId)i, v0) )
      PhysicsSVFX_UnregisterWorld((Physics_WorldId)i, v0);
    if ( PhysicsGravityModifier_IsInitialized((const Physics_WorldId)i) )
      PhysicsGravityModifier_Shutdown((const Physics_WorldId)i);
    if ( PhysicsGravityModifier_IsInitialized((const Physics_WorldId)(i - 1)) )
      PhysicsGravityModifier_Shutdown((const Physics_WorldId)(i - 1));
    if ( PhysicsForceAction_IsInitialized((const Physics_WorldId)i) )
      PhysicsForceAction_Shutdown((const Physics_WorldId)i);
    if ( PhysicsForceAction_IsInitialized((const Physics_WorldId)(i - 1)) )
      PhysicsForceAction_Shutdown((const Physics_WorldId)(i - 1));
    ++v0;
  }
  CG_PhysicsCharacterProxy_Clear();
  CG_PhysicsCoverWall_Clear();
  v2 = 1;
  for ( j = 4; j <= 7; j += 3 )
  {
    if ( (v2 & g_physicsClientWorldsCreated) != 0 )
    {
      v4 = j;
      if ( !__OFSUB__(j, j - 2) )
      {
        do
          Physics_DestroyWorld(v4--);
        while ( v4 >= j - 2 );
      }
    }
    v2 = __ROL4__(v2, 1);
  }
  g_physicsClientWorldsCreated = 0;
  if ( !g_physicsServerWorldsCreated )
    Physics_NoWorldTidyUp();
  HavokPhysics_DoGarbageCollectionClient();
  Sys_LeaveCriticalSection(CRITSECT_PHYS_WORLDCREATE);
}

/*
==============
Physics_DestroyConstraint
==============
*/
void Physics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5769, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Destroy constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5770, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Destroy constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5771, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Destroy constraint in invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5772, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Destroy constraint in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v8) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5773, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Destroy constraint in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v8) )
      __debugbreak();
  }
  if ( constraintIdx < 0 || constraintIdx >= (int)Physics_GetNumConstraints(worldId, instanceId) )
  {
    LODWORD(v8) = constraintIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5774, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < (int)Physics_GetNumConstraints( worldId, instanceId))", "%s\n\tPhysics: Trying to Destroy constraint with invalid index %i in world %i", "constraintIdx >= 0 && constraintIdx < (int)Physics_GetNumConstraints( worldId, instanceId)", v8, worldId) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_DestroyConstraint(worldId, instanceId, constraintIdx, activate);
}

/*
==============
Physics_DestroyInstance
==============
*/
void Physics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v5; 
  void (__fastcall *v6)(Physics_WorldId); 
  __int64 v7; 

  v5 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5741, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Destroy Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v5 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5742, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Destroy Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v7) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5743, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Destroy invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v7) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v5 - 2) <= 5 )
  {
    LODWORD(v7) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5744, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Destroy Instance in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v7) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v5 <= 1 )
  {
    LODWORD(v7) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5745, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Destroy Instance in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v7) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  if ( !Com_ErrorEntered() || HavokPhysics_IsInstanceInUse((Physics_WorldId)v5, instanceId) )
  {
    HavokPhysics_DestroyInstance((Physics_WorldId)v5, instanceId, activate);
    v6 = s_physicsWorldBodyListChangedFns[v5];
    if ( v6 )
      v6((Physics_WorldId)v5);
  }
}

/*
==============
Physics_DestroyServerWorlds
==============
*/
void Physics_DestroyServerWorlds(void)
{
  int i; 

  Sys_EnterCriticalSection(CRITSECT_PHYS_WORLDCREATE);
  if ( !level.initializing || g_physicsServerWorldsCreated )
  {
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1946, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to CreateServerWorlds when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( !g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1947, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated)", "%s\n\tPhysics: Trying to DestroyServerWorlds that weren't created", "g_physicsServerWorldsCreated") )
      __debugbreak();
    G_PhysicsVolume_Shutdown();
    __asm { vmovss  xmm0, cs:__real@3f800000; velocityScale }
    G_PhysicsCharacterProxy_Update(*(float *)&_XMM0);
    PhysicsGravityModifier_Shutdown(PHYSICS_WORLD_ID_FIRST);
    PhysicsForceAction_Shutdown(PHYSICS_WORLD_ID_FIRST);
    for ( i = 1; i >= 0; --i )
      Physics_DestroyWorld((Physics_WorldId)i);
    g_physicsServerWorldsCreated = 0;
    if ( !g_physicsClientWorldsCreated )
      Physics_NoWorldTidyUp();
    HavokPhysics_DoGarbageCollectionServer();
  }
  Sys_LeaveCriticalSection(CRITSECT_PHYS_WORLDCREATE);
}

/*
==============
Physics_DestroyWorld
==============
*/
void Physics_DestroyWorld(Physics_WorldId worldId)
{
  __int64 v1; 
  LocalClientNum_t v2; 
  int integer; 
  unsigned int v4; 
  CgVehicleSystem *VehicleSystem; 

  v1 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1721, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DestroyWorld when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v1 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1722, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DestroyWorld with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v1) )
    __debugbreak();
  v2 = LOCAL_CLIENT_0;
  integer = physics_debugVisualizeWorld->current.integer;
  if ( integer )
  {
    v4 = integer - 2;
    if ( v4 > 7 )
      v4 = -1;
    if ( !g_physicsServerWorldsCreated && v4 <= 1 )
      v4 = -1;
    if ( !g_physicsClientWorldsCreated && v4 - 2 <= 5 )
      v4 = -1;
    if ( v4 == (_DWORD)v1 )
    {
      Dvar_SetInt_Internal(physics_debugVisualizeWorld, 0);
      Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorld);
      if ( g_physicsServerWorldsCreated || g_physicsClientWorldsCreated )
        HavokPhysics_StopDrawDebugWorld((Physics_WorldId)v1);
    }
  }
  if ( GVehicles::ms_gVehiclesSystem )
    PhysicsVehicle_DestroyWorld((Physics_WorldId)v1, GVehicles::ms_gVehiclesSystem);
  if ( (unsigned int)v1 > 1 )
  {
    if ( (int)v1 <= 4 )
    {
LABEL_26:
      if ( v2 < CgVehicleSystem::ms_allocatedCount && CgVehicleSystem::ms_vehicleSystemArray[v2] )
      {
        VehicleSystem = CgVehicleSystem::GetVehicleSystem(v2);
        PhysicsVehicle_DestroyWorld((Physics_WorldId)v1, VehicleSystem);
      }
      goto LABEL_31;
    }
    if ( (int)v1 <= 7 )
    {
      v2 = LOCAL_CLIENT_1;
      goto LABEL_26;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
  }
LABEL_31:
  Physics_ManifoldCallback_ShutdownForWorld((Physics_WorldId)v1);
  Physics_SimpleCollisionCallback_ShutdownForWorld((Physics_WorldId)v1);
  if ( s_physicsWorldCInfos[v1].hasFXSupport )
    PhysicsFX_UnregisterWorld((Physics_WorldId)v1);
  PhysicsQuery_ShutdownForWorld((Physics_WorldId)v1);
  HavokPhysics_DestroyWorld((Physics_WorldId)v1);
}

/*
==============
Physics_DirtyBroadphase
==============
*/
void Physics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6429, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Physics_DirtyBroadphase when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6430, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Instance contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !array && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6431, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array") )
    __debugbreak();
  HavokPhysics_DirtyBroadphase(worldId, array);
}

/*
==============
Physics_DisableShapeCache
==============
*/

void __fastcall Physics_DisableShapeCache(unsigned int threadId, bool disable)
{
  HavokPhysics_DisableShapeCache(threadId, disable);
}

/*
==============
Physics_DoCmd_StepWorldCollide
==============
*/
void Physics_DoCmd_StepWorldCollide(const void *const cmdInfo)
{
  int v4; 
  int v5; 
  __int64 v6; 
  int v10; 
  __int128 data; 
  int v12; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RBX = cmdInfo;
  __asm { vmovss  xmm6, dword ptr [rcx+10h] }
  v4 = *((_DWORD *)cmdInfo + 3);
  v5 = *((_DWORD *)cmdInfo + 2);
  v6 = *(int *)cmdInfo;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2801, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World collide when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v6 > 7 )
  {
    v10 = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2802, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World collide with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  qword_14B804BF0[v6] = Sys_Milliseconds();
  __asm { vmovaps xmm3, xmm6; stepTimeOverride }
  HavokPhysics_StepWorldCollide((Physics_WorldId)v6, v5, v4, *(float *)&_XMM3);
  Physics_SetBroadphaseNeedsRefresh((const Physics_WorldId)v6, 0);
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v12 = _RBX[4];
  __asm { vmovups [rsp+78h+data], xmm0 }
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_SOLVE, &data);
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
Physics_DoCmd_StepWorldDetail
==============
*/
void Physics_DoCmd_StepWorldDetail(const void *const cmdInfo)
{
  Physics_StepWorldDetail(*(Physics_WorldId *)cmdInfo, *((_DWORD *)cmdInfo + 2), *((_DWORD *)cmdInfo + 3));
}

/*
==============
Physics_DoCmd_StepWorldEnd
==============
*/
void Physics_DoCmd_StepWorldEnd(const void *const cmdInfo)
{
  __int128 data; 
  int v4; 

  _RBX = cmdInfo;
  Physics_StepWorldEnd(*(Physics_WorldId *)cmdInfo, *((_DWORD *)cmdInfo + 2), *((_DWORD *)cmdInfo + 3));
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v4 = _RBX[4];
  __asm { vmovups [rsp+48h+data], xmm0 }
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_DETAIL, &data);
}

/*
==============
Physics_DoCmd_StepWorldFX
==============
*/
void Physics_DoCmd_StepWorldFX(const void *const cmdInfo)
{
  int *v2; 
  int v3; 
  int v4; 
  Physics_WorldId v5; 
  int v8; 
  int v9; 
  Physics_WorldId v11; 
  int data; 

  v2 = (int *)cmdInfo;
  v3 = *((_DWORD *)cmdInfo + 3);
  v4 = *((_DWORD *)cmdInfo + 2);
  v5 = *(_DWORD *)cmdInfo;
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovss  xmm6, dword ptr [rcx+10h]
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2833, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World fx when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v5 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v11 = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2834, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World fx with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  __asm { vmovaps xmm3, xmm6; stepTimeOverride }
  HavokPhysics_StepWorldFX(v5, v4, v3, *(float *)&_XMM3);
  v8 = *v2;
  if ( (unsigned int)*v2 <= 1 )
    goto LABEL_14;
  if ( v8 > 4 )
  {
    if ( v8 <= 7 )
    {
      v9 = 1;
      goto LABEL_15;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
LABEL_14:
    v9 = -1;
    goto LABEL_15;
  }
  v9 = 0;
LABEL_15:
  data = v9;
  Sys_AddWorkerCmd(WRKCMD_PHYSICSFX_PLAYSOUNDS, &data);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
Physics_DoCmd_StepWorldPhysicsObjects
==============
*/
void Physics_DoCmd_StepWorldPhysicsObjects(const void *const cmdInfo)
{
  Physics_StepWorldPhysicsObjects(*(Physics_WorldId *)cmdInfo, *((_DWORD *)cmdInfo + 2), *((_DWORD *)cmdInfo + 3));
}

/*
==============
Physics_DoCmd_StepWorldPrep
==============
*/
void Physics_DoCmd_StepWorldPrep(const void *const cmdInfo)
{
  int v4; 
  int v5; 
  Physics_WorldId v6; 
  Physics_WorldId v10; 
  __int128 data; 
  int v12; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RBX = cmdInfo;
  __asm { vmovss  xmm6, dword ptr [rcx+10h] }
  v4 = *((_DWORD *)cmdInfo + 3);
  v5 = *((_DWORD *)cmdInfo + 2);
  v6 = *(_DWORD *)cmdInfo;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2789, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World Prep when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v6 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v10 = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2790, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World Prep with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  __asm { vmovaps xmm3, xmm6; stepTimeOverride }
  HavokPhysics_StepWorldPrep(v6, v5, v4, *(float *)&_XMM3);
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v12 = _RBX[4];
  __asm { vmovups [rsp+78h+data], xmm0 }
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_COLLIDE, &data);
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
Physics_DoCmd_StepWorldSolve
==============
*/
void Physics_DoCmd_StepWorldSolve(const void *const cmdInfo)
{
  int v4; 
  int v5; 
  Physics_WorldId v6; 
  Physics_WorldId v10; 
  __int128 data; 
  int v12; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RBX = cmdInfo;
  __asm { vmovss  xmm6, dword ptr [rcx+10h] }
  v4 = *((_DWORD *)cmdInfo + 3);
  v5 = *((_DWORD *)cmdInfo + 2);
  v6 = *(_DWORD *)cmdInfo;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2820, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World solve when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v6 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v10 = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2821, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World solve with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  __asm { vmovaps xmm3, xmm6; stepTimeOverride }
  HavokPhysics_StepWorldSolve(v6, v5, v4, *(float *)&_XMM3);
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v12 = _RBX[4];
  __asm { vmovups [rsp+78h+data], xmm0 }
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_FX, &data);
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_END, &data);
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_PHYSICS_OBJECTS, &data);
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
Physics_DoCmd_StepWorldStart
==============
*/
void Physics_DoCmd_StepWorldStart(const void *const cmdInfo)
{
  float v4; 
  __int128 data; 
  int v6; 

  __asm { vmovss  xmm0, dword ptr [rcx+10h] }
  _RBX = cmdInfo;
  __asm { vmovss  [rsp+58h+var_38], xmm0 }
  Physics_StepWorldStart(*(Physics_WorldId *)cmdInfo, *((_DWORD *)cmdInfo + 1), *((_DWORD *)cmdInfo + 2), *((_DWORD *)cmdInfo + 3), v4);
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v6 = _RBX[4];
  __asm { vmovups [rsp+58h+data], xmm0 }
  Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_PREP, &data);
}

/*
==============
Physics_DoCmd_Task
==============
*/
void Physics_DoCmd_Task(const void *const cmdInfo)
{
  int v1; 
  Physics_WorldId v2; 
  Physics_WorldId v3; 

  v1 = *((_DWORD *)cmdInfo + 1);
  v2 = *(_DWORD *)cmdInfo;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2879, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Process a task when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v2 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v3 = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2880, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Process a task with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v3) )
      __debugbreak();
  }
  Profile_Begin(612);
  HavokPhysics_Task(v2, v1);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_DoCmd_UpdatePredictiveWorld
==============
*/

void __fastcall Physics_DoCmd_UpdatePredictiveWorld(const void *const cmdInfo, __int64 a2, __int64 a3, double _XMM3_8)
{
  Profile_Begin(602);
  __asm { vxorps  xmm3, xmm3, xmm3; stepTimeOverride }
  Physics_StepWorld(*(Physics_WorldId *)cmdInfo, 0, 1, *(float *)&_XMM3);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_DoCmd_UpdatePredictiveWorldPre
==============
*/
void Physics_DoCmd_UpdatePredictiveWorldPre(const void *const cmdInfo)
{
  _RBX = (Physics_WorldId *)cmdInfo;
  Sys_ProfBeginNamedEvent(0xFF808080, "ClientPhysicsPredictiveWorldUpdatePre");
  __asm { vmovss  xmm1, dword ptr [rbx+4]; timeStep }
  Physics_PreStepWorld(*_RBX, *(float *)&_XMM1);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_DoDeferredQueries
==============
*/
void Physics_DoDeferredQueries(Physics_WorldId worldId)
{
  char v2; 
  Physics_WorldId v3; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9860, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DoDeferredQueries against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9861, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DoDeferredQueries against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v3) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL && Physics_IsDetailWorld(worldId) )
  {
    v2 = 1;
    CL_Main_SkeletonCacheValidity_Lock(SkeletonCacheValidityLockType_Locked_Physics);
  }
  else
  {
    v2 = 0;
  }
  HavokPhysics_DoDeferredQueries(worldId);
  if ( v2 )
    CL_Main_SkeletonCacheValidity_Unlock(SkeletonCacheValidityLockType_Locked_Physics);
}

/*
==============
Physics_DoGarbageCollectionClient
==============
*/

void Physics_DoGarbageCollectionClient(void)
{
  HavokPhysics_DoGarbageCollectionClient();
}

/*
==============
Physics_DoGarbageCollectionServer
==============
*/

void Physics_DoGarbageCollectionServer(void)
{
  HavokPhysics_DoGarbageCollectionServer();
}

/*
==============
Physics_DrawDebug
==============
*/

void __fastcall Physics_DrawDebug(const ScreenPlacement *scrPlace, double _XMM1_8)
{
  signed __int64 v2; 
  void *v9; 
  fileHandle_t *v18; 
  int integer; 
  int v20; 
  int v21; 
  unsigned int unsignedInt; 
  BOOL enabled; 
  int v24; 
  int v27; 
  Physics_WorldId v37; 
  Physics_WorldId v53; 
  __int64 v150; 
  Physics_WorldId v155; 
  int v157; 
  const char **v158; 
  const char *v159; 
  char v163; 
  int v164; 
  char v165; 
  char v166; 
  char v167; 
  char v168; 
  char v169; 
  char v170; 
  char v171; 
  char v172; 
  char v173; 
  char v174; 
  char v175; 
  char v176; 
  char v177; 
  char v178; 
  char v179; 
  char v180; 
  char v181; 
  char v182; 
  char v183; 
  char v184; 
  char v185; 
  char v186; 
  char v187; 
  char v188; 
  char v189; 
  char v190; 
  char v191; 
  char v192; 
  char v193; 
  char v194; 
  char v195; 
  char v196; 
  char v197; 
  char v198; 
  char v199; 
  char v200; 
  char v201; 
  Physics_WorldId v202; 
  int v203; 
  int v204; 
  char v205; 
  const char *WorldName; 
  __int64 v222; 
  LocalClientNum_t v230; 
  __int64 v251; 
  __int64 v257; 
  __int64 v263; 
  __int64 v279; 
  __int64 v285; 
  __int64 v318; 
  __int64 v324; 
  __int64 v336; 
  __int64 v348; 
  MapEnts *mapEnts; 
  unsigned int v358; 
  __int64 v361; 
  signed int v362; 
  const char *MapEntsShapeName; 
  unsigned int v371; 
  DB_AssetEntryFlags *p_m_headEntries; 
  unsigned int v373; 
  DB_AssetEntryPool *AssetEntryPool; 
  __int64 v376; 
  unsigned int v377; 
  __int64 v379; 
  __int64 v380; 
  _DWORD *v381; 
  unsigned int v382; 
  int v383; 
  __int64 v384; 
  unsigned int v385; 
  __int64 v386; 
  _BYTE *v387; 
  __int64 v392; 
  Physics_WorldId v398; 
  __int64 v399; 
  __int64 v411; 
  const char *v412; 
  Physics_WorldId v423; 
  __int64 v425; 
  const char *v426; 
  Physics_WorldId v437; 
  __int64 v439; 
  Physics_WorldId v444; 
  __int64 v445; 
  Physics_WorldId v450; 
  __int64 v451; 
  Physics_WorldId v462; 
  __int64 v463; 
  Physics_WorldId v474; 
  bool v481; 
  const char *v485; 
  char v486; 
  __int64 v496; 
  Physics_WorldId v497; 
  int v514; 
  int v515; 
  const dvar_t *v516; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float fmtl; 
  float fmtm; 
  float fmtn; 
  float fmto; 
  float fmtp; 
  float fmtq; 
  float fmtr; 
  float fmts; 
  char *fmtt; 
  char *fmtu; 
  char *fmtv; 
  char *fmtw; 
  char *fmtx; 
  char *fmty; 
  char *fmtz; 
  char *fmtba; 
  char *fmtbb; 
  char *fmtbc; 
  char *fmtbd; 
  char *fmtbe; 
  char *fmtbf; 
  char *fmtbg; 
  char *fmtbh; 
  char *fmtbi; 
  float fmtbj; 
  float fmtbk; 
  float fmtbl; 
  float fmtbm; 
  float fmtbn; 
  float fmtbo; 
  float fmtbp; 
  float fmtbq; 
  float fmtbr; 
  float fmtbs; 
  float fmtbt; 
  float fmtbu; 
  float fmtbv; 
  float fmtbw; 
  float fmtbx; 
  float fmtby; 
  float fmtbz; 
  float fmtca; 
  float fmtcb; 
  float fmtcc; 
  float fmtcd; 
  float fmtce; 
  float fmtcf; 
  float fmtcg; 
  float fmtch; 
  float fmtci; 
  float fmtcj; 
  float fmtck; 
  float fmtcl; 
  float fmtcm; 
  float fmtcn; 
  float fmtco; 
  float fmtcp; 
  float fmtcq; 
  float fmtcr; 
  float fmtcs; 
  float fmtct; 
  float fmtcu; 
  float fmtcv; 
  float fmtcw; 
  float fmtcx; 
  float fmtcy; 
  float fmtcz; 
  float fmtda; 
  float fmtdb; 
  float fmtdc; 
  float fmtdd; 
  float fmtde; 
  float fmtdf; 
  __int64 forceColor; 
  int forceColorb; 
  int forceColorc; 
  int forceColord; 
  int forceColore; 
  int forceColorf; 
  int forceColorg; 
  int forceColorh; 
  int forceColori; 
  int forceColorj; 
  int forceColork; 
  int forceColorl; 
  int forceColorm; 
  int forceColorn; 
  int forceColoro; 
  int forceColorp; 
  int forceColorq; 
  __int64 forceColorr; 
  __int64 forceColors; 
  __int64 forceColort; 
  __int64 forceColoru; 
  __int64 forceColorv; 
  __int64 forceColorw; 
  __int64 forceColorx; 
  int forceColory; 
  int forceColorz; 
  int forceColorba; 
  int forceColorbb; 
  int forceColorbc; 
  int forceColorbd; 
  int forceColorbe; 
  int forceColorbf; 
  int forceColorbg; 
  int forceColorbh; 
  int forceColorbi; 
  int forceColorbj; 
  int forceColorbk; 
  int forceColorbl; 
  int forceColorbm; 
  int forceColorbn; 
  int forceColorbo; 
  int forceColorbp; 
  int forceColorbq; 
  int forceColorbr; 
  int forceColorbs; 
  int forceColorbt; 
  int forceColorbu; 
  int forceColorbv; 
  int forceColorbw; 
  int forceColorbx; 
  int forceColorby; 
  int forceColorbz; 
  int forceColorca; 
  int forceColorcb; 
  int forceColorcc; 
  int forceColorcd; 
  int forceColorce; 
  __int64 forceColora; 
  int forceColorcf; 
  int forceColorcg; 
  __int64 shadow; 
  __int64 shadowa; 
  __int64 shadowb; 
  __int64 shadowc; 
  int shadowd; 
  int shadowe; 
  int shadowf; 
  int shadowg; 
  int shadowh; 
  int shadowi; 
  int shadowj; 
  int shadowk; 
  int shadowl; 
  int shadowm; 
  int shadown; 
  int shadowo; 
  float charHeight; 
  float charHeighta; 
  float charHeightb; 
  float charHeightc; 
  float charHeightd; 
  float charHeighte; 
  float charHeightf; 
  float charHeightg; 
  float charHeighth; 
  float charHeighti; 
  float charHeightj; 
  float charHeightk; 
  float charHeightl; 
  float charHeightm; 
  float charHeightn; 
  float charHeighto; 
  float charHeightp; 
  float charHeightq; 
  float charHeightr; 
  float charHeights; 
  __int64 charHeightt; 
  float charHeightu; 
  float charHeightv; 
  float charHeightw; 
  float charHeightx; 
  float charHeighty; 
  float charHeightz; 
  float charHeightba; 
  float charHeightbb; 
  float charHeightbc; 
  float charHeightbd; 
  float charHeightbe; 
  float charHeightbf; 
  float charHeightbg; 
  float charHeightbh; 
  float charHeightbi; 
  float charHeightbj; 
  float charHeightbk; 
  float charHeightbl; 
  float charHeightbm; 
  float charHeightbn; 
  float charHeightbo; 
  float charHeightbp; 
  float charHeightbq; 
  float charHeightbr; 
  float charHeightbs; 
  float charHeightbt; 
  float charHeightbu; 
  float charHeightbv; 
  float charHeightbw; 
  float charHeightbx; 
  float charHeightby; 
  float charHeightbz; 
  float charHeightca; 
  float charHeightcb; 
  float charHeightcc; 
  float charHeightcd; 
  float charHeightce; 
  float charHeightcf; 
  float charHeightcg; 
  float charHeightch; 
  float charHeightci; 
  float charHeightcj; 
  float charHeightck; 
  float charHeightcl; 
  float charHeightcm; 
  float charHeightcn; 
  float charHeightco; 
  float charHeightcp; 
  float charHeightcq; 
  float charHeightcr; 
  float charHeightcs; 
  float charHeightct; 
  float charHeightcu; 
  float charHeightcv; 
  float charHeightcw; 
  float charHeightcx; 
  float charHeightcy; 
  float charHeightcz; 
  float charHeightda; 
  __int64 adjust; 
  int adjusta; 
  int adjustb; 
  float x; 
  float y; 
  unsigned int collisionFilterInfo; 
  char buffer[32]; 
  __int64 v771[3584]; 
  char dest[256]; 
  char v778; 

  v9 = alloca(v2);
  __asm
  {
    vmovaps [rsp+7200h+var_30], xmm6
    vmovaps [rsp+7200h+var_40], xmm7
    vmovaps [rsp+7200h+var_50], xmm8
    vmovaps [rsp+7200h+var_60], xmm9
    vmovaps [rsp+7200h+var_70], xmm10
  }
  if ( !physics_debugDisplayOffsetX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10661, ASSERT_TYPE_ASSERT, "(physics_debugDisplayOffsetX)", "%s\n\tPhysics: debug dvar physics_debugDisplayOffsetX is null", "physics_debugDisplayOffsetX") )
    __debugbreak();
  if ( !physics_debugDisplayOffsetY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10662, ASSERT_TYPE_ASSERT, "(physics_debugDisplayOffsetY)", "%s\n\tPhysics: debug dvar physics_debugDisplayOffsetY is null", "physics_debugDisplayOffsetY") )
    __debugbreak();
  if ( !physics_debugMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10663, ASSERT_TYPE_ASSERT, "(physics_debugMemory)", "%s\n\tPhysics: debug dvar physics_debugMemory is null", "physics_debugMemory") )
    __debugbreak();
  if ( !physics_debugCPU && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10664, ASSERT_TYPE_ASSERT, "(physics_debugCPU)", "%s\n\tPhysics: debug dvar physics_debugCPU is null", "physics_debugCPU") )
    __debugbreak();
  if ( !physics_debugProfileData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10665, ASSERT_TYPE_ASSERT, "(physics_debugProfileData)", "%s\n\tPhysics: debug dvar physics_debugProfileData is null", "physics_debugProfileData") )
    __debugbreak();
  if ( !physics_debugTimestep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10666, ASSERT_TYPE_ASSERT, "(physics_debugTimestep)", "%s\n\tPhysics: debug dvar physics_debugTimestep is null", "physics_debugTimestep") )
    __debugbreak();
  if ( !physics_debugRefSystemCounts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10667, ASSERT_TYPE_ASSERT, "(physics_debugRefSystemCounts)", "%s\n\tPhysics: debug dvar physics_debugRefSystemCounts is null", "physics_debugRefSystemCounts") )
    __debugbreak();
  if ( !physics_debugVisualizeWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10668, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorld)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorld is null", "physics_debugVisualizeWorld") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldIgnoreCharacterProxies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10669, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldIgnoreCharacterProxies)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldIgnoreCharacterProxies is null", "physics_debugVisualizeWorldIgnoreCharacterProxies") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10670, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldRadius)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldRadius is null", "physics_debugVisualizeWorldRadius") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldClearZFirst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10671, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldClearZFirst)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldClearZFirst is null", "physics_debugVisualizeWorldClearZFirst") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldViewMode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10672, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldViewMode)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldViewMode is null", "physics_debugVisualizeWorldViewMode") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldComplexityTriThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10673, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldComplexityTriThreshold)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldComplexityTriThreshold is null", "physics_debugVisualizeWorldComplexityTriThreshold") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldComplexityLineThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10674, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldComplexityLineThreshold)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldComplexityLineThreshold is null", "physics_debugVisualizeWorldComplexityLineThreshold") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldBodyId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10675, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldBodyId)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldBodyId is null", "physics_debugVisualizeWorldBodyId") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldBroadphase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10676, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldBroadphase)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldBroadphase is null", "physics_debugVisualizeWorldBroadphase") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldConstraint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10677, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldConstraint)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldConstraint is null", "physics_debugVisualizeWorldConstraint") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldDeactivation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10678, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldDeactivation)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldDeactivation is null", "physics_debugVisualizeWorldDeactivation") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldManifold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10679, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldManifold)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldManifold is null", "physics_debugVisualizeWorldManifold") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldMassProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10680, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldMassProperties)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldMassProperties is null", "physics_debugVisualizeWorldMassProperties") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldMotionId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10681, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldMotionId)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldMotionId is null", "physics_debugVisualizeWorldMotionId") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10682, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldShape)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldShape is null", "physics_debugVisualizeWorldShape") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldShapeLowRes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10683, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldShapeLowRes)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldShapeLowRes is null", "physics_debugVisualizeWorldShapeLowRes") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldVehicles && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10684, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldVehicles)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldVehicles is null", "physics_debugVisualizeWorldVehicles") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldCollisionHeatmap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10685, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldCollisionHeatmap)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldCollisionHeatmap is null", "physics_debugVisualizeWorldCollisionHeatmap") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldCollisionHeatmapGood && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10686, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldCollisionHeatmapGood)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldCollisionHeatmapGood is null", "physics_debugVisualizeWorldCollisionHeatmapGood") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldCollisionHeatmapBad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10687, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldCollisionHeatmapBad)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldCollisionHeatmapBad is null", "physics_debugVisualizeWorldCollisionHeatmapBad") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldCollisionHeatmapRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10688, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldCollisionHeatmapRange)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldCollisionHeatmapRange is null", "physics_debugVisualizeWorldCollisionHeatmapRange") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldDebugDraw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10689, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldDebugDraw)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldDebugDraw is null", "physics_debugVisualizeWorldDebugDraw") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldCollisionTile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10690, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldCollisionTile)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldCollisionTile is null", "physics_debugVisualizeWorldCollisionTile") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldRaycasts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10691, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldRaycasts)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldRaycasts is null", "physics_debugVisualizeWorldRaycasts") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldShapecasts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10692, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldShapecasts)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldShapecasts is null", "physics_debugVisualizeWorldShapecasts") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldAABBQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10693, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldAABBQuery)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldAABBQuery is null", "physics_debugVisualizeWorldAABBQuery") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldPointQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10694, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldPointQuery)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldPointQuery is null", "physics_debugVisualizeWorldPointQuery") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldClosestPointsQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10695, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldClosestPointsQuery)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldClosestPointsQuery is null", "physics_debugVisualizeWorldClosestPointsQuery") )
    __debugbreak();
  if ( !physics_debugVisualizeCharacterProxies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10696, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeCharacterProxies)", "%s\n\tPhysics: debug dvar physics_debugVisualizeCharacterProxies is null", "physics_debugVisualizeCharacterProxies") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldIWShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10697, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldIWShape)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldIWShape is null", "physics_debugVisualizeWorldIWShape") )
    __debugbreak();
  if ( !physics_debugVisualizeWorldParticles && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10698, ASSERT_TYPE_ASSERT, "(physics_debugVisualizeWorldParticles)", "%s\n\tPhysics: debug dvar physics_debugVisualizeWorldParticles is null", "physics_debugVisualizeWorldParticles") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldGeometry && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10699, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldGeometry)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldGeometry is null", "cloth_debugVisualizeWorldGeometry") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimParticlePosition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10700, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimParticlePosition)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimParticlePosition is null", "cloth_debugVisualizeWorldSimParticlePosition") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimNormals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10701, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimNormals)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimNormals is null", "cloth_debugVisualizeWorldSimNormals") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldParticleVelocity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10702, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldParticleVelocity)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldParticleVelocity is null", "cloth_debugVisualizeWorldParticleVelocity") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldParticleId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10703, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldParticleId)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldParticleId is null", "cloth_debugVisualizeWorldParticleId") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimStandardLinks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10704, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimStandardLinks)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimStandardLinks is null", "cloth_debugVisualizeWorldSimStandardLinks") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimStretchLinks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10705, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimStretchLinks)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimStretchLinks is null", "cloth_debugVisualizeWorldSimStretchLinks") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimBendLinks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10706, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimBendLinks)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimBendLinks is null", "cloth_debugVisualizeWorldSimBendLinks") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimBendStiffness && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10707, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimBendStiffness)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimBendStiffness is null", "cloth_debugVisualizeWorldSimBendStiffness") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldSimVolumeTransforms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10708, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldSimVolumeTransforms)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldSimVolumeTransforms is null", "cloth_debugVisualizeWorldSimVolumeTransforms") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldLocalRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10709, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldLocalRange)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldLocalRange is null", "cloth_debugVisualizeWorldLocalRange") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldBonePlane && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10710, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldBonePlane)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldBonePlane is null", "cloth_debugVisualizeWorldBonePlane") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldTransition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10711, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldTransition)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldTransition is null", "cloth_debugVisualizeWorldTransition") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldCollidable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10712, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldCollidable)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldCollidable is null", "cloth_debugVisualizeWorldCollidable") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldParticleRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10713, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldParticleRadius)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldParticleRadius is null", "cloth_debugVisualizeWorldParticleRadius") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldVirtualCollisionPoints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10714, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldVirtualCollisionPoints)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldVirtualCollisionPoints is null", "cloth_debugVisualizeWorldVirtualCollisionPoints") )
    __debugbreak();
  if ( !cloth_debugVisualizeWorldVirtualCollisionPointsLandscape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10715, ASSERT_TYPE_ASSERT, "(cloth_debugVisualizeWorldVirtualCollisionPointsLandscape)", "%s\n\tCloth: debug dvar cloth_debugVisualizeWorldVirtualCollisionPointsLandscape is null", "cloth_debugVisualizeWorldVirtualCollisionPointsLandscape") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_SOLID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10716, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_SOLID)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_SOLID is null", "physics_debugVisualize_CONTENTS_SOLID") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_FOLIAGE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10717, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_FOLIAGE)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_FOLIAGE is null", "physics_debugVisualize_CONTENTS_FOLIAGE") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_VEHICLETRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10718, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_VEHICLETRIGGER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_VEHICLETRIGGER is null", "physics_debugVisualize_CONTENTS_VEHICLETRIGGER") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_GLASS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10719, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_GLASS)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_GLASS is null", "physics_debugVisualize_CONTENTS_GLASS") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_WATER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10720, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_WATER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_WATER is null", "physics_debugVisualize_CONTENTS_WATER") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_AI_NOSHOOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10721, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_AI_NOSHOOT)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_AI_NOSHOOT is null", "physics_debugVisualize_CONTENTS_AI_NOSHOOT") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_MISSILECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10722, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_MISSILECLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_MISSILECLIP is null", "physics_debugVisualize_CONTENTS_MISSILECLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_ITEM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10723, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_ITEM)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_ITEM is null", "physics_debugVisualize_CONTENTS_ITEM") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_VEHICLECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10724, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_VEHICLECLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_VEHICLECLIP is null", "physics_debugVisualize_CONTENTS_VEHICLECLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_ITEMCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10725, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_ITEMCLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_ITEMCLIP is null", "physics_debugVisualize_CONTENTS_ITEMCLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_SKY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10726, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_SKY)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_SKY is null", "physics_debugVisualize_CONTENTS_SKY") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_AI_NOSIGHT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10727, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_AI_NOSIGHT)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_AI_NOSIGHT is null", "physics_debugVisualize_CONTENTS_AI_NOSIGHT") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_CLIPSHOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10728, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_CLIPSHOT)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_CLIPSHOT is null", "physics_debugVisualize_CONTENTS_CLIPSHOT") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_ACTOR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10729, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_ACTOR)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_ACTOR is null", "physics_debugVisualize_CONTENTS_ACTOR") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_PLAYERCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10730, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_PLAYERCLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_PLAYERCLIP is null", "physics_debugVisualize_CONTENTS_PLAYERCLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10731, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT is null", "physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_AI_CLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10732, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_AI_CLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_AI_CLIP is null", "physics_debugVisualize_CONTENTS_AI_CLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_SENTIENTTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10733, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_SENTIENTTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_SENTIENTTRIGGER is null", "physics_debugVisualize_CONTENTS_SENTIENTTRIGGER") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_EXPLOSIONCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10734, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_EXPLOSIONCLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_EXPLOSIONCLIP is null", "physics_debugVisualize_CONTENTS_EXPLOSIONCLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_SOUNDCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10735, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_SOUNDCLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_SOUNDCLIP is null", "physics_debugVisualize_CONTENTS_SOUNDCLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_SOUNDREFLECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10736, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_SOUNDREFLECT)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_SOUNDREFLECT is null", "physics_debugVisualize_CONTENTS_SOUNDREFLECT") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10737, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER is null", "physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_VEHICLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10738, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_VEHICLE)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_VEHICLE is null", "physics_debugVisualize_CONTENTS_VEHICLE") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_MANTLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10739, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_MANTLE)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_MANTLE is null", "physics_debugVisualize_CONTENTS_MANTLE") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_PLAYER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10740, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_PLAYER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_PLAYER is null", "physics_debugVisualize_CONTENTS_PLAYER") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_USECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10741, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_USECLIP)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_USECLIP is null", "physics_debugVisualize_CONTENTS_USECLIP") )
    __debugbreak();
  if ( !physics_debugVisualize_CONTENTS_PLAYERTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10742, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_CONTENTS_PLAYERTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugVisualize_CONTENTS_PLAYERTRIGGER is null", "physics_debugVisualize_CONTENTS_PLAYERTRIGGER") )
    __debugbreak();
  if ( !physics_debugVisualize_Preset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10743, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_Preset)", "%s\n\tPhysics: debug dvar physics_debugVisualize_Preset is null", "physics_debugVisualize_Preset") )
    __debugbreak();
  if ( !physics_debugVisualize_Query && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10744, ASSERT_TYPE_ASSERT, "(physics_debugVisualize_Query)", "%s\n\tPhysics: debug dvar physics_debugVisualize_Query is null", "physics_debugVisualize_Query") )
    __debugbreak();
  if ( !physics_debugLibraryMaterials && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10745, ASSERT_TYPE_ASSERT, "(physics_debugLibraryMaterials)", "%s\n\tPhysics: debug dvar physics_debugLibraryMaterials is null", "physics_debugLibraryMaterials") )
    __debugbreak();
  if ( !physics_debugLibraryBodyQualitys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10746, ASSERT_TYPE_ASSERT, "(physics_debugLibraryBodyQualitys)", "%s\n\tPhysics: debug dvar physics_debugLibraryBodyQualitys is null", "physics_debugLibraryBodyQualitys") )
    __debugbreak();
  if ( !physics_debugLibraryMotionProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10747, ASSERT_TYPE_ASSERT, "(physics_debugLibraryMotionProperties)", "%s\n\tPhysics: debug dvar physics_debugLibraryMotionProperties is null", "physics_debugLibraryMotionProperties") )
    __debugbreak();
  if ( !physics_debugLibraryMaterialId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10748, ASSERT_TYPE_ASSERT, "(physics_debugLibraryMaterialId)", "%s\n\tPhysics: debug dvar physics_debugLibraryMaterialId is null", "physics_debugLibraryMaterialId") )
    __debugbreak();
  if ( !physics_debugLibraryBodyQualityId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10749, ASSERT_TYPE_ASSERT, "(physics_debugLibraryBodyQualityId)", "%s\n\tPhysics: debug dvar physics_debugLibraryBodyQualityId is null", "physics_debugLibraryBodyQualityId") )
    __debugbreak();
  if ( !physics_debugLibraryMotionPropertiesId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10750, ASSERT_TYPE_ASSERT, "(physics_debugLibraryMotionPropertiesId)", "%s\n\tPhysics: debug dvar physics_debugLibraryMotionPropertiesId is null", "physics_debugLibraryMotionPropertiesId") )
    __debugbreak();
  if ( !physics_debugAssetsByName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10751, ASSERT_TYPE_ASSERT, "(physics_debugAssetsByName)", "%s\n\tPhysics: debug dvar physics_debugAssetsByName is null", "physics_debugAssetsByName") )
    __debugbreak();
  if ( !physics_debugAssetsByMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10752, ASSERT_TYPE_ASSERT, "(physics_debugAssetsByMemory)", "%s\n\tPhysics: debug dvar physics_debugAssetsByMemory is null", "physics_debugAssetsByMemory") )
    __debugbreak();
  if ( !physics_debugAssetIdByName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10753, ASSERT_TYPE_ASSERT, "(physics_debugAssetIdByName)", "%s\n\tPhysics: debug dvar physics_debugAssetIdByName is null", "physics_debugAssetIdByName") )
    __debugbreak();
  if ( !physics_debugAssetIdByMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10754, ASSERT_TYPE_ASSERT, "(physics_debugAssetIdByMemory)", "%s\n\tPhysics: debug dvar physics_debugAssetIdByMemory is null", "physics_debugAssetIdByMemory") )
    __debugbreak();
  if ( !physics_debugXModelsWithNoPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10755, ASSERT_TYPE_ASSERT, "(physics_debugXModelsWithNoPhysicsAsset)", "%s\n\tPhysics: debug dvar physics_debugXModelsWithNoPhysicsAsset is null", "physics_debugXModelsWithNoPhysicsAsset") )
    __debugbreak();
  if ( !physics_debugXModelsWithCollLods && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10756, ASSERT_TYPE_ASSERT, "(physics_debugXModelsWithCollLods)", "%s\n\tPhysics: debug dvar physics_debugXModelsWithCollLods is null", "physics_debugXModelsWithCollLods") )
    __debugbreak();
  if ( !physics_debugXModelsExcludeDoNotUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10757, ASSERT_TYPE_ASSERT, "(physics_debugXModelsExcludeDoNotUse)", "%s\n\tPhysics: debug dvar physics_debugXModelsExcludeDoNotUse is null", "physics_debugXModelsExcludeDoNotUse") )
    __debugbreak();
  if ( !physics_debugXModelsByName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10758, ASSERT_TYPE_ASSERT, "(physics_debugXModelsByName)", "%s\n\tPhysics: debug dvar physics_debugXModelsByName is null", "physics_debugXModelsByName") )
    __debugbreak();
  if ( !physics_debugXModelsByMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10759, ASSERT_TYPE_ASSERT, "(physics_debugXModelsByMemory)", "%s\n\tPhysics: debug dvar physics_debugXModelsByMemory is null", "physics_debugXModelsByMemory") )
    __debugbreak();
  if ( !physics_debugXModelsByDetailBodyCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10760, ASSERT_TYPE_ASSERT, "(physics_debugXModelsByDetailBodyCount)", "%s\n\tPhysics: debug dvar physics_debugXModelsByDetailBodyCount is null", "physics_debugXModelsByDetailBodyCount") )
    __debugbreak();
  if ( !physics_debugXModelIdByName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10761, ASSERT_TYPE_ASSERT, "(physics_debugXModelIdByName)", "%s\n\tPhysics: debug dvar physics_debugXModelIdByName is null", "physics_debugXModelIdByName") )
    __debugbreak();
  if ( !physics_debugXModelIdByMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10762, ASSERT_TYPE_ASSERT, "(physics_debugXModelIdByMemory)", "%s\n\tPhysics: debug dvar physics_debugXModelIdByMemory is null", "physics_debugXModelIdByMemory") )
    __debugbreak();
  if ( !physics_debugSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10763, ASSERT_TYPE_ASSERT, "(physics_debugSFXEventAssets)", "%s\n\tPhysics: debug dvar physics_debugSFXEventAssets is null", "physics_debugSFXEventAssets") )
    __debugbreak();
  if ( !physics_debugSFXEventAssetId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10764, ASSERT_TYPE_ASSERT, "(physics_debugSFXEventAssetId)", "%s\n\tPhysics: debug dvar physics_debugSFXEventAssetId is null", "physics_debugSFXEventAssetId") )
    __debugbreak();
  if ( !physics_debugVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10765, ASSERT_TYPE_ASSERT, "(physics_debugVFXEventAssets)", "%s\n\tPhysics: debug dvar physics_debugVFXEventAssets is null", "physics_debugVFXEventAssets") )
    __debugbreak();
  if ( !physics_debugVFXEventAssetId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10766, ASSERT_TYPE_ASSERT, "(physics_debugVFXEventAssetId)", "%s\n\tPhysics: debug dvar physics_debugVFXEventAssetId is null", "physics_debugVFXEventAssetId") )
    __debugbreak();
  if ( !physics_debugClipmapBrushes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10767, ASSERT_TYPE_ASSERT, "(physics_debugClipmapBrushes)", "%s\n\tPhysics: debug dvar physics_debugClipmapBrushes is null", "physics_debugClipmapBrushes") )
    __debugbreak();
  if ( !physics_debugParticlesHeavyweight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10768, ASSERT_TYPE_ASSERT, "(physics_debugParticlesHeavyweight)", "%s\n\tPhysics: debug dvar physics_debugClipmapBrushes is null", "physics_debugParticlesHeavyweight") )
    __debugbreak();
  if ( !physics_debugWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10769, ASSERT_TYPE_ASSERT, "(physics_debugWorld)", "%s\n\tPhysics: debug dvar physics_debugWorld is null", "physics_debugWorld") )
    __debugbreak();
  if ( !physics_debugWorldFull && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10770, ASSERT_TYPE_ASSERT, "(physics_debugWorldFull)", "%s\n\tPhysics: debug dvar physics_debugWorldFull is null", "physics_debugWorldFull") )
    __debugbreak();
  if ( !physics_debugWorldBody && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10771, ASSERT_TYPE_ASSERT, "(physics_debugWorldBody)", "%s\n\tPhysics: debug dvar physics_debugWorldBody is null", "physics_debugWorldBody") )
    __debugbreak();
  if ( !physics_debugRayWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10772, ASSERT_TYPE_ASSERT, "(physics_debugRayWorld)", "%s\n\tPhysics: debug dvar physics_debugRayWorld is null", "physics_debugRayWorld") )
    __debugbreak();
  if ( !physics_debugShapeCastWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10773, ASSERT_TYPE_ASSERT, "(physics_debugShapeCastWorld)", "%s\n\tPhysics: debug dvar physics_debugShapeCastWorld is null", "physics_debugShapeCastWorld") )
    __debugbreak();
  if ( !physics_debugQueryPointWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10774, ASSERT_TYPE_ASSERT, "(physics_debugQueryPointWorld)", "%s\n\tPhysics: debug dvar physics_debugQueryPointWorld is null", "physics_debugQueryPointWorld") )
    __debugbreak();
  if ( !physics_debugQueryPointPosition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10775, ASSERT_TYPE_ASSERT, "(physics_debugQueryPointPosition)", "%s\n\tPhysics: debug dvar physics_debugQueryPointPosition is null", "physics_debugQueryPointPosition") )
    __debugbreak();
  if ( !physics_debugQueryPointMaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10776, ASSERT_TYPE_ASSERT, "(physics_debugQueryPointMaxDistance)", "%s\n\tPhysics: debug dvar physics_debugQueryPointMaxDistance is null", "physics_debugQueryPointMaxDistance") )
    __debugbreak();
  if ( !physics_debugGetClosestPointsWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10777, ASSERT_TYPE_ASSERT, "(physics_debugGetClosestPointsWorld)", "%s\n\tPhysics: debug dvar physics_debugGetClosestPointsWorld is null", "physics_debugGetClosestPointsWorld") )
    __debugbreak();
  if ( !physics_debugGetClosestPointsPosition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10778, ASSERT_TYPE_ASSERT, "(physics_debugGetClosestPointsPosition)", "%s\n\tPhysics: debug dvar physics_debugGetClosestPointsPosition is null", "physics_debugGetClosestPointsPosition") )
    __debugbreak();
  if ( !physics_debugGetClosestPointsMaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10779, ASSERT_TYPE_ASSERT, "(physics_debugGetClosestPointsMaxDistance)", "%s\n\tPhysics: debug dvar physics_debugGetClosestPointsMaxDistance is null", "physics_debugGetClosestPointsMaxDistance") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_SOLID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10780, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_SOLID)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_SOLID is null", "physics_debugQuery_CONTENTS_SOLID") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_FOLIAGE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10781, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_FOLIAGE)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_FOLIAGE is null", "physics_debugQuery_CONTENTS_FOLIAGE") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_VEHICLETRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10782, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_VEHICLETRIGGER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_VEHICLETRIGGER is null", "physics_debugQuery_CONTENTS_VEHICLETRIGGER") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_GLASS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10783, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_GLASS)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_GLASS is null", "physics_debugQuery_CONTENTS_GLASS") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_WATER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10784, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_WATER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_WATER is null", "physics_debugQuery_CONTENTS_WATER") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_AI_NOSHOOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10785, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_AI_NOSHOOT)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_AI_NOSHOOT is null", "physics_debugQuery_CONTENTS_AI_NOSHOOT") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_MISSILECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10786, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_MISSILECLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_MISSILECLIP is null", "physics_debugQuery_CONTENTS_MISSILECLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_ITEM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10787, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_ITEM)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_ITEM is null", "physics_debugQuery_CONTENTS_ITEM") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_VEHICLECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10788, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_VEHICLECLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_VEHICLECLIP is null", "physics_debugQuery_CONTENTS_VEHICLECLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_ITEMCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10789, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_ITEMCLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_ITEMCLIP is null", "physics_debugQuery_CONTENTS_ITEMCLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_SKY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10790, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_SKY)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_SKY is null", "physics_debugQuery_CONTENTS_SKY") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_AI_NOSIGHT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10791, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_AI_NOSIGHT)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_AI_NOSIGHT is null", "physics_debugQuery_CONTENTS_AI_NOSIGHT") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_CLIPSHOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10792, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_CLIPSHOT)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_CLIPSHOT is null", "physics_debugQuery_CONTENTS_CLIPSHOT") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_ACTOR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10793, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_ACTOR)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_ACTOR is null", "physics_debugQuery_CONTENTS_ACTOR") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_PLAYERCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10794, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_PLAYERCLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_PLAYERCLIP is null", "physics_debugQuery_CONTENTS_PLAYERCLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_PLAYER_NOSIGHT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10795, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_PLAYER_NOSIGHT)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_PLAYER_NOSIGHT is null", "physics_debugQuery_CONTENTS_PLAYER_NOSIGHT") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_AI_CLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10796, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_AI_CLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_AI_CLIP is null", "physics_debugQuery_CONTENTS_AI_CLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_SENTIENTTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10797, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_SENTIENTTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_SENTIENTTRIGGER is null", "physics_debugQuery_CONTENTS_SENTIENTTRIGGER") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_EXPLOSIONCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10798, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_EXPLOSIONCLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_EXPLOSIONCLIP is null", "physics_debugQuery_CONTENTS_EXPLOSIONCLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_SOUNDCLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10799, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_SOUNDCLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_SOUNDCLIP is null", "physics_debugQuery_CONTENTS_SOUNDCLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_SOUNDREFLECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10800, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_SOUNDREFLECT)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_SOUNDREFLECT is null", "physics_debugQuery_CONTENTS_SOUNDREFLECT") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10801, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER is null", "physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_VEHICLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10802, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_VEHICLE)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_VEHICLE is null", "physics_debugQuery_CONTENTS_VEHICLE") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_MANTLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10803, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_MANTLE)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_MANTLE is null", "physics_debugQuery_CONTENTS_MANTLE") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_PLAYER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10804, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_PLAYER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_PLAYER is null", "physics_debugQuery_CONTENTS_PLAYER") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_USECLIP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10805, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_USECLIP)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_USECLIP is null", "physics_debugQuery_CONTENTS_USECLIP") )
    __debugbreak();
  if ( !physics_debugQuery_CONTENTS_PLAYERTRIGGER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10806, ASSERT_TYPE_ASSERT, "(physics_debugQuery_CONTENTS_PLAYERTRIGGER)", "%s\n\tPhysics: debug dvar physics_debugQuery_CONTENTS_PLAYERTRIGGER is null", "physics_debugQuery_CONTENTS_PLAYERTRIGGER") )
    __debugbreak();
  if ( !physics_debugQuery_Preset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10807, ASSERT_TYPE_ASSERT, "(physics_debugQuery_Preset)", "%s\n\tPhysics: debug dvar physics_debugQuery_Preset is null", "physics_debugQuery_Preset") )
    __debugbreak();
  if ( !physics_debugQuery_IgnoreVolumes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10808, ASSERT_TYPE_ASSERT, "(physics_debugQuery_IgnoreVolumes)", "%s\n\tPhysics: debug dvar physics_debugQuery_IgnoreVolumes is null", "physics_debugQuery_IgnoreVolumes") )
    __debugbreak();
  if ( !physics_debugDetailModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10809, ASSERT_TYPE_ASSERT, "(physics_debugDetailModel)", "%s\n\tPhysics: debug dvar physics_debugDetailModel is null", "physics_debugDetailModel") )
    __debugbreak();
  if ( !physics_debugFlickerColLod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10810, ASSERT_TYPE_ASSERT, "(physics_debugFlickerColLod)", "%s\n\tPhysics: debug dvar physics_debugFlickerColLod is null", "physics_debugFlickerColLod") )
    __debugbreak();
  if ( !physics_debugBadColLods && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10811, ASSERT_TYPE_ASSERT, "(physics_debugBadColLods)", "%s\n\tPhysics: debug dvar physics_debugBadColLods is null", "physics_debugBadColLods") )
    __debugbreak();
  if ( !physics_debugMutableShapesInWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10812, ASSERT_TYPE_ASSERT, "(physics_debugMutableShapesInWorld)", "%s\n\tPhysics: debug dvar physics_debugMutableShapesInWorld is null", "physics_debugMutableShapesInWorld") )
    __debugbreak();
  if ( !physics_debugMutableShapesInWorldRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10813, ASSERT_TYPE_ASSERT, "(physics_debugMutableShapesInWorldRange)", "%s\n\tPhysics: debug dvar physics_debugMutableShapesInWorldRange is null", "physics_debugMutableShapesInWorldRange") )
    __debugbreak();
  __asm
  {
    vmovss  xmm7, cs:__real@41000000
    vxorps  xmm0, xmm0, xmm0
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm0, xmm0, dword ptr [rax+28h]
    vaddss  xmm0, xmm0, xmm7
    vmovss  [rsp+7200h+x], xmm0
    vcvtsi2ss xmm1, xmm1, dword ptr [rax+28h]
    vaddss  xmm0, xmm1, xmm7
    vmovss  [rsp+7200h+y], xmm0
  }
  s_physicsDumpFile.handle.handle = -1i64;
  if ( physics_debugDump->current.enabled )
  {
    v18 = FS_FOpenTextFileWrite((fileHandle_t *)&result, (const char *)0xFFFFFFFFFFFFFFFFi64);
    s_physicsDumpFile.handle.handle = (__int64)v18;
    if ( v18 != (fileHandle_t *)-1i64 )
    {
      FS_Write("<html>", 6ui64, (fileHandle_t)v18);
      FS_Write("\n\r\n", 3ui64, s_physicsDumpFile);
      FS_Write("<body>", 6ui64, s_physicsDumpFile);
      FS_Write("\n\r\n", 3ui64, s_physicsDumpFile);
    }
  }
  integer = physics_debugVisualize_Preset->current.integer;
  v20 = (physics_debugVisualize_CONTENTS_ITEM->current.enabled ? 0x100 : 0) | (physics_debugVisualize_CONTENTS_VEHICLECLIP->current.enabled ? 0x200 : 0) | (physics_debugVisualize_CONTENTS_PLAYERCLIP->current.enabled ? 0x10000 : 0) | (physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT->current.enabled ? 0x8000 : 0) | (physics_debugVisualize_CONTENTS_AI_CLIP->current.enabled ? 0x20000 : 0) | (physics_debugVisualize_CONTENTS_ITEMCLIP->current.enabled ? 0x400 : 0) | (physics_debugVisualize_CONTENTS_SENTIENTTRIGGER->current.enabled ? 0x40000 : 0) | (physics_debugVisualize_CONTENTS_SKY->current.enabled ? 0x800 : 0) | (physics_debugVisualize_CONTENTS_EXPLOSIONCLIP->current.enabled ? 0x100000 : 0) | (physics_debugVisualize_CONTENTS_SOUNDCLIP->current.enabled ? 0x200000 : 0) | (physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER->current.enabled ? 0x400000 : 0) | (physics_debugVisualize_CONTENTS_VEHICLE->current.enabled ? 0x800000 : 0) | (physics_debugVisualize_CONTENTS_MANTLE->current.enabled ? 0x1000000 : 0) | (physics_debugVisualize_CONTENTS_PLAYER->current.enabled ? 0x2000000 : 0) | (physics_debugVisualize_CONTENTS_SOUNDREFLECT->current.enabled ? 0x4000000 : 0) | (physics_debugVisualize_CONTENTS_AI_NOSIGHT->current.enabled ? 0x1000 : 0) | (physics_debugVisualize_CONTENTS_CLIPSHOT->current.enabled ? 0x2000 : 0) | (physics_debugVisualize_CONTENTS_USECLIP->current.enabled ? 0x20000000 : 0);
  v21 = (physics_debugVisualize_CONTENTS_ACTOR->current.enabled ? 0x4000 : 0) | (physics_debugVisualize_CONTENTS_PLAYERTRIGGER->current.enabled ? 0x40000000 : 0) | physics_debugVisualize_CONTENTS_SOLID->current.enabled | (physics_debugVisualize_CONTENTS_FOLIAGE->current.enabled ? 2 : 0) | (physics_debugVisualize_CONTENTS_VEHICLETRIGGER->current.enabled ? 8 : 0) | (physics_debugVisualize_CONTENTS_GLASS->current.enabled ? 0x10 : 0) | (physics_debugVisualize_CONTENTS_WATER->current.enabled ? 0x20 : 0) | (physics_debugVisualize_CONTENTS_AI_NOSHOOT->current.enabled ? 0x40 : 0) | (physics_debugVisualize_CONTENTS_MISSILECLIP->current.enabled ? 0x80 : 0) | v20;
  if ( !integer )
    integer = v21;
  HavokPhysics_DebugSetVisualizeContents(integer);
  HavokPhysics_DebugSetVisualizeQuery(physics_debugVisualize_Query->current.enabled);
  unsignedInt = physics_debugQuery_Preset->current.unsignedInt;
  enabled = physics_debugQuery_CONTENTS_SOLID->current.enabled;
  v24 = (physics_debugQuery_CONTENTS_PLAYER->current.enabled ? 0x2000000 : 0) | (physics_debugQuery_CONTENTS_SOUNDREFLECT->current.enabled ? 0x4000000 : 0) | (physics_debugQuery_CONTENTS_AI_NOSIGHT->current.enabled ? 0x1000 : 0) | (physics_debugQuery_CONTENTS_CLIPSHOT->current.enabled ? 0x2000 : 0) | (physics_debugQuery_CONTENTS_USECLIP->current.enabled ? 0x20000000 : 0) | (physics_debugQuery_CONTENTS_ACTOR->current.enabled ? 0x4000 : 0) | (physics_debugQuery_CONTENTS_PLAYERTRIGGER->current.enabled ? 0x40000000 : 0) | enabled | (physics_debugQuery_CONTENTS_FOLIAGE->current.enabled ? 2 : 0) | (physics_debugQuery_CONTENTS_VEHICLETRIGGER->current.enabled ? 8 : 0) | (physics_debugQuery_CONTENTS_GLASS->current.enabled ? 0x10 : 0) | (physics_debugQuery_CONTENTS_WATER->current.enabled ? 0x20 : 0) | (physics_debugQuery_CONTENTS_AI_NOSHOOT->current.enabled ? 0x40 : 0) | (physics_debugQuery_CONTENTS_MISSILECLIP->current.enabled ? 0x80 : 0) | (physics_debugQuery_CONTENTS_ITEM->current.enabled ? 0x100 : 0) | (physics_debugQuery_CONTENTS_VEHICLECLIP->current.enabled ? 0x200 : 0) | (physics_debugQuery_CONTENTS_PLAYERCLIP->current.enabled ? 0x10000 : 0) | (physics_debugQuery_CONTENTS_PLAYER_NOSIGHT->current.enabled ? 0x8000 : 0) | (physics_debugQuery_CONTENTS_AI_CLIP->current.enabled ? 0x20000 : 0);
  __asm
  {
    vmovss  xmm8, cs:__real@41400000
    vmovss  xmm9, cs:__real@c1400000
  }
  v27 = (physics_debugQuery_CONTENTS_ITEMCLIP->current.enabled ? 0x400 : 0) | (physics_debugQuery_CONTENTS_SENTIENTTRIGGER->current.enabled ? 0x40000 : 0) | (physics_debugQuery_CONTENTS_SKY->current.enabled ? 0x800 : 0) | (physics_debugQuery_CONTENTS_EXPLOSIONCLIP->current.enabled ? 0x100000 : 0) | (physics_debugQuery_CONTENTS_SOUNDCLIP->current.enabled ? 0x200000 : 0) | (physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER->current.enabled ? 0x400000 : 0) | (physics_debugQuery_CONTENTS_VEHICLE->current.enabled ? 0x800000 : 0) | (physics_debugQuery_CONTENTS_MANTLE->current.enabled ? 0x1000000 : 0) | v24;
  if ( !unsignedInt )
    unsignedInt = v27;
  collisionFilterInfo = unsignedInt;
  if ( physics_debugMemory->current.integer )
  {
    Physics_DebugIntToString(buffer, 16, 0x5CC0000u);
    Com_sprintf(dest, 0x100ui64, "Physics Memory Report - Total Shipping Usage:%10s", buffer);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeight, 0);
    __asm
    {
      vaddss  xmm2, xmm7, [rsp+7200h+y]; y
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm2
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugMemory->current.integer )
    {
      case 1:
        __asm
        {
          vmovss  xmm1, [rsp+7200h+x]; jumptable 0000000140EAEF01 case 1
          vmovss  [rsp+7200h+charHeight], xmm7
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "General", &colorWhite, 0, 1, charHeighta, 0);
        __asm
        {
          vaddss  xmm1, xmm7, [rsp+7200h+y]
          vaddss  xmm0, xmm8, [rsp+7200h+x]
          vmovaps xmm3, xmm8; tabWidth
          vmovss  [rsp+7200h+y], xmm1
          vmovss  [rsp+7200h+x], xmm0
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        HavokPhysics_DrawDebugGeneralMemory(scrPlace, &x, &y, *(float *)&_XMM3, fmt);
        __asm
        {
          vaddss  xmm1, xmm9, [rsp+7200h+x]
          vmovss  [rsp+7200h+x], xmm1
        }
        break;
      case 2:
        if ( g_physicsServerWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_FIRST;
          goto LABEL_491;
        }
        break;
      case 3:
        if ( g_physicsServerWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_SERVER_DETAIL;
          goto LABEL_491;
        }
        break;
      case 4:
        if ( g_physicsClientWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_CLIENT_FIRST;
          goto LABEL_491;
        }
        break;
      case 5:
        if ( g_physicsClientWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
          goto LABEL_491;
        }
        break;
      case 6:
        if ( g_physicsClientWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
          goto LABEL_491;
        }
        break;
      case 7:
        if ( g_physicsClientWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
          goto LABEL_491;
        }
        break;
      case 8:
        if ( g_physicsClientWorldsCreated )
        {
          v37 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
          goto LABEL_491;
        }
        break;
      case 9:
        if ( g_physicsClientWorldsCreated )
          goto LABEL_490;
        break;
      case 0xA:
        __asm
        {
          vmovss  xmm1, [rsp+7200h+x]; jumptable 0000000140EAEF01 case 10
          vmovss  [rsp+7200h+charHeight], xmm7
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "General", &colorWhite, 0, 1, charHeightb, 0);
        __asm
        {
          vaddss  xmm1, xmm7, [rsp+7200h+y]
          vaddss  xmm0, xmm8, [rsp+7200h+x]
          vmovaps xmm3, xmm8; tabWidth
          vmovss  [rsp+7200h+y], xmm1
          vmovss  [rsp+7200h+x], xmm0
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        HavokPhysics_DrawDebugGeneralMemory(scrPlace, &x, &y, *(float *)&_XMM3, fmta);
        __asm
        {
          vaddss  xmm1, xmm9, [rsp+7200h+x]
          vmovss  [rsp+7200h+x], xmm1
        }
        if ( g_physicsServerWorldsCreated )
        {
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_FIRST, scrPlace, &x, &y, fmtb, *(float *)&forceColorb);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_SERVER_DETAIL, scrPlace, &x, &y, fmtc, *(float *)&forceColorc);
        }
        if ( g_physicsClientWorldsCreated )
        {
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_CLIENT_FIRST, scrPlace, &x, &y, fmtd, *(float *)&forceColord);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE, scrPlace, &x, &y, fmte, *(float *)&forceColore);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_CLIENT0_DETAIL, scrPlace, &x, &y, fmtf, *(float *)&forceColorf);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_CLIENT1_FIRST, scrPlace, &x, &y, fmtg, *(float *)&forceColorg);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE, scrPlace, &x, &y, fmth, *(float *)&forceColorh);
LABEL_490:
          v37 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_491:
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldMemory(v37, scrPlace, &x, &y, fmti, *(float *)&forceColori);
        }
        break;
      default:
        break;
    }
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]; jumptable 0000000140EAEF01 default case
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugCPU->current.integer )
  {
    Com_sprintf(dest, 0x100ui64, "Physics CPU Report");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightc, 0);
    __asm
    {
      vaddss  xmm2, xmm7, [rsp+7200h+y]; y
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm2
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugCPU->current.integer )
    {
      case 1:
        __asm
        {
          vmovss  xmm1, [rsp+7200h+x]; jumptable 0000000140EAF26E case 1
          vmovss  [rsp+7200h+charHeight], xmm7
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "General", &colorWhite, 0, 1, charHeightd, 0);
        __asm
        {
          vaddss  xmm1, xmm7, [rsp+7200h+y]
          vaddss  xmm0, xmm8, [rsp+7200h+x]
          vmovaps xmm3, xmm8; tabWidth
          vmovss  [rsp+7200h+y], xmm1
          vmovss  [rsp+7200h+x], xmm0
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        HavokPhysics_DrawDebugGeneralCPU(scrPlace, &x, &y, *(float *)&_XMM3, fmtj);
        __asm
        {
          vaddss  xmm1, xmm9, [rsp+7200h+x]
          vmovss  [rsp+7200h+x], xmm1
        }
        break;
      case 2:
        if ( g_physicsServerWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_FIRST;
          goto LABEL_517;
        }
        break;
      case 3:
        if ( g_physicsServerWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_SERVER_DETAIL;
          goto LABEL_517;
        }
        break;
      case 4:
        if ( g_physicsClientWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_CLIENT_FIRST;
          goto LABEL_517;
        }
        break;
      case 5:
        if ( g_physicsClientWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
          goto LABEL_517;
        }
        break;
      case 6:
        if ( g_physicsClientWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
          goto LABEL_517;
        }
        break;
      case 7:
        if ( g_physicsClientWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
          goto LABEL_517;
        }
        break;
      case 8:
        if ( g_physicsClientWorldsCreated )
        {
          v53 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
          goto LABEL_517;
        }
        break;
      case 9:
        if ( g_physicsClientWorldsCreated )
          goto LABEL_516;
        break;
      case 0xA:
        __asm
        {
          vmovss  xmm1, [rsp+7200h+x]; jumptable 0000000140EAF26E case 10
          vmovss  [rsp+7200h+charHeight], xmm7
        }
        Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "General", &colorWhite, 0, 1, charHeighte, 0);
        __asm
        {
          vaddss  xmm1, xmm7, [rsp+7200h+y]
          vaddss  xmm0, xmm8, [rsp+7200h+x]
          vmovaps xmm3, xmm8; tabWidth
          vmovss  [rsp+7200h+y], xmm1
          vmovss  [rsp+7200h+x], xmm0
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        HavokPhysics_DrawDebugGeneralCPU(scrPlace, &x, &y, *(float *)&_XMM3, fmtk);
        __asm
        {
          vaddss  xmm1, xmm9, [rsp+7200h+x]
          vmovss  [rsp+7200h+x], xmm1
        }
        if ( g_physicsServerWorldsCreated )
        {
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_FIRST, scrPlace, &x, &y, fmtl, *(float *)&forceColorj);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_SERVER_DETAIL, scrPlace, &x, &y, fmtm, *(float *)&forceColork);
        }
        if ( g_physicsClientWorldsCreated )
        {
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_CLIENT_FIRST, scrPlace, &x, &y, fmtn, *(float *)&forceColorl);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE, scrPlace, &x, &y, fmto, *(float *)&forceColorm);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_CLIENT0_DETAIL, scrPlace, &x, &y, fmtp, *(float *)&forceColorn);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_CLIENT1_FIRST, scrPlace, &x, &y, fmtq, *(float *)&forceColoro);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE, scrPlace, &x, &y, fmtr, *(float *)&forceColorp);
LABEL_516:
          v53 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_517:
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          Physics_DrawDebugWorldCPU(v53, scrPlace, &x, &y, fmts, *(float *)&forceColorq);
        }
        break;
      default:
        break;
    }
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]; jumptable 0000000140EAF26E default case
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugProfileData->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Profiling Summary");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightf, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "Client 0");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightg, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "Entities");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighth, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
    }
    LODWORD(forceColorr) = s_debugProfileData.clientData[0].numPredictivePhysicsObjectsNeedingFullUpdate;
    LODWORD(fmtt) = s_debugProfileData.clientData[0].numPredictivePhysicsObjectsNeedingUpdate;
    __asm
    {
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "%i Predictive Physics supporting Entities.  %i needing update including %i needing full update.", (unsigned int)s_debugProfileData.clientData[0].numPredictivePhysicsObjects, fmtt, forceColorr);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighti, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    LODWORD(fmtu) = s_debugProfileData.clientData[0].predictivePhysicsObjectChildCount;
    Com_sprintf(dest, 0x100ui64, "%i updating a total of %i children.", (unsigned int)s_debugProfileData.clientData[0].predictivePhysicsObjectChildHavingCount, fmtu);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightj, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(fmtv) = s_debugProfileData.clientData[0].predictivePhysicsObjectDynamicBoneMappingCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i updating a total of %i server-dynamic bone maps.", (unsigned int)s_debugProfileData.clientData[0].predictivePhysicsObjectDynamicBoneMappingHavingCount, fmtv);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightk, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(shadowa) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedBoneMappingCount;
    LODWORD(forceColors) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedBoneMappingCountUpdated;
    LODWORD(fmtw) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedBoneMappingHavingCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i of %i updating a total of %i of %i keyframed bone maps.", (unsigned int)s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedBoneMappingHavingCountUpdated, fmtw, forceColors, shadowa);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightl, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(shadowb) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedOffsetMappingCount;
    LODWORD(forceColort) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedOffsetMappingCountUpdated;
    LODWORD(fmtx) = s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedOffsetMappingHavingCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i of %i updating a total of %i of %i keyframed offset maps.", (unsigned int)s_debugProfileData.clientData[0].predictivePhysicsObjectKeyframedOffsetMappingHavingCountUpdated, fmtx, forceColort, shadowb);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightm, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
    }
    LODWORD(fmty) = s_debugProfileData.clientData[0].numPropagatedBodies;
    __asm { vmovss  [rsp+7200h+x], xmm0 }
    Com_sprintf(dest, 0x100ui64, "%i entities with a total of %i bodies propagated to auth world.", (unsigned int)s_debugProfileData.clientData[0].numPropagatedPhysicsObjects, fmty);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightn, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
    }
    LODWORD(fmtz) = s_debugProfileData.clientData[0].authoritativePhysicsObjectDynamicBoneMappingCount;
    __asm
    {
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "%i updating a total of %i client-dynamic bone maps.", (unsigned int)s_debugProfileData.clientData[0].authoritativePhysicsObjectDynamicBoneMappingHavingCount, fmtz);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighto, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
    }
    LODWORD(forceColoru) = s_debugProfileData.clientData[0].physicsObjectDetailDuplicationBodyCount;
    LODWORD(fmtba) = s_debugProfileData.clientData[0].physicsObjectDetailDuplicationCount;
    __asm
    {
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "%i detail bounded. %i with a total of %i bodies detail duplicated.", (unsigned int)s_debugProfileData.clientData[0].physicsObjectDetailBoundedCount, fmtba, forceColoru);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightp, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "Character Proxies");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightq, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+y], xmm1
    }
    Com_sprintf(dest, 0x100ui64, "%i proxies.", (unsigned int)s_debugProfileData.clientData[0].numPredictiveCharacterProxies);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightr, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "DynEnts");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeights, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    LODWORD(adjust) = s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntComplexAdditionalBoneCount;
    LODWORD(charHeightt) = s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntComplexBodyCount;
    LODWORD(shadowc) = s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntComplexCount;
    LODWORD(forceColorv) = s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntSimpleAdditionalBoneCount;
    LODWORD(fmtbb) = s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntSimpleCount;
    Com_sprintf(dest, 0x100ui64, "%i dynents.  %i Simple (%i total extra bones).  %i complex (%i/%i total bodies/extra bones).", (unsigned int)s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[0].dynEntsDataBufferIndex].dynEntCount, fmtbb, forceColorv, shadowc, charHeightt, adjust);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightu, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(forceColorw) = s_debugProfileData.clientData[0].dynEntDetailDuplicationBodyCount;
    LODWORD(fmtbc) = s_debugProfileData.clientData[0].dynEntDetailDuplicationCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i detail bounded.  %i with a total of %i bodies detail duplicated.", (unsigned int)s_debugProfileData.clientData[0].dynEntDetailBoundedCount, fmtbc, forceColorw);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightv, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "Particles");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightw, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
    }
    LODWORD(fmtbd) = s_debugProfileData.clientData[0].fxOldElemsWithPhysicsCount;
    __asm
    {
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "%i old elements with %i heavyweight bodies.", (unsigned int)s_debugProfileData.clientData[0].fxOldElemsCount, fmtbd);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightx, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(fmtbe) = s_debugProfileData.clientData[0].fxPhysicsSystemsCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i systems   - %i with heavyweight physics.", (unsigned int)s_debugProfileData.clientData[0].fxSystemsCount, fmtbe);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeighty, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(fmtbf) = s_debugProfileData.clientData[0].fxPhysicsEmittersCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i emitters  - %i with heavyweight physics.", (unsigned int)s_debugProfileData.clientData[0].fxEmittersCount, fmtbf);
    __asm
    {
      vmovss  [rsp+7200h+charHeight], xmm7
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightz, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(fmtbg) = s_debugProfileData.clientData[0].fxPhysicsStatesCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i states    - %i with heavyweight physics.", (unsigned int)s_debugProfileData.clientData[0].fxStatesCount, fmtbg);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightba, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    LODWORD(fmtbh) = s_debugProfileData.clientData[0].fxPhysicsParticlesCount;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    Com_sprintf(dest, 0x100ui64, "%i particles - %i with heavyweight physics.", (unsigned int)s_debugProfileData.clientData[0].fxParticlesCount, fmtbh);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbb, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "Glass");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbc, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
    }
    LODWORD(forceColorx) = s_debugProfileData.clientData[0].glassBodyCount;
    LODWORD(fmtbi) = s_debugProfileData.clientData[0].glassPhysicsCount;
    __asm
    {
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    Com_sprintf(dest, 0x100ui64, "%i pieces. %i physics pieces with %i bodies.", (unsigned int)s_debugProfileData.clientData[0].glassPieceCount, fmtbi, forceColorx);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  [rsp+7200h+charHeight], xmm7
      vmovss  xmm1, [rsp+7200h+x]; x
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbd, 0);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+x]
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vsubss  xmm0, xmm2, xmm8
      vmovss  [rsp+7200h+y], xmm1
      vsubss  xmm1, xmm0, cs:__real@41c00000
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v150 = physics_debugTimestep->current.integer;
  if ( (_DWORD)v150 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Timestep Graph for World %s", s_Physics_DebugSectionNames[v150]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbe, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugTimestep->current.integer )
    {
      case 2:
        v155 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_535;
      case 3:
        v155 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_535;
      case 4:
        v155 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_535;
      case 5:
        v155 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_535;
      case 6:
        v155 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_535;
      case 7:
        v155 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_535;
      case 8:
        v155 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_535;
      case 9:
        goto $LN859;
      case 0xA:
        if ( g_physicsServerWorldsCreated )
        {
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_FIRST, scrPlace, &x, &y, fmtbj, *(float *)&forceColory, g_physicsClientWorldsCreated == 0);
          __asm
          {
            vmovss  [rsp+7200h+forceColor], xmm7
            vmovss  dword ptr [rsp+7200h+fmt], xmm8
          }
          HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_SERVER_DETAIL, scrPlace, &x, &y, fmtbk, *(float *)&forceColorz, g_physicsClientWorldsCreated == 0);
        }
        if ( !g_physicsClientWorldsCreated )
          goto LABEL_536;
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_CLIENT_FIRST, scrPlace, &x, &y, fmtbl, *(float *)&forceColorba, 0);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE, scrPlace, &x, &y, fmtbm, *(float *)&forceColorbb, 1);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_CLIENT0_DETAIL, scrPlace, &x, &y, fmtbn, *(float *)&forceColorbc, 1);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_CLIENT1_FIRST, scrPlace, &x, &y, fmtbo, *(float *)&forceColorbd, 0);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE, scrPlace, &x, &y, fmtbp, *(float *)&forceColorbe, 1);
$LN859:
        v155 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_535:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        HavokPhysics_DrawDebugWorldTimestep(v155, scrPlace, &x, &y, fmtbq, *(float *)&forceColorbf, 1);
LABEL_536:
        __asm
        {
          vaddss  xmm1, xmm9, [rsp+7200h+x]; jumptable 0000000140EB010A default case
          vmovss  [rsp+7200h+x], xmm1
        }
        break;
      default:
        goto LABEL_536;
    }
  }
  if ( physics_debugRefSystemCounts->current.enabled )
  {
    v157 = 0;
    v158 = s_Physics_WorldNames;
    do
    {
      if ( v157 == -1 )
      {
        v159 = "Invalid";
      }
      else
      {
        if ( (unsigned int)v157 >= 8 )
        {
          LODWORD(shadow) = 8;
          LODWORD(forceColor) = v157;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 753, ASSERT_TYPE_ASSERT, "(unsigned)( worldId ) < (unsigned)( ( sizeof( *array_counter( s_Physics_WorldNames ) ) + 0 ) )", "worldId doesn't index ARRAY_COUNT( s_Physics_WorldNames )\n\t%i not in [0, %i)", forceColor, shadow) )
            __debugbreak();
        }
        v159 = *v158;
      }
      Com_sprintf(dest, 0x100ui64, "Physics Ref System counts for world %s", v159);
      __asm
      {
        vmovss  xmm2, [rsp+7200h+y]; y
        vmovss  xmm1, [rsp+7200h+x]; x
        vmovss  [rsp+7200h+charHeight], xmm7
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbf, 0);
      __asm
      {
        vaddss  xmm1, xmm7, [rsp+7200h+y]
        vmovss  [rsp+7200h+forceColor], xmm7
        vmovss  [rsp+7200h+y], xmm1
        vmovss  dword ptr [rsp+7200h+fmt], xmm8
      }
      HavokPhysics_DrawDebugPhysicsRefSystemCounts((Physics_WorldId)v157++, scrPlace, &x, &y, fmtbr, *(float *)&forceColorbg);
      ++v158;
    }
    while ( v157 < 8 );
  }
  v163 = 0;
  v164 = physics_debugVisualizeWorld->current.integer;
  if ( Dvar_HasLatchedValue(physics_debugVisualizeWorld) )
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorld);
  if ( Dvar_HasLatchedValue(physics_debugVisualizeWorldViewMode) )
  {
    v163 = 1;
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldViewMode);
  }
  if ( Dvar_HasLatchedValue(physics_debugVisualizeWorldComplexityTriThreshold) )
  {
    v163 = 1;
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldComplexityTriThreshold);
  }
  if ( Dvar_HasLatchedValue(physics_debugVisualizeWorldComplexityLineThreshold) )
  {
    v163 = 1;
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldComplexityLineThreshold);
  }
  v165 = Dvar_HasLatchedValue(physics_debugVisualizeWorldBodyId) | v163;
  v166 = Dvar_HasLatchedValue(physics_debugVisualizeWorldBroadphase) | v165;
  v167 = Dvar_HasLatchedValue(physics_debugVisualizeWorldConstraint) | v166;
  v168 = Dvar_HasLatchedValue(physics_debugVisualizeWorldDeactivation) | v167;
  v169 = Dvar_HasLatchedValue(physics_debugVisualizeWorldManifold) | v168;
  v170 = Dvar_HasLatchedValue(physics_debugVisualizeWorldMassProperties) | v169;
  v171 = Dvar_HasLatchedValue(physics_debugVisualizeWorldMotionId) | v170;
  v172 = Dvar_HasLatchedValue(physics_debugVisualizeWorldShape) | v171;
  v173 = Dvar_HasLatchedValue(physics_debugVisualizeWorldShapeLowRes) | v172;
  v174 = Dvar_HasLatchedValue(physics_debugVisualizeWorldVehicles) | v173;
  v175 = Dvar_HasLatchedValue(physics_debugVisualizeWorldCollisionHeatmap) | v174;
  v176 = Dvar_HasLatchedValue(physics_debugVisualizeWorldDebugDraw) | v175;
  v177 = Dvar_HasLatchedValue(physics_debugVisualizeWorldCollisionTile) | v176;
  v178 = Dvar_HasLatchedValue(physics_debugVisualizeWorldRaycasts) | v177;
  v179 = Dvar_HasLatchedValue(physics_debugVisualizeWorldShapecasts) | v178;
  v180 = Dvar_HasLatchedValue(physics_debugVisualizeWorldAABBQuery) | v179;
  v181 = Dvar_HasLatchedValue(physics_debugVisualizeWorldPointQuery) | v180;
  v182 = Dvar_HasLatchedValue(physics_debugVisualizeWorldClosestPointsQuery) | v181;
  v183 = Dvar_HasLatchedValue(physics_debugVisualizeWorldIWShape) | v182;
  v184 = Dvar_HasLatchedValue(physics_debugVisualizeWorldParticles) | v183;
  v185 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldGeometry) | v184;
  v186 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimParticlePosition) | v185;
  v187 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimNormals) | v186;
  v188 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldParticleVelocity) | v187;
  v189 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldParticleId) | v188;
  v190 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimStandardLinks) | v189;
  v191 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimStretchLinks) | v190;
  v192 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimBendLinks) | v191;
  v193 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimBendStiffness) | v192;
  v194 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldSimVolumeTransforms) | v193;
  v195 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldLocalRange) | v194;
  v196 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldBonePlane) | v195;
  v197 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldTransition) | v196;
  v198 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldCollidable) | v197;
  v199 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldParticleRadius) | v198;
  v200 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldVirtualCollisionPoints) | v199;
  v201 = Dvar_HasLatchedValue(cloth_debugVisualizeWorldVirtualCollisionPointsLandscape) | v200;
  if ( v201 )
  {
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldBodyId);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldBroadphase);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldConstraint);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldDeactivation);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldManifold);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldMassProperties);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldMotionId);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldShape);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldShapeLowRes);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldVehicles);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldCollisionHeatmap);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldDebugDraw);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldCollisionTile);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldRaycasts);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldShapecasts);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldAABBQuery);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldPointQuery);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldClosestPointsQuery);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldIWShape);
    Dvar_MakeLatchedValueCurrent(physics_debugVisualizeWorldParticles);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldGeometry);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimParticlePosition);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimNormals);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldParticleVelocity);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldParticleId);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimStandardLinks);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimStretchLinks);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimBendLinks);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimBendStiffness);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldSimVolumeTransforms);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldLocalRange);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldBonePlane);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldTransition);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldCollidable);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldParticleRadius);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldVirtualCollisionPoints);
    Dvar_MakeLatchedValueCurrent(cloth_debugVisualizeWorldVirtualCollisionPointsLandscape);
  }
  v202 = v164 - 2;
  if ( (unsigned int)v202 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    v202 = PHYSICS_WORLD_ID_INVALID;
  if ( !g_physicsServerWorldsCreated && (unsigned int)v202 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    v202 = PHYSICS_WORLD_ID_INVALID;
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v202 - 2) <= 5 )
    v202 = PHYSICS_WORLD_ID_INVALID;
  v203 = physics_debugVisualizeWorld->current.integer - 2;
  if ( (unsigned int)v203 > 7 )
    v203 = -1;
  if ( !g_physicsServerWorldsCreated && (unsigned int)v203 <= 1 )
    v203 = -1;
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v203 - 2) <= 5 )
    v203 = -1;
  if ( v202 != PHYSICS_WORLD_ID_INVALID && (v202 != v203 || v201) && (g_physicsServerWorldsCreated || g_physicsClientWorldsCreated) )
    HavokPhysics_StopDrawDebugWorld(v202);
  if ( (unsigned int)v203 > 1 )
  {
    if ( v203 > 4 )
      v204 = 2;
    else
      v204 = 1;
    if ( (v204 & g_physicsClientWorldsCreated) == 0 )
      goto LABEL_586;
LABEL_585:
    v205 = 1;
    goto LABEL_587;
  }
  if ( g_physicsServerWorldsCreated )
    goto LABEL_585;
LABEL_586:
  v205 = 0;
LABEL_587:
  if ( v203 == -1 )
    goto LABEL_599;
  if ( v202 != v203 || v201 )
  {
    if ( !v205 )
      goto LABEL_599;
    if ( g_physicsServerWorldsCreated || g_physicsClientWorldsCreated )
      HavokPhysics_StartDrawDebugWorld((Physics_WorldId)v203);
  }
  if ( v205 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics World Visualization");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbg, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    WorldName = Physics_GetWorldName((Physics_WorldId)v203);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, WorldName, &colorWhite, 0, 1, charHeightbh, 0);
    __asm
    {
      vaddss  xmm2, xmm7, [rsp+7200h+y]; y
      vmovss  [rsp+7200h+y], xmm2
    }
    if ( g_physicsServerWorldsCreated || g_physicsClientWorldsCreated )
    {
      __asm
      {
        vaddss  xmm1, xmm8, [rsp+7200h+x]
        vmovss  [rsp+7200h+forceColor], xmm7
        vmovss  [rsp+7200h+x], xmm1
        vmovss  dword ptr [rsp+7200h+fmt], xmm8
      }
      HavokPhysics_DrawDebugWorld((Physics_WorldId)v203, scrPlace, &x, &y, fmtbs, *(float *)&forceColorbh);
      __asm
      {
        vmovss  xmm0, [rsp+7200h+x]
        vaddss  xmm2, xmm0, xmm9
        vaddss  xmm0, xmm2, xmm9
        vmovss  [rsp+7200h+x], xmm0
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm1, [rsp+7200h+x]; x
        vmovss  [rsp+7200h+charHeight], xmm7
      }
      Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "Worlds not set up", &colorWhite, 0, 1, charHeightbi, 0);
      __asm
      {
        vmovss  xmm2, [rsp+7200h+x]
        vaddss  xmm1, xmm7, [rsp+7200h+y]
        vaddss  xmm0, xmm2, xmm9
        vmovss  [rsp+7200h+x], xmm0
        vmovss  [rsp+7200h+y], xmm1
      }
    }
  }
LABEL_599:
  v222 = physics_debugVisualizeCharacterProxies->current.integer;
  if ( (_DWORD)v222 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics character proxies in World %s", s_Physics_DebugSectionNames[v222]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbj, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugVisualizeCharacterProxies->current.integer )
    {
      case 1:
        __asm
        {
          vmovaps xmm3, xmm8; jumptable 0000000140EB0BE6 case 1
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        G_PhysicsCharacterProxy_DebugDrawEntityData(scrPlace, &x, &y, *(float *)&_XMM3, fmtbt);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_0, scrPlace, &x, &y, fmtbu, *(float *)&forceColorbi);
        break;
      case 2:
        __asm
        {
          vmovaps xmm3, xmm8; jumptable 0000000140EB0BE6 case 2
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        G_PhysicsCharacterProxy_DebugDrawEntityData(scrPlace, &x, &y, *(float *)&_XMM3, fmtbv);
        G_PhysicsCharacterProxy_DebugDrawEntityShapes(PHYSICS_WORLD_ID_FIRST);
        break;
      case 3:
        __asm
        {
          vmovaps xmm3, xmm8; jumptable 0000000140EB0BE6 case 3
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        G_PhysicsCharacterProxy_DebugDrawEntityData(scrPlace, &x, &y, *(float *)&_XMM3, fmtbw);
        G_PhysicsCharacterProxy_DebugDrawEntityShapes(PHYSICS_WORLD_ID_SERVER_DETAIL);
        break;
      case 4:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 4
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_0, scrPlace, &x, &y, fmtbx, *(float *)&forceColorbj);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesPred(LOCAL_CLIENT_0);
        break;
      case 5:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 5
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_0, scrPlace, &x, &y, fmtby, *(float *)&forceColorbk);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesAuth(LOCAL_CLIENT_0);
        break;
      case 6:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 6
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_0, scrPlace, &x, &y, fmtbz, *(float *)&forceColorbl);
        v230 = LOCAL_CLIENT_0;
        goto LABEL_612;
      case 7:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_1, scrPlace, &x, &y, fmtca, *(float *)&forceColorbm);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesPred(LOCAL_CLIENT_1);
        break;
      case 8:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 8
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_1, scrPlace, &x, &y, fmtcb, *(float *)&forceColorbn);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesAuth(LOCAL_CLIENT_1);
        break;
      case 9:
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7; jumptable 0000000140EB0BE6 case 9
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_1, scrPlace, &x, &y, fmtcc, *(float *)&forceColorbo);
        goto LABEL_611;
      case 0xA:
        __asm
        {
          vmovaps xmm3, xmm8; jumptable 0000000140EB0BE6 case 10
          vmovss  dword ptr [rsp+7200h+fmt], xmm7
        }
        G_PhysicsCharacterProxy_DebugDrawEntityData(scrPlace, &x, &y, *(float *)&_XMM3, fmtcd);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_0, scrPlace, &x, &y, fmtce, *(float *)&forceColorbp);
        __asm
        {
          vmovss  [rsp+7200h+forceColor], xmm7
          vmovss  dword ptr [rsp+7200h+fmt], xmm8
        }
        CG_PhysicsCharacterProxy_DebugDrawEntityData(LOCAL_CLIENT_1, scrPlace, &x, &y, fmtcf, *(float *)&forceColorbq);
        G_PhysicsCharacterProxy_DebugDrawEntityShapes(PHYSICS_WORLD_ID_FIRST);
        G_PhysicsCharacterProxy_DebugDrawEntityShapes(PHYSICS_WORLD_ID_SERVER_DETAIL);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesPred(LOCAL_CLIENT_0);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesAuth(LOCAL_CLIENT_0);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesDetail(LOCAL_CLIENT_0);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesPred(LOCAL_CLIENT_1);
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesAuth(LOCAL_CLIENT_1);
LABEL_611:
        v230 = LOCAL_CLIENT_1;
LABEL_612:
        CG_PhysicsCharacterProxy_DebugDrawEntityShapesDetail(v230);
        break;
      default:
        break;
    }
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]; jumptable 0000000140EB0BE6 default case
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugLibraryMaterials->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Materials");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbk, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsLibraryMaterials(scrPlace, &x, &y, *(float *)&_XMM3, fmtcg);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugLibraryBodyQualitys->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Body Qualitys");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbl, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsLibraryBodyQualitys(scrPlace, &x, &y, *(float *)&_XMM3, fmtch);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugLibraryMotionProperties->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Motion Properties");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbm, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsLibraryMotionProperties(scrPlace, &x, &y, *(float *)&_XMM3, fmtci);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v251 = physics_debugLibraryMaterialId->current.unsignedInt;
  if ( (int)v251 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Material Id %i", v251);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbn, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsLibraryMaterialId(physics_debugLibraryMaterialId->current.integer, scrPlace, &x, &y, fmtcj, *(float *)&forceColorbr);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v257 = physics_debugLibraryBodyQualityId->current.unsignedInt;
  if ( (int)v257 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Body Quality Id %i", v257);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbo, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsLibraryBodyQualityId(physics_debugLibraryBodyQualityId->current.integer, scrPlace, &x, &y, fmtck, *(float *)&forceColorbs);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v263 = physics_debugLibraryMotionPropertiesId->current.unsignedInt;
  if ( (int)v263 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Library Material Id %i", v263);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbp, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+shadow], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm8
    }
    HavokPhysics_DrawPhysicsLibraryMotionPropertiesId(NULL, physics_debugLibraryMotionPropertiesId->current.integer, scrPlace, &x, &y, *(float *)&forceColorbt, *(float *)&shadowd);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugAssetsByName->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Assets by Name");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbq, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsAssets(1, scrPlace, &x, &y, fmtcl, *(float *)&forceColorbu);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugAssetsByMemory->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Assets by Memory");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbr, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsAssets(0, scrPlace, &x, &y, fmtcm, *(float *)&forceColorbv);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v279 = physics_debugAssetIdByName->current.unsignedInt;
  if ( (int)v279 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Asset Id by Name: %i", v279);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbs, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+shadow], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm8
    }
    HavokPhysics_DrawPhysicsAssetId(1, physics_debugAssetIdByName->current.integer, scrPlace, &x, &y, *(float *)&forceColorbw, *(float *)&shadowe);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v285 = physics_debugAssetIdByMemory->current.unsignedInt;
  if ( (int)v285 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Asset Id by Memory: %i", v285);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbt, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+shadow], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm8
    }
    HavokPhysics_DrawPhysicsAssetId(0, physics_debugAssetIdByMemory->current.integer, scrPlace, &x, &y, *(float *)&forceColorbx, *(float *)&shadowf);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugXModelsWithNoPhysicsAsset->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModels without PhysicsAssets");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbu, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovaps xmm3, xmm8; tabWidth
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets(scrPlace, &x, &y, *(float *)&_XMM3, fmtcn, physics_debugXModelsExcludeDoNotUse->current.enabled);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugXModelsWithCollLods->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModels with ColLods");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbv, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovaps xmm3, xmm8; tabWidth
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsXModelsWithColLods(scrPlace, &x, &y, *(float *)&_XMM3, fmtco, physics_debugXModelsExcludeDoNotUse->current.enabled);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugXModelsByName->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModels By Name");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbw, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType_ByName, scrPlace, &x, &y, fmtcp, *(float *)&forceColorby);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugXModelsByMemory->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModels By Memory");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbx, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType_ByMemory, scrPlace, &x, &y, fmtcq, *(float *)&forceColorbz);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugXModelsByDetailBodyCount->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModels By Detail Body Count");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightby, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType_ByDetailBodyCount, scrPlace, &x, &y, fmtcr, *(float *)&forceColorca);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v318 = physics_debugXModelIdByName->current.unsignedInt;
  if ( (int)v318 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModel Id %i, indexed by name", v318);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightbz, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+shadow], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm8
    }
    HavokPhysics_DrawPhysicsXModelId(1, physics_debugXModelIdByName->current.integer, scrPlace, &x, &y, *(float *)&forceColorcb, *(float *)&shadowg);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v324 = physics_debugXModelIdByMemory->current.unsignedInt;
  if ( (int)v324 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics XModel Id %i, indexed by memory", v324);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightca, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+shadow], xmm7
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm8
    }
    HavokPhysics_DrawPhysicsXModelId(0, physics_debugXModelIdByMemory->current.integer, scrPlace, &x, &y, *(float *)&forceColorcc, *(float *)&shadowh);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugSFXEventAssets->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics SFX Event Assets");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcb, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsSFXEventAssets(scrPlace, &x, &y, *(float *)&_XMM3, fmtcs);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v336 = physics_debugSFXEventAssetId->current.unsignedInt;
  if ( (int)v336 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics SFX Event Asset Id %i", v336);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcc, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsSFXEventAssetId(physics_debugSFXEventAssetId->current.integer, scrPlace, &x, &y, fmtct, *(float *)&forceColorcd);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugVFXEventAssets->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics VFX Event Assets");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcd, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawPhysicsVFXEventAssets(scrPlace, &x, &y, *(float *)&_XMM3, fmtcu);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v348 = physics_debugVFXEventAssetId->current.unsignedInt;
  if ( (int)v348 >= 0 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics VFX Event Asset Id %i", v348);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightce, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+forceColor], xmm7
      vmovss  dword ptr [rsp+7200h+fmt], xmm8
    }
    HavokPhysics_DrawPhysicsVFXEventAssetId(physics_debugVFXEventAssetId->current.integer, scrPlace, &x, &y, fmtcv, *(float *)&forceColorce);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  if ( physics_debugClipmapBrushes->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Clipmap Brushes");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcf, 0);
    __asm { vmovss  xmm2, [rsp+7200h+x] }
    mapEnts = cm.mapEnts;
    v358 = 0;
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm2, xmm8
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+y], xmm1
    }
    if ( cm.mapEnts->numSubModels )
    {
      do
      {
        v361 = (__int64)&mapEnts->cmodels[v358];
        if ( *(_QWORD *)(v361 + 32) )
        {
          v362 = *(unsigned __int16 *)(v361 + 40);
          if ( v362 >= WorldCollision_GetMapEntsShapeCount() )
            MapEntsShapeName = "Unknown";
          else
            MapEntsShapeName = WorldCollision_GetMapEntsShapeName(v362);
          Com_sprintf(dest, 0x100ui64, "%i asset:%s for brush:%s", v358, **(const char ***)(v361 + 32), MapEntsShapeName);
          __asm
          {
            vmovss  xmm2, [rsp+7200h+y]; y
            vmovss  xmm1, [rsp+7200h+x]; x
            vmovss  [rsp+7200h+charHeight], xmm7
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcg, 0);
          __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
          mapEnts = cm.mapEnts;
          __asm { vmovss  [rsp+7200h+y], xmm1 }
        }
        ++v358;
      }
      while ( v358 < mapEnts->numSubModels );
      __asm { vmovss  xmm0, [rsp+7200h+x] }
    }
    __asm
    {
      vaddss  xmm0, xmm0, xmm9
      vmovss  [rsp+7200h+x], xmm0
    }
  }
  if ( physics_debugParticlesHeavyweight->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Loaded particle effect assets that have heavyweight bodies");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightch, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    *(_DWORD *)buffer = 40;
    __asm { vmovss  [rsp+7200h+y], xmm1 }
    *(_QWORD *)&buffer[8] = v771;
    *(_DWORD *)&buffer[16] = 0;
    *(_DWORD *)&buffer[20] = 3584;
    DB_LockHashRead();
    v371 = 0;
    p_m_headEntries = &s_assetManager.table.m_headEntries;
    v373 = 0;
    AssetEntryPool = DB_GetAssetEntryPool();
    do
    {
      DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>(AssetEntryPool, &s_assetManager.table.m_headEntries, p_m_headEntries->m_flags.m_data[0], v373, (GetAllXAssetFunctor *)buffer);
      v373 += 64;
      ++v371;
      p_m_headEntries = (DB_AssetEntryFlags *)((char *)p_m_headEntries + 8);
    }
    while ( v371 < 0x1768 );
    DB_UnlockHashRead();
    __asm { vmovss  xmm0, [rsp+7200h+x] }
    v376 = *(int *)&buffer[16];
    unsignedInt = collisionFilterInfo;
    v377 = 0;
    __asm
    {
      vaddss  xmm1, xmm0, xmm8
      vmovss  [rsp+7200h+x], xmm1
    }
    if ( *(int *)&buffer[16] > 0 )
    {
      v379 = 0i64;
      do
      {
        v380 = v771[v379];
        if ( v380 )
        {
          v381 = *(_DWORD **)(v380 + 8);
          if ( v381 )
          {
            if ( (*(_BYTE *)(v380 + 36) & 8) != 0 )
            {
              v382 = *(_DWORD *)(v380 + 28);
              v383 = 0;
              if ( v382 )
              {
                v384 = v382;
                do
                {
                  if ( (v381[25] & 0x21) == 32 )
                  {
                    v385 = v381[2];
                    if ( v385 )
                    {
                      v386 = v385;
                      v387 = (_BYTE *)(*(_QWORD *)v381 + 16i64);
                      do
                      {
                        if ( (*v387 & 1) == 0 && *((_DWORD *)v387 - 2) == 7 && (*(_DWORD *)v387 & 0x400i64) != 0 )
                          v383 += v381[9];
                        v387 += 32;
                        --v386;
                      }
                      while ( v386 );
                    }
                  }
                  v381 += 40;
                  --v384;
                }
                while ( v384 );
                if ( v383 > 0 )
                {
                  LODWORD(forceColora) = v383;
                  Com_sprintf(dest, 0x100ui64, "%i \tasset:\t%s \twith max HWP:\t%i", v377, *(const char **)v380, forceColora);
                  __asm
                  {
                    vmovss  xmm2, [rsp+7200h+y]; y
                    vmovss  xmm1, [rsp+7200h+x]; x
                    vmovss  [rsp+7200h+charHeight], xmm7
                  }
                  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightci, 0);
                  __asm
                  {
                    vaddss  xmm1, xmm7, [rsp+7200h+y]
                    vmovss  [rsp+7200h+y], xmm1
                  }
                  ++v377;
                }
              }
            }
          }
        }
        ++v379;
      }
      while ( v379 < v376 );
      __asm { vmovss  xmm1, [rsp+7200h+x] }
    }
    __asm
    {
      vaddss  xmm0, xmm1, xmm9
      vmovss  [rsp+7200h+x], xmm0
    }
  }
  v392 = physics_debugWorld->current.integer;
  if ( (_DWORD)v392 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics World %s", s_Physics_DebugSectionNames[v392]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcj, 0);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+x]
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm2, xmm8
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+y], xmm1
    }
    switch ( physics_debugWorld->current.integer )
    {
      case 2:
        v398 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_700;
      case 3:
        v398 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_700;
      case 4:
        v398 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_700;
      case 5:
        v398 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_700;
      case 6:
        v398 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_700;
      case 7:
        v398 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_700;
      case 8:
        v398 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_700;
      case 9:
        v398 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_700:
        __asm
        {
          vmovss  [rsp+7200h+shadow], xmm7
          vmovss  [rsp+7200h+forceColor], xmm8
        }
        HavokPhysics_DrawWorld(v398, physics_debugWorldFull->current.enabled, scrPlace, &x, &y, *(float *)&forceColorcf, *(float *)&shadowi);
        v399 = physics_debugWorldBody->current.unsignedInt;
        if ( (_DWORD)v399 == -1 )
        {
          __asm
          {
            vmovss  xmm0, [rsp+7200h+x]
            vaddss  xmm0, xmm0, xmm9
            vmovss  [rsp+7200h+x], xmm0
          }
        }
        else
        {
          Com_sprintf(dest, 0x100ui64, "Physics Body %i", v399);
          __asm
          {
            vmovss  xmm2, [rsp+7200h+y]; y
            vmovss  xmm1, [rsp+7200h+x]; x
            vmovss  [rsp+7200h+charHeight], xmm7
          }
          Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightck, 0);
          __asm
          {
            vaddss  xmm1, xmm7, [rsp+7200h+y]
            vaddss  xmm0, xmm8, [rsp+7200h+x]
            vmovss  [rsp+7200h+charHeight], xmm7
            vmovss  [rsp+7200h+shadow], xmm8
            vmovss  [rsp+7200h+y], xmm1
            vmovss  [rsp+7200h+x], xmm0
          }
          HavokPhysics_DrawPhysicsBody(v398, *(hknpBodyId *)&physics_debugWorldBody->current.enabled, 1, scrPlace, &x, &y, *(float *)&shadowj, charHeightcl);
          __asm
          {
            vaddss  xmm0, xmm9, [rsp+7200h+x]
            vaddss  xmm0, xmm0, xmm9
            vmovss  [rsp+7200h+x], xmm0
          }
        }
        break;
      default:
        __asm
        {
          vaddss  xmm0, xmm0, xmm9; jumptable 0000000140EB20DC default case
          vmovss  [rsp+7200h+x], xmm0
        }
        break;
    }
  }
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vxorps  xmm10, xmm10, xmm10
  }
  v411 = physics_debugAABBBroadphaseWorldQuery->current.integer;
  if ( (_DWORD)v411 )
  {
    v412 = s_Physics_DebugSectionNames[v411];
    __asm
    {
      vmovss  dword ptr [rsp+7200h+buffer+0Ch], xmm10
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer], xmm1
      vmovss  dword ptr [rsp+7200h+buffer+4], xmm0
      vmovss  dword ptr [rsp+7200h+buffer+8], xmm2
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer+10h], xmm1
      vmovss  dword ptr [rsp+7200h+buffer+14h], xmm0
      vmovss  dword ptr [rsp+7200h+buffer+18h], xmm2
      vmovss  dword ptr [rsp+7200h+buffer+1Ch], xmm10
    }
    Com_sprintf(dest, 0x100ui64, "Physics AABB Broadphase Query for world %s", v412);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcm, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugAABBBroadphaseWorldQuery->current.integer )
    {
      case 2:
        v423 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_714;
      case 3:
        v423 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_714;
      case 4:
        v423 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_714;
      case 5:
        v423 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_714;
      case 6:
        v423 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_714;
      case 7:
        v423 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_714;
      case 8:
        v423 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_714;
      case 9:
        v423 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_714:
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+7200h+buffer]
          vmovss  [rsp+7200h+charHeight], xmm7
          vmovss  [rsp+7200h+shadow], xmm8
          vmovups ymmword ptr [rsp+7200h+buffer], ymm0
        }
        HavokPhysics_DrawDebugAABBBroadphaseWorldQuery(v423, unsignedInt, (const hkAabb *)buffer, scrPlace, &x, &y, *(float *)&shadowk, charHeightcn);
        break;
      default:
        break;
    }
  }
  v425 = physics_debugAABBWorldQuery->current.integer;
  if ( (_DWORD)v425 )
  {
    v426 = s_Physics_DebugSectionNames[v425];
    __asm
    {
      vmovss  dword ptr [rsp+7200h+buffer+0Ch], xmm10
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer], xmm1
      vmovss  dword ptr [rsp+7200h+buffer+4], xmm0
      vmovss  dword ptr [rsp+7200h+buffer+8], xmm2
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer+10h], xmm1
      vmovss  dword ptr [rsp+7200h+buffer+14h], xmm0
      vmovss  dword ptr [rsp+7200h+buffer+18h], xmm2
      vmovss  dword ptr [rsp+7200h+buffer+1Ch], xmm10
    }
    Com_sprintf(dest, 0x100ui64, "Physics AABB World Query for world %s", v426);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightco, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugAABBWorldQuery->current.integer )
    {
      case 2:
        v437 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_725;
      case 3:
        v437 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_725;
      case 4:
        v437 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_725;
      case 5:
        v437 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_725;
      case 6:
        v437 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_725;
      case 7:
        v437 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_725;
      case 8:
        v437 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_725;
      case 9:
        v437 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_725:
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+7200h+buffer]
          vmovss  [rsp+7200h+charHeight], xmm7
          vmovss  [rsp+7200h+shadow], xmm8
          vmovups ymmword ptr [rsp+7200h+buffer], ymm0
        }
        HavokPhysics_DrawDebugAABBWorldQuery(v437, unsignedInt, (const hkAabb *)buffer, scrPlace, &x, &y, *(float *)&shadowl, charHeightcp);
        break;
      default:
        break;
    }
  }
  v439 = physics_debugRayWorld->current.integer;
  if ( (_DWORD)v439 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Raycast for world %s", s_Physics_DebugSectionNames[v439]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcq, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugRayWorld->current.integer )
    {
      case 2:
        v444 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_736;
      case 3:
        v444 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_736;
      case 4:
        v444 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_736;
      case 5:
        v444 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_736;
      case 6:
        v444 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_736;
      case 7:
        v444 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_736;
      case 8:
        v444 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_736;
      case 9:
        v444 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_736:
        __asm
        {
          vmovss  [rsp+7200h+charHeight], xmm7
          vmovss  [rsp+7200h+shadow], xmm8
        }
        HavokPhysics_DrawDebugRaycast(v444, unsignedInt, physics_debugRayClutter->current.enabled, scrPlace, &x, &y, *(float *)&shadowm, charHeightcr);
        break;
      default:
        break;
    }
  }
  v445 = physics_debugShapeCastWorld->current.integer;
  if ( (_DWORD)v445 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Shapecast for world %s", s_Physics_DebugSectionNames[v445]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcs, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
    }
    switch ( physics_debugShapeCastWorld->current.integer )
    {
      case 2:
        v450 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_747;
      case 3:
        v450 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_747;
      case 4:
        v450 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_747;
      case 5:
        v450 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_747;
      case 6:
        v450 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_747;
      case 7:
        v450 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_747;
      case 8:
        v450 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_747;
      case 9:
        v450 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_747:
        __asm
        {
          vmovss  [rsp+7200h+shadow], xmm7
          vmovss  [rsp+7200h+forceColor], xmm8
        }
        HavokPhysics_DrawDebugShapecast(v450, unsignedInt, scrPlace, &x, &y, *(float *)&forceColorcg, *(float *)&shadown);
        break;
      default:
        break;
    }
  }
  v451 = physics_debugQueryPointWorld->current.integer;
  if ( (_DWORD)v451 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Point Query for world %s", s_Physics_DebugSectionNames[v451]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightct, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+y], xmm1
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmovss  dword ptr [rsp+7200h+buffer], xmm1
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmovss  dword ptr [rsp+7200h+buffer+4], xmm0
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer+8], xmm2
      vmovss  dword ptr [rsp+7200h+buffer+0Ch], xmm10
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rax+28h]
      vmulss  xmm2, xmm0, xmm6; maxDistance
    }
    switch ( physics_debugQueryPointWorld->current.integer )
    {
      case 2:
        v462 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_758;
      case 3:
        v462 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_758;
      case 4:
        v462 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_758;
      case 5:
        v462 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_758;
      case 6:
        v462 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_758;
      case 7:
        v462 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_758;
      case 8:
        v462 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_758;
      case 9:
        v462 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_758:
        __asm
        {
          vmovss  [rsp+7200h+adjust], xmm7
          vmovss  [rsp+7200h+charHeight], xmm8
        }
        HavokPhysics_DrawDebugQueryPoint(v462, (const hkVector4f *)buffer, *(float *)&_XMM2, unsignedInt, scrPlace, &x, &y, charHeightcu, *(float *)&adjusta);
        break;
      default:
        break;
    }
  }
  v463 = physics_debugGetClosestPointsWorld->current.integer;
  if ( (_DWORD)v463 )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Get Closest Points Query for world %s", s_Physics_DebugSectionNames[v463]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcv, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm0
      vmovss  [rsp+7200h+y], xmm1
      vmulss  xmm1, xmm6, dword ptr [rax+28h]
      vmovss  dword ptr [rsp+7200h+buffer], xmm1
      vmulss  xmm0, xmm6, dword ptr [rax+2Ch]
      vmovss  dword ptr [rsp+7200h+buffer+4], xmm0
      vmulss  xmm2, xmm6, dword ptr [rax+30h]
      vmovss  dword ptr [rsp+7200h+buffer+8], xmm2
      vmovss  dword ptr [rsp+7200h+buffer+0Ch], xmm10
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rax+28h]
      vmulss  xmm2, xmm0, xmm6; maxDistance
    }
    switch ( physics_debugGetClosestPointsWorld->current.integer )
    {
      case 2:
        v474 = PHYSICS_WORLD_ID_FIRST;
        goto LABEL_769;
      case 3:
        v474 = PHYSICS_WORLD_ID_SERVER_DETAIL;
        goto LABEL_769;
      case 4:
        v474 = PHYSICS_WORLD_ID_CLIENT_FIRST;
        goto LABEL_769;
      case 5:
        v474 = PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE;
        goto LABEL_769;
      case 6:
        v474 = PHYSICS_WORLD_ID_CLIENT0_DETAIL;
        goto LABEL_769;
      case 7:
        v474 = PHYSICS_WORLD_ID_CLIENT1_FIRST;
        goto LABEL_769;
      case 8:
        v474 = PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
        goto LABEL_769;
      case 9:
        v474 = PHYSICS_WORLD_ID_CLIENT1_DETAIL;
LABEL_769:
        __asm
        {
          vmovss  [rsp+7200h+adjust], xmm7
          vmovss  [rsp+7200h+charHeight], xmm8
        }
        HavokPhysics_DrawDebugGetClosestPoints(v474, (const hkVector4f *)buffer, *(float *)&_XMM2, unsignedInt, scrPlace, &x, &y, charHeightcw, *(float *)&adjustb);
        break;
      default:
        break;
    }
  }
  if ( physics_debugDetailModel->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Physics Debug Detail model");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcx, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawDebugDetailModel(scrPlace, &x, &y, *(float *)&_XMM3, fmtcw);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v481 = !physics_debugFlickerColLod->current.enabled;
  if ( physics_debugFlickerColLod->current.enabled )
  {
    __asm
    {
      vmovss  xmm0, cs:timer
      vaddss  xmm1, xmm0, cs:__real@3c888889
      vcomiss xmm1, cs:__real@40000000
      vmovss  cs:timer, xmm1
    }
    if ( !v481 )
    {
      __asm
      {
        vmovss  cs:timer, xmm10
        vxorps  xmm1, xmm1, xmm1
      }
    }
    __asm { vcomiss xmm1, cs:__real@3f800000 }
    Dvar_SetBoolByName("MOQLSLTLKM", !v481);
    __asm
    {
      vmovss  xmm0, cs:timer
      vcomiss xmm0, cs:__real@3f800000
    }
    v485 = "Showing normal geo";
    if ( !(v486 | v481) )
      v485 = "Showing ColLod";
    Com_sprintf(dest, 0x100ui64, "Flicker Debug ColLod: %s", v485);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcy, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vmovss  [rsp+7200h+y], xmm1
    }
  }
  if ( physics_debugBadColLods->current.enabled )
  {
    Com_sprintf(dest, 0x100ui64, "Bad Detail models");
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightcz, 0);
    __asm
    {
      vaddss  xmm1, xmm7, [rsp+7200h+y]
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovaps xmm3, xmm8; tabWidth
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawDebugBadColLods(scrPlace, &x, &y, *(float *)&_XMM3, fmtcx);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  v496 = physics_debugMutableShapesInWorld->current.integer;
  v497 = v496 - 2;
  if ( (unsigned int)(v496 - 2) > 7 )
    v497 = PHYSICS_WORLD_ID_INVALID;
  if ( !g_physicsServerWorldsCreated && (unsigned int)v497 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    v497 = PHYSICS_WORLD_ID_INVALID;
  if ( (g_physicsClientWorldsCreated || (unsigned int)(v497 - 2) > 5) && v497 != PHYSICS_WORLD_ID_INVALID )
  {
    Com_sprintf(dest, 0x100ui64, "Mutable Shapes in World %s", s_Physics_DebugSectionNames[v496]);
    __asm
    {
      vmovss  xmm2, [rsp+7200h+y]; y
      vmovss  xmm1, [rsp+7200h+x]; x
      vmovss  [rsp+7200h+charHeight], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, dest, &colorWhite, 0, 1, charHeightda, 0);
    __asm { vaddss  xmm1, xmm7, [rsp+7200h+y] }
    _RAX = physics_debugMutableShapesInWorldRange;
    __asm
    {
      vaddss  xmm0, xmm8, [rsp+7200h+x]
      vmovss  [rsp+7200h+y], xmm1
      vmovss  [rsp+7200h+x], xmm0
      vmovss  xmm1, dword ptr [rax+28h]
      vmovss  [rsp+7200h+shadow], xmm1
      vmovaps xmm3, xmm8; tabWidth
      vmovss  dword ptr [rsp+7200h+fmt], xmm7
    }
    HavokPhysics_DrawDebugMutableShapesInWorld(scrPlace, &x, &y, *(float *)&_XMM3, fmtcy, v497, *(float *)&shadowo);
    __asm
    {
      vaddss  xmm1, xmm9, [rsp+7200h+x]
      vmovss  [rsp+7200h+x], xmm1
    }
  }
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysicsSVFX_DrawDebug(scrPlace, &x, &y, *(float *)&_XMM3, fmtcz);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysicsFX_Debug_Draw(scrPlace, &x, &y, *(float *)&_XMM3, fmtda);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysicsVolume_DrawDebug(scrPlace, &x, &y, *(float *)&_XMM3, fmtdb);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysPerfTrack_DebugDraw(scrPlace, &x, &y, *(float *)&_XMM3, fmtdc);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysPerfRaycast_DebugDraw(scrPlace, &x, &y, *(float *)&_XMM3, fmtdd);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  PhysicsVehicle_DebugDraw(scrPlace, &x, &y, *(float *)&_XMM3, fmtde);
  __asm
  {
    vmovaps xmm3, xmm8; tabWidth
    vmovss  dword ptr [rsp+7200h+fmt], xmm7
  }
  Ragdoll_DebugDraw(scrPlace, &x, &y, *(float *)&_XMM3, fmtdf);
  __asm { vcvttss2si eax, [rsp+7200h+y] }
  v514 = physics_debugDisplayOffsetY->current.integer;
  v515 = v514 - _EAX + 200;
  if ( v515 > 0 )
    v515 = 0;
  if ( v514 > v515 )
    v515 = physics_debugDisplayOffsetY->current.integer;
  if ( v514 != v515 )
    Dvar_SetInt_Internal(physics_debugDisplayOffsetY, v515);
  v516 = physics_debugDump;
  if ( physics_debugDump->current.enabled )
  {
    if ( s_physicsDumpFile.handle.handle != -1 )
    {
      FS_Write("<BR>", 4ui64, s_physicsDumpFile);
      FS_Write("</body>", 7ui64, s_physicsDumpFile);
      FS_Write("\n\r\n", 3ui64, s_physicsDumpFile);
      FS_Write("</html>", 7ui64, s_physicsDumpFile);
      FS_Write("\n\r\n", 3ui64, s_physicsDumpFile);
      FS_FCloseFile(s_physicsDumpFile);
      v516 = physics_debugDump;
    }
    Dvar_SetBool_Internal(v516, 0);
  }
  _R11 = &v778;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
Physics_DrawDebugString
==============
*/

void __fastcall Physics_DrawDebugString(const ScreenPlacement *scrPlace, double x, double y, const char *string, const vec4_t *setColor)
{
  bool v15; 
  char v21; 
  unsigned __int64 v28; 
  unsigned __int64 v29; 
  unsigned __int64 v38; 
  __int64 v43; 
  vec4_t *v44; 
  char _Buffer[128]; 
  char buffer[128]; 

  __asm { vmovaps [rsp+1C8h+var_28], xmm6 }
  _RBX = setColor;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps xmm6, xmm1
  }
  if ( (unsigned __int64)&v43 != _security_cookie )
    __asm { vcomiss xmm2, cs:__real@44870000 }
  v15 = !physics_debugDump->current.enabled;
  if ( physics_debugDump->current.enabled )
  {
    __asm
    {
      vmovaps [rsp+1C8h+var_38], xmm7
      vxorps  xmm0, xmm0, xmm0
      vmovaps [rsp+1C8h+var_48], xmm8
      vcvtsi2ss xmm0, xmm0, dword ptr [rax+28h]
      vaddss  xmm7, xmm0, cs:__real@41000000
      vcomiss xmm6, xmm7
      vmovaps [rsp+1C8h+var_68], xmm10
      vmovaps xmm10, xmm6
    }
    if ( !v15 )
    {
      __asm { vmovss  xmm8, cs:__real@c1400000 }
      do
      {
        Com_Printf(14, " ");
        __asm
        {
          vaddss  xmm6, xmm6, xmm8
          vcomiss xmm6, xmm7
        }
      }
      while ( !(v21 | v15) );
    }
    Com_Printf(14, (const char *)&queryFormat, string);
    Com_Printf(14, "\n");
    if ( s_physicsDumpFile.handle.handle != -1 )
    {
      __asm
      {
        vmovss  xmm6, dword ptr [rbx]
        vmovss  xmm0, cs:__real@3f800000
        vucomiss xmm6, xmm0
        vmovaps [rsp+1C8h+var_58], xmm9
      }
      if ( s_physicsDumpFile.handle.handle != -1 )
        goto LABEL_12;
      __asm { vucomiss xmm0, dword ptr [rbx+4] }
      if ( s_physicsDumpFile.handle.handle != -1 )
        goto LABEL_12;
      __asm { vucomiss xmm0, dword ptr [rbx+8] }
      if ( s_physicsDumpFile.handle.handle == -1 )
      {
        __asm
        {
          vmovss  xmm6, dword ptr cs:?colorBlack@@3Tvec4_t@@B; vec4_t const colorBlack
          vmovss  xmm8, dword ptr cs:?colorBlack@@3Tvec4_t@@B+4; vec4_t const colorBlack
          vmovss  xmm9, dword ptr cs:?colorBlack@@3Tvec4_t@@B+8; vec4_t const colorBlack
        }
      }
      else
      {
LABEL_12:
        __asm
        {
          vmovss  xmm8, dword ptr [rbx+4]
          vmovss  xmm9, dword ptr [rbx+8]
        }
      }
      __asm
      {
        vsubss  xmm0, xmm10, xmm7
        vcvttss2si r8d, xmm0
      }
      j_sprintf(_Buffer, "<p style = \"margin-bottom:0px;margin-top:0px;margin-left:%ipx\">", _R8);
      v28 = -1i64;
      v29 = -1i64;
      do
        ++v29;
      while ( _Buffer[v29] );
      FS_Write(_Buffer, v29, s_physicsDumpFile);
      __asm
      {
        vmovss  xmm2, cs:__real@437f0000
        vmulss  xmm0, xmm9, xmm2
        vcvttss2si eax, xmm0
        vmulss  xmm0, xmm6, xmm2
        vmulss  xmm1, xmm8, xmm2
        vcvttss2si r8d, xmm0
        vcvttss2si r9d, xmm1
      }
      LODWORD(v44) = _EAX;
      j_sprintf(buffer, "<font color=\"%02X%02X%02X\">", _R8, _R9, v44);
      __asm { vmovaps xmm9, [rsp+1C8h+var_58] }
      v38 = -1i64;
      do
        ++v38;
      while ( buffer[v38] );
      FS_Write(buffer, v38, s_physicsDumpFile);
      do
        ++v28;
      while ( string[v28] );
      FS_Write(string, v28, s_physicsDumpFile);
      FS_Write("\n\r\n", 3ui64, s_physicsDumpFile);
    }
    __asm
    {
      vmovaps xmm8, [rsp+1C8h+var_48]
      vmovaps xmm7, [rsp+1C8h+var_38]
      vmovaps xmm10, [rsp+1C8h+var_68]
    }
  }
  __asm { vmovaps xmm6, [rsp+1C8h+var_28] }
}

/*
==============
Physics_DrawDebugWorldCPU
==============
*/
void Physics_DrawDebugWorldCPU(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const char *WorldName; 
  float fmt; 
  int forceColor; 
  float v28; 
  float v29; 

  __asm { vmovaps [rsp+88h+var_38], xmm7 }
  _RSI = y;
  _RBX = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10471, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Draw Debug World CPU with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  WorldName = Physics_GetWorldName(worldId);
  __asm
  {
    vmovss  xmm7, [rsp+88h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rbx]; x
    vmovss  [rsp+88h+var_50], xmm7
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, WorldName, &colorWhite, 0, 1, v28, 0);
  __asm
  {
    vaddss  xmm2, xmm7, dword ptr [rsi]; y
    vmovss  dword ptr [rsi], xmm2
  }
  if ( g_physicsServerWorldsCreated || g_physicsClientWorldsCreated )
  {
    __asm
    {
      vmovaps [rsp+88h+var_28], xmm6
      vmovss  xmm6, [rsp+88h+tabWidth]
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  [rsp+88h+forceColor], xmm7
      vmovss  dword ptr [rbx], xmm0
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    HavokPhysics_DrawDebugWorldCPU(worldId, scrPlace, _RBX, _RSI, fmt, *(float *)&forceColor);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vsubss  xmm1, xmm0, xmm6
      vmovaps xmm6, [rsp+88h+var_28]
      vmovss  dword ptr [rbx], xmm1
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx]; x
      vmovss  [rsp+88h+var_50], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "Worlds not set up", &colorWhite, 0, 1, v29, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
  }
  __asm { vmovaps xmm7, [rsp+88h+var_38] }
}

/*
==============
Physics_DrawDebugWorldMemory
==============
*/
void Physics_DrawDebugWorldMemory(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const char *WorldName; 
  float fmt; 
  int forceColor; 
  float v28; 
  float v29; 

  __asm { vmovaps [rsp+88h+var_38], xmm7 }
  _RSI = y;
  _RBX = x;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10428, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Draw Debug World Memory with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  WorldName = Physics_GetWorldName(worldId);
  __asm
  {
    vmovss  xmm7, [rsp+88h+charHeight]
    vmovss  xmm2, dword ptr [rsi]; y
    vmovss  xmm1, dword ptr [rbx]; x
    vmovss  [rsp+88h+var_50], xmm7
  }
  Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, WorldName, &colorWhite, 0, 1, v28, 0);
  __asm
  {
    vaddss  xmm2, xmm7, dword ptr [rsi]; y
    vmovss  dword ptr [rsi], xmm2
  }
  if ( g_physicsServerWorldsCreated || g_physicsClientWorldsCreated )
  {
    __asm
    {
      vmovaps [rsp+88h+var_28], xmm6
      vmovss  xmm6, [rsp+88h+tabWidth]
      vaddss  xmm0, xmm6, dword ptr [rbx]
      vmovss  [rsp+88h+forceColor], xmm7
      vmovss  dword ptr [rbx], xmm0
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    HavokPhysics_DrawDebugWorldMemory(worldId, scrPlace, _RBX, _RSI, fmt, *(float *)&forceColor);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vsubss  xmm1, xmm0, xmm6
      vmovaps xmm6, [rsp+88h+var_28]
      vmovss  dword ptr [rbx], xmm1
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx]; x
      vmovss  [rsp+88h+var_50], xmm7
    }
    Physics_DrawDebugString(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, "Worlds not set up", &colorWhite, 0, 1, v29, 0);
    __asm
    {
      vaddss  xmm0, xmm7, dword ptr [rsi]
      vmovss  dword ptr [rsi], xmm0
    }
  }
  __asm { vmovaps xmm7, [rsp+88h+var_38] }
}

/*
==============
Physics_EnableDeactivationForBody
==============
*/
void Physics_EnableDeactivationForBody(Physics_WorldId worldId, unsigned int bodyId, bool enableDeactivation)
{
  __int64 v6; 
  Physics_WorldId v7; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7858, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to enable deactivation for a body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v7 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7859, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to enable deactivation for a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7860, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to enable deactivation for a body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v6) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_EnableDeactivationForBody(worldId, (hknpBodyId)bodyId, enableDeactivation);
}

/*
==============
Physics_EnableShapeInstance
==============
*/
void Physics_EnableShapeInstance(Physics_WorldId worldId, unsigned int bodyId, unsigned __int16 shapeInstanceId, bool enabled)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10218, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to EnableShapeInstance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10219, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to EnableShapeInstance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10220, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to EnableShapeInstance with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v8) )
      __debugbreak();
  }
  if ( shapeInstanceId == 0xFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10221, ASSERT_TYPE_ASSERT, "(Physics_IsShapeInstanceIdValid( shapeInstanceId ))", "%s\n\tPhysics: Trying to EnableShapeInstance with invalid ShapeInstanceId in world %i", "Physics_IsShapeInstanceIdValid( shapeInstanceId )", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_EnableShapeInstance(worldId, (hknpBodyId)bodyId, (hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant>)shapeInstanceId, enabled);
}

/*
==============
Physics_FlushMovedStatics
==============
*/
void Physics_FlushMovedStatics(Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_FlushMovedStatics");
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7787, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Flush Moved Statics when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7788, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Flush Moved Statics with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  Physics_LockWorld(worldId);
  HavokPhysics_FlushMovedStatics(worldId);
  Physics_UnlockWorld(worldId);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_FreeBroadphaseCollisionQueryResult
==============
*/
void Physics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8055, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to FreeBroadphaseCollisionQueryResult when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8056, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to FreeBroadphaseCollisionQueryResult for invalid result", "result") )
    __debugbreak();
  HavokPhysics_FreeBroadphaseCollisionQueryResult(result);
}

/*
==============
Physics_FreeCollisionQueryResult
==============
*/
void Physics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8108, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to FreeCollisionQueryResult when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8109, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to FreeCollisionQueryResult for invalid result", "result") )
    __debugbreak();
  HavokPhysics_FreeCollisionQueryResult(result);
}

/*
==============
Physics_FreeIgnoreBodies
==============
*/
void Physics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8133, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to FreeIgnoreBodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8134, ASSERT_TYPE_ASSERT, "(ignoreBodies)", "%s\n\tPhysics: Trying to FreeIgnoreBodies for invalid ignoreBodies", "ignoreBodies") )
    __debugbreak();
  HavokPhysics_FreeIgnoreBodies(ignoreBodies);
}

/*
==============
Physics_GetAssetByName
==============
*/
const PhysicsAsset *Physics_GetAssetByName(const char *name)
{
  __int64 v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5882, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Asset by name when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( name )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( name[v2] );
    if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5883, ASSERT_TYPE_ASSERT, "(!name || strlen( name ) != 0)", "%s\n\tPhysics: Trying to Get Asset by name with invalid name", "!name || strlen( name ) != 0") )
      __debugbreak();
  }
  return HavokPhysics_GetAssetByName(name);
}

/*
==============
Physics_GetBroadphaseNeedsRefresh
==============
*/
_BOOL8 Physics_GetBroadphaseNeedsRefresh(const Physics_WorldId worldId)
{
  __int64 v1; 

  v1 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  return g_physicsBroadphaseRefreshNeeded[v1];
}

/*
==============
Physics_GetBrushBasisFromUserData
==============
*/
__int64 Physics_GetBrushBasisFromUserData(unsigned __int64 userData)
{
  return BYTE6(userData) & 1;
}

/*
==============
Physics_GetClosestPoints
==============
*/
void Physics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v13; 
  __int64 v44; 
  float v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  hkVector4f v53; 
  hkQuaternionf v54; 

  __asm { vmovaps [rsp+0E8h+var_58], xmm6 }
  v13 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9782, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v13 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9783, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v13) )
    __debugbreak();
  if ( numBodies )
  {
    if ( !bodyIds )
    {
      LODWORD(v44) = v13;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9784, ASSERT_TYPE_ASSERT, "(numBodies == 0 || bodyIds)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with bad bodies %i", "numBodies == 0 || bodyIds", v44) )
        __debugbreak();
    }
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9785, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast against bodies with null shape", "shape") )
    __debugbreak();
  _RSI = point;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
  {
LABEL_51:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9786, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  _RDI = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0E8h+var_98], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
  {
LABEL_52:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9787, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9788, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9789, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9790, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9791, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire GetClosestPoints against bodies with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9792, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rsi]
    vmulss  xmm2, xmm6, dword ptr [rsi+4]
    vmulss  xmm1, xmm6, dword ptr [rsi+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmulss  xmm6, xmm6, [rsp+0E8h+maxDistance]
    vmovss  dword ptr [rsp+0E8h+var_88.m_quad], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmovss  dword ptr [rsp+0E8h+var_88.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+0E8h+var_78.m_vec.m_quad], xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+0E8h+var_88.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0E8h+var_88.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0E8h+var_78.m_vec.m_quad], xmm1
  }
  switch ( (int)v13 )
  {
    case 0:
      Profile_Begin(757);
      break;
    case 1:
      Profile_Begin(758);
      break;
    case 2:
    case 5:
      Profile_Begin(759);
      break;
    case 3:
    case 6:
      Profile_Begin(760);
      break;
    case 4:
    case 7:
      Profile_Begin(761);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9846, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm { vmovss  [rsp+0E8h+var_B8], xmm6 }
  HavokPhysics_GetClosestPoints((Physics_WorldId)v13, numBodies, bodyIds, shape, &v53, &v54, v45, extendedData, result);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+0E8h+var_58] }
}

/*
==============
Physics_GetClosestPoints
==============
*/
void Physics_GetClosestPoints(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v12; 
  float v42; 
  Physics_GetClosestPointsExtendedData *v43; 
  int v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  hkVector4f pointa; 
  hkQuaternionf v52; 

  __asm { vmovaps [rsp+0C8h+var_48], xmm6 }
  _RBP = point;
  v12 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9704, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v12 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9705, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v12) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v43) = v12;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9706, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v43) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9707, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast against body with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9708, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  _RDI = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
  {
LABEL_51:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9709, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9710, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9711, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9712, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9713, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire GetClosestPoints against body with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9714, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rbp+0]
    vmulss  xmm2, xmm6, dword ptr [rbp+4]
    vmulss  xmm1, xmm6, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmulss  xmm6, xmm6, [rsp+0C8h+maxDistance]
    vmovss  dword ptr [rsp+0C8h+point.m_quad], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmovss  dword ptr [rsp+0C8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+0C8h+var_68.m_vec.m_quad], xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+0C8h+point.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0C8h+point.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0C8h+var_68.m_vec.m_quad], xmm1
  }
  switch ( (int)v12 )
  {
    case 0:
      Profile_Begin(752);
      break;
    case 1:
      Profile_Begin(753);
      break;
    case 2:
    case 5:
      Profile_Begin(754);
      break;
    case 3:
    case 6:
      Profile_Begin(755);
      break;
    case 4:
    case 7:
      Profile_Begin(756);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9768, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm { vmovss  [rsp+0C8h+var_A0], xmm6 }
  HavokPhysics_GetClosestPoints((Physics_WorldId)v12, (hknpBodyId)bodyId, shape, &pointa, &v52, v42, extendedData, result);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+0C8h+var_48] }
}

/*
==============
Physics_GetClosestPoints
==============
*/
void Physics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const vec3_t *point, const vec4_t *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v11; 
  const dvar_t *v19; 
  float fmt; 
  int v42; 
  int v43; 
  int v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  hkVector4f pointa; 
  hkQuaternionf rotationa; 

  __asm { vmovaps [rsp+0C8h+var_48], xmm6 }
  _RSI = rotation;
  _R14 = point;
  v11 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9078, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire GetClosestPoints when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v11 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9079, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire GetClosestPoints with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9080, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
  {
LABEL_53:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9081, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+0Ch]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
  {
LABEL_54:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9082, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire GetClosestPoints with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9083, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire GetClosestPoints with invalid extended Data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9084, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire GetClosestPoints with invalid result", "result") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v11] )
  {
    v19 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    if ( v19->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9085, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  if ( g_physicsQueriesNotAllowedForWorld[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9086, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v11 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v11] )
    Physics_UpdateBroadphase((Physics_WorldId)v11, 1);
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [r14]
    vmulss  xmm2, xmm6, dword ptr [r14+4]
    vmulss  xmm1, xmm6, dword ptr [r14+8]
    vmovss  xmm5, dword ptr [rsi]
    vinsertps xmm5, xmm5, dword ptr [rsi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rsi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rsi+0Ch], 30h ; '0'
    vmulss  xmm6, xmm6, [rsp+0C8h+maxDistance]
    vmovss  dword ptr [rsp+0C8h+point.m_quad], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmovss  dword ptr [rsp+0C8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+0C8h+rotation.m_vec.m_quad], xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+0C8h+point.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0C8h+point.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0C8h+rotation.m_vec.m_quad], xmm1
  }
  switch ( (int)v11 )
  {
    case 0:
      Profile_Begin(722);
      break;
    case 1:
      Profile_Begin(723);
      break;
    case 2:
    case 5:
      Profile_Begin(724);
      break;
    case 3:
    case 6:
      Profile_Begin(725);
      break;
    case 4:
    case 7:
      Profile_Begin(726);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9146, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm { vmovss  dword ptr [rsp+0C8h+fmt], xmm6 }
  HavokPhysics_GetClosestPoints((Physics_WorldId)v11, shape, &pointa, &rotationa, fmt, extendedData, result);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+0C8h+var_48] }
}

/*
==============
Physics_GetConstraintBodyIds
==============
*/
void Physics_GetConstraintBodyIds(Physics_WorldId worldId, unsigned int constraintId, unsigned int *bodyIdA, unsigned int *bodyIdB)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6151, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Constraint Body Ids when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6152, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Constraint Body Ids with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId == 0x7FFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6153, ASSERT_TYPE_ASSERT, "(Physics_IsConstraintIdValid( constraintId ))", "%s\n\tPhysics: Trying to Get Constraint Body Ids with invalid Constraint in world %i", "Physics_IsConstraintIdValid( constraintId )", v8) )
      __debugbreak();
  }
  if ( !bodyIdA )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6154, ASSERT_TYPE_ASSERT, "(bodyIdA)", "%s\n\tPhysics: Trying to Get Constraint Body Ids with invalid BodyIDA in world %i", "bodyIdA", v8) )
      __debugbreak();
  }
  if ( !bodyIdB )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6155, ASSERT_TYPE_ASSERT, "(bodyIdB)", "%s\n\tPhysics: Trying to Get Constraint Body Ids with invalid BodyIDB in world %i", "bodyIdB", v8) )
      __debugbreak();
  }
  HavokPhysics_GetConstraintBodyIds(worldId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)constraintId, (hknpBodyId *)bodyIdA, (hknpBodyId *)bodyIdB);
}

/*
==============
Physics_GetContentsFromShapeList
==============
*/
int Physics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumContentsInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3958, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetContentsFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3959, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3873, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumContentsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3874, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumContentsInShapeList(shapeList) )
  {
    NumContentsInShapeList = Physics_GetNumContentsInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3960, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumContentsInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumContentsInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumContentsInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetContentsFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetDBThreadId
==============
*/
__int64 Physics_GetDBThreadId()
{
  return 7i64;
}

/*
==============
Physics_GetDebugMemorySize
==============
*/
unsigned __int64 Physics_GetDebugMemorySize()
{
  return physics_debugMemoryEnable->current.integer != 0 ? 0xC800000 : 0;
}

/*
==============
Physics_GetDecalTypeFromUserData
==============
*/
_BOOL8 Physics_GetDecalTypeFromUserData(unsigned __int64 userData)
{
  return (userData & 0x2000000000000i64) != 0;
}

/*
==============
Physics_GetDetailCollisionContents
==============
*/
int Physics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4371, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get detail collision contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4372, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tPhysics: Trying to get detail collision contents with invalid physics asset", "detailCollision") )
    __debugbreak();
  return HavokPhysics_GetDetailCollisionContents(detailCollision);
}

/*
==============
Physics_GetDetailCollisionShape
==============
*/
const hknpShape *Physics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4671, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get detail collision shape when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4672, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tPhysics: Trying to get detail collision shape with invalid detail collision", "detailCollision") )
    __debugbreak();
  return HavokPhysics_GetDetailCollisionShape(detailCollision, shapeIdx);
}

/*
==============
Physics_GetDetailCollisionShapeCount
==============
*/
int Physics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4437, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get detail collision shape count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4438, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tPhysics: Trying to get detail collision shape count with invalid detail collision", "detailCollision") )
    __debugbreak();
  return HavokPhysics_GetDetailCollisionShapeCount(detailCollision);
}

/*
==============
Physics_GetDetailCollisionShapeTag
==============
*/
unsigned __int16 Physics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4737, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get detail collision shapetag when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4738, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tPhysics: Trying to get detail collision shapetag with invalid detail collision", "detailCollision") )
    __debugbreak();
  return HavokPhysics_GetDetailCollisionShapeTag(detailCollision, shapeIdx);
}

/*
==============
Physics_GetDetailCollisionShapeTransform
==============
*/
void Physics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, vec3_t *shapePosition, vec4_t *shapeOrientationAsQuat)
{
  hkQuaternionf shapeOrientationAsQuata; 
  hkVector4f shapePositiona; 

  _RDI = shapeOrientationAsQuat;
  _RBX = shapePosition;
  HavokPhysics_GetDetailCollisionShapeTransform(detailCollision, shapeIdx, &shapePositiona, &shapeOrientationAsQuata);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rsp+68h+shapePosition.m_quad+4]
    vmulss  xmm1, xmm3, dword ptr [rsp+68h+shapePosition.m_quad]
    vmulss  xmm2, xmm3, dword ptr [rsp+68h+shapePosition.m_quad+8]
    vmovss  dword ptr [rbx+4], xmm0
    vmovaps xmm0, xmmword ptr [rsp+68h+shapeOrientationAsQuat.m_vec.m_quad]
    vmovss  dword ptr [rbx], xmm1
    vmovss  dword ptr [rbx+8], xmm2
    vmovups xmmword ptr [rdi], xmm0
  }
}

/*
==============
Physics_GetDetailHitData
==============
*/
const Physics_DetailHitData *Physics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8094, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetDetailHitData when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8095, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to GetDetailHitData for invalid result", "result") )
    __debugbreak();
  return HavokPhysics_GetDetailHitData(result, modifierIndex, hitIndex);
}

/*
==============
Physics_GetDontCollideWithClutterFromUserData
==============
*/
_BOOL8 Physics_GetDontCollideWithClutterFromUserData(unsigned __int64 userData)
{
  return (userData & 0x2000000000000000i64) != 0;
}

/*
==============
Physics_GetEntityNum
==============
*/
unsigned int Physics_GetEntityNum(int ref)
{
  int v1; 
  int v2; 
  int v3; 
  unsigned int result; 
  int v5; 
  ScriptableInstanceContext *InstanceCommonContext; 
  int v7; 
  ScriptableLinkType LinkType; 

  v1 = ref;
  v2 = (ref >> 25) & 0x1F;
  v3 = ref >> 16;
  LOWORD(result) = truncate_cast<unsigned short,int>((unsigned __int16)ref);
  switch ( v2 )
  {
    case 0:
      return 2046;
    case 1:
    case 7:
    case 11:
    case 12:
      return 2047;
    case 2:
    case 3:
    case 4:
    case 5:
    case 9:
      return (unsigned __int16)result;
    case 6:
      return Ragdoll_GetEntityNumber((unsigned __int8)v3 + 1);
    case 8:
      v5 = v1 & 0x3FFFFF;
      LOBYTE(v1) = (v1 >> 22) & 3;
      if ( !(_BYTE)v1 )
      {
        InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(v5);
        if ( InstanceCommonContext->linkedObjectType )
        {
          v7 = (unsigned __int8)InstanceCommonContext->linkedObjectType - 1;
          if ( InstanceCommonContext->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
            return ScriptableSv_GetInstanceCommonContext(v5)->linkedObjectIndex;
          goto LABEL_10;
        }
        return 2046;
      }
      v1 = (unsigned __int8)v1;
      LinkType = ScriptableCl_GetLinkType((const LocalClientNum_t)((unsigned __int8)v1 - 1), v5);
      if ( LinkType == SCRIPTABLE_LINK_NONE )
        return 2046;
      v7 = (unsigned __int8)LinkType - 1;
      if ( LinkType == SCRIPTABLE_LINK_ENTITY )
        return ScriptableCl_GetLinkObject((const LocalClientNum_t)(v1 - 1), v5);
LABEL_10:
      if ( v7 == 1 )
        return 2046;
      return 2047;
    case 10:
      return (unsigned __int16)result + 2117;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5182, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Physics_GetEntityNum unknown system") )
        __debugbreak();
      return 2047;
  }
}

/*
==============
Physics_GetErrorString
==============
*/

const char *__fastcall Physics_GetErrorString()
{
  return HavokPhysics_GetErrorString();
}

/*
==============
Physics_GetFilterSubGroupIdFromUserData
==============
*/
char Physics_GetFilterSubGroupIdFromUserData(unsigned __int64 userData)
{
  return truncate_cast<char,unsigned __int64>((userData >> 50) & 0x1F);
}

/*
==============
Physics_GetFilterSubGroupIdNoCollideIdFromUserData
==============
*/
char Physics_GetFilterSubGroupIdNoCollideIdFromUserData(unsigned __int64 userData)
{
  return truncate_cast<char,unsigned __int64>((userData >> 55) & 0x1F);
}

/*
==============
Physics_GetFixedMemoryPoolUsage
==============
*/
double Physics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  Physics_WorldId v3; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10350, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Fixed Memory Pool Usage when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10351, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Fixed Memory Pool Usage with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v3) )
      __debugbreak();
  }
  return HavokPhysics_GetFixedMemoryPoolUsage(worldId);
}

/*
==============
Physics_GetGlassIdFromUserData
==============
*/
__int64 Physics_GetGlassIdFromUserData(unsigned __int64 userData)
{
  return WORD2(userData);
}

/*
==============
Physics_GetHitTypeByEntId
==============
*/
__int64 Physics_GetHitTypeByEntId(const unsigned int entId)
{
  if ( entId == 2047 )
    return 0i64;
  if ( entId - 2117 <= 0x17F )
    return 6i64;
  if ( entId >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8209, ASSERT_TYPE_ASSERT, "(unsigned)( entId ) < (unsigned)( ( 2048 ) )", "entId doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entId, 2048) )
    __debugbreak();
  return 1i64;
}

/*
==============
Physics_GetInstanceAsset
==============
*/
const PhysicsAsset *Physics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5800, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Instance Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5801, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Instance Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5802, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Instance Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5803, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Instance Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5804, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Instance Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetInstanceAsset(worldId, instanceId);
}

/*
==============
Physics_GetInstanceDetailModel
==============
*/
const XModel *Physics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5816, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Instance detail Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5817, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Instance detail Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5818, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Instance detail Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5819, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Instance detail Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5820, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Instance detail Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetInstanceDetailModel(worldId, instanceId);
}

/*
==============
Physics_GetInstanceXModel
==============
*/
const XModel *Physics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5832, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Instance model Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5833, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5834, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Instance model Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5835, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5836, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Instance model Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetInstanceXModel(worldId, instanceId);
}

/*
==============
Physics_GetInstantiatiationPenetrationDepthForAsset
==============
*/
float Physics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const vec3_t *position, const vec4_t *orientationAsQuat, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  char v27; 
  __int64 v31; 
  __int64 v32; 
  int v33; 
  int v34; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  hkVector4f positiona; 
  hkQuaternionf orientation; 
  char v43; 

  __asm { vmovaps [rsp+0A8h+var_28], xmm6 }
  _RDI = orientationAsQuat;
  _RSI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5456, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get instantiation penetration depth for PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5457, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to get instantiation penetration depth for Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(v31) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5458, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get instantiation penetration depth for NULL Physics Asset in world %i", "physicsAsset", v31) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5459, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to get instantiation penetration depth for Physics Asset %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, worldId) )
    __debugbreak();
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5460, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to get instantiation penetration depth for Physics Asset %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v32) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v33 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v34 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v35 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5461, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to get instantiation penetration depth for PhysicsAsset with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
  {
LABEL_39:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5462, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to get instantiation penetration depth for PhysicsAsset with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5463, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tPhysics: Trying to get instantiation penetration depth for PhysicsAsset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0A8h+position.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vxorps  xmm6, xmm6, xmm6
    vmovups xmmword ptr [rsp+0A8h+orientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+0A8h+position.m_quad+4], xmm2
    vmovss  dword ptr [rsp+0A8h+position.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0A8h+position.m_quad+0Ch], xmm6
  }
  *(double *)&_XMM0 = HavokPhysics_GetInstantiatiationPenetrationDepthForAsset(worldId, physicsAsset, &positiona, &orientation, shapeOverride, ignoreSystems);
  __asm { vcomiss xmm0, xmm6 }
  if ( !v27 )
    __asm { vmulss  xmm0, xmm0, cs:__real@42000000 }
  _R11 = &v43;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return *(float *)&_XMM0;
}

/*
==============
Physics_GetIsClutterFromUserData
==============
*/
_BOOL8 Physics_GetIsClutterFromUserData(unsigned __int64 userData)
{
  return (userData & 0x1000000000000000i64) != 0;
}

/*
==============
Physics_GetLocalClientForWorld
==============
*/
__int64 Physics_GetLocalClientForWorld(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT0_DETAIL )
      return 0i64;
    if ( worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      return 1i64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid world") )
      __debugbreak();
  }
  return 0xFFFFFFFFi64;
}

/*
==============
Physics_GetMainThreadId
==============
*/
__int64 Physics_GetMainThreadId()
{
  return 0i64;
}

/*
==============
Physics_GetNoBroadphaseQueriesAllowed
==============
*/
_BOOL8 Physics_GetNoBroadphaseQueriesAllowed(Physics_WorldId worldId)
{
  __int64 v1; 

  v1 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8370, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  return g_physicsBroadphaseQueriesNotAllowedForWorld[v1];
}

/*
==============
Physics_GetNoQueriesAllowed
==============
*/
_BOOL8 Physics_GetNoQueriesAllowed(Physics_WorldId worldId)
{
  __int64 v1; 

  v1 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8387, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  return g_physicsQueriesNotAllowedForWorld[v1];
}

/*
==============
Physics_GetNumContentsInShapeList
==============
*/
int Physics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3873, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumContentsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3874, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumContentsInShapeList(shapeList);
}

/*
==============
Physics_GetNumConvexCountsInShapeList
==============
*/
int Physics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3929, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumConvexCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3930, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumConvexCountsInShapeList(shapeList);
}

/*
==============
Physics_GetNumServerRigidBodysInAsset
==============
*/
int Physics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4770, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset server body count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4771, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset server body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetNumServerRigidBodysInAsset(physicsAsset);
}

/*
==============
Physics_GetNumShapeNamesInShapeList
==============
*/
int Physics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3887, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumShapeNamesInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3888, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumShapeNamesInShapeList(shapeList);
}

/*
==============
Physics_GetNumShapesInShapeList
==============
*/
int Physics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3859, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumShapesInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3860, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumShapesInShapeList(shapeList);
}

/*
==============
Physics_GetNumTriCountsInShapeList
==============
*/
int Physics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3915, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumTriCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3916, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumTriCountsInShapeList(shapeList);
}

/*
==============
Physics_GetNumVertCountsInShapeList
==============
*/
int Physics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3901, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumVertCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3902, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  return HavokPhysics_GetNumVertCountsInShapeList(shapeList);
}

/*
==============
Physics_GetPhysicsAssetBodyBounds
==============
*/
void Physics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, vec3_t *min, vec3_t *max)
{
  hkAabb aabb; 
  hkTransformf transform; 

  _R14 = max;
  _RSI = min;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4601, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body bounds when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4602, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body bounds with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( (bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4603, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to get physics asset body bounds with invalid body index", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  *(_QWORD *)_RSI->v = 0i64;
  _RSI->v[2] = 0.0;
  *(_QWORD *)_R14->v = 0i64;
  _R14->v[2] = 0.0;
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rsp+0C8h+transform.m_rotation.baseclass_0.m_col0.m_quad], ymm0
    vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
    vmovups ymmword ptr [rsp+0C8h+transform.m_rotation.baseclass_0.m_col2.m_quad], ymm0
  }
  HavokPhysics_GetPhysicsAssetBodyBounds(physicsAsset, bodyIdx, &transform, &aabb);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+0C8h+aabb.m_min.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+0C8h+aabb.m_min.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+0C8h+aabb.m_min.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmulss  xmm1, xmm3, dword ptr [rsp+0C8h+aabb.m_max.m_quad]
    vmovss  dword ptr [rsi+4], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+0C8h+aabb.m_max.m_quad+4]
    vmovss  dword ptr [rsi+8], xmm2
    vmulss  xmm2, xmm3, dword ptr [rsp+0C8h+aabb.m_max.m_quad+8]
    vmovss  dword ptr [r14], xmm1
    vmovss  dword ptr [r14+4], xmm0
    vmovss  dword ptr [r14+8], xmm2
  }
}

/*
==============
Physics_GetPhysicsAssetBodyCount
==============
*/
int Physics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4404, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4405, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset);
}

/*
==============
Physics_GetPhysicsAssetBodyName
==============
*/
const char *Physics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4470, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body name when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4471, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body name with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( bodyIdx < 0 )
    goto LABEL_20;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4404, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4405, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( bodyIdx >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
LABEL_20:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4472, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to get physics asset body name with invalid body index", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )") )
      __debugbreak();
  }
  return HavokPhysics_GetPhysicsAssetBodyName(physicsAsset, bodyIdx);
}

/*
==============
Physics_GetPhysicsAssetBodyTransform
==============
*/
void Physics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, vec3_t *bodyPosition, vec4_t *bodyOrientationAsQuat)
{
  hkQuaternionf bodyOrientationAsQuata; 
  hkVector4f bodyPositiona; 

  _RDI = bodyOrientationAsQuat;
  _RBX = bodyPosition;
  HavokPhysics_GetPhysicsAssetBodyTransform(physicsAsset, bodyIdx, &bodyPositiona, &bodyOrientationAsQuata);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rsp+68h+bodyPosition.m_quad+4]
    vmulss  xmm1, xmm3, dword ptr [rsp+68h+bodyPosition.m_quad]
    vmulss  xmm2, xmm3, dword ptr [rsp+68h+bodyPosition.m_quad+8]
    vmovss  dword ptr [rbx+4], xmm0
    vmovaps xmm0, xmmword ptr [rsp+68h+bodyOrientationAsQuat.m_vec.m_quad]
    vmovss  dword ptr [rbx], xmm1
    vmovss  dword ptr [rbx+8], xmm2
    vmovups xmmword ptr [rdi], xmm0
  }
}

/*
==============
Physics_GetPhysicsAssetConstraintBodyIds
==============
*/
void Physics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4563, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset constraint body ids when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4564, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset constraint body ids with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( (constraintIdx < 0 || constraintIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4565, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to get physics asset constraint body ids with invalid constraint index", "constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  if ( !bodyId1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4566, ASSERT_TYPE_ASSERT, "(bodyId1)", "%s\n\tPhysics: Trying to get physics asset constraint body ids with invalid bodyId1", "bodyId1") )
    __debugbreak();
  if ( !bodyId2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4567, ASSERT_TYPE_ASSERT, "(bodyId2)", "%s\n\tPhysics: Trying to get physics asset constraint body ids with invalid bodyId2", "bodyId2") )
    __debugbreak();
  *bodyId1 = 0;
  *bodyId2 = 0;
  HavokPhysics_GetPhysicsAssetConstraintBodyIds(physicsAsset, constraintIdx, bodyId1, bodyId2);
}

/*
==============
Physics_GetPhysicsAssetConstraintCount
==============
*/
int Physics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4530, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset constraint count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4531, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset constraint count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetPhysicsAssetConstraintCount(physicsAsset);
}

/*
==============
Physics_GetPhysicsAssetContents
==============
*/
int Physics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4358, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4359, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset contents with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetPhysicsAssetContents(physicsAsset);
}

/*
==============
Physics_GetPhysicsAssetShape
==============
*/
const hknpShape *Physics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4644, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset shape when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4645, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset shape with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetPhysicsAssetShape(physicsAsset, bodyIdx);
}

/*
==============
Physics_GetPhysicsAssetShapeTag
==============
*/
unsigned __int16 Physics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4704, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset shapetag when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4705, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset shapetag with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_GetPhysicsAssetShapeTag(physicsAsset, bodyIdx);
}

/*
==============
Physics_GetRef
==============
*/
int Physics_GetRef(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5896, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Ref when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5897, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Ref with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5898, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Ref with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetRef(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_GetRefDetailFlag
==============
*/
bool Physics_GetRefDetailFlag(int ref)
{
  return (ref & 0xC0000000) != 0;
}

/*
==============
Physics_GetRefEntityType
==============
*/
__int64 Physics_GetRefEntityType(Physics_WorldId worldId, Physics_RefSystem refSystem, int ref)
{
  __int32 v4; 
  __int32 v5; 
  __int32 v6; 
  __int64 v8; 
  LocalClientNum_t LocalClientForWorld; 
  __int64 v10; 
  CgEntitySystem *v11; 
  centity_t *v12; 
  int EntityNum; 
  __int64 v14; 
  gentity_s *v15; 
  __int64 v16; 
  __int64 v17; 

  v4 = refSystem - 2;
  if ( !v4 || (v5 = v4 - 1) == 0 )
  {
LABEL_22:
    EntityNum = Physics_GetEntityNum(ref);
    v14 = EntityNum;
    if ( (unsigned int)EntityNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 188, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", EntityNum, 2048) )
      __debugbreak();
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 189, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v15 = &g_entities[v14];
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4941, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    return (unsigned __int16)v15->s.eType;
  }
  v6 = v5 - 1;
  if ( v6 )
  {
    if ( v6 != 5 )
      return 0i64;
    goto LABEL_22;
  }
  v8 = Physics_GetEntityNum(ref);
  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  v10 = LocalClientForWorld;
  if ( !(_BYTE)CgEntitySystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", LocalClientForWorld) )
    __debugbreak();
  if ( (unsigned int)v10 >= CgEntitySystem::ms_allocatedCount )
  {
    LODWORD(v17) = CgEntitySystem::ms_allocatedCount;
    LODWORD(v16) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v16, v17) )
      __debugbreak();
  }
  if ( !CgEntitySystem::ms_entitySystemArray[v10] )
  {
    LODWORD(v17) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v17) )
      __debugbreak();
  }
  v11 = CgEntitySystem::ms_entitySystemArray[v10];
  if ( (unsigned int)v8 >= 0x800 )
  {
    LODWORD(v17) = 2048;
    LODWORD(v16) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v16, v17) )
      __debugbreak();
  }
  v12 = &v11->m_entities[v8];
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4952, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  return v12->pose.eType;
}

/*
==============
Physics_GetRefId
==============
*/
unsigned __int16 Physics_GetRefId(int ref)
{
  return truncate_cast<unsigned short,int>((unsigned __int16)ref);
}

/*
==============
Physics_GetRefSubSystem
==============
*/
__int64 Physics_GetRefSubSystem(int ref)
{
  return BYTE2(ref);
}

/*
==============
Physics_GetRefSystem
==============
*/
__int64 Physics_GetRefSystem(int ref)
{
  return (ref >> 25) & 0x1F;
}

/*
==============
Physics_GetRelationshipSystem
==============
*/
__int64 Physics_GetRelationshipSystem(int ref)
{
  return (ref >> 24) & 1;
}

/*
==============
Physics_GetRendererThreadId
==============
*/
__int64 Physics_GetRendererThreadId()
{
  return 1i64;
}

/*
==============
Physics_GetRigidBodyAABB
==============
*/
void Physics_GetRigidBodyAABB(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax)
{
  __int64 v15; 
  Physics_WorldId v16; 
  hkAabb aabb; 

  _RSI = aabbMax;
  _RDI = aabbMin;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6252, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body aabb when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v16 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6253, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v16) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6254, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v15) )
      __debugbreak();
  }
  if ( _RDI == _RSI )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6255, ASSERT_TYPE_ASSERT, "(&aabbMin != &aabbMax)", "%s\n\tPhysics: Trying to Get Rigid Body aabb in world %i with aabbMin == aabbMax", "&aabbMin != &aabbMax", v15) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyAABB(worldId, (hknpBodyId)bodyId, &aabb, 1);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+8]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad]
    vmovss  dword ptr [rdi+4], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+4]
    vmovss  dword ptr [rdi+8], xmm2
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_GetRigidBodyAABB
==============
*/
void Physics_GetRigidBodyAABB(Physics_WorldId worldId, unsigned int bodyId, vec3_t *aabbMin, vec3_t *aabbMax, bool worldSpace)
{
  __int64 v16; 
  Physics_WorldId v17; 
  hkAabb aabb; 

  _RSI = aabbMax;
  _RDI = aabbMin;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6252, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body aabb when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v17 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6253, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v17) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6254, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body aabb with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v16) )
      __debugbreak();
  }
  if ( _RDI == _RSI )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6255, ASSERT_TYPE_ASSERT, "(&aabbMin != &aabbMax)", "%s\n\tPhysics: Trying to Get Rigid Body aabb in world %i with aabbMin == aabbMax", "&aabbMin != &aabbMax", v16) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyAABB(worldId, (hknpBodyId)bodyId, &aabb, worldSpace);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_min.m_quad+8]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm1, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad]
    vmovss  dword ptr [rdi+4], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+4]
    vmovss  dword ptr [rdi+8], xmm2
    vmulss  xmm2, xmm3, dword ptr [rsp+88h+aabb.m_max.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_GetRigidBodyCenterOfMass
==============
*/
void Physics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, unsigned int bodyId, vec3_t *centerOfMass)
{
  __int64 v10; 
  Physics_WorldId v11; 
  hkVector4f centerOfMassa; 

  _RSI = centerOfMass;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6213, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body CenterOfMass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v11 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6214, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body CenterOfMass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6215, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body CenterOfMass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v10) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyCenterOfMass(worldId, (hknpBodyId)bodyId, &centerOfMassa);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+68h+centerOfMass.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+68h+centerOfMass.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+68h+centerOfMass.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_GetRigidBodyCenterOfMassLocal
==============
*/
void Physics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, unsigned int bodyId, vec3_t *centerOfMassLocal)
{
  __int64 v10; 
  Physics_WorldId v11; 
  hkVector4f centerOfMassLocala; 

  _RSI = centerOfMassLocal;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6230, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Local Rigid Body CenterOfMass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v11 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6231, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Local CenterOfMass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6232, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Local CenterOfMass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v10) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyCenterOfMassLocal(worldId, (hknpBodyId)bodyId, &centerOfMassLocala);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm1, xmm3, dword ptr [rsp+68h+centerOfMassLocal.m_quad]
    vmulss  xmm0, xmm3, dword ptr [rsp+68h+centerOfMassLocal.m_quad+4]
    vmulss  xmm2, xmm3, dword ptr [rsp+68h+centerOfMassLocal.m_quad+8]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_GetRigidBodyContents
==============
*/
int Physics_GetRigidBodyContents(const Physics_WorldId worldId, const unsigned int bodyId)
{
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6515, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6516, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetRigidBodyContents(worldId, (const hknpBodyId)bodyId);
}

/*
==============
Physics_GetRigidBodyContents
==============
*/
int Physics_GetRigidBodyContents(const Physics_WorldId worldId, const unsigned int instanceId, const unsigned int bodyIdx)
{
  hknpBodyId v6; 
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6497, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6498, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6499, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get RigidBody contents with invalid instance %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  if ( bodyIdx >= Physics_GetNumRigidBodys(worldId, instanceId) )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6500, ASSERT_TYPE_ASSERT, "(bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId ))", "%s\n\tPhysics: Trying to Get RigidBody contents with invalid bodyIdx %i %i", "bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId )", v8, bodyIdx) )
      __debugbreak();
  }
  v6.m_serialAndIndex = Physics_GetRigidBodyID(worldId, instanceId, bodyIdx);
  if ( (v6.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6505, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6515, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6516, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
      __debugbreak();
  }
  return HavokPhysics_GetRigidBodyContents(worldId, v6);
}

/*
==============
Physics_GetRigidBodyDefaultMass
==============
*/
double Physics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  __int64 v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6183, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Default Mass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6184, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Default Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physAsset )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6185, ASSERT_TYPE_ASSERT, "(physAsset)", "%s\n\tPhysics: Trying to Get Rigid Body Default Mass in world %i with invalid physics asset", "physAsset", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetRigidBodyDefaultMass(worldId, physAsset);
}

/*
==============
Physics_GetRigidBodyDynamicMass
==============
*/
void Physics_GetRigidBodyDynamicMass(Physics_WorldId worldId, unsigned int bodyId, float *mass)
{
  __int64 v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6197, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Dynamic Mass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6198, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Dynamic Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6199, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Dynamic Mass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v6) )
      __debugbreak();
  }
  if ( !mass )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6200, ASSERT_TYPE_ASSERT, "(mass)", "%s\n\tPhysics: Trying to Get Rigid Body Dynamic Mass in world %i with invalid mass", "mass", v6) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyDynamicMass(worldId, (hknpBodyId)bodyId, mass);
}

/*
==============
Physics_GetRigidBodyInverseInertiaLocal
==============
*/
void Physics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, unsigned int bodyId, vec4_t *invInertia)
{
  __int64 v11; 
  Physics_WorldId v12; 
  hkVector4f invInertiaa; 

  _RSI = invInertia;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6309, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Inverse Inertia Matrix when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v12 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6310, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Inverse Inertia Matrix with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v12) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6311, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Body Inverse Inertia Matrix with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v11) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyInverseInertiaLocal(worldId, (hknpBodyId)bodyId, &invInertiaa);
  __asm
  {
    vmovss  xmm3, cs:__real@3a800000
    vmulss  xmm0, xmm3, dword ptr [rsp+68h+invInertia.m_quad+4]
    vmulss  xmm1, xmm3, dword ptr [rsp+68h+invInertia.m_quad]
    vmulss  xmm2, xmm3, dword ptr [rsp+68h+invInertia.m_quad+8]
    vmovss  dword ptr [rsi+4], xmm0
    vmovss  xmm0, dword ptr [rsp+68h+invInertia.m_quad+0Ch]
    vmovss  dword ptr [rsi+0Ch], xmm0
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rsi+8], xmm2
  }
}

/*
==============
Physics_GetRigidBodyMass
==============
*/
void Physics_GetRigidBodyMass(Physics_WorldId worldId, unsigned int bodyId, float *mass)
{
  __int64 v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6168, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Mass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6169, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid BodyMass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6170, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Mass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v6) )
      __debugbreak();
  }
  if ( !mass )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6171, ASSERT_TYPE_ASSERT, "(mass)", "%s\n\tPhysics: Trying to Get Rigid Body Mass in world %i with invalid mass", "mass", v6) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyMass(worldId, (hknpBodyId)bodyId, mass);
}

/*
==============
Physics_GetRigidBodyMaxAngSpeed
==============
*/
void Physics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxAngSpeed)
{
  __int64 v7; 
  float maxAngSpeeda; 

  _RDI = maxAngSpeed;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6096, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Max AngSpeed when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6097, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Max AngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6098, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Max AngSpeed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v7) )
      __debugbreak();
  }
  if ( !_RDI )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6099, ASSERT_TYPE_ASSERT, "(maxAngSpeed)", "%s\n\tPhysics: Trying to Get Rigid Body Max AngSpeed in world %i with invalid maxAngSpeed", "maxAngSpeed", v7) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyMaxAngSpeed(worldId, (hknpBodyId)bodyId, &maxAngSpeeda);
  __asm
  {
    vmovss  xmm0, [rsp+48h+maxAngSpeed]
    vmovss  dword ptr [rdi], xmm0
  }
}

/*
==============
Physics_GetRigidBodyMaxLinAngSpeed
==============
*/
void Physics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  __int64 v11; 
  float maxLinSpeeda; 
  float maxAngSpeeda; 

  _RDI = maxAngSpeed;
  _RSI = maxLinSpeed;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6114, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinAngSpeed when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6115, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinAngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6116, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Max LinAngSpeed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v11) )
      __debugbreak();
  }
  if ( !_RSI )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6117, ASSERT_TYPE_ASSERT, "(maxLinSpeed)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinAngSpeed in world %i with invalid maxLinSpeed", "maxLinSpeed", v11) )
      __debugbreak();
  }
  if ( !_RDI )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6118, ASSERT_TYPE_ASSERT, "(maxAngSpeed)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinAngSpeed in world %i with invalid maxAngSpeed", "maxAngSpeed", v11) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyMaxLinAngSpeed(worldId, (hknpBodyId)bodyId, &maxLinSpeeda, &maxAngSpeeda);
  __asm
  {
    vmovss  xmm0, [rsp+58h+maxLinSpeed]
    vmulss  xmm1, xmm0, cs:__real@42000000
    vmovss  xmm2, [rsp+58h+maxAngSpeed]
    vmovss  dword ptr [rsi], xmm1
    vmovss  dword ptr [rdi], xmm2
  }
}

/*
==============
Physics_GetRigidBodyMaxLinSpeed
==============
*/
void Physics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, unsigned int bodyId, float *maxLinSpeed)
{
  __int64 v8; 
  float maxLinSpeeda; 

  _RDI = maxLinSpeed;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6078, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6079, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6080, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v8) )
      __debugbreak();
  }
  if ( !_RDI )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6081, ASSERT_TYPE_ASSERT, "(maxLinSpeed)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed in world %i with invalid maxLinSpeed", "maxLinSpeed", v8) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyMaxLinSpeed(worldId, (hknpBodyId)bodyId, &maxLinSpeeda);
  __asm
  {
    vmovss  xmm0, [rsp+48h+maxLinSpeed]
    vmulss  xmm1, xmm0, cs:__real@42000000
    vmovss  dword ptr [rdi], xmm1
  }
}

/*
==============
Physics_GetRigidBodyName
==============
*/
const char *Physics_GetRigidBodyName(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6136, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Name when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6137, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Name with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6138, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Name with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  return HavokPhysics_GetRigidBodyName(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/
void Physics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyId, const vec3_t *instancePosition, const vec4_t *instanceOrientationAsQuat, vec3_t *bodyPosition, vec4_t *bodyOrientationAsQuat)
{
  hkQuaternionf *hkBodyOrientation; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  hkVector4f hkInstancePosition; 
  hkQuaternionf v44; 
  hkVector4f hkBodyPosition; 
  hkQuaternionf hkInstanceOrientation; 

  _RSI = instancePosition;
  _R12 = bodyPosition;
  _R15 = bodyOrientationAsQuat;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6762, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6763, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(hkBodyOrientation) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6764, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", hkBodyOrientation) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(hkBodyOrientation) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6765, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance with invalid body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", hkBodyOrientation) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_27;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6766, ASSERT_TYPE_ASSERT, "(!IS_NAN( instancePosition[0] ) && !IS_NAN( instancePosition[1] ) && !IS_NAN( instancePosition[2] ))", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance with invalid instance position", "!IS_NAN( instancePosition[0] ) && !IS_NAN( instancePosition[1] ) && !IS_NAN( instancePosition[2] )") )
      __debugbreak();
  }
  _RBX = instanceOrientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0C8h+var_88], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
  {
LABEL_28:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6767, ASSERT_TYPE_ASSERT, "(!IS_NAN( instanceOrientationAsQuat[0] ) && !IS_NAN( instanceOrientationAsQuat[1] ) && !IS_NAN( instanceOrientationAsQuat[2] ) && !IS_NAN( instanceOrientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Get RigidBody Transform after Warp Instance with invalid instance orientation", "!IS_NAN( instanceOrientationAsQuat[0] ) && !IS_NAN( instanceOrientationAsQuat[1] ) && !IS_NAN( instanceOrientationAsQuat[2] ) && !IS_NAN( instanceOrientationAsQuat[3] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0C8h+hkInstancePosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0C8h+hkInstancePosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+0C8h+hkInstanceOrientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+0C8h+hkInstancePosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0C8h+hkInstancePosition.m_quad+0Ch], xmm2
  }
  HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo(worldId, instanceId, (hknpBodyId)bodyId, &hkInstancePosition, &hkInstanceOrientation, &hkBodyPosition, &v44);
  __asm
  {
    vmovss  xmm3, cs:__real@42000000
    vmulss  xmm0, xmm3, dword ptr [rsp+0C8h+var_58.m_quad+4]
    vmulss  xmm1, xmm3, dword ptr [rsp+0C8h+var_58.m_quad]
    vmulss  xmm2, xmm3, dword ptr [rsp+0C8h+var_58.m_quad+8]
    vmovss  dword ptr [r12+4], xmm0
    vmovaps xmm0, xmmword ptr [rsp+0C8h+var_68.m_vec.m_quad]
    vmovss  dword ptr [r12], xmm1
    vmovss  dword ptr [r12+8], xmm2
    vmovups xmmword ptr [r15], xmm0
  }
}

/*
==============
Physics_GetSFXEventAsset
==============
*/

int __fastcall Physics_GetSFXEventAsset(Physics_WorldId worldId, unsigned int bodyId0, unsigned int bodyId1, PhysicsSFXEventAsset **asset)
{
  return HavokPhysics_GetSFXEventAsset(worldId, (hknpBodyId)bodyId0, (hknpBodyId)bodyId1, asset);
}

/*
==============
Physics_GetSaveGameSecondarySaveStateThreadId
==============
*/
__int64 Physics_GetSaveGameSecondarySaveStateThreadId()
{
  return 17i64;
}

/*
==============
Physics_GetServerThreadId
==============
*/
__int64 Physics_GetServerThreadId()
{
  return 5i64;
}

/*
==============
Physics_GetShape
==============
*/
hknpShape *Physics_GetShape(Physics_WorldId worldId, unsigned int bodyId)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9887, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShape when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  return HavokPhysics_GetShape(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_GetShapeConvexCountFromShapeList
==============
*/
int Physics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumConvexCountsInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4018, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeConvexCountFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4019, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3929, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumConvexCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3930, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumConvexCountsInShapeList(shapeList) )
  {
    NumConvexCountsInShapeList = Physics_GetNumConvexCountsInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4020, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumConvexCountsInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumConvexCountsInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumConvexCountsInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetShapeConvexCountFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetShapeFromShapeList
==============
*/
hknpShape *Physics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumShapesInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3943, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3944, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3859, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumShapesInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3860, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumShapesInShapeList(shapeList) )
  {
    NumShapesInShapeList = Physics_GetNumShapesInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3945, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumShapesInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumShapesInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumShapesInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetShapeFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetShapeNameFromShapeList
==============
*/
const char *Physics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumShapeNamesInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3973, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeNameFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3974, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3887, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumShapeNamesInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3888, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumShapeNamesInShapeList(shapeList) )
  {
    NumShapeNamesInShapeList = Physics_GetNumShapeNamesInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3975, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumShapeNamesInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumShapeNamesInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumShapeNamesInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetShapeNameFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetShapeOverrideContents
==============
*/
int Physics_GetShapeOverrideContents(int shapeOverride)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5193, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeOverrideContents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  return HavokPhysics_GetShapeOverrideContents(shapeOverride);
}

/*
==============
Physics_GetShapeTriCountFromShapeList
==============
*/
int Physics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumTriCountsInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4003, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeTriCountFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4004, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3915, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumTriCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3916, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumTriCountsInShapeList(shapeList) )
  {
    NumTriCountsInShapeList = Physics_GetNumTriCountsInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4005, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumTriCountsInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumTriCountsInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumTriCountsInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetShapeTriCountFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetShapeTypeName
==============
*/
const char *Physics_GetShapeTypeName(const hknpShape *shape)
{
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10276, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  return HavokPhysics_GetShapeTypeName(shape);
}

/*
==============
Physics_GetShapeUserData
==============
*/
unsigned __int64 Physics_GetShapeUserData(hknpShape *inShape)
{
  if ( !inShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4031, ASSERT_TYPE_ASSERT, "(inShape)", (const char *)&queryFormat, "inShape") )
    __debugbreak();
  return HavokPhysics_GetShapeUserData(inShape);
}

/*
==============
Physics_GetShapeVertCountFromShapeList
==============
*/
int Physics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  __int64 v5; 
  int NumVertCountsInShapeList; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3988, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetShapeVertCountFromShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3989, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3901, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to GetNumVertCountsInShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !shapeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3902, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  if ( shapeIdx >= HavokPhysics_GetNumVertCountsInShapeList(shapeList) )
  {
    NumVertCountsInShapeList = Physics_GetNumVertCountsInShapeList(shapeList);
    LODWORD(v5) = shapeIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3990, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( Physics_GetNumVertCountsInShapeList( shapeList ) )", "shapeIdx doesn't index Physics_GetNumVertCountsInShapeList( shapeList )\n\t%i not in [0, %i)", v5, NumVertCountsInShapeList) )
      __debugbreak();
  }
  return HavokPhysics_GetShapeVertCountFromShapeList(shapeList, shapeIdx);
}

/*
==============
Physics_GetSurfaceFlagsFromUserData
==============
*/
__int64 Physics_GetSurfaceFlagsFromUserData(unsigned __int64 userData)
{
  return (unsigned int)userData;
}

/*
==============
Physics_GetThreadId
==============
*/

unsigned int __fastcall Physics_GetThreadId()
{
  return HavokPhysics_GetThreadId();
}

/*
==============
Physics_GetVFXEventAsset
==============
*/

int __fastcall Physics_GetVFXEventAsset(Physics_WorldId worldId, unsigned int bodyId0, unsigned int bodyId1, PhysicsVFXEventAsset **asset)
{
  return HavokPhysics_GetVFXEventAsset(worldId, (hknpBodyId)bodyId0, (hknpBodyId)bodyId1, asset);
}

/*
==============
Physics_GetWireframeGeometry
==============
*/
void Physics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10290, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  if ( !pointArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10291, ASSERT_TYPE_ASSERT, "(pointArray)", (const char *)&queryFormat, "pointArray") )
    __debugbreak();
  if ( pointArraySize <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10292, ASSERT_TYPE_ASSERT, "(pointArraySize > 0)", (const char *)&queryFormat, "pointArraySize > 0") )
    __debugbreak();
  HavokPhysics_GetWireframeGeometry(shape, pointArray, pointArraySize, numLines);
}

/*
==============
Physics_GetWorkerThreadId
==============
*/
ThreadContext Physics_GetWorkerThreadId(unsigned int index)
{
  ThreadContext result; 
  unsigned int v2; 
  unsigned int v3; 
  int v4; 

  result = Sys_GetCurrentThreadContext();
  v2 = result;
  if ( (unsigned int)result >= THREAD_CONTEXT_COUNT )
  {
    v4 = 28;
    v3 = result;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1480, ASSERT_TYPE_ASSERT, "(unsigned)( threadId ) < (unsigned)( PHYSICS_MAX_SUPPORTED_NUM_THREADS )", "threadId doesn't index PHYSICS_MAX_SUPPORTED_NUM_THREADS\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
    return v2;
  }
  return result;
}

/*
==============
Physics_GetWorldName
==============
*/
const char *Physics_GetWorldName(Physics_WorldId worldId)
{
  __int64 v1; 

  v1 = worldId;
  if ( worldId == PHYSICS_WORLD_ID_INVALID )
    return "Invalid";
  if ( (unsigned int)worldId >= PHYSICS_WORLD_ID_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 753, ASSERT_TYPE_ASSERT, "(unsigned)( worldId ) < (unsigned)( ( sizeof( *array_counter( s_Physics_WorldNames ) ) + 0 ) )", "worldId doesn't index ARRAY_COUNT( s_Physics_WorldNames )\n\t%i not in [0, %i)", worldId, 8) )
    __debugbreak();
  return s_Physics_WorldNames[v1];
}

/*
==============
Physics_HasSFXEventAsset
==============
*/

bool __fastcall Physics_HasSFXEventAsset(Physics_WorldId worldId, unsigned int bodyId)
{
  return HavokPhysics_HasSFXEventAsset(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_HasVFXEventAsset
==============
*/

bool __fastcall Physics_HasVFXEventAsset(Physics_WorldId worldId, unsigned int bodyId)
{
  return HavokPhysics_HasVFXEventAsset(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_HavokTriggerVolumeEvent
==============
*/
void Physics_HavokTriggerVolumeEvent(const hknpEventHandlerInput *input, const hknpEvent *event)
{
  unsigned __int8 m_filterBits; 
  bool v5; 
  Physics_WorldId WorldId; 
  __int64 m_bodiesAreReversed; 
  Physics_WorldId v8; 
  unsigned int v9; 
  unsigned int v10; 

  m_filterBits = event[3].m_filterBits;
  v5 = m_filterBits == 0;
  if ( m_filterBits <= 1u )
  {
    WorldId = HavokPhysics_GetWorldId(input->m_world);
    m_bodiesAreReversed = input->m_bodiesAreReversed;
    v8 = WorldId;
    v9 = *((_DWORD *)&event[1].m_filterBits + m_bodiesAreReversed);
    v10 = *((_DWORD *)&event[1].m_filterBits + (unsigned int)(1 - m_bodiesAreReversed));
    if ( (v9 & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10320, ASSERT_TYPE_ASSERT, "( triggerId.isValid() )", (const char *)&queryFormat, "triggerId.isValid()") )
      __debugbreak();
    if ( (v10 & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10321, ASSERT_TYPE_ASSERT, "( triggeringId.isValid() )", (const char *)&queryFormat, "triggeringId.isValid()") )
      __debugbreak();
    PhysicsVolume_TriggerEvent(v8, v9, v10, v5);
  }
}

/*
==============
Physics_Init
==============
*/
void Physics_Init(void)
{
  unsigned int v0; 
  char *v1; 
  const dvar_t *v2; 
  int integer; 

  if ( g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1370, ASSERT_TYPE_ASSERT, "(!g_physicsInitialized)", "%s\n\tPhysics: Trying to initialize twice", "!g_physicsInitialized") )
    __debugbreak();
  *(_QWORD *)g_physicsBroadphaseQueriesNotAllowedForWorld = 0i64;
  *(_QWORD *)g_physicsQueriesNotAllowedForWorld = 0i64;
  *(_QWORD *)g_physicsBroadphaseRefreshNeeded = 0i64;
  Physics_SetupDvars();
  PhysicsCharacterProxy_Init();
  PhysicsCoverWall_Init();
  PMem_BeginAlloc(s_physicsPMemName, PMEM_STACK_GAME);
  if ( s_physicsGeneralMemoryBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1269, ASSERT_TYPE_ASSERT, "(s_physicsGeneralMemoryBuffer == nullptr)", (const char *)&queryFormat, "s_physicsGeneralMemoryBuffer == nullptr") )
    __debugbreak();
  s_physicsGeneralBufferSize = 88080384;
  if ( Mem_Paged_GetDevMemorySize() > 0x3200000 || Sys_GetXB3ConsoleType() == XB3_CONSOLE_SCORPIO )
  {
    v0 = s_physicsGeneralBufferSize + 52428800;
    s_physicsGeneralBufferSize += 52428800;
  }
  else
  {
    v0 = s_physicsGeneralBufferSize;
  }
  if ( physics_debugMemoryEnable->current.integer )
  {
    s_physicsGeneralBufferSize = v0 + 209715200;
    Com_Printf(20, "Physics: Enabling debug physics memory (%dMB).\n", 200i64);
  }
  else
  {
    Com_Printf(20, "Physics: Disabling debug physics memory.  Certain debug features, such as collision visualization, may not work.\n");
  }
  s_physicsGeneralMemoryBuffer = (char *)PMem_Alloc(s_physicsGeneralBufferSize, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "Physics");
  s_physicsWorldPersistentBufferSizeServerMain = (char *)PMem_Alloc(0x800000ui64, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "s_physicsWorldPersistentBufferSizeServerMain");
  v1 = (char *)PMem_Alloc(0x80000ui64, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "s_physicsWorldPersistentBufferSizeServerDetail");
  v2 = DCONST_DVARINT_physics_ExtraClientAuthFixedMemory;
  s_physicsWorldPersistentBufferSizeServerDetail = v1;
  if ( !DCONST_DVARINT_physics_ExtraClientAuthFixedMemory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraClientAuthFixedMemory") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  integer = v2->current.integer;
  s_physicsWorldPersistentBufferSizeClientPredictive = (char *)PMem_Alloc(0x700000ui64, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "s_physicsWorldPersistentBufferSizeClientPredictive");
  s_physicsWorldPersistentBufferSizeClientAuthoritative = (char *)PMem_Alloc(integer + 13631488, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "s_physicsWorldPersistentBufferSizeClientAuthoritative");
  s_physicsWorldPersistentBufferSizeClientDetail = (char *)PMem_Alloc(0x40000ui64, 8ui64, MEM_POOL_MAIN, PMEM_STACK_GAME, "s_physicsWorldPersistentBufferSizeClientDetail");
  G_PhysicsObject_Init();
  CG_PhysicsObject_Init();
  HavokPhysics_Init(s_physicsGeneralMemoryBuffer, s_physicsGeneralBufferSize, s_physicsGeneralBufferSize, NULL, 0);
  PhysicsQuery_Init();
  PhysicsFX_Init();
  PMem_EndAlloc(s_physicsPMemName, PMEM_STACK_GAME);
  g_physicsInitialized = 1;
}

/*
==============
Physics_InstantiateAsset
==============
*/
__int64 Physics_InstantiateAsset(Physics_WorldId worldId, const XModel *baseModel, const PhysicsAsset *physicsAsset, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v15; 
  unsigned int v34; 
  void (__fastcall *v35)(Physics_WorldId); 
  __int64 v37; 
  __int64 v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  int v45; 
  hkVector4f v47; 
  hkQuaternionf orientation; 

  v15 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5336, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v15 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5337, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v15) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(v37) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5338, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset in world %i", "physicsAsset", v37) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v15 - 2) <= 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5339, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, v15) )
    __debugbreak();
  if ( !g_physicsServerWorldsCreated && (unsigned int)v15 <= 1 )
  {
    LODWORD(v38) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5340, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v38) )
      __debugbreak();
  }
  _RSI = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
  {
LABEL_43:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5341, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
  {
LABEL_44:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5342, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5343, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  if ( forceType >= Physics_InstantiationForceType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5344, ASSERT_TYPE_ASSERT, "(IsIndexInRange( forceType, Physics_InstantiationForceType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset with invalid forceType", "IsIndexInRange( forceType, Physics_InstantiationForceType_Count )") )
    __debugbreak();
  if ( filterType >= Physics_InstantiationFilterType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5345, ASSERT_TYPE_ASSERT, "(IsIndexInRange( filterType, Physics_InstantiationFilterType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset with invalid filterType", "IsIndexInRange( filterType, Physics_InstantiationFilterType_Count )") )
    __debugbreak();
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+0Ch], xmm2
    vmovups xmmword ptr [rsp+0F8h+var_68.m_vec.m_quad], xmm0
  }
  v34 = HavokPhysics_InstantiateAsset((Physics_WorldId)v15, baseModel, physicsAsset, ref, &v47, &orientation, add, forceAddImmediate, tryStartDeactivated, shapeOverride, forceType, filterType, forQueryOnly);
  v35 = s_physicsWorldBodyListChangedFns[v15];
  if ( v35 )
    v35((Physics_WorldId)v15);
  return v34;
}

/*
==============
Physics_InstantiateAssetBody
==============
*/
_BOOL8 Physics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v16; 
  bool v45; 
  void (__fastcall *v46)(Physics_WorldId); 
  hkQuaternionf *orientation; 
  __int64 v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  hkVector4f v57; 
  hkQuaternionf v58; 

  v16 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5501, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5502, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", v16) )
    __debugbreak();
  if ( (unsigned int)v16 > 7 )
  {
    LODWORD(orientation) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5503, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", orientation) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(orientation) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5504, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body in world %i", "physicsAsset", orientation) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(orientation) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5505, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body with invalid body Idx %i %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", orientation, bodyIdx) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v16 - 2) <= 5 )
  {
    LODWORD(v49) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5506, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, v49) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v16 <= 1 )
  {
    LODWORD(v49) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5507, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v49) )
      __debugbreak();
  }
  _RBP = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_47;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_47;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
  {
LABEL_47:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5508, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
    goto LABEL_48;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
    goto LABEL_48;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_48;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0F8h+var_88], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
  {
LABEL_48:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5509, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  if ( forceType >= Physics_InstantiationForceType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5510, ASSERT_TYPE_ASSERT, "(IsIndexInRange( forceType, Physics_InstantiationForceType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body with invalid forceType", "IsIndexInRange( forceType, Physics_InstantiationForceType_Count )") )
    __debugbreak();
  if ( filterType >= Physics_InstantiationFilterType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5511, ASSERT_TYPE_ASSERT, "(IsIndexInRange( filterType, Physics_InstantiationFilterType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body with invalid filterType", "IsIndexInRange( filterType, Physics_InstantiationFilterType_Count )") )
    __debugbreak();
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  Physics_LockWorld((Physics_WorldId)v16);
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rbp+0]
    vmulss  xmm2, xmm3, dword ptr [rbp+4]
    vmulss  xmm1, xmm3, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad], xmm0
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0F8h+var_68.m_vec.m_quad], xmm1
  }
  v45 = HavokPhysics_InstantiateAssetBody(instanceId, (Physics_WorldId)v16, physicsAsset, bodyIdx, ref, &v57, &v58, add, tryStartDeactivated, neverDeactivate, shapeOverride, forceType, filterType, forQueryOnly);
  Physics_UnlockWorld((Physics_WorldId)v16);
  v46 = s_physicsWorldBodyListChangedFns[v16];
  if ( v46 )
    v46((Physics_WorldId)v16);
  return v45;
}

/*
==============
Physics_InstantiateAssetBodyCylinder
==============
*/
_BOOL8 Physics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v22; 
  bool v33; 
  bool v34; 
  bool v38; 
  bool v60; 
  void (__fastcall *v61)(Physics_WorldId); 
  _BOOL8 result; 
  hkQuaternionf *orientation; 
  hkQuaternionf *orientationa; 
  hkQuaternionf *orientationb; 
  __int64 v71; 
  float v72; 
  float v73; 
  int v74; 
  int v75; 
  int v76; 
  int v77; 
  int v78; 
  int v79; 
  int v80; 
  hkVector4f v81; 
  hkQuaternionf v82; 
  char v83; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
  }
  v22 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5621, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5622, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body cylinder with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", v22) )
    __debugbreak();
  if ( (unsigned int)v22 > 7 )
  {
    LODWORD(orientation) = v22;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5623, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body cylinder with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", orientation) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(orientation) = v22;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5624, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body cylinder in world %i", "physicsAsset", orientation) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(orientation) = v22;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5625, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body cylinder with invalid body Idx %i %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", orientation, bodyIdx) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v22 - 2) <= 5 )
  {
    LODWORD(v71) = v22;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5626, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body cylinder %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, v71) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v22 <= 1 )
  {
    LODWORD(v71) = v22;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5627, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body cylinder %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v71) )
      __debugbreak();
  }
  _RBP = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v74 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v75 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
  {
LABEL_53:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5628, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v77 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v78 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  if ( (v79 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+148h+var_C8], xmm0
  }
  v33 = (v80 & 0x7F800000u) <= 0x7F800000;
  if ( (v80 & 0x7F800000) == 2139095040 )
  {
LABEL_54:
    v34 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5629, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )");
    v33 = !v34;
    if ( v34 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm9, [rsp+148h+radius]
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm9, xmm7
  }
  if ( v33 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm9, xmm9
      vmovsd  [rsp+148h+orientation], xmm0
    }
    v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5630, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid radius %.2f", "radius > 0.f", *(double *)&orientationa);
    v33 = !v38;
    if ( v38 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm8, [rsp+148h+height]
    vcomiss xmm8, xmm7
  }
  if ( v33 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+148h+orientation], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5631, ASSERT_TYPE_ASSERT, "(height > 0.f)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid height %.2f", "height > 0.f", *(double *)&orientationb) )
      __debugbreak();
  }
  if ( forceType >= Physics_InstantiationForceType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5632, ASSERT_TYPE_ASSERT, "(IsIndexInRange( forceType, Physics_InstantiationForceType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid forceType", "IsIndexInRange( forceType, Physics_InstantiationForceType_Count )") )
    __debugbreak();
  if ( filterType >= Physics_InstantiationFilterType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5633, ASSERT_TYPE_ASSERT, "(IsIndexInRange( filterType, Physics_InstantiationFilterType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body cylinder with invalid filterType", "IsIndexInRange( filterType, Physics_InstantiationFilterType_Count )") )
    __debugbreak();
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  Physics_LockWorld((Physics_WorldId)v22);
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rbp+0]
    vmulss  xmm2, xmm6, dword ptr [rbp+4]
    vmulss  xmm1, xmm6, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+148h+var_B8.m_quad], xmm0
    vmovss  dword ptr [rsp+148h+var_B8.m_quad+4], xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+148h+var_B8.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmulss  xmm0, xmm8, xmm6
    vmovss  [rsp+148h+var_F0], xmm0
    vmulss  xmm2, xmm9, xmm6
    vmovss  [rsp+148h+var_F8], xmm2
    vmovss  dword ptr [rsp+148h+var_B8.m_quad+0Ch], xmm7
    vmovups xmmword ptr [rsp+148h+var_A8.m_vec.m_quad], xmm1
  }
  v60 = HavokPhysics_InstantiateAssetBodyCylinder(instanceId, (Physics_WorldId)v22, physicsAsset, bodyIdx, ref, &v81, &v82, add, tryStartDeactivated, neverDeactivate, v72, v73, forceType, filterType, forQueryOnly);
  v61 = s_physicsWorldBodyListChangedFns[v22];
  if ( v61 )
    v61((Physics_WorldId)v22);
  Physics_UnlockWorld((Physics_WorldId)v22);
  result = v60;
  _R11 = &v83;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
  }
  return result;
}

/*
==============
Physics_InstantiateAssetBodySphere
==============
*/
_BOOL8 Physics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v20; 
  bool v31; 
  bool v32; 
  bool v54; 
  void (__fastcall *v55)(Physics_WorldId); 
  _BOOL8 result; 
  hkQuaternionf *orientation; 
  hkQuaternionf *orientationa; 
  __int64 v63; 
  float v64; 
  int v65; 
  int v66; 
  int v67; 
  int v68; 
  int v69; 
  int v70; 
  int v71; 
  hkVector4f v72; 
  hkQuaternionf v73; 
  char v74; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
  }
  v20 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5560, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5561, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body sphere with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", v20) )
    __debugbreak();
  if ( (unsigned int)v20 > 7 )
  {
    LODWORD(orientation) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5562, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body sphere with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", orientation) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(orientation) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5563, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body sphere in world %i", "physicsAsset", orientation) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(orientation) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5564, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset body sphere with invalid body Idx %i %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", orientation, bodyIdx) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v20 - 2) <= 5 )
  {
    LODWORD(v63) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5565, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body sphere %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, v63) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v20 <= 1 )
  {
    LODWORD(v63) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5566, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset body sphere %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v63) )
      __debugbreak();
  }
  _RBP = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v65 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v66 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v67 & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5567, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v68 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v69 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  if ( (v70 & 0x7F800000) == 2139095040 )
    goto LABEL_51;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+128h+var_B8], xmm0
  }
  v31 = (v71 & 0x7F800000u) <= 0x7F800000;
  if ( (v71 & 0x7F800000) == 2139095040 )
  {
LABEL_51:
    v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5568, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )");
    v31 = !v32;
    if ( v32 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm7, [rsp+128h+radius]
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm7, xmm8
  }
  if ( v31 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm7, xmm7
      vmovsd  [rsp+128h+orientation], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5569, ASSERT_TYPE_ASSERT, "(radius > 0.f)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere with invalid radius %.2f", "radius > 0.f", *(double *)&orientationa) )
      __debugbreak();
  }
  if ( forceType >= Physics_InstantiationForceType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5570, ASSERT_TYPE_ASSERT, "(IsIndexInRange( forceType, Physics_InstantiationForceType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere with invalid forceType", "IsIndexInRange( forceType, Physics_InstantiationForceType_Count )") )
    __debugbreak();
  if ( filterType >= Physics_InstantiationFilterType_Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5571, ASSERT_TYPE_ASSERT, "(IsIndexInRange( filterType, Physics_InstantiationFilterType_Count ))", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset body sphere with invalid filterType", "IsIndexInRange( filterType, Physics_InstantiationFilterType_Count )") )
    __debugbreak();
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  Physics_LockWorld((Physics_WorldId)v20);
  __asm
  {
    vmovss  xmm6, cs:__real@3d000000
    vmulss  xmm0, xmm6, dword ptr [rbp+0]
    vmulss  xmm2, xmm6, dword ptr [rbp+4]
    vmulss  xmm1, xmm6, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+128h+var_A8.m_quad], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+128h+var_A8.m_quad+4], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+128h+var_A8.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulss  xmm0, xmm7, xmm6
    vmovss  [rsp+128h+var_D8], xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovss  dword ptr [rsp+128h+var_A8.m_quad+0Ch], xmm8
    vmovups xmmword ptr [rsp+128h+var_98.m_vec.m_quad], xmm1
  }
  v54 = HavokPhysics_InstantiateAssetBodySphere(instanceId, (Physics_WorldId)v20, physicsAsset, bodyIdx, ref, &v72, &v73, add, tryStartDeactivated, neverDeactivate, v64, forceType, filterType, forQueryOnly);
  v55 = s_physicsWorldBodyListChangedFns[v20];
  if ( v55 )
    v55((Physics_WorldId)v20);
  Physics_UnlockWorld((Physics_WorldId)v20);
  result = v54;
  _R11 = &v74;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
  }
  return result;
}

/*
==============
Physics_InstantiateAssetConstraint
==============
*/
bool Physics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  __int64 v11; 
  __int64 v12; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5684, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate PhysicsAsset constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5685, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Instantiate Physics Asset constraint with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5686, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5687, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset constraint in world %i", "physicsAsset", v11) )
      __debugbreak();
  }
  if ( constraintIdx < 0 )
    goto LABEL_21;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4530, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset constraint count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4531, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset constraint count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( constraintIdx >= HavokPhysics_GetPhysicsAssetConstraintCount(physicsAsset) )
  {
LABEL_21:
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5688, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset ))", "%s\n\tPhysics: Trying to Instantiate NULL Physics Asset constraint with invalid constraint Idx %i %i", "constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset )", v11, constraintIdx) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5689, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset constraint %s in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", physicsAsset->name, v12) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5690, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Physics Asset constraint %s in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", physicsAsset->name, v12) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  return HavokPhysics_InstantiateAssetConstraint(instanceId, worldId, physicsAsset, constraintIdx, instanceRef, deepCloneConstraintData);
}

/*
==============
Physics_InstantiateDetailModel
==============
*/
__int64 Physics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  __int64 v11; 
  unsigned int v30; 
  void (__fastcall *v31)(Physics_WorldId); 
  __int64 v33; 
  int v34; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  hkVector4f positiona; 
  hkQuaternionf orientation; 

  _RSI = position;
  v11 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5388, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate Detail Model when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v11 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5389, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Detail Model with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
    __debugbreak();
  if ( !detailModel )
  {
    LODWORD(v33) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5390, ASSERT_TYPE_ASSERT, "(detailModel)", "%s\n\tPhysics: Trying to Instantiate NULL Detail Model in world %i", "detailModel", v33) )
      __debugbreak();
  }
  if ( !detailModel->detailCollision )
  {
    LODWORD(v33) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5391, ASSERT_TYPE_ASSERT, "(detailModel->detailCollision)", "%s\n\tPhysics: Trying to Instantiate Detail Model with no detail physics date in world %i", "detailModel->detailCollision", v33) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v11 - 2) <= 5 )
  {
    LODWORD(v33) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5392, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Detail Model in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v33) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v11 <= 1 )
  {
    LODWORD(v33) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5393, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Detail Model in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v33) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v34 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v35 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
  {
LABEL_37:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5394, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate Detail Model with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0B8h+var_68], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5395, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate Detail Model with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  Physics_LockWorld((Physics_WorldId)v11);
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0B8h+position.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0B8h+position.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0B8h+position.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0B8h+position.m_quad+0Ch], xmm2
    vmovups xmmword ptr [rsp+0B8h+orientation.m_vec.m_quad], xmm0
  }
  v30 = HavokPhysics_InstantiateDetailModel((Physics_WorldId)v11, detailModel, ref, &positiona, &orientation, add, tryStartDeactivated, forQueryOnly, allowSingleBodyAddToWorld);
  v31 = s_physicsWorldBodyListChangedFns[v11];
  if ( v31 )
    v31((Physics_WorldId)v11);
  Physics_UnlockWorld((Physics_WorldId)v11);
  return v30;
}

/*
==============
Physics_InstantiateHingeConstraint
==============
*/
bool Physics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, const vec3_t *position, const vec3_t *direction, float friction, float angleMin, float angleMax, float breakingThreshold, unsigned int *outConstraintId)
{
  float v27; 
  __int64 minAngle; 
  float minAnglea; 
  float v30; 
  float v31; 
  hkVector4f dir; 
  hkVector4f pos; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5718, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate Hinge constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5719, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Instantiate Hinge constraint with invalid instance id %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(minAngle) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5720, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Hinge constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", minAngle) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(minAngle) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5721, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Hinge constraint in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", minAngle) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(minAngle) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5722, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Hinge constraint in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", minAngle) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm1, xmm4, dword ptr [rsi+8]
    vmulss  xmm0, xmm4, dword ptr [rsi]
    vmulss  xmm2, xmm4, dword ptr [rsi+4]
    vmovss  dword ptr [rsp+0A8h+pos.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rax]
    vmovss  dword ptr [rsp+0A8h+pos.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rax+4]
    vmovss  dword ptr [rsp+0A8h+dir.m_quad], xmm1
    vmovss  xmm1, [rsp+0A8h+breakingThreshold]
    vmovss  [rsp+0A8h+var_68], xmm1
    vmovss  xmm1, [rsp+0A8h+angleMin]
    vmovss  dword ptr [rsp+0A8h+pos.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rax+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+dir.m_quad+4], xmm0
    vmovss  xmm0, [rsp+0A8h+angleMax]
    vmovss  [rsp+0A8h+var_70], xmm0
    vmovss  [rsp+0A8h+minAngle], xmm1
    vmovss  dword ptr [rsp+0A8h+dir.m_quad+8], xmm2
    vmulss  xmm2, xmm4, [rsp+0A8h+friction]
    vmovss  [rsp+0A8h+var_80], xmm2
    vmovss  dword ptr [rsp+0A8h+pos.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+dir.m_quad+0Ch], xmm3
  }
  return HavokPhysics_InstantiateHingeConstraint(worldId, instanceId, bodyIdx, &pos, &dir, v27, minAnglea, v30, v31, outConstraintId);
}

/*
==============
Physics_InstantiateKeyframedBody
==============
*/
__int64 Physics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int contents, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v14; 
  unsigned int v33; 
  void (__fastcall *v34)(Physics_WorldId); 
  hkVector4f *v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  hkVector4f v44; 
  hkQuaternionf orientation; 

  v14 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5235, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v14 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5236, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v14) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5237, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body with null shape in world %i", "shape", v36) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5238, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tPhysics: Trying to Instantiate Keyframed Body with null name in world %i", (const char *)&stru_143C9A1A4, v36) )
      __debugbreak();
  }
  if ( !physicsMaterial )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5239, ASSERT_TYPE_ASSERT, "(physicsMaterial)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body with null physics material in world %i", "physicsMaterial", v36) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v14 - 2) <= 5 )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5240, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v36) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v14 <= 1 )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5241, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Keyframed Body in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v36) )
      __debugbreak();
  }
  _RSI = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
  {
LABEL_40:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5242, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate Keyframed Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
  {
LABEL_41:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5243, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate Keyframed Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+0Ch], xmm2
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm0
  }
  v33 = HavokPhysics_InstantiateKeyframedBody((Physics_WorldId)v14, shape, ref, name, physicsMaterial, contents, &v44, &orientation, add, tryStartDeactivated, forQueryOnly);
  v34 = s_physicsWorldBodyListChangedFns[v14];
  if ( v34 )
    v34((Physics_WorldId)v14);
  return v33;
}

/*
==============
Physics_InstantiateStaticBody
==============
*/
__int64 Physics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int contents, const vec3_t *position, const vec4_t *orientationAsQuat, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v14; 
  unsigned int v33; 
  void (__fastcall *v34)(Physics_WorldId); 
  hkVector4f *v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  hkVector4f v44; 
  hkQuaternionf orientation; 

  v14 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5286, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Instantiate Static Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v14 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5287, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Instantiate Static Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v14) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5288, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to Instantiate Static Body with null shape in world %i", "shape", v36) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5289, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tPhysics: Trying to Instantiate Static Body with null name in world %i", (const char *)&stru_143C9A1A4, v36) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v14 - 2) <= 5 )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5290, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Instantiate Static Body in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v36) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v14 <= 1 )
  {
    LODWORD(v36) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5291, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Instantiate Static Body in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v36) )
      __debugbreak();
  }
  _RSI = position;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
  {
LABEL_37:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5292, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Instantiate Static Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  _RDI = orientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0D8h+var_78], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5293, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Instantiate Static Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+8], xmm1
    vmovss  dword ptr [rsp+0D8h+var_68.m_quad+0Ch], xmm2
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm0
  }
  v33 = HavokPhysics_InstantiateStaticBody((Physics_WorldId)v14, shape, ref, name, physicsMaterial, contents, &v44, &orientation, add, tryStartDeactivated, forQueryOnly);
  v34 = s_physicsWorldBodyListChangedFns[v14];
  if ( v34 )
    v34((Physics_WorldId)v14);
  return v33;
}

/*
==============
Physics_InverseInertiaFromLocalToWorld
==============
*/
void Physics_InverseInertiaFromLocalToWorld(const vec3_t *invInertiaLocal, const tmat33_t<vec3_t> *rotation, tmat33_t<vec3_t> *invInertiaWs)
{
  tmat33_t<vec3_t> in1; 
  tmat33_t<vec3_t> out; 

  __asm
  {
    vmovss  xmm2, dword ptr [rcx]
    vmovss  xmm3, dword ptr [rcx+4]
    vmovss  xmm4, dword ptr [rcx+8]
    vmulss  xmm0, xmm2, dword ptr [rdx]
    vmulss  xmm1, xmm2, dword ptr [rdx+4]
    vmovss  dword ptr [rsp+88h+in1], xmm0
    vmulss  xmm0, xmm2, dword ptr [rdx+8]
    vmovss  dword ptr [rsp+88h+in1+8], xmm0
    vmulss  xmm0, xmm3, dword ptr [rdx+10h]
    vmovss  dword ptr [rsp+88h+in1+4], xmm1
    vmulss  xmm1, xmm3, dword ptr [rdx+0Ch]
    vmovss  dword ptr [rsp+88h+in1+10h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rdx+18h]
    vmovss  dword ptr [rsp+88h+in1+0Ch], xmm1
    vmulss  xmm1, xmm3, dword ptr [rdx+14h]
    vmovss  dword ptr [rsp+88h+in1+18h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rdx+20h]
    vmovss  dword ptr [rsp+88h+in1+14h], xmm1
    vmulss  xmm1, xmm4, dword ptr [rdx+1Ch]
    vmovss  dword ptr [rsp+88h+in1+20h], xmm0
    vmovss  dword ptr [rsp+88h+in1+1Ch], xmm1
  }
  MatrixTranspose(rotation, &out);
  MatrixMultiply(&in1, &out, invInertiaWs);
}

/*
==============
Physics_IsAssetBodyAnimationDriven
==============
*/
bool Physics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4813, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body animation driven state when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4814, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body animation driven state with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( bodyIdx < 0 )
    goto LABEL_20;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4404, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to get physics asset body count when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4405, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( bodyIdx >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
LABEL_20:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4815, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tPhysics: Trying to get physics asset body animation driven state with invalid body index", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )") )
      __debugbreak();
  }
  return HavokPhysics_IsAssetBodyAnimationDriven(physicsAsset, bodyIdx);
}

/*
==============
Physics_IsAssetRagdoll
==============
*/
bool Physics_IsAssetRagdoll(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4803, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to check if an asset is a ragdoll when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4804, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to check if an asset is a ragdoll with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return physicsAsset->useCategory == PhysicsAssetUseCategory_Ragdoll;
}

/*
==============
Physics_IsAuthoritativeWorld
==============
*/
bool Physics_IsAuthoritativeWorld(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2123, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsAuthoritativeWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return worldId == PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE || worldId == PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE;
}

/*
==============
Physics_IsChildOfShape
==============
*/
bool Physics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  if ( !possibleParent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10262, ASSERT_TYPE_ASSERT, "(possibleParent)", (const char *)&queryFormat, "possibleParent") )
    __debugbreak();
  if ( !possibleChild && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10263, ASSERT_TYPE_ASSERT, "(possibleChild)", (const char *)&queryFormat, "possibleChild") )
    __debugbreak();
  return HavokPhysics_IsChildOfShape(possibleParent, possibleChild);
}

/*
==============
Physics_IsClientEntitylessScriptable
==============
*/
bool Physics_IsClientEntitylessScriptable(const int ref)
{
  unsigned __int8 v1; 
  unsigned int v2; 
  __int64 v3; 
  unsigned int v4; 
  const ScriptableDef *def; 
  __int64 v7; 
  __int64 v8; 

  if ( (ref & 0x3E000000) != 0x10000000 )
    return 0;
  v1 = (ref >> 22) & 3;
  if ( !v1 )
    return 0;
  v2 = ref & 0x3FFFFF;
  v3 = v1;
  v4 = ((ref >> 22) & 3) - 1;
  ScriptableCommon_AssertCountsInitialized();
  if ( v2 >= g_scriptableWorldCounts.totalInstanceCount )
  {
    ScriptableCommon_AssertCountsInitialized();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 113, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableId ) < (unsigned)( ScriptableCommon_GetTotalInstanceCount() )", "scriptableId doesn't index ScriptableCommon_GetTotalInstanceCount()\n\t%i not in [0, %i)", v2, g_scriptableWorldCounts.totalInstanceCount) )
      __debugbreak();
  }
  if ( v4 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( g_scriptableCl_instanceContexts ) ) + 0 ) )", "localClientNum doesn't index g_scriptableCl_instanceContexts\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  if ( !g_scriptableCl_instanceContexts[v3 - 1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 115, ASSERT_TYPE_ASSERT, "(g_scriptableCl_instanceContexts[localClientNum])", (const char *)&queryFormat, "g_scriptableCl_instanceContexts[localClientNum]") )
    __debugbreak();
  def = g_scriptableCl_instanceContexts[v3 - 1][v2].commonContext.def;
  return def && ScriptableDef_IsStandaloneRequested(def);
}

/*
==============
Physics_IsDebugCodeReadingServer
==============
*/
bool Physics_IsDebugCodeReadingServer()
{
  bool result; 

  if ( (unsigned int)(physics_debugRayWorld->current.integer - 2) <= 1 )
    return 1;
  if ( (unsigned int)(physics_debugMutableShapesInWorld->current.integer - 2) <= 1 )
    return 1;
  if ( Physics_RenderDebugEnabled() )
    return 1;
  result = PhysicsVehicle_IsDebugDrawing();
  if ( result )
    return 1;
  return result;
}

/*
==============
Physics_IsDetailWorld
==============
*/
bool Physics_IsDetailWorld(Physics_WorldId worldId)
{
  int v2; 
  bool result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2101, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsDetailWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  result = 0;
  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = 146;
    if ( _bittest(&v2, worldId) )
      return 1;
  }
  return result;
}

/*
==============
Physics_IsInBroadphase
==============
*/
bool Physics_IsInBroadphase(Physics_WorldId worldId, const vec3_t *position)
{
  bool v4; 
  bool v5; 
  bool v6; 
  char v8; 
  char v10; 
  Physics_WorldId v13; 

  _RBX = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7815, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to check if a point is in a broadphase when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  v4 = (unsigned int)worldId < PHYSICS_WORLD_ID_CLIENT1_DETAIL;
  v5 = (unsigned int)worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v13 = worldId;
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7816, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to check if a point is in a broadphase with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v13);
    v4 = 0;
    v5 = !v6;
    if ( v6 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin; clipMap_t cm
  }
  if ( v4 )
    goto LABEL_10;
  __asm { vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax; clipMap_t cm }
  if ( !v5 )
  {
LABEL_10:
    v8 = 0;
    v5 = 1;
  }
  else
  {
    v8 = 1;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+4; clipMap_t cm
    vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+4; clipMap_t cm
  }
  if ( v5 )
  {
    v10 = 1;
  }
  else
  {
    v10 = 0;
    v5 = 1;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMin+8; clipMap_t cm
    vcomiss xmm0, dword ptr cs:?cm@@3UclipMap_t@@A.broadphaseMax+8; clipMap_t cm
  }
  if ( v5 )
    return v8 & v10;
  else
    return 0;
}

/*
==============
Physics_IsInitialized
==============
*/
_BOOL8 Physics_IsInitialized()
{
  return g_physicsInitialized;
}

/*
==============
Physics_IsInstanceDeactivated
==============
*/
bool Physics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5969, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if instance is deactivated when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5970, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if instance is deactivated with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5971, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Check if instance is deactivated with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5972, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if instance is deactivated in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5973, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if instance is deactivated in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsInstanceDeactivated(worldId, instanceId);
}

/*
==============
Physics_IsInstanceInWorld
==============
*/
bool Physics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  __int64 v7; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5911, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to test if instance is in world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5912, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to test if instance is in world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5913, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to test if instance is in world with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v7) )
      __debugbreak();
  }
  return HavokPhysics_IsInstanceInWorld(worldId, instanceId, checkPending);
}

/*
==============
Physics_IsInstanceStatic
==============
*/
char Physics_IsInstanceStatic(Physics_WorldId worldId, unsigned int instanceId)
{
  unsigned int v4; 
  unsigned int NumRigidBodys; 
  unsigned int m_serialAndIndex; 
  __int64 v8; 
  hknpBodyId result; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6002, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if an instance is Static when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6003, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if an instance is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6004, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Check if an instance is Static with invalid instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6005, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if an instance is Static in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v8) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6006, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if an instance is Static in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v8) )
      __debugbreak();
  }
  v4 = 0;
  NumRigidBodys = Physics_GetNumRigidBodys(worldId, instanceId);
  if ( !NumRigidBodys )
    return 1;
  while ( 1 )
  {
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 105, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body ID when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 106, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
        __debugbreak();
    }
    if ( instanceId == -1 )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 107, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
        __debugbreak();
    }
    if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 108, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v8) )
        __debugbreak();
    }
    if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 109, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v8) )
        __debugbreak();
    }
    m_serialAndIndex = HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, v4)->m_serialAndIndex;
    if ( (m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6012, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
      __debugbreak();
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6027, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6028, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
        __debugbreak();
    }
    if ( (m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6029, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v8) )
        __debugbreak();
    }
    if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6030, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v8) )
        __debugbreak();
    }
    if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
    {
      LODWORD(v8) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6031, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v8) )
        __debugbreak();
    }
    if ( !HavokPhysics_IsRigidBodyStatic(worldId, (hknpBodyId)m_serialAndIndex) )
      break;
    if ( ++v4 >= NumRigidBodys )
      return 1;
  }
  return 0;
}

/*
==============
Physics_IsPhysicsAssetBodyDynamic
==============
*/
bool Physics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4344, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to test if a physics asset's body is dynamic when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4345, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to test if a physics asset's body is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_IsPhysicsAssetBodyDynamic(physicsAsset, bodyIdx);
}

/*
==============
Physics_IsPhysicsAssetDynamic
==============
*/
bool Physics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4330, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to test if a physics asset is dynamic when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4331, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tPhysics: Trying to test if a physics asset is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  return HavokPhysics_IsPhysicsAssetDynamic(physicsAsset);
}

/*
==============
Physics_IsPredictiveWorld
==============
*/
bool Physics_IsPredictiveWorld(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2112, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsPredictiveWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return worldId == PHYSICS_WORLD_ID_CLIENT_FIRST || worldId == PHYSICS_WORLD_ID_CLIENT1_FIRST;
}

/*
==============
Physics_IsQueryWorld
==============
*/
bool Physics_IsQueryWorld(Physics_WorldId worldId)
{
  int v2; 
  bool result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2089, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsQueryWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  result = 0;
  if ( (unsigned int)worldId <= PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = 146;
    if ( _bittest(&v2, worldId) )
      return 1;
  }
  return result;
}

/*
==============
Physics_IsRigidBodyActive
==============
*/
bool Physics_IsRigidBodyActive(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6294, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body active state when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6295, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body active state with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6296, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body active state with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsRigidBodyActive(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_IsRigidBodyDynamic
==============
*/
bool Physics_IsRigidBodyDynamic(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6061, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Dynamic when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6062, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6063, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Check if a Rigid Body is Dynamic with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6064, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Dynamic in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6065, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Dynamic in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsRigidBodyDynamic(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_IsRigidBodyKeyframed
==============
*/
bool Physics_IsRigidBodyKeyframed(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6044, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Keyframed when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6045, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6046, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Check if a Rigid Body is Keyframed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6047, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Keyframed in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6048, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Keyframed in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsRigidBodyKeyframed(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_IsRigidBodyStatic
==============
*/
bool Physics_IsRigidBodyStatic(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6027, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6028, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6029, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v5) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6030, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6031, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Static in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsRigidBodyStatic(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_IsRigidBodyValid
==============
*/
bool Physics_IsRigidBodyValid(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v5; 
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5986, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Valid when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5987, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Valid with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5988, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Valid in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v5) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5989, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Check if a Rigid Body is Valid in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v5) )
      __debugbreak();
  }
  return HavokPhysics_IsRigidBodyValid(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_IsServerEntitylessScriptable
==============
*/
bool Physics_IsServerEntitylessScriptable(const int ref)
{
  const ScriptableDef *def; 

  return (ref & 0x3E000000) == 0x10000000 && ((ref >> 22) & 3) == 0 && (def = ScriptableSv_GetInstanceCommonContext(ref & 0x3FFFFF)->def) != NULL && ScriptableDef_IsStandaloneRequested(def);
}

/*
==============
Physics_IsShapeCacheDisabled
==============
*/

bool __fastcall Physics_IsShapeCacheDisabled(unsigned int threadId)
{
  return HavokPhysics_IsShapeCacheDisabled(threadId);
}

/*
==============
Physics_KeyframeInstanceTo
==============
*/
Physics_MovementType Physics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  float fmt; 
  __int64 v32; 
  float v33; 
  int v34; 
  int v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6737, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Keyframe Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6738, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Keyframe Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6739, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Keyframe Instance with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v32) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v34 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v35 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6740, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Keyframe Instance with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6741, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Keyframe Instance with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovups xmmword ptr [rsp+98h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  xmm0, [rsp+98h+stepTimeOverride]
    vmovss  [rsp+98h+var_60], xmm0
    vmovss  xmm0, [rsp+98h+velocityScale]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+98h+fmt], xmm0
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+0Ch], xmm2
  }
  return HavokPhysics_KeyframeInstanceTo(worldId, instanceId, &hkPosition, &hkOrientation, fmt, canWarp, updateBroadphaseIfWarping, v33);
}

/*
==============
Physics_KeyframeRigidBodyTo
==============
*/
__int64 Physics_KeyframeRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  Physics_MovementType v30; 
  float fmt; 
  __int64 v33; 
  Physics_WorldId v34; 
  float v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6894, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Keyframe Rigid Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v34 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6895, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v34) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6896, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v33) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6897, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6898, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovups xmmword ptr [rsp+98h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  xmm0, [rsp+98h+stepTimeOverride]
    vmovss  [rsp+98h+var_60], xmm0
    vmovss  xmm0, [rsp+98h+velocityScale]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+98h+fmt], xmm0
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+0Ch], xmm2
  }
  v30 = HavokPhysics_KeyframeRigidBodyTo(worldId, (hknpBodyId)bodyId, &hkPosition, &hkOrientation, fmt, canWarp, updateBroadphaseIfWarping, v35);
  Physics_KeyframeRigidBodyValidation(worldId, bodyId, canWarp, v30);
  return (unsigned int)v30;
}

/*
==============
Physics_KeyframeRigidBodyToFast
==============
*/
__int64 Physics_KeyframeRigidBodyToFast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  Physics_MovementType v30; 
  float fmt; 
  __int64 v33; 
  Physics_WorldId v34; 
  float v35; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6923, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Keyframe Rigid Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v34 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6924, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v34) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6925, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v33) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v36 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v37 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6926, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6927, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Keyframe Rigid Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovups xmmword ptr [rsp+98h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  xmm0, [rsp+98h+stepTimeOverride]
    vmovss  [rsp+98h+var_60], xmm0
    vmovss  xmm0, [rsp+98h+velocityScale]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+98h+fmt], xmm0
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+0Ch], xmm2
  }
  v30 = HavokPhysics_KeyframeRigidBodyToFast(worldId, (hknpBodyId)bodyId, &hkPosition, &hkOrientation, fmt, canWarp, updateBroadphaseIfWarping, v35);
  Physics_KeyframeRigidBodyValidation(worldId, bodyId, canWarp, v30);
  return (unsigned int)v30;
}

/*
==============
Physics_KeyframeRigidBodyValidation
==============
*/
void Physics_KeyframeRigidBodyValidation(Physics_WorldId worldId, unsigned int bodyId, bool canWarp, Physics_MovementType movementType)
{
  char v19; 
  unsigned int Ref; 
  const char *name; 
  unsigned __int16 model; 
  XModel *v23; 
  double v29; 
  double v30; 
  float maxLinSpeed; 
  vec3_t linVel; 
  char string[256]; 

  if ( worldId == PHYSICS_WORLD_ID_FIRST && !canWarp && movementType == Physics_MovementType_Keyframed )
  {
    __asm
    {
      vmovaps [rsp+198h+var_18], xmm6
      vmovaps [rsp+198h+var_28], xmm7
    }
    Physics_GetRigidBodyLinVel(PHYSICS_WORLD_ID_FIRST, bodyId, &linVel);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+198h+linVel]
      vmovss  xmm1, dword ptr [rsp+198h+linVel+4]
      vmulss  xmm2, xmm1, xmm1
      vmulss  xmm3, xmm0, xmm0
      vmovss  xmm0, dword ptr [rsp+198h+linVel+8]
      vaddss  xmm4, xmm3, xmm2
      vmulss  xmm1, xmm0, xmm0
      vxorps  xmm2, xmm2, xmm2
      vmovss  [rsp+198h+maxLinSpeed], xmm2
      vaddss  xmm7, xmm4, xmm1
    }
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6078, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( (bodyId & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6080, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Max LinSpeed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", 0) )
      __debugbreak();
    HavokPhysics_GetRigidBodyMaxLinSpeed(PHYSICS_WORLD_ID_FIRST, (hknpBodyId)bodyId, &maxLinSpeed);
    __asm
    {
      vmovss  xmm0, [rsp+198h+maxLinSpeed]
      vmulss  xmm6, xmm0, cs:__real@42000000
      vmulss  xmm1, xmm6, xmm6
      vcomiss xmm7, xmm1
    }
    if ( !v19 && !Dvar_GetBool_Internal_DebugName(DVARBOOL_physics_disableSpammyWarnings, "physics_disableSpammyWarnings") )
    {
      Ref = Physics_GetRef(PHYSICS_WORLD_ID_FIRST, bodyId);
      Physics_ConvertRefSystemToString(Ref, PHYSICS_WORLD_ID_FIRST, string, 256);
      name = (char *)&queryFormat.fmt + 3;
      if ( (Ref & 0x3E000000) == 0x4000000 )
      {
        model = g_entities[truncate_cast<unsigned short,int>((unsigned __int16)Ref)].model;
        if ( model )
        {
          v23 = G_Utils_GetModel(model);
          if ( v23 )
            name = v23->name;
        }
      }
      __asm
      {
        vsqrtss xmm0, xmm7, xmm7
        vcvtss2sd xmm2, xmm6, xmm6
        vmovsd  [rsp+198h+var_168], xmm2
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+198h+var_170], xmm1
      }
      Com_PrintWarning(20, "Physics body (ref:%x %s%s) was requested to move at speed %.2f, but has a max of %.2f.  It may appear to not have server collision until it catches up.  Turn this message off with dvar physics_disableSpammyWarnings\n", Ref, string, name, v29, v30);
    }
    __asm
    {
      vmovaps xmm6, [rsp+198h+var_18]
      vmovaps xmm7, [rsp+198h+var_28]
    }
  }
}

/*
==============
Physics_Load
==============
*/
void Physics_Load(SaveGame *save)
{
  MemFile_ReadSentinel(&save->memFile, 0x42158u);
  HavokPhysics_Load(save);
  G_PhysicsCharacterProxy_Load(save);
  PhysicsCoverWall_Load(save);
  G_PhysicsObject_Load(save);
  PhysicsVehicle_Load(save);
  PhysicsVolume_Load(save);
  PhysicsGravityModifier_Load(save);
  PhysicsForceAction_Load(save);
  Physics_UpdateBroadphase(PHYSICS_WORLD_ID_FIRST, 1);
  Physics_UpdateBroadphase(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_FIRST);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_SERVER_DETAIL);
}

/*
==============
Physics_LockWorld
==============
*/
void Physics_LockWorld(Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3266, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Lock World when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3267, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Lock World with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  HavokPhysics_LockWorld(worldId);
}

/*
==============
Physics_LoosenConstraint
==============
*/
bool Physics_LoosenConstraint(Physics_WorldId worldId, unsigned int constraintId, PhysicsConstraintLooseningResult *result)
{
  __int64 v7; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7909, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to loosen constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7910, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to loosen constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId == 0x7FFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7911, ASSERT_TYPE_ASSERT, "(Physics_IsConstraintIdValid( constraintId ))", "%s\n\tPhysics: Trying to loosen constraint with invalid constraint in world %i", "Physics_IsConstraintIdValid( constraintId )", v7) )
      __debugbreak();
  }
  if ( !result )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7912, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to loosen constraint with NULL result in world %i", "result", v7) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  return HavokPhysics_LoosenConstraint(worldId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)constraintId, result);
}

/*
==============
Physics_MakeRef
==============
*/
__int64 Physics_MakeRef(Physics_RefSystem system, Physics_RelationshipSystem relationSystem, unsigned __int8 subSystem, unsigned __int16 id)
{
  return id | ((subSystem | (((2 * (char)system) | relationSystem & 1u) << 8)) << 16);
}

/*
==============
Physics_MovePhysicsAsset
==============
*/
void Physics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3749, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Move PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (to->usageCounter.serverEnt || to->usageCounter.clientEnt || to->usageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( to->usageCounter.serverEnt )
      G_Utils_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.dynEnt )
      DynEnt_PrepareForPhysicsAssetChange(to);
  }
  HavokPhysics_MovePhysicsAsset(from, to);
}

/*
==============
Physics_MovePhysicsSFXEventAsset
==============
*/
void Physics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3586, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to move PhysicsSFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_MovePhysicsSFXEventAsset(from, to);
}

/*
==============
Physics_MovePhysicsVFXEventAsset
==============
*/
void Physics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3641, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to move PhysicsVFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_MovePhysicsVFXEventAsset(from, to);
}

/*
==============
Physics_MoveXModelAsset
==============
*/
void Physics_MoveXModelAsset(XModel *from, XModel *to)
{
  char v4; 
  PhysicsAsset *physicsAsset; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4247, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Move XModel Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( to->physicsAsset || from->physicsAsset )
  {
    v4 = 1;
  }
  else
  {
    v4 = 0;
    if ( !to->physicsUsageCounter.serverEnt && !to->physicsUsageCounter.clientEnt && !to->physicsUsageCounter.dynEnt )
      goto LABEL_25;
  }
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( v4 )
    {
      physicsAsset = to->physicsAsset;
      if ( !physicsAsset || physicsAsset->usageCounter.serverEnt )
      {
        G_Utils_PhysicsPrepareForPhysicsAssetChange(to, physicsAsset);
        physicsAsset = to->physicsAsset;
      }
      if ( !physicsAsset || physicsAsset->usageCounter.clientEnt )
        CG_Entity_PhysicsPrepareForPhysicsAssetChange(to, physicsAsset);
    }
    if ( to->physicsUsageCounter.serverEnt )
      G_Utils_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.dynEnt )
      DynEnt_PrepareForXModelChange(to);
  }
LABEL_25:
  HavokPhysics_MoveXModelAsset(from, to);
}

/*
==============
Physics_MoveXModelDetailCollisionAsset
==============
*/
void Physics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4126, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Move XModelDetailCollision Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    G_Utils_PhysicsPrepareForXModelDetailCollisionChange(to);
    CG_Entity_PhysicsPrepareForXModelDetailCollisionChange(to);
    DynEnt_PrepareForXModelDetailCollisionChange(to);
  }
  HavokPhysics_MoveXModelDetailCollisionAsset(from, to);
}

/*
==============
Physics_MyChangesInitAndLoad
==============
*/

void Physics_MyChangesInitAndLoad(void)
{
  HavokPhysics_MyChangesInitAndLoad();
}

/*
==============
Physics_MyChangesSaveAndShutdown
==============
*/

void Physics_MyChangesSaveAndShutdown(void)
{
  HavokPhysics_MyChangesSaveAndShutdown();
}

/*
==============
Physics_NoWorldTidyUp
==============
*/
void Physics_NoWorldTidyUp()
{
  if ( g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1923, ASSERT_TYPE_ASSERT, "(!g_physicsServerWorldsCreated)", (const char *)&queryFormat, "!g_physicsServerWorldsCreated") )
    __debugbreak();
  if ( g_physicsClientWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1924, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated == 0)", (const char *)&queryFormat, "g_physicsClientWorldsCreated == 0") )
    __debugbreak();
  if ( g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10112, ASSERT_TYPE_ASSERT, "(!Physics_AreServerWorldsCreated())", (const char *)&queryFormat, "!Physics_AreServerWorldsCreated()") )
    __debugbreak();
  if ( g_physicsClientWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10113, ASSERT_TYPE_ASSERT, "(!Physics_AreClientWorldsCreated())", (const char *)&queryFormat, "!Physics_AreClientWorldsCreated()") )
    __debugbreak();
  HavokPhysics_ClearShapeCache();
}

/*
==============
Physics_OnThreadInit
==============
*/
void Physics_OnThreadInit(unsigned int threadId)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1468, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to init a physics thread when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_OnThreadInit(threadId);
}

/*
==============
Physics_OnThreadShutdown
==============
*/
void Physics_OnThreadShutdown(unsigned int threadId)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1604, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to shutdown a physics thread when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_OnThreadShutdown(threadId);
}

/*
==============
Physics_PreStepWorld
==============
*/

void __fastcall Physics_PreStepWorld(Physics_WorldId worldId, double timeStep)
{
  __int64 v5; 
  const dvar_t *v7; 
  char v8; 
  hkMonitorStream *Value; 
  hkMonitorStream *v11; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmm6, xmm1
  }
  v5 = worldId;
  if ( HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled(worldId) )
  {
    _RAX = HavokPhysics_GetMutableWorld((Physics_WorldId)v5);
    __asm { vmovss  dword ptr [rax+84h], xmm6 }
  }
  v7 = DVARBOOL_physics_killswitchEnableApplyTimeSmoothingBeforePreWorldFunctions;
  if ( !DVARBOOL_physics_killswitchEnableApplyTimeSmoothingBeforePreWorldFunctions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableApplyTimeSmoothingBeforePreWorldFunctions") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled && Com_GameMode_SupportsFeature(WEAPON_DROPPING_AKIMBO|0x100) )
  {
    v8 = 1;
    __asm { vmovaps xmm1, xmm6; timeStep }
    HavokPhysics_SmoothTimeStep((Physics_WorldId)v5, *(float *)&_XMM1);
  }
  else
  {
    v8 = 0;
  }
  if ( s_physicsPreStepWorldFns[v5] )
  {
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v11 = Value;
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtBefore Step world Fn");
    s_physicsPreStepWorldFns[v5]((Physics_WorldId)v5);
    if ( v11 )
      hkMonitorStream::timerEnd(v11, "Et");
  }
  if ( !v8 )
  {
    __asm { vmovaps xmm1, xmm6; timeStep }
    HavokPhysics_SmoothTimeStep((Physics_WorldId)v5, *(float *)&_XMM1);
  }
  __asm
  {
    vmovaps xmm1, xmm6; timeStep
    vmovaps xmm6, [rsp+78h+var_28]
  }
  HavokPhysics_PreStepWorld((Physics_WorldId)v5, *(float *)&_XMM1);
}

/*
==============
Physics_PrepareForDetailCollisionAssetChange
==============
*/
void Physics_PrepareForDetailCollisionAssetChange(XModelDetailCollision *detailCollision)
{
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    G_Utils_PhysicsPrepareForXModelDetailCollisionChange(detailCollision);
    CG_Entity_PhysicsPrepareForXModelDetailCollisionChange(detailCollision);
    DynEnt_PrepareForXModelDetailCollisionChange(detailCollision);
  }
}

/*
==============
Physics_ProcessDeferredForce
==============
*/
void Physics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7737, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to process deferred force when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7738, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to process deferred force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  HavokPhysics_ProcessDeferredForce(worldId);
}

/*
==============
Physics_ProcessDeferredForceCallbacks
==============
*/
void Physics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7749, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to process deferred force callbacks when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7750, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to process deferred force callbacks with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  HavokPhysics_ProcessDeferredForceCallbacks(worldId);
}

/*
==============
Physics_ProcessDeferredKeyframe
==============
*/

void __fastcall Physics_ProcessDeferredKeyframe(const Physics_WorldId worldId, double velocityScale)
{
  int v5; 
  Physics_WorldId v8; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7722, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to process deferred keyframe when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE || (v5 = 73, !_bittest(&v5, worldId)) )
  {
    v8 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7724, ASSERT_TYPE_ASSERT, "(worldId == PHYSICS_WORLD_ID_SERVER_MAIN || worldId == PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE || worldId == PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE)", "%s\n\tPhysics: Trying to Add deferred keyframe with invalid world index %i", "worldId == PHYSICS_WORLD_ID_SERVER_MAIN || worldId == PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE || worldId == PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE", v8) )
      __debugbreak();
  }
  __asm
  {
    vmovaps xmm1, xmm6; velocityScale
    vmovaps xmm6, [rsp+58h+var_18]
  }
  HavokPhysics_ProcessDeferredKeyframe(worldId, *(const float *)&_XMM1);
}

/*
==============
Physics_QueryPoint
==============
*/

void __fastcall Physics_QueryPoint(Physics_WorldId worldId, const vec3_t *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v9; 
  const dvar_t *v13; 
  int v22; 
  int v23; 
  int v24; 
  hkVector4f pointa; 

  __asm { vmovaps [rsp+0B8h+var_48], xmm6 }
  _RSI = point;
  __asm { vmovaps xmm6, xmm2 }
  v9 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8971, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire QueryPoint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8972, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire QueryPoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
  {
LABEL_43:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8973, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire QueryPoint with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  if ( !result )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8974, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire QueryPoint with invalid extended data", "result") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8975, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire QueryPoint with invalid result", "result") )
      __debugbreak();
  }
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v9] )
  {
    v13 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( v13->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8976, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  if ( g_physicsQueriesNotAllowedForWorld[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8977, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v9] )
    Physics_UpdateBroadphase((Physics_WorldId)v9, 1);
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0B8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0B8h+point.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+0B8h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+0B8h+point.m_quad+8], xmm1
    vmulss  xmm6, xmm6, xmm3
  }
  switch ( (int)v9 )
  {
    case 0:
      Profile_Begin(717);
      break;
    case 1:
      Profile_Begin(718);
      break;
    case 2:
    case 5:
      Profile_Begin(719);
      break;
    case 3:
    case 6:
      Profile_Begin(720);
      break;
    case 4:
    case 7:
      Profile_Begin(721);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9034, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm { vmovaps xmm2, xmm6; maxDistance }
  HavokPhysics_QueryPoint((Physics_WorldId)v9, &pointa, *(float *)&_XMM2, extendedData, result);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+0B8h+var_48] }
}

/*
==============
Physics_QueryPoint
==============
*/

void __fastcall Physics_QueryPoint(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *point, double maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v10; 
  __int64 v22; 
  int v23; 
  int v24; 
  int v25; 
  hkVector4f pointa; 

  __asm { vmovaps [rsp+0A8h+var_38], xmm6 }
  _RDI = point;
  __asm { vmovaps xmm6, xmm3 }
  v10 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9598, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire QueryPoint against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v10 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9599, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire QueryPoint against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9600, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire QueryPoint against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v22) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
  {
LABEL_41:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9601, ASSERT_TYPE_ASSERT, "(!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] ))", "%s\n\tPhysics: Trying to fire QueryPoint against body with invalid point", "!IS_NAN( point[0] ) && !IS_NAN( point[1] ) && !IS_NAN( point[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9602, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire QueryPoint against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9603, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire QueryPoint against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9604, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tPhysics: Trying to fire QueryPoint against body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9605, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire QueryPoint against body with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9606, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+point.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+0A8h+point.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+0A8h+point.m_quad], xmm0
    vmovss  dword ptr [rsp+0A8h+point.m_quad+8], xmm1
    vmulss  xmm6, xmm6, xmm3
  }
  switch ( (int)v10 )
  {
    case 0:
      Profile_Begin(747);
      break;
    case 1:
      Profile_Begin(748);
      break;
    case 2:
    case 5:
      Profile_Begin(749);
      break;
    case 3:
    case 6:
      Profile_Begin(750);
      break;
    case 4:
    case 7:
      Profile_Begin(751);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9657, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  __asm { vmovaps xmm3, xmm6; maxDistance }
  HavokPhysics_QueryPoint((Physics_WorldId)v10, (hknpBodyId)bodyId, &pointa, *(float *)&_XMM3, extendedData, result);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
}

/*
==============
Physics_Raycast
==============
*/
void Physics_Raycast(Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v9; 
  const dvar_t *v16; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  hkVector4f enda; 
  hkVector4f starta; 

  _RBP = end;
  _R14 = start;
  v9 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8640, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire Raycast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8641, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire Raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_49;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_49:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8642, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire Raycast with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_50;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
  {
LABEL_50:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8643, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire Raycast with invalid end", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8644, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire Raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8645, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire Raycast with invalid result", "result") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v9] )
  {
    v16 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8646, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
  }
  if ( g_physicsQueriesNotAllowedForWorld[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8647, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v9 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v9] )
    Physics_UpdateBroadphase((Physics_WorldId)v9, 1);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [r14]
    vmulss  xmm2, xmm4, dword ptr [r14+4]
    vmulss  xmm1, xmm4, dword ptr [r14+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0B8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbp+4]
    vmovss  dword ptr [rsp+0B8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rbp+8]
    vmovss  dword ptr [rsp+0B8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rbp+0]
    vmovss  dword ptr [rsp+0B8h+end.m_quad], xmm1
    vmovss  dword ptr [rsp+0B8h+end.m_quad+4], xmm0
    vmovss  dword ptr [rsp+0B8h+end.m_quad+8], xmm2
    vmovss  dword ptr [rsp+0B8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0B8h+end.m_quad+0Ch], xmm3
  }
  switch ( (int)v9 )
  {
    case 0:
      Profile_Begin(702);
      break;
    case 1:
      Profile_Begin(703);
      break;
    case 2:
    case 5:
      Profile_Begin(704);
      break;
    case 3:
    case 6:
      Profile_Begin(705);
      break;
    case 4:
    case 7:
      Profile_Begin(706);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8704, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_Raycast((Physics_WorldId)v9, &starta, &enda, extendedData, result);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_Raycast
==============
*/
void Physics_Raycast(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v10; 
  __int64 v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  hkVector4f enda; 
  hkVector4f starta; 

  _RDI = end;
  _RSI = start;
  v10 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9287, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire Raycast against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v10 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9288, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire Raycast against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v25) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9289, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire raycast against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v25) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_43;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
LABEL_43:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9290, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire Raycast against body with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_44;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+var_68], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_44:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9291, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire Raycast against body with invalid start", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9292, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire Raycast against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9293, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire Raycast against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9294, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire Raycast against body with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9295, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rsi]
    vmulss  xmm2, xmm4, dword ptr [rsi+4]
    vmulss  xmm1, xmm4, dword ptr [rsi+8]
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0A8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rdi+4]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+0A8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rdi]
    vmovss  dword ptr [rsp+0A8h+end.m_quad], xmm1
    vmovss  dword ptr [rsp+0A8h+end.m_quad+4], xmm0
    vmovss  dword ptr [rsp+0A8h+end.m_quad+8], xmm2
    vmovss  dword ptr [rsp+0A8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0A8h+end.m_quad+0Ch], xmm3
  }
  switch ( (int)v10 )
  {
    case 0:
      Profile_Begin(732);
      break;
    case 1:
      Profile_Begin(733);
      break;
    case 2:
    case 5:
      Profile_Begin(734);
      break;
    case 3:
    case 6:
      Profile_Begin(735);
      break;
    case 4:
    case 7:
      Profile_Begin(736);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9346, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_Raycast((Physics_WorldId)v10, (hknpBodyId)bodyId, &starta, &enda, extendedData, result);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_ReleaseMapLocalAllocatorBuffer
==============
*/

void Physics_ReleaseMapLocalAllocatorBuffer(void)
{
  HavokPhysics_ReleaseMapLocalAllocatorBuffer();
}

/*
==============
Physics_ReleasePhysicsAsset
==============
*/
void Physics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  __int64 v4; 
  int serverEnt; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3677, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (physicsAsset->usageCounter.serverEnt || physicsAsset->usageCounter.clientEnt || physicsAsset->usageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( physicsAsset->usageCounter.serverEnt )
      G_Utils_PhysicsPrepareForPhysicsAssetChange(physicsAsset);
    if ( physicsAsset->usageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForPhysicsAssetChange(physicsAsset);
    if ( physicsAsset->usageCounter.dynEnt )
      DynEnt_PrepareForPhysicsAssetChange(physicsAsset);
  }
  if ( physicsAsset->usageCounter.serverEnt )
  {
    serverEnt = physicsAsset->usageCounter.serverEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3701, ASSERT_TYPE_ASSERT, "(physicsAsset->usageCounter.serverEnt == 0)", "%s\n\tPhysicsAsset %s has server ent refcount of %i", "physicsAsset->usageCounter.serverEnt == 0", physicsAsset->name, serverEnt) )
      __debugbreak();
  }
  if ( physicsAsset->usageCounter.clientEnt )
  {
    LODWORD(v4) = physicsAsset->usageCounter.clientEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3702, ASSERT_TYPE_ASSERT, "(physicsAsset->usageCounter.clientEnt == 0)", "%s\n\tPhysicsAsset %s has client ent refcount of %i", "physicsAsset->usageCounter.clientEnt == 0", physicsAsset->name, v4) )
      __debugbreak();
  }
  if ( physicsAsset->usageCounter.dynEnt )
  {
    LODWORD(v4) = physicsAsset->usageCounter.dynEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3703, ASSERT_TYPE_ASSERT, "(physicsAsset->usageCounter.dynEnt == 0)", "%s\n\tPhysicsAsset %s has dyn ent refcount of %i", "physicsAsset->usageCounter.dynEnt == 0", physicsAsset->name, v4) )
      __debugbreak();
  }
  HavokPhysics_ReleasePhysicsAsset(physicsAsset, unloadPackFileData);
}

/*
==============
Physics_ReleasePhysicsLibrary
==============
*/
void Physics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3541, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release PhysicsLibary when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ReleasePhysicsLibrary(physicsLibrary);
}

/*
==============
Physics_ReleasePhysicsSFXEventAsset
==============
*/
void Physics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3564, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release PhysicsSFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ReleasePhysicsSFXEventAsset(physicsSFXEventAsset);
}

/*
==============
Physics_ReleasePhysicsVFXEventAsset
==============
*/
void Physics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3619, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release PhysicsVFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ReleasePhysicsVFXEventAsset(physicsVFXEventAsset);
}

/*
==============
Physics_ReleaseShape
==============
*/

void __fastcall Physics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  HavokPhysics_ReleaseShape(worldId, shape, finalReference);
}

/*
==============
Physics_ReleaseXModelAsset
==============
*/
void Physics_ReleaseXModelAsset(XModel *xmodel)
{
  __int64 v2; 
  int serverEnt; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4163, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release XModel Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (xmodel->physicsUsageCounter.serverEnt || xmodel->physicsUsageCounter.clientEnt || xmodel->physicsUsageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( xmodel->physicsUsageCounter.serverEnt )
      G_Utils_PhysicsPrepareForXModelChange(xmodel);
    if ( xmodel->physicsUsageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForXModelChange(xmodel);
    if ( xmodel->physicsUsageCounter.dynEnt )
      DynEnt_PrepareForXModelChange(xmodel);
  }
  if ( xmodel->physicsUsageCounter.serverEnt )
  {
    serverEnt = xmodel->physicsUsageCounter.serverEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4187, ASSERT_TYPE_ASSERT, "(xmodel->physicsUsageCounter.serverEnt == 0)", "%s\n\tXModel %s has server ent refcount of %i", "xmodel->physicsUsageCounter.serverEnt == 0", xmodel->name, serverEnt) )
      __debugbreak();
  }
  if ( xmodel->physicsUsageCounter.clientEnt )
  {
    LODWORD(v2) = xmodel->physicsUsageCounter.clientEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4188, ASSERT_TYPE_ASSERT, "(xmodel->physicsUsageCounter.clientEnt == 0)", "%s\n\tXModel %s has client ent refcount of %i", "xmodel->physicsUsageCounter.clientEnt == 0", xmodel->name, v2) )
      __debugbreak();
  }
  if ( xmodel->physicsUsageCounter.dynEnt )
  {
    LODWORD(v2) = xmodel->physicsUsageCounter.dynEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4189, ASSERT_TYPE_ASSERT, "(xmodel->physicsUsageCounter.dynEnt == 0)", "%s\n\tXModel %s has dyn ent refcount of %i", "xmodel->physicsUsageCounter.dynEnt == 0", xmodel->name, v2) )
      __debugbreak();
  }
  HavokPhysics_ReleaseXModelAsset(xmodel);
}

/*
==============
Physics_ReleaseXModelDetailCollisionAsset
==============
*/
void Physics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  if ( detailCollision->physicsLODDataSize )
  {
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4100, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release XModelDetailCollision Asset when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( DB_ShouldUpdateGameOnPhysicsChange() )
    {
      G_Utils_PhysicsPrepareForXModelDetailCollisionChange(detailCollision);
      CG_Entity_PhysicsPrepareForXModelDetailCollisionChange(detailCollision);
      DynEnt_PrepareForXModelDetailCollisionChange(detailCollision);
    }
    HavokPhysics_ReleaseXModelDetailCollisionAsset(detailCollision, unloadPackFileData);
  }
}

/*
==============
Physics_RemoveClipMap
==============
*/
void Physics_RemoveClipMap(clipMap_t *clipMap)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4053, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Release ClipMap when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_RemoveClipMap(clipMap);
}

/*
==============
Physics_RemoveInstanceFromWorld
==============
*/
void Physics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5940, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to remove instance from world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5941, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to remove instance from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5942, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to remove instance from world with invalid instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_RemoveInstanceFromWorld(worldId, instanceId, activate);
}

/*
==============
Physics_RemoveRigidBodiesFromWorld
==============
*/
void Physics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, unsigned int *bodyIds, int numBodies, bool activate)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5954, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to remove bodies from world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5955, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to remove bodies from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !bodyIds )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5956, ASSERT_TYPE_ASSERT, "(bodyIds)", "%s\n\tPhysics: Trying to remove bodies from world with invalid bodies array in world %i", "bodyIds", v8) )
      __debugbreak();
  }
  if ( numBodies <= 0 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5957, ASSERT_TYPE_ASSERT, "(numBodies > 0)", "%s\n\tPhysics: Trying to remove bodies from world with no bodies in world %i", "numBodies > 0", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_RemoveRigidBodiesFromWorld(worldId, (hknpBodyId *)bodyIds, numBodies, activate);
}

/*
==============
Physics_RemoveShapeList
==============
*/
void Physics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3835, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Remove ShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !rawShapeData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3837, ASSERT_TYPE_ASSERT, "(rawShapeData)", (const char *)&queryFormat, "rawShapeData") )
    __debugbreak();
  if ( !rawShapeDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3838, ASSERT_TYPE_ASSERT, "(rawShapeDataSize > 0)", (const char *)&queryFormat, "rawShapeDataSize > 0") )
    __debugbreak();
  HavokPhysics_RemoveShapeList(rawShapeData, rawShapeDataSize);
}

/*
==============
Physics_RenderDebug
==============
*/
void Physics_RenderDebug(GfxCmdBufContext *gfxContext)
{
  bool v3; 
  GfxCmdBufContext v5; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  _RBX = gfxContext;
  __asm { vmovups xmmword ptr [rsp+38h+var_18.source], xmm0 }
  PhysPerfTrack_DebugRender(&v5);
  if ( Physics_RenderDebugEnabled() )
  {
    v3 = g_physicsServerWorldsCreated || g_physicsClientWorldsCreated;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
    }
    HavokPhysics_RenderDebug(&v5, v3);
  }
}

/*
==============
Physics_RenderDebugEnabled
==============
*/
bool Physics_RenderDebugEnabled()
{
  const dvar_t *v0; 
  const dvar_t *v1; 
  const dvar_t *v2; 
  int Int_Internal_DebugName; 

  if ( physics_debugVisualizeWorld->current.integer )
    goto LABEL_15;
  v0 = DVARBOOL_physics_debugTrackPerfPMoveHeatmap;
  if ( !DVARBOOL_physics_debugTrackPerfPMoveHeatmap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_debugTrackPerfPMoveHeatmap") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
    goto LABEL_15;
  v1 = DVARBOOL_physics_debugTrackPerfBulletHeatmap;
  if ( !DVARBOOL_physics_debugTrackPerfBulletHeatmap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_debugTrackPerfBulletHeatmap") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
    goto LABEL_15;
  v2 = DVARINT_physics_debugTrackWorldMeshDisplayArea;
  if ( !DVARINT_physics_debugTrackWorldMeshDisplayArea && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_debugTrackWorldMeshDisplayArea") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.integer || (Int_Internal_DebugName = Dvar_GetInt_Internal_DebugName(DVARINT_physics_debugRaycasterMode, "physics_debugRaycasterMode")) != 0 )
LABEL_15:
    LOBYTE(Int_Internal_DebugName) = 1;
  return Int_Internal_DebugName;
}

/*
==============
Physics_RenderDebugOverlays
==============
*/
void Physics_RenderDebugOverlays(GfxCmdBufContext *gfxContext)
{
  GfxCmdBufContext v2; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  PhysPerfRaycast_DebugRender(&v2);
}

/*
==============
Physics_ResetWorkerError
==============
*/
void Physics_ResetWorkerError(void)
{
  s_physicsHasWorkerError = 0;
}

/*
==============
Physics_SetBroadphaseNeedsRefresh
==============
*/
void Physics_SetBroadphaseNeedsRefresh(const Physics_WorldId worldId, const bool needsRefresh)
{
  __int64 v2; 

  v2 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8395, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8396, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't impact the broadphase during entity workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  g_physicsBroadphaseRefreshNeeded[v2] = needsRefresh;
}

/*
==============
Physics_SetCGCharacterProxyPredictiveDebugData
==============
*/
void Physics_SetCGCharacterProxyPredictiveDebugData(LocalClientNum_t localClientNum, int numCharacterProxies)
{
  s_debugProfileData.clientData[localClientNum].numPredictiveCharacterProxies = numCharacterProxies;
}

/*
==============
Physics_SetCGDynEntAuthoritativeDebugData
==============
*/
void Physics_SetCGDynEntAuthoritativeDebugData(LocalClientNum_t localClientNum, int dynEntCount, int dynEntSimpleCount, int dynEntSimpleAdditionalBoneCount, int dynEntComplexCount, int dynEntComplexBodyCount, int dynEntComplexAdditionalBoneCount)
{
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  v7 = localClientNum;
  v8 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntCount + v8) += dynEntCount;
  v9 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntSimpleCount + v9) += dynEntSimpleCount;
  v10 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntSimpleAdditionalBoneCount + v10) += dynEntSimpleAdditionalBoneCount;
  v11 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntComplexCount + v11) += dynEntComplexCount;
  v12 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntComplexBodyCount + v12) += dynEntComplexBodyCount;
  v13 = v7 * 208 + 24i64 * s_debugProfileData.clientData[v7].dynEntsDataBufferIndex;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[0].dynEntComplexAdditionalBoneCount + v13) += dynEntComplexAdditionalBoneCount;
}

/*
==============
Physics_SetCGDynEntDetailPropagationDebugData
==============
*/
void Physics_SetCGDynEntDetailPropagationDebugData(LocalClientNum_t localClientNum, int detailBoundedCount, int duplicationCount, int duplicationBodyCount)
{
  __int64 v4; 

  v4 = localClientNum;
  s_debugProfileData.clientData[v4].dynEntDetailBoundedCount = detailBoundedCount;
  s_debugProfileData.clientData[v4].dynEntDetailDuplicationCount = duplicationCount;
  s_debugProfileData.clientData[v4].dynEntDetailDuplicationBodyCount = duplicationBodyCount;
}

/*
==============
Physics_SetCGFXEmittersDetailPropagationDebugData
==============
*/
void Physics_SetCGFXEmittersDetailPropagationDebugData(LocalClientNum_t localClientNum, int numEmitters, int numPhysicsEmitters)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].fxEmittersCount = numEmitters;
  s_debugProfileData.clientData[v3].fxPhysicsEmittersCount = numPhysicsEmitters;
}

/*
==============
Physics_SetCGFXOldDetailPropagationDebugData
==============
*/
void Physics_SetCGFXOldDetailPropagationDebugData(LocalClientNum_t localClientNum, int numOldElems, int numOldElemsWithPhysics)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].fxOldElemsCount = numOldElems;
  s_debugProfileData.clientData[v3].fxOldElemsWithPhysicsCount = numOldElemsWithPhysics;
}

/*
==============
Physics_SetCGFXParticlesDetailPropagationDebugData
==============
*/
void Physics_SetCGFXParticlesDetailPropagationDebugData(LocalClientNum_t localClientNum, int numParticles, int numPhysicsParticles)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].fxParticlesCount = numParticles;
  s_debugProfileData.clientData[v3].fxPhysicsParticlesCount = numPhysicsParticles;
}

/*
==============
Physics_SetCGFXStatesDetailPropagationDebugData
==============
*/
void Physics_SetCGFXStatesDetailPropagationDebugData(LocalClientNum_t localClientNum, int numState, int numPhysicsState)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].fxStatesCount = numState;
  s_debugProfileData.clientData[v3].fxPhysicsStatesCount = numPhysicsState;
}

/*
==============
Physics_SetCGFXSystemsDetailPropagationDebugData
==============
*/
void Physics_SetCGFXSystemsDetailPropagationDebugData(LocalClientNum_t localClientNum, int numSystems, int numPhysicsSystems)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].fxSystemsCount = numSystems;
  s_debugProfileData.clientData[v3].fxPhysicsSystemsCount = numPhysicsSystems;
}

/*
==============
Physics_SetCGGlassDetailPropagationDebugData
==============
*/
void Physics_SetCGGlassDetailPropagationDebugData(LocalClientNum_t localClientNum, int glassPieceCount, int glassPhysicsCount, int glassBodyCount)
{
  __int64 v4; 

  v4 = localClientNum;
  s_debugProfileData.clientData[v4].glassPieceCount = glassPieceCount;
  s_debugProfileData.clientData[v4].glassPhysicsCount = glassPhysicsCount;
  s_debugProfileData.clientData[v4].glassBodyCount = glassBodyCount;
}

/*
==============
Physics_SetCGPhysicsObjectAuthoritativeDebugData
==============
*/
void Physics_SetCGPhysicsObjectAuthoritativeDebugData(LocalClientNum_t localClientNum, int physicsObjectDynamicBoneMappingHavingCount, int physicsObjectDynamicBoneMappingCount)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].authoritativePhysicsObjectDynamicBoneMappingHavingCount = physicsObjectDynamicBoneMappingHavingCount;
  s_debugProfileData.clientData[v3].authoritativePhysicsObjectDynamicBoneMappingCount = physicsObjectDynamicBoneMappingCount;
}

/*
==============
Physics_SetCGPhysicsObjectDetailPropagationDebugData
==============
*/
void Physics_SetCGPhysicsObjectDetailPropagationDebugData(LocalClientNum_t localClientNum, int detailBoundedCount, int duplicationCount, int duplicationBodyCount)
{
  __int64 v4; 

  v4 = localClientNum;
  s_debugProfileData.clientData[v4].physicsObjectDetailBoundedCount = detailBoundedCount;
  s_debugProfileData.clientData[v4].physicsObjectDetailDuplicationCount = duplicationCount;
  s_debugProfileData.clientData[v4].physicsObjectDetailDuplicationBodyCount = duplicationBodyCount;
}

/*
==============
Physics_SetCGPhysicsObjectPredictiveDebugData
==============
*/
void Physics_SetCGPhysicsObjectPredictiveDebugData(LocalClientNum_t localClientNum, int numPhysicsObjects, int numPhysicsObjectsNeedingUpdate, int numPhysicsObjectsNeedingFullUpdate, int physicsObjectChildHavingCount, int physicsObjectChildCount, int physicsObjectDynamicBoneMappingHavingCount, int physicsObjectDynamicBoneMappingCount, int physicsObjectKeyframedBoneMappingHavingCount, int physicsObjectKeyframedBoneMappingCount, int physicsObjectKeyframedBoneMappingHavingCountUpdated, int physicsObjectKeyframedBoneMappingCountUpdated, int physicsObjectKeyframedOffsetMappingHavingCount, int physicsObjectKeyframedOffsetMappingCount, int physicsObjectKeyframedOffsetMappingHavingCountUpdated, int physicsObjectKeyframedOffsetMappingCountUpdated)
{
  __int64 v16; 

  v16 = localClientNum;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectChildHavingCount = physicsObjectChildHavingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectChildCount = physicsObjectChildCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectDynamicBoneMappingHavingCount = physicsObjectDynamicBoneMappingHavingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectDynamicBoneMappingCount = physicsObjectDynamicBoneMappingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedBoneMappingHavingCount = physicsObjectKeyframedBoneMappingHavingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedBoneMappingCount = physicsObjectKeyframedBoneMappingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedBoneMappingHavingCountUpdated = physicsObjectKeyframedBoneMappingHavingCountUpdated;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedBoneMappingCountUpdated = physicsObjectKeyframedBoneMappingCountUpdated;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedOffsetMappingHavingCount = physicsObjectKeyframedOffsetMappingHavingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedOffsetMappingCount = physicsObjectKeyframedOffsetMappingCount;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedOffsetMappingHavingCountUpdated = physicsObjectKeyframedOffsetMappingHavingCountUpdated;
  s_debugProfileData.clientData[v16].predictivePhysicsObjectKeyframedOffsetMappingCountUpdated = physicsObjectKeyframedOffsetMappingCountUpdated;
  s_debugProfileData.clientData[v16].numPredictivePhysicsObjects = numPhysicsObjects;
  s_debugProfileData.clientData[v16].numPredictivePhysicsObjectsNeedingUpdate = numPhysicsObjectsNeedingUpdate;
  s_debugProfileData.clientData[v16].numPredictivePhysicsObjectsNeedingFullUpdate = numPhysicsObjectsNeedingFullUpdate;
}

/*
==============
Physics_SetCGPhysicsObjectPropagatedDebugData
==============
*/
void Physics_SetCGPhysicsObjectPropagatedDebugData(LocalClientNum_t localClientNum, int numPropagatedPhysicsObjects, int numPropagatedBodies)
{
  __int64 v3; 

  v3 = localClientNum;
  s_debugProfileData.clientData[v3].numPropagatedPhysicsObjects = numPropagatedPhysicsObjects;
  s_debugProfileData.clientData[v3].numPropagatedBodies = numPropagatedBodies;
}

/*
==============
Physics_SetDebugCameras
==============
*/
void Physics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 12928, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Debug Cameras when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_SetDebugCameras(viewInfo);
}

/*
==============
Physics_SetErrorString
==============
*/

void __fastcall Physics_SetErrorString(const char *string)
{
  HavokPhysics_SetErrorString(string);
}

/*
==============
Physics_SetInstanceContents
==============
*/
void Physics_SetInstanceContents(Physics_WorldId worldId, unsigned int instanceId, int contents)
{
  signed int v6; 
  int NumRigidBodys; 
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6442, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Instance contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6443, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Instance contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6444, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Set Instance contents with invalid instance %i", "instanceId != PHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  v6 = 0;
  NumRigidBodys = Physics_GetNumRigidBodys(worldId, instanceId);
  if ( NumRigidBodys > 0 )
  {
    do
      Physics_SetRigidBodyContents(worldId, instanceId, v6++, contents, 0);
    while ( v6 < NumRigidBodys );
  }
}

/*
==============
Physics_SetInstanceDetailModel
==============
*/
void Physics_SetInstanceDetailModel(const Physics_WorldId worldId, const unsigned int instanceId, const XModel *const xmodel)
{
  __int64 v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5864, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Instance detail model Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5865, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Instance detail model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5866, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Instance model Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5867, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Set Instance model Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v6) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5868, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Set Instance model Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v6) )
      __debugbreak();
  }
  if ( !xmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5869, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tPhysics: Trying to Set null Instance model detail Asset", "xmodel") )
    __debugbreak();
  HavokPhysics_SetInstanceDetailModel(worldId, instanceId, xmodel);
}

/*
==============
Physics_SetInstanceXModel
==============
*/
void Physics_SetInstanceXModel(const Physics_WorldId worldId, const unsigned int instanceId, const XModel *const xmodel)
{
  __int64 v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5848, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Instance model Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5849, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5850, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Set Instance model Asset with invalid instance Id in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(worldId - 2) <= 5 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5851, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Set Instance model Asset in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v6) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)worldId <= PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5852, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Set Instance model Asset in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v6) )
      __debugbreak();
  }
  HavokPhysics_SetInstanceXModel(worldId, instanceId, xmodel);
}

/*
==============
Physics_SetMainShapeList
==============
*/
void Physics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3848, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to SetMainShapeList when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_SetMainShapeList(shapeList);
}

/*
==============
Physics_SetMapLocalAllocatorBuffer
==============
*/
void Physics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  __int64 v4; 

  if ( !buffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1583, ASSERT_TYPE_ASSERT, "( buffer ) != ( nullptr )", "%s != %s\n\t%p, %p", "buffer", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !size )
  {
    LODWORD(v4) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1584, ASSERT_TYPE_ASSERT, "( size ) > ( 0 )", "%s > %s\n\t%u, %u", "size", "0", v4, 0i64) )
      __debugbreak();
  }
  HavokPhysics_SetMapLocalAllocatorBuffer(buffer, size);
}

/*
==============
Physics_SetMassPropertiesCenterOfMass
==============
*/
void Physics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, const vec3_t *centerOfMass)
{
  hkVector4f centerOfMassa; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10171, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to SetMassPropertiesCenterOfMass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !massProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10172, ASSERT_TYPE_ASSERT, "(massProperties)", "%s\n\tPhysics: Trying to SetMassPropertiesCenterOfMass with NULL mass properties", "massProperties") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+58h+centerOfMass.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+58h+centerOfMass.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+58h+centerOfMass.m_quad], xmm0
    vmovss  dword ptr [rsp+58h+centerOfMass.m_quad+8], xmm1
  }
  HavokPhysics_SetMassPropertiesCenterOfMass(massProperties, &centerOfMassa);
}

/*
==============
Physics_SetMassPropertiesInertiaTensor
==============
*/
void Physics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, const vec3_t *inertiaTensor)
{
  hkVector4f inertiaTensora; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10186, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to SetMassPropertiesInertiaTensor when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !massProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10187, ASSERT_TYPE_ASSERT, "(massProperties)", "%s\n\tPhysics: Trying to SetMassPropertiesInertiaTensor with NULL mass properties", "massProperties") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+58h+inertiaTensor.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+58h+inertiaTensor.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+58h+inertiaTensor.m_quad], xmm0
    vmovss  dword ptr [rsp+58h+inertiaTensor.m_quad+8], xmm1
  }
  HavokPhysics_SetMassPropertiesInertiaTensor(massProperties, &inertiaTensora);
}

/*
==============
Physics_SetMassPropertiesMass
==============
*/

void __fastcall Physics_SetMassPropertiesMass(hkMassProperties *massProperties, double mass)
{
  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10158, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to SetMassPropertiesMass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( !massProperties && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 10159, ASSERT_TYPE_ASSERT, "(massProperties)", "%s\n\tPhysics: Trying to SetMassPropertiesMass with NULL mass properties", "massProperties") )
    __debugbreak();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
    vmovaps xmm1, xmm6; mass
    vmovaps xmm6, [rsp+48h+var_18]
  }
  HavokPhysics_SetMassPropertiesMass(massProperties, *(float *)&_XMM1);
}

/*
==============
Physics_SetNoBroadphaseQueriesAllowed
==============
*/
void Physics_SetNoBroadphaseQueriesAllowed(Physics_WorldId worldId, bool noQueriesAllowed)
{
  __int64 v2; 
  bool *v4; 

  v2 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8361, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  v4 = &g_physicsBroadphaseQueriesNotAllowedForWorld[v2];
  if ( *v4 == noQueriesAllowed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8362, ASSERT_TYPE_ASSERT, "(g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] != noQueriesAllowed)", (const char *)&queryFormat, "g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] != noQueriesAllowed") )
    __debugbreak();
  *v4 = noQueriesAllowed;
}

/*
==============
Physics_SetNoQueriesAllowed
==============
*/
void Physics_SetNoQueriesAllowed(Physics_WorldId worldId, bool noQueriesAllowed)
{
  __int64 v2; 
  bool *v4; 

  v2 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8378, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  v4 = &g_physicsQueriesNotAllowedForWorld[v2];
  if ( *v4 == noQueriesAllowed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8379, ASSERT_TYPE_ASSERT, "(g_physicsQueriesNotAllowedForWorld[worldId] != noQueriesAllowed)", (const char *)&queryFormat, "g_physicsQueriesNotAllowedForWorld[worldId] != noQueriesAllowed") )
    __debugbreak();
  *v4 = noQueriesAllowed;
}

/*
==============
Physics_SetRigidBodyCenterOfMass
==============
*/
void Physics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *centerOfMass)
{
  __int64 v10; 
  Physics_WorldId v11; 
  hkVector4f centerOfMassa; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6327, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Rigid Body center of mass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v11 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6328, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to set Rigid Body center of mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6329, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to set Body center of mass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v10) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+68h+centerOfMass.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+68h+centerOfMass.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+68h+centerOfMass.m_quad], xmm0
    vmovss  dword ptr [rsp+68h+centerOfMass.m_quad+8], xmm1
  }
  HavokPhysics_SetRigidBodyCenterOfMass(worldId, (hknpBodyId)bodyId, &centerOfMassa);
}

/*
==============
Physics_SetRigidBodyContents
==============
*/
void Physics_SetRigidBodyContents(Physics_WorldId worldId, unsigned int bodyId, int contents, bool forceCacheRebuild)
{
  Physics_WorldId v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6484, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v8 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6485, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyContents(worldId, (hknpBodyId)bodyId, contents, forceCacheRebuild);
}

/*
==============
Physics_SetRigidBodyContents
==============
*/
void Physics_SetRigidBodyContents(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIdx, int contents, bool forceCacheRebuild)
{
  hknpBodyId v9; 
  __int64 v10; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6466, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6467, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6468, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Set RigidBody contents with invalid instance %i", "instanceId != PHYSICSINSTANCEID_INVALID", v10) )
      __debugbreak();
  }
  if ( bodyIdx >= Physics_GetNumRigidBodys(worldId, instanceId) )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6469, ASSERT_TYPE_ASSERT, "(bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId ))", "%s\n\tPhysics: Trying to Set RigidBody contents with invalid bodyIdx %i %i", "bodyIdx < Physics_GetNumRigidBodys( worldId, instanceId )", v10, bodyIdx) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  v9.m_serialAndIndex = Physics_GetRigidBodyID(worldId, instanceId, bodyIdx);
  if ( (v9.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6475, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyId )") )
    __debugbreak();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6484, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody contents when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6485, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyContents(worldId, v9, contents, forceCacheRebuild);
}

/*
==============
Physics_SetRigidBodyDynamic
==============
*/
void Physics_SetRigidBodyDynamic(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v4; 
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6599, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody Dynamic when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6600, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6601, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set RigidBody Dynamic with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v4) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyDynamic(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_SetRigidBodyInverseInertiaLocal
==============
*/
void Physics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, unsigned int bodyId, const vec4_t *invInertia)
{
  __int64 v11; 
  Physics_WorldId v12; 
  hkVector4f invInertiaa; 

  _RSI = invInertia;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6344, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Rigid Body inertia local when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v12 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6345, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to set Rigid Body inertia local with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v12) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6346, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to set Body inertia local with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v11) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@44800000
    vmulss  xmm2, xmm3, dword ptr [rsi+4]
    vmulss  xmm0, xmm3, dword ptr [rsi]
    vmulss  xmm1, xmm3, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+68h+invInertia.m_quad+4], xmm2
    vmovss  xmm2, dword ptr [rsi+0Ch]
    vmovss  dword ptr [rsp+68h+invInertia.m_quad+0Ch], xmm2
    vmovss  dword ptr [rsp+68h+invInertia.m_quad], xmm0
    vmovss  dword ptr [rsp+68h+invInertia.m_quad+8], xmm1
  }
  HavokPhysics_SetRigidBodyInverseInertiaLocal(worldId, (hknpBodyId)bodyId, &invInertiaa);
}

/*
==============
Physics_SetRigidBodyKeyframed
==============
*/
void Physics_SetRigidBodyKeyframed(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v4; 
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6586, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody Keyframed when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6587, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6588, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set RigidBody keyframed with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v4) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyKeyframed(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_SetRigidBodyMass
==============
*/

void __fastcall Physics_SetRigidBodyMass(Physics_WorldId worldId, unsigned int bodyId, double mass)
{
  __int64 v9; 
  Physics_WorldId v10; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6641, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody Mass when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v10 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6642, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6643, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set RigidBody Mass with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v9) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovaps xmm2, xmm6; mass
    vmovaps xmm6, [rsp+58h+var_18]
  }
  HavokPhysics_SetRigidBodyMass(worldId, (hknpBodyId)bodyId, *(float *)&_XMM2);
}

/*
==============
Physics_SetRigidBodyStatic
==============
*/
void Physics_SetRigidBodyStatic(Physics_WorldId worldId, unsigned int bodyId)
{
  __int64 v4; 
  Physics_WorldId v5; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6613, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody Static when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v5 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6614, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6615, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set RigidBody Static with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v4) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyStatic(worldId, (hknpBodyId)bodyId);
}

/*
==============
Physics_SetRigidBodyToDefault
==============
*/
void Physics_SetRigidBodyToDefault(Physics_WorldId worldId, unsigned int bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  __int64 v8; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6627, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set RigidBody To Default when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6628, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set RigidBody Default with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6629, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set RigidBody Default with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v8) )
      __debugbreak();
  }
  if ( !asset )
  {
    LODWORD(v8) = bodyId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6630, ASSERT_TYPE_ASSERT, "(asset)", "%s\n\tPhysics: Trying to Set RigidBody %i Default with invalid asset in world %i", "asset", v8, worldId) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_SetRigidBodyToDefault(worldId, (hknpBodyId)bodyId, asset, assetIndex);
}

/*
==============
Physics_SetRigidBodyVelocity
==============
*/
void Physics_SetRigidBodyVelocity(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *linearVelocity, const vec3_t *angularVelocity)
{
  __int64 v23; 
  Physics_WorldId v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  hkVector4f hkLinVel; 
  hkVector4f hkAngVel; 

  _RBX = angularVelocity;
  _RDI = linearVelocity;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6980, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Rigid Body Velocity when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v24 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6981, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Rigid Body Velocity with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v24) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6982, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Set Rigid Body Velocity with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v23) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
    goto LABEL_23;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_23;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
  {
LABEL_23:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6983, ASSERT_TYPE_ASSERT, "(!IS_NAN( linearVelocity[0] ) && !IS_NAN( linearVelocity[1] ) && !IS_NAN( linearVelocity[2] ))", "%s\n\tPhysics: Trying to Set Rigid Body Velocity with invalid linvel", "!IS_NAN( linearVelocity[0] ) && !IS_NAN( linearVelocity[1] ) && !IS_NAN( linearVelocity[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6984, ASSERT_TYPE_ASSERT, "(!IS_NAN( angularVelocity[0] ) && !IS_NAN( angularVelocity[1] ) && !IS_NAN( angularVelocity[2] ))", "%s\n\tPhysics: Trying to Set Rigid Body Velocity with invalid angvel", "!IS_NAN( angularVelocity[0] ) && !IS_NAN( angularVelocity[1] ) && !IS_NAN( angularVelocity[2] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+88h+hkLinVel.m_quad], xmm0
    vxorps  xmm0, xmm0, xmm0
    vinsertps xmm0, xmm0, dword ptr [rbx], 0
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vmovss  dword ptr [rsp+88h+hkLinVel.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+88h+hkAngVel.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+hkLinVel.m_quad+8], xmm1
    vmovss  dword ptr [rsp+88h+hkLinVel.m_quad+0Ch], xmm2
  }
  HavokPhysics_SetRigidBodyVelocity(worldId, (hknpBodyId)bodyId, &hkLinVel, &hkAngVel);
}

/*
==============
Physics_SetThreadHeapAllocationGeneral
==============
*/

void __fastcall Physics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  HavokPhysics_SetThreadHeapAllocationGeneral(threadId);
}

/*
==============
Physics_SetThreadHeapAllocationMapLocal
==============
*/

void __fastcall Physics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  HavokPhysics_SetThreadHeapAllocationMapLocal(threadId);
}

/*
==============
Physics_SetWorkerError
==============
*/
void Physics_SetWorkerError(void)
{
  s_physicsHasWorkerError = 1;
}

/*
==============
Physics_SetupBootDvars
==============
*/
void Physics_SetupBootDvars(void)
{
  physics_debugMemoryEnable = Dvar_RegisterInt("NTTKLMLOOS", 0, 0, 1, 4u, "Enables memory for physics debugging features");
}

/*
==============
Physics_SetupClientWorldCInfos
==============
*/
void Physics_SetupClientWorldCInfos()
{
  bool v5; 
  int maxNumRigidBodiesClient; 
  const dvar_t *v7; 
  int maxNumDetailRigidBodiesClient; 
  const dvar_t *v9; 
  int maxNumConstraintsClient; 
  const dvar_t *v11; 
  int maxNumMotionsClient; 
  const dvar_t *v13; 
  int maxNumRigidBodiesServer; 
  const dvar_t *v15; 
  const dvar_t *v16; 
  int maxNumMotionsServer; 
  const dvar_t *v18; 
  const dvar_t *v24; 
  __int64 v40; 
  int v41; 
  __int64 v42; 
  int v43; 
  char v45; 
  void *retaddr; 

  _RAX = &retaddr;
  v5 = s_physicsWorldPersistentBufferSizeClientPredictive == NULL;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
  }
  if ( v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 877, ASSERT_TYPE_ASSERT, "(s_physicsWorldPersistentBufferSizeClientPredictive)", (const char *)&queryFormat, "s_physicsWorldPersistentBufferSizeClientPredictive") )
    __debugbreak();
  if ( !s_physicsWorldPersistentBufferSizeClientAuthoritative && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 878, ASSERT_TYPE_ASSERT, "(s_physicsWorldPersistentBufferSizeClientAuthoritative)", (const char *)&queryFormat, "s_physicsWorldPersistentBufferSizeClientAuthoritative") )
    __debugbreak();
  if ( !s_physicsWorldPersistentBufferSizeClientDetail && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 879, ASSERT_TYPE_ASSERT, "(s_physicsWorldPersistentBufferSizeClientDetail)", (const char *)&queryFormat, "s_physicsWorldPersistentBufferSizeClientDetail") )
    __debugbreak();
  maxNumRigidBodiesClient = cm.physicsCapacities.maxNumRigidBodiesClient;
  if ( !cm.physicsCapacities.maxNumRigidBodiesClient )
  {
    v7 = DVARINT_physics_MaxNumClientBodies;
    if ( !DVARINT_physics_MaxNumClientBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumClientBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    maxNumRigidBodiesClient = v7->current.integer;
  }
  maxNumDetailRigidBodiesClient = cm.physicsCapacities.maxNumDetailRigidBodiesClient;
  if ( !cm.physicsCapacities.maxNumDetailRigidBodiesClient )
  {
    v9 = DVARINT_physics_MaxNumClientDetailBodies;
    if ( !DVARINT_physics_MaxNumClientDetailBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumClientDetailBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    maxNumDetailRigidBodiesClient = v9->current.integer;
  }
  maxNumConstraintsClient = cm.physicsCapacities.maxNumConstraintsClient;
  if ( !cm.physicsCapacities.maxNumConstraintsClient )
  {
    v11 = DVARINT_physics_MaxNumClientConstraints;
    if ( !DVARINT_physics_MaxNumClientConstraints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumClientConstraints") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    maxNumConstraintsClient = v11->current.integer;
  }
  maxNumMotionsClient = cm.physicsCapacities.maxNumMotionsClient;
  if ( !cm.physicsCapacities.maxNumMotionsClient )
  {
    v13 = DVARINT_physics_MaxNumClientMotions;
    if ( !DVARINT_physics_MaxNumClientMotions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumClientMotions") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    maxNumMotionsClient = v13->current.integer;
  }
  maxNumRigidBodiesServer = cm.physicsCapacities.maxNumRigidBodiesServer;
  if ( !cm.physicsCapacities.maxNumRigidBodiesServer )
  {
    v15 = DVARINT_physics_MaxNumServerBodies;
    if ( !DVARINT_physics_MaxNumServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    maxNumRigidBodiesServer = v15->current.integer;
  }
  if ( !cm.physicsCapacities.maxNumDetailRigidBodiesServer )
  {
    v16 = DVARINT_physics_MaxNumServerDetailBodies;
    if ( !DVARINT_physics_MaxNumServerDetailBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerDetailBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
  }
  maxNumMotionsServer = cm.physicsCapacities.maxNumMotionsServer;
  if ( !cm.physicsCapacities.maxNumMotionsServer )
  {
    v18 = DVARINT_physics_MaxNumServerMotions;
    if ( !DVARINT_physics_MaxNumServerMotions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerMotions") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v18);
    maxNumMotionsServer = v18->current.integer;
  }
  if ( cm.mapEnts )
  {
    maxNumRigidBodiesClient += cm.mapEnts->scriptableMapEnts.physicsLimits.clientStandaloneMainRigidBodyCount;
    maxNumDetailRigidBodiesClient += cm.mapEnts->scriptableMapEnts.physicsLimits.clientStandaloneDetailedRigidBodyCount;
    maxNumMotionsClient += cm.mapEnts->scriptableMapEnts.physicsLimits.clientStandaloneMotionCount;
    maxNumRigidBodiesServer += cm.mapEnts->scriptableMapEnts.physicsLimits.serverStandaloneMainRigidBodyCount;
    maxNumMotionsServer += cm.mapEnts->scriptableMapEnts.physicsLimits.serverStandaloneMotionCount;
  }
  if ( maxNumRigidBodiesServer > 0xFFFFFF )
  {
    v43 = 0xFFFFFF;
    v41 = maxNumRigidBodiesServer;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 905, ASSERT_TYPE_ASSERT, "( serverRigidBodyMax ) <= ( 0xffffff )", "%s <= %s\n\t%i, %i", "serverRigidBodyMax", "PHYSICS_HARD_MAX_BODIES_PER_WORLD", v41, v43) )
      __debugbreak();
  }
  if ( maxNumRigidBodiesClient > 0xFFFFFF )
  {
    LODWORD(v42) = 0xFFFFFF;
    LODWORD(v40) = maxNumRigidBodiesClient;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 906, ASSERT_TYPE_ASSERT, "( clientRigidBodyMax ) <= ( 0xffffff )", "%s <= %s\n\t%i, %i", "clientRigidBodyMax", "PHYSICS_HARD_MAX_BODIES_PER_WORLD", v40, v42) )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, cs:__xmm@43c10b8541dc00003ecccccd3d4ccccd
    vmovss  xmm6, cs:__real@3fc00000
    vmovss  xmm7, cs:__real@3f19999a
    vmovss  xmm8, cs:__real@3f800000
    vmovss  xmm9, cs:__real@3c888889
  }
  s_physicsWorldCInfos[2].motionCountMax = maxNumMotionsServer;
  s_physicsWorldCInfos[2].systemCountMax = maxNumRigidBodiesServer;
  s_physicsWorldCInfos[2].persistentBuffer = NULL;
  s_physicsWorldCInfos[2].persistentBufferSize = 0;
  *(_QWORD *)&s_physicsWorldCInfos[2].adjustSolverSettingsOnTimestep = 0i64;
  s_physicsWorldCInfos[3].persistentBuffer = NULL;
  s_physicsWorldCInfos[3].persistentBufferSize = 0;
  __asm
  {
    vmovss  cs:s_physicsWorldCInfos.collisionTolerance+0A0h, xmm6
    vmovss  cs:s_physicsWorldCInfos.solverStrength+0A0h, xmm7
    vmovss  cs:s_physicsWorldCInfos.solverDamping+0A0h, xmm8
    vmovss  cs:s_physicsWorldCInfos.defaultTimeStep+0A0h, xmm9
    vmovss  cs:s_physicsWorldCInfos.collisionTolerance+0F0h, xmm6
    vmovss  cs:s_physicsWorldCInfos.solverStrength+0F0h, xmm7
    vmovss  cs:s_physicsWorldCInfos.solverDamping+0F0h, xmm8
    vmovss  cs:s_physicsWorldCInfos.defaultTimeStep+0F0h, xmm9
  }
  s_physicsWorldCInfos[2].bodyCountMax = maxNumRigidBodiesServer;
  s_physicsWorldCInfos[2].constraintCountMax = 1;
  __asm { vmovups xmmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+0A0h, xmm0 }
  s_physicsWorldCInfos[2].solverIterations = 4;
  s_physicsWorldCInfos[3].systemCountMax = maxNumRigidBodiesClient;
  s_physicsWorldCInfos[3].bodyCountMax = maxNumRigidBodiesClient;
  s_physicsWorldCInfos[3].motionCountMax = maxNumMotionsClient;
  s_physicsWorldCInfos[3].constraintCountMax = maxNumConstraintsClient;
  __asm { vmovups xmmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+0F0h, xmm0 }
  s_physicsWorldCInfos[3].solverIterations = 4;
  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x100) )
    goto LABEL_58;
  v24 = DVARBOOL_physics_killswitchEnableDontAdjustSolverSettingsOnTimestep;
  if ( !DVARBOOL_physics_killswitchEnableDontAdjustSolverSettingsOnTimestep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableDontAdjustSolverSettingsOnTimestep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v24);
  v5 = !v24->current.enabled;
  s_physicsWorldCInfos[3].adjustSolverSettingsOnTimestep = 0;
  if ( v5 )
LABEL_58:
    s_physicsWorldCInfos[3].adjustSolverSettingsOnTimestep = 1;
  __asm
  {
    vmovups xmm0, cs:__xmm@43c10b8541dc00003ecccccd3d4ccccd
    vmovups ymm1, ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+0A0h
    vmovups xmmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+140h, xmm0
    vmovups ymm0, ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+0A0h
  }
  _R11 = &v45;
  s_physicsWorldCInfos[4].systemCountMax = maxNumRigidBodiesClient;
  __asm
  {
    vmovups ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+190h, ymm0
    vmovups xmm0, xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+0A0h
    vmovups xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+190h, xmm0
    vmovups ymm0, ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+0F0h
    vmovups ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+190h, ymm1
    vmovups ymm1, ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+0F0h
    vmovups ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+1E0h, ymm0
    vmovss  cs:s_physicsWorldCInfos.collisionTolerance+140h, xmm6
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovups ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+1E0h, ymm1
    vmovss  cs:s_physicsWorldCInfos.solverStrength+140h, xmm7
    vmovaps xmm7, [rsp+0B8h+var_48]
    vmovss  cs:s_physicsWorldCInfos.solverDamping+140h, xmm8
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovss  cs:s_physicsWorldCInfos.defaultTimeStep+140h, xmm9
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  *(_WORD *)&s_physicsWorldCInfos[3].isMultiThreaded = 257;
  s_physicsWorldCInfos[3].visualizeWithCloth = 1;
  s_physicsWorldCInfos[3].maxRagdolls = 64;
  __asm { vmovups xmm1, xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+0F0h }
  s_physicsWorldCInfos[4].bodyCountMax = maxNumDetailRigidBodiesClient;
  s_physicsWorldCInfos[4].motionCountMax = 1;
  s_physicsWorldCInfos[4].constraintCountMax = 1;
  s_physicsWorldCInfos[4].persistentBuffer = NULL;
  s_physicsWorldCInfos[4].persistentBufferSize = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+140h
    vmovups ymmword ptr cs:s_physicsWorldCInfos.systemCountMax+230h, ymm0
  }
  s_physicsWorldCInfos[4].solverIterations = 4;
  *(_WORD *)&s_physicsWorldCInfos[4].isMultiThreaded = 0;
  s_physicsWorldCInfos[4].visualizeWithCloth = 1;
  s_physicsWorldCInfos[4].maxRagdolls = 0;
  s_physicsWorldCInfos[4].adjustSolverSettingsOnTimestep = 0;
  __asm
  {
    vmovups xmm0, xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+140h
    vmovups xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+1E0h, xmm1
    vmovups ymm1, ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+140h
    vmovups xmmword ptr cs:s_physicsWorldCInfos.defaultTimeMS+230h, xmm0
    vmovups ymmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+230h, ymm1
  }
}

/*
==============
Physics_SetupDvars
==============
*/

void __fastcall Physics_SetupDvars(__int64 a1, __int64 a2, double _XMM2_8)
{
  const dvar_t *v22; 
  const dvar_t *v29; 
  const dvar_t *v37; 
  const dvar_t *v45; 
  const dvar_t *v53; 
  const dvar_t *v63; 
  const dvar_t *v72; 
  const dvar_t *v79; 
  float flags; 
  float flagsa; 
  float flagsb; 
  float flagsc; 
  float flagsd; 
  float flagse; 
  float flagsf; 
  float flagsg; 
  float flagsh; 
  float flagsi; 
  float description; 
  float descriptiona; 
  float descriptionb; 
  float descriptionc; 
  float descriptiond; 
  float descriptione; 
  float v159; 
  float v160; 
  float v161; 
  float v162; 
  float v163; 
  float v164; 
  char v165; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm13
  }
  Dvar_BeginPermanentRegistration();
  DVARSTR_physics_HavokPhysicsLicense = Dvar_RegisterString("NPTRLNOPS", "0x3e0db513-0x05f256b0:2021-07-05.Physics.InfinityWard_CallofDutyInfiniteWarfare2019_PS4-Windows-XboxOne", 0, "Havok Physics License dvar");
  DVARSTR_physics_HavokClothLicense = Dvar_RegisterString("PSQKKLKSL", "0x50120c42-0x6bedefe1:2021-07-05.Cloth.InfinityWard_CallofDutyInfiniteWarfare2019_PS4-Windows-XboxOne", 0, "Havok Cloth License dvar");
  DVARINT_physics_MaxNumServerBodies = Dvar_RegisterInt("MKSSOOTQNM", 2048, 0, 0xFFFFFF, 4u, "Set Maximum number of rigid bodies on the server");
  DVARINT_physics_MaxNumServerDetailBodies = Dvar_RegisterInt("MOKOKSQMT", 4096, 0, 0xFFFFFF, 4u, "Set Maximum number of detail rigid bodies on the server");
  DVARINT_physics_MaxNumServerConstraints = Dvar_RegisterInt("NSPRQNOQSK", 100, 0, 0xFFFFFF, 4u, "Set Maximum number of constraints on the server");
  DVARINT_physics_MaxNumServerMotions = Dvar_RegisterInt("NLTTRSNSKR", 2048, 0, 0xFFFFFF, 4u, "Set Maximum number of motions on the server");
  DVARINT_physics_MaxNumClientBodies = Dvar_RegisterInt("NSTNQMNKQK", 6144, 0, 0xFFFFFF, 4u, "Set Maximum number of rigid bodies on the client");
  DVARINT_physics_MaxNumClientDetailBodies = Dvar_RegisterInt("NORNMSRTLN", 10240, 0, 0xFFFFFF, 4u, "Set Maximum number of detail rigid bodies on the client");
  DVARINT_physics_MaxNumClientConstraints = Dvar_RegisterInt("MRQOQRQTKS", 1800, 0, 0xFFFFFF, 4u, "Set Maximum number of constraints on the client");
  DVARINT_physics_MaxNumClientMotions = Dvar_RegisterInt("OLSPPSNROR", 5120, 0, 0xFFFFFF, 4u, "Set Maximum number of motions on the client");
  DVARINT_physics_ExtraLootServerBodies = Dvar_RegisterInt("LKMLSQLSSS", 1024, 0, 2048, 4u, "Number of extra rigid bodies we allocate when loot system is active");
  DVARINT_physics_ExtraPlayerServerBodies = Dvar_RegisterInt("MKMMPMRRTT", 4, 0, 128, 4u, "Number of extra rigid bodies we allocate on the server per client");
  __asm
  {
    vmovss  xmm7, cs:__real@47c35000
    vmovss  xmm1, cs:__real@40400000; value
  }
  DVARINT_physics_RadiusForceHitLimit = Dvar_RegisterInt("OLPQQNNNQS", 20, 0, 100, 0x40u, "Maximum number of entities moved on client or server by a radius force (explosion)");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm11, cs:__real@40800000
  }
  DCONST_DVARFLT_physics_RadiusForceMassLimit = Dvar_RegisterFloat("physics_RadiusForceMassLimit", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mass limit, below which we drop off radius force to prevent small objects from going flying");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm11; value
  }
  DCONST_DVARFLT_physics_RadiusForceUpOffset = Dvar_RegisterFloat("physics_RadiusForceUpOffset", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Vertical offset of force applied from radius force (explosion) - used to apply rotation to objects");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm11; value
  }
  v22 = Dvar_RegisterFloat("physics_RadiusForceRandomOffset", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Random offset of force applied from radius force (explosion) - used to apply rotation to objects");
  __asm { vmovss  xmm1, cs:__real@3f000000; value }
  DCONST_DVARFLT_physics_RadiusForceRandomOffset = v22;
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_physics_RadiusForceUpBias = Dvar_RegisterFloat("physics_RadiusForceUpBias", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "How much we want to make objects go up during an explosion");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm1, cs:__real@451c4000; value
  }
  v29 = Dvar_RegisterFloat("physics_RadiusForceMax", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Max Force applied from radius force (explosion)");
  __asm { vmovss  xmm1, cs:__real@40400000; value }
  DCONST_DVARFLT_physics_RadiusForceMax = v29;
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm13, cs:__real@43fa0000
  }
  DCONST_DVARFLT_physics_BulletForceMassLimit = Dvar_RegisterFloat("physics_BulletForceMassLimit", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Mass limit, below which we drop off bullet force to prevent small objects from going flying");
  __asm
  {
    vmovaps xmm1, xmm13; value
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v37 = Dvar_RegisterFloat("physics_BulletForceDefault", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Force applied from bullet hit");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm13; value
  }
  DCONST_DVARFLT_physics_BulletForceDefault = v37;
  DCONST_DVARFLT_physics_BulletForceRagdoll = Dvar_RegisterFloat("physics_BulletForceRagdoll", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Force applied from bullet hit");
  DVARBOOL_physics_allowQueryDisabling = Dvar_RegisterBool("NSKPNLRNOR", 1, 4u, "Allow the engine to disable queries");
  DVARBOOL_physics_disableSpammyWarnings = Dvar_RegisterBool("LNOMRSSOPP", 0, 4u, "Turn off spammy warnings");
  DCONST_DVARINT_physics_ExtraClientAuthFixedMemory = Dvar_RegisterInt("physics_ExtraClientAuthFixedMemory", 0, 0, 200000000, 0x40004u, "Extra memory for client auth fixed physics pool");
  __asm
  {
    vmovss  xmm10, cs:__real@447a0000
    vmovss  xmm3, cs:__real@461c4000; max
  }
  DVARBOOL_physics_enableCharacterSoftBody = Dvar_RegisterBool("LPLMNTRPQR", 0, 4u, "Enable Character Proxy Soft Body");
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm10; value
  }
  v45 = Dvar_RegisterFloat("physics_characterSoftBodyDistance", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Character Proxy Soft Body activation Distance");
  __asm
  {
    vmovss  xmm3, cs:__real@461c4000; max
    vmovss  xmm1, cs:__real@437a0000; value
  }
  DCONST_DVARFLT_physics_characterSoftBodyDistance = v45;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  xmm9, cs:__real@3f800000
  }
  DCONST_DVARFLT_physics_characterProxyClientDistance = Dvar_RegisterFloat("physics_characterProxyClientDistance", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Character Proxy Clients out of this range and out of view have no proxy collision");
  __asm
  {
    vmovss  xmm1, cs:__real@3f000000; value
    vmovaps xmm3, xmm9; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v53 = Dvar_RegisterFloat("physics_characterProxyClientCosFOV", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Character Proxy Clients out of this fov and out of range have no proxy collision");
  __asm { vmovss  xmm3, cs:__real@453b8000; max }
  DCONST_DVARFLT_physics_characterProxyClientCosFOV = v53;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vxorps  xmm1, xmm1, xmm1; value
  }
  DVARFLT_physics_shapecastMaxDist = Dvar_RegisterFloat("LPPQLMRSNN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Max distance permitted for a Physics_Shapecast operation. A value of 0 means that we shouldn't evaluate this constraint.");
  __asm
  {
    vmovaps xmm3, xmm13; max
    vxorps  xmm2, xmm2, xmm2; min
    vxorps  xmm1, xmm1, xmm1; value
  }
  DVARFLT_physics_shapecastMaxRadius = Dvar_RegisterFloat("NOQQNLQTQN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Max radius permitted for a Physics_Shapecast operation. A value of 0 means that we shouldn't evaluate this constraint.");
  DVARBOOL_physics_debugTrackWorldMeshStats = Dvar_RegisterBool("SNKOPNNQN", 0, 0, "Debug draw world mesh stats");
  __asm { vmovss  xmm3, cs:__real@466a6000; max }
  DVARINT_physics_debugTrackWorldMeshDisplayArea = Dvar_RegisterEnum("MSOKPLNRLT", physics_debugTrackWorldMeshDisplayTypeNames, 0, 0, "Debug draw world mesh by area");
  __asm
  {
    vmovaps xmm2, xmm9; min
    vmovaps xmm1, xmm13; value
  }
  v63 = Dvar_RegisterFloat("MLSNOMLKQQ", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Debug draw world mesh by area - cheap threshold");
  __asm
  {
    vmovss  xmm3, cs:__real@466a6000; max
    vmovss  xmm1, cs:__real@42480000; value
  }
  DVARFLT_physics_debugTrackPerfWorldMeshDisplayAreaThresholdCheap = v63;
  __asm { vmovaps xmm2, xmm9; min }
  DVARFLT_physics_debugTrackPerfWorldMeshDisplayAreaThresholdExpensive = Dvar_RegisterFloat("MORTKOOTOM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Debug draw world mesh by area - expensive threshold");
  DVARBOOL_physics_debugTrackPerfServerWorlds = Dvar_RegisterBool("LTPKMNTTKQ", 0, 0, "Debug draw for tracking the server world update part of the frame");
  DVARBOOL_physics_debugTrackPerfPMoveHeatmap = Dvar_RegisterBool("MQLSQNTT", 0, 0, "Debug draw for pmove heatmap");
  __asm
  {
    vmovss  xmm6, cs:__real@43480000
    vmovss  xmm8, cs:__real@3dcccccd
  }
  DVARBOOL_physics_debugTrackPerfPMoveHeatmapShowCheap = Dvar_RegisterBool("LPQTSQLSRT", 1, 0, "Debug draw for move heatmap - show cheap samples");
  __asm
  {
    vmovaps xmm3, xmm6; max
    vmovss  xmm1, cs:__real@41a00000; value
    vmovaps xmm2, xmm8; min
  }
  v72 = Dvar_RegisterFloat("LTKSOTTTKR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Pmove debug draw heatmap - cheap threshold");
  __asm { vmovss  xmm1, cs:__real@41f00000; value }
  DVARFLT_physics_debugTrackPerfPMoveHeatmapThresholdCheap = v72;
  __asm
  {
    vmovaps xmm3, xmm6; max
    vmovaps xmm2, xmm8; min
  }
  DVARFLT_physics_debugTrackPerfPMoveHeatmapThresholdExpensive = Dvar_RegisterFloat("MMLQLSOLMR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Pmove debug draw heatmap - expensive threshold");
  DVARBOOL_physics_debugTrackPerfPMoveServer = Dvar_RegisterBool("TQRRPQLMM", 0, 0, "Debug draw for tracking pmove performance on the server");
  DVARBOOL_physics_debugTrackPerfPMoveClient = Dvar_RegisterBool("LNNNQQSOSQ", 0, 0, "Debug draw for tracking pmove performance on the client");
  DVARBOOL_physics_debugTrackPerfBulletHeatmap = Dvar_RegisterBool("LQNNPMTNKS", 0, 0, "Debug draw for bullet heatmap");
  __asm { vmovss  xmm1, cs:__real@41700000; value }
  DVARBOOL_physics_debugTrackPerfBulletHeatmapShowCheap = Dvar_RegisterBool("LPORLNSPQ", 1, 0, "Debug draw for bullet heatmap - show cheap samples");
  __asm
  {
    vmovaps xmm3, xmm6; max
    vmovaps xmm2, xmm8; min
  }
  v79 = Dvar_RegisterFloat("QPPPTRKSK", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Bullet debug draw heatmap - cheap threshold");
  __asm { vmovss  xmm1, cs:__real@41c80000; value }
  DVARFLT_physics_debugTrackPerfBulletHeatmapThresholdCheap = v79;
  __asm
  {
    vmovaps xmm3, xmm6; max
    vmovaps xmm2, xmm8; min
  }
  DVARFLT_physics_debugTrackPerfBulletHeatmapThresholdExpensive = Dvar_RegisterFloat("MKRPQLLQLM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Bullet debug draw heatmap - expensive threshold");
  DVARBOOL_physics_debugTrackPerfBulletServer = Dvar_RegisterBool("MQPMSLPTTR", 0, 0, "Debug draw for tracking bullets performance on the server");
  DVARBOOL_physics_debugTrackPerfBulletClient = Dvar_RegisterBool("OMOMQMPQSL", 0, 0, "Debug draw for tracking bullets performance on the client");
  DVARINT_physics_debugRaycasterMode = Dvar_RegisterEnum("LQSRLNKPMR", Physics_DebugRaycasterModeNames, 0, 0, "Debug draw raycaster mode");
  __asm
  {
    vmovaps xmm3, xmm6; max
    vmovaps xmm2, xmm9; min
    vmovss  xmm1, cs:__real@42200000; value
  }
  DVARFLT_physics_debugRaycasterMaxCost = Dvar_RegisterFloat("LPQSKMSNP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Debug draw raycaster maximum cost");
  DVARINT_physics_debugRaycasterRaysPerFrame = Dvar_RegisterInt("PKMRKKTNL", 1000, 100, 10000, 0, "Debug draw raycaster rays/frame");
  DVARBOOL_physicsFX_enableCallbacks = Dvar_RegisterBool("NSTRKPQLLQ", 1, 0, "Physics fx callbacks kill switch");
  DVARBOOL_physicsFX_debugPerformance = Dvar_RegisterBool("OKRMKOMNRS", 0, 4u, "Show physics fx performance");
  DVARBOOL_physicsFX_debugDrawFXPipelines = Dvar_RegisterBool("MRPROLRPOL", 0, 4u, "Show physics fx pipelines");
  DVARINT_physicsFX_debugDrawFXPipelineId = Dvar_RegisterInt("PQKKKSKPP", -1, -1, 10000, 4u, "Show details about a physics fx Pipeline");
  DVARBOOL_physicsFX_debugDrawFXShapes = Dvar_RegisterBool("LSRPKTMQRQ", 0, 4u, "Show physics fx Shapes");
  DVARINT_physicsFX_debugDrawFXShapeId = Dvar_RegisterInt("LLSONOSNKQ", -1, -1, 10000, 4u, "Show details about a physics fx Shape");
  DVARBOOL_physicsFX_debugDrawFXPipelineInstances = Dvar_RegisterBool("OONPSOPOO", 0, 4u, "Show physics fx pipeline instances");
  DVARINT_physicsFX_debugDrawFXPipelineInstanceId = Dvar_RegisterInt("LLQKTNQLTS", -1, -1, 10000, 4u, "Show details about a physics fx Pipeline instance");
  DVARBOOL_physicsFX_debugDrawFXPipelineInstanceDrawParticles = Dvar_RegisterBool("NSMRROLQSO", 0, 4u, "Show physics fx pipeline instance particles for the selected instance");
  DVARBOOL_physicsFX_debugDrawSounds = Dvar_RegisterBool("NQSLKRQNSQ", 0, 4u, "Show physics fx sounds");
  DVARBOOL_physics_processWorkerCommandsWhenWaiting_enabled = Dvar_RegisterBool("LLTTMRLPOL", 1, 0, "When true, process worker commands in HavokPhysicsThreadPool::waitForCompletion if we detect a stall or deadlock (IWH-237742)");
  DVARBOOL_physics_killswitchEnableRagdollFrameDelayFixOnMovers = Dvar_RegisterBool("NOPQTQPROP", 1, 0, "Enables the frame delay fix for ragdolls created on moving platforms. We have to rearchitect ragdolls next game so we can get up to date rigid body poses when rendering. This is a hack.");
  DVARBOOL_physics_killswitchEnableDontAdjustSolverSettingsOnTimestep = Dvar_RegisterBool("MOMNLSNLTS", 1, 0, "Sets the m_adjustSolverSettingsBasedOnTimestep to false for the client auth world. Keyframe rigid body velocities are not calculated correctly when this flag is set to true.");
  DVARBOOL_physics_killswitchEnableClientPredWorldUseCGameTimeForWorldStep = Dvar_RegisterBool("NRNRQMQPRM", 0, 0, "If enabled, cg_t::frametime is used for the client predictive world step time.");
  DVARBOOL_physics_killswitchEnableClientAuthWorldUseCGameTimeForWorldStep = Dvar_RegisterBool("NTTLSROMMR", 0, 0, "If enabled, cg_t::frametime is used for the client authoritative world step time.");
  DVARBOOL_physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix = Dvar_RegisterBool("RTROOQNRS", 1, 0, "Enables the fix to calculate the correct linear velocity to reach the target position for the key framed client predicted world body. Only for MP.");
  DVARBOOL_physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix = Dvar_RegisterBool("NNTSLRPLMT", 1, 0, "Enables the fix to calculate the correct linear velocity to reach the target position for the key framed client authoritative world body. Only for MP.");
  DVARBOOL_physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc = Dvar_RegisterBool("MSTNTPSRQR", 0, 0, "Disables mean time step smoothing for the client authoritative world. Only for MP.");
  DVARBOOL_physics_killswitchEnableApplyTimeSmoothingBeforePreWorldFunctions = Dvar_RegisterBool("MLPPSQLONO", 1, 0, "Enables the fix to calculate the correct linear velocity to reach the target position for the key framed client predicted world body. Disables the mean step time calculation. Only for MP.");
  __asm { vmovss  xmm7, cs:__real@7f7fffff }
  DVARBOOL_physics_killswitchEnableWarpingChecksForKeyframedServerObjects = Dvar_RegisterBool("LNSLTORNKN", 1, 0, "Enables an assert check on entities considered keyframed movers in server (marked with MarkKeyframedMover()). They shouldn't be warped.");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
    vmovss  xmm6, cs:__real@ff7fffff
  }
  DVARFLT_physics_maxClientWorldTimeStep = Dvar_RegisterFloat("LRNPORTQMT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Caps the time step for the client predictive and authoritative worlds.");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vmovaps xmm2, xmm6; min
    vmovaps xmm1, xmm9; value
  }
  DVARFLT_physics_ragdollMoverFriction = Dvar_RegisterFloat("NOMLTLTRNT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Ragdoll vs special mover (train) (dynamic) friction. Use a negative value to disable this override.");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vmovaps xmm2, xmm6; min
    vmovaps xmm1, xmm9; value
  }
  DVARFLT_physics_ragdollMoverStaticFrictionExtra = Dvar_RegisterFloat("MOSRKQNMRN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Ragdoll vs special mover (train) static friction extra. Use a negative value to disable this override.");
  __asm
  {
    vmovaps xmm3, xmm7; max
    vmovaps xmm2, xmm6; min
    vxorps  xmm1, xmm1, xmm1; value
  }
  DVARFLT_physics_ragdollMoverRestitution = Dvar_RegisterFloat("MQPPTSLNKP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0, "Ragdoll vs special mover (train) restitution. Use a negative value to disable this override.");
  DCONST_DVARBOOL_ragdoll_debugRagdollMoverOffset = Dvar_RegisterBool("ragdoll_debugRagdollMoverOffset", 0, 0x40004u, "Verbose debugging to track down mover offset issues");
  DCONST_DVARBOOL_physics_debugClientBodyVelocities = Dvar_RegisterBool("physics_debugClientBodyVelocities", 0, 0x40004u, "Enables verbose debugging for the client predictive and authoritative physics bodies. Please use physics_debugClientBodyVelocitiesEntNumber and physics_debugClientBodyVelocitiesModelSearchString for filtering.");
  DCONST_DVARINT_physics_debugClientBodyVelocitiesEntNumber = Dvar_RegisterInt("physics_debugClientBodyVelocitiesEntNumber", 2048, 0, 2048, 0x40004u, "The entity number to filter a physics body. 2047 matches no entities and 2048 matches all entities");
  DVARSTR_physics_debugClientBodyVelocitiesModelSearchString = Dvar_RegisterString("LTMPPLNLTQ", (const char *)&queryFormat.fmt + 3, 0, "Model name to filter a physics body. Partial matches are supported. CASE SENSITIVE!");
  PhysicsVolume_SetupDvars();
  physics_debugDisplayOffsetX = Dvar_RegisterInt("LTTKKLRTOR", 0, -500, 500, 4u, "Move the Physics Debug Display in the X direction");
  physics_debugDisplayOffsetY = Dvar_RegisterInt("OMLMNQPSLK", 0, -15000, 500, 4u, "Move the Physics Debug Display in the Y direction");
  physics_debugMemory = Dvar_RegisterEnum("PSQSLMNMT", s_Physics_DebugSectionNames, 0, 4u, "Show physics memory usage");
  physics_debugCPU = Dvar_RegisterEnum("PLKLKSKOQ", s_Physics_DebugSectionNames, 0, 4u, "Show physics cpu usage");
  physics_debugProfileData = Dvar_RegisterBool("PONNOONMN", 0, 4u, "Show Physics profile data");
  physics_debugTimestep = Dvar_RegisterEnum("NQRPQSMSRP", s_Physics_DebugSectionNames, 0, 4u, "Show physics timestep");
  physics_debugRefSystemCounts = Dvar_RegisterBool("NQSKKPQPSS", 0, 4u, "Show physics ref system counts");
  physics_debugVisualizeWorld = Dvar_RegisterEnum("LQPTRSLMSO", s_Physics_DebugSectionNames, 0, 0x26u, "Show physics world");
  physics_debugVisualizeWorldIgnoreCharacterProxies = Dvar_RegisterBool("MNMSONRSNP", 1, 4u, "Don't show character proxies");
  physics_debugVisualizeWorldRadius = Dvar_RegisterInt("OSRKRRNLM", 10, 0, 4000, 4u, "Don't try to render any geometries closer than this distance in feet");
  physics_debugVisualizeWorldClearZFirst = Dvar_RegisterBool("RSKQQSKQP", 0, 4u, "Clear Z before visualizing physics world");
  physics_debugVisualizeWorldViewMode = Dvar_RegisterEnum("MNNTRKTPTO", s_Physics_DebugVisualizationViewNames, 3, 0x26u, "View Mode for world visualization");
  physics_debugVisualizeWorldComplexityTriThreshold = Dvar_RegisterInt("NNRKMNNNNQ", 0, 0, 100000, 0x26u, "Don't try to render any geometries with more triangles than this");
  physics_debugVisualizeWorldComplexityLineThreshold = Dvar_RegisterInt("SSROMTKRR", 0, 0, 100000, 0x26u, "Don't try to render any wireframe geometries with more lines than this");
  physics_debugVisualizeWorldBodyId = Dvar_RegisterBool("LSNKPQQOLN", 0, 0x26u, "Show Body Ids when rendering the physics world");
  physics_debugVisualizeWorldBroadphase = Dvar_RegisterBool("LQLMLQMTTN", 0, 0x26u, "Show Broadphase when rendering the physics world");
  physics_debugVisualizeWorldConstraint = Dvar_RegisterBool("OKSLLQLPNR", 0, 0x26u, "Show Constraints when rendering the physics world");
  physics_debugVisualizeWorldDeactivation = Dvar_RegisterBool("NNONPKPMOT", 0, 0x26u, "Show Deactivation when rendering the physics world");
  physics_debugVisualizeWorldManifold = Dvar_RegisterBool("POPPMLQQQ", 0, 0x26u, "Show Manifold when rendering the physics world");
  physics_debugVisualizeWorldMassProperties = Dvar_RegisterBool("NTKNTQOPN", 0, 0x26u, "Show Mass Properties when rendering the physics world");
  physics_debugVisualizeWorldMotionId = Dvar_RegisterBool("NSOPNOMR", 0, 0x26u, "Show Motion Ids when rendering the physics world");
  physics_debugVisualizeWorldShape = Dvar_RegisterBool("LPMMQQONNL", 0, 0x26u, "Show Shapes when rendering the physics world");
  physics_debugVisualizeWorldShapeLowRes = Dvar_RegisterBool("NLOLRSKMSN", 0, 0x26u, "Show Low-Res Shapes when rendering the physics world");
  physics_debugVisualizeWorldVehicles = Dvar_RegisterBool("NQNTQNPSSR", 0, 0x26u, "Show Vehicles when rendering the physics world");
  physics_debugVisualizeWorldCollisionHeatmap = Dvar_RegisterBool("MNKORKMKM", 0, 0x26u, "Show Collision Heatmap when rendering the physics world");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vxorps  xmm1, xmm1, xmm1; value
    vmovss  [rsp+0C8h+flags], xmm9
  }
  physics_debugVisualizeWorldCollisionHeatmapGood = Dvar_RegisterFloat("NTSTRRQOL", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flags, 4u, "Collision Heatmap Density Good Threshold");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovss  xmm10, cs:__real@42c80000
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm10; value
    vmovss  [rsp+0C8h+flags], xmm9
  }
  physics_debugVisualizeWorldCollisionHeatmapBad = Dvar_RegisterFloat("TLQKPKNPN", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsa, 4u, "Collision Heatmap Density Bad Threshold");
  __asm
  {
    vmovss  xmm1, cs:__real@48f42400; value
    vmovaps xmm3, xmm1; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovss  [rsp+0C8h+flags], xmm10
  }
  physics_debugVisualizeWorldCollisionHeatmapRange = Dvar_RegisterFloat("STSTLQQQT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsb, 4u, "Collision Heatmap Density Display range");
  physics_debugVisualizeWorldDebugDraw = Dvar_RegisterBool("NQLOQTNQKT", 0, 0x26u, "Show Debug Draw data when rendering the physics world");
  physics_debugVisualizeWorldCollisionTile = Dvar_RegisterBool("LNKKPSONOQ", 0, 0x26u, "Show Collision Tile data when rendering the physics world");
  physics_debugVisualizeWorldRaycasts = Dvar_RegisterBool("OLKTNOMLQ", 0, 0x26u, "Show raycasts when rendering the physics world");
  physics_debugVisualizeWorldShapecasts = Dvar_RegisterBool("LTMPNPQRTR", 0, 0x26u, "Show shapecasts when rendering the physics world");
  physics_debugVisualizeWorldAABBQuery = Dvar_RegisterBool("OKOTKKLQOQ", 0, 0x26u, "Show aabb queries when rendering the physics world");
  physics_debugVisualizeWorldPointQuery = Dvar_RegisterBool("NRRLQPNONO", 0, 0x26u, "Show point queries when rendering the physics world");
  physics_debugVisualizeWorldClosestPointsQuery = Dvar_RegisterBool("NQRLTTOTQS", 0, 0x26u, "Show closest point queries when rendering the physics world");
  physics_debugVisualizeCharacterProxies = Dvar_RegisterEnum("NLLMTOPKKL", s_Physics_DebugSectionNames, 0, 4u, "Show character proxy data");
  physics_debugVisualizeWorldIWShape = Dvar_RegisterBool("SMKSQMTSP", 1, 0x26u, "Show IW Shapes when rendering the physics world");
  physics_debugVisualizeWorldParticles = Dvar_RegisterBool("OMPSTPTSOR", 0, 0x26u, "Show particles when rendering the physics world");
  cloth_debugVisualizeWorldGeometry = Dvar_RegisterBool("NQMQKQKRKT", 0, 0x26u, "Show Cloth Geometry when rendering the physics world");
  cloth_debugVisualizeWorldSimParticlePosition = Dvar_RegisterBool("MPTKTMLQMT", 0, 0x26u, "Show Cloth SimParticlePosition when rendering the physics world");
  cloth_debugVisualizeWorldSimNormals = Dvar_RegisterBool("LSRNKKNQRQ", 0, 0x26u, "Show Cloth SimNormals when rendering the physics world");
  cloth_debugVisualizeWorldParticleVelocity = Dvar_RegisterBool("LRNMRTNQSK", 0, 0x26u, "Show Cloth ParticleVelocity when rendering the physics world");
  cloth_debugVisualizeWorldParticleId = Dvar_RegisterBool("PLPOQPNSQ", 0, 0x26u, "Show Cloth ParticleId when rendering the physics world");
  cloth_debugVisualizeWorldSimStandardLinks = Dvar_RegisterBool("NONKTOQLPM", 0, 0x26u, "Show Cloth SimStandardLinks when rendering the physics world");
  cloth_debugVisualizeWorldSimStretchLinks = Dvar_RegisterBool("MORONTMNSK", 0, 0x26u, "Show Cloth SimStretchLinks when rendering the physics world");
  cloth_debugVisualizeWorldSimBendLinks = Dvar_RegisterBool("MOKTQTMQLO", 0, 0x26u, "Show Cloth SimBendLinks when rendering the physics world");
  cloth_debugVisualizeWorldSimBendStiffness = Dvar_RegisterBool("OLKPMPTPQO", 0, 0x26u, "Show Cloth SimBendStiffness when rendering the physics world");
  cloth_debugVisualizeWorldSimVolumeTransforms = Dvar_RegisterBool("NSTOMSOSTP", 0, 0x26u, "Show Cloth SimVolumeTransforms when rendering the physics world");
  cloth_debugVisualizeWorldLocalRange = Dvar_RegisterBool("MSTLRPTTNN", 0, 0x26u, "Show Cloth LocalRange when rendering the physics world");
  cloth_debugVisualizeWorldBonePlane = Dvar_RegisterBool("LRMKMNNTMR", 0, 0x26u, "Show Cloth BonePlane when rendering the physics world");
  cloth_debugVisualizeWorldTransition = Dvar_RegisterBool("NNMMQRPQOS", 0, 0x26u, "Show Cloth Transition when rendering the physics world");
  cloth_debugVisualizeWorldCollidable = Dvar_RegisterBool("MPRMLSOOMK", 0, 0x26u, "Show Cloth Collidable when rendering the physics world");
  cloth_debugVisualizeWorldParticleRadius = Dvar_RegisterBool("MONPQLLPL", 0, 0x26u, "Show Cloth ParticleRadius when rendering the physics world");
  cloth_debugVisualizeWorldVirtualCollisionPoints = Dvar_RegisterBool("MNNNQMTPQR", 0, 0x26u, "Show Cloth VirtualCollisionPoints when rendering the physics world");
  cloth_debugVisualizeWorldVirtualCollisionPointsLandscape = Dvar_RegisterBool("QLTLOPQSK", 0, 0x26u, "Show Cloth VirtualCollisionPointsLandscape when rendering the physics world");
  physics_debugVisualize_CONTENTS_SOLID = Dvar_RegisterBool("MMRSSLOSST", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_FOLIAGE = Dvar_RegisterBool("SOSSMNPT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_VEHICLETRIGGER = Dvar_RegisterBool("PPKLORSPM", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_GLASS = Dvar_RegisterBool("OKNMNOKLNS", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_WATER = Dvar_RegisterBool("NMQNKRSTSP", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_AI_NOSHOOT = Dvar_RegisterBool("NNSTKTTQLN", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_MISSILECLIP = Dvar_RegisterBool("LSMMOSPOOQ", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_ITEM = Dvar_RegisterBool("NONMMKPOP", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_VEHICLECLIP = Dvar_RegisterBool("MSSLKOKTLO", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_ITEMCLIP = Dvar_RegisterBool("LLMQNNTTQR", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_SKY = Dvar_RegisterBool("MRPOLTTMPR", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_AI_NOSIGHT = Dvar_RegisterBool("MSQNSMNRMN", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_CLIPSHOT = Dvar_RegisterBool("TSPQKTNNS", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_ACTOR = Dvar_RegisterBool("LLKQSOPKRT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_PLAYERCLIP = Dvar_RegisterBool("NKTLQPNOSL", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_PLAYER_NOSIGHT = Dvar_RegisterBool("NNMQQOSOTM", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_AI_CLIP = Dvar_RegisterBool("MNSPNLPNQT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_SENTIENTTRIGGER = Dvar_RegisterBool("OKLLOTRORS", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_EXPLOSIONCLIP = Dvar_RegisterBool("MTNNQSOMTP", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_SOUNDCLIP = Dvar_RegisterBool("OPONKTOSP", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_SOUNDREFLECT = Dvar_RegisterBool("MTTTPMPSPQ", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_NONSENTIENTTRIGGER = Dvar_RegisterBool("LMKKNSLQRN", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_VEHICLE = Dvar_RegisterBool("NTKLQNKKQK", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_MANTLE = Dvar_RegisterBool("MMMRPSPTTT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_PLAYER = Dvar_RegisterBool("MMSOKRRQRL", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_USECLIP = Dvar_RegisterBool("MOLLRNNKT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_CONTENTS_PLAYERTRIGGER = Dvar_RegisterBool("MQNMTQRMNP", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugVisualize_Query = Dvar_RegisterBool("LPNPSNLPKN", 1, 4u, "Set this to false to hide triggers/players in the vdb");
  physics_debugVisualize_Preset = Dvar_RegisterInt("ORMOTTQOK", 0, 0x80000000, 0x7FFFFFFF, 4u, "Set the physics query to use this contents preset - if 0, uses the other settings");
  physics_debugLibraryMaterials = Dvar_RegisterBool("MNOKSQLKSN", 0, 4u, "Show Physics Library Materials");
  physics_debugLibraryBodyQualitys = Dvar_RegisterBool("MLMKOPLKQL", 0, 4u, "Show Physics Library Body Qualitys");
  physics_debugLibraryMotionProperties = Dvar_RegisterBool("MNMSTQSOOS", 0, 4u, "Show Physics Library Motion Properties");
  physics_debugLibraryMaterialId = Dvar_RegisterInt("LQLSPLTSOT", -1, -1, 1000, 4u, "Show details about a selected Material in the Physics Library");
  physics_debugLibraryBodyQualityId = Dvar_RegisterInt("MMQRMLKONT", -1, -1, 1000, 4u, "Show details about a selected Body Quality in the Physics Library");
  physics_debugLibraryMotionPropertiesId = Dvar_RegisterInt("NPTROKKPNR", -1, -1, 1000, 4u, "Show details about a selected Motion Properties in the Physics Library");
  physics_debugAssetsByName = Dvar_RegisterBool("ONSNQNOSN", 0, 4u, "Show Physics Assets by name");
  physics_debugAssetsByMemory = Dvar_RegisterBool("PNPTOKOT", 0, 4u, "Show Physics Assets by memory");
  physics_debugAssetIdByName = Dvar_RegisterInt("MLSLNSQRRR", -1, -1, 10000, 4u, "Show details about a selected Physics Asset - indexed into name ordered list");
  physics_debugAssetIdByMemory = Dvar_RegisterInt("NORQNROMMR", -1, -1, 10000, 4u, "Show details about a selected Physics Asset - indexed into memory ordered list");
  physics_debugXModelsWithNoPhysicsAsset = Dvar_RegisterBool("NPRNSLQOOS", 0, 4u, "Show Physics XModels without PhysicsAssets");
  physics_debugXModelsWithCollLods = Dvar_RegisterBool("TRLTSTRNS", 0, 4u, "Show Physics Xmodels with ColLods");
  physics_debugXModelsExcludeDoNotUse = Dvar_RegisterBool("QONOKKPTL", 1, 4u, "When using physics_debugXModelsWithNoPhysicsAsset or physics_debugXModelsWithCollLods, excludes models using material 'do_not_use'");
  physics_debugXModelsByName = Dvar_RegisterBool("OKONLRQMRM", 0, 4u, "Show Physics XModels By Name");
  physics_debugXModelsByMemory = Dvar_RegisterBool("MRKOLKQQKM", 0, 4u, "Show Physics XModels By Memory");
  physics_debugXModelsByDetailBodyCount = Dvar_RegisterBool("NPKROSRRML", 0, 4u, "Show Physics XModels By Detail body count");
  physics_debugXModelIdByName = Dvar_RegisterInt("LQQRLPSPO", -1, -1, 10000, 4u, "Show details about a selected XModel Asset Indexed By Name");
  physics_debugXModelIdByMemory = Dvar_RegisterInt("LPRTRKPPKK", -1, -1, 10000, 4u, "Show details about a selected XModel Asset Indexed By Memory");
  physics_debugSFXEventAssets = Dvar_RegisterBool("NORTRTMPRO", 0, 4u, "Show Physics SFXEvent Assets");
  physics_debugSFXEventAssetId = Dvar_RegisterInt("NQKLNLPKOK", -1, -1, 10000, 4u, "Show details about a selected Physics SFXEvent Asset");
  physics_debugVFXEventAssets = Dvar_RegisterBool("MLSLMPNSN", 0, 4u, "Show Physics VFXEvent Assets");
  physics_debugVFXEventAssetId = Dvar_RegisterInt("OMSSSQRPOT", -1, -1, 10000, 4u, "Show details about a selected Physics VFXEventAsset");
  physics_debugClipmapBrushes = Dvar_RegisterBool("PPKONLNNO", 0, 4u, "Show Physics Clipmap brushes");
  physics_debugParticlesHeavyweight = Dvar_RegisterBool("MSKQOPRMNM", 0, 4u, "Show Physics Heavyweight Particle assets");
  physics_debugWorld = Dvar_RegisterEnum("NOSMNOPOMM", s_Physics_DebugSectionNames, 0, 4u, "Show information about a physics world");
  physics_debugWorldFull = Dvar_RegisterBool("LRPOKMKQKP", 0, 4u, "Show full information about a physics world, when physics_debugWorld is set");
  physics_debugWorldBody = Dvar_RegisterInt("MRPPSMTSOQ", -1, -1, 4096, 4u, "Show details about a selected Body in the physics_debugWorld selected world");
  physics_debugQueryBody = Dvar_RegisterInt("MNOPNSNTNO", -1, -1, 4096, 4u, "Set queries to use a single body (has no effect on broadphase aabb query)");
  __asm { vmovss  xmm9, cs:__real@47fa0000 }
  physics_debugAABBBroadphaseWorldQuery = Dvar_RegisterEnum("NLLRTPOQKL", s_Physics_DebugSectionNames, 0, 4u, "Fire an AABB Broadphase Query, and show info about the target");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vmovss  xmm7, cs:__real@c1800000
    vmovss  xmm8, cs:__real@c7fa0000
    vmovaps xmm3, xmm7; z
    vmovaps xmm2, xmm7; y
    vmovaps xmm1, xmm7; x
    vmovss  [rsp+0C8h+flags], xmm8
    vmovss  xmm6, cs:__real@41800000
  }
  physics_debugAABBBroadphaseWorldQueryAABBMin = Dvar_RegisterVec3("MSLPPLSNT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsc, description, v159, 4u, "AABB Broadphase Query - AABB Min");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vmovaps xmm3, xmm6; z
    vmovaps xmm2, xmm6; y
    vmovaps xmm1, xmm6; x
    vmovss  [rsp+0C8h+flags], xmm8
  }
  physics_debugAABBBroadphaseWorldQueryAABBMax = Dvar_RegisterVec3("LTQQPLTNMT", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsd, descriptiona, v160, 4u, "AABB Broadphase Query - AABB Max");
  physics_debugAABBWorldQuery = Dvar_RegisterEnum("NOOTMTPKK", s_Physics_DebugSectionNames, 0, 4u, "Fire an AABB Query, and show info about the target");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vmovaps xmm3, xmm7; z
    vmovaps xmm2, xmm7; y
    vmovaps xmm1, xmm7; x
    vmovss  [rsp+0C8h+flags], xmm8
  }
  physics_debugAABBWorldQueryAABBMin = Dvar_RegisterVec3("NSKNRLOSRS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagse, descriptionb, v161, 4u, "AABB Query - AABB Min");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vmovaps xmm3, xmm6; z
    vmovaps xmm2, xmm6; y
    vmovaps xmm1, xmm6; x
    vmovss  [rsp+0C8h+flags], xmm8
  }
  physics_debugAABBWorldQueryAABBMax = Dvar_RegisterVec3("QMLOQNKSS", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsf, descriptionc, v162, 4u, "AABB Query - AABB Max");
  physics_debugRayWorld = Dvar_RegisterEnum("NRLRKKPRPM", s_Physics_DebugSectionNames, 0, 4u, "Fire a raycast, and show info about the target");
  physics_debugRayDetail = Dvar_RegisterBool("MNMSQQNKON", 0, 4u, "Do raytraces with detail check");
  physics_debugRayClutter = Dvar_RegisterBool("NMKNNMLNTT", 0, 4u, "Do raytraces with clutter flag");
  physics_debugShapeCastWorld = Dvar_RegisterEnum("PQMNRRMOO", s_Physics_DebugSectionNames, 0, 4u, "Fire a shapecast, and show info about the target");
  physics_debugQueryPointWorld = Dvar_RegisterEnum("MTKNOSPOMO", s_Physics_DebugSectionNames, 0, 4u, "Do a point query");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vxorps  xmm3, xmm3, xmm3; z
    vxorps  xmm2, xmm2, xmm2; y
    vxorps  xmm1, xmm1, xmm1; x
    vmovss  [rsp+0C8h+flags], xmm8
  }
  physics_debugQueryPointPosition = Dvar_RegisterVec3("MOKLLNKLNP", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsg, descriptiond, v163, 4u, "Query Point Position");
  physics_debugQueryPointMaxDistance = Dvar_RegisterInt("LTQPTMNPOP", 6, 0, 1024, 4u, "Query Point Max Distance");
  physics_debugGetClosestPointsWorld = Dvar_RegisterEnum("LRKOMMKRPS", s_Physics_DebugSectionNames, 0, 4u, "Do a get closest points query");
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_98], xmm11
    vmovss  dword ptr [rsp+0C8h+description], xmm9
    vxorps  xmm3, xmm3, xmm3; z
    vxorps  xmm2, xmm2, xmm2; y
    vxorps  xmm1, xmm1, xmm1; x
    vmovss  [rsp+0C8h+flags], xmm8
  }
  physics_debugGetClosestPointsPosition = Dvar_RegisterVec3("MSNMSQNNRR", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsh, descriptione, v164, 4u, "Get Closest Points Position");
  physics_debugGetClosestPointsMaxDistance = Dvar_RegisterInt("NNSNRSMMOR", 6, 0, 1024, 4u, "Get Closest Points Max Distance");
  physics_debugQuery_CONTENTS_SOLID = Dvar_RegisterBool("POSKRTPKT", 1, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_FOLIAGE = Dvar_RegisterBool("SSSNKSKN", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_VEHICLETRIGGER = Dvar_RegisterBool("RQOPLTPKO", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_GLASS = Dvar_RegisterBool("NNTOQMTNRO", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_WATER = Dvar_RegisterBool("OKMKLROKNR", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_AI_NOSHOOT = Dvar_RegisterBool("NLSKMNNNTN", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_MISSILECLIP = Dvar_RegisterBool("LNLTLTO", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_ITEM = Dvar_RegisterBool("LKRRKRRST", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_VEHICLECLIP = Dvar_RegisterBool("NPNRRQQMRK", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_ITEMCLIP = Dvar_RegisterBool("LMPRNKNKTL", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_SKY = Dvar_RegisterBool("MRRSTMNKQT", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_AI_NOSIGHT = Dvar_RegisterBool("NOOQQQNNNP", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_CLIPSHOT = Dvar_RegisterBool("MKMNSLRTPS", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_ACTOR = Dvar_RegisterBool("MOLPRROTKR", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_PLAYERCLIP = Dvar_RegisterBool("LRPQRLMML", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_PLAYER_NOSIGHT = Dvar_RegisterBool("TQKPMLQRM", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_AI_CLIP = Dvar_RegisterBool("NPMQPQNPLR", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_SENTIENTTRIGGER = Dvar_RegisterBool("LNQKQMRRKQ", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_EXPLOSIONCLIP = Dvar_RegisterBool("NPPQKTPTQN", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_SOUNDCLIP = Dvar_RegisterBool("MONMOKKMSL", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_SOUNDREFLECT = Dvar_RegisterBool("LNQQONNNKS", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_NONSENTIENTTRIGGER = Dvar_RegisterBool("NQPNTMSKQT", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_VEHICLE = Dvar_RegisterBool("RTKNTQSOS", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_MANTLE = Dvar_RegisterBool("LPLKLLKKN", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_PLAYER = Dvar_RegisterBool("MKMSPKSSPT", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_USECLIP = Dvar_RegisterBool("TNTLMTNNR", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_CONTENTS_PLAYERTRIGGER = Dvar_RegisterBool("MKTRMOQKSR", 0, 4u, "Set the physics query to use this contents flag");
  physics_debugQuery_Preset = Dvar_RegisterInt("LLMSLMMQSO", 0, 0x80000000, 0x7FFFFFFF, 4u, "Set the physics query to use this contents preset - if 0, uses the other settings");
  physics_debugQuery_IgnoreVolumes = Dvar_RegisterBool("NSTMRSSOQ", 1, 4u, "Set the physics query to ignore volumes or include them");
  physics_dumpCharacterProxyServer = Dvar_RegisterBool("NLTOKQSORN", 0, 4u, "Dump the character proxy data on the server");
  physics_debugDetailModel = Dvar_RegisterBool("NTTPRPRPPS", 0, 4u, "Debug detail models");
  physics_debugFlickerColLod = Dvar_RegisterBool("NKKNSKTOKN", 0, 4u, "Toggle back and forth between normal lod and collod");
  physics_debugBadColLods = Dvar_RegisterBool("NMSTLLMOPP", 0, 4u, "Display models with bad collods");
  __asm { vmovss  xmm3, cs:__real@453b8000; max }
  physics_debugMutableShapesInWorld = Dvar_RegisterEnum("LMLLOTTOTP", s_Physics_DebugSectionNames, 0, 4u, "Display mutable shape data for a world");
  __asm
  {
    vmovaps xmm2, xmm10; min
    vmovaps xmm1, xmm13; value
    vmovss  [rsp+0C8h+flags], xmm10
  }
  physics_debugMutableShapesInWorldRange = Dvar_RegisterFloat("RKNQSMTRM", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, flagsi, 4u, "Range at which we display detailed info for mutable shapes in world debug mode");
  physics_debugDump = Dvar_RegisterBool("MOMNNTQQMO", 0, 4u, "Dump debug screen to tty");
  PhysicsSVFX_SetupDvars();
  _R11 = &v165;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm13, xmmword ptr [r11-70h]
  }
  Dvar_EndPermanentRegistration();
}

/*
==============
Physics_SetupServerWorldCInfos
==============
*/
void Physics_SetupServerWorldCInfos(const unsigned int maxClients)
{
  int maxNumRigidBodiesServer; 
  const dvar_t *v3; 
  int maxNumDetailRigidBodiesServer; 
  const dvar_t *v5; 
  int maxNumMotionsServer; 
  const dvar_t *v7; 
  int maxNumConstraintsServer; 
  const dvar_t *v9; 
  const dvar_t *v10; 
  const dvar_t *v11; 
  const dvar_t *v12; 
  const dvar_t *v13; 
  int integer; 
  const dvar_t *v15; 

  if ( maxClients - 1 > 0xC7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 766, ASSERT_TYPE_ASSERT, "(( maxClients > 0 ) && ( maxClients <= ((1 >= 200) ? 1 : 200) ))", (const char *)&queryFormat, "( maxClients > 0 ) && ( maxClients <= MAX_CLIENTS_STATIC )") )
    __debugbreak();
  if ( !s_physicsWorldPersistentBufferSizeServerMain && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 776, ASSERT_TYPE_ASSERT, "(s_physicsWorldPersistentBufferSizeServerMain)", (const char *)&queryFormat, "s_physicsWorldPersistentBufferSizeServerMain") )
    __debugbreak();
  if ( !s_physicsWorldPersistentBufferSizeServerDetail && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 777, ASSERT_TYPE_ASSERT, "(s_physicsWorldPersistentBufferSizeServerDetail)", (const char *)&queryFormat, "s_physicsWorldPersistentBufferSizeServerDetail") )
    __debugbreak();
  maxNumRigidBodiesServer = cm.physicsCapacities.maxNumRigidBodiesServer;
  if ( !cm.physicsCapacities.maxNumRigidBodiesServer )
  {
    v3 = DVARINT_physics_MaxNumServerBodies;
    if ( !DVARINT_physics_MaxNumServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    maxNumRigidBodiesServer = v3->current.integer;
  }
  maxNumDetailRigidBodiesServer = cm.physicsCapacities.maxNumDetailRigidBodiesServer;
  if ( !cm.physicsCapacities.maxNumDetailRigidBodiesServer )
  {
    v5 = DVARINT_physics_MaxNumServerDetailBodies;
    if ( !DVARINT_physics_MaxNumServerDetailBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerDetailBodies") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    maxNumDetailRigidBodiesServer = v5->current.integer;
  }
  maxNumMotionsServer = cm.physicsCapacities.maxNumMotionsServer;
  if ( !cm.physicsCapacities.maxNumMotionsServer )
  {
    v7 = DVARINT_physics_MaxNumServerMotions;
    if ( !DVARINT_physics_MaxNumServerMotions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerMotions") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    maxNumMotionsServer = v7->current.integer;
  }
  maxNumConstraintsServer = cm.physicsCapacities.maxNumConstraintsServer;
  if ( !cm.physicsCapacities.maxNumConstraintsServer )
  {
    v9 = DVARINT_physics_MaxNumServerConstraints;
    if ( !DVARINT_physics_MaxNumServerConstraints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_MaxNumServerConstraints") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    maxNumConstraintsServer = v9->current.integer;
  }
  if ( cm.mapEnts )
  {
    maxNumRigidBodiesServer += cm.mapEnts->scriptableMapEnts.physicsLimits.serverStandaloneMainRigidBodyCount;
    maxNumDetailRigidBodiesServer += cm.mapEnts->scriptableMapEnts.physicsLimits.serverStandaloneDetailedRigidBodyCount;
    maxNumMotionsServer += cm.mapEnts->scriptableMapEnts.physicsLimits.serverStandaloneMotionCount;
    if ( cm.mapEnts->spawnGroupLoot.pointCount )
    {
      v10 = DVARSTR_loot_table_name;
      if ( !DVARSTR_loot_table_name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loot_table_name") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v10);
      if ( *(_BYTE *)v10->current.integer64 )
      {
        v11 = DVARINT_physics_ExtraLootServerBodies;
        if ( !DVARINT_physics_ExtraLootServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraLootServerBodies") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v11);
        maxNumRigidBodiesServer += v11->current.integer;
        v12 = DVARINT_physics_ExtraLootServerBodies;
        if ( !DVARINT_physics_ExtraLootServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraLootServerBodies") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v12);
        maxNumDetailRigidBodiesServer += v12->current.integer;
      }
    }
    if ( maxClients > 0x40 )
    {
      v13 = DVARINT_physics_ExtraPlayerServerBodies;
      if ( !DVARINT_physics_ExtraPlayerServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraPlayerServerBodies") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v13);
      integer = v13->current.integer;
      v15 = DVARINT_physics_ExtraPlayerServerBodies;
      maxNumRigidBodiesServer += maxClients * integer;
      if ( !DVARINT_physics_ExtraPlayerServerBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_ExtraPlayerServerBodies") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v15);
      maxNumDetailRigidBodiesServer += maxClients * v15->current.integer;
    }
  }
  if ( maxNumRigidBodiesServer > 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 816, ASSERT_TYPE_ASSERT, "( serverRigidBodyMax ) <= ( 0xffffff )", "%s <= %s\n\t%i, %i", "serverRigidBodyMax", "PHYSICS_HARD_MAX_BODIES_PER_WORLD", maxNumRigidBodiesServer, 0xFFFFFF) )
    __debugbreak();
  __asm
  {
    vmovss  xmm4, cs:__real@3fc00000
    vmovups xmm0, cs:__xmm@43c10b8541dc00003ecccccd3d4ccccd
    vmovss  xmm3, cs:__real@3f19999a
    vmovss  xmm2, cs:__real@3f800000
    vmovss  xmm1, cs:__real@3c888889
  }
  s_physicsWorldCInfos[0].persistentBuffer = s_physicsWorldPersistentBufferSizeServerMain;
  s_physicsWorldCInfos[1].persistentBuffer = s_physicsWorldPersistentBufferSizeServerDetail;
  __asm
  {
    vmovss  cs:s_physicsWorldCInfos.collisionTolerance, xmm4
    vmovss  cs:s_physicsWorldCInfos.solverStrength, xmm3
    vmovss  cs:s_physicsWorldCInfos.solverDamping, xmm2
    vmovss  cs:s_physicsWorldCInfos.defaultTimeStep, xmm1
    vmovss  cs:s_physicsWorldCInfos.collisionTolerance+50h, xmm4
    vmovss  cs:s_physicsWorldCInfos.solverStrength+50h, xmm3
    vmovss  cs:s_physicsWorldCInfos.solverDamping+50h, xmm2
    vmovss  cs:s_physicsWorldCInfos.defaultTimeStep+50h, xmm1
  }
  s_physicsWorldCInfos[0].systemCountMax = maxNumRigidBodiesServer;
  s_physicsWorldCInfos[0].bodyCountMax = maxNumRigidBodiesServer;
  s_physicsWorldCInfos[0].motionCountMax = maxNumMotionsServer;
  s_physicsWorldCInfos[0].constraintCountMax = maxNumConstraintsServer;
  s_physicsWorldCInfos[0].persistentBufferSize = 0x800000;
  __asm { vmovups xmmword ptr cs:s_physicsWorldCInfos.collisionAccuracy, xmm0 }
  s_physicsWorldCInfos[0].solverIterations = 4;
  *(_WORD *)&s_physicsWorldCInfos[0].isMultiThreaded = 0;
  s_physicsWorldCInfos[0].visualizeWithCloth = 0;
  s_physicsWorldCInfos[0].adjustSolverSettingsOnTimestep = 0;
  s_physicsWorldCInfos[0].maxRagdolls = 0;
  s_physicsWorldCInfos[1].systemCountMax = maxNumRigidBodiesServer;
  s_physicsWorldCInfos[1].bodyCountMax = maxNumDetailRigidBodiesServer;
  s_physicsWorldCInfos[1].motionCountMax = 1;
  s_physicsWorldCInfos[1].constraintCountMax = 1;
  s_physicsWorldCInfos[1].persistentBufferSize = 0x80000;
  __asm { vmovups xmmword ptr cs:s_physicsWorldCInfos.collisionAccuracy+50h, xmm0 }
  s_physicsWorldCInfos[1].solverIterations = 4;
  *(_QWORD *)&s_physicsWorldCInfos[1].adjustSolverSettingsOnTimestep = 0i64;
}

/*
==============
Physics_Shapecast
==============
*/
void Physics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  __int64 v14; 
  hkQuaternionf *v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  int v58; 
  int v59; 
  int v60; 
  hkVector4f v61; 
  hkVector4f v62; 
  hkQuaternionf v63; 

  v14 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9475, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire Shapecast against bodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v14 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9476, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v14) )
    __debugbreak();
  if ( numBodies )
  {
    if ( !bodyIds )
    {
      LODWORD(v50) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9477, ASSERT_TYPE_ASSERT, "(numBodies == 0 || bodyIds)", "%s\n\tPhysics: Trying to fire shapecast against bodies with bad bodies %i", "numBodies == 0 || bodyIds", v50) )
        __debugbreak();
    }
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9478, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast against bodies with null shape", "shape") )
    __debugbreak();
  _RBP = start;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
  {
LABEL_53:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9479, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  _RSI = end;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
  {
LABEL_54:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9480, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid end", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  _RDI = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v57 & 0x7F800000) == 2139095040 )
    goto LABEL_55;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v58 & 0x7F800000) == 2139095040 )
    goto LABEL_55;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v59 & 0x7F800000) == 2139095040 )
    goto LABEL_55;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0F8h+var_A8], xmm0
  }
  if ( (v60 & 0x7F800000) == 2139095040 )
  {
LABEL_55:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9481, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9482, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9483, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire Shapecast against bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9484, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire Shapecast against bodies with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v14] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9485, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  Physics_CheckShapecastConstraints(shape, start, end);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rbp+0]
    vmulss  xmm2, xmm4, dword ptr [rbp+4]
    vmulss  xmm1, xmm4, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rsi+4]
    vmovss  dword ptr [rsp+0F8h+var_88.m_quad+4], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rsi]
    vrsqrtps xmm4, xmm0
    vmovups xmmword ptr [rsp+0F8h+var_68.m_vec.m_quad], xmm0
    vxorps  xmm3, xmm3, xmm3
    vmulps  xmm0, xmm4, xmm0
    vmovss  dword ptr [rsp+0F8h+var_88.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0F8h+var_88.m_quad+8], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+0F8h+var_78.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0F8h+var_88.m_quad+0Ch], xmm3
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0F8h+var_68.m_vec.m_quad], xmm1
  }
  switch ( (int)v14 )
  {
    case 0:
      Profile_Begin(742);
      break;
    case 1:
      Profile_Begin(743);
      break;
    case 2:
    case 5:
      Profile_Begin(744);
      break;
    case 3:
    case 6:
      Profile_Begin(745);
      break;
    case 4:
    case 7:
      Profile_Begin(746);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9541, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_Shapecast((Physics_WorldId)v14, numBodies, bodyIds, shape, &v62, &v61, &v63, extendedData, result, startResult);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_Shapecast
==============
*/
void Physics_Shapecast(Physics_WorldId worldId, unsigned int bodyId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  __int64 v13; 
  Physics_ShapecastExtendedData *v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  int v58; 
  hkVector4f v59; 
  hkVector4f starta; 
  hkQuaternionf v61; 

  _RBP = start;
  v13 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9394, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire Shapecast against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v13 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9395, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v13) )
    __debugbreak();
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v48) = v13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9396, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to fire shapecast against body with invalid body id %i", "Physics_IsRigidBodyIdValid( bodyId )", v48) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9397, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast against body with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_52;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
  {
LABEL_52:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9398, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  _RSI = end;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
    goto LABEL_53;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
  {
LABEL_53:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9399, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid start", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  _RDI = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v57 & 0x7F800000) == 2139095040 )
    goto LABEL_54;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0D8h+var_88], xmm0
  }
  if ( (v58 & 0x7F800000) == 2139095040 )
  {
LABEL_54:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9400, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9401, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9402, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tPhysics: Trying to fire Shapecast against body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9403, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire Shapecast against body with invalid result", "result") )
    __debugbreak();
  if ( g_physicsQueriesNotAllowedForWorld[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9404, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  Physics_CheckShapecastConstraints(shape, _RBP, end);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rbp+0]
    vmulss  xmm2, xmm4, dword ptr [rbp+4]
    vmulss  xmm1, xmm4, dword ptr [rbp+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0D8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rsi+4]
    vmovss  dword ptr [rsp+0D8h+var_78.m_quad+4], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vmovss  dword ptr [rsp+0D8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0D8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rsi]
    vrsqrtps xmm4, xmm0
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm0
    vxorps  xmm3, xmm3, xmm3
    vmulps  xmm0, xmm4, xmm0
    vmovss  dword ptr [rsp+0D8h+var_78.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0D8h+var_78.m_quad+8], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+0D8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0D8h+var_78.m_quad+0Ch], xmm3
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm1
  }
  switch ( (int)v13 )
  {
    case 0:
      Profile_Begin(737);
      break;
    case 1:
      Profile_Begin(738);
      break;
    case 2:
    case 5:
      Profile_Begin(739);
      break;
    case 3:
    case 6:
      Profile_Begin(740);
      break;
    case 4:
    case 7:
      Profile_Begin(741);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9460, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_Shapecast((Physics_WorldId)v13, (hknpBodyId)bodyId, shape, &starta, &v59, &v61, extendedData, result, startResult);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_Shapecast
==============
*/
void Physics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const vec3_t *start, const vec3_t *end, const vec4_t *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  HavokPhysics_CollisionQueryResult *v10; 
  __int64 v13; 
  const dvar_t *v25; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  hkVector4f enda; 
  hkVector4f starta; 
  hkQuaternionf v60; 

  _R14 = end;
  v10 = result;
  _R15 = start;
  v13 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8861, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to fire Shapecast when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v13 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8862, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to fire Shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v13) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8863, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tPhysics: Trying to fire Shapecast with null shape", "shape") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_59;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_59;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
  {
LABEL_59:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8864, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", "%s\n\tPhysics: Trying to fire Shapecast with invalid start", "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
    goto LABEL_60;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_60;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
  {
LABEL_60:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8865, ASSERT_TYPE_ASSERT, "(!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] ))", "%s\n\tPhysics: Trying to fire Shapecast with invalid end", "!IS_NAN( end[0] ) && !IS_NAN( end[1] ) && !IS_NAN( end[2] )") )
      __debugbreak();
  }
  _RDI = rotation;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
    goto LABEL_61;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_61;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
    goto LABEL_61;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0D8h+var_98], xmm0
  }
  if ( (v57 & 0x7F800000) == 2139095040 )
  {
LABEL_61:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8866, ASSERT_TYPE_ASSERT, "(!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] ))", "%s\n\tPhysics: Trying to fire Shapecast with invalid rotation", "!IS_NAN( rotation[0] ) && !IS_NAN( rotation[1] ) && !IS_NAN( rotation[2] ) && !IS_NAN( rotation[3] )") )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8867, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tPhysics: Trying to fire Shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8868, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to fire Shapecast with invalid result", "result") )
    __debugbreak();
  if ( g_physicsBroadphaseQueriesNotAllowedForWorld[v13] )
  {
    v25 = DVARBOOL_physics_allowQueryDisabling;
    if ( !DVARBOOL_physics_allowQueryDisabling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_allowQueryDisabling") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    if ( v25->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8869, ASSERT_TYPE_ASSERT, "(!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool_Internal_DebugName( DVARBOOL_physics_allowQueryDisabling, \"physics_allowQueryDisabling\" ))", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsBroadphaseQueriesNotAllowedForWorld[worldId] || !Dvar_GetBool( physics_allowQueryDisabling )") )
      __debugbreak();
    v10 = result;
  }
  if ( g_physicsQueriesNotAllowedForWorld[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8870, ASSERT_TYPE_ASSERT, "(!g_physicsQueriesNotAllowedForWorld[worldId])", "%s\n\tCan't perform a physics query here - they have been expressly disallowed", "!g_physicsQueriesNotAllowedForWorld[worldId]") )
    __debugbreak();
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  if ( (unsigned int)v13 > 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", (const char *)&queryFormat, "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST") )
    __debugbreak();
  if ( g_physicsBroadphaseRefreshNeeded[v13] )
    Physics_UpdateBroadphase((Physics_WorldId)v13, 1);
  Physics_CheckShapecastConstraints(shape, _R15, _R14);
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [r15]
    vmulss  xmm2, xmm4, dword ptr [r15+4]
    vmulss  xmm1, xmm4, dword ptr [r15+8]
    vmovss  xmm5, dword ptr [rdi]
    vinsertps xmm5, xmm5, dword ptr [rdi+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rdi+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+0D8h+start.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [r14+4]
    vmovss  dword ptr [rsp+0D8h+end.m_quad+4], xmm0
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vmovss  dword ptr [rsp+0D8h+start.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [r14+8]
    vmovss  dword ptr [rsp+0D8h+start.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [r14]
    vrsqrtps xmm4, xmm0
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm0
    vxorps  xmm3, xmm3, xmm3
    vmulps  xmm0, xmm4, xmm0
    vmovss  dword ptr [rsp+0D8h+end.m_quad], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+0D8h+end.m_quad+8], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vmovss  dword ptr [rsp+0D8h+start.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0D8h+end.m_quad+0Ch], xmm3
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+0D8h+var_58.m_vec.m_quad], xmm1
  }
  switch ( (int)v13 )
  {
    case 0:
      Profile_Begin(712);
      break;
    case 1:
      Profile_Begin(713);
      break;
    case 2:
    case 5:
      Profile_Begin(714);
      break;
    case 3:
    case 6:
      Profile_Begin(715);
      break;
    case 4:
    case 7:
      Profile_Begin(716);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 8932, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown world id") )
        __debugbreak();
      break;
  }
  HavokPhysics_Shapecast((Physics_WorldId)v13, shape, &starta, &enda, &v60, extendedData, v10, startResult);
  Profile_EndInternal(NULL);
}

/*
==============
Physics_Shutdown
==============
*/
void Physics_Shutdown(void)
{
  StreamerMemLoan result; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1422, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to shutdown when not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( g_physicsServerWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1423, ASSERT_TYPE_ASSERT, "(!g_physicsServerWorldsCreated)", "%s\n\tPhysics: Trying to shutdown while server worlds still exist", "!g_physicsServerWorldsCreated") )
    __debugbreak();
  if ( g_physicsClientWorldsCreated && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 1424, ASSERT_TYPE_ASSERT, "(!g_physicsClientWorldsCreated)", "%s\n\tPhysics: Trying to shutdown while client worlds still exist", "!g_physicsClientWorldsCreated") )
    __debugbreak();
  PhysicsFX_Shutdown();
  PhysicsQuery_Shutdown();
  HavokPhysics_Shutdown();
  CG_PhysicsObject_Shutdown();
  G_PhysicsObject_Shutdown();
  if ( s_physicsGeneralMemoryBuffer )
  {
    PMem_Free(&result, s_physicsPMemName, PMEM_STACK_GAME);
    StreamerMemLoan::~StreamerMemLoan(&result);
    s_physicsGeneralMemoryBuffer = NULL;
    s_physicsWorldPersistentBufferSizeServerMain = NULL;
    s_physicsWorldPersistentBufferSizeServerDetail = NULL;
    s_physicsWorldPersistentBufferSizeClientPredictive = NULL;
    s_physicsWorldPersistentBufferSizeClientAuthoritative = NULL;
    s_physicsWorldPersistentBufferSizeClientDetail = NULL;
  }
  PhysicsCharacterProxy_Shutdown();
  PhysicsCoverWall_Shutdown();
  g_physicsInitialized = 0;
}

/*
==============
Physics_StepVDB
==============
*/

void __fastcall Physics_StepVDB(Physics_WorldId worldId, double time, bool updateStats)
{
  Physics_WorldId v9; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3254, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step a VDB when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v9 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3255, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step a VDB with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
      __debugbreak();
  }
  __asm
  {
    vmovaps xmm1, xmm6; time
    vmovaps xmm6, [rsp+58h+var_18]
  }
  HavokPhysics_StepVDB(worldId, *(float *)&_XMM1, updateStats);
}

/*
==============
Physics_StepWorld
==============
*/

void __fastcall Physics_StepWorld(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, double stepTimeOverride)
{
  __int64 v7; 
  Physics_WorldInfo *v9; 
  LocalClientNum_t LocalClientForWorld; 
  float fmt; 
  __int64 v17; 
  int v18; 
  int data[6]; 

  __asm
  {
    vmovaps [rsp+0A8h+var_48], xmm6
    vmovaps xmm6, xmm3
  }
  v7 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3205, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v7 > 7 )
  {
    v18 = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3206, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to STep World with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v18) )
      __debugbreak();
  }
  v9 = &s_physicsWorldInfos[v7];
  if ( Com_GameIsPaused() && (unsigned int)v7 > 1 )
  {
    Physics_UpdateWorld((Physics_WorldId)v7, 1);
    if ( Physics_IsAuthoritativeWorld((Physics_WorldId)v7) )
    {
      LocalClientForWorld = Physics_GetLocalClientForWorld((Physics_WorldId)v7);
      Physics_UpdateWorld((Physics_WorldId)(3 * LocalClientForWorld + 4), 1);
    }
  }
  else if ( v9->isMultiThreaded )
  {
    data[1] = v9->timePostStep;
    data[0] = v7;
    __asm { vmovss  [rsp+0A8h+var_58], xmm6 }
    data[2] = stepIndex;
    data[3] = numStepsPlanned;
    Sys_AddWorkerCmd(WRKCMD_PHYSICS_STEP_WORLD_START, data);
  }
  else
  {
    __asm { vmovss  dword ptr [rsp+0A8h+fmt], xmm6 }
    Physics_StepWorldStart((Physics_WorldId)v7, v9->timePostStep, stepIndex, numStepsPlanned, fmt);
    if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2846, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World Step when system is not initialized", "g_physicsInitialized") )
      __debugbreak();
    if ( (unsigned int)v7 > 7 )
    {
      LODWORD(v17) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2847, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World Step with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v17) )
        __debugbreak();
    }
    Profile_Begin(((unsigned int)v7 > 1) + 608);
    __asm { vmovaps xmm3, xmm6; stepTimeOverride }
    HavokPhysics_StepWorldPrep((Physics_WorldId)v7, stepIndex, numStepsPlanned, *(float *)&_XMM3);
    __asm { vmovaps xmm3, xmm6; stepTimeOverride }
    HavokPhysics_StepWorldCollide((Physics_WorldId)v7, stepIndex, numStepsPlanned, *(float *)&_XMM3);
    Physics_SetBroadphaseNeedsRefresh((const Physics_WorldId)v7, 0);
    __asm { vmovaps xmm3, xmm6; stepTimeOverride }
    HavokPhysics_StepWorldSolve((Physics_WorldId)v7, stepIndex, numStepsPlanned, *(float *)&_XMM3);
    __asm { vmovaps xmm3, xmm6; stepTimeOverride }
    HavokPhysics_StepWorldFX((Physics_WorldId)v7, stepIndex, numStepsPlanned, *(float *)&_XMM3);
    Profile_EndInternal(NULL);
    Physics_StepWorldPhysicsObjects((Physics_WorldId)v7, stepIndex, numStepsPlanned);
    Physics_StepWorldDetail((Physics_WorldId)v7, stepIndex, numStepsPlanned);
    Physics_StepWorldEnd((Physics_WorldId)v7, stepIndex, numStepsPlanned);
  }
  __asm { vmovaps xmm6, [rsp+0A8h+var_48] }
}

/*
==============
Physics_StepWorldDetail
==============
*/
void Physics_StepWorldDetail(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  __int64 v5; 
  void (__fastcall *v6)(Physics_WorldId, int, int); 
  int v7; 

  v5 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2930, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World Detail when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v5 > 7 )
  {
    v7 = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2931, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World Detail with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "physics step world detail");
  Profile_Begin(((unsigned int)v5 > 1) + 617);
  HavokPhysics_StepWorldDetail((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  v6 = s_physicsStepWorldDetailFns[v5];
  if ( v6 )
    v6((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  Profile_EndInternal(NULL);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_StepWorldEnd
==============
*/
void Physics_StepWorldEnd(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  __int64 v5; 
  void (__fastcall *v6)(Physics_WorldId, int, int); 
  int v7; 

  v5 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2965, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World End when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v5 > 7 )
  {
    v7 = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2966, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World End with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "physics step world end");
  Profile_Begin(((unsigned int)v5 > 1) + 619);
  HavokPhysics_StepWorldEnd((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  v6 = s_physicsAfterStepWorldFns[v5];
  if ( v6 )
    v6((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  Profile_EndInternal(NULL);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_StepWorldPhysicsObjects
==============
*/
void Physics_StepWorldPhysicsObjects(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  __int64 v5; 
  void (__fastcall *v6)(Physics_WorldId, int, int); 
  int v7; 

  v5 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2895, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World PhysicsObjects when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v5 > 7 )
  {
    v7 = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2896, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World PhysicsObjects with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "physics step world physicsobjects");
  Profile_Begin(((unsigned int)v5 > 1) + 613);
  HavokPhysics_StepWorldPhysicsObjects((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  v6 = s_physicsStepWorldPhysicsObjectsFns[v5];
  if ( v6 )
    v6((Physics_WorldId)v5, stepIndex, numStepsPlanned);
  Profile_EndInternal(NULL);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_StepWorldStart
==============
*/
void Physics_StepWorldStart(Physics_WorldId worldId, int timePostStep, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  __int64 v9; 
  int v10; 
  hkMonitorStream *Value; 
  hkMonitorStream *v13; 
  int v17; 

  __asm { vmovaps [rsp+78h+var_28], xmm6 }
  v9 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2753, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Step World Start when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v9 > 7 )
  {
    v17 = v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2754, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Step World Start with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v17) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "physics step world start");
  v10 = 606;
  if ( (unsigned int)v9 > 1 )
    v10 = 607;
  Profile_Begin(v10);
  __asm { vmovss  xmm6, [rsp+78h+stepTimeOverride] }
  if ( s_physicsBeforeStepWorldFns[v9] )
  {
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v13 = Value;
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtBefore Step world Fn");
    __asm { vmovss  dword ptr [rsp+78h+fmt], xmm6 }
    ((void (__fastcall *)(Physics_WorldId, int, int, int))s_physicsBeforeStepWorldFns[v9])((Physics_WorldId)v9, timePostStep, stepIndex, numStepsPlanned);
    if ( v13 )
      hkMonitorStream::timerEnd(v13, "Et");
  }
  __asm { vmovaps xmm3, xmm6; stepTimeOverride }
  HavokPhysics_StepWorldStart((Physics_WorldId)v9, stepIndex, numStepsPlanned, *(float *)&_XMM3);
  Profile_EndInternal(NULL);
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_SubscribeToTriggerEvent
==============
*/
void Physics_SubscribeToTriggerEvent(Physics_WorldId worldId, unsigned int bodyId)
{
  HavokPhysics_SubscribeToEvent(worldId, TRIGGER, (hknpBodyId)bodyId, Physics_HavokTriggerVolumeEvent, "IW Trigger");
}

/*
==============
Physics_SwapPhysicsAsset
==============
*/
void Physics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3715, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Swap PhysicsAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (to->usageCounter.serverEnt || to->usageCounter.clientEnt || to->usageCounter.dynEnt) && DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( to->usageCounter.serverEnt )
      G_Utils_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForPhysicsAssetChange(to);
    if ( to->usageCounter.dynEnt )
      DynEnt_PrepareForPhysicsAssetChange(to);
  }
  HavokPhysics_SwapPhysicsAsset(from, to);
}

/*
==============
Physics_SwapPhysicsSFXEventAsset
==============
*/
void Physics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3575, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Swap PhysicsSFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_SwapPhysicsSFXEventAsset(from, to);
}

/*
==============
Physics_SwapPhysicsVFXEventAsset
==============
*/
void Physics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3630, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Swap PhysicsVFXEventAsset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_SwapPhysicsVFXEventAsset(from, to);
}

/*
==============
Physics_SwapXModelAsset
==============
*/
void Physics_SwapXModelAsset(XModel *from, XModel *to)
{
  char v4; 
  PhysicsAsset *physicsAsset; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4201, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Swap XModel Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( to->physicsAsset || from->physicsAsset )
  {
    v4 = 1;
  }
  else
  {
    v4 = 0;
    if ( !to->physicsUsageCounter.serverEnt && !to->physicsUsageCounter.clientEnt && !to->physicsUsageCounter.dynEnt )
      return;
  }
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    if ( v4 )
    {
      physicsAsset = to->physicsAsset;
      if ( !physicsAsset || physicsAsset->usageCounter.serverEnt )
      {
        G_Utils_PhysicsPrepareForPhysicsAssetChange(to, physicsAsset);
        physicsAsset = to->physicsAsset;
      }
      if ( !physicsAsset || physicsAsset->usageCounter.clientEnt )
        CG_Entity_PhysicsPrepareForPhysicsAssetChange(to, physicsAsset);
    }
    if ( to->physicsUsageCounter.serverEnt )
      G_Utils_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.clientEnt )
      CG_Entity_PhysicsPrepareForXModelChange(to);
    if ( to->physicsUsageCounter.dynEnt )
      DynEnt_PrepareForXModelChange(to);
  }
}

/*
==============
Physics_SwapXModelDetailCollisionAsset
==============
*/
void Physics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 4113, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Swap XModelDetailCollision Asset when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( DB_ShouldUpdateGameOnPhysicsChange() )
  {
    G_Utils_PhysicsPrepareForXModelDetailCollisionChange(to);
    CG_Entity_PhysicsPrepareForXModelDetailCollisionChange(to);
    DynEnt_PrepareForXModelDetailCollisionChange(to);
  }
  HavokPhysics_SwapXModelDetailCollisionAsset(from, to);
}

/*
==============
Physics_TakeMemorySnapshot
==============
*/
void Physics_TakeMemorySnapshot(const char *filename)
{
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 12975, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Take a memory snapshot when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_TakeMemorySnapshot(filename);
}

/*
==============
Physics_TakeSnapshot
==============
*/
void Physics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  Physics_WorldId v6; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 12961, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Take Snapshot when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 12962, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to take Snapshot with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  HavokPhysics_TakeSnapshot(worldId, filename, humanReadable);
}

/*
==============
Physics_TightenConstraint
==============
*/

void __fastcall Physics_TightenConstraint(Physics_WorldId worldId, unsigned int constraintId, PhysicsConstraintLooseningResult *values, double proportion)
{
  __int64 v14; 
  double v15; 
  int v17; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7925, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to tighten constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7926, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to tighten constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId == 0x7FFFFFFF )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7927, ASSERT_TYPE_ASSERT, "(Physics_IsConstraintIdValid( constraintId ))", "%s\n\tPhysics: Trying to tighten constraint with invalid constraint in world %i", "Physics_IsConstraintIdValid( constraintId )", v14) )
      __debugbreak();
  }
  if ( !values )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7928, ASSERT_TYPE_ASSERT, "(values)", "%s\n\tPhysics: Trying to tighten constraint with NULL result in world %i", "values", v14) )
      __debugbreak();
  }
  __asm { vmovss  [rsp+58h+arg_0], xmm6 }
  if ( (v17 & 0x7F800000) == 2139095040 )
    goto LABEL_16;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( (v17 & 0x7F800000u) < 0x7F800000 )
  {
LABEL_16:
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+58h+var_28], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7929, ASSERT_TYPE_ASSERT, "(!IS_NAN(proportion) && proportion >= 0.f && proportion <= 1.f)", "%s\n\tPhysics: Trying to tighten constraint with invalid prop %.2f in world %i", "!IS_NAN(proportion) && proportion >= 0.f && proportion <= 1.f", v15, worldId) )
      __debugbreak();
  }
  else
  {
    __asm { vcomiss xmm6, cs:__real@3f800000 }
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovaps xmm3, xmm6; proportion
    vmovaps xmm6, [rsp+58h+var_18]
  }
  HavokPhysics_TightenConstraint(worldId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)constraintId, values, *(float *)&_XMM3);
}

/*
==============
Physics_ToggleCGDynEntAuthoritativeDebugData
==============
*/
void Physics_ToggleCGDynEntAuthoritativeDebugData(LocalClientNum_t localClientNum)
{
  __int64 v1; 

  v1 = localClientNum;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntCount + v1 * 208) = 0;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntSimpleCount + v1 * 208) = 0;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntSimpleAdditionalBoneCount + v1 * 208) = 0;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntComplexCount + v1 * 208) = 0;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntComplexBodyCount + v1 * 208) = 0;
  *(int *)((char *)&s_debugProfileData.clientData[0].dynEntsData[1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex].dynEntComplexAdditionalBoneCount + v1 * 208) = 0;
  s_debugProfileData.clientData[v1].dynEntsDataBufferIndex = 1 - s_debugProfileData.clientData[v1].dynEntsDataBufferIndex;
}

/*
==============
Physics_TransientZoneLoaded
==============
*/
void Physics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  if ( g_physicsInitialized )
    HavokPhysics_TransientZoneLoaded(worldTransientIndex, fullLoad);
}

/*
==============
Physics_TransientZoneUnloading
==============
*/
void Physics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  if ( g_physicsInitialized )
    HavokPhysics_TransientZoneUnloading(worldTransientIndex, fullUnload);
}

/*
==============
Physics_UnlockWorld
==============
*/
void Physics_UnlockWorld(Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3279, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Unlock World when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3280, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Unlock World with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasAnyLock_Physics();
  HavokPhysics_UnlockWorld(worldId);
}

/*
==============
Physics_UnsubscribeFromTriggerEvent
==============
*/
void Physics_UnsubscribeFromTriggerEvent(Physics_WorldId worldId, unsigned int bodyId)
{
  HavokPhysics_UnsubscribeFromEvent(worldId, TRIGGER, (hknpBodyId)bodyId, Physics_HavokTriggerVolumeEvent);
}

/*
==============
Physics_UpdateBroadphase
==============
*/
void Physics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  __int64 v3; 
  void (__fastcall *v4)(Physics_WorldId); 
  int v5; 

  v3 = worldId;
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_UpdateBroadphase");
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7762, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Update Broadphase when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v3 > 7 )
  {
    v5 = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7763, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Update Broadphase with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
      __debugbreak();
  }
  Physics_LockWorld((Physics_WorldId)v3);
  HavokPhysics_UpdateBroadphase((Physics_WorldId)v3, updateAll);
  Physics_UnlockWorld((Physics_WorldId)v3);
  Physics_SetBroadphaseNeedsRefresh((const Physics_WorldId)v3, 0);
  v4 = s_physicsBroadphaseUpdateFns[v3];
  if ( v4 )
    v4((Physics_WorldId)v3);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_UpdateClientGravity
==============
*/
void Physics_UpdateClientGravity(Physics_WorldId worldId, LocalClientNum_t localClientNum)
{
  OmnvarData *Data; 
  HavokPhysicsWorld *MutableWorld; 
  OmnvarData *v23; 
  bool v25; 
  bool v26; 
  __int64 v41; 
  Physics_WorldId v42; 
  int v43[4]; 
  char v45; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  _RBP = localClientNum;
  _R14 = CG_Omnvar_GetData(localClientNum, s_physicsClientWorldGravityOmnvarIdxX);
  _RDI = CG_Omnvar_GetData((LocalClientNum_t)_RBP, s_physicsClientWorldGravityOmnvarIdxY);
  Data = CG_Omnvar_GetData((LocalClientNum_t)_RBP, s_physicsClientWorldGravityOmnvarIdxZ);
  _RSI = Data;
  if ( (!_R14 || !_RDI || !Data) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2324, ASSERT_TYPE_ASSERT, "(xData && yData && zData)", "%s\n\tCG_PhysicsSetGravity has invalid omnvars - check omnvar.csv", "xData && yData && zData") )
    __debugbreak();
  __asm
  {
    vmovss  xmm6, dword ptr [r14+4]
    vmovss  xmm7, dword ptr [rdi+4]
    vmovss  xmm8, dword ptr [rsi+4]
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 27, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Set Gravity when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v42 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 28, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Set Gravity with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v42) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, cs:__real@3d000000
    vmulss  xmm0, xmm6, xmm2
    vmulss  xmm1, xmm7, xmm2
    vmovss  [rsp+0B8h+var_78], xmm0
    vmovss  [rsp+0B8h+var_74], xmm1
    vmulss  xmm0, xmm8, xmm2
    vxorps  xmm1, xmm1, xmm1
    vmovss  [rsp+0B8h+var_70], xmm0
    vmovss  [rsp+0B8h+var_6C], xmm1
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v41) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 81, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set Gravity with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v41) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  MutableWorld->world->setGravity(&MutableWorld->world->hknpWorldWriter, (const hkVector4f *)v43);
  if ( Physics_IsAuthoritativeWorld(worldId) )
  {
    _R14 = CG_Omnvar_GetData((LocalClientNum_t)_RBP, s_physicsClientWorldGravityRagdollOmnvarIdx);
    _RDI = CG_Omnvar_GetData((LocalClientNum_t)_RBP, s_physicsClientWorldGravityDynentOmnvarIdx);
    v23 = CG_Omnvar_GetData((LocalClientNum_t)_RBP, s_physicsClientWorldGravityParticleOmnvarIdx);
    _RSI = v23;
    if ( !_R14 || !_RDI || (v25 = v23 == NULL, !v23) )
    {
      v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2341, ASSERT_TYPE_ASSERT, "(ragdollScalarValue && dynentScalarValue && particleScalarValue)", "%s\n\tCG_PhysicsSetGravity has invalid omnvars - check omnvar.csv", "ragdollScalarValue && dynentScalarValue && particleScalarValue");
      v25 = !v26;
      if ( v26 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm6, dword ptr [rsi+4]
      vmovss  xmm8, dword ptr [r14+4]
      vmovss  xmm7, dword ptr [rdi+4]
    }
    _RSI = g_physicsClientWorldGravityScalars;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+rbp*4+30h]
      vucomiss xmm0, xmm8
    }
    if ( !v25 )
    {
      __asm { vdivss  xmm2, xmm8, xmm0; scalar }
      HavokPhysics_UpdateGravityScalar(worldId, Physics_GravityType_Ragdoll, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rsi+rbp*4+30h], xmm8 }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+rbp*4+8]
      vucomiss xmm0, xmm7
    }
    if ( !v25 )
    {
      __asm { vdivss  xmm2, xmm7, xmm0; scalar }
      HavokPhysics_UpdateGravityScalar(worldId, Physics_GravityType_Dynent, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rsi+rbp*4+8], xmm7 }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+rbp*4+38h]
      vucomiss xmm0, xmm6
    }
    if ( !v25 )
    {
      __asm { vdivss  xmm2, xmm6, xmm0; scalar }
      HavokPhysics_UpdateGravityScalar(worldId, Physics_GravityType_Particle, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rsi+rbp*4+38h], xmm6 }
    }
  }
  _R11 = &v45;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+0B8h+var_48]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
Physics_UpdateLoosenedConstraint
==============
*/
bool Physics_UpdateLoosenedConstraint(Physics_WorldId worldId, unsigned int constraintId, const vec4_t *bodyAOrientation, const vec3_t *bodyAPosition, const vec4_t *bodyBOrientation, const vec3_t *bodyBPosition, PhysicsConstraintLooseningResult *result)
{
  bool updated; 
  __int64 v62; 
  int v63; 
  int v64; 
  int v65; 
  int v66; 
  int v67; 
  int v68; 
  int v69; 
  int v70; 
  int v71; 
  int v72; 
  int v73; 
  int v74; 
  int v75; 
  int v76; 
  hkQuaternionf qi; 
  hkQuaternionf v78; 
  hkTransformf v79; 
  hkTransformf v80; 
  char v81; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
  }
  _R15 = bodyAPosition;
  _RDI = bodyAOrientation;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7872, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to loosen constraint when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7873, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to loosen constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId == 0x7FFFFFFF )
  {
    LODWORD(v62) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7874, ASSERT_TYPE_ASSERT, "(Physics_IsConstraintIdValid( constraintId ))", "%s\n\tPhysics: Trying to loosen constraint with invalid constraint in world %i", "Physics_IsConstraintIdValid( constraintId )", v62) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v63 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v64 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v65 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7875, ASSERT_TYPE_ASSERT, "(!IS_NAN( bodyAPosition[0] ) && !IS_NAN( bodyAPosition[1] ) && !IS_NAN( bodyAPosition[2] ))", "%s\n\tPhysics: Trying to update loosened constraint with invalid bodyAPosition", "!IS_NAN( bodyAPosition[0] ) && !IS_NAN( bodyAPosition[1] ) && !IS_NAN( bodyAPosition[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v66 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v67 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v68 & 0x7F800000) == 2139095040 )
    goto LABEL_39;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v69 & 0x7F800000) == 2139095040 )
  {
LABEL_39:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7876, ASSERT_TYPE_ASSERT, "(!IS_NAN( bodyAOrientation[0] ) && !IS_NAN( bodyAOrientation[1] ) && !IS_NAN( bodyAOrientation[2] ) && !IS_NAN( bodyAOrientation[3] ))", "%s\n\tPhysics: Trying to update loosened constraint with invalid bodyAOrientation", "!IS_NAN( bodyAOrientation[0] ) && !IS_NAN( bodyAOrientation[1] ) && !IS_NAN( bodyAOrientation[2] ) && !IS_NAN( bodyAOrientation[3] )") )
      __debugbreak();
  }
  _R14 = bodyBPosition;
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v70 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v71 & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v72 & 0x7F800000) == 2139095040 )
  {
LABEL_40:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7877, ASSERT_TYPE_ASSERT, "(!IS_NAN( bodyBPosition[0] ) && !IS_NAN( bodyBPosition[1] ) && !IS_NAN( bodyBPosition[2] ))", "%s\n\tPhysics: Trying to update loosened constraint with invalid bodyBPosition", "!IS_NAN( bodyBPosition[0] ) && !IS_NAN( bodyBPosition[1] ) && !IS_NAN( bodyBPosition[2] )") )
      __debugbreak();
  }
  _RBX = bodyBOrientation;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v73 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v74 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v75 & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+1A0h+var_160], xmm0
  }
  if ( (v76 & 0x7F800000) == 2139095040 )
  {
LABEL_41:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7878, ASSERT_TYPE_ASSERT, "(!IS_NAN( bodyBOrientation[0] ) && !IS_NAN( bodyBOrientation[1] ) && !IS_NAN( bodyBOrientation[2] ) && !IS_NAN( bodyBOrientation[3] ))", "%s\n\tPhysics: Trying to update loosened constraint with invalid bodyBOrientation", "!IS_NAN( bodyBOrientation[0] ) && !IS_NAN( bodyBOrientation[1] ) && !IS_NAN( bodyBOrientation[2] ) && !IS_NAN( bodyBOrientation[3] )") )
      __debugbreak();
  }
  if ( !result )
  {
    LODWORD(v62) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7879, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tPhysics: Trying to loosen constraint with NULL result in world %i", "result", v62) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm2, cs:__real@3d000000
    vmovss  xmm0, dword ptr [r15]
    vmovups xmm1, xmmword ptr [rdi]
    vmulss  xmm6, xmm2, dword ptr [r15+4]
    vmulss  xmm7, xmm2, dword ptr [r15+8]
    vmulss  xmm8, xmm2, dword ptr [r14+4]
    vmulss  xmm9, xmm2, dword ptr [r14+8]
    vmulss  xmm10, xmm0, xmm2
    vmovss  xmm0, dword ptr [r14]
    vmovaps xmmword ptr [rsp+1A0h+qi.m_vec.m_quad], xmm1
    vmovups xmm1, xmmword ptr [rbx]
    vmulss  xmm12, xmm0, xmm2
    vmovaps xmmword ptr [rsp+1A0h+var_130.m_vec.m_quad], xmm1
    vxorps  xmm11, xmm11, xmm11
  }
  hkRotationImpl<float>::set(&v80.m_rotation, &qi);
  __asm
  {
    vinsertps xmm10, xmm10, xmm6, 10h
    vinsertps xmm10, xmm10, xmm7, 20h ; ' '
    vinsertps xmm10, xmm10, xmm11, 30h ; '0'
    vmovups [rbp+0A0h+var_B0], xmm10
  }
  hkRotationImpl<float>::set(&v79.m_rotation, &v78);
  __asm
  {
    vinsertps xmm12, xmm12, xmm8, 10h
    vinsertps xmm12, xmm12, xmm9, 20h ; ' '
    vinsertps xmm12, xmm12, xmm11, 30h ; '0'
    vmovups [rbp+0A0h+var_F0], xmm12
  }
  updated = HavokPhysics_UpdateLoosenedConstraint(worldId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)constraintId, &v80, &v79, result);
  _R11 = &v81;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
  return updated;
}

/*
==============
Physics_UpdateVDB
==============
*/

void __fastcall Physics_UpdateVDB(__int64 a1, double _XMM1_8)
{
  int i; 

  for ( i = 0; i <= 1; ++i )
  {
    Physics_LockWorld((Physics_WorldId)i);
    __asm { vxorps  xmm1, xmm1, xmm1; time }
    Physics_StepVDB((Physics_WorldId)i, *(float *)&_XMM1_8, 1);
    Physics_UnlockWorld((Physics_WorldId)i);
  }
}

/*
==============
Physics_UpdateWorld
==============
*/
void Physics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  __int64 v4; 
  void (__fastcall *v5)(Physics_WorldId); 
  int v6; 
  int v7; 
  int v8; 
  char v9; 
  __int64 v11; 
  int v12; 

  v4 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3068, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Update World when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v4 > 7 )
  {
    v12 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3069, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Update World with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v12) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "physics update world");
  v5 = s_physicsBeforeUpdateWorldFns[v4];
  if ( v5 )
    v5((Physics_WorldId)v4);
  if ( (unsigned int)v4 > 1 )
    v6 = 634 - Physics_IsDetailWorld((Physics_WorldId)v4);
  else
    v6 = 632;
  Profile_Begin(v6);
  Physics_LockWorld((Physics_WorldId)v4);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5785, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Add Pending Bodies when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v4 > 7 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5786, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( !g_physicsClientWorldsCreated && (unsigned int)(v4 - 2) <= 5 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5787, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v11) )
      __debugbreak();
  }
  if ( !g_physicsServerWorldsCreated && (unsigned int)v4 <= 1 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 5788, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Add Pending Bodies in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v11) )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  HavokPhysics_AddPendingBodies((Physics_WorldId)v4);
  if ( (unsigned int)v4 > 1 )
    v7 = 637 - Physics_IsDetailWorld((Physics_WorldId)v4);
  else
    v7 = 635;
  Profile_Begin(v7);
  Physics_UpdateBroadphase((Physics_WorldId)v4, 1);
  Profile_EndInternal(NULL);
  if ( (unsigned int)v4 <= 7 )
    goto LABEL_33;
  LODWORD(v11) = v4;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2089, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Request IsQueryWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
    __debugbreak();
  if ( (unsigned int)v4 <= 7 )
  {
LABEL_33:
    v8 = 146;
    if ( _bittest(&v8, v4) )
    {
      Sys_ProfBeginNamedEvent(0xFF008008, "Physics_FlushMovedStatics");
      if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7787, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Flush Moved Statics when system is not initialized", "g_physicsInitialized") )
        __debugbreak();
      if ( (unsigned int)v4 > 7 )
      {
        LODWORD(v11) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 7788, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Flush Moved Statics with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
          __debugbreak();
      }
      Physics_LockWorld((Physics_WorldId)v4);
      HavokPhysics_FlushMovedStatics((Physics_WorldId)v4);
      Physics_UnlockWorld((Physics_WorldId)v4);
      Sys_ProfEndNamedEvent();
    }
  }
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9860, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DoDeferredQueries against body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)v4 > 7 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 9861, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DoDeferredQueries against body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (unsigned int)v4 > 1 && Physics_IsDetailWorld((Physics_WorldId)v4) )
  {
    v9 = 1;
    CL_Main_SkeletonCacheValidity_Lock(SkeletonCacheValidityLockType_Locked_Physics);
  }
  else
  {
    v9 = 0;
  }
  HavokPhysics_DoDeferredQueries((Physics_WorldId)v4);
  if ( v9 )
    CL_Main_SkeletonCacheValidity_Unlock(SkeletonCacheValidityLockType_Locked_Physics);
  __asm { vxorps  xmm1, xmm1, xmm1; time }
  Physics_StepVDB((Physics_WorldId)v4, *(float *)&_XMM1, syncStats);
  HavokPhysics_UpdateWorld((Physics_WorldId)v4, syncStats);
  Physics_UnlockWorld((Physics_WorldId)v4);
  Profile_EndInternal(NULL);
  Sys_ProfEndNamedEvent();
}

/*
==============
Physics_ValidateWorld
==============
*/
void Physics_ValidateWorld(Physics_WorldId worldId)
{
  Physics_WorldId v2; 

  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v2 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2291, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Validate world with invalid world index: %d", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
      __debugbreak();
  }
  HavokPhysics_ValidateWorld(worldId);
}

/*
==============
Physics_WaitForAllCommandsToFinish
==============
*/
void Physics_WaitForAllCommandsToFinish(void)
{
  if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3437, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
    __debugbreak();
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_START);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_PREP);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_COLLIDE);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_SOLVE);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_FX);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_TASK);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_PHYSICS_OBJECTS);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_END);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_STEP_WORLD_DETAIL);
  Sys_WaitWorkerCmdsOfType(WRKCMD_RAGDOLL_UPDATE);
  if ( s_physicsHasWorkerError )
  {
    s_physicsHasWorkerError = 0;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143EA3040, 884i64);
  }
}

/*
==============
Physics_WaitForPredictiveWorldUpdateCommandToFinish
==============
*/
void Physics_WaitForPredictiveWorldUpdateCommandToFinish(void)
{
  if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3486, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
    __debugbreak();
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_UPDATE_PREDICTIVE_WORLD_PRE);
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_UPDATE_PREDICTIVE_WORLD);
  if ( s_physicsHasWorkerError )
  {
    s_physicsHasWorkerError = 0;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143EA3040, 6200i64);
  }
}

/*
==============
Physics_WaitForPredictiveWorldUpdatePreCommandToFinish
==============
*/
void Physics_WaitForPredictiveWorldUpdatePreCommandToFinish(void)
{
  if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 3469, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
    __debugbreak();
  Sys_WaitWorkerCmdsOfType(WRKCMD_PHYSICS_UPDATE_PREDICTIVE_WORLD_PRE);
  if ( s_physicsHasWorkerError )
  {
    s_physicsHasWorkerError = 0;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143EA3040, 5808i64);
  }
}

/*
==============
Physics_WarpDetailRigidBodyTo
==============
*/
Physics_MovementType Physics_WarpDetailRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphase, bool activate)
{
  __int64 v36; 
  Physics_WorldId v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6793, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Rigid Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v37 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6794, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v37) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v36) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6795, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v36) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6796, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6797, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+88h+hkOrientation.m_vec.m_quad], xmm1
  }
  return HavokPhysics_WarpDetailRigidBodyTo(worldId, (hknpBodyId)bodyId, &hkPosition, &hkOrientation, updateBroadphase, activate);
}

/*
==============
Physics_WarpInstanceTo
==============
*/
bool Physics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphaseIfNecessary)
{
  __int64 v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  int v33; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6656, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Instance when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6657, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6658, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Warp Instance with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v26) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6659, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v32 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+98h+var_58], xmm0
  }
  if ( (v33 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6660, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Instance with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vmovups xmmword ptr [rsp+98h+hkOrientation.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+8], xmm1
    vmovss  dword ptr [rsp+98h+hkPosition.m_quad+0Ch], xmm2
  }
  return HavokPhysics_WarpInstanceTo(worldId, instanceId, &hkPosition, &hkOrientation, updateBroadphaseIfNecessary);
}

/*
==============
Physics_WarpLeafDetailRigidBodyTo
==============
*/
Physics_MovementType Physics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *position, const vec4_t *orientationAsQuat, bool updateBroadphase, bool activate)
{
  __int64 v36; 
  Physics_WorldId v37; 
  int v38; 
  int v39; 
  int v40; 
  int v41; 
  int v42; 
  int v43; 
  int v44; 
  hkVector4f hkPosition; 
  hkQuaternionf hkOrientation; 

  _RBX = orientationAsQuat;
  _RDI = position;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6819, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Rigid Body when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v37 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6820, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v37) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v36) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6821, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v36) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v38 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v39 & 0x7F800000) == 2139095040 )
    goto LABEL_24;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v40 & 0x7F800000) == 2139095040 )
  {
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6822, ASSERT_TYPE_ASSERT, "(!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid position", "!IS_NAN( position[0] ) && !IS_NAN( position[1] ) && !IS_NAN( position[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v41 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v42 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v43 & 0x7F800000) == 2139095040 )
    goto LABEL_25;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+88h+var_48], xmm0
  }
  if ( (v44 & 0x7F800000) == 2139095040 )
  {
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6823, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Rigid Body with invalid orientation", "!IS_NAN( orientationAsQuat[0] ) && !IS_NAN( orientationAsQuat[1] ) && !IS_NAN( orientationAsQuat[2] ) && !IS_NAN( orientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm3, cs:__real@3d000000
    vmulss  xmm0, xmm3, dword ptr [rdi]
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vmulss  xmm1, xmm3, dword ptr [rdi+8]
    vmovss  xmm5, dword ptr [rbx]
    vinsertps xmm5, xmm5, dword ptr [rbx+4], 10h
    vinsertps xmm5, xmm5, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm5, xmm5, dword ptr [rbx+0Ch], 30h ; '0'
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad], xmm0
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+4], xmm2
    vxorps  xmm2, xmm2, xmm2
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
    vmulps  xmm0, xmm0, xmm4
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+8], xmm1
    vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
    vmovss  dword ptr [rsp+88h+hkPosition.m_quad+0Ch], xmm2
    vmulps  xmm2, xmm0, xmm4
    vmulps  xmm0, xmm4, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
    vsubps  xmm3, xmm1, xmm2
    vmulps  xmm2, xmm3, xmm0
    vmulps  xmm1, xmm2, xmm5
    vmovups xmmword ptr [rsp+88h+hkOrientation.m_vec.m_quad], xmm1
  }
  return HavokPhysics_WarpLeafDetailRigidBodyTo(worldId, (hknpBodyId)bodyId, &hkPosition, &hkOrientation, updateBroadphase, activate);
}

/*
==============
Physics_WarpRigidBodyToRelative
==============
*/
void Physics_WarpRigidBodyToRelative(Physics_WorldId worldId, unsigned int bodyId, const vec3_t *startPosition, const vec4_t *startOrientationAsQuat, const vec3_t *endPosition, const vec4_t *endOrientationAsQuat)
{
  __int64 v43; 
  Physics_WorldId v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  int v58; 
  hkVector4f hkEndPosition; 
  hkVector4f hkStartPosition; 
  hkQuaternionf hkEndOrientation; 
  hkQuaternionf hkStartOrientation; 

  _RDI = startOrientationAsQuat;
  _RBP = startPosition;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6951, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Warp Rigid Body relative when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v44 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6952, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v44) )
      __debugbreak();
  }
  if ( (bodyId & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v43) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6953, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v43) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v45 & 0x7F800000) == 2139095040 )
    goto LABEL_35;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v46 & 0x7F800000) == 2139095040 )
    goto LABEL_35;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v47 & 0x7F800000) == 2139095040 )
  {
LABEL_35:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6954, ASSERT_TYPE_ASSERT, "(!IS_NAN( startPosition[0] ) && !IS_NAN( startPosition[1] ) && !IS_NAN( startPosition[2] ))", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid start position", "!IS_NAN( startPosition[0] ) && !IS_NAN( startPosition[1] ) && !IS_NAN( startPosition[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v48 & 0x7F800000) == 2139095040 )
    goto LABEL_36;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v49 & 0x7F800000) == 2139095040 )
    goto LABEL_36;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v50 & 0x7F800000) == 2139095040 )
    goto LABEL_36;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v51 & 0x7F800000) == 2139095040 )
  {
LABEL_36:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6955, ASSERT_TYPE_ASSERT, "(!IS_NAN( startOrientationAsQuat[0] ) && !IS_NAN( startOrientationAsQuat[1] ) && !IS_NAN( startOrientationAsQuat[2] ) && !IS_NAN( startOrientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid start orientation", "!IS_NAN( startOrientationAsQuat[0] ) && !IS_NAN( startOrientationAsQuat[1] ) && !IS_NAN( startOrientationAsQuat[2] ) && !IS_NAN( startOrientationAsQuat[3] )") )
      __debugbreak();
  }
  _RSI = endPosition;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v52 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v53 & 0x7F800000) == 2139095040 )
    goto LABEL_37;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v54 & 0x7F800000) == 2139095040 )
  {
LABEL_37:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6956, ASSERT_TYPE_ASSERT, "(!IS_NAN( endPosition[0] ) && !IS_NAN( endPosition[1] ) && !IS_NAN( endPosition[2] ))", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid end position", "!IS_NAN( endPosition[0] ) && !IS_NAN( endPosition[1] ) && !IS_NAN( endPosition[2] )") )
      __debugbreak();
  }
  _RBX = endOrientationAsQuat;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v55 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v56 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v57 & 0x7F800000) == 2139095040 )
    goto LABEL_38;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  [rsp+0B8h+var_78], xmm0
  }
  if ( (v58 & 0x7F800000) == 2139095040 )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 6957, ASSERT_TYPE_ASSERT, "(!IS_NAN( endOrientationAsQuat[0] ) && !IS_NAN( endOrientationAsQuat[1] ) && !IS_NAN( endOrientationAsQuat[2] ) && !IS_NAN( endOrientationAsQuat[3] ))", "%s\n\tPhysics: Trying to Warp Rigid Body relative with invalid end orientation", "!IS_NAN( endOrientationAsQuat[0] ) && !IS_NAN( endOrientationAsQuat[1] ) && !IS_NAN( endOrientationAsQuat[2] ) && !IS_NAN( endOrientationAsQuat[3] )") )
      __debugbreak();
  }
  CG_EntityWorkers_CheckHasWriteLock_Physics();
  __asm
  {
    vmovss  xmm4, cs:__real@3d000000
    vmulss  xmm0, xmm4, dword ptr [rbp+0]
    vmulss  xmm2, xmm4, dword ptr [rbp+4]
    vmulss  xmm1, xmm4, dword ptr [rbp+8]
    vmovss  dword ptr [rsp+0B8h+hkStartPosition.m_quad], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vinsertps xmm0, xmm0, dword ptr [rdi+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rdi+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rdi+0Ch], 30h ; '0'
    vmovups xmmword ptr [rsp+0B8h+hkStartOrientation.m_vec.m_quad], xmm0
    vmulss  xmm0, xmm4, dword ptr [rsi+4]
    vmovss  dword ptr [rsp+0B8h+hkEndPosition.m_quad+4], xmm0
    vmovss  xmm0, dword ptr [rbx]
    vinsertps xmm0, xmm0, dword ptr [rbx+4], 10h
    vinsertps xmm0, xmm0, dword ptr [rbx+8], 20h ; ' '
    vinsertps xmm0, xmm0, dword ptr [rbx+0Ch], 30h ; '0'
    vxorps  xmm3, xmm3, xmm3
    vmovss  dword ptr [rsp+0B8h+hkStartPosition.m_quad+4], xmm2
    vmulss  xmm2, xmm4, dword ptr [rsi+8]
    vmovss  dword ptr [rsp+0B8h+hkStartPosition.m_quad+8], xmm1
    vmulss  xmm1, xmm4, dword ptr [rsi]
    vmovups xmmword ptr [rsp+0B8h+var_48.m_vec.m_quad], xmm0
    vmovss  dword ptr [rsp+0B8h+hkStartPosition.m_quad+0Ch], xmm3
    vmovss  dword ptr [rsp+0B8h+hkEndPosition.m_quad], xmm1
    vmovss  dword ptr [rsp+0B8h+hkEndPosition.m_quad+8], xmm2
    vmovss  dword ptr [rsp+0B8h+hkEndPosition.m_quad+0Ch], xmm3
  }
  HavokPhysics_WarpRigidBodyToRelative(worldId, (hknpBodyId)bodyId, &hkStartPosition, &hkStartOrientation, &hkEndPosition, &hkEndOrientation);
}

/*
==============
Physics_Write
==============
*/
void Physics_Write(MemoryFile *memFile)
{
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_Write");
  MemFile_WriteSentinel(memFile, 0x42158u);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_FIRST);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_SERVER_DETAIL);
  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_Write");
  HavokPhysics_Write(memFile);
  Sys_ProfEndNamedEvent();
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_FIRST);
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\core\\physics.cpp", 2290, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Validate world when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  HavokPhysics_ValidateWorld(PHYSICS_WORLD_ID_SERVER_DETAIL);
  G_PhysicsCharacterProxy_Write(memFile);
  PhysicsCoverWall_Write(memFile);
  G_PhysicsObject_Write(memFile);
  PhysicsVehicle_Write(memFile);
  PhysicsVolume_Write(memFile);
  PhysicsGravityModifier_Write(memFile);
  PhysicsForceAction_Write(memFile);
  Sys_ProfBeginNamedEvent(0xFF008008, "Physics_UpdateBroadphase");
  Physics_UpdateBroadphase(PHYSICS_WORLD_ID_FIRST, 1);
  Physics_UpdateBroadphase(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
  Sys_ProfEndNamedEvent();
  Sys_ProfEndNamedEvent();
}

