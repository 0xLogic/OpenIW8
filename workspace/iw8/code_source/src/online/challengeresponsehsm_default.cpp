/*
==============
ChallengeResponseHSM_default::HSM_PrintDebugInfo
==============
*/

void __fastcall ChallengeResponseHSM_default::HSM_PrintDebugInfo(ChallengeResponseHSM_default *this, const char *pDebugString)
{
  ?HSM_PrintDebugInfo@ChallengeResponseHSM_default@@UEAAXPEBD@Z(this, pDebugString);
}

/*
==============
ChallengeResponseHSM_default::CopyCompleteChallenge
==============
*/

void __fastcall ChallengeResponseHSM_default::CopyCompleteChallenge(ChallengeResponseHSM_default *this, LiveAntiCheatPendingChallenge *pendingChallenge)
{
  ?CopyCompleteChallenge@ChallengeResponseHSM_default@@QEAAXPEAULiveAntiCheatPendingChallenge@@@Z(this, pendingChallenge);
}

/*
==============
ChallengeResponseHSM_default::ProcessChallenge
==============
*/

bool __fastcall ChallengeResponseHSM_default::ProcessChallenge(ChallengeResponseHSM_default *this, const int controllerindex_in, LiveAntiCheatPendingChallenge *pendingChallenge)
{
  return ?ProcessChallenge@ChallengeResponseHSM_default@@QEAA_NHPEAULiveAntiCheatPendingChallenge@@@Z(this, controllerindex_in, pendingChallenge);
}

/*
==============
ChallengeResponseHSM_default::Update
==============
*/

void __fastcall ChallengeResponseHSM_default::Update(ChallengeResponseHSM_default *this, int dt)
{
  ?Update@ChallengeResponseHSM_default@@QEAAXH@Z(this, dt);
}

/*
==============
ChallengeResponseHSM_default::OnEnterHandleChallenge
==============
*/

void __fastcall ChallengeResponseHSM_default::OnEnterHandleChallenge(ChallengeResponseHSM_default *this)
{
  ?OnEnterHandleChallenge@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ChallengeResponseHSM_default::ResetResponses
==============
*/

void __fastcall ChallengeResponseHSM_default::ResetResponses(ChallengeResponseHSM_default *this, bool logUnsent)
{
  ?ResetResponses@ChallengeResponseHSM_default@@QEAAX_N@Z(this, logUnsent);
}

/*
==============
ChallengeResponseHSM_default::AddNewChallenge
==============
*/

void __fastcall ChallengeResponseHSM_default::AddNewChallenge(ChallengeResponseHSM_default *this, int controllerIndex, const bdAntiCheatChallenge *challenge)
{
  ?AddNewChallenge@ChallengeResponseHSM_default@@QEAAXHPEBVbdAntiCheatChallenge@@@Z(this, controllerIndex, challenge);
}

/*
==============
ChallengeResponseHSM_default::CheckForQueuedChallenges
==============
*/

void __fastcall ChallengeResponseHSM_default::CheckForQueuedChallenges(ChallengeResponseHSM_default *this)
{
  ?CheckForQueuedChallenges@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ChallengeResponseHSM_default::~ChallengeResponseHSM_default
==============
*/

void __fastcall ChallengeResponseHSM_default::~ChallengeResponseHSM_default(ChallengeResponseHSM_default *this)
{
  ??1ChallengeResponseHSM_default@@UEAA@XZ(this);
}

/*
==============
ChallengeResponseHSM_default::UpdateSendResponse
==============
*/

void __fastcall ChallengeResponseHSM_default::UpdateSendResponse(ChallengeResponseHSM_default *this)
{
  ?UpdateSendResponse@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ExtractDataFromBuffer<char>
==============
*/

void __fastcall ExtractDataFromBuffer<char>(int *pos, unsigned __int8 *in, char *out, int size)
{
  ??$ExtractDataFromBuffer@D@@YAXPEAHPEAEPEADH@Z(pos, in, out, size);
}

/*
==============
ChallengeResponseHSM_default::ChallengeResponseHSM_default
==============
*/

void __fastcall ChallengeResponseHSM_default::ChallengeResponseHSM_default(ChallengeResponseHSM_default *this)
{
  ??0ChallengeResponseHSM_default@@QEAA@XZ(this);
}

/*
==============
ChallengeResponseHSM_default::OnEnterSendResponse
==============
*/

void __fastcall ChallengeResponseHSM_default::OnEnterSendResponse(ChallengeResponseHSM_default *this)
{
  ?OnEnterSendResponse@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ExtractDataFromBuffer<int>
==============
*/

void __fastcall ExtractDataFromBuffer<int>(int *pos, unsigned __int8 *in, int *out, int size)
{
  ??$ExtractDataFromBuffer@H@@YAXPEAHPEAE0H@Z(pos, in, out, size);
}

/*
==============
ChallengeResponseHSM_default::SetResponseDataBlob
==============
*/

void __fastcall ChallengeResponseHSM_default::SetResponseDataBlob(ChallengeResponseHSM_default *this)
{
  ?SetResponseDataBlob@ChallengeResponseHSM_default@@QEAAXXZ(this);
}

/*
==============
ChallengeResponseHSM_default::StartUpdateFrame
==============
*/

void ChallengeResponseHSM_default::StartUpdateFrame(void)
{
  ?StartUpdateFrame@ChallengeResponseHSM_default@@SAXXZ();
}

/*
==============
ChallengeResponseHSM_default::UpdateProcessChallenge
==============
*/

void __fastcall ChallengeResponseHSM_default::UpdateProcessChallenge(ChallengeResponseHSM_default *this)
{
  ?UpdateProcessChallenge@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ChallengeResponseHSM_default::OnEnterResponseFailure
==============
*/

void __fastcall ChallengeResponseHSM_default::OnEnterResponseFailure(ChallengeResponseHSM_default *this)
{
  ?OnEnterResponseFailure@ChallengeResponseHSM_default@@UEAAXXZ(this);
}

/*
==============
ChallengeResponseHSM_default::Init
==============
*/

void __fastcall ChallengeResponseHSM_default::Init(ChallengeResponseHSM_default *this, int controllerIndex)
{
  ?Init@ChallengeResponseHSM_default@@QEAAXH@Z(this, controllerIndex);
}

/*
==============
ChallengeResponseHSM_default::ResetAllChallenges
==============
*/

void __fastcall ChallengeResponseHSM_default::ResetAllChallenges(ChallengeResponseHSM_default *this)
{
  ?ResetAllChallenges@ChallengeResponseHSM_default@@QEAAXXZ(this);
}

/*
==============
ExtractDataFromBuffer<char>
==============
*/
void ExtractDataFromBuffer<char>(int *pos, unsigned __int8 *in, char *out, int size)
{
  memcpy_0(out, &in[*pos], size);
  *pos += size;
}

/*
==============
ExtractDataFromBuffer<int>
==============
*/
void ExtractDataFromBuffer<int>(int *pos, unsigned __int8 *in, int *out, int size)
{
  memcpy_0(out, &in[*pos], size);
  *pos += size;
}

/*
==============
ChallengeResponseHSM_default::ChallengeResponseHSM_default
==============
*/
void ChallengeResponseHSM_default::ChallengeResponseHSM_default(ChallengeResponseHSM_default *this)
{
  ChallengeResponseHSM_base::ChallengeResponseHSM_base(this);
  this->__vftable = (ChallengeResponseHSM_default_vtbl *)&ChallengeResponseHSM_default::`vftable';
  `eh vector constructor iterator'(this->m_pendingChallenges, 0x50ui64, 8ui64, (void (__fastcall *)(void *))LiveAntiCheatPendingChallenge::LiveAntiCheatPendingChallenge, (void (__fastcall *)(void *))LiveAntiCheatPendingChallenge::~LiveAntiCheatPendingChallenge);
  bdAntiCheatResponses::bdAntiCheatResponses(&this->m_sender.responses);
  this->m_sender.remoteTask.m_ptr = NULL;
}

/*
==============
ChallengeResponseHSM_default::~ChallengeResponseHSM_default
==============
*/
void ChallengeResponseHSM_default::~ChallengeResponseHSM_default(ChallengeResponseHSM_default *this)
{
  this->__vftable = (ChallengeResponseHSM_default_vtbl *)&ChallengeResponseHSM_default::`vftable';
  LiveAntiCheatSender::~LiveAntiCheatSender(&this->m_sender);
  `eh vector destructor iterator'(this->m_pendingChallenges, 0x50ui64, 8ui64, (void (__fastcall *)(void *))LiveAntiCheatPendingChallenge::~LiveAntiCheatPendingChallenge);
  ChallengeResponseHSM_base::~ChallengeResponseHSM_base(this);
}

/*
==============
ChallengeResponseHSM_default::AddNewChallenge
==============
*/
void ChallengeResponseHSM_default::AddNewChallenge(ChallengeResponseHSM_default *this, int controllerIndex, const bdAntiCheatChallenge *challenge)
{
  int v6; 
  int v7; 
  int v8; 
  AntiCheatChallengeStatus *p_status; 
  int v10; 
  AntiCheatChallengeStatus v11; 
  int v12; 
  int v13; 
  __int64 v14; 
  char *v15; 
  unsigned int v16; 
  char *fmt; 
  __int64 v18; 

  v6 = -1;
  v7 = 0;
  v8 = Sys_Milliseconds();
  if ( controllerIndex != this->m_controllerIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 929, ASSERT_TYPE_ASSERT, "(controllerIndex == m_controllerIndex)", "%s\n\tgiving a challenge to the wrong HSM.", "controllerIndex == m_controllerIndex") )
    __debugbreak();
  if ( challenge->m_parameters.m_size > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 930, ASSERT_TYPE_ASSERT, "(challenge->m_parameters.getSize() <= 1)", "%s\n\tDemonware challenge received with more than one parameter.  Only the first one is supported.", "challenge->m_parameters.getSize() <= 1") )
    __debugbreak();
  ++this->m_sender.challengesReceived;
  p_status = &this->m_pendingChallenges[0].status;
  v10 = 0;
  while ( 1 )
  {
    v11 = *p_status;
    if ( *(_QWORD *)(p_status - 15) == challenge->m_challengeID )
      break;
    if ( v11 == CHALLENGE_STATUS_INVALID )
      goto LABEL_17;
    v12 = v10;
    v13 = v8 - *((_DWORD *)p_status - 7);
    if ( v13 <= v7 )
      v12 = v6;
    ++v10;
    p_status += 20;
    v6 = v12;
    if ( v13 <= v7 )
      v13 = v7;
    v7 = v13;
    if ( v10 >= 8 )
      goto LABEL_18;
  }
  if ( v11 == CHALLENGE_STATUS_INVALID )
  {
LABEL_17:
    if ( v10 < 0 )
    {
LABEL_18:
      if ( v6 < 0 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 975, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "unable to find unused or oldest challenge index.  we can't ignore challenges so just using index 0.") )
          __debugbreak();
        v10 = 0;
      }
      else
      {
        v10 = v6;
      }
    }
    v14 = v10;
    this->m_pendingChallenges[v14].status = CHALLENGE_STATUS_NEW;
    this->m_pendingChallenges[v14].receivedTime = v8;
    this->m_pendingChallenges[v14].processingStartTime = v8 - 1;
    this->m_pendingChallenges[v14].cumulativeProcessingTime = 0;
    this->m_pendingChallenges[v14].challenge.m_functionID = challenge->m_functionID;
    this->m_pendingChallenges[v14].challenge.m_challengeID = challenge->m_challengeID;
    bdArray<bdAntiCheatChallengeParam>::operator=(&this->m_pendingChallenges[v10].challenge.m_parameters, &challenge->m_parameters);
    return;
  }
  v15 = (char *)this + 80 * v10;
  if ( *((_WORD *)v15 + 72) != challenge->m_functionID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 939, ASSERT_TYPE_ASSERT, "(m_pendingChallenges[challengeIndex].challenge.m_functionID == challenge->m_functionID)", "%s\n\tDemonWare should never issue us the same challenge ID with different parameters.", "m_pendingChallenges[challengeIndex].challenge.m_functionID == challenge->m_functionID") )
    __debugbreak();
  v16 = Sys_Milliseconds() - *((_DWORD *)v15 + 46);
  LODWORD(fmt) = Sys_Milliseconds() - *((_DWORD *)v15 + 47);
  Com_Printf(25, "old challenge info: status = %d, received = %d, processingStart = %d\n", *((unsigned int *)v15 + 53), v16, fmt);
  LODWORD(v18) = this->m_controllerIndex;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 947, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "AntiCheat:  Received a challenge for controller %d that we are already processing.\n", v18) )
    __debugbreak();
}

/*
==============
ChallengeResponseHSM_default::CheckForQueuedChallenges
==============
*/
void ChallengeResponseHSM_default::CheckForQueuedChallenges(ChallengeResponseHSM_default *this)
{
  __int64 v1; 
  AntiCheatChallengeStatus *i; 

  v1 = 0i64;
  for ( i = &this->m_pendingChallenges[0].status; *i == CHALLENGE_STATUS_INVALID; i += 20 )
  {
    if ( ++v1 >= 8 )
      return;
  }
  ChallengeResponseHSM_base::HSM_TriggerEvent(this, INVITE_GENERIC_COM_ERROR);
}

/*
==============
ChallengeResponseHSM_default::CopyCompleteChallenge
==============
*/
void ChallengeResponseHSM_default::CopyCompleteChallenge(ChallengeResponseHSM_default *this, LiveAntiCheatPendingChallenge *pendingChallenge)
{
  MemoryHashInfo **p_memoryHashInfo; 
  __int64 v5; 
  MemoryHashInfo *v6; 

  p_memoryHashInfo = &this->m_pendingChallenges[0].memoryHashInfo;
  v5 = 8i64;
  do
  {
    if ( (unsigned int)(*((_DWORD *)p_memoryHashInfo + 3) - 1) <= 1 && *(p_memoryHashInfo - 6) == (MemoryHashInfo *)pendingChallenge->challenge.m_challengeID )
    {
      v6 = *p_memoryHashInfo;
      *(p_memoryHashInfo - 3) = (MemoryHashInfo *)pendingChallenge->response;
      if ( v6 )
      {
        MemoryHashInfo::Cancel(v6);
        *p_memoryHashInfo = NULL;
      }
      *((_DWORD *)p_memoryHashInfo + 3) = 3;
      Com_Printf(25, "AntiCheat: controller %d copied response %lld\n", (unsigned int)this->m_controllerIndex, pendingChallenge->response);
      ChallengeResponseHSM_base::HSM_TriggerEvent(this, INVITE_GENERIC_ERROR_NO_MSG);
      this->m_sender.failureCount = 0;
    }
    p_memoryHashInfo += 10;
    --v5;
  }
  while ( v5 );
}

/*
==============
ChallengeResponseHSM_default::HSM_PrintDebugInfo
==============
*/
void ChallengeResponseHSM_default::HSM_PrintDebugInfo(ChallengeResponseHSM_default *this, const char *pDebugString)
{
  Com_Printf(16, ">>>> Challenge Response HSM: controller id %d : %s", (unsigned int)this->m_controllerIndex, pDebugString);
}

/*
==============
ChallengeResponseHSM_default::Init
==============
*/
void ChallengeResponseHSM_default::Init(ChallengeResponseHSM_default *this, int controllerIndex)
{
  MemoryHashInfo **p_memoryHashInfo; 
  __int64 v5; 
  bdRemoteTask *m_ptr; 
  bdRemoteTask *v7; 
  bdRemoteTask *v8; 

  ChallengeResponseHSM_base::HSM_Init(this);
  this->m_controllerIndex = controllerIndex;
  p_memoryHashInfo = &this->m_pendingChallenges[0].memoryHashInfo;
  v5 = 8i64;
  do
  {
    if ( *p_memoryHashInfo )
    {
      MemoryHashInfo::Cancel(*p_memoryHashInfo);
      *p_memoryHashInfo = NULL;
    }
    *((_DWORD *)p_memoryHashInfo + 3) = 0;
    p_memoryHashInfo += 10;
    --v5;
  }
  while ( v5 );
  bdAntiCheatResponses::clear(&this->m_sender.responses);
  m_ptr = this->m_sender.remoteTask.m_ptr;
  *(_QWORD *)&this->m_sender.challengesReceived = 0i64;
  *(_QWORD *)&this->m_sender.sendTime = 0i64;
  if ( m_ptr )
  {
    bdRemoteTask::cancelTask(m_ptr);
    v7 = this->m_sender.remoteTask.m_ptr;
    if ( v7 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 0xFFFFFFFF) == 1 )
      {
        v8 = this->m_sender.remoteTask.m_ptr;
        if ( v8 )
          ((void (__fastcall *)(bdRemoteTask *, __int64))v8->~bdReferencable)(v8, 1i64);
      }
    }
    this->m_sender.remoteTask.m_ptr = NULL;
  }
  bdAntiCheatResponses::setLogMessage(&this->m_sender.responses, NULL, 0);
  this->m_lastRunTime = Sys_Milliseconds();
}

/*
==============
ChallengeResponseHSM_default::OnEnterHandleChallenge
==============
*/
void ChallengeResponseHSM_default::OnEnterHandleChallenge(ChallengeResponseHSM_default *this)
{
  ;
}

/*
==============
ChallengeResponseHSM_default::OnEnterResponseFailure
==============
*/
void ChallengeResponseHSM_default::OnEnterResponseFailure(ChallengeResponseHSM_default *this)
{
  MemoryHashInfo **p_memoryHashInfo; 
  __int64 v3; 
  ChallengeResponseHSM_base::eHSMEvents v4; 
  const char *v5; 

  if ( ++this->m_sender.failureCount <= 3 )
  {
    v5 = "AntiCheat: Retrying...\n";
    v4 = COM_ERROR_TRIGGERED;
  }
  else
  {
    ChallengeResponseHSM_default::ResetResponses(this, 1);
    p_memoryHashInfo = &this->m_pendingChallenges[0].memoryHashInfo;
    v3 = 8i64;
    do
    {
      if ( *p_memoryHashInfo )
      {
        MemoryHashInfo::Cancel(*p_memoryHashInfo);
        *p_memoryHashInfo = NULL;
      }
      *((_DWORD *)p_memoryHashInfo + 3) = 0;
      p_memoryHashInfo += 10;
      --v3;
    }
    while ( v3 );
    v4 = INVITE_CANT_DETERMINE_CONTROLLER_PAIRING;
    v5 = "AntiCheat: Aborting.\n";
  }
  ChallengeResponseHSM_base::HSM_TriggerEvent(this, v4);
  Com_Printf(25, v5);
}

/*
==============
ChallengeResponseHSM_default::OnEnterSendResponse
==============
*/
void ChallengeResponseHSM_default::OnEnterSendResponse(ChallengeResponseHSM_default *this)
{
  int v2; 
  AntiCheatChallengeStatus *p_status; 
  unsigned int i; 
  __int64 v5; 
  int v6; 
  int v7; 
  int v8; 

  ChallengeResponseHSM_default::SetResponseDataBlob(this);
  if ( this->m_sender.remoteTask.m_ptr )
    goto LABEL_11;
  v2 = -1;
  p_status = &this->m_pendingChallenges[0].status;
  for ( i = 0; i < 8; ++i )
  {
    if ( *p_status == CHALLENGE_STATUS_COMPLETE )
    {
      v2 = i;
      goto LABEL_9;
    }
    p_status += 20;
  }
  v8 = 8;
  v7 = -1;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 779, ASSERT_TYPE_ASSERT, "(unsigned)( sendChallengeIndex ) < (unsigned)( ( sizeof( *array_counter( m_pendingChallenges ) ) + 0 ) )", "sendChallengeIndex doesn't index ARRAY_COUNT( m_pendingChallenges )\n\t%i not in [0, %i)", v7, v8) )
    __debugbreak();
LABEL_9:
  if ( v2 < 0 )
  {
LABEL_11:
    ChallengeResponseHSM_base::HSM_TriggerEvent(this, START_JOINING_USER_WITH_PLATFORM_ID);
  }
  else
  {
    v5 = v2;
    bdAntiCheatResponses::addResponse(&this->m_sender.responses, &this->m_pendingChallenges[v5].challenge, this->m_pendingChallenges[v5].response);
    v6 = Sys_Milliseconds();
    ++this->m_sender.responsesReady;
    this->m_sender.sendTime = v6;
    this->m_pendingChallenges[v5].status = CHALLENGE_STATUS_INVALID;
    ChallengeResponseHSM_base::HSM_TriggerEvent(this, INVITE_RECEIVED);
  }
}

/*
==============
ChallengeResponseHSM_default::ProcessChallenge
==============
*/
bool ChallengeResponseHSM_default::ProcessChallenge(ChallengeResponseHSM_default *this, const int controllerindex_in, LiveAntiCheatPendingChallenge *pendingChallenge)
{
  __int64 *p_response; 
  unsigned int m_functionID; 
  bdArray<bdAntiCheatChallengeParam> *p_m_parameters; 
  bool result; 
  __int64 m_size; 
  unsigned __int8 *m_data; 
  int v10; 
  unsigned __int64 v11; 
  __int64 v12; 
  __int64 CurrentValueAsInt64; 
  char dvarname_in[80]; 

  p_response = &pendingChallenge->response;
  m_functionID = pendingChallenge->challenge.m_functionID;
  p_m_parameters = &pendingChallenge->challenge.m_parameters;
  pendingChallenge->response = 0i64;
  switch ( m_functionID )
  {
    case 0xC8u:
      result = ProcessMemoryHashRequest(controllerindex_in, pendingChallenge, CT_TYPE_CRC32);
      break;
    case 0xC9u:
      result = ProcessMemoryHashRequest(controllerindex_in, pendingChallenge, CT_TYPE_MD4);
      break;
    case 0xCAu:
      result = ProcessMemoryHashRequest(controllerindex_in, pendingChallenge, CT_TYPE_SHA_TOMCRYPT);
      break;
    case 0xCBu:
      result = ProcessMemoryHashRequest(controllerindex_in, pendingChallenge, CT_TYPE_8WAY);
      break;
    case 0xCCu:
      result = ProcessMemoryHashRequest(controllerindex_in, pendingChallenge, CT_TYPE_CRC32_SPLIT);
      break;
    case 0x12Cu:
      m_size = pendingChallenge->challenge.m_parameters.m_size;
      if ( (_DWORD)m_size == 1 )
      {
        bdHandleAssert(1, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
        m_data = p_m_parameters->m_data->m_data;
        if ( m_data )
        {
          bdHandleAssert(p_m_parameters->m_size != 0, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
          v10 = p_m_parameters->m_data->m_size;
          if ( v10 > 64 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 269, ASSERT_TYPE_ASSERT, "(buffer_size <= 64)", (const char *)&queryFormat, "buffer_size <= LIVE_ANTI_CHEAT_DVAR_NAME_SIZE") )
              __debugbreak();
            v10 = 64;
          }
          v11 = v10;
          memcpy_0(dvarname_in, m_data, v10);
          if ( v11 >= 0x41 )
          {
            j___report_rangecheckfailure(v12);
            __debugbreak();
          }
          dvarname_in[v11] = 0;
          CurrentValueAsInt64 = Dvar_GetCurrentValueAsInt64(dvarname_in);
          *p_response = CurrentValueAsInt64;
          Com_Printf(25, "Challenge/Response: Responding to dvar check, \"%s\" = %llu.\n", dvarname_in, CurrentValueAsInt64);
        }
        else
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 260, ASSERT_TYPE_ASSERT, "(buffer_ptr)", (const char *)&queryFormat, "buffer_ptr") )
            __debugbreak();
          Com_PrintError(25, "Challenge/Response: AnswerDvarRequest param #1 has null buffer!\n");
        }
      }
      else
      {
        Com_PrintError(25, "Challenge/Response: AnswerDvarRequest expecting 1 param but got %d instead!!!\n", m_size);
      }
      result = 1;
      break;
    case 0x12Du:
      result = ProcessDvarFloatRequest(controllerindex_in, m_functionID, p_m_parameters, p_response);
      break;
    default:
      Com_PrintError(25, "Challenge/Response: GetChallengeResponse Function ID: %d does not exist.\n", m_functionID);
      result = 1;
      break;
  }
  return result;
}

/*
==============
ProcessDvarFloatRequest
==============
*/
char ProcessDvarFloatRequest(const int controllerindex_in, const unsigned __int16 functionid_in, const bdArray<bdAntiCheatChallengeParam> *bdchallengeparams_in, __int64 *bdchallengeresponse_in)
{
  signed __int64 v6; 
  __int64 m_size; 
  const char *v10; 
  char *v11; 
  __int64 v12; 
  char dvarName[64]; 

  v6 = (signed __int64)bdchallengeparams_in;
  m_size = bdchallengeparams_in->m_size;
  if ( (_DWORD)m_size == 1 )
  {
    bdHandleAssert(1, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
    v10 = *(const char **)(*(_QWORD *)v6 + 8i64);
    if ( v10 )
    {
      bdHandleAssert(*(_DWORD *)(v6 + 12) != 0, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
      LODWORD(v6) = *(_DWORD *)(*(_QWORD *)v6 + 16i64);
      v11 = strstr_0(v10, "~");
      if ( v11 )
      {
        v6 = v11 - v10;
        if ( (unsigned __int64)(v11 - v10 + 0x80000000i64) > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,__int64>(__int64)", "signed", (int)v6, "signed", v6) )
          __debugbreak();
      }
      memcpy_0(dvarName, v10, (int)v6);
      if ( (unsigned __int64)(int)v6 >= 0x40 )
      {
        j___report_rangecheckfailure(v12);
        JUMPOUT(0x140B72996i64);
      }
      dvarName[(int)v6] = 0;
      *(double *)&_XMM0 = Dvar_GetFloatSafe(dvarName);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, ebp
        vmulss  xmm0, xmm0, xmm1
        vcvttss2si r9, xmm0
      }
      *bdchallengeresponse_in = _R9;
      Com_Printf(25, "Challenge/Response: Responding to dvar float check, \"%s\" = %llu.\n", dvarName, _R9);
      return 1;
    }
    else
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 315, ASSERT_TYPE_ASSERT, "(buffer_ptr)", (const char *)&queryFormat, "buffer_ptr") )
        __debugbreak();
      Com_PrintError(25, "Challenge/Response: AnswerDvarFloatRequest param #1 has null buffer!\n");
      return 1;
    }
  }
  else
  {
    Com_PrintError(25, "Challenge/Response: AnswerDvarFloatRequest expecting 1 param but got %d instead!!!\n", m_size);
    return 1;
  }
}

/*
==============
ProcessMemoryHashRequest
==============
*/
bool ProcessMemoryHashRequest(const int controllerindex_in, LiveAntiCheatPendingChallenge *pendingChallenge, challengeTest_t checksumType)
{
  unsigned __int16 m_functionID; 
  __int64 m_size; 
  bool result; 
  unsigned __int8 *m_data; 
  MemoryHashInfo *memoryHashInfo; 
  Online_ErrorReporting *InstancePtr; 
  MemoryHashInfo *v11; 
  Online_ErrorReporting *v12; 
  int v13; 
  MemoryHashInfo *v14; 
  __int64 v15; 
  char *format; 
  unsigned __int64 resultptr; 
  LiveAntiCheatMemoryInfo liveanticheatmemoryinfo_in; 

  m_functionID = pendingChallenge->challenge.m_functionID;
  m_size = pendingChallenge->challenge.m_parameters.m_size;
  if ( (_DWORD)m_size != 1 )
  {
    Com_PrintError(25, "Challenge/Response: AnswerChecksumRequest expecting 1 param but got %d instead!!!\n", m_size);
    return 1;
  }
  bdHandleAssert(1, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
  m_data = pendingChallenge->challenge.m_parameters.m_data->m_data;
  if ( !m_data )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 134, ASSERT_TYPE_ASSERT, "(buffer_ptr)", (const char *)&queryFormat, "buffer_ptr") )
      __debugbreak();
    Com_PrintError(25, "Challenge/Response: AnswerChecksumRequest param #1 has null buffer!\n");
    return 1;
  }
  bdHandleAssert(pendingChallenge->challenge.m_parameters.m_size != 0, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
  memoryHashInfo = pendingChallenge->memoryHashInfo;
  if ( memoryHashInfo )
  {
    if ( MemoryHashInfo::Continue(memoryHashInfo) )
    {
      v14 = pendingChallenge->memoryHashInfo;
      resultptr = 0xFFFFFFFFFFi64;
      MemoryHashInfo::Complete(v14, &resultptr);
      v15 = resultptr;
      pendingChallenge->memoryHashInfo = NULL;
      pendingChallenge->response = v15;
      Com_Printf(25, "AntiCheat: Completed memory hash check (%u), results = %llu.\n", m_functionID, v15);
      return 1;
    }
    return 0;
  }
  if ( pendingChallenge->challenge.m_parameters.m_data->m_size != 16 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 150, ASSERT_TYPE_ASSERT, "(buffer_size == sizeof( scan_key ) + sizeof( scan_start ) + sizeof( scan_size ))", (const char *)&queryFormat, "buffer_size == sizeof( scan_key ) + sizeof( scan_start ) + sizeof( scan_size )") )
      __debugbreak();
    Com_PrintError(25, "Challenge/Response: AnswerChecksumRequest challenge param buffer size is not the correct address + memcheck size.\n");
    InstancePtr = Online_ErrorReporting::GetInstancePtr();
    Online_ErrorReporting::ReportError(InstancePtr, DODGE, NULL);
    return 1;
  }
  if ( !LiveAntiCheatMemoryInfo_Init(&liveanticheatmemoryinfo_in, m_data[7] | ((m_data[6] | ((m_data[5] | ((m_data[4] | ((m_data[3] | ((m_data[2] | ((((unsigned __int64)*m_data << 8) | m_data[1]) << 8)) << 8)) << 8)) << 8)) << 8)) << 8), m_data[11] | ((m_data[10] | ((m_data[9] | (m_data[8] << 8)) << 8)) << 8), m_data[15] | ((m_data[14] | ((m_data[13] | (m_data[12] << 8)) << 8)) << 8)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 167, ASSERT_TYPE_ASSERT, "(LiveAntiCheatMemoryInfo_Init( &liveanticheatmemoryinfo, scan_key, scan_start, scan_size ))", (const char *)&queryFormat, "LiveAntiCheatMemoryInfo_Init( &liveanticheatmemoryinfo, scan_key, scan_start, scan_size )") )
    __debugbreak();
  v11 = MemoryHashInfo::RequestHash();
  pendingChallenge->memoryHashInfo = v11;
  if ( v11 )
  {
    switch ( checksumType )
    {
      case CT_TYPE_CRC32:
        v13 = MemoryHashInfo::OpenAsCRC32(v11, liveanticheatmemoryinfo_in.scan_start, liveanticheatmemoryinfo_in.scan_size, liveanticheatmemoryinfo_in.scan_key);
        break;
      case CT_TYPE_MD4:
        v13 = MemoryHashInfo::OpenAsMD4(v11, liveanticheatmemoryinfo_in.scan_start, liveanticheatmemoryinfo_in.scan_size, liveanticheatmemoryinfo_in.scan_key);
        break;
      case CT_TYPE_SHA_TOMCRYPT:
        v13 = MemoryHashInfo::OpenAsSHATomCrypt(v11, liveanticheatmemoryinfo_in.scan_start, liveanticheatmemoryinfo_in.scan_size, liveanticheatmemoryinfo_in.scan_key);
        break;
      case CT_TYPE_8WAY:
        v13 = MemoryHashInfo::OpenAs8WayProbe(v11, liveanticheatmemoryinfo_in.scan_start, liveanticheatmemoryinfo_in.scan_size, liveanticheatmemoryinfo_in.scan_key);
        break;
      case CT_TYPE_CRC32_SPLIT:
        v13 = MemoryHashInfo::OpenAsCRC32Split(v11, liveanticheatmemoryinfo_in.scan_start, liveanticheatmemoryinfo_in.scan_size, liveanticheatmemoryinfo_in.scan_key);
        break;
      default:
        LODWORD(format) = checksumType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 200, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Challenge/Response: Unknown memory hash type %d (0x%x)!!!", format, checksumType) )
          __debugbreak();
        Com_PrintError(25, "Challenge/Response: Unknown memory hash type %d (0x%x)!!!\n", (unsigned int)checksumType, (unsigned int)checksumType);
        goto LABEL_31;
    }
    if ( !v13 )
    {
LABEL_31:
      MemoryHashInfo::Cancel(pendingChallenge->memoryHashInfo);
      result = 0;
      pendingChallenge->memoryHashInfo = NULL;
      return result;
    }
    return 0;
  }
  Com_PrintError(25, "Challenge/Response: AnswerChecksumRequest challenge could not be initiated.\n");
  v12 = Online_ErrorReporting::GetInstancePtr();
  Online_ErrorReporting::ReportError(v12, COUNT, NULL);
  return 1;
}

/*
==============
ChallengeResponseHSM_default::ResetAllChallenges
==============
*/
void ChallengeResponseHSM_default::ResetAllChallenges(ChallengeResponseHSM_default *this)
{
  MemoryHashInfo **p_memoryHashInfo; 
  __int64 v2; 

  p_memoryHashInfo = &this->m_pendingChallenges[0].memoryHashInfo;
  v2 = 8i64;
  do
  {
    if ( *p_memoryHashInfo )
    {
      MemoryHashInfo::Cancel(*p_memoryHashInfo);
      *p_memoryHashInfo = NULL;
    }
    *((_DWORD *)p_memoryHashInfo + 3) = 0;
    p_memoryHashInfo += 10;
    --v2;
  }
  while ( v2 );
}

/*
==============
ChallengeResponseHSM_default::ResetResponses
==============
*/
void ChallengeResponseHSM_default::ResetResponses(ChallengeResponseHSM_default *this, bool logUnsent)
{
  __int64 challengesReceived; 
  __int64 responsesReady; 
  const char *v5; 
  bdRemoteTask *m_ptr; 
  bdRemoteTask *v7; 
  bdRemoteTask *v8; 

  if ( logUnsent )
  {
    challengesReceived = (unsigned int)this->m_sender.challengesReceived;
    responsesReady = (unsigned int)this->m_sender.responsesReady;
    if ( (int)challengesReceived > (int)responsesReady )
    {
      v5 = j_va("ftr c%d rec%d rd%d", (unsigned int)this->m_controllerIndex, challengesReceived, responsesReady);
      dwRecordStringEventFF(v5, DW_EVENT_CHALLENGE_RESPONSE_FAILURE);
    }
  }
  bdAntiCheatResponses::clear(&this->m_sender.responses);
  m_ptr = this->m_sender.remoteTask.m_ptr;
  *(_QWORD *)&this->m_sender.challengesReceived = 0i64;
  *(_QWORD *)&this->m_sender.sendTime = 0i64;
  if ( m_ptr )
  {
    bdRemoteTask::cancelTask(m_ptr);
    v7 = this->m_sender.remoteTask.m_ptr;
    if ( v7 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 0xFFFFFFFF) == 1 )
      {
        v8 = this->m_sender.remoteTask.m_ptr;
        if ( v8 )
          ((void (__fastcall *)(bdRemoteTask *, __int64))v8->~bdReferencable)(v8, 1i64);
      }
    }
    this->m_sender.remoteTask.m_ptr = NULL;
  }
  bdAntiCheatResponses::setLogMessage(&this->m_sender.responses, NULL, 0);
}

/*
==============
ChallengeResponseHSM_default::SetResponseDataBlob
==============
*/
void ChallengeResponseHSM_default::SetResponseDataBlob(ChallengeResponseHSM_default *this)
{
  bdAntiCheatResponses *p_responses; 
  Online_PatchStreamer *Instance; 
  int ConsoleDetails; 
  int v5; 
  char v7[4]; 
  int v8; 
  unsigned __int8 consoleExternalIP[4]; 
  unsigned __int8 consoleInternalIP[4]; 
  unsigned __int16 dataptr_in[2]; 
  __int16 v12; 
  float lat; 
  float lon; 
  LiveAntiCheatQuickBuf liveanticheatquickbuf_in; 
  unsigned __int64 machineIDHigh; 
  unsigned __int64 macAddress; 
  unsigned __int64 machineIDLow; 
  char dest[8]; 
  char bufferptr_in[64]; 

  p_responses = &this->m_sender.responses;
  bdAntiCheatResponses::setLogMessage(&this->m_sender.responses, NULL, 0);
  LiveAntiCheatQuickBuf_Init(&liveanticheatquickbuf_in, bufferptr_in, 64);
  Core_strcpy(dest, 8ui64, "8.24");
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, dest, 8, 0);
  Instance = Online_PatchStreamer::GetInstance();
  dataptr_in[0] = Online_PatchStreamer::GetPatchManifestVersion(Instance, MOVEMENT);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, dataptr_in, 2, 1);
  v8 = 0;
  machineIDHigh = 0i64;
  machineIDLow = 0i64;
  *(_DWORD *)consoleInternalIP = 0;
  *(_DWORD *)consoleExternalIP = 0;
  macAddress = 0i64;
  ConsoleDetails = Live_GetConsoleDetails(1, consoleInternalIP, consoleExternalIP, &machineIDHigh, &machineIDLow, &macAddress);
  v5 = 0;
  if ( ConsoleDetails )
    v5 = *(_DWORD *)consoleExternalIP;
  v8 = v5;
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &v8, 4, 0);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &machineIDHigh, 8, 1);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &macAddress, 8, 1);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rbp+57h+lat], xmm0
    vmovss  [rbp+57h+lon], xmm0
  }
  LiveRegionInfo_GetLatLong(&lat, &lon);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &lat, 4, 1);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &lon, 4, 1);
  v12 = 0;
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &v12, 2, 1);
  v7[0] = 1;
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, v7, 1, 1);
  LiveAntiCheatQuickBuf_WriteData(&liveanticheatquickbuf_in, &machineIDLow, 8, 1);
  bdAntiCheatResponses::setLogMessage(p_responses, liveanticheatquickbuf_in.bufferptr, liveanticheatquickbuf_in.numbytestraversed);
}

/*
==============
ChallengeResponseHSM_default::StartUpdateFrame
==============
*/
void ChallengeResponseHSM_default::StartUpdateFrame(void)
{
  s_challengesProcessedThisFrame = 0;
}

/*
==============
ChallengeResponseHSM_default::Update
==============
*/
void ChallengeResponseHSM_default::Update(ChallengeResponseHSM_default *this, int dt)
{
  int v4; 

  v4 = Sys_Milliseconds();
  if ( dt < 0 )
    dt = v4 - this->m_lastRunTime;
  this->m_lastRunTime = v4;
  if ( dt > 1000 )
    dt = 1000;
  this->m_lastFrameTime = dt;
  ChallengeResponseHSM_base::HSM_Update(this, dt);
}

/*
==============
ChallengeResponseHSM_default::UpdateProcessChallenge
==============
*/
void ChallengeResponseHSM_default::UpdateProcessChallenge(ChallengeResponseHSM_default *this)
{
  int *p_cumulativeProcessingTime; 
  LiveAntiCheatPendingChallenge *m_pendingChallenges; 
  __int64 v4; 
  int v5; 
  int *p_failureCount; 
  int *v7; 
  __int64 v8; 
  MemoryHashInfo *v9; 
  int v10; 
  __int64 v11; 
  __int64 v12; 

  p_cumulativeProcessingTime = &this->m_pendingChallenges[0].cumulativeProcessingTime;
  m_pendingChallenges = this->m_pendingChallenges;
  v4 = 8i64;
  do
  {
    switch ( p_cumulativeProcessingTime[5] )
    {
      case 1:
        Com_Printf(25, "AntiCheat: New challenge ID#%llu (function ID %llu) pending.\n", *((_QWORD *)p_cumulativeProcessingTime - 5), *((unsigned __int16 *)p_cumulativeProcessingTime - 24));
        p_cumulativeProcessingTime[5] = 2;
        break;
      case 2:
        if ( !s_challengesProcessedThisFrame )
        {
          if ( *(p_cumulativeProcessingTime - 1) == *(p_cumulativeProcessingTime - 2) - 1 )
          {
            Com_Printf(25, "AntiCheat: Beginning to process challenge ID#%llu.\n", *((_QWORD *)p_cumulativeProcessingTime - 5));
            *(p_cumulativeProcessingTime - 1) = Sys_Milliseconds();
          }
          *p_cumulativeProcessingTime += this->m_lastFrameTime;
          if ( ChallengeResponseHSM_default::ProcessChallenge(this, this->m_controllerIndex, m_pendingChallenges) )
          {
            v10 = *p_cumulativeProcessingTime;
            LODWORD(v12) = Sys_Milliseconds() - *(p_cumulativeProcessingTime - 2);
            LODWORD(v11) = v10;
            Com_Printf(25, "AntiCheat: Processed challenge ID#%llu (function ID %u) with result = %llu (0x%llu) in %d msecs (%d msec since received).\n", *((_QWORD *)p_cumulativeProcessingTime - 5), *((unsigned __int16 *)p_cumulativeProcessingTime - 24), *((_QWORD *)p_cumulativeProcessingTime - 2), *((_QWORD *)p_cumulativeProcessingTime - 2), v11, v12);
            p_cumulativeProcessingTime[5] = 3;
          }
          ++s_challengesProcessedThisFrame;
        }
        break;
      case 3:
        v5 = 0;
        p_failureCount = &g_challengeResponseHSMs[0].m_sender.failureCount;
        do
        {
          if ( v5 != this->m_controllerIndex )
          {
            v7 = p_failureCount - 183;
            v8 = 8i64;
            do
            {
              if ( (unsigned int)(v7[3] - 1) <= 1 && *((_QWORD *)v7 - 6) == *((_QWORD *)p_cumulativeProcessingTime - 5) )
              {
                v9 = *(MemoryHashInfo **)v7;
                *((_QWORD *)v7 - 3) = *((_QWORD *)p_cumulativeProcessingTime - 2);
                if ( v9 )
                {
                  MemoryHashInfo::Cancel(v9);
                  *(_QWORD *)v7 = 0i64;
                }
                v7[3] = 3;
                Com_Printf(25, "AntiCheat: controller %d copied response %lld\n", (unsigned int)*(p_failureCount - 201), *((_QWORD *)p_cumulativeProcessingTime - 2));
                ChallengeResponseHSM_base::HSM_TriggerEvent((ChallengeResponseHSM_base *)(p_failureCount - 233), INVITE_GENERIC_ERROR_NO_MSG);
                *p_failureCount = 0;
              }
              v7 += 20;
              --v8;
            }
            while ( v8 );
          }
          ++v5;
          p_failureCount += 236;
        }
        while ( (__int64)p_failureCount < (__int64)&unk_149EE5F34 );
        ChallengeResponseHSM_base::HSM_TriggerEvent(this, INVITE_GENERIC_ERROR_NO_MSG);
        this->m_sender.failureCount = 0;
        break;
    }
    ++m_pendingChallenges;
    p_cumulativeProcessingTime += 20;
    --v4;
  }
  while ( v4 );
}

/*
==============
ChallengeResponseHSM_default::UpdateSendResponse
==============
*/
void ChallengeResponseHSM_default::UpdateSendResponse(ChallengeResponseHSM_default *this)
{
  int responsesReady; 
  bdReference<bdRemoteTask> *p_remoteTask; 
  bdRemoteTask *m_ptr; 
  bool v5; 
  bdTask::bdStatus v6; 
  int v7; 
  bool v8; 
  DWServicesAccess *Instance; 
  DWServicesAccess *v10; 
  DWAntiCheat *AntiCheat; 
  bdReference<bdRemoteTask> *v12; 
  bdRemoteTask *v13; 
  bdReference<bdRemoteTask> result; 

  responsesReady = this->m_sender.responsesReady;
  p_remoteTask = &this->m_sender.remoteTask;
  m_ptr = this->m_sender.remoteTask.m_ptr;
  v5 = Sys_Milliseconds() - this->m_sender.sendTime >= 0;
  if ( m_ptr )
  {
    v6 = p_remoteTask->m_ptr->getStatus(p_remoteTask->m_ptr);
    if ( v6 == BD_EMPTY )
    {
LABEL_16:
      this->m_sender.sendTime = (5000 << this->m_sender.failureCount) + Sys_Milliseconds();
      if ( p_remoteTask->m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&p_remoteTask->m_ptr->m_refCount, 0xFFFFFFFF) == 1 && p_remoteTask->m_ptr )
        ((void (__fastcall *)(bdRemoteTask *, __int64))p_remoteTask->m_ptr->~bdReferencable)(p_remoteTask->m_ptr, 1i64);
      p_remoteTask->m_ptr = NULL;
      Com_PrintWarning(25, "AntiCheat: failed %d times to send responses to challenges for controller %d.  Resetting.\n", (unsigned int)this->m_sender.failureCount, (unsigned int)this->m_controllerIndex);
      ChallengeResponseHSM_base::HSM_TriggerEvent(this, START_JOINING_USER_WITH_XUID);
      return;
    }
    if ( v6 == BD_PENDING )
      return;
    if ( v6 != BD_DONE )
    {
      if ( (unsigned int)(v6 - 3) > 2 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 886, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "unreachable code") )
          __debugbreak();
        return;
      }
      goto LABEL_16;
    }
    Com_Printf(25, "AntiCheat: Successfully sent %d response(s) to challenges for controller %d.\n", (unsigned int)this->m_sender.responsesReady, (unsigned int)this->m_controllerIndex);
    v7 = this->m_sender.responsesReady;
    v8 = this->m_sender.challengesReceived - v7 < 0;
    this->m_sender.challengesReceived -= v7;
    if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\online\\challengeresponsehsm_default.cpp", 863, ASSERT_TYPE_SANITY, "(m_sender.challengesReceived >= 0)", "%s\n\t\"We somehow sent more challenges than we received!\"", "m_sender.challengesReceived >= 0") )
      __debugbreak();
    this->m_sender.responsesReady = 0;
    if ( p_remoteTask->m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&p_remoteTask->m_ptr->m_refCount, 0xFFFFFFFF) == 1 && p_remoteTask->m_ptr )
      ((void (__fastcall *)(bdRemoteTask *, __int64))p_remoteTask->m_ptr->~bdReferencable)(p_remoteTask->m_ptr, 1i64);
    p_remoteTask->m_ptr = NULL;
    *(_QWORD *)&this->m_sender.sendTime = 0i64;
    bdAntiCheatResponses::clear(&this->m_sender.responses);
    ChallengeResponseHSM_base::HSM_TriggerEvent(this, START_JOINING_LOBBY);
  }
  else if ( responsesReady > 0 && v5 )
  {
    Instance = DWServicesAccess::GetInstance();
    if ( DWServicesAccess::isReady(Instance, this->m_controllerIndex) )
    {
      Com_Printf(25, "AntiCheat: Sending %d response(s) to challenges for controller %d.\n", (unsigned int)this->m_sender.responsesReady, (unsigned int)this->m_controllerIndex);
      v10 = DWServicesAccess::GetInstance();
      AntiCheat = DWServicesAccess::GetAntiCheat(v10, this->m_controllerIndex);
      v12 = DWAntiCheat::answerChallenges(AntiCheat, &result, &this->m_sender.responses);
      if ( v12 != p_remoteTask )
      {
        if ( p_remoteTask->m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&p_remoteTask->m_ptr->m_refCount, 0xFFFFFFFF) == 1 && p_remoteTask->m_ptr )
          ((void (__fastcall *)(bdRemoteTask *, __int64))p_remoteTask->m_ptr->~bdReferencable)(p_remoteTask->m_ptr, 1i64);
        v13 = v12->m_ptr;
        p_remoteTask->m_ptr = v12->m_ptr;
        if ( v13 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v13->m_refCount, 1u);
      }
      if ( result.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&result.m_ptr->m_refCount, 0xFFFFFFFF) == 1 && result.m_ptr )
        ((void (__fastcall *)(bdRemoteTask *, __int64))result.m_ptr->~bdReferencable)(result.m_ptr, 1i64);
    }
    else
    {
      Com_Printf(25, "AntiCheat: No anticheat service!  Unable to proceed...\n");
    }
  }
}

