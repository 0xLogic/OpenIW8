/*
==============
RBTD_RefImageOverlay
==============
*/

void __fastcall RBTD_RefImageOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_RefImageOverlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSR_DeferredTraceHQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredTraceHQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SSR_DeferredTraceHQInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
cRBT_SSR_DeferredTraceHQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredTraceHQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SSR_DeferredTraceHQ@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBT_Begin3D
==============
*/

void __fastcall RBT_Begin3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Begin3D@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
R_TG_Util_GetCenteredViewport
==============
*/

GfxViewport *__fastcall R_TG_Util_GetCenteredViewport(GfxViewport *result, R_RT_ColorHandle *dstRt, unsigned int srcWidth, unsigned int srcHeight, float resampleFactor)
{
  return ?R_TG_Util_GetCenteredViewport@@YA?AUGfxViewport@@VR_RT_ColorHandle@@IIM@Z(result, dstRt, srcWidth, srcHeight, resampleFactor);
}

/*
==============
Util_DebugUav_Blend
==============
*/

void __fastcall Util_DebugUav_Blend(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?Util_DebugUav_Blend@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_Magnifier_Part2
==============
*/

void __fastcall RBTD_Magnifier_Part2(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Magnifier_Part2@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
Util_ForceRtState
==============
*/

void __fastcall Util_ForceRtState(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?Util_ForceRtState@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_ApplyHudOutlineVrsInlineResolve
==============
*/

void __fastcall RBT_ApplyHudOutlineVrsInlineResolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_ApplyHudOutlineVrsInlineResolve@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_ApplyHudOutlineCSVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_ApplyHudOutlineCSVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  return ??$cRBT_ApplyHudOutlineCSVrsInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_Draw2D_ReceivePostFXComposite<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_ReceivePostFXComposite<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Draw2D_ReceivePostFXComposite@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RT_Draw2D_BeforePostFXSetup
==============
*/

void __fastcall RT_Draw2D_BeforePostFXSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_Draw2D_BeforePostFXSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_SSR_DeferredWaterTrace_CreateRT_HQ
==============
*/

void __fastcall RBT_SSR_DeferredWaterTrace_CreateRT_HQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredWaterTrace_CreateRT_HQ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Draw2D_LowResOverlays
==============
*/

void __fastcall RBT_Draw2D_LowResOverlays(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_LowResOverlays@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Lens_Convolution
==============
*/

void __fastcall RBT_Lens_Convolution(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Lens_Convolution@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_Draw2D_HudSetup
==============
*/

void __fastcall RT_Draw2D_HudSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_Draw2D_HudSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBTD_DrawPrimitives_Offscreen_VRS<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DrawPrimitives_Offscreen_VRS<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_DrawPrimitives_Offscreen_VRS@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SSR_DeferredTraceHQInlineResolve
==============
*/

void __fastcall RBT_SSR_DeferredTraceHQInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceHQInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawOcclusionQueries<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawOcclusionQueries<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DrawOcclusionQueries@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_SSR_DeferredWaterTrace_CreateRT_HQ<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredWaterTrace_CreateRT_HQ<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SSR_DeferredWaterTrace_CreateRT_HQ@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_WaveWaterFloatZ_CreateClear<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_WaveWaterFloatZ_CreateClear<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_WaveWaterFloatZ_CreateClear@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBTD_HDR_SpotMeterProcess
==============
*/

void __fastcall RBTD_HDR_SpotMeterProcess(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_HDR_SpotMeterProcess@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_DrawPrimitives_Offscreen<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DrawPrimitives_Offscreen<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_DrawPrimitives_Offscreen@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_Distortion<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Distortion<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Distortion@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_Draw2D_RTT
==============
*/

void __fastcall RBT_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_RTT@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Magnifier_Part1<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Magnifier_Part1<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_Magnifier_Part1@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_CreateReticleBuffer<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CreateReticleBuffer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_CreateReticleBuffer@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBTD_ReflectionProbeGenerate_CaptureScene<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_ReflectionProbeGenerate_CaptureScene<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_ReflectionProbeGenerate_CaptureScene@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cUtil_DebugUav_Blend<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_DebugUav_Blend<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cUtil_DebugUav_Blend@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBTD_DrawPrimitives_Offscreen_VRS
==============
*/

void __fastcall RBTD_DrawPrimitives_Offscreen_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawPrimitives_Offscreen_VRS@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawPrimitives_Offscreen_Common
==============
*/

void __fastcall RBTD_DrawPrimitives_Offscreen_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawPrimitives_Offscreen_Common@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawPrimitives_Offscreen
==============
*/

void __fastcall RBTD_DrawPrimitives_Offscreen(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawPrimitives_Offscreen@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_FullScreenFilter
==============
*/

void __fastcall RBT_FullScreenFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_FullScreenFilter@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawDebug3D
==============
*/

void __fastcall RBTD_DrawDebug3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawDebug3D@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceHQ
==============
*/

void __fastcall RBT_SSR_DeferredTraceHQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceHQ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Blur_Mip1_Apply
==============
*/

void __fastcall RBT_Blur_Mip1_Apply(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Blur_Mip1_Apply@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_Overlay
==============
*/

void __fastcall RBTD_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Flare_Draw_VRS
==============
*/

void __fastcall RBT_Flare_Draw_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Flare_Draw_VRS@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Lens_Convolution<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Lens_Convolution<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_Lens_Convolution@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
Util_DebugUav_Clear
==============
*/

void __fastcall Util_DebugUav_Clear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?Util_DebugUav_Clear@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DecompressOrFlushResourceSynced
==============
*/

void __fastcall RBT_DecompressOrFlushResourceSynced(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DecompressOrFlushResourceSynced@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DecompressOrFlushTexture<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DecompressOrFlushTexture<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_DecompressOrFlushTexture@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_FullScreenFilterBlend
==============
*/

void __fastcall RBT_FullScreenFilterBlend(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_FullScreenFilterBlend@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_ReflectionProbeGenerate_CaptureScene
==============
*/

void __fastcall RBTD_ReflectionProbeGenerate_CaptureScene(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_ReflectionProbeGenerate_CaptureScene@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_HudOutlineWorkgroupsArgs
==============
*/

void __fastcall RBT_HudOutlineWorkgroupsArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HudOutlineWorkgroupsArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_CreateShellshockRT<R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/

unsigned int __fastcall cRBT_CreateShellshockRT<R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const int *<args_3>)
{
  return ??$cRBT_CreateShellshockRT@UR_TG_Handle@@U1@U1@H@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11AEBH@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
cRBT_DrawSunPost<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawSunPost<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DrawSunPost@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SSR_DeferredWaterTrace_CreateRT_LQ
==============
*/

void __fastcall RBT_SSR_DeferredWaterTrace_CreateRT_LQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredWaterTrace_CreateRT_LQ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_CompositeStaticVelocity<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CompositeStaticVelocity<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_CompositeStaticVelocity@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBT_CopyDepthStencilRT
==============
*/

void __fastcall RBT_CopyDepthStencilRT(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CopyDepthStencilRT@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Lens_ScopeDistortion
==============
*/

void __fastcall RBT_Lens_ScopeDistortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Lens_ScopeDistortion@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Flare_CalculateOcclusionInlineResolve
==============
*/

void __fastcall RBT_Flare_CalculateOcclusionInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Flare_CalculateOcclusionInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_CompositeToDisplayAndApplyPostfx
==============
*/

void __fastcall RBT_CompositeToDisplayAndApplyPostfx(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CompositeToDisplayAndApplyPostfx@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceWaterCommon
==============
*/

void __fastcall RBT_SSR_DeferredTraceWaterCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceWaterCommon@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DroneCamera_ChromaSubsampling<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DroneCamera_ChromaSubsampling<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DroneCamera_ChromaSubsampling@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_DrawQuadLightmapImage<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawQuadLightmapImage<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_DrawQuadLightmapImage@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Lens_ScopeClear
==============
*/

void __fastcall RBT_Lens_ScopeClear(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Lens_ScopeClear@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_ApplyHudOutlineCSVrsInlineResolve
==============
*/

void __fastcall RBT_ApplyHudOutlineCSVrsInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_ApplyHudOutlineCSVrsInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Flare_CalculateOcclusion<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Flare_CalculateOcclusion<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_Flare_CalculateOcclusion@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_Lens_ScopeClear<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Lens_ScopeClear<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_Lens_ScopeClear@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_CopyDistortion<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CopyDistortion<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_CopyDistortion@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBTD_DrawPrimitives_Overlay<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DrawPrimitives_Overlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_DrawPrimitives_Overlay@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_CompositeStaticVelocityInlineResolve
==============
*/

void __fastcall RBT_CompositeStaticVelocityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CompositeStaticVelocityInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Draw2D_Hud
==============
*/

void __fastcall RBT_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_Hud@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_CopyDistortion
==============
*/

void __fastcall RBT_CopyDistortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CopyDistortion@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_ReflectionProbeRelighting_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_ReflectionProbeRelighting_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_ReflectionProbeRelighting_Process@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBT_DrawOcclusionQueries
==============
*/

void __fastcall RBT_DrawOcclusionQueries(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOcclusionQueries@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_Rtt_Overlay
==============
*/

void __fastcall RBTD_Rtt_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Rtt_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Draw2D_ReceivePostFXLite<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_ReceivePostFXLite<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Draw2D_ReceivePostFXLite@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_SSR_DeferredTraceLQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredTraceLQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SSR_DeferredTraceLQ@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
Util_DebugUav_ClearSetup
==============
*/

void __fastcall Util_DebugUav_ClearSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?Util_DebugUav_ClearSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_DroneCamera_ChromaSubsampling
==============
*/

void __fastcall RBT_DroneCamera_ChromaSubsampling(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DroneCamera_ChromaSubsampling@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DecompressOrFlushTexture
==============
*/

void __fastcall RBT_DecompressOrFlushTexture(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DecompressOrFlushTexture@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceLQ
==============
*/

void __fastcall RBT_SSR_DeferredTraceLQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceLQ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_DebugTextureOverlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DebugTextureOverlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBTD_DebugTextureOverlay@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
RBT_Draw2D_BeforePostFX
==============
*/

void __fastcall RBT_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_BeforePostFX@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_ApplyHudOutlineVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_ApplyHudOutlineVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_ApplyHudOutlineVrsInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_HudOutlineGenWorkgroups<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HudOutlineGenWorkgroups<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_HudOutlineGenWorkgroups@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
cRBT_Draw2D_RestoreScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_RestoreScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Draw2D_RestoreScopeReticle@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBTD_DrawDebug3D<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DrawDebug3D<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBTD_DrawDebug3D@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBTD_Magnifier_Part1
==============
*/

void __fastcall RBTD_Magnifier_Part1(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Magnifier_Part1@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawSun
==============
*/

void __fastcall RBT_DrawSun(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawSun@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Draw2D_RestoreScopeReticle
==============
*/

void __fastcall RBT_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_RestoreScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_ShowTris
==============
*/

void __fastcall RBTD_ShowTris(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_ShowTris@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Magnifier_Part2<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Magnifier_Part2<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_Magnifier_Part2@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_Draw2D_BackupScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_BackupScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Draw2D_BackupScopeReticle@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_DecompressOrFlushTextureMetadata
==============
*/

void __fastcall RBT_DecompressOrFlushTextureMetadata(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DecompressOrFlushTextureMetadata@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Copy
==============
*/

void __fastcall RBT_Copy(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Copy@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_LightSensor_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_LightSensor_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_LightSensor_Process@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBT_SSR_DeferredWaterTrace
==============
*/

void __fastcall RBT_SSR_DeferredWaterTrace(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredWaterTrace@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TG_Util_GetCenteredViewport
==============
*/

GfxViewport *__fastcall R_TG_Util_GetCenteredViewport(GfxViewport *result, R_RT_ColorHandle *dstRt, R_RT_ColorHandle *srcRt, float resampleFactor)
{
  return ?R_TG_Util_GetCenteredViewport@@YA?AUGfxViewport@@VR_RT_ColorHandle@@0M@Z(result, dstRt, srcRt, resampleFactor);
}

/*
==============
cRBT_Umbra_ResolveOcclusion<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Umbra_ResolveOcclusion<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_Umbra_ResolveOcclusion@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Draw2D_BackupScopeReticle
==============
*/

void __fastcall RBT_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_BackupScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DroneCamera_Upsampling<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DroneCamera_Upsampling<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DroneCamera_Upsampling@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_Flare_Draw<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Flare_Draw<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Flare_Draw@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_SSR_DeferredWaterTrace<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredWaterTrace<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_SSR_DeferredWaterTrace@UR_TG_Handle@@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_CompositeStaticVelocity
==============
*/

void __fastcall RBT_CompositeStaticVelocity(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CompositeStaticVelocity@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Flare_Draw
==============
*/

void __fastcall RBT_Flare_Draw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Flare_Draw@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_CompositeStaticVelocityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CompositeStaticVelocityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_CompositeStaticVelocityInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBT_DroneCamera_DownsampleBayerDebayer
==============
*/

void __fastcall RBT_DroneCamera_DownsampleBayerDebayer(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DroneCamera_DownsampleBayerDebayer@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DroneCamera_Upsampling
==============
*/

void __fastcall RBT_DroneCamera_Upsampling(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DroneCamera_Upsampling@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Draw2D_ReceivePostFXLite
==============
*/

void __fastcall RBT_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_ReceivePostFXLite@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Flare_CalculateOcclusion
==============
*/

void __fastcall RBT_Flare_CalculateOcclusion(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Flare_CalculateOcclusion@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_ApplyHudOutlineCS
==============
*/

void __fastcall RBT_ApplyHudOutlineCS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_ApplyHudOutlineCS@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DecompressOrFlushTextureMetadata<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DecompressOrFlushTextureMetadata<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_DecompressOrFlushTextureMetadata@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_HudOutlineGenWorkgroups
==============
*/

void __fastcall RBT_HudOutlineGenWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HudOutlineGenWorkgroups@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_ApplyHudOutline<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_ApplyHudOutline<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_ApplyHudOutline@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBT_Distortion
==============
*/

void __fastcall RBT_Distortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Distortion@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Flare_CalculateOcclusionInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Flare_CalculateOcclusionInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_Flare_CalculateOcclusionInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_HudOutlineWorkgroupsArgs<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HudOutlineWorkgroupsArgs<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_HudOutlineWorkgroupsArgs@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_CaptureShellshock<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CaptureShellshock<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_CaptureShellshock@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBT_WaveWaterFloatZ_CreateClear
==============
*/

void __fastcall RBT_WaveWaterFloatZ_CreateClear(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_WaveWaterFloatZ_CreateClear@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cUtil_ForceRtState<R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_ForceRtState<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cUtil_ForceRtState@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Blur_Apply_Common
==============
*/

void __fastcall RBT_Blur_Apply_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, unsigned int taskBlurMip)
{
  ?RBT_Blur_Apply_Common@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@I@Z(gfxContext, taskInfo, viewInfo, data, taskBlurMip);
}

/*
==============
RBTD_RenderValidate
==============
*/

void __fastcall RBTD_RenderValidate(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_RenderValidate@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Umbra_ResolveOcclusion
==============
*/

void __fastcall RBT_Umbra_ResolveOcclusion(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Umbra_ResolveOcclusion@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawSunPost
==============
*/

void __fastcall RBT_DrawSunPost(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawSunPost@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Lens_ForceReadBuffer
==============
*/

void __fastcall RBT_Lens_ForceReadBuffer(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Lens_ForceReadBuffer@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Lens_ForceReadBuffer<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Lens_ForceReadBuffer<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_Lens_ForceReadBuffer@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Draw2D_ReceivePostFXComposite
==============
*/

void __fastcall RBT_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Draw2D_ReceivePostFXComposite@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_LightSensor_Process
==============
*/

void __fastcall RBT_LightSensor_Process(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_LightSensor_Process@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Draw2D_Hud<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_Hud<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_Draw2D_Hud@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBT_End3D
==============
*/

void __fastcall RBT_End3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_End3D@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceCommon
==============
*/

void __fastcall RBT_SSR_DeferredTraceCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceCommon@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawPrimitives_Overlay
==============
*/

void __fastcall RBTD_DrawPrimitives_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawPrimitives_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_CaptureShellshock
==============
*/

void __fastcall RBT_CaptureShellshock(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CaptureShellshock@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_ReflectionProbeRelighting_Process
==============
*/

void __fastcall RBT_ReflectionProbeRelighting_Process(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_ReflectionProbeRelighting_Process@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Overlay<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Overlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_Overlay@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_PartialScreenFilter
==============
*/

void __fastcall RBT_PartialScreenFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_PartialScreenFilter@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBTD_HDR_ScopesProcess
==============
*/

void __fastcall RBTD_HDR_ScopesProcess(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_HDR_ScopesProcess@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Begin3D<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Begin3D<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_Begin3D@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBT_Flare_Draw_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Flare_Draw_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Flare_Draw_VRS@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_ApplyHudOutline
==============
*/

void __fastcall RBT_ApplyHudOutline(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_ApplyHudOutline@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawSun<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawSun<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DrawSun@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_Blur_Mip2_Apply
==============
*/

void __fastcall RBT_Blur_Mip2_Apply(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Blur_Mip2_Apply@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Rtt_Overlay<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Rtt_Overlay<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBTD_Rtt_Overlay@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBT_DroneCamera_DownsampleBayerDebayer<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DroneCamera_DownsampleBayerDebayer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DroneCamera_DownsampleBayerDebayer@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_SSR_DeferredWaterTrace_CreateRT_LQ<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredWaterTrace_CreateRT_LQ<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SSR_DeferredWaterTrace_CreateRT_LQ@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_ApplyHudOutlineCS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_ApplyHudOutlineCS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  return ??$cRBT_ApplyHudOutlineCS@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_CompositeToDisplayAndApplyPostfx<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_CompositeToDisplayAndApplyPostfx<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_CompositeToDisplayAndApplyPostfx@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_DrawQuadLightmapImage
==============
*/

void __fastcall RBT_DrawQuadLightmapImage(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawQuadLightmapImage@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSR_DeferredTraceLQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSR_DeferredTraceLQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SSR_DeferredTraceLQInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RBTD_DebugTextureOverlay
==============
*/

void __fastcall RBTD_DebugTextureOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DebugTextureOverlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_FullScreenFilter<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_FullScreenFilter<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_FullScreenFilter@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_Draw2D_RTT<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_RTT<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_Draw2D_RTT@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBT_Draw2D_BeforePostFX<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Draw2D_BeforePostFX<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Draw2D_BeforePostFX@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_End3D<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_End3D<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_End3D@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_SSR_DeferredTraceLQInlineResolve
==============
*/

void __fastcall RBT_SSR_DeferredTraceLQInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSR_DeferredTraceLQInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cUtil_DebugUav_Clear<R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_DebugUav_Clear<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cUtil_DebugUav_Clear@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBTD_DebugTextureOverlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DebugTextureOverlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBTD_DebugTextureOverlay.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBTD_DrawDebug3D<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DrawDebug3D<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_DrawDebug3D.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_DrawPrimitives_Offscreen<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DrawPrimitives_Offscreen<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_DrawPrimitives_Offscreen.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_DrawPrimitives_Offscreen_VRS<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DrawPrimitives_Offscreen_VRS<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_DrawPrimitives_Offscreen_VRS.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_DrawPrimitives_Overlay<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DrawPrimitives_Overlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_DrawPrimitives_Overlay.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_Magnifier_Part1<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_Magnifier_Part1<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_Magnifier_Part1.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_Magnifier_Part2<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_Magnifier_Part2<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_Magnifier_Part2.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_Overlay<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_Overlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_Overlay.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_ReflectionProbeGenerate_CaptureScene<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_ReflectionProbeGenerate_CaptureScene<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_ReflectionProbeGenerate_CaptureScene.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBTD_Rtt_Overlay<R_TG_Handle>
==============
*/
unsigned int cRBTD_Rtt_Overlay<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBTD_Rtt_Overlay.m_index, &stack);
}

/*
==============
cRBT_ApplyHudOutline<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_ApplyHudOutline<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_ApplyHudOutline.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_ApplyHudOutlineCS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_ApplyHudOutlineCS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_ApplyHudOutlineCS.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_ApplyHudOutlineCSVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_ApplyHudOutlineCSVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_ApplyHudOutlineCSVrsInlineResolve.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_ApplyHudOutlineVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_ApplyHudOutlineVrsInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_ApplyHudOutlineVrsInlineResolve.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Begin3D<R_TG_Handle>
==============
*/
unsigned int cRBT_Begin3D<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_Begin3D.m_index, &stack);
}

/*
==============
cRBT_CaptureShellshock<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CaptureShellshock<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_CaptureShellshock.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_CompositeStaticVelocity<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CompositeStaticVelocity<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_CompositeStaticVelocity.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_CompositeStaticVelocityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CompositeStaticVelocityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_CompositeStaticVelocityInlineResolve.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_CompositeToDisplayAndApplyPostfx<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CompositeToDisplayAndApplyPostfx<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_CompositeToDisplayAndApplyPostfx.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_CopyDistortion<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CopyDistortion<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_CopyDistortion.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_CreateReticleBuffer<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_CreateReticleBuffer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_CreateReticleBuffer.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_CreateShellshockRT<R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/
unsigned int cRBT_CreateShellshockRT<R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const int *<args_3>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,int>(context, g_R_TG_Def_RBT_CreateShellshockRT.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
cRBT_DecompressOrFlushTexture<R_TG_Handle>
==============
*/
unsigned int cRBT_DecompressOrFlushTexture<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_DecompressOrFlushTexture.m_index, &stack);
}

/*
==============
cRBT_DecompressOrFlushTextureMetadata<R_TG_Handle>
==============
*/
unsigned int cRBT_DecompressOrFlushTextureMetadata<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_DecompressOrFlushTextureMetadata.m_index, &stack);
}

/*
==============
cRBT_Distortion<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Distortion<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Distortion.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_BackupScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_BackupScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_BackupScopeReticle.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_BeforePostFX<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_BeforePostFX<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_BeforePostFX.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_Hud<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_Hud<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_Hud.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_RTT<R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_RTT<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_Draw2D_RTT.m_index, &stack);
}

/*
==============
cRBT_Draw2D_ReceivePostFXComposite<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_ReceivePostFXComposite<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_ReceivePostFXComposite.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_ReceivePostFXLite<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_ReceivePostFXLite<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_ReceivePostFXLite.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Draw2D_RestoreScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Draw2D_RestoreScopeReticle<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Draw2D_RestoreScopeReticle.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DrawOcclusionQueries<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawOcclusionQueries<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DrawOcclusionQueries.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DrawQuadLightmapImage<R_TG_Handle>
==============
*/
unsigned int cRBT_DrawQuadLightmapImage<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_DrawQuadLightmapImage.m_index, &stack);
}

/*
==============
cRBT_DrawSun<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawSun<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DrawSun.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DrawSunPost<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawSunPost<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DrawSunPost.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DroneCamera_ChromaSubsampling<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DroneCamera_ChromaSubsampling<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DroneCamera_ChromaSubsampling.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DroneCamera_DownsampleBayerDebayer<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DroneCamera_DownsampleBayerDebayer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DroneCamera_DownsampleBayerDebayer.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DroneCamera_Upsampling<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DroneCamera_Upsampling<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DroneCamera_Upsampling.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_End3D<R_TG_Handle>
==============
*/
unsigned int cRBT_End3D<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_End3D.m_index, &stack);
}

/*
==============
cRBT_Flare_CalculateOcclusion<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Flare_CalculateOcclusion<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_Flare_CalculateOcclusion.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_Flare_CalculateOcclusionInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Flare_CalculateOcclusionInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_Flare_CalculateOcclusionInlineResolve.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_Flare_Draw<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Flare_Draw<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Flare_Draw.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Flare_Draw_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Flare_Draw_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Flare_Draw_VRS.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_FullScreenFilter<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_FullScreenFilter<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_FullScreenFilter.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HudOutlineGenWorkgroups<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HudOutlineGenWorkgroups<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HudOutlineGenWorkgroups.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HudOutlineWorkgroupsArgs<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HudOutlineWorkgroupsArgs<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HudOutlineWorkgroupsArgs.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Lens_Convolution<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Lens_Convolution<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Lens_Convolution.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Lens_ForceReadBuffer<R_TG_Handle>
==============
*/
unsigned int cRBT_Lens_ForceReadBuffer<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_Lens_ForceReadBuffer.m_index, &stack);
}

/*
==============
cRBT_Lens_ScopeClear<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Lens_ScopeClear<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Lens_ScopeClear.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_LightSensor_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_LightSensor_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_LightSensor_Process.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_ReflectionProbeRelighting_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_ReflectionProbeRelighting_Process<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_ReflectionProbeRelighting_Process.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredTraceHQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredTraceHQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredTraceHQ.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredTraceHQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredTraceHQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredTraceHQInlineResolve.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredTraceLQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredTraceLQ<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredTraceLQ.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredTraceLQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredTraceLQInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v12; 
  unsigned int v13; 
  unsigned int v14; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredTraceLQInlineResolve.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_2>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_3>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_4>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredWaterTrace<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredWaterTrace<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredWaterTrace.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &<args_2>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_3>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredWaterTrace_CreateRT_HQ<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredWaterTrace_CreateRT_HQ<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredWaterTrace_CreateRT_HQ.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSR_DeferredWaterTrace_CreateRT_LQ<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSR_DeferredWaterTrace_CreateRT_LQ<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSR_DeferredWaterTrace_CreateRT_LQ.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Umbra_ResolveOcclusion<R_TG_Handle>
==============
*/
unsigned int cRBT_Umbra_ResolveOcclusion<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_Umbra_ResolveOcclusion.m_index, &stack);
}

/*
==============
cRBT_WaveWaterFloatZ_CreateClear<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_WaveWaterFloatZ_CreateClear<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_WaveWaterFloatZ_CreateClear.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_DebugUav_Blend<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_DebugUav_Blend<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_DebugUav_Blend.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_DebugUav_Clear<R_TG_Handle>
==============
*/
unsigned int cUtil_DebugUav_Clear<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_Util_DebugUav_Clear.m_index, &stack);
}

/*
==============
cUtil_ForceRtState<R_TG_Handle>
==============
*/
unsigned int cUtil_ForceRtState<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_Util_ForceRtState.m_index, &stack);
}

/*
==============
RBTD_DebugTextureOverlay
==============
*/
void RBTD_DebugTextureOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxImage *blackImage; 
  GfxImage *v12; 
  GfxImage *v15; 
  GfxImage *v18; 
  const R_RT_Surface *Surface; 
  GfxImage *v24; 
  GfxImage *v27; 
  GfxImage *v30; 
  GfxImage *defaultUIntImage; 
  const R_RT_Surface *v37; 
  GfxImage *v39; 
  R_RT_Handle v42; 
  GfxDebugTextureOverlayImages v43; 

  _RAX = taskInfo->attachments;
  blackImage = rgp.blackImage;
  _R14 = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.floatZ = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.floatZ = blackImage;
  }
  _RAX = taskInfo->attachments;
  v12 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.entityIDVelocity = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.entityIDVelocity = v12;
  }
  _RAX = taskInfo->attachments;
  v15 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.tangentFrame = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.tangentFrame = v15;
  }
  _RAX = taskInfo->attachments;
  v18 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.packedStencil = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.packedStencil = v18;
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    Surface = R_RT_Handle::GetSurface(&v42);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.stencilMask = (const GfxWrappedBuffer *)&Surface->1080;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.stencilMask = &gfxBuf.dummyBuffer;
  }
  _RAX = taskInfo->attachments;
  v24 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.ssao = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.ssao = v24;
  }
  _RAX = taskInfo->attachments;
  v27 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.ssr = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.ssr = v27;
  }
  _RAX = taskInfo->attachments;
  v30 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.transMask = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.transMask = v30;
  }
  _RAX = taskInfo->attachments;
  defaultUIntImage = rgp.defaultUIntImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.vrs = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.vrs = defaultUIntImage;
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+120h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v37 = R_RT_Handle::GetSurface(&v42);
    if ( (v37->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.sunvisPrepass = (const GfxWrappedBuffer *)&v37->1080;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.sunvisPrepass = &gfxBuf.dummyBuffer;
  }
  _RAX = taskInfo->attachments;
  v39 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+140h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    v43.scopeBuffer = &R_RT_Handle::GetSurface(&v42)->m_image.m_base;
  }
  else
  {
    if ( v42.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v42.m_surfaceID) )
      __debugbreak();
    v43.scopeBuffer = v39;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rbp+57h+var_A0.m_surfaceID], xmm0
  }
  R_DebugTextureOverlay((GfxCmdBufContext *)&v42, viewInfo, &v43);
}

/*
==============
RBTD_DrawDebug3D
==============
*/
void RBTD_DrawDebug3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *blackImage3D; 
  R_RT_Image *p_m_image; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v18; 
  GfxCmdBufInput *v19; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v26; 

  _RAX = taskInfo->attachments;
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    blackImage3D = &R_RT_Handle::GetSurface(&v26)->m_image;
  }
  else if ( v26.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v26.m_surfaceID) )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  p_m_image = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+20h]
    vmovd   r8d, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_ER8 )
  {
    R_RT_Handle::GetSurface(&v26);
    p_m_image = &R_RT_Handle::GetSurface(&v26)->m_image;
  }
  else if ( v26.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v26.m_surfaceID) )
  {
    __debugbreak();
  }
  R_SetPersistentTables(_RDI, _RDI->state->data, PERSISTENT_TABLE_SCENE);
  source = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1585, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[21] = &blackImage3D->m_base;
  v18 = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1585, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v19 = &v18->input;
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v19->codePersistentImages[22] = &p_m_image->m_base;
  if ( R_LGV_DrawProbes_Enabled(viewInfo) )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
    }
    R_LGV_DrawProbes((GfxCmdBufContext *)&v26, viewInfo);
  }
  if ( R_ReflectionProbe_DrawSH_Enabled(viewInfo) )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
    }
    R_ReflectionProbe_DrawSH((GfxCmdBufContext *)&v26, viewInfo);
  }
  if ( R_FL_RenderDebugProxies_Enabled(viewInfo) )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
    }
    R_FL_RenderDebugProxies((GfxCmdBufContext *)&v26, viewInfo);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_GpuLightGrid_DebugDrawVolumes((GfxCmdBufContext *)&v26, viewInfo);
  if ( R_RT_Handle::IsValid(taskInfo->attachments + 2) )
  {
    Surface = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
    }
    R_Umbra_ShowOcclusion((GfxCmdBufContext *)&v26, viewInfo, data, &Surface->m_image.m_base);
  }
}

/*
==============
RBTD_DrawPrimitives_Offscreen
==============
*/
void RBTD_DrawPrimitives_Offscreen(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RBTD_DrawPrimitives_Offscreen_Common(&v5, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawPrimitives_Offscreen_Common
==============
*/
void RBTD_DrawPrimitives_Offscreen_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *blackImage3D; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v10; 

  _RBX = gfxContext;
  if ( R_DebugPrimitivesValid() )
  {
    R_ClearScreen(_RBX->state, 0xFu, 0);
    source = _RBX->source;
    blackImage3D = rgp.blackImage3D;
    if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    p_input = &source->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm { vmovups xmm0, xmmword ptr [rbx] }
    p_input->codeImages[67] = blackImage3D;
    __asm { vmovups xmmword ptr [rsp+48h+var_18.source], xmm0 }
    R_DrawDebugPrimitives(&v10, viewInfo);
  }
}

/*
==============
RBTD_DrawPrimitives_Offscreen_VRS
==============
*/
void RBTD_DrawPrimitives_Offscreen_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RBTD_DrawPrimitives_Offscreen_Common(&v5, taskInfo, viewInfo, data);
}

/*
==============
RBTD_DrawPrimitives_Overlay
==============
*/
void RBTD_DrawPrimitives_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v13; 
  R_RT_ColorHandle v14; 
  R_RT_ColorHandle v15; 

  _RBX = taskInfo;
  _RSI = gfxContext;
  if ( R_DebugPrimitivesValid() )
  {
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rsp+98h+var_48], ymm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v13);
      if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rsp+98h+var_48] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rsp+98h+var_48], ymm0
      vmovups ymm0, ymmword ptr [rbx+38h]
      vmovups [rsp+98h+var_28], ymm0
      vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm1
    }
    R_BlitDebugOverlay((GfxCmdBufContext *)&v13, viewInfo, &v15, &v14);
  }
}

/*
==============
RBTD_HDR_ScopesProcess
==============
*/
void RBTD_HDR_ScopesProcess(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  HDRScopesStage *pTaskData; 
  R_RT_Handle v6; 

  pTaskData = (HDRScopesStage *)taskInfo->pTaskData;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+38h]
    vmovups ymmword ptr [rsp+48h+var_28.m_surfaceID], ymm0
  }
  RB_HDRScopes_ProcessStageDisplay(gfxContext, viewInfo, &v6, *pTaskData);
}

/*
==============
RBTD_HDR_SpotMeterProcess
==============
*/
void RBTD_HDR_SpotMeterProcess(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  SpotMeterId *pTaskData; 
  R_RT_Handle v12; 
  R_RT_ColorHandle v13; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v12);
    if ( (R_RT_Handle::GetSurface(&v12)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  pTaskData = (SpotMeterId *)taskInfo->pTaskData;
  __asm { vmovups [rsp+78h+var_28], ymm0 }
  R_HDRSpotMeter_ProcessStage(computeState, viewInfo, &v13, *pTaskData);
}

/*
==============
RBTD_Magnifier_Part1
==============
*/
void RBTD_Magnifier_Part1(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v11; 
  R_RT_ColorHandle v12; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v11);
    if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_Magnify_Part1((GfxCmdBufContext *)&v11, viewInfo, &v12);
}

/*
==============
RBTD_Magnifier_Part2
==============
*/
void RBTD_Magnifier_Part2(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v11; 
  R_RT_ColorHandle v12; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v11);
    if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_Magnify_Part2((GfxCmdBufContext *)&v11, viewInfo, &v12);
}

/*
==============
RBTD_Overlay
==============
*/
void RBTD_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v13; 
  R_RT_ColorHandle v14; 
  R_RT_ColorHandle v15; 

  _RAX = taskInfo->attachments;
  _RBX = taskInfo;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+98h+var_48], ymm0
    vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v13);
    if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+98h+var_48] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rsp+98h+var_48], ymm0
    vmovups ymm0, ymmword ptr [rbx+38h]
    vmovups [rsp+98h+var_28], ymm0
    vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm1
  }
  R_BlitDebugOverlay((GfxCmdBufContext *)&v13, viewInfo, &v15, &v14);
}

/*
==============
RBTD_RefImageOverlay
==============
*/
void RBTD_RefImageOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const dvar_t *v5; 
  signed int v7; 
  GfxCmdBufContext v9; 

  v5 = DVARINT_r_refImageDraw;
  _RBP = gfxContext;
  v7 = *taskInfo->pTaskData;
  if ( !DVARINT_r_refImageDraw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_refImageDraw") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.integer == v7 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+0]
      vmovups xmmword ptr [rsp+58h+var_18.source], xmm0
    }
    R_DrawRefImage(&v9, viewInfo, (RefImageDrawMode)v7);
  }
}

/*
==============
RBTD_ReflectionProbeGenerate_CaptureScene
==============
*/
void RBTD_ReflectionProbeGenerate_CaptureScene(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBTD_RenderValidate
==============
*/
void RBTD_RenderValidate(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBTD_Rtt_Overlay
==============
*/
void RBTD_Rtt_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  R_Draw2D_RTT_Overlay(&v5, viewInfo, data);
}

/*
==============
RBTD_ShowTris
==============
*/
void RBTD_ShowTris(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int taskFlags; 
  R_SHOW_TRIS ShowTris; 

  taskFlags = taskInfo->pGraphInfo->taskFlags;
  if ( (taskFlags & 2) == 0 )
  {
    RB_PreOpaque_UnmapMeshes(data);
    taskFlags = taskInfo->pGraphInfo->taskFlags;
  }
  if ( (taskFlags & 4) == 0 )
    RB_DrawEmissive_UnmapMeshes(data);
  ShowTris = R_ShowTris_GetShowTris();
  if ( ShowTris )
    R_ShowTris_Draw(viewInfo, data, &taskInfo->rtGroup, ShowTris);
}

/*
==============
RBT_ApplyHudOutline
==============
*/
void RBT_ApplyHudOutline(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v41; 
  R_RT_ColorHandle v42; 
  R_RT_ColorHandle v43; 
  R_RT_ColorHandle v44; 
  R_RT_ColorHandle v45; 
  R_RT_ColorHandle v46; 
  R_RT_ColorHandle v47; 

  _RSI = gfxContext;
  _RBX = taskInfo;
  if ( R_HudOutline_Enabled(viewInfo) )
  {
    R_SetPersistentTables(_RSI, _RSI->state->data, PERSISTENT_TABLE_SCENE);
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rsp+140h+var_D0], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rsp+140h+var_D0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rsp+140h+var_D0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rbp+40h+var_B0], ymm1
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_B0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_B0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups [rbp+40h+var_90], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_90], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_90], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rbp+40h+var_70], ymm1
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_70], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_70], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+40h+var_50], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_50], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_50], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    if ( _RBX->rtGroup.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
      __debugbreak();
    __asm
    {
      vmovups ymm0, [rsp+140h+var_D0]
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rsp+140h+var_D0], ymm0
      vmovups ymm0, [rbp+40h+var_B0]
      vmovups [rbp+40h+var_B0], ymm0
      vmovups ymm0, [rbp+40h+var_90]
      vmovups [rbp+40h+var_90], ymm0
      vmovups ymm0, [rbp+40h+var_70]
      vmovups [rbp+40h+var_70], ymm0
      vmovups ymm0, [rbp+40h+var_50]
      vmovups [rbp+40h+var_50], ymm0
      vmovups ymm0, ymmword ptr [rbx+38h]
      vmovups ymmword ptr [rbp+40h+var_30.baseclass_0.m_surfaceID], ymm0
      vmovups xmmword ptr [rsp+140h+var_F0.m_surfaceID], xmm1
    }
    R_ApplyHudOutline((GfxCmdBufContext *)&v41, viewInfo, &v47, &v46, &v45, &v44, &v43, &v42, 0);
  }
}

/*
==============
RBT_ApplyHudOutlineCS
==============
*/
void RBT_ApplyHudOutlineCS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  const GfxWrappedBuffer *v15; 
  const R_RT_Surface *v16; 
  const GfxWrappedBuffer *v18; 
  bool v41; 
  R_RT_Handle v47; 
  R_RT_ColorHandle v48; 
  R_RT_ColorHandle v49; 
  R_RT_ColorHandle v50; 
  R_RT_ColorHandle v51; 
  R_RT_ColorHandle v52; 
  R_RT_ColorHandle v53; 

  if ( R_HudOutline_Enabled(viewInfo) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0E0h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_E0], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_E0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_E0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    Surface = R_RT_Handle::GetSurface(taskInfo->attachments + 6);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v15 = (const GfxWrappedBuffer *)&Surface->1080;
    v16 = R_RT_Handle::GetSurface(taskInfo->attachments + 5);
    if ( (v16->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    _RAX = taskInfo->attachments;
    v18 = (const GfxWrappedBuffer *)&v16->1080;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_C0], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_C0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_C0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rbp+60h+var_A0], ymm1
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_A0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_A0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_80], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_80], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_80], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rbp+60h+var_60], ymm1
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_60], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_60], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_40], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+60h+var_40] }
        if ( v41 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, [rbp+60h+var_E0]
      vmovups [rbp+60h+var_40], ymm1
      vmovups ymm1, [rbp+60h+var_C0]
      vmovups [rbp+60h+var_C0], ymm1
      vmovups ymm1, [rbp+60h+var_A0]
      vmovups [rbp+60h+var_A0], ymm1
      vmovups ymm1, [rbp+60h+var_80]
      vmovups [rbp+60h+var_80], ymm1
      vmovups ymm1, [rbp+60h+var_60]
      vmovups [rbp+60h+var_60], ymm1
      vmovups [rbp+60h+var_E0], ymm0
    }
    R_ApplyHudOutlineCS(computeState, viewInfo, &v48, &v52, &v51, &v50, &v49, v18, v15, &v53, 0);
  }
}

/*
==============
RBT_ApplyHudOutlineCSVrsInlineResolve
==============
*/
void RBT_ApplyHudOutlineCSVrsInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  const GfxWrappedBuffer *v15; 
  const R_RT_Surface *v16; 
  const GfxWrappedBuffer *v18; 
  bool v41; 
  R_RT_Handle v47; 
  R_RT_ColorHandle v48; 
  R_RT_ColorHandle v49; 
  R_RT_ColorHandle v50; 
  R_RT_ColorHandle v51; 
  R_RT_ColorHandle v52; 
  R_RT_ColorHandle v53; 

  if ( R_HudOutline_Enabled(viewInfo) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0E0h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_E0], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_E0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_E0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    Surface = R_RT_Handle::GetSurface(taskInfo->attachments + 6);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v15 = (const GfxWrappedBuffer *)&Surface->1080;
    v16 = R_RT_Handle::GetSurface(taskInfo->attachments + 5);
    if ( (v16->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    _RAX = taskInfo->attachments;
    v18 = (const GfxWrappedBuffer *)&v16->1080;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_C0], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_C0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_C0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rbp+60h+var_A0], ymm1
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_A0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_A0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_80], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_80], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_80], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rbp+60h+var_60], ymm1
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_60], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID]
          vmovups [rbp+60h+var_60], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+60h+var_40], ymm0
      vmovups ymmword ptr [rsp+160h+var_100.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v47);
      if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+160h+var_100.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+60h+var_40] }
        if ( v41 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, [rbp+60h+var_E0]
      vmovups [rbp+60h+var_40], ymm1
      vmovups ymm1, [rbp+60h+var_C0]
      vmovups [rbp+60h+var_C0], ymm1
      vmovups ymm1, [rbp+60h+var_A0]
      vmovups [rbp+60h+var_A0], ymm1
      vmovups ymm1, [rbp+60h+var_80]
      vmovups [rbp+60h+var_80], ymm1
      vmovups ymm1, [rbp+60h+var_60]
      vmovups [rbp+60h+var_60], ymm1
      vmovups [rbp+60h+var_E0], ymm0
    }
    R_ApplyHudOutlineCS(computeState, viewInfo, &v48, &v52, &v51, &v50, &v49, v18, v15, &v53, 1);
  }
}

/*
==============
RBT_ApplyHudOutlineVrsInlineResolve
==============
*/
void RBT_ApplyHudOutlineVrsInlineResolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v41; 
  R_RT_ColorHandle v42; 
  R_RT_ColorHandle v43; 
  R_RT_ColorHandle v44; 
  R_RT_ColorHandle v45; 
  R_RT_ColorHandle v46; 
  R_RT_ColorHandle v47; 

  _RSI = gfxContext;
  _RBX = taskInfo;
  if ( R_HudOutline_Enabled(viewInfo) )
  {
    R_SetPersistentTables(_RSI, _RSI->state->data, PERSISTENT_TABLE_SCENE);
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rsp+140h+var_D0], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rsp+140h+var_D0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rsp+140h+var_D0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rbp+40h+var_B0], ymm1
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_B0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_B0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups [rbp+40h+var_90], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_90], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_90], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rbp+40h+var_70], ymm1
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_70], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_70], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+40h+var_50], ymm0
      vmovups ymmword ptr [rsp+140h+var_F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v41);
      if ( (R_RT_Handle::GetSurface(&v41)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_50], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+140h+var_F0.m_surfaceID]
          vmovups [rbp+40h+var_50], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    if ( _RBX->rtGroup.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
      __debugbreak();
    __asm
    {
      vmovups ymm0, [rsp+140h+var_D0]
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rsp+140h+var_D0], ymm0
      vmovups ymm0, [rbp+40h+var_B0]
      vmovups [rbp+40h+var_B0], ymm0
      vmovups ymm0, [rbp+40h+var_90]
      vmovups [rbp+40h+var_90], ymm0
      vmovups ymm0, [rbp+40h+var_70]
      vmovups [rbp+40h+var_70], ymm0
      vmovups ymm0, [rbp+40h+var_50]
      vmovups [rbp+40h+var_50], ymm0
      vmovups ymm0, ymmword ptr [rbx+38h]
      vmovups ymmword ptr [rbp+40h+var_30.baseclass_0.m_surfaceID], ymm0
      vmovups xmmword ptr [rsp+140h+var_F0.m_surfaceID], xmm1
    }
    R_ApplyHudOutline((GfxCmdBufContext *)&v41, viewInfo, &v47, &v46, &v45, &v44, &v43, &v42, 1);
  }
}

/*
==============
RBT_Begin3D
==============
*/
void RBT_Begin3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  GfxCmdBufContext v7; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  state = gfxContext->state;
  __asm { vmovups xmmword ptr [rsp+38h+var_18.source], xmm0 }
  RB_StartDraw3DScene(&v7, viewInfo, data);
  RB_AddComputeCmdsTransitions(state, data, 1);
  R_FlushResourceTransitions(state);
}

/*
==============
RBT_Blur_Apply_Common
==============
*/
void RBT_Blur_Apply_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, unsigned int taskBlurMip)
{
  const GfxTaskInfo *v10; 
  const char *v41; 
  CmdBufState *state; 
  float v52; 
  float v53; 
  R_RT_Handle v54; 
  unsigned int outBlurMip; 
  float outBlurAlpha; 
  float outBlurRadius; 
  R_RT_ColorHandle v58; 
  R_RT_ColorHandle v59; 
  R_RT_ColorHandle v60; 
  R_RT_ColorHandle v61; 
  R_RT_ColorHandle v62; 
  char v63; 
  __int16 v64; 
  int v65; 
  __int16 v67; 
  int v68; 
  __int128 v69; 
  R_RT_Group v70; 

  _RAX = taskInfo->attachments;
  __asm { vmovups ymm0, ymmword ptr [rdx+38h] }
  v10 = taskInfo;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
  }
  _RSI = gfxContext;
  __asm
  {
    vmovups [rbp+200h+var_200], ymm0
    vmovups [rbp+200h+var_220], ymm1
    vmovups ymmword ptr [rsp+300h+var_2B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v54);
    if ( (R_RT_Handle::GetSurface(&v54)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_220], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_220], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = v10->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+200h+var_240], ymm0
    vmovups ymmword ptr [rsp+300h+var_2B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v54);
    if ( (R_RT_Handle::GetSurface(&v54)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_240], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_240], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = v10->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+200h+var_260], ymm1
    vmovups ymmword ptr [rsp+300h+var_2B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v54);
    if ( (R_RT_Handle::GetSurface(&v54)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_260], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_260], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = v10->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+200h+var_280], ymm0
    vmovups ymmword ptr [rsp+300h+var_2B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v54);
    if ( (R_RT_Handle::GetSurface(&v54)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_280], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+300h+var_2B0.m_surfaceID]
        vmovups [rbp+200h+var_280], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  R_GetBlurRadiusAlphaAndMip(viewInfo, &outBlurRadius, &outBlurAlpha, &outBlurMip);
  if ( outBlurMip != taskBlurMip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h", 1715, ASSERT_TYPE_ASSERT, "(blurMip == taskBlurMip)", (const char *)&queryFormat, "blurMip == taskBlurMip") )
    __debugbreak();
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+200h+var_148], xmm0
    vmovdqu [rbp+200h+var_128], xmm0
  }
  _RCX = &v70;
  v63 = 0;
  _RAX = &v63;
  v64 = 0;
  v65 = 0;
  v67 = 0;
  v68 = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovups ymmword ptr [rcx], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rcx+40h], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rcx+60h], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups ymmword ptr [rcx+80h], ymm1
    vmovups ymm1, ymmword ptr [rax+0A0h]
  }
  v41 = (const char *)*((_QWORD *)&v69 + 1);
  __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
  v70.m_vrsRt.m_tracking.m_location = v41;
  __asm { vmovups xmmword ptr [rsp+300h+var_2B0.m_surfaceID], xmm0 }
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v54, &v70, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1718)");
  __asm { vmovups ymm0, [rbp+200h+var_200] }
  state = _RSI->state;
  __asm { vmovups ymmword ptr [rsp+300h+var_2B0.m_surfaceID], ymm0 }
  R_HW_AddResourceTransition(state, &v54, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_FlushResourceTransitions(_RSI->state);
  __asm
  {
    vmovups ymm0, [rbp+200h+var_280]
    vmovups ymm1, [rbp+200h+var_260]
    vmovups [rbp+200h+var_280], ymm0
    vmovups ymm0, [rbp+200h+var_240]
    vmovups [rbp+200h+var_240], ymm0
    vmovups ymm0, [rbp+200h+var_200]
    vmovups [rbp+200h+var_260], ymm1
    vmovups ymm1, [rbp+200h+var_220]
    vmovups [rbp+200h+var_200], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+200h+var_220], ymm1
    vmovss  xmm1, [rsp+300h+outBlurAlpha]
    vmovss  [rsp+300h+var_2C0], xmm1
    vmovups xmmword ptr [rsp+300h+var_2B0.m_surfaceID], xmm0
    vmovss  xmm0, [rsp+300h+outBlurRadius]
    vmovss  [rsp+300h+var_2C8], xmm0
  }
  R_Blur_Apply((GfxCmdBufContext *)&v54, viewInfo, &v62, &v61, &v60, &v59, &v58, v52, v53, NULL);
}

/*
==============
RBT_Blur_Mip1_Apply
==============
*/
void RBT_Blur_Mip1_Apply(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  RBT_Blur_Apply_Common(&v5, taskInfo, viewInfo, data, 1u);
}

/*
==============
RBT_Blur_Mip2_Apply
==============
*/
void RBT_Blur_Mip2_Apply(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  RBT_Blur_Apply_Common(&v5, taskInfo, viewInfo, data, 2u);
}

/*
==============
RBT_CaptureShellshock
==============
*/
void RBT_CaptureShellshock(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v16; 
  R_RT_Handle v36; 
  R_RT_ColorHandle v37; 
  R_RT_ColorHandle v38; 
  R_RT_ColorHandle v39; 
  R_RT_Handle v40; 

  _RSI = gfxContext;
  if ( viewInfo->shellShock.capture )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
      vmovups ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v36);
      if ( (R_RT_Handle::GetSurface(&v36)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_F8+8] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymmword ptr [rbp+50h+var_90.m_surfaceID], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
      vmovups ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v36);
      if ( (R_RT_Handle::GetSurface(&v36)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_F8+8] }
        if ( v16 )
          __debugbreak();
      }
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups [rbp+50h+var_70], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
      vmovups ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v36);
      if ( (R_RT_Handle::GetSurface(&v36)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rbp+50h+var_B0], ymm1
      vmovups ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v36);
      if ( (R_RT_Handle::GetSurface(&v36)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups [rbp+50h+var_B0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups [rbp+50h+var_B0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rbp+50h+var_D0], ymm0
      vmovups ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v36);
      if ( (R_RT_Handle::GetSurface(&v36)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups [rbp+50h+var_D0], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter]
          vmovups [rbp+50h+var_D0], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    R_RT_Handle::GetSurface(&v40);
    R_RT_Handle::GetSurface(&v40);
    __asm
    {
      vmovups ymm0, [rbp+50h+var_D0]
      vmovups ymm1, [rbp+50h+var_B0]
      vmovups [rbp+50h+var_D0], ymm0
      vmovups ymm0, ymmword ptr [rsp+150h+var_F8+8]
      vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups xmmword ptr [rsp+150h+var_118.m_tracking.m_allocCounter], xmm0
      vmovups [rbp+50h+var_B0], ymm1
    }
    R_CompositePostfx_CaptureShellShock((GfxCmdBufContext *)&v36, viewInfo, data, (R_RT_ColorHandle *)&v40, &v37, &v39, &v38);
  }
}

/*
==============
RBT_CompositeStaticVelocity
==============
*/
void RBT_CompositeStaticVelocity(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v15; 
  bool v19; 
  bool v23; 
  bool v27; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  R_RT_Handle v29; 
  ID3D12Resource *buffers; 
  R_RT_ColorHandle dstVelocityMBlur; 
  R_RT_ColorHandle dstVelocityAA; 
  R_RT_ColorHandle srcPackedStencil; 
  R_RT_ColorHandle srcFloatzFull; 
  R_RT_ColorHandle srcVelocity; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcVelocity.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v15 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcFloatzFull.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v19 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcPackedStencil.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v23 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+var_C8.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v27 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  __asm { vmovups ymmword ptr [rbp+70h+var_E8.baseclass_0.m_surfaceID], ymm0 }
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_CompositeStaticVelocity(computeState, viewInfo, &srcVelocity, &srcFloatzFull, &srcPackedStencil, &dstVelocityAA, &dstVelocityMBlur, 0);
}

/*
==============
RBT_CompositeStaticVelocityInlineResolve
==============
*/
void RBT_CompositeStaticVelocityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v15; 
  bool v19; 
  bool v23; 
  bool v27; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  R_RT_Handle v29; 
  ID3D12Resource *buffers; 
  R_RT_ColorHandle dstVelocityMBlur; 
  R_RT_ColorHandle dstVelocityAA; 
  R_RT_ColorHandle srcPackedStencil; 
  R_RT_ColorHandle srcFloatzFull; 
  R_RT_ColorHandle srcVelocity; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcVelocity.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v15 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcFloatzFull.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v19 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+srcPackedStencil.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v23 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+70h+var_C8.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rsp+170h+var_110], ymm0
    vmovups ymmword ptr [rsp+170h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_130.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+170h+var_110] }
      if ( v27 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  __asm { vmovups ymmword ptr [rbp+70h+var_E8.baseclass_0.m_surfaceID], ymm0 }
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_CompositeStaticVelocity(computeState, viewInfo, &srcVelocity, &srcFloatzFull, &srcPackedStencil, &dstVelocityAA, &dstVelocityMBlur, 1);
}

/*
==============
RBT_CompositeToDisplayAndApplyPostfx
==============
*/
void RBT_CompositeToDisplayAndApplyPostfx(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v23; 
  bool v27; 
  bool v28; 
  bool v32; 
  bool v37; 
  int v41; 
  bool v42; 
  R_RT_Handle v50; 
  R_RT_Handle v51; 
  R_RT_ColorHandle v53; 
  R_RT_ColorHandle v54; 
  R_RT_Handle v55; 
  GfxViewport v56; 
  R_RT_Handle v57; 
  R_RT_Handle v58; 

  _RAX = taskInfo->attachments;
  _R14 = viewInfo;
  _R15 = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+0A0h+var_E0], ymm0
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_E0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_E0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+0A0h+var_100], ymm1
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_100], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_100], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+0A0h+var_120], ymm0
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+0A0h+var_120] }
      if ( v23 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+0A0h+var_90.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+0A0h+var_120], ymm0
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+0A0h+var_120] }
      if ( v27 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rbp+0A0h+var_70.m_surfaceID], ymm0 }
  v28 = R_RT_Handle::IsValid(&v57) && R_RT_Handle::IsValid(&v58);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+0A0h+var_120], ymm0
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_120], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
        vmovups [rbp+0A0h+var_120], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+0A0h+var_120] }
      if ( v32 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+0A0h+var_C0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   edi, xmm0
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+1A0h+var_140.m_surfaceID], ymm0
  }
  if ( (_WORD)_EDI )
  {
    R_RT_Handle::GetSurface(&v51);
    if ( (R_RT_Handle::GetSurface(&v51)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_140.m_surfaceID] }
      LODWORD(_RBX) = v51.m_tracking.m_allocCounter;
      LOWORD(_EDI) = v51.m_surfaceID;
      __asm { vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0 }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_140.m_surfaceID] }
      LODWORD(_RBX) = v51.m_tracking.m_allocCounter;
      LOWORD(_EDI) = v51.m_surfaceID;
      __asm { vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0 }
    }
  }
  else
  {
    __asm { vpextrd rbx, xmm0, 2 }
    if ( (_DWORD)_RBX )
    {
      v37 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID] }
      if ( v37 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymmword ptr [rsp+1A0h+var_140.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [r14+4B0h]
    vmovups [rbp+0A0h+var_A0], xmm0
  }
  if ( (_WORD)_EDI )
  {
    R_RT_Handle::GetSurface(&v51);
  }
  else if ( (_DWORD)_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_EDI + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  __asm
  {
    vmovups ymm0, [rbp+0A0h+var_120]
    vmovd   eax, xmm0
  }
  v41 = (unsigned __int16)_EAX;
  v42 = (unsigned __int16)_EDI != 0;
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v55);
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v41 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+1A0h+var_140.m_surfaceID], xmm0
  }
  R_CompositePostfx_SetConstants((GfxCmdBufContext *)&v51, _R14, data, 1, v28, v41 != 0, v42);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+1A0h+var_160.m_surfaceID]
    vmovups ymm1, [rbp+0A0h+var_100]
    vmovups ymmword ptr [rbp+0A0h+var_C0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+0A0h+var_120]
    vmovups ymmword ptr [rsp+1A0h+var_160.m_surfaceID], ymm0
    vmovups ymm0, [rbp+0A0h+var_E0]
    vmovups [rbp+0A0h+var_E0], ymm0
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+1A0h+var_140.m_surfaceID], xmm0
    vmovups [rbp+0A0h+var_100], ymm1
  }
  R_CompositePostfx_Apply((GfxCmdBufContext *)&v51, _R14, &v56, &v54, &v53, (R_RT_ColorHandle *)&v57, (R_RT_ColorHandle *)&v50, (R_RT_ColorHandle *)&v55);
}

/*
==============
RBT_Copy
==============
*/
void RBT_Copy(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v10; 
  GfxCmdBufInput *v11; 
  GfxCmdBufContext v12; 

  _RDI = gfxContext;
  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  source = _RDI->source;
  p_m_image = &Surface->m_image;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  p_input->codeImages[4] = &p_m_image->m_base;
  __asm { vmovups [rsp+58h+var_28], xmm0 }
  RB_FullScreenFilterInternal(&v12, rgp.feedbackReplaceBackbufferMaterial, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1034)");
  v10 = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v11 = &v10->input;
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v11->codeImages[4] = NULL;
}

/*
==============
RBT_CopyDepthStencilRT
==============
*/
void RBT_CopyDepthStencilRT(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v16; 
  R_RT_Handle v18; 
  R_RT_DepthHandle v19; 
  R_RT_DepthHandle v20; 

  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rsp+98h+var_48], ymm1
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v18);
      if ( (R_RT_Handle::GetSurface(&v18)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
          vmovups [rsp+98h+var_48], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
          vmovups [rsp+98h+var_48], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+98h+var_28.baseclass_0.m_surfaceID], ymm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v18);
      if ( (R_RT_Handle::GetSurface(&v18)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_28.baseclass_0.m_surfaceID] }
        if ( v16 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, [rsp+98h+var_48]
      vmovups ymmword ptr [rsp+98h+var_28.baseclass_0.m_surfaceID], ymm1
      vmovups [rsp+98h+var_48], ymm0
    }
    R_CopyDepthStencilRT(computeState, &v19, &v20);
    R_RT_Handle::ClearAuxDirty(taskInfo->attachments);
  }
}

/*
==============
RBT_CopyDistortion
==============
*/
void RBT_CopyDistortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  bool v10; 
  GfxCmdBufSourceState *v12; 
  GfxCmdBufInput *v13; 
  GfxCmdBufContext v14[2]; 

  _RBX = gfxContext;
  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  source = _RBX->source;
  p_m_image = &Surface->m_image;
  if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[4] = &p_m_image->m_base;
  v10 = R_Distortion_Scoped(viewInfo);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rsp+58h+var_28], xmm0
  }
  if ( v10 )
    RB_ScopeSizeScreenFilter(v14, viewInfo, rgp.feedbackReplaceBackbufferMaterial, NULL);
  else
    RB_FullScreenFilterInternal(v14, rgp.feedbackReplaceBackbufferMaterial, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1073)");
  v12 = _RBX->source;
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source", *(_OWORD *)v14) )
    __debugbreak();
  v13 = &v12->input;
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v13->codeImages[4] = NULL;
}

/*
==============
RBT_DecompressOrFlushResourceSynced
==============
*/
void RBT_DecompressOrFlushResourceSynced(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_DecompressOrFlushTexture
==============
*/
void RBT_DecompressOrFlushTexture(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_DecompressOrFlushTextureMetadata
==============
*/
void RBT_DecompressOrFlushTextureMetadata(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_Distortion
==============
*/
void RBT_Distortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v17; 
  R_RT_Handle v20; 
  R_RT_ColorHandle v21; 
  R_RT_ColorHandle v22; 

  _RAX = taskInfo->attachments;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+0A8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0A8h+var_38] }
      if ( v17 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+0A8h+var_78.m_surfaceID], xmm0
    vmovups [rsp+0A8h+var_38], ymm1
  }
  R_Distortion_Apply((GfxCmdBufContext *)&v20, viewInfo, &v21, &v22);
}

/*
==============
RBT_Draw2D_BackupScopeReticle
==============
*/
void RBT_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *v6; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v16; 

  _RAX = taskInfo->attachments;
  v6 = NULL;
  _R15 = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    p_m_image = &R_RT_Handle::GetSurface(&v16)->m_image;
  }
  else
  {
    if ( v16.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v16.m_surfaceID) )
      __debugbreak();
    p_m_image = NULL;
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    v6 = &R_RT_Handle::GetSurface(&v16)->m_image;
  }
  else if ( v16.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v16.m_surfaceID) )
  {
    __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_Draw2D_BackupScopeReticle((GfxCmdBufContext *)&v16, viewInfo, data, &p_m_image->m_base, &v6->m_base);
}

/*
==============
RBT_Draw2D_BeforePostFX
==============
*/
void RBT_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *p_m_image; 
  R_RT_Handle v15; 
  R_RT_DepthHandle v16; 
  R_RT_ColorHandle v17; 

  _RBP = gfxContext;
  _RBX = taskInfo;
  if ( R_Draw2D_BeforePostFX_IsValid(viewInfo) )
  {
    _RAX = _RBX->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v15);
      p_m_image = &R_RT_Handle::GetSurface(&v15)->m_image;
    }
    else
    {
      if ( v15.m_tracking.m_allocCounter )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v15.m_surfaceID) )
          __debugbreak();
      }
      p_m_image = NULL;
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+0B8h]
      vmovups ymm1, ymmword ptr [rbx+38h]
      vmovups [rsp+98h+var_48], ymm0
      vmovups xmm0, xmmword ptr [rbp+0]
      vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm0
      vmovups [rsp+98h+var_28], ymm1
    }
    R_Draw2D_BeforePostFX((GfxCmdBufContext *)&v15, viewInfo, data, &v17, &v16, &p_m_image->m_base);
  }
}

/*
==============
RBT_Draw2D_Hud
==============
*/
void RBT_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedBuffer *v6; 
  R_RT_Image *p_m_image; 
  R_RT_Image *v16; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v25; 
  R_RT_Handle v26; 
  R_RT_ColorHandle v27; 

  _RAX = taskInfo->attachments;
  v6 = NULL;
  _RBP = taskInfo;
  _R12 = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0C8h+var_88.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v25);
    p_m_image = &R_RT_Handle::GetSurface(&v25)->m_image;
  }
  else
  {
    if ( v25.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    p_m_image = NULL;
  }
  _RCX = _RBP->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+40h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+0C8h+var_88.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v25);
    v16 = &R_RT_Handle::GetSurface(&v25)->m_image;
  }
  else
  {
    if ( v25.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    v16 = NULL;
  }
  _RCX = _RBP->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+60h]
    vmovd   r8d, xmm0
    vmovups ymmword ptr [rsp+0C8h+var_88.m_surfaceID], ymm0
  }
  if ( (_WORD)_ER8 )
  {
    R_RT_Handle::GetSurface(&v25);
    Surface = R_RT_Handle::GetSurface(&v25);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v6 = (const GfxWrappedBuffer *)&Surface->1080;
  }
  else if ( v25.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RAX = _RBP->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rbp+38h]
    vmovups ymm0, ymmword ptr [rax]
    vmovups [rsp+0C8h+var_68], ymm0
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmmword ptr [rsp+0C8h+var_88.m_surfaceID], xmm0
    vmovups [rsp+0C8h+var_48], ymm1
  }
  R_Draw2D_Hud((GfxCmdBufContext *)&v25, viewInfo, data, &v27, &v26, &p_m_image->m_base, &v16->m_base, v6);
}

/*
==============
RBT_Draw2D_LowResOverlays
==============
*/
void RBT_Draw2D_LowResOverlays(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *p_m_image; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v21; 
  GfxImage *blackImage; 
  GfxCmdBufInput *v23; 
  GfxCmdBufSourceState *v24; 
  GfxImage *v25; 
  GfxCmdBufInput *v26; 
  __int64 v29; 
  GfxImage *Image; 
  GfxCmdBufInput *v34; 
  const void *v39; 
  R_RT_Handle v44; 
  R_RT_Handle v45; 
  GfxViewport viewport; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+38h]
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  _R15 = viewInfo;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
  }
  _RSI = gfxContext;
  __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    R_RT_Handle::GetSurface(&v44);
    R_RT_Handle::GetSurface(&v44);
    p_m_image = &R_RT_Handle::GetSurface(&v44)->m_image;
  }
  else
  {
    if ( v44.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v44.m_surfaceID) )
      __debugbreak();
    p_m_image = (R_RT_Image *)rgp.blackImage;
  }
  source = _RSI->source;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
    vcvtsi2ss xmm6, xmm6, rcx
    vcvtsi2ss xmm7, xmm7, rdx
  }
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[79] = &p_m_image->m_base;
  v21 = _RSI->source;
  blackImage = rgp.blackImage;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v23 = &v21->input;
  if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v23->codeImages[6] = blackImage;
  v24 = _RSI->source;
  v25 = rgp.blackImage;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v26 = &v24->input;
  if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v26->codeImages[80] = v25;
  _RBX = _RSI->source;
  _RDI = _RSI->source;
  v29 = (__int64)&_RSI->source->input;
  if ( _RSI->source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vdivss  xmm0, xmm1, xmm6
    vdivss  xmm1, xmm1, xmm7
    vmovss  dword ptr [rdi+75Ch], xmm1
    vmovss  dword ptr [rdi+750h], xmm6
    vmovss  dword ptr [rdi+754h], xmm7
    vmovss  dword ptr [rdi+758h], xmm0
  }
  *(_QWORD *)(v29 + 7424) = &gfxBuf.dummyBuffer;
  ++_RDI->constVersions[5];
  Image = FontCache_GetImage();
  v34 = &_RDI->input;
  if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
  {
    __debugbreak();
    _RBX = _RSI->source;
  }
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  v34->codeImages[32] = Image;
  __asm { vmovups xmmword ptr [rbp+57h+var_C0.m_surfaceID], xmm0 }
  RB_SetDefaultUIState((GfxCmdBufContext *)&v44, data, NULL);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+57h+var_C0.m_surfaceID], xmm0
  }
  RB_SetUIColorimetryParams((GfxCmdBufContext *)&v44);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+57h+var_C0.m_surfaceID], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v44, _R15);
  R_BeginViewInternal(_RBX, &_R15->sceneDef, (const GfxViewParms *)_R15, &_R15->viewParmsSet.frames[1].viewParms);
  *(_QWORD *)&viewport.x = 0i64;
  viewport.width = R_RT_Handle::GetSurface(&v45)->m_image.m_base.width;
  viewport.height = R_RT_Handle::GetSurface(&v45)->m_image.m_base.height;
  R_SetViewportStruct(_RBX, &viewport);
  __asm
  {
    vmovups xmm0, xmmword ptr [r15+4B0h]
    vmovups xmmword ptr [rbx+2D14h], xmm0
  }
  v39 = _R15->displayCmds[6];
  if ( v39 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups xmmword ptr [rbp+57h+var_C0.m_surfaceID], xmm0
    }
    RB_ExecuteRenderCommandsLoop((GfxCmdBufContext *)&v44, v39, NULL);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+57h+var_C0.m_surfaceID], xmm0
  }
  RB_SetUIColorimetryParams((GfxCmdBufContext *)&v44);
  *(_QWORD *)&_RBX->viewportTransformOverride.x = 0i64;
  *(_QWORD *)&_RBX->viewportTransformOverride.width = 0i64;
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+0F0h+var_58+8]
    vmovaps xmm7, [rsp+0F0h+var_68+8]
  }
}

/*
==============
RBT_Draw2D_RTT
==============
*/
void RBT_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  R_Draw2D_RTT(&v5, viewInfo, data);
}

/*
==============
RBT_Draw2D_ReceivePostFXComposite
==============
*/
void RBT_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *v11; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v19; 
  R_RT_ColorHandle v20; 

  _R15 = gfxContext;
  _RBP = taskInfo;
  if ( R_Draw2D_ReceivePostFXComposite_IsValid(viewInfo) )
  {
    _RAX = _RBP->attachments;
    __asm { vmovups ymm0, ymmword ptr [rbp+38h] }
    v11 = NULL;
    __asm
    {
      vmovups [rsp+98h+var_48], ymm0
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v19);
      p_m_image = &R_RT_Handle::GetSurface(&v19)->m_image;
    }
    else
    {
      if ( v19.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v19.m_surfaceID) )
        __debugbreak();
      p_m_image = NULL;
    }
    _RCX = _RBP->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+20h]
      vmovd   r8d, xmm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_ER8 )
    {
      R_RT_Handle::GetSurface(&v19);
      v11 = &R_RT_Handle::GetSurface(&v19)->m_image;
    }
    else if ( v19.m_tracking.m_allocCounter )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v19.m_surfaceID) )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rsp+98h+var_48]
      vmovups [rsp+98h+var_48], ymm0
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm0
    }
    R_Draw2D_ReceivePostFXComposite((GfxCmdBufContext *)&v19, viewInfo, data, &v20, &p_m_image->m_base, &v11->m_base);
  }
}

/*
==============
RBT_Draw2D_ReceivePostFXLite
==============
*/
void RBT_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *v10; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v18; 
  R_RT_ColorHandle v19; 

  _R15 = gfxContext;
  _RSI = taskInfo;
  if ( R_Draw2D_ReceivePostFXLite_IsValid(viewInfo) )
  {
    _RAX = _RSI->attachments;
    v10 = NULL;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v18);
      p_m_image = &R_RT_Handle::GetSurface(&v18)->m_image;
    }
    else
    {
      if ( v18.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v18.m_surfaceID) )
        __debugbreak();
      p_m_image = NULL;
    }
    _RCX = _RSI->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+20h]
      vmovd   r8d, xmm0
      vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
    }
    if ( (_WORD)_ER8 )
    {
      R_RT_Handle::GetSurface(&v18);
      v10 = &R_RT_Handle::GetSurface(&v18)->m_image;
    }
    else if ( v18.m_tracking.m_allocCounter )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v18.m_surfaceID) )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+38h]
      vmovups xmm1, xmmword ptr [r15]
      vmovups [rsp+98h+var_48], ymm0
      vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm1
    }
    R_Draw2D_ReceivePostFXLite((GfxCmdBufContext *)&v18, viewInfo, data, &v19, &p_m_image->m_base, &v10->m_base);
  }
}

/*
==============
RBT_Draw2D_RestoreScopeReticle
==============
*/
void RBT_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *v6; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v16; 

  _RAX = taskInfo->attachments;
  v6 = NULL;
  _R15 = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    p_m_image = &R_RT_Handle::GetSurface(&v16)->m_image;
  }
  else
  {
    if ( v16.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v16.m_surfaceID) )
      __debugbreak();
    p_m_image = NULL;
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    v6 = &R_RT_Handle::GetSurface(&v16)->m_image;
  }
  else if ( v16.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v16.m_surfaceID) )
  {
    __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_Draw2D_RestoreScopeReticle((GfxCmdBufContext *)&v16, viewInfo, data, &p_m_image->m_base, &v6->m_base);
}

/*
==============
RBT_DrawOcclusionQueries
==============
*/
void RBT_DrawOcclusionQueries(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v7; 

  _RDI = gfxContext;
  if ( RB_HaveAnyOcclusionQueries(viewInfo->clientIndex) && (*((_DWORD *)&viewInfo->viewportFeatures + 10) & 0x10000) != 0 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
    }
    RB_DrawOcclusionQueries(&v7, viewInfo);
  }
}

/*
==============
RBT_DrawQuadLightmapImage
==============
*/
void RBT_DrawQuadLightmapImage(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxImage *LightmapAtlasTexture; 
  GfxCmdBufSourceState *source; 
  const GfxImage *v7; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v10; 
  GfxCmdBufInput *v11; 
  GfxCmdBufContext v12; 

  _RDI = gfxContext;
  LightmapAtlasTexture = R_GetLightmapAtlasTexture(data, g_worldDraw->lightmapType, 1u);
  source = _RDI->source;
  v7 = LightmapAtlasTexture;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  p_input->codeImages[4] = v7;
  v10 = _RDI->source;
  __asm { vmovups [rsp+58h+var_28], xmm0 }
  *(_QWORD *)v10->input.consts[149].v = 0i64;
  *(_QWORD *)&v10->input.consts[149].xyz.z = 0i64;
  ++v10->constVersions[149];
  RB_FullScreenFilterInternal(&v12, rgp.lightmapAtlasDebugMaterial, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1018)");
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v11 = &v10->input;
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v11->codeImages[4] = NULL;
}

/*
==============
RBT_DrawSun
==============
*/
void RBT_DrawSun(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RB_DrawSun(&v5, viewInfo);
}

/*
==============
RBT_DrawSunPost
==============
*/
void RBT_DrawSunPost(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RB_DrawSunPostEffects(&v5, viewInfo);
}

/*
==============
RBT_DroneCamera_ChromaSubsampling
==============
*/
void RBT_DroneCamera_ChromaSubsampling(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v11; 
  R_RT_Handle v13; 
  R_RT_ColorHandle v14; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  _RSI = gfxContext;
  __asm { vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0 }
  R_DroneCamera_SetConstants((GfxCmdBufContext *)&v13, viewInfo);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v13);
    if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( v11 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups [rsp+78h+var_28], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_DroneCamera_ChromaSubsampling((GfxCmdBufContext *)&v13, viewInfo, &v14);
}

/*
==============
RBT_DroneCamera_DownsampleBayerDebayer
==============
*/
void RBT_DroneCamera_DownsampleBayerDebayer(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v11; 
  R_RT_Handle v13; 
  R_RT_ColorHandle v14; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  _RSI = gfxContext;
  __asm { vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0 }
  R_DroneCamera_SetConstants((GfxCmdBufContext *)&v13, viewInfo);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v13);
    if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( v11 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups [rsp+78h+var_28], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_DroneCamera_DownsampleBayerDebayer((GfxCmdBufContext *)&v13, viewInfo, &v14);
}

/*
==============
RBT_DroneCamera_Upsampling
==============
*/
void RBT_DroneCamera_Upsampling(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v17; 
  R_RT_Handle v20; 
  R_RT_ColorHandle v21; 
  R_RT_ColorHandle v22; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  _RSI = gfxContext;
  __asm { vmovups xmmword ptr [rsp+0A8h+var_78.m_surfaceID], xmm0 }
  R_DroneCamera_SetConstants((GfxCmdBufContext *)&v20, viewInfo);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+0A8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0A8h+var_38] }
      if ( v17 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+0A8h+var_78.m_surfaceID], xmm0
    vmovups [rsp+0A8h+var_38], ymm1
  }
  R_DroneCamera_Upsampling((GfxCmdBufContext *)&v20, viewInfo, &v21, &v22);
}

/*
==============
RBT_End3D
==============
*/
void RBT_End3D(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int taskFlags; 

  taskFlags = taskInfo->pGraphInfo->taskFlags;
  if ( (taskFlags & 0xC) != 0 )
  {
    RB_DrawEmissive_MapMeshes(data);
    taskFlags = taskInfo->pGraphInfo->taskFlags;
  }
  if ( (taskFlags & 0xA) != 0 )
    RB_PreOpaque_MapMeshes(data);
  RB_AddComputeCmdsTransitions(gfxContext->state, data, 0);
  R_FlushResourceTransitions(gfxContext->state);
}

/*
==============
RBT_Flare_CalculateOcclusion
==============
*/
void RBT_Flare_CalculateOcclusion(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *blackImage3D; 
  R_RT_Image *volExtinctionImage; 
  R_RT_Image *scopeImage; 
  bool v25; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v27; 
  R_RT_Handle v28; 
  R_RT_ColorHandle sceneAlphaRT; 

  RB_Flare_UnmapGfxMeshFlare(viewInfo);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( (R_RT_Handle::GetSurface(&v27)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymmword ptr [rbp+57h+sceneAlphaRT.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v27);
    blackImage3D = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  volExtinctionImage = (R_RT_Image *)rgp.whiteImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+40h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    volExtinctionImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  scopeImage = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+80h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    scopeImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+0A0h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( (R_RT_Handle::GetSurface(&v27)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID] }
      if ( v25 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(&v28);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 589, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  if ( (Surface->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 590, ASSERT_TYPE_ASSERT, "(surface->m_rtFlags & R_RT_Flag_RWView)", (const char *)&queryFormat, "surface->m_rtFlags & R_RT_Flag_RWView") )
    __debugbreak();
  R_Flare_CalculateOcclusion(computeState, viewInfo, data, &sceneAlphaRT, &blackImage3D->m_base, &volExtinctionImage->m_base, &scopeImage->m_base, &Surface->m_buffer.m_wrappedBuffer.rwView, 0);
}

/*
==============
RBT_Flare_CalculateOcclusionInlineResolve
==============
*/
void RBT_Flare_CalculateOcclusionInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *blackImage3D; 
  R_RT_Image *volExtinctionImage; 
  R_RT_Image *scopeImage; 
  bool v25; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v27; 
  R_RT_Handle v28; 
  R_RT_ColorHandle sceneAlphaRT; 

  RB_Flare_UnmapGfxMeshFlare(viewInfo);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( (R_RT_Handle::GetSurface(&v27)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  __asm
  {
    vmovups ymmword ptr [rbp+57h+sceneAlphaRT.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v27);
    blackImage3D = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  volExtinctionImage = (R_RT_Image *)rgp.whiteImage3D;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+40h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    volExtinctionImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  scopeImage = (R_RT_Image *)rgp.whiteImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+80h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    scopeImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+0A0h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( (R_RT_Handle::GetSurface(&v27)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID] }
      if ( v25 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(&v28);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 589, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  if ( (Surface->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 590, ASSERT_TYPE_ASSERT, "(surface->m_rtFlags & R_RT_Flag_RWView)", (const char *)&queryFormat, "surface->m_rtFlags & R_RT_Flag_RWView") )
    __debugbreak();
  R_Flare_CalculateOcclusion(computeState, viewInfo, data, &sceneAlphaRT, &blackImage3D->m_base, &volExtinctionImage->m_base, &scopeImage->m_base, &Surface->m_buffer.m_wrappedBuffer.rwView, 1);
}

/*
==============
RBT_Flare_Draw
==============
*/
void RBT_Flare_Draw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *defaultWaveWaterFloatZImage; 
  GfxCmdBufInput *p_input; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v16; 
  R_RT_Handle v17; 

  _RDI = gfxContext;
  R_SetPersistentTables(gfxContext, gfxContext->state->data, PERSISTENT_TABLE_SCENE);
  source = _RDI->source;
  defaultWaveWaterFloatZImage = rgp.defaultWaveWaterFloatZImage;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1585, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[15] = defaultWaveWaterFloatZImage;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+88h+var_38.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+88h+var_58.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    if ( (R_RT_Handle::GetSurface(&v16)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_58.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_58.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_38.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+88h+var_38.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(&v17);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+88h+var_58.m_surfaceID], xmm0
  }
  R_Flare_Draw((GfxCmdBufContext *)&v16, viewInfo, (const GfxWrappedBuffer *)&Surface->1080, TECHNIQUE_EMISSIVE);
  RB_Flare_MapGfxMeshFlare(viewInfo);
}

/*
==============
RBT_Flare_Draw_VRS
==============
*/
void RBT_Flare_Draw_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *defaultWaveWaterFloatZImage; 
  GfxCmdBufInput *p_input; 
  BOOL enabled; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v17; 
  R_RT_Handle v18; 

  _RSI = gfxContext;
  R_SetPersistentTables(gfxContext, gfxContext->state->data, PERSISTENT_TABLE_SCENE);
  source = _RSI->source;
  defaultWaveWaterFloatZImage = rgp.defaultWaveWaterFloatZImage;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1585, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[15] = defaultWaveWaterFloatZImage;
  _RAX = taskInfo->attachments;
  enabled = r_flareHalfres->current.enabled;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+88h+var_38.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+88h+var_58.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v17);
    if ( (R_RT_Handle::GetSurface(&v17)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_58.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_58.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+88h+var_38.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+88h+var_38.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(&v18);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+88h+var_58.m_surfaceID], xmm0
  }
  R_Flare_Draw((GfxCmdBufContext *)&v17, viewInfo, (const GfxWrappedBuffer *)&Surface->1080, (MaterialTechniqueType)(enabled + 31));
  RB_Flare_MapGfxMeshFlare(viewInfo);
}

/*
==============
RBT_FullScreenFilter
==============
*/
void RBT_FullScreenFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  bool v15; 
  GfxCmdBufSourceState *v22; 
  GfxCmdBufInput *v23; 
  float fmt; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  GfxCmdBufContext v32; 

  _RBX = gfxContext;
  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  source = _RBX->source;
  p_m_image = &Surface->m_image;
  if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  p_input->codeImages[4] = &p_m_image->m_base;
  v15 = (taskInfo->flags & 2) == 0;
  __asm { vmovups [rsp+0A8h+var_38], xmm0 }
  if ( v15 )
  {
    RB_FullScreenFilterInternal(&v32, rgp.feedbackReplaceBackbufferMaterial, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1093)");
  }
  else
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm3, xmm3, xmm3
      vcvtsi2ss xmm3, xmm3, rax
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, rax
      vmovss  [rsp+0A8h+var_50], xmm0
      vmovss  [rsp+0A8h+var_58], xmm0
      vmovss  [rsp+0A8h+var_60], xmm1
      vmovss  [rsp+0A8h+var_68], xmm1
      vmovss  [rsp+0A8h+var_70], xmm3
      vmovss  [rsp+0A8h+var_78], xmm2
      vmovss  dword ptr [rsp+0A8h+var_80], xmm1
      vmovss  dword ptr [rsp+0A8h+fmt], xmm1
    }
    RB_ViewportFilterDirectInternal(&v32, rgp.feedbackReplaceBackbufferMaterial, 0xFFFFFFFF, &viewInfo->displayViewport, fmt, v25, v26, v27, v28, v29, v30, v31, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1091)");
  }
  v22 = _RBX->source;
  if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v23 = &v22->input;
  if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v23->codeImages[4] = NULL;
}

/*
==============
RBT_FullScreenFilterBlend
==============
*/
void RBT_FullScreenFilterBlend(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  bool v17; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *v25; 
  float fmt; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  GfxCmdBufContext v34; 

  _RBX = gfxContext->source;
  _RDI = gfxContext;
  _RBX->input.consts[59].v[0] = 1.0;
  _RBX->input.consts[59].v[1] = 1.0;
  _RBX->input.consts[59].v[2] = 1.0;
  _RBX->input.consts[59].v[3] = 1.0;
  ++_RBX->constVersions[59];
  __asm
  {
    vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC0h], xmm0
    vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+4; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC4h], xmm1
    vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+8; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC8h], xmm0
    vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+0Ch; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0ACCh], xmm1
  }
  ++_RBX->constVersions[60];
  _RBX->input.consts[61].v[0] = 0.0;
  *(_QWORD *)&_RBX->input.consts[61].xyz.y = 2139095039i64;
  _RBX->input.consts[61].v[3] = 0.0;
  ++_RBX->constVersions[61];
  p_m_image = &R_RT_Handle::GetSurface(taskInfo->attachments)->m_image;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &_RBX->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  p_input->codeImages[4] = &p_m_image->m_base;
  v17 = (taskInfo->flags & 2) == 0;
  __asm { vmovups [rsp+0A8h+var_38], xmm0 }
  if ( v17 )
  {
    RB_FullScreenFilterInternal(&v34, rgp.feedbackBlendScenebufferMaterial, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1114)");
  }
  else
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm3, xmm3, xmm3
      vcvtsi2ss xmm3, xmm3, rax
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, rax
      vmovss  [rsp+0A8h+var_50], xmm0
      vmovss  [rsp+0A8h+var_58], xmm0
      vmovss  [rsp+0A8h+var_60], xmm1
      vmovss  [rsp+0A8h+var_68], xmm1
      vmovss  [rsp+0A8h+var_70], xmm3
      vmovss  [rsp+0A8h+var_78], xmm2
      vmovss  dword ptr [rsp+0A8h+var_80], xmm1
      vmovss  dword ptr [rsp+0A8h+fmt], xmm1
    }
    RB_ViewportFilterDirectInternal(&v34, rgp.feedbackBlendBackbufferMaterial, 0xFFFFFFFF, &viewInfo->displayViewport, fmt, v27, v28, v29, v30, v31, v32, v33, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1112)");
  }
  source = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v25 = &source->input;
  if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v25->codeImages[4] = NULL;
}

/*
==============
RBT_HudOutlineGenWorkgroups
==============
*/
void RBT_HudOutlineGenWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v8; 
  const R_RT_Surface *Surface; 
  const GfxTexture *floatZFull; 
  const R_RT_Surface *v11; 
  const GfxTexture *floatZEighthMipMin; 

  if ( R_HudOutline_Enabled(viewInfo) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v8 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
    Surface = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
    floatZFull = R_Texture_GetResident(Surface->m_image.m_base.textureId);
    v11 = R_RT_Handle::GetSurface(taskInfo->attachments + 3);
    floatZEighthMipMin = R_Texture_GetResident(v11->m_image.m_base.textureId);
    R_HudOutlineGenWorkgroups(computeState, viewInfo, WrappedBuffer, v8, floatZFull, floatZEighthMipMin);
  }
}

/*
==============
RBT_HudOutlineWorkgroupsArgs
==============
*/
void RBT_HudOutlineWorkgroupsArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v8; 

  if ( R_HudOutline_Enabled(viewInfo) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v8 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
    R_HudOutlineWorkgroupArgs(computeState, viewInfo, WrappedBuffer, v8);
  }
}

/*
==============
RBT_Lens_Convolution
==============
*/
void RBT_Lens_Convolution(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v18; 
  R_RT_ColorHandle v19; 
  R_RT_ColorHandle v20; 

  _RAX = taskInfo->attachments;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+98h+var_48], ymm0
    vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v18);
    if ( (R_RT_Handle::GetSurface(&v18)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
        vmovups [rsp+98h+var_48], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
        vmovups [rsp+98h+var_48], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm0
  }
  R_Lens_SetConstants((GfxCmdBufContext *)&v18, viewInfo, data);
  v18.m_surfaceID = 0;
  v18.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+98h+var_68.m_tracking.m_name], xmm0
    vmovups ymm0, [rsp+98h+var_48]
    vmovups ymm1, ymmword ptr [rsp+98h+var_68.m_surfaceID]
    vmovups [rsp+98h+var_48], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm0
    vmovups [rsp+98h+var_28], ymm1
  }
  R_Lens_Apply((GfxCmdBufContext *)&v18, viewInfo, data, GFX_LENS_PROFILE_CONVOLUTION, &v19, &v20);
}

/*
==============
RBT_Lens_ForceReadBuffer
==============
*/
void RBT_Lens_ForceReadBuffer(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_Lens_ScopeClear
==============
*/
void RBT_Lens_ScopeClear(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  GfxCmdBufContext v22; 

  if ( data->scope.scopeUseDualFov )
  {
    __asm { vxorps  xmm3, xmm3, xmm3 }
    if ( !data->scope.adsSmoothFade )
      goto LABEL_4;
    __asm { vucomiss xmm3, dword ptr [r9+75A870h] }
    if ( data->scope.adsSmoothFade )
    {
LABEL_4:
      __asm
      {
        vmovups xmm0, xmmword ptr [rcx]
        vxorps  xmm2, xmm2, xmm2
        vcvtsi2ss xmm2, xmm2, rax
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, rax
        vmovups xmmword ptr [rsp+88h+var_18.source], xmm0
        vmovss  xmm0, cs:__real@3f800000
        vmovss  [rsp+88h+var_30], xmm0
        vmovss  [rsp+88h+var_38], xmm0
        vmovss  [rsp+88h+var_40], xmm3
        vmovss  [rsp+88h+var_48], xmm3
        vmovss  [rsp+88h+var_50], xmm2
        vmovss  [rsp+88h+var_58], xmm1
        vmovss  [rsp+88h+var_60], xmm3
        vmovss  [rsp+88h+var_68], xmm3
      }
      RB_ViewportFilterDirectInternal(&v22, rgp.scopeUIDepthClear, 0xFFFFFFFF, &viewInfo->sceneGeoViewport, v14, v15, v16, v17, v18, v19, v20, v21, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(465)");
    }
  }
}

/*
==============
RBT_Lens_ScopeDistortion
==============
*/
void RBT_Lens_ScopeDistortion(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  R_Lens_ScopeDistortion(&v5, viewInfo, data);
}

/*
==============
RBT_LightSensor_Process
==============
*/
void RBT_LightSensor_Process(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *blackShadowImage; 
  bool v9; 
  R_RT_Image *zeroImage; 
  bool v15; 
  bool v17; 
  R_RT_Image *translucentSunShadowMaskImage; 
  bool v21; 
  bool v23; 
  R_RT_Image *spotshadowsArrayImage; 
  bool v29; 
  R_RT_Handle v30; 

  blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
  v9 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
  _RAX = taskInfo->attachments + 1;
  if ( data->sunShadow.opaqueCascadeCount <= 1u )
    _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+88h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v30);
    if ( v9 )
      blackShadowImage = &R_RT_Handle::GetSurface(&v30)->m_image;
  }
  else if ( v30.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  zeroImage = (R_RT_Image *)rgp.zeroImage;
  v15 = R_SunShadow_TranslucentEnabled(viewInfo);
  _RCX = taskInfo->attachments;
  v17 = v15;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+40h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+88h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v30);
    if ( v17 )
      zeroImage = &R_RT_Handle::GetSurface(&v30)->m_image;
  }
  else if ( v30.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  translucentSunShadowMaskImage = (R_RT_Image *)rgp.blackImage;
  v21 = R_SunShadow_TranslucentEnabled(viewInfo);
  _RCX = taskInfo->attachments;
  v23 = v21;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+60h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+88h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v30);
    if ( v23 )
      translucentSunShadowMaskImage = &R_RT_Handle::GetSurface(&v30)->m_image;
  }
  else if ( v30.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RAX = taskInfo->attachments;
  spotshadowsArrayImage = (R_RT_Image *)rgp.blackShadowImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
  }
  v29 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
  __asm { vmovups ymmword ptr [rsp+88h+var_48.m_surfaceID], ymm0 }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v30);
    if ( v29 )
      spotshadowsArrayImage = &R_RT_Handle::GetSurface(&v30)->m_image;
  }
  else if ( v30.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  R_LightSensor_Process(computeState, viewInfo, data, &blackShadowImage->m_base, &zeroImage->m_base, &translucentSunShadowMaskImage->m_base, &spotshadowsArrayImage->m_base);
}

/*
==============
RBT_PartialScreenFilter
==============
*/
void RBT_PartialScreenFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v26; 
  GfxCmdBufInput *v27; 
  float fmt; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  GfxCmdBufContext v34; 

  _R14 = gfxContext;
  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  source = _R14->source;
  p_m_image = &Surface->m_image;
  if ( !_R14->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[4] = &p_m_image->m_base;
  if ( taskInfo->taskDataCount != 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h", 1128, ASSERT_TYPE_ASSERT, "(taskInfo->taskDataCount == 4)", (const char *)&queryFormat, "taskInfo->taskDataCount == 4") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm5, xmm5, xmm5
    vcvtsi2ss xmm5, xmm5, rax
    vxorps  xmm4, xmm4, xmm4
    vcvtsi2ss xmm4, xmm4, rax
    vxorps  xmm3, xmm3, xmm3
    vcvtsi2ss xmm3, xmm3, rax
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rax
    vmovups [rsp+88h+var_28], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+88h+var_40], xmm0
    vmovss  [rsp+88h+var_48], xmm0
    vmovss  [rsp+88h+var_50], xmm1
    vmovss  [rsp+88h+var_58], xmm1
    vmovss  dword ptr [rsp+88h+var_60], xmm5
    vmovss  dword ptr [rsp+88h+fmt], xmm4
  }
  RB_PartialScreenFilterInternal(&v34, rgp.feedbackReplaceBackbufferMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmt, v29, v30, v31, v32, v33, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h(1129)");
  v26 = _R14->source;
  if ( !_R14->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v27 = &v26->input;
  if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v27->codeImages[4] = NULL;
}

/*
==============
RBT_ReflectionProbeRelighting_Process
==============
*/
void RBT_ReflectionProbeRelighting_Process(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *blackShadowImage; 
  bool v12; 
  int v14; 
  R_RT_Image *p_m_image; 
  bool v17; 
  int v19; 
  R_RT_Image *v20; 
  bool v22; 
  R_RT_Image *zeroImage; 
  bool v24; 
  bool v26; 
  R_RT_Image *translucentSunShadowMaskImage; 
  bool v30; 
  bool v32; 
  R_RT_Image *spotshadowArrayImage; 
  bool v38; 
  R_RT_Handle v39; 
  GfxImage *sunShadowImages[3]; 

  if ( R_ReflectionProbeRelighting_ShouldUpdate(&viewInfo->viewportFeatures) )
  {
    _RAX = taskInfo->attachments;
    blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
    }
    v12 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
    __asm { vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v12 )
        blackShadowImage = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    _RAX = taskInfo->attachments;
    v14 = *((_DWORD *)&viewInfo->viewportFeatures + 11);
    sunShadowImages[0] = &blackShadowImage->m_base;
    p_m_image = (R_RT_Image *)rgp.blackShadowImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovd   eax, xmm0
    }
    v17 = (v14 & 4) != 0;
    __asm { vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v17 )
        p_m_image = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    _RAX = taskInfo->attachments;
    v19 = *((_DWORD *)&viewInfo->viewportFeatures + 11);
    sunShadowImages[1] = &p_m_image->m_base;
    v20 = (R_RT_Image *)rgp.blackShadowImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
    }
    v22 = (v19 & 4) != 0;
    __asm { vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v22 )
        v20 = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    zeroImage = (R_RT_Image *)rgp.zeroImage;
    sunShadowImages[2] = &v20->m_base;
    v24 = R_SunShadow_TranslucentEnabled(viewInfo);
    _RCX = taskInfo->attachments;
    v26 = v24;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+20h]
      vmovd   ecx, xmm0
      vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0
    }
    if ( (_WORD)_ECX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v26 )
        zeroImage = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    translucentSunShadowMaskImage = (R_RT_Image *)rgp.blackImage;
    v30 = R_SunShadow_TranslucentEnabled(viewInfo);
    _RCX = taskInfo->attachments;
    v32 = v30;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+40h]
      vmovd   ecx, xmm0
      vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0
    }
    if ( (_WORD)_ECX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v32 )
        translucentSunShadowMaskImage = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    _RAX = taskInfo->attachments;
    spotshadowArrayImage = (R_RT_Image *)rgp.blackShadowImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovd   eax, xmm0
    }
    v38 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
    __asm { vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( v38 )
        spotshadowArrayImage = &R_RT_Handle::GetSurface(&v39)->m_image;
    }
    else if ( v39.m_tracking.m_allocCounter )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    R_ReflectionProbeRelighting_Update(computeState, viewInfo, data, (const GfxImage **)sunShadowImages, &zeroImage->m_base, &translucentSunShadowMaskImage->m_base, &spotshadowArrayImage->m_base);
  }
}

/*
==============
RBT_SSR_DeferredTraceCommon
==============
*/
void RBT_SSR_DeferredTraceCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v42; 
  R_RT_ColorHandle v43; 
  R_RT_ColorHandle v44; 
  R_RT_ColorHandle v45; 
  R_RT_ColorHandle v46; 
  R_RT_ColorHandle v47; 
  ID3D12Resource *buffers; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+130h+var_C0], ymm0
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rsp+130h+var_C0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rsp+130h+var_C0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+30h+var_40], ymm1
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_40], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_40], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+30h+var_60], ymm0
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_60], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_60], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+30h+var_80], ymm1
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_80], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_80], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+30h+var_A0], ymm0
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_A0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
        vmovups [rbp+30h+var_A0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  __asm { vmovups ymm1, [rsp+130h+var_C0] }
  v42.m_surfaceID = 0;
  v42.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+130h+var_E0.m_tracking.m_name], xmm0
    vmovups ymm0, [rbp+30h+var_A0]
    vmovups [rsp+130h+var_C0], ymm1
    vmovups ymm1, [rbp+30h+var_80]
    vmovups [rbp+30h+var_A0], ymm0
    vmovups ymm0, [rbp+30h+var_60]
    vmovups [rbp+30h+var_80], ymm1
    vmovups ymm1, [rbp+30h+var_40]
    vmovups [rbp+30h+var_60], ymm0
    vmovups ymm0, ymmword ptr [rsp+130h+var_E0.m_surfaceID]
    vmovups ymmword ptr [rsp+130h+var_E0.m_surfaceID], ymm0
    vmovups [rbp+30h+var_40], ymm1
  }
  R_SSR_DeferredTrace(computeState, viewInfo, data, 0, &v47, (R_RT_ColorHandle *)&v42, &v46, &v45, &v44, &v43);
}

/*
==============
RBT_SSR_DeferredTraceHQ
==============
*/

void __fastcall RBT_SSR_DeferredTraceHQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SSR_DeferredTraceCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceHQInlineResolve
==============
*/

void __fastcall RBT_SSR_DeferredTraceHQInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SSR_DeferredTraceCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceLQ
==============
*/

void __fastcall RBT_SSR_DeferredTraceLQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SSR_DeferredTraceCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceLQInlineResolve
==============
*/

void __fastcall RBT_SSR_DeferredTraceLQInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SSR_DeferredTraceCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredTraceWaterCommon
==============
*/
void RBT_SSR_DeferredTraceWaterCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int64 v39; 
  R_RT_ColorHandle v40; 
  R_RT_Handle v41; 
  R_RT_Handle v42; 
  R_RT_Handle v43; 
  R_RT_Handle v44; 
  R_RT_Handle v45; 
  __m256i v46; 
  __m256i v47; 
  R_RT_ColorHandle v48; 
  R_RT_ColorHandle v49; 
  R_RT_ColorHandle v50; 
  R_RT_ColorHandle v51; 
  R_RT_ColorHandle v52; 
  ID3D12Resource *buffers; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   edi, xmm0
    vmovups [rsp+210h+var_1C0], ymm0
    vmovups ymmword ptr [rbp+110h+var_180.m_surfaceID], ymm0
  }
  if ( (_WORD)_EDI )
  {
    R_RT_Handle::GetSurface(&v42);
    if ( (R_RT_Handle::GetSurface(&v42)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+110h+var_180.m_surfaceID] }
      LODWORD(_RBX) = v42.m_tracking.m_allocCounter;
      LOWORD(_EDI) = v42.m_surfaceID;
      __asm { vmovups [rsp+210h+var_1C0], ymm0 }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+110h+var_180.m_surfaceID] }
      LODWORD(_RBX) = v42.m_tracking.m_allocCounter;
      LOWORD(_EDI) = v42.m_surfaceID;
      __asm { vmovups [rsp+210h+var_1C0], ymm0 }
    }
  }
  else
  {
    __asm { vpextrd rbx, xmm0, 2 }
    if ( (_DWORD)_RBX )
    {
      __asm { vmovups ymm0, [rsp+210h+var_1C0] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0 }
  if ( (_WORD)_EDI )
  {
    R_RT_Handle::GetSurface(&v41);
  }
  else if ( (_DWORD)_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_EDI + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  if ( ((unsigned __int16)_EDI != 0) == R_WaveWaterFloatZ_Active(viewInfo) )
  {
    __asm { vmovups ymm0, [rsp+210h+var_1C0] }
  }
  else
  {
    LODWORD(v39) = viewInfo->matRenderFeatures;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_misc.h", 315, ASSERT_TYPE_ASSERT, "( ( waterFloatZFullRt.IsValid() == R_WaveWaterFloatZ_Active( viewInfo ) ) )", "( viewInfo->matRenderFeatures ) = %i", v39) )
      __debugbreak();
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
      vmovups [rsp+210h+var_1C0], ymm0
    }
  }
  __asm { vmovd   eax, xmm0 }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v41);
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+110h+var_160.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v43);
      if ( (R_RT_Handle::GetSurface(&v43)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_160.m_surfaceID]
          vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_160.m_surfaceID]
          vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups ymmword ptr [rbp+110h+var_160.m_surfaceID], ymm1
      vmovups ymmword ptr [rbp+110h+var_140.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v44);
      if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_140.m_surfaceID]
          vmovups ymmword ptr [rbp+110h+var_160.m_surfaceID], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_140.m_surfaceID]
          vmovups ymmword ptr [rbp+110h+var_160.m_surfaceID], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+110h+var_140.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+110h+var_120.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v45);
      if ( (R_RT_Handle::GetSurface(&v45)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_120.m_surfaceID]
          vmovups ymmword ptr [rbp+110h+var_140.m_surfaceID], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+110h+var_120.m_surfaceID]
          vmovups ymmword ptr [rbp+110h+var_140.m_surfaceID], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    buffers = data->globalSceneConstantBuffer->buffer;
    R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
    __asm { vmovups ymm1, ymmword ptr [rsp+210h+var_1A0.m_surfaceID] }
    v46.m256i_i16[0] = 0;
    v46.m256i_i32[2] = 0;
    v47.m256i_i16[0] = 0;
    v47.m256i_i32[2] = 0;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rbp+110h+var_E0+10h], xmm0
      vmovdqu xmmword ptr [rbp+110h+var_100+10h], xmm0
      vmovups ymm0, ymmword ptr [rbp+110h+var_140.m_surfaceID]
      vmovups [rbp+110h+var_C0], ymm1
      vmovups ymm1, [rbp+110h+var_E0]
      vmovups [rbp+110h+var_A0], ymm0
      vmovups ymm0, [rbp+110h+var_100]
      vmovups [rbp+110h+var_80], ymm0
      vmovups ymm0, [rsp+210h+var_1C0]
      vmovups [rbp+110h+var_60], ymm1
      vmovups ymm1, ymmword ptr [rbp+110h+var_160.m_surfaceID]
      vmovups [rsp+210h+var_1C0], ymm0
      vmovups [rbp+110h+var_40], ymm1
    }
    R_SSR_DeferredTrace(computeState, viewInfo, data, 1, &v52, &v40, &v51, &v50, &v49, &v48);
  }
  else if ( v41.m_tracking.m_allocCounter )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
}

/*
==============
RBT_SSR_DeferredWaterTrace
==============
*/

void __fastcall RBT_SSR_DeferredWaterTrace(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SSR_DeferredTraceWaterCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSR_DeferredWaterTrace_CreateRT_HQ
==============
*/
void RBT_SSR_DeferredWaterTrace_CreateRT_HQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SSR_DeferredWaterTrace_CreateRT_LQ
==============
*/
void RBT_SSR_DeferredWaterTrace_CreateRT_LQ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_Umbra_ResolveOcclusion
==============
*/
void RBT_Umbra_ResolveOcclusion(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v11; 
  R_RT_ColorHandle v12; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v11);
    if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups [rsp+78h+var_28], ymm0 }
  R_Umbra_ResolveOcclusion(computeState, viewInfo, data, &v12);
}

/*
==============
RBT_WaveWaterFloatZ_CreateClear
==============
*/
void RBT_WaveWaterFloatZ_CreateClear(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RT_Draw2D_BeforePostFXSetup
==============
*/
void RT_Draw2D_BeforePostFXSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle v9; 
  GfxAsync2DRenderResources resources; 

  _RDI = taskInfo;
  if ( R_Draw2D_BeforePostFX_IsValid(viewInfo) )
  {
    memset_0(&resources, 0, 0x80ui64);
    _RAX = _RDI->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+38h]
      vmovups ymm1, ymmword ptr [rdi+0B8h]
    }
    resources.resolvedScene = NULL;
    resources.exposureBuffer = NULL;
    __asm
    {
      vmovups ymmword ptr [rsp+108h+resources.sceneColor.baseclass_0.m_surfaceID], ymm0
      vmovups ymmword ptr [rsp+108h+resources.sceneDepth.baseclass_0.m_surfaceID], ymm1
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+108h+var_D8.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v9);
      resources.universalClut = &R_RT_Handle::GetSurface(&v9)->m_image.m_base;
    }
    else
    {
      if ( v9.m_tracking.m_allocCounter )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v9.m_surfaceID) )
          __debugbreak();
      }
      resources.universalClut = NULL;
    }
    LUI_Workers_AddRenderWorker(viewInfo, &resources, 1);
  }
}

/*
==============
RT_Draw2D_HudSetup
==============
*/
void RT_Draw2D_HudSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  const R_RT_Surface *Surface; 
  R_RT_Handle v15; 
  GfxAsync2DRenderResources resources; 

  _RBX = taskInfo;
  memset_0(&resources.sceneColor, 0, 0x60ui64);
  _RAX = _RBX->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+38h]
    vmovups ymmword ptr [rsp+118h+resources.displayColor.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+118h+resources.packedStencil.m_surfaceID], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups ymmword ptr [rsp+118h+var_E8.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v15);
    resources.universalClut = &R_RT_Handle::GetSurface(&v15)->m_image.m_base;
  }
  else
  {
    if ( v15.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v15.m_surfaceID) )
      __debugbreak();
    resources.universalClut = NULL;
  }
  _RAX = _RBX->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+118h+var_E8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v15);
    resources.resolvedScene = &R_RT_Handle::GetSurface(&v15)->m_image.m_base;
  }
  else
  {
    if ( v15.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v15.m_surfaceID) )
      __debugbreak();
    resources.resolvedScene = NULL;
  }
  _RAX = _RBX->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+118h+var_E8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v15);
    Surface = R_RT_Handle::GetSurface(&v15);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v15.m_surfaceID) )
      __debugbreak();
    resources.exposureBuffer = (const GfxWrappedBuffer *)&Surface->1080;
  }
  else
  {
    if ( v15.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v15.m_surfaceID) )
      __debugbreak();
    resources.exposureBuffer = NULL;
  }
  LUI_Workers_AddRenderWorker(viewInfo, &resources, 0);
}

/*
==============
R_TG_Util_GetCenteredViewport
==============
*/

GfxViewport *__fastcall R_TG_Util_GetCenteredViewport(GfxViewport *result, R_RT_ColorHandle *dstRt, R_RT_ColorHandle *srcRt, double resampleFactor)
{
  const R_RT_Surface *Surface; 
  int v23; 
  int height; 
  int v25; 
  GfxViewport *v26; 
  R_RT_Handle v28; 

  _R14 = result;
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  _RBX = dstRt;
  R_RT_Handle::GetSurface(srcRt);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx]
    vmovss  xmm1, cs:__real@3f800000
    vmovups ymmword ptr [rsp+58h+var_38.m_surfaceID], ymm0
    vdivss  xmm6, xmm1, xmm6
  }
  R_RT_Handle::GetSurface(srcRt);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, edx
    vmulss  xmm1, xmm0, xmm6
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rsi
    vcvttss2si rbp, xmm1
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rdi, xmm1
  }
  LODWORD(_RBX) = R_RT_Handle::GetSurface(&v28)->m_image.m_base.width;
  Surface = R_RT_Handle::GetSurface(&v28);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  v23 = (_DWORD)_RBX - _RBP;
  v28.m_tracking.m_allocCounter = _RBP;
  height = Surface->m_image.m_base.height;
  if ( v23 < 0 )
    v23 = 0;
  *(&v28.m_tracking.m_allocCounter + 1) = _RDI;
  *(_DWORD *)&v28.m_surfaceID = v23 / 2;
  v25 = height - _RDI;
  if ( v25 < 0 )
    v25 = 0;
  *((_DWORD *)&v28.m_surfaceID + 1) = v25 / 2;
  v26 = _R14;
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+58h+var_38.m_surfaceID]
    vmovups xmmword ptr [r14], xmm0
  }
  return v26;
}

/*
==============
R_TG_Util_GetCenteredViewport
==============
*/
GfxViewport *R_TG_Util_GetCenteredViewport(GfxViewport *result, R_RT_ColorHandle *dstRt, unsigned int srcWidth, unsigned int srcHeight)
{
  int width; 
  const R_RT_Surface *Surface; 
  int v19; 
  int height; 
  int v21; 

  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vdivss  xmm2, xmm0, [rsp+28h+arg_20]
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, rax
    vmulss  xmm0, xmm1, xmm2
    vcvttss2si rbp, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rax
    vmulss  xmm1, xmm0, xmm2
    vcvttss2si rsi, xmm1
  }
  width = R_RT_Handle::GetSurface(dstRt)->m_image.m_base.width;
  Surface = R_RT_Handle::GetSurface(dstRt);
  v19 = width - _RBP;
  result->width = _RBP;
  height = Surface->m_image.m_base.height;
  if ( v19 < 0 )
    v19 = 0;
  result->height = _RSI;
  result->x = v19 / 2;
  v21 = height - _RSI;
  if ( v21 < 0 )
    v21 = 0;
  result->y = v21 / 2;
  return result;
}

/*
==============
Util_DebugUav_Blend
==============
*/
void Util_DebugUav_Blend(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v14; 
  bool v18; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v21; 
  const R_RT_Surface *v22; 
  int height; 
  const R_RT_Surface *v24; 
  int width; 
  R_RT_Handle v26; 
  R_RT_Handle v27; 
  R_RT_Handle v28; 
  R_RT_Handle v29; 
  ID3D12Resource *buffers; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_80.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+57h+var_80.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_60.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_60.m_surfaceID] }
      if ( v14 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+57h+var_40.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_60.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_60.m_surfaceID] }
      if ( v18 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  __asm { vmovups ymmword ptr [rbp+57h+var_60.m_surfaceID], ymm0 }
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  Surface = R_RT_Handle::GetSurface(&v27);
  buffers = (ID3D12Resource *)R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&buffers);
  v21 = R_RT_Handle::GetSurface(&v29);
  buffers = (ID3D12Resource *)R_Texture_GetResident(v21->m_image.m_base.textureId);
  R_SetComputeTextures(computeState, 0, 1, (const GfxTexture *const *)&buffers);
  v22 = R_RT_Handle::GetSurface(&v28);
  buffers = (ID3D12Resource *)R_Texture_GetResident(v22->m_image.m_base.textureId);
  R_SetComputeTextures(computeState, 1, 1, (const GfxTexture *const *)&buffers);
  R_SetComputeShader(computeState, rgp.csDebugUavBlend);
  height = R_RT_Handle::GetSurface(&v27)->m_image.m_base.height;
  v24 = R_RT_Handle::GetSurface(&v27);
  width = v24->m_image.m_base.width;
  if ( (!v24->m_image.m_base.width || !height) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_compute.h", 558, ASSERT_TYPE_ASSERT, "(xThreads > 0 && yThreads > 0 && zThreads > 0 && xGroupSize > 0 && yGroupSize > 0 && zGroupSize > 0)", "%s\n\tCompute thread count or group size is 0.", "xThreads > 0 && yThreads > 0 && zThreads > 0 && xGroupSize > 0 && yGroupSize > 0 && zGroupSize > 0") )
    __debugbreak();
  R_Dispatch(computeState, (unsigned int)(width + 15) >> 4, (unsigned int)(height + 15) >> 4, 1u);
}

/*
==============
Util_DebugUav_Clear
==============
*/
void Util_DebugUav_Clear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_ColorHandle *p_debugUav; 
  const R_RT_Surface *Surface; 
  int height; 
  const R_RT_Surface *v8; 
  int width; 
  GfxTexture *textures; 

  p_debugUav = &viewInfo->debugUav;
  Surface = R_RT_Handle::GetSurface(&viewInfo->debugUav);
  textures = (GfxTexture *)R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 4, 1, (const GfxTexture *const *)&textures);
  R_SetComputeShader(computeState, rgp.csDebugUavClear);
  height = R_RT_Handle::GetSurface(p_debugUav)->m_image.m_base.height;
  v8 = R_RT_Handle::GetSurface(p_debugUav);
  width = v8->m_image.m_base.width;
  if ( (!v8->m_image.m_base.width || !height) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_compute.h", 558, ASSERT_TYPE_ASSERT, "(xThreads > 0 && yThreads > 0 && zThreads > 0 && xGroupSize > 0 && yGroupSize > 0 && zGroupSize > 0)", "%s\n\tCompute thread count or group size is 0.", "xThreads > 0 && yThreads > 0 && zThreads > 0 && xGroupSize > 0 && yGroupSize > 0 && zGroupSize > 0") )
    __debugbreak();
  R_Dispatch(computeState, (unsigned int)(width + 15) >> 4, (unsigned int)(height + 15) >> 4, 1u);
}

/*
==============
Util_DebugUav_ClearSetup
==============
*/
void Util_DebugUav_ClearSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  R_RT_Handle v10; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v10);
    if ( (R_RT_Handle::GetSurface(&v10)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RCX = &viewInfo->debugUav;
  __asm { vmovups ymmword ptr [rcx], ymm0 }
  p_m_image = &R_RT_Handle::GetSurface(&viewInfo->debugUav)->m_image;
  p_input = &viewInfo->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[78] = &p_m_image->m_base;
}

/*
==============
Util_ForceRtState
==============
*/
void Util_ForceRtState(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

