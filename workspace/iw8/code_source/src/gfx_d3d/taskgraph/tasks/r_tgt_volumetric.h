/*
==============
RBT_VOL_ScatteringSetup
==============
*/

void __fastcall RBT_VOL_ScatteringSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RBT_VOL_ScatteringSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_VOL_ClearIndirectScattering
==============
*/

void __fastcall RBT_VOL_ClearIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_ClearIndirectScattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_WriteClusterBuffer
==============
*/

void __fastcall RBT_VOL_WriteClusterBuffer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_WriteClusterBuffer@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_CombineAmbientMultiLightGrid
==============
*/

void __fastcall RBT_VOL_CombineAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_CombineAmbientMultiLightGrid@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_VOL_ShowVolumetricDebug@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_VOL_ClearIndirectScattering<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_VOL_ClearIndirectScattering<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_VOL_ClearIndirectScattering@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_VOL_MaxFloatZ
==============
*/

void __fastcall RBT_VOL_MaxFloatZ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_MaxFloatZ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_FillIndirectScattering
==============
*/

void __fastcall RBT_VOL_FillIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_FillIndirectScattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_Scattering
==============
*/

void __fastcall RBT_VOL_Scattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_Scattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_Accumulate
==============
*/

void __fastcall RBT_VOL_Accumulate(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_Accumulate@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/

unsigned int __fastcall cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const int *<args_17>)
{
  return ??$cRBT_VOL_Scattering@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@H@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111111111AEBH@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>);
}

/*
==============
RBT_VOL_SampleAmbient
==============
*/

void __fastcall RBT_VOL_SampleAmbient(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_SampleAmbient@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_SampleAmbientMultiLightGrid
==============
*/

void __fastcall RBT_VOL_SampleAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_SampleAmbientMultiLightGrid@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_VOL_ShowVolumetricDebug
==============
*/

void __fastcall RBTD_VOL_ShowVolumetricDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_VOL_ShowVolumetricDebug@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_VOL_ShowVolumetricDebug.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_VOL_ClearIndirectScattering<R_TG_Handle>
==============
*/
unsigned int cRBT_VOL_ClearIndirectScattering<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_VOL_ClearIndirectScattering.m_index, &stack);
}

/*
==============
cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/
unsigned int cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const int *<args_17>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  m_index = g_R_TG_Def_RBT_VOL_Scattering.m_index;
  handleArgCount = arguments.handleArgCount + 1;
  arguments.handleArgs[0] = &<args_0>->index;
  arguments.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = arguments.handleArgCount;
  }
  arguments.handleArgs[handleArgCount] = &<args_1>->index;
  ++arguments.handleArgCount;
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(context, m_index, &arguments, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>);
}

/*
==============
RBTD_VOL_ShowVolumetricDebug
==============
*/
void RBTD_VOL_ShowVolumetricDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufContext v8; 

  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  v8 = *gfxContext;
  RB_ShowVolumetricDebug(&v8, viewInfo, data, &Surface->m_image.m_base);
}

/*
==============
RBT_VOL_Accumulate
==============
*/
void RBT_VOL_Accumulate(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int16 v4; 
  bool v9; 
  R_RT_Handle *attachments; 
  unsigned int v11; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage3D; 
  const R_RT_Surface *v14; 
  R_RT_Handle *v15; 
  const R_RT_Surface *v16; 
  GfxImage *blackImage; 
  const R_RT_Surface *v18; 
  R_RT_Handle *v19; 
  const R_RT_Surface *v20; 
  R_RT_Handle *v21; 
  const R_RT_Surface *v22; 
  R_RT_Handle *v23; 
  R_RT_Handle v24; 
  VolumetricDrawStream drawStream; 
  VolumetricAccumulateResources resources; 
  ID3D12Resource *buffers; 

  drawStream.state = computeState;
  drawStream.data = data;
  v9 = R_VOL_UseLocalMedia(data, viewInfo);
  attachments = taskInfo->attachments;
  drawStream.useLocalMedia = v9;
  drawStream.useLocalMediaPrev = v9;
  v11 = data->volumetricsIndex & 1;
  drawStream.viewInfo = viewInfo;
  drawStream.toggle = v11;
  Surface = R_RT_Handle::GetSurface(attachments);
  blackImage3D = rgp.blackImage3D;
  resources.scatterTemporalWriteImage = &Surface->m_image.m_base;
  v24 = taskInfo->attachments[1];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v24);
    resources.scatterTemporalReadImage = &R_RT_Handle::GetSurface(&v24)->m_image.m_base;
  }
  else
  {
    if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
      __debugbreak();
    resources.scatterTemporalReadImage = blackImage3D;
  }
  v14 = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
  v15 = taskInfo->attachments + 3;
  resources.extinctionTemporalReadImage = &v14->m_image.m_base;
  v16 = R_RT_Handle::GetSurface(v15);
  blackImage = rgp.blackImage;
  resources.visibilityImage = &v16->m_image.m_base;
  v24 = taskInfo->attachments[4];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v24);
    resources.visibilityPrevFrameImage = &R_RT_Handle::GetSurface(&v24)->m_image.m_base;
  }
  else
  {
    if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v24.m_surfaceID) )
      __debugbreak();
    resources.visibilityPrevFrameImage = blackImage;
  }
  v18 = R_RT_Handle::GetSurface(taskInfo->attachments + 5);
  v19 = taskInfo->attachments + 6;
  resources.scatterIntegralImage = &v18->m_image.m_base;
  v20 = R_RT_Handle::GetSurface(v19);
  v21 = taskInfo->attachments + 7;
  resources.extinctionIntegralImage = &v20->m_image.m_base;
  v22 = R_RT_Handle::GetSurface(v21);
  v23 = taskInfo->attachments + 8;
  resources.scatterCurrentTexture = &v22->m_image.m_base;
  resources.scatterCurrentMomentsTexture = &R_RT_Handle::GetSurface(v23)->m_image.m_base;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_AccumulateScattering(&drawStream, &resources);
}

/*
==============
RBT_VOL_ClearIndirectScattering
==============
*/
void RBT_VOL_ClearIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxShaderBufferRWView *views; 

  views = &R_RT_Handle::GetWrappedBuffer(taskInfo->attachments)->rwView;
  R_SetComputeRWViewsWithCounters(computeState, 0, 1, (const GfxShaderBufferRWView *const *)&views, NULL);
  R_SetComputeShader(computeState, rgp.clearIndirectScattering);
  R_Dispatch(computeState, 1u, 1u, 1u);
}

/*
==============
RBT_VOL_CombineAmbientMultiLightGrid
==============
*/
void RBT_VOL_CombineAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *attachments; 
  ID3D12Resource *buffers; 

  attachments = taskInfo->attachments;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_CombineAmbientMultiLightGrid(computeState, viewInfo, attachments, attachments + 1, attachments + 2, attachments + 3, attachments + 4, attachments + 5, attachments + 6, attachments + 7);
}

/*
==============
RBT_VOL_FillIndirectScattering
==============
*/
void RBT_VOL_FillIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __m256i v9; 
  R_RT_Handle *v11; 
  const R_RT_Surface *Surface; 
  const GfxWrappedBuffer *v13; 
  const R_RT_Surface *v14; 
  const GfxWrappedBuffer *v15; 
  const R_RT_Surface *v16; 
  const GfxWrappedBuffer *v17; 
  __m256i v18; 
  bool v20; 
  R_RT_Handle *attachments; 
  __m256i v22; 
  bool v24; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  R_RT_Handle v26; 
  __m256i v27; 
  ID3D12Resource *buffers; 
  R_RT_ColorHandle visibilityTexture; 
  R_RT_BufferHandle froxelIDBuffer; 
  R_RT_BufferHandle froxelIndirectBuffer; 

  v9 = *(__m256i *)taskInfo->attachments;
  v27 = v9;
  v26 = (R_RT_Handle)v9;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v9 = (__m256i)v26;
      __debugbreak();
    }
    else
    {
      v9 = (__m256i)v26;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v9 = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v11 = taskInfo->attachments + 1;
  visibilityTexture = (R_RT_ColorHandle)v9;
  Surface = R_RT_Handle::GetSurface(v11);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v13 = (const GfxWrappedBuffer *)&Surface->1080;
  v14 = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
  if ( (v14->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v15 = (const GfxWrappedBuffer *)&v14->1080;
  v16 = R_RT_Handle::GetSurface(taskInfo->attachments + 3);
  if ( (v16->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v17 = (const GfxWrappedBuffer *)&v16->1080;
  v18 = (__m256i)taskInfo->attachments[4];
  v27 = v18;
  v26 = (R_RT_Handle)v18;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v18 = (__m256i)v26;
    }
    else
    {
      v18 = (__m256i)v26;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v18 = v27;
      if ( v20 )
        __debugbreak();
    }
  }
  attachments = taskInfo->attachments;
  froxelIndirectBuffer = (R_RT_BufferHandle)v18;
  v22 = (__m256i)attachments[5];
  v27 = v22;
  v26 = (R_RT_Handle)v22;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v22 = (__m256i)v26;
    }
    else
    {
      v22 = (__m256i)v26;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v22 = v27;
      if ( v24 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  froxelIDBuffer = (R_RT_BufferHandle)v22;
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_FillIndirectScattering(computeState, viewInfo, v13, v15, v17, &froxelIndirectBuffer, &froxelIDBuffer, &visibilityTexture);
}

/*
==============
RBT_VOL_MaxFloatZ
==============
*/
void RBT_VOL_MaxFloatZ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *dstVolVisibilityRt; 
  int reProjFloatZMipMap; 
  R_RT_Handle v10; 
  bool v12; 
  int ambientVisibilityMipMap; 
  R_RT_Handle v14; 
  bool v16; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v19; 
  R_RT_Handle v20; 
  R_RT_Handle v21; 
  R_RT_Handle v22; 
  R_RT_Handle v23; 
  ID3D12Resource *buffers; 

  dstVolVisibilityRt = taskInfo->attachments;
  reProjFloatZMipMap = viewInfo->reProjFloatZMipMap;
  v21 = dstVolVisibilityRt[6];
  v10 = *R_RT_GetViewInternal(&v22, &v21, 0, reProjFloatZMipMap);
  v21 = v10;
  v20 = v10;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v10 = v20;
      __debugbreak();
    }
    else
    {
      v10 = v20;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v10 = v21;
      if ( v12 )
        __debugbreak();
    }
  }
  ambientVisibilityMipMap = viewInfo->ambientVisibilityMipMap;
  v22 = v10;
  v21 = dstVolVisibilityRt[6];
  v14 = *R_RT_GetViewInternal(&v23, &v21, 0, ambientVisibilityMipMap);
  v21 = v14;
  v20 = v14;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v14 = v20;
      __debugbreak();
    }
    else
    {
      v14 = v20;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v14 = v21;
      if ( v16 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  v21 = v14;
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  Surface = R_RT_Handle::GetSurface(&v21);
  v19 = R_RT_Handle::GetSurface(&v22);
  R_VOL_MaxFloatZ(computeState, viewInfo, &v19->m_image.m_base, &Surface->m_image.m_base, dstVolVisibilityRt + 4, dstVolVisibilityRt + 5, dstVolVisibilityRt, dstVolVisibilityRt + 2);
}

/*
==============
RBT_VOL_SampleAmbient
==============
*/
void RBT_VOL_SampleAmbient(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int16 v4; 
  R_RT_Handle *attachments; 
  R_RT_Image *visibilityPrev; 
  const R_RT_Handle *v11; 
  R_RT_Handle v12; 
  ID3D12Resource *buffers; 

  attachments = taskInfo->attachments;
  visibilityPrev = (R_RT_Image *)rgp.blackImage;
  v12 = attachments[6];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v12);
    visibilityPrev = &R_RT_Handle::GetSurface(&v12)->m_image;
  }
  else if ( v12.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v11 = taskInfo->attachments + 7;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_SampleLightgridImages(computeState, viewInfo, attachments + 1, attachments, v11, attachments + 2, attachments + 3, attachments + 4, attachments + 5, &visibilityPrev->m_base);
}

/*
==============
RBT_VOL_SampleAmbientMultiLightGrid
==============
*/
void RBT_VOL_SampleAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *attachments; 
  ID3D12Resource *buffers; 

  attachments = taskInfo->attachments;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_SampleAmbientMultiLightGrid(computeState, viewInfo, attachments, attachments + 1, attachments + 2, attachments + 4, attachments + 6, attachments + 7);
}

/*
==============
RBT_VOL_Scattering
==============
*/
void RBT_VOL_Scattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned __int16 v4; 
  unsigned int v9; 
  bool v10; 
  R_RT_Handle *attachments; 
  unsigned int v12; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage3D; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v16; 
  const GfxWrappedRWBuffer *v17; 
  R_RT_Handle *v18; 
  const GfxWrappedRWBuffer *v19; 
  R_RT_Handle *v20; 
  const R_RT_Surface *v21; 
  R_RT_Handle *v22; 
  const R_RT_Surface *v23; 
  R_RT_Handle *v24; 
  const R_RT_Surface *v25; 
  GfxImage *v26; 
  GfxImage *blackShadowImage; 
  __int64 v28; 
  bool v29; 
  GfxImage *zeroImage; 
  bool v31; 
  GfxImage *blackImage; 
  bool v33; 
  GfxImage *v34; 
  bool v35; 
  const GfxWrappedRWBuffer *v36; 
  R_RT_Handle *v37; 
  R_RT_Handle *v38; 
  GfxImage *v39; 
  R_RT_Handle v40; 
  VolumetricScatteringResources resources; 
  VolumetricDrawStream drawStream; 
  ID3D12Resource *buffers; 

  v9 = *taskInfo->pTaskData;
  drawStream.state = computeState;
  drawStream.data = data;
  v10 = R_VOL_UseLocalMedia(data, viewInfo);
  attachments = taskInfo->attachments;
  drawStream.useLocalMedia = v10;
  drawStream.useLocalMediaPrev = v10;
  v12 = data->volumetricsIndex & 1;
  drawStream.viewInfo = viewInfo;
  drawStream.toggle = v12;
  Surface = R_RT_Handle::GetSurface(attachments);
  blackImage3D = rgp.blackImage3D;
  resources.maxFloatzImage = &Surface->m_image.m_base;
  v40 = taskInfo->attachments[1];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v40);
    resources.ambientImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
  }
  else
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v4 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    resources.ambientImage = blackImage3D;
  }
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
  v16 = taskInfo->attachments + 3;
  resources.volumesClusterBuffer = WrappedBuffer;
  v17 = R_RT_Handle::GetWrappedBuffer(v16);
  v18 = taskInfo->attachments + 4;
  resources.featureClusterBuffer = v17;
  v19 = R_RT_Handle::GetWrappedBuffer(v18);
  v20 = taskInfo->attachments + 5;
  resources.lightsClusterBuffer = v19;
  v21 = R_RT_Handle::GetSurface(v20);
  v22 = taskInfo->attachments + 6;
  resources.scatterTemporalWriteImage = &v21->m_image.m_base;
  v23 = R_RT_Handle::GetSurface(v22);
  v24 = taskInfo->attachments + 7;
  resources.scatterMomentsWriteImage = &v23->m_image.m_base;
  v25 = R_RT_Handle::GetSurface(v24);
  v26 = rgp.blackImage3D;
  resources.extinctionTemporalWriteImage = &v25->m_image.m_base;
  v40 = taskInfo->attachments[8];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v40);
    resources.extinctionTemporalReadImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
  }
  else
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    resources.extinctionTemporalReadImage = v26;
  }
  blackShadowImage = rgp.blackShadowImage;
  v28 = 10i64;
  v29 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
  if ( data->sunShadow.opaqueCascadeCount <= 1u )
    v28 = 9i64;
  v40 = taskInfo->attachments[v28];
  if ( !v4 )
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    goto LABEL_19;
  }
  R_RT_Handle::GetSurface(&v40);
  if ( !v29 )
  {
LABEL_19:
    resources.sunShadowImage = blackShadowImage;
    goto LABEL_20;
  }
  resources.sunShadowImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
LABEL_20:
  zeroImage = rgp.zeroImage;
  v31 = R_SunShadow_TranslucentEnabled(viewInfo);
  v40 = taskInfo->attachments[11];
  if ( !v4 )
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v4 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    goto LABEL_24;
  }
  R_RT_Handle::GetSurface(&v40);
  if ( !v31 )
  {
LABEL_24:
    resources.translucentSunShadowImage = zeroImage;
    goto LABEL_25;
  }
  resources.translucentSunShadowImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
LABEL_25:
  blackImage = rgp.blackImage;
  v33 = R_SunShadow_TranslucentEnabled(viewInfo);
  v40 = taskInfo->attachments[12];
  if ( !v4 )
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v4 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    goto LABEL_29;
  }
  R_RT_Handle::GetSurface(&v40);
  if ( !v33 )
  {
LABEL_29:
    resources.translucentSunShadowMaskImage = blackImage;
    goto LABEL_30;
  }
  resources.translucentSunShadowMaskImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
LABEL_30:
  v34 = rgp.blackShadowImage;
  v35 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
  v40 = taskInfo->attachments[13];
  if ( !v4 )
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    goto LABEL_34;
  }
  R_RT_Handle::GetSurface(&v40);
  if ( !v35 )
  {
LABEL_34:
    resources.spotShadowCacheStale = v34;
    goto LABEL_35;
  }
  resources.spotShadowCacheStale = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
LABEL_35:
  v36 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 14);
  v37 = taskInfo->attachments + 15;
  resources.indirectScatteringBuffer = v36;
  resources.froxelIDBuffer = R_RT_Handle::GetWrappedBuffer(v37);
  v38 = taskInfo->attachments;
  v39 = rgp.blackImage;
  v40 = v38[16];
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v40);
    resources.visibilityPrevFrameImage = &R_RT_Handle::GetSurface(&v40)->m_image.m_base;
  }
  else
  {
    if ( v40.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v40.m_surfaceID) )
      __debugbreak();
    resources.visibilityPrevFrameImage = v39;
  }
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_EvaluateScattering(&drawStream, &resources, v9);
}

/*
==============
RBT_VOL_ScatteringSetup
==============
*/
void RBT_VOL_ScatteringSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  __int16 v2; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  signed int width; 
  signed int v8; 
  signed int v9; 
  unsigned int v10; 
  int v11; 
  unsigned int reProjFloatZHeight; 
  unsigned int reProjFloatZWidth; 
  unsigned int reProjFloatZMipMap; 
  signed int v15; 
  signed int v16; 
  R_RT_Handle v17; 
  R_RT_Handle v18; 
  R_RT_Handle v19; 

  v19 = taskInfo->attachments[2];
  R_SetInputCodePersistentBuffer(&viewInfo->input, 0xDu, &v19);
  v18 = taskInfo->attachments[5];
  height = R_RT_Handle::GetSurface(&v18)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v18);
  R_SetForwardPlusClusterInfo(viewInfo, Surface->m_image.m_base.width, height);
  width = viewInfo->sceneViewport.width;
  v8 = viewInfo->sceneViewport.height;
  v9 = v8 / (signed int)viewInfo->frustumGrid.voxelCountY;
  if ( width / (signed int)viewInfo->frustumGrid.voxelCountX < v9 )
    v9 = (signed int)viewInfo->sceneViewport.width / (signed int)viewInfo->frustumGrid.voxelCountX;
  v10 = __lzcnt(v9);
  v11 = 1 << (31 - v10);
  viewInfo->reProjFloatZMipMap = 31 - v10;
  viewInfo->reProjFloatZWidth = width / v11;
  viewInfo->reProjFloatZHeight = v8 / v11;
  v17 = taskInfo->attachments[1];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v17);
    v15 = width / (unsigned int)R_RT_Handle::GetSurface(&v17)->m_image.m_base.width;
    v16 = v8 / (unsigned int)R_RT_Handle::GetSurface(&v17)->m_image.m_base.height;
    if ( v15 < v16 )
      v16 = v15;
    reProjFloatZMipMap = 31 - __lzcnt(v16);
    reProjFloatZHeight = v8 / (1 << reProjFloatZMipMap);
    reProjFloatZWidth = width / (1 << reProjFloatZMipMap);
  }
  else
  {
    if ( v17.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v17.m_surfaceID) )
      __debugbreak();
    reProjFloatZHeight = viewInfo->reProjFloatZHeight;
    reProjFloatZWidth = viewInfo->reProjFloatZWidth;
    reProjFloatZMipMap = viewInfo->reProjFloatZMipMap;
  }
  viewInfo->ambientVisibilityMipMap = reProjFloatZMipMap;
  viewInfo->ambientVisibilityWidth = reProjFloatZWidth;
  viewInfo->ambientVisibilityHeight = reProjFloatZHeight;
}

/*
==============
RBT_VOL_WriteClusterBuffer
==============
*/
void RBT_VOL_WriteClusterBuffer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v9; 
  R_RT_Handle *attachments; 
  R_RT_Handle v12; 
  bool v14; 
  const R_RT_Surface *Surface; 
  const GfxWrappedRWBuffer *v16; 
  const R_RT_Surface *v17; 
  R_RT_Handle v18; 
  R_RT_Handle v19; 
  R_RT_Handle v20; 

  v9 = *taskInfo->attachments;
  v19 = v9;
  v18 = v9;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v18);
    if ( (R_RT_Handle::GetSurface(&v18)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v9 = v18;
    }
    else
    {
      v9 = v18;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v9 = v19;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  attachments = taskInfo->attachments;
  v20 = v9;
  v12 = attachments[1];
  v19 = v12;
  v18 = v12;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v18);
    if ( (R_RT_Handle::GetSurface(&v18)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v12 = v18;
    }
    else
    {
      v12 = v18;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v12 = v19;
      if ( v14 )
        __debugbreak();
    }
  }
  v19 = v12;
  Surface = R_RT_Handle::GetSurface(&v19);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v16 = (const GfxWrappedRWBuffer *)&Surface->1080;
  v17 = R_RT_Handle::GetSurface(&v20);
  if ( (v17->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  R_VOL_FrustumGridCluster(computeState, viewInfo, data, (const GfxWrappedRWBuffer *)&v17->1080, v16);
}

