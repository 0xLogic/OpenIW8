/*
==============
Scr_EnableDismemberment
==============
*/

void __fastcall Scr_EnableDismemberment(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_EnableDismemberment@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_NonLocalizedStringErrorPrefix
==============
*/

int __fastcall Scr_NonLocalizedStringErrorPrefix(scrContext_t *scrContext, int parmIndex, unsigned int tokenLen, const char *errorContext, unsigned int stringLen, unsigned int stringLimit, char *string)
{
  return ?Scr_NonLocalizedStringErrorPrefix@@YAHAEAUscrContext_t@@HIPEBDIIPEAD@Z(scrContext, parmIndex, tokenLen, errorContext, stringLen, stringLimit, string);
}

/*
==============
GScrSP_FindAITypeScriptByClassname
==============
*/

const AITypeScript *__fastcall GScrSP_FindAITypeScriptByClassname(const char *const classname)
{
  return ?GScrSP_FindAITypeScriptByClassname@@YAPEBUAITypeScript@@QEBD@Z(classname);
}

/*
==============
GScriptSP::GetMethod
==============
*/

unsigned int __fastcall GScriptSP::GetMethod(GScriptSP *this, const char **pName, BuiltinType *type)
{
  return ?GetMethod@GScriptSP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
GScr_SpawnDrone
==============
*/

void __fastcall GScr_SpawnDrone(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SpawnDrone@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_ValidateNonLocalizedStringRef
==============
*/

bool __fastcall Scr_ValidateNonLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen, const char *errorContext)
{
  return ?Scr_ValidateNonLocalizedStringRef@@YA_NAEAUscrContext_t@@HPEBDH1@Z(scrContext, parmIndex, token, tokenLen, errorContext);
}

/*
==============
GScr_MainSP_StartRagdoll
==============
*/

void __fastcall GScr_MainSP_StartRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MainSP_StartRagdoll@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MakeEntityDrone
==============
*/

void __fastcall GScr_MakeEntityDrone(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MakeEntityDrone@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_Hide
==============
*/

void __fastcall ScrCmd_Hide(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_Hide@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_Show
==============
*/

void __fastcall ScrCmd_Show(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_Show@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_DisableDismemberment
==============
*/

void __fastcall Scr_DisableDismemberment(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_DisableDismemberment@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SetCalloutText
==============
*/

void __fastcall GScr_SetCalloutText(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetCalloutText@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_StartRagdollInternal
==============
*/

void __fastcall GScr_StartRagdollInternal(gentity_s *ent, bool bAutoUnlink)
{
  ?GScr_StartRagdollInternal@@YAXPEAUgentity_s@@_N@Z(ent, bAutoUnlink);
}

/*
==============
GScrSP_ClearAITypeScriptTable
==============
*/

void GScrSP_ClearAITypeScriptTable(void)
{
  ?GScrSP_ClearAITypeScriptTable@@YAXXZ();
}

/*
==============
Scr_BulletTracer
==============
*/

void __fastcall Scr_BulletTracer(scrContext_t *scrContext)
{
  ?Scr_BulletTracer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_SetCorpseRemoveTimer
==============
*/

void __fastcall GScr_SetCorpseRemoveTimer(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetCorpseRemoveTimer@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScriptSP::GetFunction
==============
*/

unsigned int __fastcall GScriptSP::GetFunction(GScriptSP *this, const char **pName, BuiltinType *type)
{
  return ?GetFunction@GScriptSP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
GScriptSP::ConstructMessageString
==============
*/

void __fastcall GScriptSP::ConstructMessageString(GScriptSP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  ?ConstructMessageString@GScriptSP@@UEBAXAEAUscrContext_t@@HHPEBDPEADI@Z(this, scrContext, firstParmIndex, lastParmIndex, errorContext, string, stringLimit);
}

/*
==============
ScrCmd_HideOnClient
==============
*/

void __fastcall ScrCmd_HideOnClient(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_HideOnClient@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SetLookatText
==============
*/

void __fastcall GScr_SetLookatText(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetLookatText@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_ShowOnClient
==============
*/

void __fastcall ScrCmd_ShowOnClient(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_ShowOnClient@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScrSP_SetScripts
==============
*/

void __fastcall GScrSP_SetScripts(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts)
{
  ?GScrSP_SetScripts@@YAXPEAUScriptFunctions@@PEAUEntryLoadScriptArray@@@Z(functions, loadscripts);
}

/*
==============
GScr_SetSingleAnimScript
==============
*/

void __fastcall GScr_SetSingleAnimScript(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts, GScrAnimScriptFunc *pAnim, const char *name, const char *subdir)
{
  ?GScr_SetSingleAnimScript@@YAXPEAUScriptFunctions@@PEAUEntryLoadScriptArray@@PEAUGScrAnimScriptFunc@@PEBD3@Z(functions, loadscripts, pAnim, name, subdir);
}

/*
==============
GScr_MainSP_SetHealth
==============
*/

void __fastcall GScr_MainSP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?GScr_MainSP_SetHealth@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_IncrementCounter
==============
*/
void GScr_IncrementCounter(scrContext_t *scrContext)
{
  const char *String; 
  int Int; 
  __int64 v4; 
  int v5; 

  String = Scr_GetString(scrContext, 0);
  Int = Scr_GetInt(scrContext, 1u);
  v4 = Int;
  if ( Int )
  {
    if ( Int >= 0 )
    {
      v5 = LiveCounter_CounterStringToID(String);
      if ( v5 == -1 )
        Com_PrintError(16, "Invalid counter string id: %s\n", String);
      else
        LiveCounter_IncrementCounterValue(v5, v4);
    }
    else
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10063, ASSERT_TYPE_ASSERT, "(increment >= 0)", (const char *)&queryFormat, "increment >= 0") )
        __debugbreak();
      Com_PrintError(16, "Invalid param: <increment value> must be greater than or equal to zero\n");
    }
  }
}

/*
==============
GScr_GetCounterTotal
==============
*/
void GScr_GetCounterTotal(scrContext_t *scrContext)
{
  const char *String; 
  int v3; 
  const char *v4; 
  __int64 CounterTotalValue; 

  String = Scr_GetString(scrContext, 0);
  v3 = LiveCounter_CounterStringToID(String);
  if ( v3 == -1 )
  {
    Com_PrintError(16, "Invalid counter string id: %s\n", String);
  }
  else
  {
    CounterTotalValue = LiveCounter_GetCounterTotalValue(v3);
    if ( CounterTotalValue != -1 )
    {
      v4 = j_va("%llu", CounterTotalValue);
      goto LABEL_6;
    }
  }
  v4 = (char *)&queryFormat.fmt + 3;
LABEL_6:
  Scr_AddString(scrContext, v4);
}

/*
==============
ScrCmd_PlayerSetGroundReferenceEnt
==============
*/
void ScrCmd_PlayerSetGroundReferenceEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Com_GameMode_SupportsFeature(WEAPON_MELEE) )
    Scr_Error(COM_ERR_3261, scrContext, "PlayerSetGroundReferenceEnt is not supported in this game mode");
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_3262, scrContext, "not a player entity");
  if ( Scr_GetType(scrContext, 0) )
  {
    if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
      Scr_ParamError(COM_ERR_3263, scrContext, 0, "not an entity");
    Entity->client->ps.groundRefEnt = GScr_GetEntity(0)->s.number;
  }
  else
  {
    Entity->client->ps.groundRefEnt = 2047;
  }
}

/*
==============
Scr_GetAICount
==============
*/
void Scr_GetAICount(scrContext_t *scrContext)
{
  int v1; 
  scrContext_t *v2; 
  scr_string_t ConstString; 
  scr_string_t v4; 
  AISpecies Species; 
  AIIterator *AIAgentIterator; 
  const gentity_s *v7; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v9; 
  __int64 v10; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  v1 = 0;
  v2 = scrContext;
  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(v2, 0);
    Scr_GetTeamFlag((bitarray<224> *)&result, v2, ConstString);
  }
  else if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
  {
    Com_TeamsSP_GetAllTeamFlags();
  }
  else
  {
    Com_TeamsMP_GetAllTeamFlags();
  }
  if ( Scr_GetNumParam(v2) <= 1 )
  {
    Species = MAX_AI_SPECIES;
  }
  else
  {
    v4 = Scr_GetConstString(v2, 1u);
    Species = Scr_GetSpecies(v2, v4);
  }
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  v7 = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator);
  if ( v7 )
  {
    do
    {
      AIAgentInterface::AIAgentInterface(&result);
      result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      p_result = NULL;
      if ( SV_IsAgentScripted(v7) )
      {
        ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(v7);
        if ( ScriptedAgentInfo )
        {
          p_result = &result;
          AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
        }
      }
      v9 = (__int64)p_result;
      if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11417, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v9 + 128i64))(v9) )
      {
        v10 = (**(__int64 (__fastcall ***)(__int64))v9)(v9);
        if ( !*(_BYTE *)(v10 + 1851) && (Species == *(_DWORD *)(v10 + 2088) || Species == MAX_AI_SPECIES) )
          ++v1;
      }
      v7 = AIAgentIterator->GetNext(AIAgentIterator);
    }
    while ( v7 );
    v2 = scrContext;
  }
  Scr_AddInt(v2, v1);
}

/*
==============
Scr_GetFreeAICount
==============
*/
void Scr_GetFreeAICount(scrContext_t *scrContext)
{
  AIIterator *AIAgentIterator; 
  int v3; 
  __int64 i; 
  int v5; 

  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  v3 = 0;
  for ( i = AIAgentIterator->GetFirst(AIAgentIterator); i; i = (__int64)AIAgentIterator->GetNext(AIAgentIterator) )
  {
    v5 = v3 + 1;
    if ( (*(_BYTE *)(*(_QWORD *)(i + 360) + 36832i64) & 1) != 0 )
      v5 = v3;
    v3 = v5;
  }
  if ( v3 > level.maxagents && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11460, ASSERT_TYPE_ASSERT, "(count <= level.maxagents)", (const char *)&queryFormat, "count <= level.maxagents") )
    __debugbreak();
  Scr_AddInt(scrContext, level.maxagents - v3);
}

/*
==============
Scr_GetAISpeciesArray
==============
*/
void Scr_GetAISpeciesArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  AISpecies Species; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v8; 
  __int64 v9; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Scr_GetTeamFlag((bitarray<224> *)&result, scrContext, ConstString);
  }
  else if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
  {
    Com_TeamsSP_GetAllTeamFlags();
  }
  else
  {
    Com_TeamsMP_GetAllTeamFlags();
  }
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    Species = MAX_AI_SPECIES;
  }
  else
  {
    v3 = Scr_GetConstString(scrContext, 1u);
    Species = Scr_GetSpecies(scrContext, v3);
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    AIAgentInterface::AIAgentInterface(&result);
    result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    p_result = NULL;
    if ( SV_IsAgentScripted(i) )
    {
      ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
      if ( ScriptedAgentInfo )
      {
        p_result = &result;
        AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
      }
    }
    v8 = (__int64)p_result;
    if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11502, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
      __debugbreak();
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 128i64))(v8) )
    {
      v9 = (**(__int64 (__fastcall ***)(__int64))v8)(v8);
      if ( !*(_BYTE *)(v9 + 1851) && (Species == *(_DWORD *)(v9 + 2088) || Species == MAX_AI_SPECIES) )
      {
        GScr_AddEntity(i);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
Scr_GetAIUnitTypeArray
==============
*/
void Scr_GetAIUnitTypeArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  AIUnitType v5; 
  const char *v6; 
  scr_string_t LowercaseString; 
  bool v8; 
  const char *v9; 
  const char *v10; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v14; 
  __int64 v15; 
  AIUnitType unitType; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Scr_GetTeamFlag((bitarray<224> *)&result, scrContext, ConstString);
  }
  else if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
  {
    Com_TeamsSP_GetAllTeamFlags();
  }
  else
  {
    Com_TeamsMP_GetAllTeamFlags();
  }
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    v5 = AI_UNITTYPE_SOLDIER;
  }
  else
  {
    v3 = Scr_GetConstString(scrContext, 1u);
    v4 = v3;
    if ( v3 == scr_const.all )
    {
      v5 = MAX_AI_UNITTYPES;
    }
    else
    {
      v6 = SL_ConvertToString(v3);
      LowercaseString = SL_GetLowercaseString(v6, 0);
      v8 = AIScriptedInterface::GetUnitType(LowercaseString, &unitType);
      SL_RemoveRefToString(LowercaseString);
      if ( v8 )
      {
        v5 = unitType;
      }
      else
      {
        v9 = SL_ConvertToString(v4);
        v10 = j_va("unknown unit type %s. (should be soldier, civilian, C6, C8, C12, alien, juggernaut, suicidebomber, or all.)", v9);
        Scr_Error(COM_ERR_3303, scrContext, v10);
        v5 = MAX_AI_UNITTYPES;
      }
    }
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    AIAgentInterface::AIAgentInterface(&result);
    result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    p_result = NULL;
    if ( SV_IsAgentScripted(i) )
    {
      ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
      if ( ScriptedAgentInfo )
      {
        p_result = &result;
        AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
      }
    }
    v14 = (__int64)p_result;
    if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11578, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
      __debugbreak();
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 128i64))(v14) )
    {
      v15 = (**(__int64 (__fastcall ***)(__int64))v14)(v14);
      if ( !*(_BYTE *)(v15 + 1851) && (v5 == MAX_AI_UNITTYPES || v5 == *(_DWORD *)(v15 + 3048)) )
      {
        GScr_AddEntity(i);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
ScrCmd_Kill
==============
*/
void ScrCmd_Kill(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  gentity_s *v4; 
  gentity_s *v5; 
  gentity_s *Entity; 
  ai_agent_t *ScriptedAgentInfo; 
  AIAgentInterface *v8; 
  const char *v9; 
  unsigned int NumParam; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 
  const char *v14; 
  gentity_s *v15; 
  gclient_s *client; 
  gclient_s *v17; 
  float v18; 
  __int128 v19; 
  __int128 v20; 
  __int128 v21; 
  float v22; 
  __int128 v23; 
  __int128 v24; 
  float v25; 
  __int128 v26; 
  vec3_t *v30; 
  playerState_s *EntityPlayerState; 
  playerState_s *v32; 
  gagent_s *agent; 
  const char *v34; 
  int health; 
  const char *EntityTypeName; 
  Weapon *r_weapon; 
  vec3_t *vDir; 
  meansOfDeath_t meansOfDeath; 
  gentity_s *inflictor; 
  AIAgentInterface v41; 
  AIAgentInterface *v42; 
  vec3_t vectorValue; 
  float v44; 
  float v45; 
  float v46; 
  vec3_t v47; 
  __int128 v48; 

  v4 = NULL;
  inflictor = NULL;
  v5 = NULL;
  meansOfDeath = MOD_SUICIDE;
  Entity = GetEntity(entref);
  vectorValue = Entity->r.currentOrigin;
  v47.v[0] = 0.0;
  v47.v[1] = 0.0;
  v47.v[2] = 0.0;
  AIAgentInterface::AIAgentInterface(&v41);
  v42 = NULL;
  v41.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  if ( SV_IsAgentScripted(Entity) )
  {
    ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(Entity);
    if ( ScriptedAgentInfo )
    {
      v42 = &v41;
      AINewAgentInterface::SetAgent((AINewAgentInterface *)&v41, ScriptedAgentInfo);
    }
  }
  v8 = v42;
  if ( v42 && *(_BYTE *)(v42->GetAI(v42) + 1645) )
  {
    v9 = j_va("Trying to kill AI %d with damageShield (magic_bullet_shield)", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_3308, scrContext, v9);
    return;
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( !NumParam )
    goto LABEL_22;
  v11 = NumParam - 1;
  if ( v11 )
  {
    v12 = v11 - 1;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 != 1 )
        {
          Scr_Error(COM_ERR_3310, scrContext, "Usage: kill( <source position>, <attacker>, <inflictor> )\n");
          return;
        }
        meansOfDeath = G_Combat_MeansOfDeathFromScriptParam(scrContext, 3);
      }
      v4 = GScr_GetEntity(2u);
      inflictor = v4;
    }
    v5 = GScr_GetEntity(1u);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( (LODWORD(vectorValue.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[2]) & 0x7F800000) == 2139095040 )
  {
    v14 = j_va("Source Damage vector is invalid : %f %f %f", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
    Scr_Error(COM_ERR_3309, scrContext, v14);
  }
  if ( v4 )
  {
    v15 = g_entities;
  }
  else
  {
LABEL_22:
    v15 = g_entities;
    inflictor = g_entities + 2046;
  }
  v48 = v2;
  if ( !v5 )
    v5 = v15 + 2046;
  client = Entity->client;
  if ( client )
  {
    if ( ((LODWORD(client->ps.origin.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(client->ps.origin.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(client->ps.origin.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11917, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] )") )
      __debugbreak();
    v17 = Entity->client;
    v18 = v17->ps.origin.v[0] - vectorValue.v[0];
    v44 = v18;
    v19 = LODWORD(v17->ps.origin.v[1]);
    v21 = v19;
    *(float *)&v21 = *(float *)&v19 - vectorValue.v[1];
    v20 = v21;
    v45 = *(float *)&v19 - vectorValue.v[1];
    v22 = v17->ps.origin.v[2];
  }
  else
  {
    if ( ((LODWORD(Entity->r.currentOrigin.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(Entity->r.currentOrigin.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(Entity->r.currentOrigin.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11922, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] )") )
      __debugbreak();
    v18 = Entity->r.currentOrigin.v[0] - vectorValue.v[0];
    v44 = v18;
    v23 = LODWORD(Entity->r.currentOrigin.v[1]);
    v24 = v23;
    *(float *)&v24 = *(float *)&v23 - vectorValue.v[1];
    v20 = v24;
    v45 = *(float *)&v23 - vectorValue.v[1];
    v22 = Entity->r.currentOrigin.v[2];
  }
  v25 = v22 - vectorValue.v[2];
  v46 = v22 - vectorValue.v[2];
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 || (v20 & 0x7F800000) == 2139095040 || (COERCE_UNSIGNED_INT(v22 - vectorValue.v[2]) & 0x7F800000) == 2139095040 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11926, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
      __debugbreak();
    v18 = v44;
    v20 = LODWORD(v45);
    v25 = v46;
  }
  v26 = v20;
  *(float *)&v26 = fsqrt((float)((float)(*(float *)&v20 * *(float *)&v20) + (float)(v18 * v18)) + (float)(v25 * v25));
  _XMM3 = v26;
  __asm
  {
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm1, xmm0
  }
  v30 = &v47;
  v44 = v18 * (float)(1.0 / *(float *)&_XMM0);
  v46 = v25 * (float)(1.0 / *(float *)&_XMM0);
  v45 = *(float *)&v20 * (float)(1.0 / *(float *)&_XMM0);
  if ( *(float *)&v26 != 0.0 )
    v30 = (vec3_t *)&v44;
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  v32 = EntityPlayerState;
  if ( EntityPlayerState )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&EntityPlayerState->eFlags, ACTIVE, 0x10u);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x10u);
  G_SetEntityFlag(Entity, DEAD);
  if ( Entity->health > 0 )
  {
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(&Entity->flags, ACTIVE, 0);
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(&Entity->flags, ACTIVE, 1u);
    Entity->health = 0;
    if ( v32 )
      v32->stats[0] = 0;
    agent = Entity->agent;
    if ( agent )
    {
      if ( (unsigned int)(agent->playerState.pm_type - 7) <= 1 )
      {
        v34 = j_va("Agent(%d) is already dead when suicide command called!", (unsigned int)Entity->s.number);
        Scr_Error(COM_ERR_3311, scrContext, v34);
        return;
      }
      G_CombatMP_AgentDie(Entity, inflictor, v5, 100000, 0, meansOfDeath, &NULL_WEAPON, 0, v30, HITLOC_NONE, 0);
    }
    else if ( Entity->client )
    {
      G_CombatMP_PlayerDie(Entity, inflictor, v5, 100000, 0, meansOfDeath, &NULL_WEAPON, 0, v30, HITLOC_NONE, 0);
    }
    if ( Entity->health > 0 && (!v8 || !*(_BYTE *)(v8->GetAI(v8) + 1851)) )
    {
      health = Entity->health;
      EntityTypeName = G_GetEntityTypeName(Entity);
      LODWORD(vDir) = health;
      LODWORD(r_weapon) = Entity->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11971, ASSERT_TYPE_ASSERT, "(ent->health <= 0 || ( pAgent && pAgent->GetAI()->painDeath.delayedDeath ))", "%s\n\tentity: %d, type: %s, health: %d\n", "ent->health <= 0 || ( pAgent && pAgent->GetAI()->painDeath.delayedDeath )", r_weapon, EntityTypeName, vDir) )
        __debugbreak();
    }
  }
}

/*
==============
Scr_UpdateEntityWithWeapons
==============
*/
void Scr_UpdateEntityWithWeapons(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
Scr_GetEntityWeapons
==============
*/

void __fastcall Scr_GetEntityWeapons(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_MakeArray(scrContext);
}

/*
==============
GScr_IsAlive
==============
*/
void GScr_IsAlive(scrContext_t *scrContext)
{
  VariableType Type; 
  int v3; 

  Type = Scr_GetType(scrContext, 0);
  v3 = 0;
  if ( Type == VAR_POINTER )
  {
    if ( Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    {
      Scr_AddInt(scrContext, 0);
      return;
    }
    v3 = GScr_GetEntity(0)->health > 0;
  }
  Scr_AddInt(scrContext, v3);
}

/*
==============
GScr_IsSpawner
==============
*/
void GScr_IsSpawner(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->s.eType == ET_VEHICLE_SPAWNER )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
Scr_LogString
==============
*/
void Scr_LogString(scrContext_t *scrContext)
{
  ;
}

/*
==============
ScrCmd_LogString
==============
*/
void ScrCmd_LogString(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_GetOrigin
==============
*/
void ScrCmd_GetOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  vec3_t value; 

  value = GetEntity(entref)->r.currentOrigin;
  Scr_AddVector(scrContext, value.v);
}

/*
==============
ScrCmd_UseBy
==============
*/
void ScrCmd_UseBy(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v3; 
  const gentity_s *v4; 
  void (__fastcall *use)(gentity_s *, gentity_s *, gentity_s *); 

  Entity = GetEntity(entref);
  v3 = GScr_GetEntity(0);
  v4 = v3;
  if ( Entity->s.eType != ET_TURRET || G_Turret_CanUse(Entity, v3) )
  {
    GScr_AddEntity(v4);
    GScr_Notify(Entity, scr_const.trigger, 1u);
    use = G_Main_GetEntHandlerList(Entity)->use;
    if ( use )
      use(Entity, (gentity_s *)v4, (gentity_s *)v4);
  }
}

/*
==============
ScrCmd_PlaySurfaceSound
==============
*/
void ScrCmd_PlaySurfaceSound(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  const char *v5; 
  const char *String; 
  const char *v7; 
  const SndAliasList *Alias; 
  const char *v9; 
  gentity_s *Entity; 
  const char *v11; 
  unsigned __int16 v12; 
  const char *v13; 
  int v14; 
  const char *v15; 
  gentity_s *v16; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    v7 = Scr_GetString(scrContext, 1u);
    Alias = SND_FindAlias(String);
    if ( Alias )
    {
      Entity = GetEntity(entref);
      if ( Com_IsSoundAliasLooping(Alias) )
      {
        v11 = j_va("'%s' is a looping alias, cannot play a looping surface sound", String);
        Scr_ParamError(COM_ERR_3002, scrContext, 0, v11);
      }
      else
      {
        v12 = G_CStringMP_SoundAliasIndex(String);
        if ( (unsigned __int16)(v12 - 1) > 0x7FFFu )
        {
          v13 = j_va("'%s' does has not have a valid index (%i)", String, v12);
          Scr_ParamError(COM_ERR_3003, scrContext, 0, v13);
        }
        v14 = Com_SurfaceTypeFromName(v7);
        if ( v14 == -1 )
        {
          v15 = j_va("Surface type '%s' does not exist (%s)", v7, String);
          Scr_ParamError(COM_ERR_3004, scrContext, 0, v15);
        }
        else
        {
          v16 = G_Utils_SpawnEventEntity(&Entity->r.currentOrigin, 7);
          v16->s.eventParm = v12 | (v14 << 15);
          v16->s.eventParm2 = 0;
        }
      }
    }
    else
    {
      v9 = j_va("unknown surface sound alias '%s'", String);
      Scr_ParamError(COM_ERR_3001, scrContext, 0, v9);
    }
  }
  else
  {
    NumParam = Scr_GetNumParam(scrContext);
    v5 = j_va("playsurfacesound has %d parameters.  There should be exactly two.", NumParam);
    Scr_Error(COM_ERR_3000, scrContext, v5);
  }
}

/*
==============
ScrCmd_PlayContextSound
==============
*/
void ScrCmd_PlayContextSound(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  unsigned int v5; 
  const char *v6; 
  const char *String; 
  const char *v8; 
  const char *v9; 
  const SndAliasList *Alias; 
  const char *v11; 
  const char *v12; 
  unsigned __int16 v13; 
  const char *v14; 
  int ContextIndex; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  int v19; 
  const char *v20; 
  gentity_s *v21; 
  gentity_s *Entity; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( ((NumParam - 3) & 0xFFFFFFFD) != 0 )
  {
    v5 = Scr_GetNumParam(scrContext);
    v6 = j_va("playcontextsound has %d parameters.  There should be exactly three or five.", v5);
    Scr_Error(COM_ERR_3005, scrContext, v6);
  }
  String = Scr_GetString(scrContext, 0);
  v8 = Scr_GetString(scrContext, 1u);
  v9 = Scr_GetString(scrContext, 2u);
  Alias = SND_FindAlias(String);
  if ( !Alias )
  {
    v11 = j_va("unknown context sound alias '%s'", String);
    Scr_ParamError(COM_ERR_3006, scrContext, 0, v11);
    return;
  }
  Entity = GetEntity(entref);
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v12 = j_va("'%s' is a looping alias, cannot play a looping context sound", String);
    Scr_ParamError(COM_ERR_3007, scrContext, 0, v12);
    return;
  }
  v13 = G_CStringMP_SoundAliasIndex(String);
  if ( (unsigned __int16)(v13 - 1) > 0x7FFFu )
  {
    v14 = j_va("'%s' does has not have a valid index (%i)", String, v13);
    Scr_ParamError(COM_ERR_3008, scrContext, 0, v14);
  }
  ContextIndex = SND_SV_FindContextIndex(v8, v9);
  if ( ContextIndex == -1 )
  {
    v16 = j_va("Sound Context '%s' - '%s' does not exist (%s)", v8, v9, String);
    Scr_ParamError(COM_ERR_3009, scrContext, 0, v16);
    return;
  }
  if ( NumParam == 5 )
  {
    v17 = Scr_GetString(scrContext, 3u);
    v18 = Scr_GetString(scrContext, 4u);
    v19 = SND_SV_FindContextIndex(v17, v18);
    if ( v19 == -1 )
    {
      v20 = j_va("Sound Context '%s' - '%s' does not exist (%s)", v17, v18, String);
      Scr_ParamError(COM_ERR_3010, scrContext, 0, v20);
      return;
    }
  }
  else
  {
    v19 = ContextIndex;
  }
  v21 = G_Utils_SpawnEventEntity(&Entity->r.currentOrigin, 8);
  v21->s.eventParm2 = 0;
  v21->s.eventParm = v13 | ((ContextIndex | (v19 << 8)) << 9);
}

/*
==============
ScrCmd_PlaySound
==============
*/
void ScrCmd_PlaySound(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_entref_t v2; 
  gentity_s *Entity; 
  char v5; 
  gentity_s *v6; 
  const char *String; 
  gentity_s *v8; 
  bitarray_base<bitarray<224> > *v9; 
  unsigned int NumParam; 
  unsigned int v11; 
  const char *v12; 
  gentity_s *v13; 
  __int64 number; 
  const char *v15; 
  scr_entref_t entrefa; 

  v2 = entref;
  entrefa = entref;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1488, ASSERT_TYPE_ASSERT, "( soundSourceEnt )", (const char *)&queryFormat, "soundSourceEnt") )
      __debugbreak();
    v5 = 1;
    entrefa.entnum = Entity->s.number;
    entrefa.entclass = ENTITY_CLASS_GENTITY;
    v2 = entrefa;
  }
  else
  {
    v5 = 0;
  }
  v6 = GetEntity(v2);
  String = Scr_GetString(scrContext, 0);
  v8 = ScrCmd_PlaySoundAtPosInternal(scrContext, &v6->r.currentOrigin, String);
  v9 = (bitarray_base<bitarray<224> > *)v8;
  if ( v5 )
    v8->s.otherEntityNum = entrefa.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  v11 = Scr_GetNumParam(scrContext);
  if ( NumParam <= 3 )
  {
    if ( v11 > 1 && Scr_GetType(scrContext, 1u) )
    {
      v13 = GScr_GetEntity(1u);
      number = (unsigned int)v13->s.number;
      if ( v13->client )
      {
        bitarray_base<bitarray<224>>::setBit(v9 + 1116, number);
      }
      else
      {
        v15 = j_va("entity %i is not a player", number);
        Scr_ObjectError(COM_ERR_6532, scrContext, v15);
      }
    }
  }
  else
  {
    v12 = j_va("Usage: PlaySound( <aliasname>, [ignoreplayer], [soundSourceEntity] ); Wrong number of parameters: %d", v11);
    Scr_Error(COM_ERR_6531, scrContext, v12);
  }
}

/*
==============
ScrCmd_PlayWorldSound
==============
*/
void ScrCmd_PlayWorldSound(scrContext_t *scrContext)
{
  ;
}

/*
==============
ScrCmd_PlaySoundAtViewHeight
==============
*/
void ScrCmd_PlaySoundAtViewHeight(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_EnableAudioPortal
==============
*/
void ScrCmd_EnableAudioPortal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  __int64 brushModel; 
  bool v7; 
  int Int; 
  __int16 otherEntityNum; 
  int v10; 
  float v11; 
  gentity_s *v12; 
  __int64 v13; 
  LerpEntityStateTypeUnion *p_u; 
  const char *v15; 
  __int64 v16; 
  __int64 v17; 
  vec3_t origin; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    v5 = Entity;
    if ( Entity->r.modelType == 4 )
    {
      brushModel = Entity->s.index.brushModel;
      if ( (unsigned int)brushModel >= 0x4000 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1683, ASSERT_TYPE_ASSERT, "(unsigned)( triggerIndex ) < (unsigned)( (16*1024) )", "triggerIndex doesn't index MAX_CLIENT_TRIGGERS\n\t%i not in [0, %i)", Entity->s.index.brushModel, 0x4000) )
        __debugbreak();
      if ( (unsigned int)brushModel < cm.mapEnts->clientTrigger.trigger.count )
      {
        if ( (int)brushModel < 512 )
        {
          v7 = (cm.mapEnts->clientTrigger.trigger.models[brushModel].flags & 0x40) == 0;
          Int = Scr_GetInt(scrContext, 0);
          otherEntityNum = v5->s.otherEntityNum;
          v10 = 0;
          if ( (Int != 0) == v7 )
          {
            if ( otherEntityNum != 2047 )
            {
              GScr_Main_DeleteCommon(scrContext, &g_entities[otherEntityNum]);
              v5->s.otherEntityNum = 2047;
            }
          }
          else if ( otherEntityNum == 2047 )
          {
            v11 = v5->r.currentOrigin.v[1];
            origin.v[0] = v5->r.currentOrigin.v[0];
            origin.v[2] = v5->r.currentOrigin.v[2];
            origin.v[1] = v11;
            SV_Game_KeepPointInPlayableBounds(&origin);
            origin.v[0] = (float)(int)origin.v[0];
            origin.v[2] = (float)(int)origin.v[2];
            origin.v[1] = (float)(int)origin.v[1];
            v12 = G_Utils_SpawnEntity();
            v12->s.eType = ET_SOUND;
            v12->s.lerp.u.anonymous.data[0] = !v7 + 1;
            v12->s.lerp.pos.trType = TR_STATIONARY;
            v12->s.lerp.apos.trType = TR_STATIONARY;
            if ( (unsigned int)brushModel >= 0x200 )
            {
              LODWORD(v17) = 512;
              LODWORD(v16) = brushModel;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1725, ASSERT_TYPE_ASSERT, "(unsigned)( triggerIndex ) < (unsigned)( 512 )", "triggerIndex doesn't index MAX_SOUNDALIASES\n\t%i not in [0, %i)", v16, v17) )
                __debugbreak();
            }
            v12->s.lerp.u.player.torsoPitchPacked = truncate_cast<unsigned short,int>(brushModel);
            G_SetOrigin(v12, &origin, 1, 1);
            SV_LinkEntity(v12);
            v5->s.otherEntityNum = v12->s.number;
          }
          v13 = 0i64;
          p_u = &g_entities->s.lerp.u;
          do
          {
            if ( g_entityIsInUse[v13] && p_u[-3].player.slopePacked == 7 && (unsigned int)(p_u->anonymous.data[0] - 1) <= 1 )
              ++v10;
            ++v13;
            p_u = (LerpEntityStateTypeUnion *)((char *)p_u + 1456);
          }
          while ( v13 < 2048 );
          if ( v10 > 10 )
          {
            v15 = j_va("Changed %i propagation portals states - budget %i", (unsigned int)v10, 10i64);
            StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_PROPAGATION_PORTAL_STATE_CHANGE, 3000, v15, v10);
          }
        }
        else
        {
          Com_PrintError(24, "Can't use trigger index %i, will not fit in replicated structure. Known issue that code will look into\n", (unsigned int)brushModel);
        }
      }
      else
      {
        Scr_Error(COM_ERR_3022, scrContext, "Invalid trigger model index");
      }
    }
    else
    {
      Scr_Error(COM_ERR_3021, scrContext, "This function only supports trigger brush entity types.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3020, scrContext, "EnableAudioPortal: Incorrect number of parameters");
  }
}

/*
==============
GScr_SetSavedDvar
==============
*/
void GScr_SetSavedDvar(scrContext_t *scrContext)
{
  ;
}

/*
==============
ScrCmd_StopSoundChannel
==============
*/
void ScrCmd_StopSoundChannel(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_PlayLoopSound
==============
*/
void ScrCmd_PlayLoopSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  unsigned __int16 v5; 
  ClientBits *p_clientMask; 
  unsigned int v7; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = G_CStringMP_LoopedSoundAliasIndex(String);
  if ( v5 >= 0x200u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2305, ASSERT_TYPE_ASSERT, "(unsigned)( loopSoundIndex ) < (unsigned)( 512 )", "loopSoundIndex doesn't index MAX_SOUNDALIASES\n\t%i not in [0, %i)", v5, 512) )
    __debugbreak();
  if ( v5 )
  {
    Entity->r.svFlags &= ~1u;
    p_clientMask = &Entity->clientMask;
    Entity->s.loopSound = v5;
    v7 = 0;
    while ( p_clientMask->array[0] == -1 )
    {
      ++v7;
      p_clientMask = (ClientBits *)((char *)p_clientMask + 4);
      if ( v7 >= 7 )
      {
        Com_PrintWarning(15, "PlayLoopSound: Entity is hidden to all players, '%s' will not be played\n", String);
        return;
      }
    }
  }
  else
  {
    Com_PrintError(1, "PlayLoopSound: Invalid sound name '%s', not precached (net const strings enforced). Check to make sure 'loop' is set for that alias in the sound alias CSV if it's already sound_precache included.\n", String);
  }
}

/*
==============
ScrCmd_GetNormalHealth
==============
*/
void ScrCmd_GetNormalHealth(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  float v4; 
  gclient_s *client; 
  int health; 
  gagent_s *agent; 
  int maxHealth; 

  Entity = GetEntity(entref);
  v4 = 0.0;
  client = Entity->client;
  if ( client )
  {
    health = Entity->health;
    if ( health )
    {
      Scr_AddFloat(scrContext, (float)health / (float)client->sess.maxHealth);
      return;
    }
  }
  else
  {
    agent = Entity->agent;
    if ( agent )
    {
      maxHealth = agent->maxHealth;
      if ( maxHealth )
      {
        Scr_AddFloat(scrContext, (float)Entity->health / (float)maxHealth);
        return;
      }
    }
    else
    {
      v4 = (float)Entity->health;
    }
  }
  Scr_AddFloat(scrContext, v4);
}

/*
==============
ScrCmd_SetNormalHealth
==============
*/
void ScrCmd_SetNormalHealth(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int maxHealth; 

  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vminss  xmm1, xmm0, cs:__real@3f800000 }
  if ( Entity->client || Entity->agent )
  {
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm3, 1 }
  }
  else
  {
    maxHealth = Entity->maxHealth;
    if ( maxHealth )
      *(float *)&_XMM1 = (float)maxHealth * *(float *)&_XMM1;
  }
  if ( (int)*(float *)&_XMM1 > 0 )
    Entity->health = (int)*(float *)&_XMM1;
  else
    Com_PrintError(23, "ERROR: Cannot setnormalhealth to 0 or below.\n");
}

/*
==============
ScrCmd_Show
==============
*/
void ScrCmd_Show(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3037, scrContext, "Cannot change a 'willNeverChange' entity");
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
  *(_QWORD *)Entity->clientMask.array = 0i64;
  *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
  *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
  Entity->clientMask.array[6] = 0;
}

/*
==============
ScrCmd_Hide
==============
*/
void ScrCmd_Hide(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v3; 
  gentity_s *Entity; 

  v3 = 0;
  Entity = GetEntity(entref);
  if ( Entity->client )
    Scr_Error(COM_ERR_3038, scrContext, "Dont call Hide() on players, use PlayerHide() for that.");
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3039, scrContext, "Cannot change a 'willNeverChange' entity");
  if ( Scr_GetNumParam(scrContext) )
    v3 = Scr_GetInt(scrContext, 0) != 0;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
  if ( !v3 )
  {
    *(_QWORD *)Entity->clientMask.array = -1i64;
    *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
    *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
    Entity->clientMask.array[6] = -1;
  }
}

/*
==============
Scr_ResetSunLight
==============
*/
void Scr_ResetSunLight(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_3135, scrContext, "Incorrect number of parameters\n");
  SV_SetConfigstring(0, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_IsSplitscreen
==============
*/
void Scr_IsSplitscreen(scrContext_t *scrContext)
{
  BOOL v2; 
  unsigned __int8 Byte; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
  {
    Scr_AddInt(scrContext, 0);
  }
  else if ( SV_IsDemoPlaying() )
  {
    Byte = SV_Demo_GetByte();
    Scr_AddInt(scrContext, Byte);
  }
  else if ( SV_Game_IsOnlineGame() || SV_Game_IsSystemLink() )
  {
    Scr_AddInt(scrContext, 0);
    SV_Record_GetByte(0);
  }
  else
  {
    v2 = CL_GetLocalClientActiveCount() > 1;
    Scr_AddInt(scrContext, v2);
    SV_Record_GetByte(v2);
  }
}

/*
==============
Scr_GetSpecies
==============
*/
__int64 Scr_GetSpecies(scrContext_t *scrContext, scr_string_t speciesString)
{
  unsigned int v4; 
  const scr_string_t **v5; 
  const char *String; 
  const char *v7; 

  if ( speciesString == scr_const.all )
    return 2i64;
  v4 = 0;
  v5 = g_AISpeciesNames;
  while ( speciesString != **v5 )
  {
    ++v4;
    if ( (__int64)++v5 >= (__int64)&RDBG_WELCOME_RAW_502 )
    {
      String = Scr_GetString(scrContext, speciesString);
      v7 = j_va("unknown species '%s' (should be human, dog, alien or all)", String);
      Scr_Error(COM_ERR_3302, scrContext, v7);
      return 2i64;
    }
  }
  return v4;
}

/*
==============
GScr_MainSP_IsAI
==============
*/
void GScr_MainSP_IsAI(scrContext_t *scrContext)
{
  unsigned __int64 v2; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (v2 = HIDWORD(*(unsigned __int64 *)&Scr_GetEntityRef(scrContext, 0)), (_BYTE)v2 != 6) && !(_BYTE)v2 && GScr_GetEntity(0)->actor )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_IsGodMode
==============
*/
void GScr_IsGodMode(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (GScr_GetEntity(0)->flags.m_flags[0] & 3) != 0 )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
Scr_GetAIArray
==============
*/
void Scr_GetAIArray(scrContext_t *scrContext)
{
  bitarray<224> *TeamFlags; 
  unsigned int v3; 
  bitarray<224> *p_iTeamFlags; 
  bitarray<224> *AllTeamFlags; 
  actor_s *i; 
  bitarray<224> iTeamFlags; 
  bitarray<224> result; 

  TeamFlags = Scr_GetTeamFlags(&result, scrContext, 0);
  v3 = 0;
  iTeamFlags = *TeamFlags;
  p_iTeamFlags = &iTeamFlags;
  while ( !p_iTeamFlags->array[0] )
  {
    ++v3;
    p_iTeamFlags = (bitarray<224> *)((char *)p_iTeamFlags + 4);
    if ( v3 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllTeamFlags();
      else
        AllTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
      iTeamFlags = *AllTeamFlags;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  for ( i = AIActorInterface::FirstActor(&iTeamFlags); i; i = AIActorInterface::NextActor(i, &iTeamFlags) )
  {
    if ( i->Physics.bIsAlive )
    {
      if ( !i->painDeath.delayedDeath )
      {
        GScr_AddEntity(i->ent);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
Scr_GetAIArrayInRadius
==============
*/
void Scr_GetAIArrayInRadius(scrContext_t *scrContext)
{
  double Float; 
  bitarray<224> *TeamFlags; 
  unsigned int v4; 
  bitarray<224> *p_iTeamFlags; 
  bitarray<224> *AllTeamFlags; 
  actor_s *i; 
  vec3_t vectorValue; 
  bitarray<224> iTeamFlags; 
  bitarray<224> result; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  TeamFlags = Scr_GetTeamFlags(&result, scrContext, 2u);
  v4 = 0;
  iTeamFlags = *TeamFlags;
  p_iTeamFlags = &iTeamFlags;
  while ( !p_iTeamFlags->array[0] )
  {
    ++v4;
    p_iTeamFlags = (bitarray<224> *)((char *)p_iTeamFlags + 4);
    if ( v4 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllTeamFlags();
      else
        AllTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
      iTeamFlags = *AllTeamFlags;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  for ( i = AIActorInterface::FirstActor(&iTeamFlags); i; i = AIActorInterface::NextActor(i, &iTeamFlags) )
  {
    if ( i->Physics.bIsAlive && !i->painDeath.delayedDeath && (float)((float)((float)((float)(vectorValue.v[1] - i->ent->r.currentOrigin.v[1]) * (float)(vectorValue.v[1] - i->ent->r.currentOrigin.v[1])) + (float)((float)(vectorValue.v[0] - i->ent->r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - i->ent->r.currentOrigin.v[0]))) + (float)((float)(vectorValue.v[2] - i->ent->r.currentOrigin.v[2]) * (float)(vectorValue.v[2] - i->ent->r.currentOrigin.v[2]))) <= (float)(*(float *)&Float * *(float *)&Float) )
    {
      GScr_AddEntity(i->ent);
      Scr_AddArray(scrContext);
    }
  }
}

/*
==============
Scr_GetCorpseArray
==============
*/
void Scr_GetCorpseArray(scrContext_t *scrContext)
{
  GameScriptDataSP *GameScriptDataSP; 
  int actorCorpseCount; 
  int v4; 
  int *p_entnum; 
  __int64 v6; 

  Scr_MakeArray(scrContext);
  GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
  actorCorpseCount = level.actorCorpseCount;
  v4 = 0;
  if ( level.actorCorpseCount > 0 )
  {
    p_entnum = &GameScriptDataSP->actorCorpseInfo[0].entnum;
    do
    {
      v6 = *p_entnum;
      if ( (int)v6 > 0 )
      {
        GScr_AddEntity(&g_entities[v6]);
        Scr_AddArray(scrContext);
        actorCorpseCount = level.actorCorpseCount;
      }
      ++v4;
      p_entnum += 12;
    }
    while ( v4 < actorCorpseCount );
  }
}

/*
==============
Scr_GetCorpseArrayInRadius
==============
*/
void Scr_GetCorpseArrayInRadius(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  GameScriptDataSP *GameScriptDataSP; 
  int v5; 
  float *v6; 
  __int64 v7; 
  const dvar_t *v8; 
  const dvar_t *v9; 
  __int64 v10; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float * *(float *)&Float;
  Scr_MakeArray(scrContext);
  GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
  v5 = 0;
  if ( level.actorCorpseCount > 0 )
  {
    v6 = &GameScriptDataSP->actorCorpseInfo[0].physicsOrigin.v[2];
    do
    {
      v7 = *((int *)v6 - 9);
      if ( (int)v7 > 0 )
      {
        v8 = DVARBOOL_ai_corpseSynch;
        if ( !DVARBOOL_ai_corpseSynch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_corpseSynch") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v8);
        if ( !v8->current.enabled || (float)((float)((float)((float)(vectorValue.v[1] - *(v6 - 1)) * (float)(vectorValue.v[1] - *(v6 - 1))) + (float)((float)(vectorValue.v[0] - *(v6 - 2)) * (float)(vectorValue.v[0] - *(v6 - 2)))) + (float)((float)(vectorValue.v[2] - *v6) * (float)(vectorValue.v[2] - *v6))) <= v3 )
        {
          v9 = DVARBOOL_ai_corpseSynch;
          if ( !DVARBOOL_ai_corpseSynch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_corpseSynch") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v9);
          v10 = v7;
          if ( v9->current.enabled || (float)((float)((float)((float)(vectorValue.v[1] - g_entities[v10].r.currentOrigin.v[1]) * (float)(vectorValue.v[1] - g_entities[v10].r.currentOrigin.v[1])) + (float)((float)(vectorValue.v[0] - g_entities[v10].r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - g_entities[v10].r.currentOrigin.v[0]))) + (float)((float)(vectorValue.v[2] - g_entities[v10].r.currentOrigin.v[2]) * (float)(vectorValue.v[2] - g_entities[v10].r.currentOrigin.v[2]))) <= v3 )
          {
            GScr_AddEntity(&g_entities[v10]);
            Scr_AddArray(scrContext);
          }
        }
      }
      ++v5;
      v6 += 12;
    }
    while ( v5 < level.actorCorpseCount );
  }
}

/*
==============
Scr_GetAccuracyFraction
==============
*/

void __fastcall Scr_GetAccuracyFraction(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  const char *WeaponBaseName; 
  const char *v5; 
  double Float; 
  WeapAccuracyType v7; 
  float v8; 
  const dvar_t *v9; 
  double AccuracyFraction; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_2038, scrContext, "GetAccuracyFraction <weapon> <distance> [use player accuracy].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !outWeapon.weaponIdx )
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    v5 = j_va("\"%s\" weapon is not precached", WeaponBaseName);
    Scr_ParamError(COM_ERR_2039, scrContext, 0, v5);
  }
  Float = Scr_GetFloat(scrContext, 1u);
  v7 = WEAP_ACCURACY_AI_VS_AI;
  v8 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) >= 3 )
    LOBYTE(v7) = Scr_GetInt(scrContext, 2u) != 0;
  if ( v7 == WEAP_ACCURACY_AI_VS_PLAYER )
  {
    v9 = DVARFLT_ai_accuracyDistScale;
    if ( !DVARFLT_ai_accuracyDistScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_accuracyDistScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    v8 = *(float *)&Float * v9->current.value;
  }
  AccuracyFraction = AICommonInterface::GetAccuracyFraction(NULL, v8, &outWeapon, v7);
  if ( *(float *)&AccuracyFraction < 0.0 || *(float *)&AccuracyFraction > 1.0 )
  {
    __asm { vxorpd  xmm2, xmm2, xmm2 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 1200, ASSERT_TYPE_SANITY, "( 0.0f ) <= ( accuracy ) && ( accuracy ) <= ( 1.0f )", "accuracy not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", *(float *)&AccuracyFraction, *(double *)&_XMM2, DOUBLE_1_0) )
      __debugbreak();
  }
  Scr_AddFloat(scrContext, *(float *)&AccuracyFraction);
}

/*
==============
Scr_GetSpawner
==============
*/
void Scr_GetSpawner(scrContext_t *scrContext)
{
  bool GenericEnt; 
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 
  scr_string_t v6; 
  unsigned int SpawnerIndex; 
  const char *v8; 
  const char *v9; 

  GenericEnt = 0;
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2040, scrContext, "GetSpawnerStruct() requires two arguments (name, key)");
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset > 0 && (Offset & 0xE000) == 0 )
    GenericEnt = Scr_GetGenericEnt(scrContext, Offset, String, ConstString, 20, "GetSpawner()");
  v6 = SL_ConvertFromString(String);
  SpawnerIndex = G_Spawner_GetSpawnerIndex(v6, ConstString);
  if ( SpawnerIndex != -1 )
  {
    if ( GenericEnt )
    {
      v8 = SL_ConvertToString(ConstString);
      v9 = j_va("GetSpawner() used with more than one entity (\"%s\" = \"%s\")", String, v8);
      Scr_Error(COM_ERR_2041, scrContext, v9);
    }
    if ( !G_Spawner_AddSpawner(SpawnerIndex) )
      Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetSpawnerArray
==============
*/
void Scr_GetSpawnerArray(scrContext_t *scrContext)
{
  unsigned int v1; 
  scr_string_t ConstString; 
  int v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = 0;
  ConstString = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Scr_Error(COM_ERR_2042, scrContext, "GetSpawnerArray must provide 0 arguments or a targetname.");
  if ( Scr_GetNumParam(scrContext) == 1 )
    ConstString = Scr_GetConstString(scrContext, 0);
  Scr_MakeArray(scrContext);
  v4 = 0;
  if ( level.num_entities > 0 )
  {
    v5 = 0i64;
    v6 = 0i64;
    do
    {
      if ( (unsigned int)v4 >= 0x800 )
      {
        LODWORD(v8) = 2048;
        LODWORD(v7) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v6].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v5] && level.gentities[v6].s.eType == ET_ACTOR_SPAWNER && (!ConstString || level.gentities[v6].targetname == ConstString) )
      {
        GScr_AddEntity(&level.gentities[v4]);
        Scr_AddArray(scrContext);
      }
      ++v4;
      ++v5;
      ++v6;
    }
    while ( v4 < level.num_entities );
    v1 = 0;
  }
  if ( cm.mapEnts->spawners.spawnerCount )
  {
    do
    {
      if ( (!ConstString || G_Spawner_GetSpawnerTargetname(v1) == ConstString) && G_Spawner_AddSpawner(v1) )
        Scr_AddArray(scrContext);
      ++v1;
    }
    while ( v1 < cm.mapEnts->spawners.spawnerCount );
  }
}

/*
==============
Scr_GetSpawnerTeamArray
==============
*/
void Scr_GetSpawnerTeamArray(scrContext_t *scrContext)
{
  unsigned int v2; 
  bitarray<224> *p_result; 
  unsigned int v4; 
  int v5; 
  __int64 v6; 
  __int64 v7; 
  unsigned __int64 coverIdx; 
  team_t SpawnerTeam; 
  unsigned __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  bitarray<224> result; 

  Scr_GetTeamFlags(&result, scrContext, 0);
  v2 = 0;
  p_result = &result;
  v4 = 0;
  while ( !p_result->array[0] )
  {
    ++v4;
    p_result = (bitarray<224> *)((char *)p_result + 4);
    if ( v4 >= 7 )
    {
      Scr_Error(COM_ERR_2043, scrContext, "no team was specified - use getspawnerarray instead");
      break;
    }
  }
  Scr_MakeArray(scrContext);
  v5 = 0;
  if ( level.num_entities > 0 )
  {
    v6 = 0i64;
    v7 = 0i64;
    do
    {
      if ( (unsigned int)v5 >= 0x800 )
      {
        LODWORD(v12) = 2048;
        LODWORD(v11) = v5;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v6] && level.gentities[v7].s.eType == ET_ACTOR_SPAWNER )
      {
        coverIdx = level.gentities[v7].c.coverWall.coverIdx;
        if ( (unsigned int)coverIdx >= 0xE0 )
        {
          LODWORD(v12) = 224;
          LODWORD(v11) = level.gentities[v7].c.item[0].ammoCount;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v11, v12) )
            __debugbreak();
        }
        if ( ((0x80000000 >> (coverIdx & 0x1F)) & result.array[coverIdx >> 5]) != 0 )
        {
          GScr_AddEntity(&level.gentities[v5]);
          Scr_AddArray(scrContext);
        }
      }
      ++v5;
      ++v6;
      ++v7;
    }
    while ( v5 < level.num_entities );
    v2 = 0;
  }
  if ( cm.mapEnts->spawners.spawnerCount )
  {
    do
    {
      SpawnerTeam = G_GetSpawnerTeam(v2);
      v10 = (unsigned int)SpawnerTeam;
      if ( (unsigned int)SpawnerTeam >= (TEAM_HUNDRED_NINETY_TWO|TEAM_THIRTY_TWO) )
      {
        LODWORD(v12) = 224;
        LODWORD(v11) = SpawnerTeam;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v11, v12) )
          __debugbreak();
      }
      if ( ((0x80000000 >> (v10 & 0x1F)) & result.array[v10 >> 5]) != 0 && G_Spawner_AddSpawner(v2) )
        Scr_AddArray(scrContext);
      ++v2;
    }
    while ( v2 < cm.mapEnts->spawners.spawnerCount );
  }
}

/*
==============
GScr_GetBrushModelCenter
==============
*/
void GScr_GetBrushModelCenter(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_2044, scrContext, "Depricated - use GetOrigin.\n");
}

/*
==============
GScr_GetKeyBinding
==============
*/
void GScr_GetKeyBinding(scrContext_t *scrContext)
{
  InputContext v2; 
  const char *String; 
  const char *v4; 
  LocalClientNum_t OnlyLocalClientNum; 
  int KeyBinding; 
  char keyNames[128]; 
  char value; 
  char v9[127]; 

  memset_0(keyNames, 0, sizeof(keyNames));
  value = 0;
  memset_0(v9, 0, sizeof(v9));
  v2 = STRUCT_POINTER|FLOAT_POINTER;
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetString(scrContext, 1u) )
  {
    v4 = Scr_GetString(scrContext, 1u);
    v2 = CL_InputContext_FromName(v4);
  }
  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  KeyBinding = CL_Keys_GetKeyBinding(OnlyLocalClientNum, String, (char (*)[128])keyNames, v2);
  Scr_MakeArray(scrContext);
  Scr_AddIString(scrContext, keyNames);
  Scr_AddArrayStringIndexed(scrContext, scr_const.key1);
  Scr_AddIString(scrContext, &value);
  Scr_AddArrayStringIndexed(scrContext, scr_const.key2);
  Scr_AddInt(scrContext, KeyBinding);
  Scr_AddArrayStringIndexed(scrContext, scr_const.count);
}

/*
==============
GScr_GetSticksConfig
==============
*/
void GScr_GetSticksConfig(scrContext_t *scrContext)
{
  int ControllerFromClient; 
  const char *SticksConfig; 
  const char *v4; 

  ControllerFromClient = CL_Mgr_GetControllerFromClient(LOCAL_CLIENT_0);
  if ( ControllerFromClient == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 1424, ASSERT_TYPE_ASSERT, "(controllerIndex != (-1))", (const char *)&queryFormat, "controllerIndex != INVALID_CONTROLLER_PORT") )
    __debugbreak();
  SticksConfig = GamerProfile_GetSticksConfig(ControllerFromClient);
  v4 = (char *)&queryFormat.fmt + 3;
  if ( SticksConfig )
    v4 = SticksConfig;
  Scr_AddString(scrContext, v4);
}

/*
==============
ScrCmd_ForceMovingPlatformEntity
==============
*/
void ScrCmd_ForceMovingPlatformEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  GHandler *Handler; 
  gentity_s *v7; 
  gclient_s *v8; 
  int id; 
  int m_movingPlatformEntity; 
  GHandler *v11; 
  actor_s *actor; 
  const char *v13; 
  ComErrorCode v14; 
  gentity_s *v15; 
  AIActorInterface v16; 
  AIActorInterface *v17; 

  Entity = GetEntity(entref);
  v4 = Entity;
  client = Entity->client;
  if ( client )
  {
    Handler = GHandler::getHandler();
    BGMovingPlatformPS::ClearMoverID(&client->ps.movingPlatforms, &v4->client->ps, Handler);
    v4->client->flags &= ~0x20u;
    if ( Scr_GetType(scrContext, 0) )
    {
      v7 = GScr_GetEntity(0);
      v8 = v4->client;
      id = v7->s.number;
      m_movingPlatformEntity = v8->ps.movingPlatforms.m_movingPlatformEntity;
      v11 = GHandler::getHandler();
      BGMovingPlatformPS::SetMoverEntityID(&v8->ps.movingPlatforms, &v4->client->ps, v11, m_movingPlatformEntity, id, 0, 1);
      v4->client->flags |= 0x20u;
    }
    return;
  }
  actor = Entity->actor;
  if ( !actor )
  {
    v13 = "ForceMovingPlatformEntity can only be called on players or actors";
    v14 = COM_ERR_2046;
    goto LABEL_11;
  }
  AIActorInterface::AIActorInterface(&v16);
  v17 = NULL;
  AIActorInterface::SetActor(&v16, actor);
  v17 = &v16;
  if ( !v16.AIScriptedInterface::m_pAI->Physics.bSpace )
  {
    v13 = "Only Space enabled actors are supported for ForceMovingPlatformEntity";
    v14 = COM_ERR_2045;
LABEL_11:
    Scr_Error(v14, scrContext, v13);
    return;
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v15 = GScr_GetEntity(0);
    v4->actor->Physics.forcedGroundEntNum = truncate_cast<unsigned short,int>(v15->s.number);
  }
  else
  {
    v4->actor->Physics.forcedGroundEntNum = 2047;
  }
}

/*
==============
ScrCmd_SetMovingPlatformTrigger
==============
*/
void ScrCmd_SetMovingPlatformTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Entity->c.trigger.flags |= 1u;
}

/*
==============
ScrCmd_startUsingHeroOnlyLighting
==============
*/
void ScrCmd_startUsingHeroOnlyLighting(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&p_lerp->eFlags, ACTIVE, 0x15u);
}

/*
==============
ScrCmd_stopUsingHeroOnlyLighting
==============
*/
void ScrCmd_stopUsingHeroOnlyLighting(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&p_lerp->eFlags, ACTIVE, 0x15u);
}

/*
==============
ScrCmd_startUsingLessFrequentLighting
==============
*/
void ScrCmd_startUsingLessFrequentLighting(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_stopUsingLessFrequentLighting
==============
*/
void ScrCmd_stopUsingLessFrequentLighting(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_DontCastShadows
==============
*/
void ScrCmd_DontCastShadows(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&p_lerp->eFlags, ACTIVE, 0x14u);
}

/*
==============
ScrCmd_CastShadows
==============
*/
void ScrCmd_CastShadows(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&p_lerp->eFlags, ACTIVE, 0x14u);
}

/*
==============
ScrCmd_DontCastDistantShadows
==============
*/
void ScrCmd_DontCastDistantShadows(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&p_lerp->eFlags, ACTIVE, 0x16u);
}

/*
==============
ScrCmd_CastDistantShadows
==============
*/
void ScrCmd_CastDistantShadows(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&p_lerp->eFlags, ACTIVE, 0x16u);
}

/*
==============
ScrCmd_CastSpotShadows
==============
*/
void ScrCmd_CastSpotShadows(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagStrict(&p_lerp->eFlags, FLAG_COUNT|PRONE);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagStrict(&p_lerp->eFlags, FLAG_COUNT|PRONE);
}

/*
==============
ScrCmd_GetTimeScale
==============
*/
void ScrCmd_GetTimeScale(scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, com_timescale->current.value);
}

/*
==============
ScrCmd_SetTimeScale
==============
*/
void ScrCmd_SetTimeScale(scrContext_t *scrContext)
{
  double Float; 

  Float = Scr_GetFloat(scrContext, 0);
  Dvar_SetFloat_Internal(com_timescale, *(float *)&Float);
}

/*
==============
ScrCmd_TeleportScene
==============
*/
void ScrCmd_TeleportScene(scrContext_t *scrContext)
{
  int v1; 
  __int64 v2; 
  __int64 v3; 
  gclient_s *client; 
  __int64 v5; 
  __int64 v6; 

  v1 = 0;
  if ( level.num_entities > 0 )
  {
    v2 = 0i64;
    v3 = 0i64;
    do
    {
      if ( (unsigned int)v1 >= 0x800 )
      {
        LODWORD(v6) = 2048;
        LODWORD(v5) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v5, v6) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v2].r.isInUse != g_entityIsInUse[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v3] )
      {
        client = g_entities[v2].client;
        if ( client )
          client->ps.eFlags.m_flags[0] ^= 4u;
        else
          g_entities[v2].s.lerp.eFlags.m_flags[0] ^= 4u;
      }
      ++v1;
      ++v3;
      ++v2;
    }
    while ( v1 < level.num_entities );
  }
}

/*
==============
ScrCmd_SetSlowMotionView
==============
*/
void ScrCmd_SetSlowMotionView(scrContext_t *scrContext)
{
  float v2; 
  float v3; 
  double Float; 
  float v5; 
  double v6; 
  double v7; 
  float v8; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2047, scrContext, "SetSlowMotionView requires at least 1 parameter.");
  v2 = FLOAT_1_0;
  v3 = FLOAT_1_0;
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    v6 = Scr_GetFloat(scrContext, 1u);
    v2 = *(float *)&v6;
  }
  if ( Scr_GetNumParam(scrContext) >= 3 )
  {
    v7 = Scr_GetFloat(scrContext, 2u);
    v3 = *(float *)&v7;
  }
  v8 = 1.0 / (float)(v2 - v5);
  g_slowmoCommon.viewType = 0;
  g_slowmoCommon.viewStartMsec = com_frameTime - (int)(float)((float)((float)(v5 - g_slowmoCommon.viewTimescale) * (float)(v3 * -1000.0)) * v8);
  g_slowmoCommon.viewEnable = 1;
  g_slowmoCommon.viewStartTimescale = v5;
  g_slowmoCommon.viewEndTimescale = v2;
  g_slowmoCommon.viewEndMsec = com_frameTime - (int)(float)((float)((float)(v2 - g_slowmoCommon.viewTimescale) * (float)(v3 * -1000.0)) * v8);
}

/*
==============
ScrCmd_SetMovingPlatformPlayerTurnRate
==============
*/
void ScrCmd_SetMovingPlatformPlayerTurnRate(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 
  double Float; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 1880, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( v4->client )
      goto LABEL_10;
    v5 = j_va("entity %i is not a player", entnum);
    Scr_ObjectError(COM_ERR_3680, scrContext, v5);
  }
  if ( !v4->client )
  {
    Scr_ParamError(COM_ERR_2050, scrContext, 0, "Moving platform turn rates can only be set on clients.");
    return;
  }
LABEL_10:
  if ( Scr_GetNumParam(scrContext) )
  {
    client = v4->client;
    Float = Scr_GetFloat(scrContext, 0);
    if ( !Com_GameMode_SupportsFeature(WEAPON_SLIDE|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\movingplatforms\\bg_moving_platform_ps.h", 70, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::MOVING_PLATFORM_TURN_RATE ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::MOVING_PLATFORM_TURN_RATE )") )
      __debugbreak();
    client->ps.movingPlatforms.m_movingPlatformTurnRate = *(float *)&Float;
  }
  else
  {
    Scr_ParamError(COM_ERR_2051, scrContext, 0, "Rate not set.");
  }
}

/*
==============
ScrCmd_TeleportEntityRelative
==============
*/
void ScrCmd_TeleportEntityRelative(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  Vehicle *vehicle; 
  Vehicle *v8; 
  actor_s *actor; 
  actor_s *v10; 
  actor_s *v11; 
  vec3_t angles; 
  tmat43_t<vec3_t> result; 
  tmat43_t<vec3_t> v14; 
  tmat43_t<vec3_t> out; 
  tmat43_t<vec3_t> in1; 

  Sys_ProfBeginNamedEvent(0xFFFF0000, "ScrCmd_TeleportEntityRelative");
  Entity = GetEntity(entref);
  if ( Entity->tagInfo )
  {
    Scr_Error(COM_ERR_2052, scrContext, "Trying to relative teleport entity that is linked to parent. Please teleport parent instead.");
  }
  else
  {
    v5 = GScr_GetEntity(0);
    v6 = GScr_GetEntity(1u);
    AnglesAndOriginToMatrix43(&v5->r.currentAngles, &v5->r.currentOrigin, &result);
    MatrixInverseOrthogonal43(&result, &out);
    AnglesAndOriginToMatrix43(&Entity->r.currentAngles, &Entity->r.currentOrigin, &result);
    MatrixMultiply43(&result, &out, &in1);
    AnglesAndOriginToMatrix43(&v6->r.currentAngles, &v6->r.currentOrigin, &result);
    MatrixMultiply43(&in1, &result, &v14);
    AxisToAngles((const tmat33_t<vec3_t> *)&v14, &angles);
    G_SetOriginAndAngle(Entity, &v14.m[3], &angles, 1, 1);
    vehicle = Entity->vehicle;
    if ( vehicle )
    {
      vehicle->phys.origin.v[0] = Entity->r.currentOrigin.v[0];
      vehicle->phys.origin.v[1] = Entity->r.currentOrigin.v[1];
      vehicle->phys.origin.v[2] = Entity->r.currentOrigin.v[2];
      v8 = Entity->vehicle;
      v8->phys.angles.v[0] = Entity->r.currentAngles.v[0];
      v8->phys.angles.v[1] = Entity->r.currentAngles.v[1];
      v8->phys.angles.v[2] = Entity->r.currentAngles.v[2];
    }
    actor = Entity->actor;
    if ( actor )
    {
      actor->Physics.bHasInited = 0;
      Entity->actor->Physics.groundEntNum = truncate_cast<unsigned short,int>(v6->s.number);
      v10 = Entity->actor;
      v10->Physics.vPrevGroundOrigin.v[0] = v6->r.currentOrigin.v[0];
      v10->Physics.vPrevGroundOrigin.v[1] = v6->r.currentOrigin.v[1];
      v10->Physics.vPrevGroundOrigin.v[2] = v6->r.currentOrigin.v[2];
      v11 = Entity->actor;
      v11->Physics.vPrevGroundAngles.v[0] = v6->r.currentAngles.v[0];
      v11->Physics.vPrevGroundAngles.v[1] = v6->r.currentAngles.v[1];
      v11->Physics.vPrevGroundAngles.v[2] = v6->r.currentAngles.v[2];
    }
    SV_LinkEntity(Entity);
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
ScrCmd_dospawn
==============
*/
void ScrCmd_dospawn(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_SpawnInternal(scrContext, entref, CHECK_SPAWN, "DoSpawn");
}

/*
==============
ScrCmd_StalingradSpawn
==============
*/
void ScrCmd_StalingradSpawn(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_SpawnInternal(scrContext, entref, FORCE_SPAWN, "StalingradSpawn");
}

/*
==============
ScrCmd_DoSpawnAiType
==============
*/
void ScrCmd_DoSpawnAiType(scrContext_t *scrContext)
{
  enumForceSpawn v1; 
  int spawnFlags; 
  scr_string_t ConstString; 
  const gentity_s *v5; 
  vec3_t angles; 
  vec3_t vectorValue; 

  v1 = CHECK_SPAWN;
  spawnFlags = 0;
  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &angles);
  if ( Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) )
    v1 = FORCE_SPAWN;
  if ( Scr_GetNumParam(scrContext) >= 5 && Scr_GetInt(scrContext, 4u) )
    spawnFlags = 8;
  if ( Scr_GetNumParam(scrContext) >= 6 && !Scr_GetInt(scrContext, 5u) )
    spawnFlags |= 0x10u;
  v5 = G_ActorSP_SpawnActorFromAitype(ConstString, &vectorValue, &angles, v1, spawnFlags);
  if ( v5 )
    GScr_AddEntity(v5);
}

/*
==============
ScrCmd_MagicGrenade
==============
*/
void ScrCmd_MagicGrenade(scrContext_t *scrContext)
{
  __int64 v2; 
  ComErrorCode v3; 
  const char *String; 
  const char *v5; 
  int shouldThrow; 
  bool bSticky; 
  double Float; 
  int grenadeTime; 
  const gentity_s *v10; 
  bool outIsAlternate; 
  vec3_t vTargetPos; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_2055, scrContext, "MagicGrenade <grenade type> <origin> <target position> [time to blow (seconds)] [should throw].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  LOWORD(v2) = outWeapon.weaponIdx;
  if ( outWeapon.weaponIdx )
  {
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
      __debugbreak();
    v2 = (unsigned __int16)v2;
    if ( !bg_weaponDefs[(unsigned __int16)v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    shouldThrow = 1;
    bSticky = bg_weaponDefs[v2]->stickiness != WEAPSTICKINESS_NONE;
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 2u, &vTargetPos);
    if ( Scr_GetNumParam(scrContext) < 4 )
    {
      grenadeTime = 5000;
    }
    else
    {
      Float = Scr_GetFloat(scrContext, 3u);
      grenadeTime = (int)(float)(*(float *)&Float * 1000.0);
    }
    if ( Scr_GetNumParam(scrContext) == 5 )
      shouldThrow = Scr_GetInt(scrContext, 4u);
    v10 = MagicGrenade_Internal(NULL, NULL, &vectorValue, &vTargetPos, &outWeapon, grenadeTime, shouldThrow, bSticky);
    if ( v10 )
      GScr_AddEntity(v10);
    else
      Scr_AddUndefined(scrContext);
  }
  else
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v3 = COM_ERR_2056;
      String = Scr_GetString(scrContext, 0);
      v5 = j_va("\"%s\" grenade weapon is not precached", String);
    }
    else
    {
      v3 = COM_ERR_2057;
      v5 = "Invalid grenade weapon for MagicGrenade";
    }
    Scr_ParamError(v3, scrContext, 0, v5);
  }
}

/*
==============
Scr_BulletTracer
==============
*/
void Scr_BulletTracer(scrContext_t *scrContext)
{
  unsigned int v2; 
  gentity_s *v3; 
  const char *v4; 
  GWeaponMap *Instance; 
  bool outIsAlternate; 
  Weapon result; 
  vec3_t v8; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &v8);
  v2 = 0;
  v3 = G_Utils_SpawnEventEntity(&vectorValue, 92);
  v3->s.eventParm2 = 0;
  v3->s.lerp.u.turret.gunAngles = v8;
  if ( Scr_GetNumParam(scrContext) >= 3 && Scr_GetType(scrContext, 2u) )
  {
    GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
    if ( !outWeapon.weaponIdx )
    {
      v4 = j_va("BulletTracer called with unknown weapon\n");
      Scr_Error(COM_ERR_2058, scrContext, v4);
    }
  }
  else
  {
    if ( bg_defaultWeaponIndex >= 0x226 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2275, ASSERT_TYPE_SANITY, "(unsigned)( bg_defaultWeaponIndex ) < (unsigned)( 550 )", "bg_defaultWeaponIndex doesn't index MAX_WEAPONS\n\t%i not in [0, %i)", bg_defaultWeaponIndex, 550) )
      __debugbreak();
    if ( bg_defaultWeaponIndex != (unsigned __int16)*(_DWORD *)&GScr_Main_GetWeaponForName(&result, scrContext, "defaultweapon")->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2276, ASSERT_TYPE_ASSERT, "( bg_defaultWeaponIndex == GScr_Main_GetWeaponForName( scrContext, \"defaultweapon\" ).weaponIdx )", (const char *)&queryFormat, "bg_defaultWeaponIndex == GScr_Main_GetWeaponForName( scrContext, DEFAULT_WEAPON ).weaponIdx") )
      __debugbreak();
    memset(&outWeapon, 0, 48);
    *(double *)&outWeapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
    *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    outWeapon.weaponIdx = truncate_cast<unsigned short,unsigned int>(bg_defaultWeaponIndex);
  }
  Instance = GWeaponMap::GetInstance();
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  Instance->SetWeapon(Instance, &v3->s.weaponHandle, &outWeapon);
  if ( Scr_GetNumParam(scrContext) >= 4 )
    LOBYTE(v2) = Scr_GetInt(scrContext, 3u) != 0;
  v3->s.eventParm = v2;
}

/*
==============
Scr_RemoveFromMovingPlatformSystem
==============
*/
void Scr_RemoveFromMovingPlatformSystem(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagStrict(&p_lerp->eFlags, DEAD|AIM_ASSIST);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagStrict(&p_lerp->eFlags, DEAD|AIM_ASSIST);
}

/*
==============
ScrCmd_PlayExplosionSound
==============
*/
void ScrCmd_PlayExplosionSound(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *String; 
  const char *v5; 
  const SndAliasList *Alias; 
  const SndAliasList *v7; 
  const char *v8; 
  const char *v9; 
  unsigned int id; 
  gentity_s *Entity; 
  __int64 number; 
  char *fmt; 
  char dest[128]; 

  String = Scr_GetString(scrContext, 0);
  if ( !*String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2626, ASSERT_TYPE_ASSERT, "(soundName[0])", (const char *)&queryFormat, "soundName[0]") )
    __debugbreak();
  v5 = Scr_GetString(scrContext, 1u);
  Alias = SND_TryFindAlias(String);
  v7 = Alias;
  if ( Alias )
  {
    if ( Com_IsSoundAliasLooping(Alias) )
    {
      v9 = j_va("'%s' is a looping alias, use 'playloopsound' instead", String);
      Scr_ParamError(COM_ERR_2067, scrContext, 0, v9);
    }
    else
    {
      id = v7->head->id;
      Entity = GetEntity(entref);
      LODWORD(fmt) = id;
      number = (unsigned int)Entity->s.number;
      Entity->r.svFlags &= ~1u;
      Com_sprintf(dest, 0x80ui64, "sndexp %d %x %s", number, fmt, v5);
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
    }
  }
  else
  {
    v8 = j_va("unknown sound alias '%s'", String);
    Scr_ParamError(COM_ERR_2066, scrContext, 0, v8);
  }
}

/*
==============
ScrCmd_PlayEquipMoveSound
==============
*/
void ScrCmd_PlayEquipMoveSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  EquipmentMoveType_t EquipmentMoveType; 
  const WeaponDef *v6; 
  gclient_s *client; 
  unsigned __int8 v8; 
  unsigned __int8 v9; 
  unsigned int v10; 
  __int64 v11; 
  bool outIsAlternate; 
  AICommonWrapper v13; 
  Weapon outWeapon; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  EquipmentMoveType = BG_GetEquipmentMoveType(String);
  if ( EquipmentMoveType != EQUIPMENT_MOVE_TYPE_INVALID )
  {
    GScr_Main_GetWeaponParam(scrContext, 1u, &outWeapon, &outIsAlternate);
    if ( outWeapon.weaponIdx )
    {
      v6 = BG_WeaponDef(&outWeapon, outIsAlternate);
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2696, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      if ( v6->sfxPackage )
      {
        client = Entity->client;
        if ( client )
        {
          v8 = truncate_cast<unsigned char,signed char>(client->ps.clothType);
        }
        else
        {
          AICommonWrapper::AICommonWrapper(&v13, Entity);
          if ( !v13.m_pAI )
          {
            v9 = 0;
LABEL_15:
            v10 = BG_PackEquipSoundEventParam(MOVEMENT_LEAD_TYPE_PRE, v9, v6->sfxPackage->rattleSoundType, EquipmentMoveType);
            G_Utils_AddEvent(Entity, 5u, v10);
            return;
          }
          v8 = v13.m_pAI->GetClothType(v13.m_pAI);
        }
        v9 = v8;
        if ( v8 >= 0x10u )
        {
          LODWORD(v11) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2721, ASSERT_TYPE_ASSERT, "(unsigned)( clothType ) < (unsigned)( ( 1 << 4 ) )", "clothType doesn't index MAX_CLOTH_TYPE\n\t%i not in [0, %i)", v11, 16) )
            __debugbreak();
        }
        goto LABEL_15;
      }
    }
  }
}

/*
==============
ScrCmd_PlayClothMoveSound
==============
*/
void ScrCmd_PlayClothMoveSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  EquipmentMoveType_t EquipmentMoveType; 
  int Int; 
  MovementLeadType_t v7; 
  gclient_s *client; 
  unsigned __int8 v9; 
  unsigned __int8 v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 
  AICommonWrapper v14; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  EquipmentMoveType = BG_GetEquipmentMoveType(String);
  if ( EquipmentMoveType != EQUIPMENT_MOVE_TYPE_INVALID )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v7 = Int;
    if ( (unsigned int)(Int - 1) > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2758, ASSERT_TYPE_ASSERT, "( MOVEMENT_LEAD_TYPE_PRE ) <= ( leadType ) && ( leadType ) <= ( MOVEMENT_LEAD_TYPE_COUNT )", "leadType not in [MOVEMENT_LEAD_TYPE_PRE, MOVEMENT_LEAD_TYPE_COUNT]\n\t%i not in [%i, %i]", Int, 1, 2) )
      __debugbreak();
    client = Entity->client;
    if ( client )
    {
      v9 = truncate_cast<unsigned char,signed char>(client->ps.clothType);
    }
    else
    {
      AIActorInterface::AIActorInterface(&v14.m_actorInterface);
      AIAgentInterface::AIAgentInterface(&v14.m_newAgentInterface);
      v14.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      AICommonInterface::AICommonInterface(&v14.m_botInterface);
      v14.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
      AICommonInterface::AICommonInterface(&v14.m_botAgentInterface);
      v14.m_pAI = NULL;
      v14.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
      AICommonWrapper::Setup(&v14, Entity);
      if ( !v14.m_pAI )
      {
        v10 = 0;
LABEL_13:
        v11 = BG_PackEquipSoundEventParam(v7, v10, 0, EquipmentMoveType);
        G_Utils_AddEvent(Entity, 6u, v11);
        return;
      }
      v9 = v14.m_pAI->GetClothType(v14.m_pAI);
    }
    v10 = v9;
    if ( v9 >= 0x10u )
    {
      LODWORD(v13) = 16;
      LODWORD(v12) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2778, ASSERT_TYPE_ASSERT, "(unsigned)( clothType ) < (unsigned)( ( 1 << 4 ) )", "clothType doesn't index MAX_CLOTH_TYPE\n\t%i not in [0, %i)", v12, v13) )
        __debugbreak();
    }
    goto LABEL_13;
  }
}

/*
==============
ScrCmd_IsWaitingOnSound
==============
*/
void ScrCmd_IsWaitingOnSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Scr_AddInt(scrContext, Entity->snd_wait.notifyString != 0);
}

/*
==============
GScr_MainSP_EntityWillNeverChange
==============
*/
void GScr_MainSP_EntityWillNeverChange(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_Show
==============
*/
void ScrCmd_Show(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_Hide
==============
*/
void ScrCmd_Hide(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_ShowOnClient
==============
*/
void ScrCmd_ShowOnClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  if ( !v4->client )
    Scr_Error(COM_ERR_2091, scrContext, "Must be called with a player.");
  if ( v4->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 3417, ASSERT_TYPE_ASSERT, "(player->s.number == 0)", (const char *)&queryFormat, "player->s.number == 0") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_HideOnClient
==============
*/
void ScrCmd_HideOnClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  if ( !v4->client )
    Scr_Error(COM_ERR_2092, scrContext, "Must be called with a player.");
  if ( v4->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 3443, ASSERT_TYPE_ASSERT, "(player->s.number == 0)", (const char *)&queryFormat, "player->s.number == 0") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_LaserForceOn
==============
*/
void ScrCmd_LaserForceOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x13u);
  client = Entity->client;
  if ( client )
  {
    p_eFlags = &client->ps.eFlags;
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 0x13u);
  }
}

/*
==============
ScrCmd_LaserForceOff
==============
*/
void ScrCmd_LaserForceOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x13u);
  client = Entity->client;
  if ( client )
  {
    p_eFlags = &client->ps.eFlags;
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0x13u);
  }
}

/*
==============
Scr_SetStableMissile
==============
*/
void Scr_SetStableMissile(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int eType; 
  int v6; 
  int v7; 
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *p_flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  eType = (unsigned __int16)Entity->s.eType;
  v6 = Int;
  if ( (unsigned __int16)eType > 0x13u || (v7 = 540674, !_bittest(&v7, eType)) )
    Scr_Error(COM_ERR_2093, scrContext, "Type should be a sentient or a vehicle");
  p_flags = &Entity->flags;
  if ( v6 )
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::SetFlagInternal(p_flags, ACTIVE, 0xEu);
  else
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(p_flags, ACTIVE, 0xEu);
}

/*
==============
GScr_TurretSP_SetMode
==============
*/
void GScr_TurretSP_SetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2094, scrContext, v6);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.manual )
  {
    G_Turret_SetMode(v4, 0);
  }
  else if ( ConstString == scr_const.manual_ai )
  {
    G_Turret_SetMode(v4, 0x8000);
  }
  else if ( ConstString == scr_const.auto_nonai )
  {
    G_Turret_SetMode(v4, 4);
  }
  else if ( ConstString == scr_const.auto_ai )
  {
    G_Turret_SetMode(v4, 32772);
  }
  else if ( ConstString == scr_const.manual_target )
  {
    Scr_ParamError(COM_ERR_2095, scrContext, 0, "'manual_target' is not support in SP");
  }
  else if ( ConstString == scr_const.sentry )
  {
    G_Turret_SetMode(v4, 12);
  }
  else if ( ConstString == scr_const.sentry_offline )
  {
    G_Turret_SetMode(v4, 1032);
  }
  else
  {
    Scr_Error(COM_ERR_2096, scrContext, "Error setting the mode of a turret.\n");
  }
}

/*
==============
GScr_TurretSP_GetMode
==============
*/
void GScr_TurretSP_GetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  int flags; 
  scr_string_t manual_ai; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2097, scrContext, v6);
  }
  flags = GTurret::GetTurret(p_turretHandle)->m_data.flags;
  if ( (flags & 0xC) == 12 )
  {
    Scr_AddConstString(scrContext, scr_const.sentry);
  }
  else if ( (flags & 0x408) == 1032 )
  {
    Scr_AddConstString(scrContext, scr_const.sentry_offline);
  }
  else if ( (flags & 0x8004) == 32772 )
  {
    Scr_AddConstString(scrContext, scr_const.auto_ai);
  }
  else if ( (flags & 4) != 0 )
  {
    Scr_AddConstString(scrContext, scr_const.auto_nonai);
  }
  else
  {
    manual_ai = scr_const.manual_ai;
    if ( (flags & 0x8000) == 0 )
      manual_ai = scr_const.manual;
    Scr_AddConstString(scrContext, manual_ai);
  }
}

/*
==============
GScr_TurretSP_GetAim
==============
*/
void GScr_TurretSP_GetAim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2098, scrContext, v6);
  }
  Scr_AddVector(scrContext, v4->s.lerp.u.turret.gunAngles.v);
}

/*
==============
GScr_SetTurretIgnoreGoals
==============
*/
void GScr_SetTurretIgnoreGoals(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2099, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xFF7FFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x800000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_SetTurretAlwaysManned
==============
*/
void GScr_SetTurretAlwaysManned(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2100, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xFDFFFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x2000000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_SetTurretHoldStill
==============
*/
void GScr_SetTurretHoldStill(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2101, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xFBFFFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x4000000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_SetTurretLockedOn
==============
*/
void GScr_SetTurretLockedOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2102, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xF7FFFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x8000000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_TurretSP_SetCanAIDetach
==============
*/
void GScr_TurretSP_SetCanAIDetach(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurretSP *Turret; 
  int Int; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2103, scrContext, v6);
  }
  if ( (_BYTE)GTurret::ms_allocatedType != HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_turret_sp.h", 76, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  Turret = (GTurretSP *)GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  GTurretSP::SetCanAIDetach(Turret, Int);
}

/*
==============
GScr_TurretSP_SetAiSpread
==============
*/
void GScr_TurretSP_SetAiSpread(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  double Float; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2104, scrContext, v6);
  }
  if ( (_BYTE)GTurret::ms_allocatedType != HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_turret_sp.h", 76, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  *(float *)&Turret[1].m_inuse = *(float *)&Float;
}

/*
==============
GScr_TurretSP_SetSuppressionTime
==============
*/
void GScr_TurretSP_SetSuppressionTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  double Float; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2105, scrContext, v6);
  }
  if ( (_BYTE)GTurret::ms_allocatedType != HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_turret_sp.h", 76, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  LODWORD(Turret[1].__vftable) = (int)(float)(*(float *)&Float * 1000.0);
}

/*
==============
GScr_TurretSP_SetFov
==============
*/
void GScr_TurretSP_SetFov(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  GWeaponMap *Instance; 
  const Weapon *Weapon; 
  const WeaponDef *v9; 
  const char *v10; 
  double Float; 
  int number; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  gentity_s *v16; 
  const char *v17; 
  const char *v18; 
  unsigned int clientNum; 
  SvClient *CommonClient; 
  __int64 v21; 
  __int64 v22; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_2106, scrContext, v6);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2107, scrContext, "usage: SetTurretFov( <fov> )\n");
  Instance = GWeaponMap::GetInstance();
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  Weapon = BgWeaponMap::GetWeapon(Instance, v4->s.weaponHandle);
  v9 = BG_WeaponDef(Weapon, 0);
  if ( BG_GetWeaponClass(Weapon, 0) != WEAPCLASS_TURRET )
  {
    v10 = j_va("SetTurretFov: weapon isn't a turret.");
    Scr_Error(COM_ERR_2108, scrContext, v10);
  }
  if ( BG_GetOverlay(Weapon, 0)->shaderMat || v9->overlayInterface == WEAPOVERLAYINTERFACE_TURRETSCOPE )
  {
    if ( EntHandle::isDefined(&v4->r.ownerNum) )
    {
      Float = Scr_GetFloat(scrContext, 0);
      number = v4->r.ownerNum.number;
      if ( (unsigned int)(number - 1) >= 0x7FF )
      {
        LODWORD(v21) = number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v21, 2047) )
          __debugbreak();
      }
      v13 = v4->r.ownerNum.number;
      if ( (unsigned int)(v13 - 1) >= 0x800 )
      {
        LODWORD(v22) = 2048;
        LODWORD(v21) = v13 - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v21, v22) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v14 = v13 - 1;
      if ( g_entities[v14].r.isInUse != g_entityIsInUse[v14] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v14] )
      {
        LODWORD(v22) = v4->r.ownerNum.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v22) )
          __debugbreak();
      }
      v15 = v4->r.ownerNum.number;
      v16 = &g_entities[v15 - 1];
      if ( (&g_entities[v15] == (gentity_s *)1456 || !v16->client) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 3848, ASSERT_TYPE_ASSERT, "(player && player->client)", (const char *)&queryFormat, "player && player->client") )
        __debugbreak();
      v17 = j_va("%s %f", "set_turret_fov", *(float *)&Float);
      v18 = v17;
      clientNum = v16->client->ps.clientNum;
      if ( clientNum == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v17);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(clientNum);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v18);
      }
    }
    else
    {
      Com_PrintWarning(23, "Warning: SetTurretFov cannot set the FOV of an unmanned turret.");
    }
  }
  else
  {
    Com_PrintWarning(23, "Warning: SetTurretFov cannot set the FOV of a non-scoped turret.");
  }
}

/*
==============
ScrCmd_LerpFOV
==============
*/
void ScrCmd_LerpFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const char *v8; 
  const char *v9; 
  unsigned int clientNum; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 3871, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2109, scrContext, "LerpFOV is not supported in this gamemode");
  if ( (int)Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_2110, scrContext, "Not enough parameters.\n");
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm6, xmm0, xmm4, 1 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  v8 = j_va("%s %f %d", "set_lerp_fov", *(float *)&_XMM0, (unsigned int)(int)*(float *)&_XMM6);
  v9 = v8;
  clientNum = v4->client->ps.clientNum;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v9);
  }
}

/*
==============
ScrCmd_ModifyBaseFOV
==============
*/
void ScrCmd_ModifyBaseFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const char *v8; 
  const char *v9; 
  unsigned int clientNum; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 3901, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2111, scrContext, "ModifyBaseFOV is not supported in this gamemode");
  if ( (int)Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_2112, scrContext, "Not enough parameters.\n");
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm6, xmm0, xmm4, 1 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  v8 = j_va("%s %f %d", "set_base_fov", *(float *)&_XMM0, (unsigned int)(int)*(float *)&_XMM6);
  v9 = v8;
  clientNum = v4->client->ps.clientNum;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v9);
  }
}

/*
==============
ScrCmd_SetViewmodelDepth
==============
*/
void ScrCmd_SetViewmodelDepth(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  if ( !Com_GetServerDObjForEnt(Entity) )
    Scr_Error(COM_ERR_2113, scrContext, "SetViewModelDepth can only be used for entities with models.");
  Int = Scr_GetInt(scrContext, 0);
  p_eFlags = &Entity->s.lerp.eFlags;
  if ( Int )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagStrict(p_eFlags, TAKE_DAMAGE|AIM_ASSIST);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagStrict(p_eFlags, TAKE_DAMAGE|AIM_ASSIST);
}

/*
==============
GScr_MakeEntityDrone
==============
*/
void GScr_MakeEntityDrone(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SCRIPTMOVER || (Entity->flags.m_flags[0] & 0x80000000) == 0 )
    Scr_Error(COM_ERR_2114, scrContext, "makeFakeAI must be applied to a script_model");
  InitDroneEntity(v4);
  SV_LinkEntity(v4);
}

/*
==============
GScr_SpawnDrone
==============
*/
void GScr_SpawnDrone(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  gentity_s *Entity; 
  gentity_s *v6; 
  const char *v7; 
  const char *v8; 
  scr_string_t targetname; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const gentity_s *v13; 
  spawner_t *Spawner; 
  EntityClass entclass; 

  entclass = entref.entclass;
  ConstString = 0;
  if ( Scr_GetNumParam(scrContext) >= 2 )
    ConstString = Scr_GetConstString(scrContext, 1u);
  if ( entclass )
  {
    if ( entclass != ENTITY_CLASS_SPAWNER )
      return;
    Spawner = G_GetSpawner(entref);
    v13 = SpawnDroneFromSpawner(Spawner, ConstString);
  }
  else
  {
    Entity = GetEntity(entref);
    v6 = Entity;
    if ( Entity->s.eType != ET_ACTOR_SPAWNER )
    {
      v7 = vtos(&Entity->r.currentOrigin);
      v8 = SL_ConvertToString(v6->classname);
      targetname = v6->targetname;
      v10 = v8;
      if ( targetname )
        v11 = SL_ConvertToString(targetname);
      else
        v11 = "<unnamed>";
      v12 = j_va("spawnDrone can only be called on actor spawners\nattempted to call spawnDrone on entity with name '%s' of type '%s' at (%s)\n", v11, v10, v7);
      Scr_Error(COM_ERR_2115, scrContext, v12);
    }
    v13 = SpawnDroneFromEnt(v6, ConstString);
  }
  if ( v13 )
    GScr_AddEntity(v13);
}

/*
==============
GScr_SetCorpseRemoveTimer
==============
*/
void GScr_SetCorpseRemoveTimer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_ACTOR_CORPSE )
    Scr_Error(COM_ERR_2116, scrContext, "SetCorpseRemoveTimer must be called on a corpse");
  Float = Scr_GetFloat(scrContext, 0);
  Entity->c.item[0].clipAmmoCount[1] = level.time - (int)(float)(*(float *)&Float * -1000.0);
}

/*
==============
GScr_GetCorpsePhysicsOrigin
==============
*/
void GScr_GetCorpsePhysicsOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  GameScriptDataSP *GameScriptDataSP; 
  gentity_s *Entity; 
  const dvar_t *v6; 
  int ActorCorpseIndex; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  float value[4]; 

  GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_ACTOR_CORPSE )
  {
    v6 = DVARBOOL_ai_corpseSynch;
    if ( !DVARBOOL_ai_corpseSynch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_corpseSynch") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    if ( v6->current.enabled )
    {
      ActorCorpseIndex = G_GetActorCorpseIndex(Entity);
      v8 = ActorCorpseIndex;
      if ( (unsigned int)ActorCorpseIndex >= 0x1C )
      {
        LODWORD(v10) = 28;
        LODWORD(v9) = ActorCorpseIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4070, ASSERT_TYPE_ASSERT, "(unsigned)( corpseIndex ) < (unsigned)( ( sizeof( *array_counter( gScrData->actorCorpseInfo ) ) + 0 ) )", "corpseIndex doesn't index ARRAY_COUNT( gScrData->actorCorpseInfo )\n\t%i not in [0, %i)", v9, v10) )
          __debugbreak();
      }
      value[0] = GameScriptDataSP->actorCorpseInfo[v8].physicsOrigin.v[0];
      value[1] = GameScriptDataSP->actorCorpseInfo[v8].physicsOrigin.v[1];
      value[2] = GameScriptDataSP->actorCorpseInfo[v8].physicsOrigin.v[2];
      Scr_AddVector(scrContext, value);
    }
    else
    {
      Scr_Error(COM_ERR_2118, scrContext, "GetCorpsePhysicsOrigin must be called when dvar ai_corpseSynch enabled");
      Scr_AddUndefined(scrContext);
    }
  }
  else
  {
    Scr_Error(COM_ERR_2117, scrContext, "GetCorpsePhysicsOrigin must be called on a corpse");
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_SetLookatText
==============
*/
void GScr_SetLookatText(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  scr_string_t ConstIString; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4096, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_SetString(&Entity->lookAtText0, ConstString);
  if ( Scr_GetNumParam(scrContext) )
  {
    ConstIString = Scr_GetConstIString(scrContext, 1u);
    Scr_SetString(&Entity->lookAtText1, ConstIString);
  }
}

/*
==============
GScr_SetCalloutText
==============
*/
void GScr_SetCalloutText(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4124, ASSERT_TYPE_ASSERT, "(playerEnt)", (const char *)&queryFormat, "playerEnt") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_2119, scrContext, "Too few arguments\n");
  if ( !Entity->client )
    Scr_Error(COM_ERR_2120, scrContext, "Must be called on a client entity.\n");
  if ( Entity->s.number != SvClientSP::GetSpClientNum() )
    Scr_Error(COM_ERR_2121, scrContext, "Non local players are not supported for this call.\n");
  Scr_GetConstIString(scrContext, 0);
  Scr_GetInt(scrContext, 1u);
}

/*
==============
GScr_SetSpawnerTeam
==============
*/
void GScr_SetSpawnerTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t v4; 
  gentity_s *Entity; 
  const char *v6; 
  const char *v7; 
  team_t *p_team; 
  scr_string_t ConstString; 
  scr_string_t v10; 
  const char *v11; 
  const char *v12; 

  if ( entref.entclass )
  {
    if ( entref.entclass == ENTITY_CLASS_SPAWNER )
    {
      p_team = &G_GetSpawner(entref)->team;
      ConstString = Scr_GetConstString(scrContext, 0);
      if ( !Com_Teams_TeamFromString(ConstString, p_team) )
      {
        v10 = Scr_GetConstString(scrContext, 0);
        v11 = SL_ConvertToString(v10);
        v12 = j_va("unknown team '%s'", v11);
        Scr_Error(COM_ERR_2124, scrContext, v12);
      }
    }
  }
  else
  {
    v4 = Scr_GetConstString(scrContext, 0);
    Entity = GetEntity(entref);
    if ( Entity->s.eType != ET_ACTOR_SPAWNER )
      Scr_Error(COM_ERR_2122, scrContext, "setspawnerteam can only be applied to AI spawners");
    if ( !Com_Teams_TeamFromString(v4, (team_t *)&Entity->c) )
    {
      v6 = SL_ConvertToString(v4);
      v7 = j_va("unknown team '%s'", v6);
      Scr_Error(COM_ERR_2123, scrContext, v7);
    }
  }
}

/*
==============
Scr_SetBlur
==============
*/
void Scr_SetBlur(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  const char *v5; 
  int v6; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = *(float *)&Float;
  v4 = Scr_GetFloat(scrContext, 1u);
  if ( *(float *)&v4 < 0.0 )
    Scr_ParamError(COM_ERR_2125, scrContext, 1u, "Time must be positive");
  if ( v3 < 0.0 )
    Scr_ParamError(COM_ERR_2126, scrContext, 0, "Blur value must be greater than 0");
  v6 = 1;
  v5 = j_va("scr_blur %i %f %i %i", (unsigned int)(int)(float)(*(float *)&v4 * 1000.0), v3, 0i64, v6);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
}

/*
==============
Scr_SoundFade
==============
*/
void Scr_SoundFade(scrContext_t *scrContext)
{
  double Float; 
  double v3; 
  float v4; 
  double v5; 
  int v6; 
  __int64 v7; 
  const char *v8; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = I_fclamp(*(float *)&Float, 0.0, 1.0);
  v4 = *(float *)&v3;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    v7 = 0i64;
  }
  else
  {
    v5 = Scr_GetFloat(scrContext, 1u);
    v6 = (int)(float)(*(float *)&v5 * 1000.0);
    v7 = 0i64;
    if ( v6 > 0 )
      v7 = (unsigned int)v6;
  }
  v8 = j_va("snd_fade %f %i\n", v4, v7);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
}

/*
==============
Scr_LevelSoundFade
==============
*/
void Scr_LevelSoundFade(scrContext_t *scrContext)
{
  double Float; 
  double v3; 
  float v4; 
  double v5; 
  int v6; 
  __int64 v7; 
  const char *v8; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = I_fclamp(*(float *)&Float, 0.0, 1.0);
  v4 = *(float *)&v3;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    v7 = 0i64;
  }
  else
  {
    v5 = Scr_GetFloat(scrContext, 1u);
    v6 = (int)(float)(*(float *)&v5 * 1000.0);
    v7 = 0i64;
    if ( v6 > 0 )
      v7 = (unsigned int)v6;
  }
  v8 = j_va("level_snd_fade %f %i\n", v4, v7);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
}

/*
==============
Scr_SaveGame
==============
*/
void Scr_SaveGame(scrContext_t *scrContext)
{
  const char *IString; 
  const char *MapName; 
  const char *String; 
  const char *v5; 
  int NumParam; 
  const char *v7; 
  bool suppressPlayerNotify; 
  const char *v9; 
  __int64 v10; 
  int v11; 
  __int64 v12; 
  int v13; 
  int v14; 
  int v15; 
  int v16; 
  char dest[64]; 

  IString = (char *)&queryFormat.fmt + 3;
  if ( !G_IsEntityInUse(0) || g_entities->health <= 0 )
    Scr_Error(COM_ERR_2129, scrContext, "Attempting to save while dead\n");
  MapName = SV_Game_GetMapName();
  String = Scr_GetString(scrContext, 0);
  v5 = String;
  if ( !String || !*String )
    v5 = "auto";
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
    IString = Scr_GetIString(scrContext, 1u);
  if ( NumParam <= 2 )
    v7 = "$default";
  else
    v7 = Scr_GetString(scrContext, 2u);
  suppressPlayerNotify = NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  v9 = "levelstart";
  v10 = 0x7FFFFFFFi64;
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v11 = (unsigned __int8)v9[v5 - "levelstart"];
    v12 = v10;
    v13 = *(unsigned __int8 *)v9++;
    --v10;
    if ( !v12 )
    {
LABEL_26:
      Com_sprintf(dest, 0x40ui64, "autosave\\%s", MapName);
      goto LABEL_27;
    }
    if ( v11 != v13 )
    {
      v14 = v11 + 32;
      if ( (unsigned int)(v11 - 65) > 0x19 )
        v14 = v11;
      v11 = v14;
      v15 = v13 + 32;
      if ( (unsigned int)(v13 - 65) > 0x19 )
        v15 = v13;
      if ( v11 != v15 )
        break;
    }
    if ( !v11 )
      goto LABEL_26;
  }
  Com_sprintf(dest, 0x40ui64, "autosave\\%s-%s", MapName, v5);
LABEL_27:
  Com_Printf(10, "Script immediately saving: \"%s\",  desc: \"%s\"\n", dest, IString);
  G_SaveMemorySP_ClearForcedCommitFlag();
  v16 = SV_SaveSP_AddPendingSave(dest, IString, v7, SAVE_TYPE_AUTOSAVE, 2u, suppressPlayerNotify);
  Scr_CheckForSaveErrors(scrContext, v16);
}

/*
==============
Scr_SaveGameNoCommit
==============
*/
void Scr_SaveGameNoCommit(scrContext_t *scrContext)
{
  const char *IString; 
  const char *MapName; 
  const char *String; 
  const char *v5; 
  int NumParam; 
  const char *v7; 
  bool suppressPlayerNotify; 
  const char *v9; 
  __int64 v10; 
  int v11; 
  __int64 v12; 
  int v13; 
  int v14; 
  int v15; 
  unsigned int v16; 
  char dest[64]; 

  IString = (char *)&queryFormat.fmt + 3;
  if ( !G_IsEntityInUse(0) || g_entities->health <= 0 )
    Scr_Error(COM_ERR_2130, scrContext, "Attempting to save while dead\n");
  MapName = SV_Game_GetMapName();
  String = Scr_GetString(scrContext, 0);
  v5 = String;
  if ( !String || !*String )
    v5 = "auto";
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
    IString = Scr_GetIString(scrContext, 1u);
  if ( NumParam <= 2 )
    v7 = "$default";
  else
    v7 = Scr_GetString(scrContext, 2u);
  suppressPlayerNotify = NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  v9 = "levelstart";
  v10 = 0x7FFFFFFFi64;
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v11 = (unsigned __int8)v9[v5 - "levelstart"];
    v12 = v10;
    v13 = *(unsigned __int8 *)v9++;
    --v10;
    if ( !v12 )
    {
LABEL_26:
      Com_sprintf(dest, 0x40ui64, "autosave\\%s", MapName);
      goto LABEL_27;
    }
    if ( v11 != v13 )
    {
      v14 = v11 + 32;
      if ( (unsigned int)(v11 - 65) > 0x19 )
        v14 = v11;
      v11 = v14;
      v15 = v13 + 32;
      if ( (unsigned int)(v13 - 65) > 0x19 )
        v15 = v13;
      if ( v11 != v15 )
        break;
    }
    if ( !v11 )
      goto LABEL_26;
  }
  Com_sprintf(dest, 0x40ui64, "autosave\\%s-%s", MapName, v5);
LABEL_27:
  Com_Printf(10, "Script buffering save: \"%s\",  desc: \"%s\"\n", dest, IString);
  G_SaveMemorySP_ClearForcedCommitFlag();
  v16 = SV_SaveSP_AddPendingSave(dest, IString, v7, SAVE_TYPE_AUTOSAVE, 1u, suppressPlayerNotify);
  Scr_CheckForSaveErrors(scrContext, v16);
  Scr_AddInt(scrContext, v16);
  Com_Printf(10, "Script successfully buffered savegame with ID #%i.\n", v16);
}

/*
==============
Scr_IsSaveSuccessful
==============
*/
void Scr_IsSaveSuccessful(scrContext_t *scrContext)
{
  SaveGame *SaveHandle; 
  bool IsSuccessful; 

  SaveHandle = G_SaveMemorySP_GetSaveHandle(SAVE_GAME_HANDLE);
  IsSuccessful = G_SaveMemorySP_IsSuccessful(SaveHandle);
  Scr_AddBool(scrContext, IsSuccessful);
}

/*
==============
Scr_IsRecentlyLoaded
==============
*/
void Scr_IsRecentlyLoaded(scrContext_t *scrContext)
{
  bool IsRecentlyLoaded; 

  IsRecentlyLoaded = SV_SaveMemory_IsRecentlyLoaded();
  Scr_AddBool(scrContext, IsRecentlyLoaded);
}

/*
==============
Scr_CommitSave
==============
*/
void Scr_CommitSave(scrContext_t *scrContext)
{
  SaveGame *SaveHandle; 
  __int64 Int; 
  const SaveHeader *Header; 
  int saveId; 
  const SaveHeader *v6; 
  __int64 v7; 
  const char *v8; 

  SaveHandle = G_SaveMemorySP_GetSaveHandle(SAVE_GAME_HANDLE);
  if ( !SaveHandle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4498, ASSERT_TYPE_ASSERT, "(save)", (const char *)&queryFormat, "save") )
    __debugbreak();
  Int = (unsigned int)Scr_GetInt(scrContext, 0);
  Com_Printf(10, "Script is attempting to commit savegame with ID #%i.\n", Int);
  if ( G_SaveMemorySP_IsCommitForced() )
  {
    Com_Printf(10, "Savegame #%i has already been committed.\n", (unsigned int)Int);
    G_SaveMemorySP_ClearForcedCommitFlag();
    return;
  }
  if ( !G_SaveMemorySP_IsWaitingForCommit(SaveHandle) )
  {
    SaveHandle = G_SaveMemorySP_GetSaveHandle(SAVE_LAST_COMMITTED);
    if ( !SaveHandle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4514, ASSERT_TYPE_ASSERT, "(save)", (const char *)&queryFormat, "save") )
      __debugbreak();
    Header = G_SaveMemorySP_GetHeader(SaveHandle);
    if ( !Header && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4516, ASSERT_TYPE_ASSERT, "(header)", (const char *)&queryFormat, "header") )
      __debugbreak();
    saveId = Header->saveId;
    if ( (_DWORD)Int == saveId || !saveId )
    {
      Com_Printf(10, "Skipping script's attempt to commit save #%i - assuming we've recently loaded from savegame.\n", (unsigned int)Int);
      return;
    }
    if ( sv_demo.playing )
    {
      Com_Printf(10, "Skipping script's attempt to commit save #%i - demo is playing.\n", (unsigned int)Int);
      return;
    }
    Scr_Error(COM_ERR_2131, scrContext, "Save Commit attempted with no valid committable save available");
  }
  v6 = G_SaveMemorySP_GetHeader(SaveHandle);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4536, ASSERT_TYPE_ASSERT, "(header)", (const char *)&queryFormat, "header") )
    __debugbreak();
  v7 = (unsigned int)v6->saveId;
  if ( (_DWORD)Int != (_DWORD)v7 )
  {
    v8 = j_va("Save Commit attempted on incorrect save.  currentsave:%i, commit:%i", (unsigned int)Int, v7);
    Scr_Error(COM_ERR_2132, scrContext, v8);
  }
  if ( !G_SaveSP_CommitSavedGame(Int) )
    Scr_Error(COM_ERR_2133, scrContext, "Attempting to commit an invalid save");
  Com_Printf(10, "Savegame #%i successfully committed by script.\n", (unsigned int)Int);
}

/*
==============
Scr_CommitWouldBeValid
==============
*/
void Scr_CommitWouldBeValid(scrContext_t *scrContext)
{
  bool WouldBeValid; 
  int Int; 
  SaveGame *SaveHandle; 
  const SaveHeader *Header; 

  if ( sv_demo.playing )
  {
    WouldBeValid = SV_DemoSP_GetSaveCommitWouldBeValid();
  }
  else
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( G_SaveMemorySP_IsCommitForced() )
    {
      WouldBeValid = 0;
    }
    else
    {
      SaveHandle = G_SaveMemorySP_GetSaveHandle(SAVE_GAME_HANDLE);
      if ( !SaveHandle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4560, ASSERT_TYPE_ASSERT, "(save)", (const char *)&queryFormat, "save") )
        __debugbreak();
      if ( G_SaveMemorySP_IsWaitingForCommit(SaveHandle) )
      {
        Header = G_SaveMemorySP_GetHeader(SaveHandle);
        if ( !Header && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4565, ASSERT_TYPE_ASSERT, "(header)", (const char *)&queryFormat, "header") )
          __debugbreak();
        WouldBeValid = Int == Header->saveId;
      }
      else
      {
        WouldBeValid = 0;
      }
    }
    SV_DemoSP_RecordSaveCommitWouldBeValid(WouldBeValid);
  }
  Scr_AddBool(scrContext, WouldBeValid);
}

/*
==============
GScr_TurretSP_IsActive
==============
*/
void GScr_TurretSP_IsActive(scrContext_t *scrContext)
{
  gentity_s *Entity; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GScr_GetEntity(0);
    if ( Entity )
      Scr_AddBool(scrContext, Entity->active);
    else
      Scr_Error(COM_ERR_2135, scrContext, "NULL turret passed to isturretactive");
  }
  else
  {
    Scr_Error(COM_ERR_2134, scrContext, "illegal call to isturretactive()");
  }
}

/*
==============
GScr_WeaponFightDist
==============
*/
void GScr_WeaponFightDist(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  int v3; 
  unsigned int v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v4 = bg_lastParsedWeaponIndex;
    v3 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v3, v4) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_AddFloat(scrContext, bg_weaponDefs[weaponIdx]->fightDist);
}

/*
==============
GScr_WeaponMaxDist
==============
*/
void GScr_WeaponMaxDist(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  int v3; 
  unsigned int v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v4 = bg_lastParsedWeaponIndex;
    v3 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v3, v4) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_AddFloat(scrContext, bg_weaponDefs[weaponIdx]->maxDist);
}

/*
==============
GScr_ScreenShake
==============
*/
void GScr_ScreenShake(scrContext_t *scrContext)
{
  __int128 v1; 
  const dvar_t *v2; 
  int v4; 
  int v5; 
  int v6; 
  float v7; 
  float v8; 
  float v9; 
  double Float; 
  double v11; 
  double v12; 
  double v13; 
  double v14; 
  double v15; 
  double v16; 
  float v17; 
  int v18; 
  double v19; 
  float v20; 
  float v21; 
  double v22; 
  int v23; 
  int v26; 
  float v27; 
  const char *v28; 
  __int64 v29; 
  __int64 v30; 
  vec3_t vectorValue; 
  __int128 v32; 

  v2 = DVARBOOL_g_earthquakeEnable;
  if ( !DVARBOOL_g_earthquakeEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_earthquakeEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    LOWORD(v4) = 100;
    LOWORD(v5) = 100;
    LOWORD(v6) = 100;
    v7 = FLOAT_N1_0;
    v8 = 0.0;
    vectorValue.v[0] = 0.0;
    vectorValue.v[1] = 0.0;
    vectorValue.v[2] = 0.0;
    v9 = 0.0;
    switch ( Scr_GetNumParam(scrContext) )
    {
      case 5u:
        goto $LN18_118;
      case 6u:
        goto $LN17_99;
      case 7u:
        goto $LN15_128;
      case 8u:
        goto $LN14_153;
      case 9u:
        goto $LN11_134;
      case 0xAu:
        goto $LN8_159;
      case 0xBu:
        Float = Scr_GetFloat(scrContext, 0xAu);
        if ( *(float *)&Float < 0.0 || *(float *)&Float > 100.0 )
          Scr_ParamError(COM_ERR_2136, scrContext, 0xAu, "frequencyroll must be >= 0 and <= 100\n");
        v6 = (int)(float)(*(float *)&Float * 100.0);
$LN8_159:
        v11 = Scr_GetFloat(scrContext, 9u);
        if ( *(float *)&v11 < 0.0 || *(float *)&v11 > 100.0 )
          Scr_ParamError(COM_ERR_2137, scrContext, 9u, "frequencyyaw must be >= 0 and <= 100\n");
        v5 = (int)(float)(*(float *)&v11 * 100.0);
$LN11_134:
        v12 = Scr_GetFloat(scrContext, 8u);
        if ( *(float *)&v12 < 0.0 || *(float *)&v12 > 100.0 )
          Scr_ParamError(COM_ERR_2138, scrContext, 8u, "frequencypitch must be >= 0 and <= 100\n");
        v4 = (int)(float)(*(float *)&v12 * 100.0);
$LN14_153:
        v13 = Scr_GetFloat(scrContext, 7u);
        v8 = *(float *)&v13;
        if ( *(float *)&v13 < 0.0 )
          Scr_ParamError(COM_ERR_2139, scrContext, 7u, "radius must be >= 0\n");
$LN15_128:
        v14 = Scr_GetFloat(scrContext, 6u);
        v7 = *(float *)&v14 * 1000.0;
$LN17_99:
        v15 = Scr_GetFloat(scrContext, 5u);
        v9 = *(float *)&v15 * 1000.0;
$LN18_118:
        v32 = v1;
        Scr_GetVector(scrContext, 0, &vectorValue);
        v16 = Scr_GetFloat(scrContext, 1u);
        if ( *(float *)&v16 < 0.0 || *(float *)&v16 > 100.0 )
          Scr_ParamError(COM_ERR_2140, scrContext, 1u, "scalepitch must be >= 0 and <= 100\n");
        v17 = *(float *)&v16 * 100.0;
        v18 = (int)(float)(*(float *)&v16 * 100.0);
        v19 = Scr_GetFloat(scrContext, 2u);
        v20 = v17;
        if ( *(float *)&v19 < 0.0 || *(float *)&v19 > 100.0 )
          Scr_ParamError(COM_ERR_2141, scrContext, 2u, "scaleyaw must be >= 0 and <= 100\n");
        v21 = v17 * 100.0;
        v22 = Scr_GetFloat(scrContext, 3u);
        if ( *(float *)&v22 < 0.0 || *(float *)&v22 > 100.0 )
          Scr_ParamError(COM_ERR_2142, scrContext, 3u, "scaleroll must be >= 0 and <= 100\n");
        v23 = (int)(float)(v21 * 100.0);
        Scr_GetFloat(scrContext, 4u);
        _XMM1 = 0i64;
        __asm { vroundss xmm4, xmm1, xmm3, 1 }
        v26 = (int)*(float *)&_XMM4;
        if ( (int)*(float *)&_XMM4 <= 0 )
          Scr_ParamError(COM_ERR_2143, scrContext, 4u, "duration must be > 0\n");
        if ( v7 >= 0.0 || v9 >= 0.0 )
        {
          v27 = (float)v26;
          if ( v9 >= 0.0 )
          {
            if ( v7 >= 0.0 )
            {
              if ( (float)(v9 + v7) > (float)v26 )
                Scr_Error(COM_ERR_2145, scrContext, "In ScreenShake: [durationfadeup] + [durationfadedown] <= <duration>.\n");
            }
            else
            {
              v7 = v27 - v9;
            }
          }
          else
          {
            v9 = v27 - v7;
          }
        }
        else
        {
          v9 = (float)v26 * 0.5;
          v7 = (float)v26 - v9;
        }
        LODWORD(v30) = (__int16)(int)(float)(v20 * 100.0);
        LODWORD(v29) = (__int16)v18;
        v28 = j_va("%c %f %f %f %d %d %d %d %f %f %f %d %d %d", 57i64, vectorValue.v[0], vectorValue.v[1], vectorValue.v[2], v29, v30, (__int16)v23, v26, v9, v7, v8, (__int16)v4, (__int16)v5, (__int16)v6);
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v28);
        break;
      default:
        Scr_Error(COM_ERR_2144, scrContext, "usage: ScreenShake( <sourcePoint>, <scalepitch>, <scaleyaw>, <scaleroll>, <duration>, [durationfadeup], [durationfadedown], [radius], [frequency] );\n");
        break;
    }
  }
}

/*
==============
ScrCmd_ScreenShakeOnEntity
==============
*/
void ScrCmd_ScreenShakeOnEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  const dvar_t *v2; 
  gentity_s *Entity; 
  float v6; 
  int v7; 
  int v8; 
  int v9; 
  int v10; 
  int v11; 
  float v12; 
  float v13; 
  int v14; 
  const char *v15; 
  const char *v16; 
  double Float; 
  double v18; 
  double v19; 
  double v20; 
  double v21; 
  double v22; 
  double v23; 
  float v24; 
  double v25; 
  float v26; 
  float v27; 
  double v28; 
  float v31; 
  const char *v32; 
  char *fmt; 
  __int64 v34; 
  __int64 v35; 
  int entnum_low; 
  int v37; 
  int v38; 
  gentity_s *v39; 

  v2 = DVARBOOL_g_earthquakeEnable;
  if ( !DVARBOOL_g_earthquakeEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_earthquakeEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    Entity = GetEntity(entref);
    v6 = FLOAT_N1_0;
    LOWORD(v7) = 0;
    v39 = Entity;
    LOWORD(entref.entnum) = 100;
    LOWORD(v8) = 0;
    LOWORD(v9) = 0;
    v10 = 0;
    LOWORD(v11) = 100;
    v12 = 0.0;
    v13 = 0.0;
    LOWORD(v14) = 100;
    if ( (Entity->r.svFlags & 1) != 0 )
    {
      v15 = SL_ConvertToString(Entity->classname);
      v16 = j_va("ScreenShakeOnEntity called on a server only entity with classname %s", v15);
      Scr_Error(COM_ERR_2146, scrContext, v16);
    }
    switch ( Scr_GetNumParam(scrContext) )
    {
      case 4u:
        goto $LN19_95;
      case 5u:
        goto $LN18_119;
      case 6u:
        goto $LN16_102;
      case 7u:
        goto $LN15_129;
      case 8u:
        goto $LN12_187;
      case 9u:
        goto $LN9_205;
      case 0xAu:
        Float = Scr_GetFloat(scrContext, 9u);
        if ( *(float *)&Float < 0.0 || *(float *)&Float > 100.0 )
          Scr_ParamError(COM_ERR_2147, scrContext, 9u, "frequencyroll must be >= 0 and <= 100\n");
        v14 = (int)(float)(*(float *)&Float * 100.0);
$LN9_205:
        v18 = Scr_GetFloat(scrContext, 8u);
        if ( *(float *)&v18 < 0.0 || *(float *)&v18 > 100.0 )
          Scr_ParamError(COM_ERR_2148, scrContext, 8u, "frequencyyaw must be >= 0 and <= 100\n");
        v11 = (int)(float)(*(float *)&v18 * 100.0);
$LN12_187:
        v19 = Scr_GetFloat(scrContext, 7u);
        if ( *(float *)&v19 < 0.0 || *(float *)&v19 > 100.0 )
          Scr_ParamError(COM_ERR_2149, scrContext, 7u, "frequencypitch must be >= 0 and <= 100\n");
        entref.entnum = (int)(float)(*(float *)&v19 * 100.0);
$LN15_129:
        v20 = Scr_GetFloat(scrContext, 6u);
        v13 = *(float *)&v20;
        if ( *(float *)&v20 < 0.0 )
          Scr_ParamError(COM_ERR_2150, scrContext, 6u, "radius must be >= 0\n");
$LN16_102:
        v21 = Scr_GetFloat(scrContext, 5u);
        v6 = *(float *)&v21 * 1000.0;
$LN18_119:
        v22 = Scr_GetFloat(scrContext, 4u);
        v12 = *(float *)&v22 * 1000.0;
$LN19_95:
        v23 = Scr_GetFloat(scrContext, 0);
        if ( *(float *)&v23 < 0.0 || *(float *)&v23 > 100.0 )
          Scr_ParamError(COM_ERR_2151, scrContext, 0, "scalepitch must be >= 0 and <= 100\n");
        v24 = *(float *)&v23 * 100.0;
        v7 = (int)(float)(*(float *)&v23 * 100.0);
        v25 = Scr_GetFloat(scrContext, 1u);
        v26 = v24;
        if ( *(float *)&v25 < 0.0 || *(float *)&v25 > 100.0 )
          Scr_ParamError(COM_ERR_2152, scrContext, 1u, "scaleyaw must be >= 0 and <= 100\n");
        v27 = v24 * 100.0;
        v8 = (int)(float)(v26 * 100.0);
        v28 = Scr_GetFloat(scrContext, 2u);
        if ( *(float *)&v28 < 0.0 || *(float *)&v28 > 100.0 )
          Scr_ParamError(COM_ERR_2153, scrContext, 2u, "scaleroll must be >= 0 and <= 100\n");
        v9 = (int)(float)(v27 * 100.0);
        Scr_GetFloat(scrContext, 3u);
        _XMM1 = 0i64;
        __asm { vroundss xmm4, xmm1, xmm3, 1 }
        v10 = (int)*(float *)&_XMM4;
        if ( (int)*(float *)&_XMM4 <= 0 )
          Scr_ParamError(COM_ERR_2154, scrContext, 3u, "duration must be > 0\n");
        if ( v6 >= 0.0 || v12 >= 0.0 )
          goto LABEL_39;
        v12 = (float)v10 * 0.5;
        v6 = (float)v10 - v12;
        break;
      default:
        Scr_Error(COM_ERR_2155, scrContext, "usage: <ent> ScreenShakeOnEntity( <scalepitch>, <scaleyaw>, <scaleroll>, <duration>, [durationfadeup], [durationfadedown], [radius], [frequencypitch], [frequencyyaw], [frequencyroll] );\n");
LABEL_39:
        v31 = (float)v10;
        if ( v12 >= 0.0 )
        {
          if ( v6 >= 0.0 )
          {
            if ( (float)(v12 + v6) > (float)v10 )
              Scr_Error(COM_ERR_2156, scrContext, "In ScreenShakeOnEntity: [durationfadeup] + [durationfadedown] <= <duration>.\n");
          }
          else
          {
            v6 = v31 - v12;
          }
        }
        else
        {
          v12 = v31 - v6;
        }
        break;
    }
    v38 = (__int16)v14;
    v37 = (__int16)v11;
    entnum_low = SLOWORD(entref.entnum);
    LODWORD(v35) = v10;
    LODWORD(v34) = (__int16)v9;
    LODWORD(fmt) = (__int16)v8;
    v32 = j_va("%c %d %d %d %d %d %f %f %f %d %d %d", 56i64, (unsigned int)v39->s.number, (unsigned int)(__int16)v7, fmt, v34, v35, v12, v6, v13, entnum_low, v37, v38);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v32);
  }
}

/*
==============
Scr_PrecacheNightvisionCodeAssets
==============
*/
void Scr_PrecacheNightvisionCodeAssets(scrContext_t *scrContext)
{
  if ( level.initializing )
    SV_SetConfigstring(0xFu, "1");
  else
    Scr_Error(COM_ERR_2157, scrContext, "PrecacheNightvisionCodeAssets() must be called during level initialization.\n");
}

/*
==============
Scr_DigitalDistortSetParams
==============
*/
void Scr_DigitalDistortSetParams(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  double Float; 
  float v7; 
  const char *v8; 
  double v9; 
  double v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  unsigned int clientNum; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4980, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v7 = *(float *)&Float;
    if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    {
      v8 = j_va("intensity must be between 0 and 1 - %f\n", *(float *)&Float);
      Scr_ParamError(COM_ERR_2159, scrContext, 1u, v8);
    }
    v9 = Scr_GetFloat(scrContext, 1u);
    if ( *(float *)&v9 < 0.0 || *(float *)&v9 > 100.0 )
    {
      v10 = *(float *)&v9;
      v11 = j_va("timeScale must be between 0 and 100 - %f\n", *(float *)&v9);
      Scr_ParamError(COM_ERR_2160, scrContext, 1u, v11);
    }
    else
    {
      v10 = *(float *)&v9;
    }
    v12 = j_va("digitaldistort %f %f", v7, v10);
    v13 = v12;
    clientNum = v4->client->ps.clientNum;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v13);
    }
  }
  else
  {
    Scr_Error(COM_ERR_2158, scrContext, "usage: DigitalDistortSetParams( <intensity>, <timeScale> )\n");
  }
}

/*
==============
Scr_PrecacheMinimapSentryCodeAssets
==============
*/
void Scr_PrecacheMinimapSentryCodeAssets(scrContext_t *scrContext)
{
  if ( level.initializing )
    SV_SetConfigstring(0xEu, "1");
  else
    Scr_Error(COM_ERR_2161, scrContext, "PrecacheMinimapSentryCodeAssets() must be called during level initialization.\n");
}

/*
==============
GScr_ChangeLevel
==============
*/
void GScr_ChangeLevel(scrContext_t *scrContext)
{
  gentity_s *v2; 
  const dvar_t *v3; 
  unsigned int v4; 
  const char *String; 

  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities->r.isInUse != *g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !*g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 5041, ASSERT_TYPE_ASSERT, "( G_IsEntityInUse( 0 ) )", (const char *)&queryFormat, "G_IsEntityInUse( 0 )") )
    __debugbreak();
  v2 = g_entities;
  if ( g_entities->classname != scr_const.player && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 5043, ASSERT_TYPE_ASSERT, "(player->classname == scr_const.player)", (const char *)&queryFormat, "player->classname == scr_const.player") )
    __debugbreak();
  if ( v2->health > 0 )
  {
    v3 = DVARINT_reloading;
    if ( !DVARINT_reloading && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "reloading") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    if ( !v3->current.integer )
    {
      level.exitTime = 1000;
      v4 = Scr_GetNumParam(scrContext) - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
        {
          Scr_GetFloat(scrContext, 2u);
          _XMM0 = 0i64;
          __asm { vroundss xmm1, xmm0, xmm4, 1 }
          level.exitTime = (int)*(float *)&_XMM1;
          if ( (int)*(float *)&_XMM1 < 0 )
            Scr_ParamError(COM_ERR_2162, scrContext, 1u, "exitTime cannot be negative");
        }
        level.savepersist = Scr_GetInt(scrContext, 1u);
      }
      String = Scr_GetString(scrContext, 0);
      level.changelevel = 1;
      G_MainSP_SetNextMap(String);
    }
  }
}

/*
==============
GScr_MissionSuccess
==============
*/
void GScr_MissionSuccess(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_2163, scrContext, "missionSuccess only takes two parameters: missionSuccess(nextMap, persistent)\n");
  GScr_ChangeLevel(scrContext);
  level.bMissionSuccess = 1;
}

/*
==============
GScr_MissionFailed
==============
*/
void GScr_MissionFailed(scrContext_t *scrContext)
{
  int Int; 
  int bMissionForceFailed; 

  G_ClientSP_Respawn();
  level.bMissionFailed = 1;
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    bMissionForceFailed = level.bMissionForceFailed;
    if ( Int == 1 )
      bMissionForceFailed = 1;
    level.bMissionForceFailed = bMissionForceFailed;
  }
}

/*
==============
GScr_Cinematic
==============
*/
void GScr_Cinematic(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *String; 
  const char *v6; 
  const dvar_t *v7; 

  v1 = DVARINT_reloading;
  if ( !DVARINT_reloading && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "reloading") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( !v1->current.integer )
  {
    if ( Scr_GetNumParam(scrContext) != 1 )
    {
      Scr_GetFloat(scrContext, 1u);
      _XMM0 = 0i64;
      __asm { vroundss xmm1, xmm0, xmm4, 1 }
      level.exitTime = (int)*(float *)&_XMM1;
      if ( (int)*(float *)&_XMM1 < 0 )
        Scr_ParamError(COM_ERR_2164, scrContext, 1u, "exitTime cannot be negative");
    }
    String = Scr_GetString(scrContext, 0);
    v6 = String;
    if ( cl_pregame->current.enabled )
    {
      Com_PrintWarning(1, "Tried to play Cinematic %s during Pre Game.\n", String);
    }
    else
    {
      if ( Scr_GetNumParam(scrContext) > 2 )
      {
        v7 = DVARFLT_g_changelevel_time;
        if ( !DVARFLT_g_changelevel_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_changelevel_time") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v7);
        if ( v7->current.value > 0.0 )
        {
          Dvar_GetFloat_Internal_DebugName(DVARFLT_g_changelevel_time, "g_changelevel_time");
          _XMM0 = 0i64;
          __asm { vroundss xmm1, xmm0, xmm4, 1 }
          level.exitTime = (int)*(float *)&_XMM1;
        }
      }
      level.changelevel = 1;
      Core_strcpy_truncate(level.cinematic, 0x40ui64, v6);
      level.bMissionSuccess = 1;
    }
  }
}

/*
==============
GScr_CinematicInGame
==============
*/
void GScr_CinematicInGame(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool v3; 
  const char *String; 
  const char *v5; 
  bool v6; 

  v2 = 0;
  v3 = 0;
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2165, scrContext, "cinematicingame requires at least one parameter: cinematicingame(<cinematic name>, [pause_at_start])\n");
  if ( cl_pregame->current.enabled )
  {
    String = Scr_GetString(scrContext, 0);
    Com_PrintWarning(1, "Tried to play Cinematic %s during Pre Game.\n", String);
  }
  else
  {
    if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetInt(scrContext, 1u) )
      v2 = 16;
    if ( Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u) )
      v2 |= 0x80u;
    if ( Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) )
      v2 |= 0x800u;
    if ( Scr_GetNumParam(scrContext) >= 5 && Scr_GetInt(scrContext, 4u) )
      v2 |= 0x4000u;
    if ( Scr_GetNumParam(scrContext) >= 6 )
      v3 = Scr_GetInt(scrContext, 5u) != 0;
    if ( Scr_GetNumParam(scrContext) >= 7 && Scr_GetInt(scrContext, 6u) )
      v2 |= 0x2000u;
    v5 = Scr_GetString(scrContext, 0);
    if ( v3 )
    {
      v6 = R_Cinematic_Preload(v5);
      Scr_AddBool(scrContext, v6);
    }
    else
    {
      R_Cinematic_SetNextPlayback(v5, v2, 0, CINEMATIC_INVALID);
    }
  }
}

/*
==============
GScr_CinematicInGameLoop
==============
*/
void GScr_CinematicInGameLoop(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool enabled; 
  const char *String; 

  v2 = 2;
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2166, scrContext, "cinematicingameloop takes at least one parameter: cinematicingameloop(<cinematic name>)\n");
  if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetInt(scrContext, 1u) )
    v2 = 258;
  if ( Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u) )
    v2 |= 0x4000u;
  enabled = cl_pregame->current.enabled;
  String = Scr_GetString(scrContext, 0);
  if ( enabled )
    Com_PrintWarning(1, "Tried to play Cinematic %s during Pre Game.\n", String);
  else
    R_Cinematic_SetNextPlayback(String, v2, 0, CINEMATIC_INVALID);
}

/*
==============
GScr_CinematicInGameLoopResident
==============
*/
void GScr_CinematicInGameLoopResident(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool enabled; 
  const char *String; 

  v2 = 14;
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetNumParam(scrContext) == 2 && Scr_GetInt(scrContext, 1u) )
      v2 = 270;
  }
  else
  {
    Scr_Error(COM_ERR_2167, scrContext, "CinematicInGameLoopResident takes one parameter: CinematicInGameLoopResident(<cinematic name>)\n");
  }
  enabled = cl_pregame->current.enabled;
  String = Scr_GetString(scrContext, 0);
  if ( enabled )
    Com_PrintWarning(1, "Tried to play Cinematic %s during Pre Game.\n", String);
  else
    R_Cinematic_SetNextPlayback(String, v2, 0, CINEMATIC_INVALID);
}

/*
==============
GScr_IsCinematicPlaying
==============
*/
void GScr_IsCinematicPlaying(scrContext_t *scrContext)
{
  bool IsCinematicPlaying; 

  if ( sv_demo.playing )
  {
    IsCinematicPlaying = SV_DemoSP_GetIsCinematicPlaying();
  }
  else
  {
    IsCinematicPlaying = (R_Cinematic_IsStarted() || R_Cinematic_IsPending()) && !R_Cinematic_IsHeld();
    SV_DemoSP_RecordIsCinematicPlaying(IsCinematicPlaying);
  }
  Scr_AddBool(scrContext, IsCinematicPlaying);
}

/*
==============
GScr_IsCinematicLoaded
==============
*/
void GScr_IsCinematicLoaded(scrContext_t *scrContext)
{
  bool IsCinematicLoaded; 

  if ( sv_demo.playing )
  {
    IsCinematicLoaded = SV_DemoSP_GetIsCinematicLoaded();
  }
  else
  {
    IsCinematicLoaded = R_Cinematic_IsLoaded();
    SV_DemoSP_RecordIsCinematicLoaded(IsCinematicLoaded);
  }
  Scr_AddBool(scrContext, IsCinematicLoaded);
}

/*
==============
GScr_CinematicGetFrame
==============
*/
void GScr_CinematicGetFrame(scrContext_t *scrContext)
{
  int Frame; 

  if ( sv_demo.playing )
  {
    Frame = SV_DemoSP_CinematicGetFrame();
  }
  else
  {
    Frame = R_Cinematic_GetFrame();
    SV_DemoSP_RecordCinematicGetFrame(Frame);
  }
  Scr_AddInt(scrContext, Frame);
}

/*
==============
GScr_CinematicGetTimeInMsec
==============
*/
void GScr_CinematicGetTimeInMsec(scrContext_t *scrContext)
{
  int TimeInMsec; 

  if ( sv_demo.playing )
  {
    TimeInMsec = SV_DemoSP_CinematicGetTimeInMsec();
  }
  else
  {
    TimeInMsec = R_Cinematic_GetTimeInMsec();
    SV_DemoSP_RecordCinematicGetTimeInMsec(TimeInMsec);
  }
  Scr_AddInt(scrContext, TimeInMsec);
}

/*
==============
GScr_StopCinematicInGame
==============
*/
void GScr_StopCinematicInGame(scrContext_t *scrContext)
{
  if ( !cl_pregame->current.enabled )
  {
    if ( Scr_GetNumParam(scrContext) )
      Scr_Error(COM_ERR_2168, scrContext, "stopcinematicingame takes no parameters: stopcinematicingame()\n");
    R_Cinematic_UnsetNextPlayback();
    R_Cinematic_StopPlayback(0);
  }
}

/*
==============
GScr_PauseCinematicInGame
==============
*/
void GScr_PauseCinematicInGame(scrContext_t *scrContext)
{
  const dvar_t *VarByName; 
  bool enabled; 
  int Int; 

  if ( !cl_pregame->current.enabled )
  {
    if ( Scr_GetNumParam(scrContext) != 1 )
      Scr_Error(COM_ERR_2169, scrContext, "pausecinematicingame takes one parameter: pausecinematicingame( <pause> )\n");
    VarByName = Dvar_FindVarByName("NMMPTOSMKQ");
    if ( !VarByName || (VarByName->type ? (enabled = atoi(VarByName->current.string) != 0) : (enabled = VarByName->current.enabled), !enabled) )
    {
      Int = Scr_GetInt(scrContext, 0);
      R_Cinematic_SetPaused(Int != 0 ? CINEMATIC_INGAME_PAUSED : CINEMATIC_NOT_PAUSED, 5);
    }
  }
}

/*
==============
GScr_DrawCompassFriendlies
==============
*/
void GScr_DrawCompassFriendlies(scrContext_t *scrContext)
{
  level.bDrawCompassFriendlies = Scr_GetInt(scrContext, 0);
}

/*
==============
GScr_SetSettleTime
==============
*/
void GScr_SetSettleTime(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) )
    level.settleTime = Scr_GetInt(scrContext, 0);
  else
    level.settleTime = 0;
}

/*
==============
GScr_SetStreamSyncOnNextLevel
==============
*/
void GScr_SetStreamSyncOnNextLevel(scrContext_t *scrContext)
{
  level.forceStreamSyncSP = 1;
}

/*
==============
Scr_GetFXVis
==============
*/
void Scr_GetFXVis(scrContext_t *scrContext)
{
  double ClientVisibility; 
  float v3; 
  double FxVisibility; 
  vec3_t end; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  if ( SV_IsDemoPlaying() )
  {
    FxVisibility = SV_DemoSP_GetFxVisibility();
    v3 = *(float *)&FxVisibility;
  }
  else
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_system_api_inline.h", 118, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY )") )
      __debugbreak();
    ClientVisibility = FX_GetClientVisibility(fx_serverVisClient, &vectorValue, &end);
    v3 = *(float *)&ClientVisibility;
    SV_DemoSP_RecordFxVisibility(*(float *)&ClientVisibility);
  }
  Scr_AddFloat(scrContext, v3);
}

/*
==============
Scr_EnableDismembermentTag
==============
*/
void Scr_EnableDismembermentTag(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  LocalClientNum_t OnlyLocalClientNum; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  FX_Dismemberment_SetBoneEnabled(OnlyLocalClientNum, ConstLowercaseString, 1);
}

/*
==============
Scr_DisableDismembermentTag
==============
*/
void Scr_DisableDismembermentTag(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  LocalClientNum_t OnlyLocalClientNum; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  FX_Dismemberment_SetBoneEnabled(OnlyLocalClientNum, ConstLowercaseString, 0);
}

/*
==============
Scr_EnableDismemberment
==============
*/
void Scr_EnableDismemberment(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(client + 94, GameModeFlagValues::ms_spValue, 0x1Du);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, GameModeFlagValues::ms_spValue, 0x1Du);
}

/*
==============
Scr_DisableDismemberment
==============
*/
void Scr_DisableDismemberment(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(client + 94, GameModeFlagValues::ms_spValue, 0x1Du);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, GameModeFlagValues::ms_spValue, 0x1Du);
}

/*
==============
GScr_SpawnMayhem
==============
*/
void GScr_SpawnMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  const char *v4; 
  vec3_t v5; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = Scr_GetConstString(scrContext, 1u);
    Scr_GetVector(scrContext, 2u, &vectorValue);
    Scr_GetVector(scrContext, 3u, &v5);
    v4 = j_va("mayhem spawn %d %d %f %f %f %f %f %f", (unsigned int)ConstString, (unsigned int)v3, vectorValue.v[0], vectorValue.v[1], vectorValue.v[2], v5.v[0], v5.v[1], v5.v[2]);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v4);
  }
  else
  {
    Scr_Error(COM_ERR_2170, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
GScr_KillMayhem
==============
*/
void GScr_KillMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = j_va("mayhem kill %d", (unsigned int)ConstString);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  else
  {
    Scr_Error(COM_ERR_2171, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
GScr_IsMayhem
==============
*/
void GScr_IsMayhem(scrContext_t *scrContext)
{
  int v2; 
  scr_string_t ConstString; 
  scr_string_t v4; 
  scr_string_t targetname; 
  scr_string_t v6; 
  unsigned int v7; 
  mayhemData_t *mayhemEnts; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2172, scrContext, "IsMayhem() requires two arguments (name, key)");
  v2 = 1;
  ConstString = Scr_GetConstString(scrContext, 0);
  v4 = Scr_GetConstString(scrContext, 1u);
  targetname = scr_const.targetname;
  v6 = v4;
  if ( v4 != scr_const.targetname )
  {
    Scr_ParamError(COM_ERR_2173, scrContext, 1u, "IsMayhem() key must be 'targetname' (for now)");
    targetname = scr_const.targetname;
  }
  v7 = 0;
  mayhemEnts = level.mayhemEnts;
  while ( v6 != targetname || ConstString != mayhemEnts->targetName )
  {
    ++v7;
    ++mayhemEnts;
    if ( v7 >= 0x40 )
    {
      v2 = 0;
      break;
    }
  }
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_PlayMayhem
==============
*/
void GScr_PlayMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = j_va("mayhem play %d", (unsigned int)ConstString);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  else
  {
    Scr_Error(COM_ERR_2174, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
GScr_PauseMayhem
==============
*/
void GScr_PauseMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = j_va("mayhem pause %d", (unsigned int)ConstString);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  else
  {
    Scr_Error(COM_ERR_2175, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
GScr_HideMayhem
==============
*/
void GScr_HideMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = j_va("mayhem hide %d", (unsigned int)ConstString);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  else
  {
    Scr_Error(COM_ERR_2176, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
GScr_ShowMayhem
==============
*/
void GScr_ShowMayhem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = j_va("mayhem show %d", (unsigned int)ConstString);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  else
  {
    Scr_Error(COM_ERR_2177, scrContext, "Invalid parameters.\n");
  }
}

/*
==============
Scr_SetCullDist
==============
*/
void Scr_SetCullDist(scrContext_t *scrContext)
{
  double Float; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2178, scrContext, "Incorrect number of parameters\n");
  Float = Scr_GetFloat(scrContext, 0);
  v3 = j_va("%g", *(float *)&Float);
  SV_SetConfigstring(0xFEEu, v3);
}

/*
==============
Scr_GetCullDist
==============
*/
void Scr_GetCullDist(scrContext_t *scrContext)
{
  char buffer[32]; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2179, scrContext, "Incorrect number of parameters\n");
  SV_GetConfigstring(0xFEEu, buffer, 32);
  *(double *)&_XMM0 = atof(buffer);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
Scr_GetMapSunColorRaw
==============
*/
void Scr_GetMapSunColorRaw(scrContext_t *scrContext)
{
  float v2; 
  float v3; 
  float v4; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2180, scrContext, "Incorrect number of parameters\n");
  v2 = level.mapSunColorAndIntensity.v[3] * level.mapSunColorAndIntensity.v[0];
  v3 = level.mapSunColorAndIntensity.v[3] * level.mapSunColorAndIntensity.v[1];
  v4 = level.mapSunColorAndIntensity.v[3] * level.mapSunColorAndIntensity.v[2];
  Scr_MakeArray(scrContext);
  Scr_AddFloat(scrContext, v2);
  Scr_AddArray(scrContext);
  Scr_AddFloat(scrContext, v3);
  Scr_AddArray(scrContext);
  Scr_AddFloat(scrContext, v4);
  Scr_AddArray(scrContext);
}

/*
==============
Scr_GetMapSunColorAndIntensity
==============
*/
void Scr_GetMapSunColorAndIntensity(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2181, scrContext, "Incorrect number of parameters\n");
  Scr_MakeArray(scrContext);
  Scr_AddFloat(scrContext, level.worldspawnSunColor.v[0]);
  Scr_AddArray(scrContext);
  Scr_AddFloat(scrContext, level.worldspawnSunColor.v[1]);
  Scr_AddArray(scrContext);
  Scr_AddFloat(scrContext, level.worldspawnSunColor.v[2]);
  Scr_AddArray(scrContext);
  Scr_AddFloat(scrContext, level.worldspawnSunLight);
  Scr_AddArray(scrContext);
}

/*
==============
Scr_SetSunColorAndIntensity
==============
*/
void Scr_SetSunColorAndIntensity(scrContext_t *scrContext)
{
  unsigned int v2; 
  unsigned int v3; 
  double v4; 
  float v5; 
  double v6; 
  float v7; 
  double v8; 
  float v9; 
  float v10; 
  float v11; 
  float v12; 
  double v13; 
  double Float; 
  float v15; 
  double v16; 
  float v17; 
  double v18; 
  float v19; 
  float v20; 
  const char *v21; 
  vec3_t color; 

  v2 = Scr_GetNumParam(scrContext) - 1;
  if ( v2 )
  {
    v3 = v2 - 2;
    if ( !v3 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v15 = *(float *)&Float;
      v16 = Scr_GetFloat(scrContext, 1u);
      v17 = *(float *)&v16;
      v18 = Scr_GetFloat(scrContext, 0);
      color.v[0] = *(float *)&v18;
      color.v[1] = v17;
      color.v[2] = v15;
      GammaToLinearColor_Srgb(&color);
      v9 = color.v[1];
      v10 = color.v[0];
      v11 = color.v[2];
      v19 = (float)((float)(color.v[1] * 0.71520001) + (float)(color.v[0] * 0.21259999)) + (float)(color.v[2] * 0.0722);
      if ( v19 > 0.0 )
      {
        v10 = color.v[0] * (float)(1.0 / v19);
        v9 = color.v[1] * (float)(1.0 / v19);
        v11 = color.v[2] * (float)(1.0 / v19);
      }
      v20 = level.overrideSunColorAndIntensity.v[3];
      level.overrideSunColorAndIntensity.v[0] = v10;
      level.overrideSunColorAndIntensity.v[1] = v9;
      level.overrideSunColorAndIntensity.v[2] = v11;
      goto LABEL_13;
    }
    if ( v3 != 1 )
    {
      Scr_Error(COM_ERR_2182, scrContext, "Incorrect number of paramters\n");
      return;
    }
    v4 = Scr_GetFloat(scrContext, 2u);
    v5 = *(float *)&v4;
    v6 = Scr_GetFloat(scrContext, 1u);
    v7 = *(float *)&v6;
    v8 = Scr_GetFloat(scrContext, 0);
    color.v[0] = *(float *)&v8;
    color.v[1] = v7;
    color.v[2] = v5;
    GammaToLinearColor_Srgb(&color);
    v9 = color.v[1];
    v10 = color.v[0];
    v11 = color.v[2];
    v12 = (float)((float)(color.v[1] * 0.71520001) + (float)(color.v[0] * 0.21259999)) + (float)(color.v[2] * 0.0722);
    if ( v12 > 0.0 )
    {
      v10 = color.v[0] * (float)(1.0 / v12);
      v9 = color.v[1] * (float)(1.0 / v12);
      v11 = color.v[2] * (float)(1.0 / v12);
    }
    v13 = Scr_GetFloat(scrContext, 3u);
    level.overrideSunColorAndIntensity.v[0] = v10;
    level.overrideSunColorAndIntensity.v[1] = v9;
    level.overrideSunColorAndIntensity.v[2] = v11;
  }
  else
  {
    v10 = level.overrideSunColorAndIntensity.v[0];
    v9 = level.overrideSunColorAndIntensity.v[1];
    v11 = level.overrideSunColorAndIntensity.v[2];
    v13 = Scr_GetFloat(scrContext, 0);
  }
  v20 = *(float *)&v13 * 0.31830987;
  level.overrideSunColorAndIntensity.v[3] = *(float *)&v13 * 0.31830987;
LABEL_13:
  v21 = j_va("%g %g %g %g", v10, v9, v11, v20);
  SV_SetConfigstring(0, v21);
}

/*
==============
Scr_GetMapSunDirection
==============
*/
void Scr_GetMapSunDirection(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2184, scrContext, "Incorrect number of parameters\n");
  Scr_AddVector(scrContext, level.mapSunDirection.v);
}

/*
==============
Scr_GetMapSunAngles
==============
*/
void Scr_GetMapSunAngles(scrContext_t *scrContext)
{
  float v2; 
  __int128 v5; 
  __int128 v6; 
  float c; 
  float s[3]; 
  vec3_t forward; 
  vec3_t angles; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2185, scrContext, "Incorrect number of parameters\n");
  forward = level.mapSunDirection;
  v2 = asinf_0(COERCE_FLOAT(LODWORD(level.mapSunDirection.v[2]) ^ _xmm));
  FastSinCos(v2, s, &c);
  _XMM6 = 0i64;
  LODWORD(_XMM2) = 0;
  if ( COERCE_FLOAT(LODWORD(c) & _xmm) > 0.000099999997 )
  {
    v6 = LODWORD(forward.v[0]);
    *(float *)&v6 = forward.v[0] / c;
    v5 = v6;
    *(float *)&v5 = acosf_0(forward.v[0] / c);
    _XMM3 = v5 ^ _xmm;
    __asm
    {
      vcmpless xmm1, xmm6, xmm2
      vblendvps xmm2, xmm3, xmm0, xmm1
    }
  }
  angles.v[0] = v2 * 57.295776;
  angles.v[1] = *(float *)&_XMM2 * 57.295776;
  angles.v[2] = 0.0;
  AngleVectors(&angles, &forward, NULL, NULL);
  if ( !VecNCompareCustomEpsilon(forward.v, level.mapSunDirection.v, 0.001, 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 6094, ASSERT_TYPE_ASSERT, "(Vec3CompareCustomEpsilon( sunDirection, level.mapSunDirection, 0.001f ))", (const char *)&queryFormat, "Vec3CompareCustomEpsilon( sunDirection, level.mapSunDirection, EQUAL_EPSILON )") )
    __debugbreak();
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
Scr_SetSunDirection
==============
*/
void Scr_SetSunDirection(scrContext_t *scrContext)
{
  __int128 v2; 
  const char *v6; 
  __int128 vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2186, scrContext, "Incorrect number of parameters\n");
  Scr_GetVector(scrContext, 0, (vec3_t *)&vectorValue);
  v2 = (unsigned int)vectorValue;
  *(float *)&v2 = fsqrt((float)((float)(*(float *)&v2 * *(float *)&v2) + (float)(*((float *)&vectorValue + 1) * *((float *)&vectorValue + 1))) + (float)(*((float *)&vectorValue + 2) * *((float *)&vectorValue + 2)));
  _XMM3 = v2;
  __asm
  {
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm1, xmm0
  }
  *((float *)&vectorValue + 1) = *((float *)&vectorValue + 1) * (float)(1.0 / *(float *)&_XMM0);
  *(float *)&vectorValue = *(float *)&vectorValue * (float)(1.0 / *(float *)&_XMM0);
  *((float *)&vectorValue + 2) = *((float *)&vectorValue + 2) * (float)(1.0 / *(float *)&_XMM0);
  v6 = j_va("%g %g %g", *(float *)&vectorValue, *((float *)&vectorValue + 1), *((float *)&vectorValue + 2), vectorValue);
  SV_SetConfigstring(0xFF0u, v6);
}

/*
==============
Scr_LerpSunDirection
==============
*/
void Scr_LerpSunDirection(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  bool v4; 
  __int128 v5; 
  float v9; 
  float v10; 
  __int128 v11; 
  float v12; 
  float v16; 
  float v17; 
  float v18; 
  const char *v19; 
  vec3_t vectorValue; 
  vec3_t v21; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_2187, scrContext, "Incorrect number of parameters\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &v21);
  Float = Scr_GetFloat(scrContext, 2u);
  v3 = *(float *)&Float;
  v4 = *(float *)&Float <= 0.001;
  v5 = LODWORD(vectorValue.v[0]);
  *(float *)&v5 = fsqrt((float)((float)(*(float *)&v5 * *(float *)&v5) + (float)(vectorValue.v[1] * vectorValue.v[1])) + (float)(vectorValue.v[2] * vectorValue.v[2]));
  _XMM4 = v5;
  __asm
  {
    vcmpless xmm1, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm9, xmm1
  }
  v9 = vectorValue.v[2] * (float)(1.0 / *(float *)&_XMM0);
  v10 = vectorValue.v[0] * (float)(1.0 / *(float *)&_XMM0);
  v11 = LODWORD(v21.v[0]);
  v12 = vectorValue.v[1] * (float)(1.0 / *(float *)&_XMM0);
  *(float *)&v11 = fsqrt((float)((float)(v21.v[0] * v21.v[0]) + (float)(v21.v[1] * v21.v[1])) + (float)(v21.v[2] * v21.v[2]));
  _XMM3 = v11;
  __asm
  {
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm9, xmm0
  }
  v16 = v21.v[0] * (float)(1.0 / *(float *)&_XMM0);
  v17 = v21.v[2] * (float)(1.0 / *(float *)&_XMM0);
  v18 = v21.v[1] * (float)(1.0 / *(float *)&_XMM0);
  v21.v[2] = v17;
  vectorValue.v[0] = v10;
  vectorValue.v[1] = v12;
  vectorValue.v[2] = v9;
  v21.v[0] = v16;
  v21.v[1] = v18;
  if ( v4 )
  {
    Scr_Error(COM_ERR_2188, scrContext, "Lerp time must be greater than 1 ms\n");
    v17 = v21.v[2];
    v18 = v21.v[1];
    v16 = v21.v[0];
    v9 = vectorValue.v[2];
    v12 = vectorValue.v[1];
    v10 = vectorValue.v[0];
  }
  v19 = j_va("%g %g %g %g %g %g %d %d", v10, v12, v9, v16, v18, v17, level.time, (int)(float)((float)(v3 * 1000.0) + (float)level.time));
  SV_SetConfigstring(0xFF0u, v19);
}

/*
==============
Scr_LerpSunAngles
==============
*/
void Scr_LerpSunAngles(scrContext_t *scrContext)
{
  float v2; 
  float v3; 
  int NumParam; 
  double Float; 
  float v6; 
  double v7; 
  double v8; 
  const char *v9; 
  int time; 
  int v11; 
  int v12; 
  int v13; 
  vec3_t v14; 
  vec3_t forward; 
  vec3_t vectorValue; 
  vec3_t angles; 

  v2 = 0.0;
  v3 = 0.0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 3) > 2 )
    Scr_Error(COM_ERR_2189, scrContext, "Incorrect number of parameters: (<angles now>, <angles end>, <lerp time>, [accel time], [decel time])\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &angles);
  AngleVectors(&vectorValue, &forward, NULL, NULL);
  AngleVectors(&angles, &v14, NULL, NULL);
  Float = Scr_GetFloat(scrContext, 2u);
  v6 = *(float *)&Float;
  if ( NumParam > 3 )
  {
    v7 = Scr_GetFloat(scrContext, 3u);
    v2 = *(float *)&v7;
  }
  if ( NumParam > 4 )
  {
    v8 = Scr_GetFloat(scrContext, 4u);
    v3 = *(float *)&v8;
  }
  if ( v6 <= 0.001 )
    Scr_Error(COM_ERR_2190, scrContext, "Lerp time must be greater than 1 ms\n");
  if ( (float)(v3 + v2) > v6 )
    Scr_Error(COM_ERR_2191, scrContext, "Lerp time must be greater than accel and decel time combined\n");
  if ( v2 < 0.0 || v3 < 0.0 )
    Scr_Error(COM_ERR_2192, scrContext, "Neither accel nor decel time can be negative\n");
  v13 = (int)(float)(v3 * 1000.0);
  v12 = (int)(float)(v2 * 1000.0);
  v11 = (int)(float)((float)(v6 * 1000.0) + (float)level.time);
  time = level.time;
  v9 = j_va("%g %g %g %g %g %g %d %d %d %d", forward.v[0], forward.v[1], forward.v[2], v14.v[0], v14.v[1], v14.v[2], time, v11, v12, v13);
  SV_SetConfigstring(0xFF0u, v9);
}

/*
==============
Scr_ResetSunDirection
==============
*/
void Scr_ResetSunDirection(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2193, scrContext, "Incorrect number of parameters\n");
  SV_SetConfigstring(0xFF0u, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_EnableForcedSunShadows
==============
*/
void Scr_EnableForcedSunShadows(scrContext_t *scrContext)
{
  SV_SetConfigstring(0xFF1u, "1");
}

/*
==============
Scr_EnableForcedNoSunShadows
==============
*/
void Scr_EnableForcedNoSunShadows(scrContext_t *scrContext)
{
  SV_SetConfigstring(0xFF1u, "2");
}

/*
==============
Scr_DisableForcedSunShadows
==============
*/
void Scr_DisableForcedSunShadows(scrContext_t *scrContext)
{
  SV_SetConfigstring(0xFF1u, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_EnableOuterSpaceModelLighting
==============
*/
void Scr_EnableOuterSpaceModelLighting(scrContext_t *scrContext)
{
  const char *v2; 
  vec3_t v3; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &v3);
    v2 = j_va("%g %g %g %g %g %g", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2], v3.v[0], v3.v[1], v3.v[2]);
    SV_SetConfigstring(0xFF2u, v2);
  }
  else
  {
    Scr_Error(COM_ERR_2194, scrContext, "Incorrect number of parameters");
  }
}

/*
==============
Scr_DisableOuterSpaceModelLighting
==============
*/
void Scr_DisableOuterSpaceModelLighting(scrContext_t *scrContext)
{
  SV_SetConfigstring(0xFF2u, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_ClearAllCorpses
==============
*/
void Scr_ClearAllCorpses(scrContext_t *scrContext)
{
  G_RemoveActorCorpses(0);
}

/*
==============
GScr_GetEntnum
==============
*/

void __fastcall GScr_GetEntnum(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddInt(scrContext, entref.entnum);
}

/*
==============
GScr_Launch
==============
*/
void GScr_Launch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  float v5; 
  float v6; 
  float v7; 
  const char *v8; 
  float v9; 
  vec3_t vectorValue; 

  Sys_ProfBeginNamedEvent(0xFFFF0000, "GScr_Launch");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2195, scrContext, "Incorrect number of parameters\n");
  Entity = GetEntity(entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  v5 = vectorValue.v[0];
  v6 = vectorValue.v[2];
  v7 = vectorValue.v[1];
  if ( (LODWORD(vectorValue.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[2]) & 0x7F800000) == 2139095040 )
  {
    v8 = j_va("invalid velocity parameter in launch command: %f %f %f", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
    Scr_Error(COM_ERR_2196, scrContext, v8);
    v6 = vectorValue.v[2];
    v7 = vectorValue.v[1];
    v5 = vectorValue.v[0];
  }
  v9 = v5;
  if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || (v9 = v7, (LODWORD(v7) & 0x7F800000) == 2139095040) || (v9 = v6, (LODWORD(v6) & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 6370, ASSERT_TYPE_SANITY, "( !IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] )", v9) )
      __debugbreak();
  }
  Entity->s.lerp.pos.trType = TR_GRAVITY;
  Entity->s.lerp.pos.trTime = level.time;
  Entity->s.lerp.pos.trDelta = vectorValue;
  if ( ((LODWORD(Entity->s.lerp.pos.trDelta.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(Entity->s.lerp.pos.trDelta.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(Entity->s.lerp.pos.trDelta.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 6376, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( ent->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( ent->s.lerp.pos.trDelta )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( ent->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( ent->s.lerp.pos.trDelta )[2] )") )
    __debugbreak();
  Entity->physicsObject = 1;
  SV_LinkEntity(Entity);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_SetSoundBlend
==============
*/
void GScr_SetSoundBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *String; 
  unsigned __int16 v6; 
  const char *v7; 
  unsigned __int16 v8; 
  double Float; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SOUND || Entity->s.lerp.u.anonymous.data[0] )
    Scr_Error(COM_ERR_2197, scrContext, "Entity is not a sound_blend\n");
  String = Scr_GetString(scrContext, 0);
  v6 = G_CStringSP_SoundAliasIndexPermanent(String);
  v7 = Scr_GetString(scrContext, 1u);
  v8 = G_CStringSP_SoundAliasIndexPermanent(v7);
  Float = Scr_GetFloat(scrContext, 2u);
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    Scr_Error(COM_ERR_2198, scrContext, "Lerp must be between 0.0f and 1.0f\n");
  v4->s.lerp.u.turret.gunAngles.v[2] = *(float *)&Float;
  v4->s.lerp.u.player.torsoPitchPacked = v6;
  v4->s.lerp.u.actor.lookAtEntityNum = v8;
  *(_QWORD *)&v4->s.lerp.u.scriptMover.animIndex = 0i64;
}

/*
==============
GScr_SetDebugOrigin
==============
*/
void GScr_SetDebugOrigin(scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  CG_SetDebugOrigin(&vectorValue);
}

/*
==============
GScr_SetDebugAngles
==============
*/
void GScr_SetDebugAngles(scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  CG_SetDebugAngles(&vectorValue);
}

/*
==============
ScrCmd_UpdateGamerProfile
==============
*/
void ScrCmd_UpdateGamerProfile(scrContext_t *scrContext)
{
  LocalClientNum_t OnlyLocalClientNum; 

  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  Cbuf_AddText(OnlyLocalClientNum, "UpdateGamerProfile\n");
}

/*
==============
ScrCmd_UpdateGamerProfileAll
==============
*/
void ScrCmd_UpdateGamerProfileAll(scrContext_t *scrContext)
{
  LocalClientNum_t OnlyLocalClientNum; 
  unsigned int ControllerFromClient; 
  const char *v3; 
  LocalClientNum_t v4; 

  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  ControllerFromClient = CL_Mgr_GetControllerFromClient(OnlyLocalClientNum);
  v3 = j_va("UpdateGamerProfile %d\n", ControllerFromClient);
  v4 = CL_GetOnlyLocalClientNum();
  Cbuf_AddText(v4, v3);
}

/*
==============
GScr_ForceDeathFall
==============
*/
void GScr_ForceDeathFall(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity->actor )
    Scr_Error(COM_ERR_2200, scrContext, "ForceDeathFall only supports actor entities.\n");
  if ( Scr_GetInt(scrContext, 0) )
  {
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::SetFlagInternal(&Entity->flags, ACTIVE, 0x23u);
  }
  else
  {
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(&Entity->flags, ACTIVE, 0x23u);
  }
}

/*
==============
GScr_MainSP_StartRagdoll
==============
*/
void GScr_MainSP_StartRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_StartRagdollInternal(Entity, 1);
}

/*
==============
GScr_StartRagdollFromImpact
==============
*/
void GScr_StartRagdollFromImpact(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  hitLocation_t HitLocationIndexFromString; 
  bool v6; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_ParamError(COM_ERR_2205, scrContext, 0, "GScr_StartRagdollFromImpact requires at least 2 parameters.");
  if ( ((Entity->s.eType - 19) & 0xFFFD) != 0 )
    Scr_ParamError(COM_ERR_2206, scrContext, 0, "GScr_StartRagdollFromImpact must be called on an actor.");
  ConstString = Scr_GetConstString(scrContext, 0);
  HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
  if ( HitLocationIndexFromString == HITLOC_NONE && ConstString != scr_const.none )
    Scr_Error(COM_ERR_2207, scrContext, "HitLoc parameter must be a valid hit location string e.g. 'torso_upper'\n");
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Entity->s.lerp.u.anonymous.data[2] = HitLocationIndexFromString;
  Entity->s.lerp.u.actor.impactVector = vectorValue;
  v6 = 1;
  if ( Scr_GetNumParam(scrContext) > 2 )
    v6 = Scr_GetInt(scrContext, 2u) != 0;
  GScr_StartRagdollInternal(Entity, v6);
}

/*
==============
GScr_ClearLocalizedStrings
==============
*/
void GScr_ClearLocalizedStrings(scrContext_t *scrContext)
{
  unsigned int ArrayObject; 

  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  Scr_AddArrayKeys(scrContext, ArrayObject);
}

/*
==============
GScr_notifyOnCommand
==============
*/
void GScr_notifyOnCommand(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2208, scrContext, "USAGE: notifyOnCommand( <notify>, <command> )\n");
  String = Scr_GetString(scrContext, 0);
  v3 = Scr_GetString(scrContext, 1u);
  Cmd_RegisterNotification(-1, v3, String);
}

/*
==============
Scr_GetTimeSinceLastPaused
==============
*/
void Scr_GetTimeSinceLastPaused(scrContext_t *scrContext)
{
  int TimeSincePaused; 

  if ( sv_demo.playing )
  {
    TimeSincePaused = SV_DemoSP_GetTimeSincePaused();
  }
  else
  {
    TimeSincePaused = level.time - level.timeAtLastPause;
    SV_DemoSP_RecordTimeSincePaused(level.time - level.timeAtLastPause);
  }
  Scr_AddInt(scrContext, TimeSincePaused);
}

/*
==============
GScr_SetLaserMaterial
==============
*/
void GScr_SetLaserMaterial(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_PARACHUTE_IDLE|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 6791, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_CUSTOMIZED_LASER ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_CUSTOMIZED_LASER )") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2210, scrContext, "SetLaserMaterial takes two parameters (laser material name, light material name)");
  String = Scr_GetString(scrContext, 0);
  v3 = Scr_GetString(scrContext, 1u);
  v4 = j_va("%s %s", String, v3);
  SV_SetConfigstring(0xCu, v4);
}

/*
==============
GScr_PushPlayerVector
==============
*/
void GScr_PushPlayerVector(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  float *p_commandTime; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  if ( !Com_GameMode_SupportsFeature(WEAPONSTATES_NUM) )
    Scr_Error(COM_ERR_2211, scrContext, "PushPlayerVector is not supported in this game mode");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_ObjectError(COM_ERR_2212, scrContext, "PushPlayerVector must be called on a player entity");
    return;
  }
  if ( Scr_GetType(scrContext, 0) != VAR_VECTOR )
  {
    Scr_ParamError(COM_ERR_2213, scrContext, 0, "PushPlayerVector first parameter must be a vector");
    return;
  }
  Scr_GetVector(scrContext, 0, &Entity->client->ps.pushVector);
  p_commandTime = (float *)&Entity->client->ps.commandTime;
  p_commandTime[5277] = 60.0 * p_commandTime[5277];
  p_commandTime[5278] = 60.0 * p_commandTime[5278];
  p_commandTime[5279] = 60.0 * p_commandTime[5279];
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    if ( Scr_GetType(scrContext, 1u) != VAR_INTEGER )
    {
      Scr_ParamError(COM_ERR_2214, scrContext, 0, "PushPlayerVector second parameter must be a boolean");
      return;
    }
    Int = Scr_GetInt(scrContext, 1u);
    p_otherFlags = &Entity->client->ps.otherFlags;
    if ( Int )
    {
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(p_otherFlags, TURRET_ACTIVE_REMOTE|0x20);
      return;
    }
  }
  else
  {
    p_otherFlags = &Entity->client->ps.otherFlags;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(p_otherFlags, TURRET_ACTIVE_REMOTE|0x20);
}

/*
==============
Scr_IsEnemyAware
==============
*/
void Scr_IsEnemyAware(scrContext_t *scrContext, scr_entref_t entref)
{
  actor_s *actor; 

  actor = GetEntity(entref)->actor;
  if ( !actor )
    Scr_Error(COM_ERR_2215, scrContext, "IsEnemyAware only supports actor entities.\n");
  Scr_AddBool(scrContext, actor->combat.alertLevel >= AI_ALERTNESS_ALERT);
}

/*
==============
Scr_HasEnemyBeenSeen
==============
*/
void Scr_HasEnemyBeenSeen(scrContext_t *scrContext, scr_entref_t entref)
{
  actor_s *actor; 
  int Int; 
  bool HasBeenSeenByPlayerWithin; 

  actor = GetEntity(entref)->actor;
  if ( !actor )
    Scr_Error(COM_ERR_2216, scrContext, "HasEnemyBeenSeen only supports actor entities.\n");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2217, scrContext, "HasEnemyBeenSeen takes a single parameter (time in ms).\n");
  Int = Scr_GetInt(scrContext, 0);
  HasBeenSeenByPlayerWithin = G_ActorVisSP_HasBeenSeenByPlayerWithin(actor, Int);
  Scr_AddBool(scrContext, HasBeenSeenByPlayerWithin);
}

/*
==============
Scr_SpeechEnableGrammar
==============
*/
void Scr_SpeechEnableGrammar(scrContext_t *scrContext)
{
  ;
}

/*
==============
Scr_SpeechEnable
==============
*/
void Scr_SpeechEnable(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_SetHUDDynLight
==============
*/
void GScr_SetHUDDynLight(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  const char *v7; 
  const char *v8; 
  unsigned int clientNum; 
  SvClient *CommonClient; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7061, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2218, scrContext, "Wrong number of parameters to SetHUDDynLight( <fade time>, <color> )");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int <= 0 )
    Int = 1;
  Scr_GetVector(scrContext, 1u, &vectorValue);
  if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7071, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
    __debugbreak();
  v7 = j_va("%s %d %f %f %f", "set_hud_dyn", (unsigned int)Int, vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
  v8 = v7;
  clientNum = v4->client->ps.clientNum;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v7);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v8);
  }
}

/*
==============
GScr_SetSunFlarePosition
==============
*/
void GScr_SetSunFlarePosition(scrContext_t *scrContext)
{
  const char *v1; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v1 = j_va("%g %g %g", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
  SV_SetConfigstring(0xFEFu, v1);
}

/*
==============
GScr_SetMotionTrackerVisible
==============
*/
void GScr_SetMotionTrackerVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    Scr_Error(COM_ERR_2219, scrContext, "May not call SetMotionTrackerVisible on a player.");
  if ( Entity->actor )
    Scr_Error(COM_ERR_2220, scrContext, "May not call SetMotionTrackerVisible on an actor.");
  Int = Scr_GetInt(scrContext, 0);
  p_eFlags = &Entity->s.lerp.eFlags;
  if ( Int )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagStrict(p_eFlags, FOG_SCALE|AIM_ASSIST);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagStrict(p_eFlags, FOG_SCALE|AIM_ASSIST);
}

/*
==============
GScr_GetMotionTrackerVisible
==============
*/
void GScr_GetMotionTrackerVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    Scr_Error(COM_ERR_2221, scrContext, "May not call GetMotionTrackerVisible on a player.");
  if ( Entity->actor )
    Scr_Error(COM_ERR_2222, scrContext, "May not call GetMotionTrackerVisible on an actor.");
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 127, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  v4 = GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Au);
  Scr_AddBool(scrContext, v4);
}

/*
==============
GScr_AddOnToViewModel
==============
*/
void GScr_AddOnToViewModel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int NumParam; 
  const char *String; 
  const char *v6; 
  unsigned int ModelIndex; 
  const char *v8; 
  const char *v9; 
  unsigned int v10; 
  const char *v11; 
  vec3_t v12; 
  vec3_t vectorValue; 
  char dest[1024]; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7182, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_2223, scrContext, "AddOnToViewModel called on an ent that's not a player.");
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 2 )
    Scr_Error(COM_ERR_2224, scrContext, "AddOnToViewModel needs a model name and bone name.");
  String = Scr_GetString(scrContext, 0);
  Core_strcpy(dest, 0x400ui64, String);
  v6 = I_strlwr(dest);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  ModelIndex = GConfigStrings::GetModelIndex(GConfigStrings::ms_gConfigStrings, v6);
  v8 = Scr_GetString(scrContext, 1u);
  Core_strcpy(dest, 0x400ui64, v8);
  v9 = I_strlwr(dest);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v10 = GConfigStrings::ms_gConfigStrings->GetClientTagIndex(GConfigStrings::ms_gConfigStrings, v9);
  vectorValue.v[0] = 0.0;
  vectorValue.v[1] = 0.0;
  vectorValue.v[2] = 0.0;
  v12.v[0] = 0.0;
  v12.v[1] = 0.0;
  v12.v[2] = 0.0;
  if ( NumParam > 2 )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    if ( NumParam > 3 )
      Scr_GetVector(scrContext, 3u, &v12);
  }
  v11 = j_va("addviewmodel %d %d %f %f %f %f %f %f", ModelIndex, v10, vectorValue.v[0], vectorValue.v[1], vectorValue.v[2], v12.v[0], v12.v[1], v12.v[2]);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
}

/*
==============
GScr_ClearViewModelAddOns
==============
*/
void GScr_ClearViewModelAddOns(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v2; 

  v2 = j_va("clearviewmodels", entref);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v2);
}

/*
==============
ScrCmd_PlayerLinkedTurretAnglesEnable
==============
*/
void ScrCmd_PlayerLinkedTurretAnglesEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7242, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_2225, scrContext, "Player is not linked.");
  client = v4->client;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  client->ps.linkFlags.m_flags[0] |= 0x80u;
}

/*
==============
ScrCmd_PlayerLinkedTurretAnglesDisable
==============
*/
void ScrCmd_PlayerLinkedTurretAnglesDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7260, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_2226, scrContext, "Player is not linked.");
  client = v4->client;
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  client->ps.linkFlags.m_flags[0] &= ~0x80u;
}

/*
==============
ScrCmd_PlayerLinkedUseLinkedVelocity
==============
*/
void ScrCmd_PlayerLinkedUseLinkedVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7281, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_2227, scrContext, "Player is not linked.");
  Int = Scr_GetInt(scrContext, 0);
  client = v4->client;
  if ( Int )
  {
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    client->ps.linkFlags.m_flags[0] |= 0x100u;
  }
  else
  {
    if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
      __debugbreak();
    client->ps.linkFlags.m_flags[0] &= ~0x100u;
  }
}

/*
==============
ScrCmd_PlayerSetStreamOrigin
==============
*/
void ScrCmd_PlayerSetStreamOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  signed int number; 
  BgWorldStreamingViewType v7; 
  int keepAlive; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7310, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  number = v4->s.number;
  if ( number >= 2 )
    Scr_Error(COM_ERR_2228, scrContext, "Invalid entity to set a streaming origin on");
  Scr_GetVector(scrContext, 0, &vectorValue);
  keepAlive = Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) != 0;
  LOBYTE(v7) = 1;
  G_WorldStreaming_SetNextStreamPosition(number, v7, LINEAR, &vectorValue, NULL, keepAlive);
}

/*
==============
ScrCmd_PlayerClearStreamOrigin
==============
*/
void ScrCmd_PlayerClearStreamOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  signed int number; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7350, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  number = v4->s.number;
  if ( number >= 2 )
    Scr_Error(COM_ERR_5636, scrContext, "Invalid entity to clear streaming origin");
  LOBYTE(entref.entnum) = 1;
  G_WorldStreaming_ClearNextStreamView(number, (const BgWorldStreamingViewType)entref.entnum);
}

/*
==============
ScrCmd_LinkToPlayerView
==============
*/
void ScrCmd_LinkToPlayerView(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  gentity_s *Entity; 
  gentity_s *v6; 
  ViewLinkedData *inited; 
  scr_string_t ConstLowercaseString; 
  scr_string_t ConstString; 

  NumParam = Scr_GetNumParam(scrContext);
  Entity = GScr_GetEntity(0);
  v6 = GetEntity(entref);
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FAST_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2235, scrContext, "This game mode does not support view linked entities");
  inited = GSCr_MainSP_InitNewViewLinkedData(scrContext, Entity, v6);
  if ( inited )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    Scr_SetString(&inited->linkedTag, ConstLowercaseString);
    Scr_GetVector(scrContext, 2u, &inited->posOffset);
    Scr_GetVector(scrContext, 3u, &inited->angleOffset);
    if ( Scr_GetInt(scrContext, 4u) )
      inited->flags |= 1u;
    if ( NumParam > 5 )
    {
      ConstString = Scr_GetConstString(scrContext, 5u);
      if ( ConstString == scr_const.view_jostle )
      {
        inited->flags |= 0x10u;
      }
      else if ( ConstString != scr_const.none )
      {
        Scr_Error(COM_ERR_2236, scrContext, "Unrecognized proceduralMotion type provided to LinkToPlayerView().");
      }
    }
  }
  EntHandle::setEnt(&v6->r.ownerNum, Entity);
}

/*
==============
ScrCmd_LinkToPlayerViewIgnoreParentRot
==============
*/
void ScrCmd_LinkToPlayerViewIgnoreParentRot(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  gentity_s *Entity; 
  const gentity_s *v6; 
  ViewLinkedData *inited; 
  scr_string_t ConstLowercaseString; 
  scr_string_t ConstString; 

  NumParam = Scr_GetNumParam(scrContext);
  Entity = GScr_GetEntity(0);
  v6 = GetEntity(entref);
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FAST_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2237, scrContext, "This game mode does not support view linked entities");
  inited = GSCr_MainSP_InitNewViewLinkedData(scrContext, Entity, v6);
  if ( inited )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    Scr_SetString(&inited->linkedTag, ConstLowercaseString);
    Scr_GetVector(scrContext, 2u, &inited->posOffset);
    Scr_GetVector(scrContext, 3u, &inited->angleOffset);
    if ( Scr_GetInt(scrContext, 4u) )
      inited->flags |= 2u;
    if ( Scr_GetInt(scrContext, 5u) )
      inited->flags |= 4u;
    if ( Scr_GetInt(scrContext, 6u) )
      inited->flags |= 8u;
    if ( Scr_GetInt(scrContext, 7u) )
      inited->flags |= 1u;
    if ( NumParam > 8 )
    {
      ConstString = Scr_GetConstString(scrContext, 8u);
      if ( ConstString == scr_const.view_jostle )
      {
        inited->flags |= 0x10u;
      }
      else if ( ConstString != scr_const.none )
      {
        Scr_Error(COM_ERR_2238, scrContext, "Unrecognized proceduralMotion type provided to LinkToPlayerView().");
      }
    }
  }
}

/*
==============
ScrCmd_BlendLinkToPlayerViewMotion
==============
*/
void ScrCmd_BlendLinkToPlayerViewMotion(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  double Float; 
  int Int; 
  gclient_s *client; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FAST_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2239, scrContext, "This game mode does not support view linked entities");
  Entity = GetEntity(entref);
  v5 = Entity;
  if ( !Entity || !Entity->client )
    Scr_Error(COM_ERR_2240, scrContext, "BlendLinkToPlayerViewMotion() must be called on a player entity.");
  Float = Scr_GetFloat(scrContext, 0);
  Int = Scr_GetInt(scrContext, 1u);
  client = v5->client;
  client->ps.viewLinkedBlendStart = level.time;
  client->ps.viewLinkedBlendDuration = (int)(float)(*(float *)&Float * 1000.0);
  client->ps.viewLinkedBlendOut = Int == 0;
}

/*
==============
ScrCmd_LinkToPlayerViewFollowRemoteEyes
==============
*/
void ScrCmd_LinkToPlayerViewFollowRemoteEyes(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gclient_s *client; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FAST_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2241, scrContext, "This game mode does not support view linked entities");
  Entity = GetEntity(entref);
  v5 = Entity;
  if ( !Entity || !Entity->client )
    Scr_Error(COM_ERR_2242, scrContext, "LinkToPlayerViewFollowRemoteEyes() must be called on a player entity.");
  client = v5->client;
  client->ps.viewLinkEntsFollowRemoteEyes = Scr_GetInt(scrContext, 0) != 0;
}

/*
==============
ScrCmd_UnlinkFromPlayerView
==============
*/
void ScrCmd_UnlinkFromPlayerView(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 

  Entity = GScr_GetEntity(0);
  v5 = GetEntity(entref);
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FAST_LAND|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2243, scrContext, "This game mode does not support view linked entities");
  GSCr_MainSP_UnlinkFromPlayerView(scrContext, Entity, v5);
}

/*
==============
GScr_MainSP_Delete
==============
*/
void GScr_MainSP_Delete(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *ViewLinkedParent; 

  switch ( entref.entclass )
  {
    case ENTITY_CLASS_FXENTITY:
      ScrCmd_FXEntityDelete(entref);
      break;
    case ENTITY_CLASS_SOUNDENTITY:
      ScrCmd_SoundEntity_Delete(scrContext, entref);
      break;
    case ENTITY_CLASS_SPAWNER:
      G_Spawner_Delete(entref.entnum);
      break;
    default:
      Entity = GetEntity(entref);
      ViewLinkedParent = GSCr_MainSP_GetViewLinkedParent(Entity->s.number);
      if ( ViewLinkedParent )
        GSCr_MainSP_UnlinkFromPlayerView(scrContext, ViewLinkedParent, Entity);
      GScr_Main_DeleteCommon(scrContext, Entity);
      break;
  }
}

/*
==============
GScr_MainSP_ScalePitch
==============
*/
void GScr_MainSP_ScalePitch(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_MainSP_ParseChangeSoundParameterCommand(scrContext, entref, 201, "ScalePitch", 4.0);
}

/*
==============
GScr_MainSP_ScaleVolume
==============
*/
void GScr_MainSP_ScaleVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_MainSP_ParseChangeSoundParameterCommand(scrContext, entref, 202, "ScaleVolume", 4.0);
}

/*
==============
GScr_MainSP_GetPlayerIntelIsFound
==============
*/
void GScr_MainSP_GetPlayerIntelIsFound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int Int; 
  int ControllerFromClient; 
  bool IsFound; 
  int number; 
  int v8; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2249, scrContext, "Must be called on a client entity.");
  if ( PlayerEntity->s.number != SvClientSP::GetSpClientNum() )
    Scr_Error(COM_ERR_2250, scrContext, "Non local players are not supported for this call.");
  Int = Scr_GetInt(scrContext, 0);
  if ( PlayerEntity->s.number >= 2u )
  {
    v8 = 2;
    number = PlayerEntity->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7862, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", number, v8) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  IsFound = GamerProfile_GetPlayerIntelIsFound(ControllerFromClient, Int);
  Scr_AddBool(scrContext, IsFound);
}

/*
==============
GScr_MainSP_SetPlayerIntelFound
==============
*/
void GScr_MainSP_SetPlayerIntelFound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int Int; 
  int ControllerFromClient; 
  int number; 
  int v7; 
  int *cheat_items_set2; 
  int *cheat_items_set1; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2251, scrContext, "Must be called on a client entity.");
  if ( PlayerEntity->s.number != SvClientSP::GetSpClientNum() )
    Scr_Error(COM_ERR_2252, scrContext, "Non local players are not supported for this call.");
  Int = Scr_GetInt(scrContext, 0);
  if ( PlayerEntity->s.number >= 2u )
  {
    v7 = 2;
    number = PlayerEntity->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7897, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", number, v7) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  GamerProfile_SetPlayerIntelFound(ControllerFromClient, Int);
  GamerProfile_GetIntelligencePtr(ControllerFromClient, &cheat_items_set1, &cheat_items_set2);
  SV_DemoSP_RecordIntelligence(ControllerFromClient, cheat_items_set1, cheat_items_set2);
}

/*
==============
GScr_MainSP_GetPlayerYoloState
==============
*/
void GScr_MainSP_GetPlayerYoloState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int number; 
  int ControllerFromClient; 
  int YoloState; 
  int v7; 
  int v8; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2253, scrContext, "Must be called on a client entity.");
  number = PlayerEntity->s.number;
  if ( number != SvClientSP::GetSpClientNum() )
  {
    Scr_Error(COM_ERR_2254, scrContext, "Non local players are not supported for this call.");
    LOWORD(number) = PlayerEntity->s.number;
  }
  if ( (unsigned __int16)number >= 2u )
  {
    v8 = 2;
    v7 = (__int16)number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7935, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  YoloState = GamerProfile_GetYoloState(ControllerFromClient);
  Scr_AddInt(scrContext, YoloState);
}

/*
==============
GScr_MainSP_SetPlayerYoloState
==============
*/
void GScr_MainSP_SetPlayerYoloState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  unsigned int Int; 
  int v5; 
  const char *v6; 
  int ControllerFromClient; 
  int number; 
  int v9; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2255, scrContext, "Must be called on a client entity.");
  if ( PlayerEntity->s.number != SvClientSP::GetSpClientNum() )
    Scr_Error(COM_ERR_2256, scrContext, "Non local players are not supported for this call.");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( Int > 3 )
  {
    v6 = j_va("SetYoloState must be provided a state between 0-3 inclusive, recieved %d", Int);
    Scr_ParamError(COM_ERR_2257, scrContext, 0, v6);
  }
  if ( PlayerEntity->s.number >= 2u )
  {
    v9 = 2;
    number = PlayerEntity->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7974, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", number, v9) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  GamerProfile_SetYoloState(ControllerFromClient, v5);
}

/*
==============
GScr_MainSP_EnableAimAssist
==============
*/
void GScr_MainSP_EnableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  entityType_s eType; 

  Entity = GetEntity(entref);
  eType = Entity->s.eType;
  if ( eType != ET_SCRIPTMOVER && Entity->r.modelType != 5 && eType != ET_TURRET )
    Scr_Error(COM_ERR_2258, scrContext, "Currently only supported on script movers and entities with brush models");
  if ( Entity->health <= 0 )
    Com_PrintWarning(16, "Enabling aim assist on an entity %d with no health will have no effect in game.", (unsigned int)Entity->s.number);
  GScr_Main_EnableAimAssistCommon(Entity);
}

/*
==============
GScr_MainSP_DisableAimAssist
==============
*/
void GScr_MainSP_DisableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SCRIPTMOVER && Entity->r.modelType != 5 )
    Scr_Error(COM_ERR_2259, scrContext, "Currently only supported on script movers and entities with brush models");
  GScr_Main_DisableAimAssistCommon(v4);
}

/*
==============
GScr_MainSP_GetLocalPlayerProfileData
==============
*/
void GScr_MainSP_GetLocalPlayerProfileData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  const char *String; 
  int ControllerFromClient; 
  const char *v6; 
  ComErrorCode v7; 
  int number; 
  int v9; 
  GamerProfileData outProfileData; 
  GamerProfileData result; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2260, scrContext, "GetLocalPlayerProfileData() must be called on a client entity\n");
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_2261, scrContext, "GetLocalPlayerProfileData() requires the name of the setting\n");
  String = Scr_GetString(scrContext, 0);
  if ( PlayerEntity->s.number >= 2u )
  {
    v9 = 2;
    number = PlayerEntity->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8041, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", number, v9) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  outProfileData = *GamerProfile_GetDataByName(&result, ControllerFromClient, String);
  if ( g_archiveGetDvar )
  {
    if ( SV_IsDemoPlaying() )
      SV_Game_GetDemo_PlayerProfileData(String, &outProfileData);
    else
      SV_Game_RecordDemo_GetPlayerProfileData(String, &outProfileData);
  }
  switch ( outProfileData.type )
  {
    case TYPE_BYTE:
      Scr_AddInt(scrContext, outProfileData.u.byteVal);
      break;
    case TYPE_BOOL:
      Scr_AddBool(scrContext, outProfileData.u.byteVal);
      break;
    case TYPE_SHORT:
      Scr_AddInt(scrContext, outProfileData.u.shortVal);
      break;
    case TYPE_INT:
    case TYPE_FLAG:
      Scr_AddInt(scrContext, outProfileData.u.intVal);
      break;
    case TYPE_FLOAT:
      Scr_AddFloat(scrContext, outProfileData.u.floatVal);
      break;
    case TYPE_STRING:
      Scr_AddString(scrContext, outProfileData.u.stringVal);
      break;
    case TYPE_BUFFER:
      v6 = "Cannot get buffer from profile";
      v7 = COM_ERR_2262;
      goto LABEL_21;
    default:
      v6 = j_va("Invalid profile data %s for GetLocalPlayerProfileData()", String);
      v7 = COM_ERR_2263;
LABEL_21:
      Scr_Error(v7, scrContext, v6);
      break;
  }
}

/*
==============
GScr_MainSP_SetLocalPlayerProfileData
==============
*/
void GScr_MainSP_SetLocalPlayerProfileData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  const char *String; 
  int DataIndexByName; 
  const char *v6; 
  double Float; 
  const char *v8; 
  ComErrorCode v9; 
  int ControllerFromClient; 
  int number; 
  int v12; 
  GamerProfileData v13; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2264, scrContext, "SetLocalPlayerProfileData() must be called on a client entity\n");
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_2265, scrContext, "SetLocalPlayerProfileData() requires the name of the setting and value\n");
  String = Scr_GetString(scrContext, 0);
  DataIndexByName = GamerProfile_GetDataIndexByName(String);
  if ( DataIndexByName < 0 )
  {
    v6 = j_va("invalid setting %s for SetLocalPlayerProfileData()", String);
    Scr_Error(COM_ERR_2266, scrContext, v6);
  }
  v13.type = GamerProfile_GetDataType(DataIndexByName);
  switch ( v13.type )
  {
    case TYPE_BYTE:
      v13.u.byteVal = Scr_GetInt(scrContext, 1u);
      break;
    case TYPE_BOOL:
      v13.u.byteVal = Scr_GetInt(scrContext, 1u) != 0;
      break;
    case TYPE_SHORT:
      v13.u.shortVal = Scr_GetInt(scrContext, 1u);
      break;
    case TYPE_INT:
    case TYPE_FLAG:
      v13.u.intVal = Scr_GetInt(scrContext, 1u);
      break;
    case TYPE_FLOAT:
      Float = Scr_GetFloat(scrContext, 1u);
      v13.u.floatVal = *(float *)&Float;
      break;
    case TYPE_STRING:
      v13.u.stringVal = Scr_GetString(scrContext, 1u);
      break;
    case TYPE_BUFFER:
      v8 = "Cannot set buffer in profile";
      v9 = COM_ERR_2267;
      goto LABEL_16;
    default:
      v8 = "Unsupported data type for SV_Game_RecordDemo_GetPlayerProfileData";
      v9 = COM_ERR_2268;
LABEL_16:
      Scr_Error(v9, scrContext, v8);
      break;
  }
  if ( PlayerEntity->s.number >= 2u )
  {
    v12 = 2;
    number = PlayerEntity->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8174, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", number, v12) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  GamerProfile_SetData(ControllerFromClient, DataIndexByName, &v13);
}

/*
==============
GScr_MainSP_SpringCamEnabled
==============
*/
void GScr_MainSP_SpringCamEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  const char *v8; 
  double Float; 
  double v10; 
  double v11; 
  bool v12; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8212, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2269, scrContext, "SpringCam is not supported in this game mode");
  if ( *((_DWORD *)client + 3) != 1 )
    Scr_Error(COM_ERR_2270, scrContext, "Cannot turn on spring camera unless player is linked.");
  if ( (client[36] & 1) != 0 )
    Scr_Error(COM_ERR_2271, scrContext, "Cannot turn on spring camera when angles are locked.");
  if ( *((float *)client + 129) > 170.0 || *((float *)client + 128) > 170.0 )
  {
    v8 = j_va("Spring camera view range cannot be more than %f.", DOUBLE_170_0);
    Scr_Error(COM_ERR_2272, scrContext, v8);
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2451, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::VIEW_SPRING_CAM ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::VIEW_SPRING_CAM )") )
    __debugbreak();
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 138, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 0x26u);
  Float = Scr_GetFloat(scrContext, 0);
  *((float *)client + 146) = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) <= 1 )
    *(float *)&v10 = FLOAT_3_2;
  else
    v10 = Scr_GetFloat(scrContext, 1u);
  *((float *)client + 144) = *(float *)&v10;
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    *((_DWORD *)client + 145) = 1070386381;
  }
  else
  {
    v11 = Scr_GetFloat(scrContext, 2u);
    v12 = *(float *)&v11 <= *((float *)client + 144);
    *((float *)client + 145) = *(float *)&v11;
    if ( !v12 )
      Scr_Error(COM_ERR_2273, scrContext, "springReleaseLerpSpeed cannot be greater than springLerpSpeed.");
  }
}

/*
==============
GScr_MainSP_SpringCamDisabled
==============
*/
void GScr_MainSP_SpringCamDisabled(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  double Float; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8275, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_2274, scrContext, "SpringCam is not supported in this game mode");
  if ( *((_DWORD *)client + 3) != 1 )
    Scr_Error(COM_ERR_2275, scrContext, "Cannot turn off spring camera unless player is linked.");
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2459, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::VIEW_SPRING_CAM ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::VIEW_SPRING_CAM )") )
    __debugbreak();
  if ( GameModeFlagValues::ms_spValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 149, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a SP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 0x26u);
  Float = Scr_GetFloat(scrContext, 0);
  *((float *)client + 146) = *(float *)&Float;
}

/*
==============
GScr_MainSP_MapRestart
==============
*/
void GScr_MainSP_MapRestart(scrContext_t *scrContext)
{
  Cbuf_AddText(LOCAL_CLIENT_0, "fast_restart\n");
}

/*
==============
GScr_MainSP_LoadLuiFile
==============
*/
void GScr_MainSP_LoadLuiFile(scrContext_t *scrContext)
{
  const char *String; 
  bool LuaFile; 

  String = Scr_GetString(scrContext, 0);
  LUI_EnterCriticalSection("GScr_MainSP_LoadLuiFile");
  LuaFile = LUI_LoadLuaFile(String, LUI_luaVM);
  LUI_LeaveCriticalSection();
  if ( !LuaFile )
    Com_ScriptError("Unable to load LUI lua file %s", String);
}

/*
==============
GScr_MainSP_FinishPlayerDeath
==============
*/
void GScr_MainSP_FinishPlayerDeath(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) == 1 )
  {
    G_ClientSP_Respawn();
    level.bMissionForceFailed = 1;
  }
  else
  {
    level.allowRespawn = 1;
  }
}

/*
==============
GScr_MainSP_GetProgressionData
==============
*/
void GScr_MainSP_GetProgressionData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int number; 
  int ControllerFromClient; 
  const DDLDef *DDLDef; 
  const DDLContext *DDLContext; 
  int firstArgIndex; 
  int v11; 
  DDLState state; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2276, scrContext, "Must be called on a client entity.");
  number = PlayerEntity->s.number;
  if ( number != SvClientSP::GetSpClientNum() )
  {
    Scr_Error(COM_ERR_2277, scrContext, "Non local players are not supported for this call.");
    LOWORD(number) = PlayerEntity->s.number;
  }
  if ( (unsigned __int16)number >= 2u )
  {
    v11 = 2;
    firstArgIndex = (__int16)number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8389, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", firstArgIndex, v11) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  DDLDef = GamerProfile_GetDDLDef(ControllerFromClient, SP_PROGRESSION);
  GamerProfile_GetDDLState(&state, ControllerFromClient, SP_PROGRESSION);
  DDLContext = GamerProfile_GetDDLContext(ControllerFromClient, SP_PROGRESSION);
  DDL_MoveToName(&state, &state, "spData");
  GScr_Main_GetDDL(scrContext, &state, DDLDef, DDLContext, "GetProgressionData", 0);
}

/*
==============
GScr_MainSP_SetProgressionData
==============
*/
void GScr_MainSP_SetProgressionData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int number; 
  int ControllerFromClient; 
  const DDLDef *DDLDef; 
  DDLContext *DDLContext; 
  int firstArgIndex; 
  int v11; 
  DDLState state; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2278, scrContext, "Must be called on a client entity.");
  number = PlayerEntity->s.number;
  if ( number != SvClientSP::GetSpClientNum() )
  {
    Scr_Error(COM_ERR_2279, scrContext, "Non local players are not supported for this call.");
    LOWORD(number) = PlayerEntity->s.number;
  }
  if ( (unsigned __int16)number >= 2u )
  {
    v11 = 2;
    firstArgIndex = (__int16)number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8430, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", firstArgIndex, v11) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  DDLDef = GamerProfile_GetDDLDef(ControllerFromClient, SP_PROGRESSION);
  GamerProfile_GetDDLState(&state, ControllerFromClient, SP_PROGRESSION);
  DDLContext = GamerProfile_GetDDLContext(ControllerFromClient, SP_PROGRESSION);
  DDL_MoveToName(&state, &state, "spData");
  GScr_Main_SetDDL(scrContext, &state, DDLDef, DDLContext, "SetProgressionData", 0);
}

/*
==============
GScr_MainSP_InitPlayerLoadoutNames
==============
*/
void GScr_MainSP_InitPlayerLoadoutNames(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int number; 
  int ControllerFromClient; 
  const DDLDef *DDLDef; 
  DDLContext *DDLContext; 
  const char *String; 
  const char *v11; 
  __int64 v12; 
  char v13; 
  const char *v14; 
  const char *v15; 
  const dvar_t *v16; 
  DDLState state; 
  int finalArgumentIndex; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2280, scrContext, "Must be called on a client entity.");
  number = PlayerEntity->s.number;
  if ( number != SvClientSP::GetSpClientNum() )
  {
    Scr_Error(COM_ERR_2281, scrContext, "Non local players are not supported for this call.");
    LOWORD(number) = PlayerEntity->s.number;
  }
  if ( (unsigned __int16)number >= 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8469, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", (__int16)number, 2) )
    __debugbreak();
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  DDLDef = GamerProfile_GetDDLDef(ControllerFromClient, SP_PROGRESSION);
  GamerProfile_GetDDLState(&state, ControllerFromClient, SP_PROGRESSION);
  DDLContext = GamerProfile_GetDDLContext(ControllerFromClient, SP_PROGRESSION);
  DDL_MoveToName(&state, &state, "spData");
  String = Scr_GetString(scrContext, 0);
  if ( !strcmp_0(String, "loadouts") )
  {
    v11 = Scr_GetString(scrContext, 2u);
    v12 = 0i64;
    while ( 1 )
    {
      v13 = v11[v12++];
      if ( v13 != *((_BYTE *)&stru_143C9A1A4 + v12 - 1) )
        break;
      if ( v12 == 5 )
      {
        finalArgumentIndex = -1;
        GScr_Main_NavigateDDL(scrContext, DDLDef, "SetProgressionData", &state, 0, &finalArgumentIndex);
        if ( finalArgumentIndex != 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8483, ASSERT_TYPE_ASSERT, "(finalArgumentIndex == 3)", (const char *)&queryFormat, "finalArgumentIndex == 3") )
          __debugbreak();
        v14 = Scr_GetString(scrContext, 3u);
        v15 = SEH_StringEd_GetString(v14);
        if ( !v15 )
        {
          v16 = DCONST_DVARBOOL_loc_warnings;
          if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v16);
          if ( v16->current.enabled )
          {
            if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_loc_warningsAsErrors, "loc_warningsAsErrors") )
              Com_Error_impl(ERR_LOCALIZATION, (const ObfuscateErrorText)&stru_144360158, 242i64, v14);
            else
              Com_PrintWarning(17, "Could not translate loadout name \"%s\"", v14);
          }
          v15 = v14;
          if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8498, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
            __debugbreak();
        }
        DDL_SetString(&state, DDLContext, v15);
        return;
      }
    }
  }
}

/*
==============
GScr_MainSP_SendLevelData
==============
*/
void GScr_MainSP_SendLevelData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int number; 
  int ControllerFromClient; 
  const char *String; 
  int Int; 
  int v8; 
  int v9; 
  int v10; 
  int v11; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2282, scrContext, "Must be called on a client entity.");
  number = PlayerEntity->s.number;
  if ( number != SvClientSP::GetSpClientNum() )
  {
    Scr_Error(COM_ERR_2283, scrContext, "Non local players are not supported for this call.");
    LOWORD(number) = PlayerEntity->s.number;
  }
  if ( (unsigned __int16)number >= 2u )
  {
    v11 = 2;
    v10 = (__int16)number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8538, ASSERT_TYPE_ASSERT, "(unsigned)( entPlayer->s.number ) < (unsigned)( 2 )", "entPlayer->s.number doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)PlayerEntity->s.number);
  String = Scr_GetString(scrContext, 0);
  Int = Scr_GetInt(scrContext, 1u);
  v8 = Scr_GetInt(scrContext, 2u);
  v9 = Scr_GetInt(scrContext, 3u);
  Online_Telemetry_SetMissionEndData(ControllerFromClient, String, Int, v8, v9);
}

/*
==============
GScr_MainSP_IsSound3d
==============
*/
void GScr_MainSP_IsSound3d(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 
  const char *v4; 
  bool IsEntChannel3D; 

  String = Scr_GetString(scrContext, 0);
  Alias = SND_FindAlias(String);
  if ( !Alias )
  {
    v4 = j_va("Sound %s was not found.", String);
    Scr_ParamError(COM_ERR_2284, scrContext, 0, v4);
  }
  IsEntChannel3D = SND_IsEntChannel3D((unsigned __int8)(Alias->head->flags >> 10));
  Scr_AddBool(scrContext, IsEntChannel3D);
}

/*
==============
GScr_MainSP_GetDobjCount
==============
*/
void GScr_MainSP_GetDobjCount(scrContext_t *scrContext)
{
  int DobjCount; 

  DobjCount = Com_GetDobjCount();
  Scr_AddInt(scrContext, DobjCount);
}

/*
==============
GScr_MainSP_GetPlayerSetting
==============
*/
void GScr_MainSP_GetPlayerSetting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  const char *String; 
  const char *Demo_PlayerSetting; 
  const dvar_t *v6; 
  const char *v7; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !PlayerEntity->client )
    Scr_Error(COM_ERR_2287, scrContext, "GetPlayerSetting must be called on a client entity\n");
  if ( (int)Scr_GetNumParam(scrContext) < 1 )
    Scr_Error(COM_ERR_2288, scrContext, "GetPlayerSetting() requires the name of the setting\n");
  String = Scr_GetString(scrContext, 0);
  if ( g_archiveGetDvar && SV_IsDemoPlaying() )
  {
    Demo_PlayerSetting = SV_Game_GetDemo_PlayerSetting(String);
  }
  else
  {
    if ( !PlayerEntity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 8622, ASSERT_TYPE_ASSERT, "( ent->client )", (const char *)&queryFormat, "ent->client") )
      __debugbreak();
    if ( I_strnicmp(String, "gameskill", 9ui64) )
    {
      Scr_ParamError(COM_ERR_2285, scrContext, 0, "GetPlayerSetting() only supports the \"gameskill\" setting\n");
      Demo_PlayerSetting = NULL;
    }
    else
    {
      v6 = DVARINT_g_gameskill;
      if ( !DVARINT_g_gameskill && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_gameskill") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v6);
      Demo_PlayerSetting = j_va("%i", v6->current.unsignedInt);
    }
    if ( g_archiveGetDvar && !SV_IsDemoPlaying() )
      SV_Game_RecordDemo_PlayerSetting(String, Demo_PlayerSetting);
  }
  if ( Demo_PlayerSetting )
  {
    Scr_AddString(scrContext, Demo_PlayerSetting);
  }
  else
  {
    v7 = j_va("%s is not a valid setting name!", String);
    Scr_ParamError(COM_ERR_2289, scrContext, 0, v7);
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_SetSpaceGrapple
==============
*/
void ScrCmd_SetSpaceGrapple(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ClearSpaceGrapple
==============
*/
void ScrCmd_ClearSpaceGrapple(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_AbortSpaceJump
==============
*/
void ScrCmd_AbortSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SpaceGrappleAvailable
==============
*/
void ScrCmd_SpaceGrappleAvailable(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddBool(scrContext, 0);
}

/*
==============
ScrCmd_GetSpaceGrappleEntity
==============
*/

void __fastcall ScrCmd_GetSpaceGrappleEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetSpaceGrapplePlatform
==============
*/

void __fastcall ScrCmd_GetSpaceGrapplePlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetSpaceGrappleWalkable
==============
*/
void ScrCmd_GetSpaceGrappleWalkable(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_AllowSpaceGrappleCancel
==============
*/
void ScrCmd_AllowSpaceGrappleCancel(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SpaceGrappleBeginMove
==============
*/
void ScrCmd_SpaceGrappleBeginMove(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetGrappleVolume
==============
*/
void ScrCmd_SetGrappleVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  gentity_s *v5; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  int Int; 
  int v11; 
  unsigned int v12; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  v5 = Entity;
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    Int = Scr_GetInt(scrContext, 0);
    v11 = v5->s.lerp.u.anonymous.data[0];
    if ( Int )
    {
      v12 = v11 & 0xFFFFFFFC | 1;
      v5->r.svFlags &= ~1u;
    }
    else
    {
      v12 = v11 & 0xFFFFFFFE;
    }
    v5->s.lerp.u.anonymous.data[0] = v12;
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(v5->classname);
    v9 = j_va("SetGrappleVolume is only valid on info_volume_grapple; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, v5->r.currentOrigin.v[0], v5->r.currentOrigin.v[1], v5->r.currentOrigin.v[2], v8, v7);
    Scr_Error(COM_ERR_2301, scrContext, v9);
  }
}

/*
==============
ScrCmd_SetGrappleRoundVolume
==============
*/
void ScrCmd_SetGrappleRoundVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  gentity_s *v5; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  int Int; 
  int v11; 
  unsigned int v12; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  v5 = Entity;
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    Int = Scr_GetInt(scrContext, 0);
    v11 = v5->s.lerp.u.anonymous.data[0];
    if ( Int )
    {
      v12 = v11 & 0xFFFFFFFC | 2;
      v5->r.svFlags &= ~1u;
    }
    else
    {
      v12 = v11 & 0xFFFFFFFD;
    }
    v5->s.lerp.u.anonymous.data[0] = v12;
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(v5->classname);
    v9 = j_va("SetGrappleRoundVolume is only valid on info_volume_grapple; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, v5->r.currentOrigin.v[0], v5->r.currentOrigin.v[1], v5->r.currentOrigin.v[2], v8, v7);
    Scr_Error(COM_ERR_2302, scrContext, v9);
  }
}

/*
==============
ScrCmd_SetGrappleActor
==============
*/
void ScrCmd_SetGrappleActor(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_ACTOR )
    Scr_Error(COM_ERR_2303, scrContext, "SetGrappleActor can only be set on an actor.\n");
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->s.lerp.u.actor.flags;
  if ( Int )
    Entity->s.lerp.u.actor.flags = flags | 2;
  else
    Entity->s.lerp.u.actor.flags = flags & 0xFD;
}

/*
==============
ScrCmd_SetVolumeWalkingEnabled
==============
*/
void ScrCmd_SetVolumeWalkingEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  int v5; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    Int = Scr_GetInt(scrContext, 0);
    v5 = Entity->s.lerp.u.anonymous.data[0];
    if ( Int )
    {
      Entity->r.svFlags &= ~1u;
      Entity->s.lerp.u.anonymous.data[0] = v5 | 4;
      SV_LinkEntity(Entity);
    }
    else
    {
      Entity->s.lerp.u.anonymous.data[0] = v5 & 0xFFFFFFFB;
    }
  }
  else
  {
    Scr_Error(COM_ERR_2304, scrContext, "SetVolumeWalkingEnabled can only be set on an info_volume_grapple.\n");
  }
}

/*
==============
ScrCmd_SetVolumeSnapEnabled
==============
*/
void ScrCmd_SetVolumeSnapEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  int v5; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    Int = Scr_GetInt(scrContext, 0);
    v5 = Entity->s.lerp.u.anonymous.data[0];
    if ( Int )
    {
      Entity->s.lerp.u.anonymous.data[0] = v5 & 0xFFFFFFEF;
    }
    else
    {
      Entity->r.svFlags &= ~1u;
      Entity->s.lerp.u.anonymous.data[0] = v5 | 0x10;
      SV_LinkEntity(Entity);
    }
  }
  else
  {
    Scr_Error(COM_ERR_2305, scrContext, "SetVolumeSnapEnabled can only be set on an info_volume_grapple.\n");
  }
}

/*
==============
ScrCmd_SetVolumeGrappleDisable
==============
*/
void ScrCmd_SetVolumeGrappleDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  int v5; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    Int = Scr_GetInt(scrContext, 0);
    v5 = Entity->s.lerp.u.anonymous.data[0];
    if ( Int )
      Entity->s.lerp.u.anonymous.data[0] = v5 | 8;
    else
      Entity->s.lerp.u.anonymous.data[0] = v5 & 0xFFFFFFF7;
  }
  else
  {
    Scr_Error(COM_ERR_2306, scrContext, "SetVolumeGrappleDisable can only be set on an info_volume_grapple.\n");
  }
}

/*
==============
ScrCmd_SetVolumeUpVector
==============
*/
void ScrCmd_SetVolumeUpVector(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int128 packedColorB_Fov; 
  __int128 v5; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_INFO_VOLUME_GRAPPLE )
  {
    if ( (int)Scr_GetNumParam(scrContext) <= 0 )
    {
      Scr_Error(COM_ERR_2309, scrContext, "normalizedVector is required.\n");
    }
    else if ( Scr_GetType(scrContext, 0) == VAR_VECTOR )
    {
      Scr_GetVector(scrContext, 0, &Entity->s.lerp.u.infoVolumeGrapple.upVector);
      packedColorB_Fov = Entity->s.lerp.u.primaryLight.packedColorB_Fov;
      v5 = packedColorB_Fov;
      *(float *)&v5 = (float)((float)(*(float *)&packedColorB_Fov * *(float *)&packedColorB_Fov) + (float)(Entity->s.lerp.u.turret.gunAngles.v[2] * Entity->s.lerp.u.turret.gunAngles.v[2])) + (float)(Entity->s.lerp.u.actor.impactVector.v[0] * Entity->s.lerp.u.actor.impactVector.v[0]);
      if ( *(float *)&v5 > 0.001 )
      {
        *(float *)&v5 = fsqrt(*(float *)&v5);
        _XMM2 = v5;
        __asm
        {
          vcmpless xmm0, xmm2, cs:__real@80000000
          vblendvps xmm0, xmm2, xmm1, xmm0
        }
        Entity->s.lerp.u.turret.gunAngles.v[1] = *(float *)&packedColorB_Fov * (float)(1.0 / *(float *)&_XMM0);
        Entity->s.lerp.u.turret.gunAngles.v[2] = (float)(1.0 / *(float *)&_XMM0) * Entity->s.lerp.u.turret.gunAngles.v[2];
        Entity->s.lerp.u.actor.impactVector.v[0] = (float)(1.0 / *(float *)&_XMM0) * Entity->s.lerp.u.actor.impactVector.v[0];
      }
    }
    else if ( Scr_GetType(scrContext, 0) )
    {
      Scr_Error(COM_ERR_2308, scrContext, "normalizedVector must be a vector or undefined.\n");
    }
    else
    {
      *(_QWORD *)Entity->s.lerp.u.actor.threatSight = 0i64;
      Entity->s.lerp.u.anonymous.data[3] = 0;
    }
  }
  else
  {
    Scr_Error(COM_ERR_2307, scrContext, "can only be set on info_volume_grapple entities.\n");
  }
}

/*
==============
ScrCmd_SetModelUsesMaterialOverride
==============
*/
void ScrCmd_SetModelUsesMaterialOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_SCRIPTMOVER )
    Scr_Error(COM_ERR_2310, scrContext, "SetModelUsesMaterialOverride() must be called on a script mover.");
  if ( Entity->s.otherEntityNum == 2047 )
    Scr_Error(COM_ERR_2311, scrContext, "SetModelUsesMaterialOverride() must be called on an ent that has had SetOtherEnt set to the owner.");
  Entity->s.lerp.u.anonymous.data[2] |= 0x100u;
}

/*
==============
ScrCmd_SetRagdollNoBloodPoolFx
==============
*/
void ScrCmd_SetRagdollNoBloodPoolFx(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  if ( ((Entity->s.eType - 19) & 0xFFFD) != 0 )
    Scr_Error(COM_ERR_2312, scrContext, "SetRagdollNoBloodPoolFx can only be set on an actor or corpse.\n");
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->s.lerp.u.actor.flags;
  if ( Int )
    Entity->s.lerp.u.actor.flags = flags | 0x20;
  else
    Entity->s.lerp.u.actor.flags = flags & 0xDF;
}

/*
==============
ScrCmd_ClearImpactMarks
==============
*/
void ScrCmd_ClearImpactMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned int v3; 
  int v4; 

  entnum = entref.entnum;
  if ( entref.entnum >= 0x800 )
  {
    v4 = 2048;
    v3 = entref.entnum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v3, v4) )
      __debugbreak();
  }
  level.entFxMarkClearRequests.array[(unsigned __int64)entnum >> 5] |= 0x80000000 >> (entnum & 0x1F);
}

/*
==============
ScrCmd_ShowCinematicLetterBoxing
==============
*/
void ScrCmd_ShowCinematicLetterBoxing(scrContext_t *scrContext)
{
  int v1; 
  unsigned int v3; 
  const char *v8; 
  int v9; 

  v1 = 0;
  v3 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    Scr_GetFloat(scrContext, 0);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v3 = (int)*(float *)&_XMM1;
  }
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v1 = (int)*(float *)&_XMM1;
  }
  v9 = v1;
  v8 = j_va("%s %d %d %d", "set_cin_lerp_lb", 1i64, v3, v9);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
}

/*
==============
ScrCmd_HideCinematicLetterBoxing
==============
*/
void ScrCmd_HideCinematicLetterBoxing(scrContext_t *scrContext)
{
  int v1; 
  unsigned int v3; 
  const char *v8; 
  int v9; 

  v1 = 0;
  v3 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    Scr_GetFloat(scrContext, 0);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v3 = (int)*(float *)&_XMM1;
  }
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v1 = (int)*(float *)&_XMM1;
  }
  v9 = v1;
  v8 = j_va("%s %d %d %d", "set_cin_lerp_lb", 0i64, v3, v9);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
}

/*
==============
GScr_GetFakeAIArray
==============
*/
void GScr_GetFakeAIArray(scrContext_t *scrContext)
{
  gentity_s *v2; 
  int v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  Scr_MakeArray(scrContext);
  v2 = g_entities;
  v3 = 0;
  if ( level.num_entities > 0 )
  {
    v4 = 0i64;
    v5 = 0i64;
    do
    {
      if ( (unsigned int)v3 >= 0x800 )
      {
        LODWORD(v7) = 2048;
        LODWORD(v6) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v4].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v5] )
      {
        if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1935, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        if ( v2->s.eType == ET_SCRIPTMOVER && v2->s.un.scriptMoverType == 1 )
        {
          GScr_AddEntity(v2);
          Scr_AddArray(scrContext);
        }
      }
      ++v3;
      ++v5;
      ++v4;
      ++v2;
    }
    while ( v3 < level.num_entities );
  }
}

/*
==============
GScr_GetFakeAIArrayInRadius
==============
*/
void GScr_GetFakeAIArrayInRadius(scrContext_t *scrContext)
{
  double Float; 
  gentity_s *v3; 
  int v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  Scr_MakeArray(scrContext);
  v3 = g_entities;
  v4 = 0;
  if ( level.num_entities > 0 )
  {
    v5 = 0i64;
    v6 = 0i64;
    do
    {
      if ( (unsigned int)v4 >= 0x800 )
      {
        LODWORD(v8) = 2048;
        LODWORD(v7) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v6] )
      {
        if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1935, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        if ( v3->s.eType == ET_SCRIPTMOVER && v3->s.un.scriptMoverType == 1 && (float)((float)((float)((float)(vectorValue.v[1] - v3->r.currentOrigin.v[1]) * (float)(vectorValue.v[1] - v3->r.currentOrigin.v[1])) + (float)((float)(vectorValue.v[0] - v3->r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - v3->r.currentOrigin.v[0]))) + (float)((float)(vectorValue.v[2] - v3->r.currentOrigin.v[2]) * (float)(vectorValue.v[2] - v3->r.currentOrigin.v[2]))) <= (float)(*(float *)&Float * *(float *)&Float) )
        {
          GScr_AddEntity(v3);
          Scr_AddArray(scrContext);
        }
      }
      ++v4;
      ++v6;
      ++v5;
      ++v3;
    }
    while ( v4 < level.num_entities );
  }
}

/*
==============
Scr_IsPlatformConsole
==============
*/
void Scr_IsPlatformConsole(scrContext_t *scrContext)
{
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
    Scr_AddInt(scrContext, 1);
  else
    Scr_Error(COM_ERR_2314, scrContext, "IsPlatformConsole can only be called from SP.");
}

/*
==============
Scr_IsPlatformPC
==============
*/
void Scr_IsPlatformPC(scrContext_t *scrContext)
{
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
    Scr_AddInt(scrContext, 0);
  else
    Scr_Error(COM_ERR_2315, scrContext, "IsPlatformPC can only be called from SP.");
}

/*
==============
Scr_IsPlatformPS4
==============
*/
void Scr_IsPlatformPS4(scrContext_t *scrContext)
{
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
    Scr_AddInt(scrContext, 0);
  else
    Scr_Error(COM_ERR_2316, scrContext, "IsPlatformPS4 can only be called from SP.");
}

/*
==============
Scr_IsPlatformXB3
==============
*/
void Scr_IsPlatformXB3(scrContext_t *scrContext)
{
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
    Scr_AddInt(scrContext, 1);
  else
    Scr_Error(COM_ERR_2317, scrContext, "IsPlatformXB3 can only be called from SP.");
}

/*
==============
GScr_MainSP_IsDismembermentEnabled
==============
*/
void GScr_MainSP_IsDismembermentEnabled(scrContext_t *scrContext)
{
  if ( master_dismemberment_setting && master_dismemberment_setting->current.enabled )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
GScriptSP::ConstructMessageString
==============
*/
void GScriptSP::ConstructMessageString(GScriptSP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  unsigned int v7; 
  int v8; 
  const char *v10; 
  unsigned int v11; 
  const char *IString; 
  const char *v13; 
  unsigned __int64 v14; 
  const char *v15; 
  __int64 v16; 
  const char *v17; 
  unsigned __int64 v18; 
  bool v19; 
  const char *v20; 
  __int64 v21; 
  const dvar_t *v22; 
  bool v23; 
  const char *v24; 
  __int64 v25; 
  double *v26; 
  __int64 v27; 
  bool IsValidGamePadChar; 
  char v29; 
  __int64 v30; 

  v7 = 0;
  v8 = firstParmIndex;
  *string = 0;
  if ( firstParmIndex > lastParmIndex )
  {
    *string = 0;
  }
  else
  {
    v10 = errorContext;
    v11 = stringLimit;
    do
    {
      if ( Scr_GetType(scrContext, v8) == VAR_ISTRING )
      {
        IString = Scr_GetIString(scrContext, v8);
        v13 = IString;
        v14 = -1i64;
        do
          ++v14;
        while ( IString[v14] );
        if ( (v14 > 0x7FFFFFFFFFFFFFFFi64 || v14 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v14, "unsigned", v14) )
          __debugbreak();
        Scr_ValidateLocalizedStringRef(scrContext, v8, v13, v14);
        if ( (unsigned int)v14 + v7 + 1 >= v11 )
        {
          v15 = j_va("%s is too long. Max length is %i\n", v10, v11);
          Scr_ParamError(COM_ERR_2031, scrContext, v8, v15);
        }
        if ( v7 )
        {
          v16 = v7++;
          string[v16] = 30;
        }
      }
      else
      {
        v17 = Scr_GetString(scrContext, v8);
        v13 = v17;
        v18 = -1i64;
        do
          ++v18;
        while ( v17[v18] );
        if ( (v18 > 0x7FFFFFFFFFFFFFFFi64 || v18 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v18, "unsigned", v18) )
          __debugbreak();
        LODWORD(v14) = v18;
        v19 = !Scr_ValidateNonLocalizedStringRef(scrContext, v8, v13, v18, errorContext);
        if ( (unsigned int)v18 + v7 + 1 >= stringLimit )
        {
          v20 = j_va("%s is too long. Max length is %i\n", errorContext, stringLimit);
          Scr_ParamError(COM_ERR_2032, scrContext, v8, v20);
        }
        if ( (_DWORD)v18 )
        {
          v21 = v7++;
          string[v21] = 31;
        }
        if ( v19 )
        {
          v22 = DCONST_DVARBOOL_loc_warnings;
          if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v22);
          v23 = !v22->current.enabled;
          v11 = stringLimit;
          if ( !v23 )
          {
            if ( (unsigned int)v18 + v7 + 14 >= stringLimit )
            {
              v24 = j_va("%s is too long. Max length is %i\n", errorContext, stringLimit);
              Scr_ParamError(COM_ERR_2030, scrContext, v8, v24);
            }
            if ( v7 + 13 >= stringLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 469, ASSERT_TYPE_ASSERT, "(stringLen + LOCALIZATION_ERROR_PREFIX_LENGTH < stringLimit)", (const char *)&queryFormat, "stringLen + LOCALIZATION_ERROR_PREFIX_LENGTH < stringLimit") )
              __debugbreak();
            v25 = v7;
            v7 += 13;
            v26 = (double *)&string[v25];
            *v26 = *(double *)"UNLOCALIZED: ";
            qmemcpy(v26 + 1, "ZED: ", 5);
          }
        }
        else
        {
          v11 = stringLimit;
        }
      }
      if ( (_DWORD)v14 )
      {
        v27 = (unsigned int)v14;
        do
        {
          if ( *v13 >= 0x1Fu || (IsValidGamePadChar = Com_Keys_IsValidGamePadChar(*v13), v29 = 46, IsValidGamePadChar) )
            v29 = *v13;
          v30 = v7;
          ++v13;
          ++v7;
          string[v30] = v29;
          --v27;
        }
        while ( v27 );
      }
      v10 = errorContext;
      ++v8;
    }
    while ( v8 <= lastParmIndex );
    string[v7] = 0;
  }
}

/*
==============
GSCr_MainSP_GetViewLinkedParent
==============
*/
gentity_s *GSCr_MainSP_GetViewLinkedParent(int entId)
{
  int SpClientNum; 
  __int64 v3; 
  gentity_s *v4; 

  SpClientNum = SvClientSP::GetSpClientNum();
  v3 = SpClientNum;
  if ( G_IsEntityInUse(SpClientNum) && (v4 = &level.gentities[v3], BG_GetViewLinkedEntityData(&v4->client->ps, entId)) )
    return v4;
  else
    return 0i64;
}

/*
==============
GSCr_MainSP_InitNewViewLinkedData
==============
*/
ViewLinkedData *GSCr_MainSP_InitNewViewLinkedData(scrContext_t *scrContext, gentity_s *player, const gentity_s *entity)
{
  gclient_s *client; 
  const char *v7; 
  ComErrorCode v8; 
  __int64 v9; 

  if ( !player && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7428, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
    __debugbreak();
  if ( !entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7429, ASSERT_TYPE_ASSERT, "(entity)", (const char *)&queryFormat, "entity") )
    __debugbreak();
  client = player->client;
  if ( !client || entity->client )
  {
    v7 = "Only view links from ent to player are allowed.";
    v8 = COM_ERR_2231;
    goto LABEL_21;
  }
  if ( entity->s.eType != ET_SCRIPTMOVER || !entity->model )
  {
    v7 = "Only script model ents can be view linked.";
    v8 = COM_ERR_2232;
    goto LABEL_21;
  }
  if ( client->ps.numViewLinkedEnts == 4 )
  {
    v7 = "Cannot link entity, MAX_VIEW_LINKED_ENTITIES ents has been reached.";
    v8 = COM_ERR_2233;
LABEL_21:
    Scr_Error(v8, scrContext, v7);
    return 0i64;
  }
  if ( GSCr_MainSP_GetViewLinkedParent(entity->s.number) )
  {
    v7 = "Cannot view link entity, it is already linked.";
    v8 = COM_ERR_2234;
    goto LABEL_21;
  }
  if ( ++client->ps.numViewLinkedEnts > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7459, ASSERT_TYPE_ASSERT, "(ps->numViewLinkedEnts <= 4)", (const char *)&queryFormat, "ps->numViewLinkedEnts <= MAX_VIEW_LINKED_ENTITIES") )
    __debugbreak();
  v9 = (__int64)&client->ps.weaponHudIconOverridesAmmo[8 * client->ps.numViewLinkedEnts + 2];
  *(_QWORD *)v9 = 0i64;
  *(_QWORD *)(v9 + 8) = 0i64;
  *(_QWORD *)(v9 + 16) = 0i64;
  *(_QWORD *)(v9 + 24) = 0i64;
  *(_WORD *)(v9 + 28) = truncate_cast<unsigned short,int>(entity->s.number);
  return (ViewLinkedData *)v9;
}

/*
==============
GSCr_MainSP_UnlinkFromPlayerView
==============
*/
void GSCr_MainSP_UnlinkFromPlayerView(scrContext_t *scrContext, gentity_s *player, gentity_s *ent)
{
  gclient_s *client; 
  ViewLinkedData *ViewLinkedEntityData; 
  ViewLinkedData *v8; 
  unsigned __int64 v9; 
  __m256i *v10; 

  if ( !player && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7383, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
    __debugbreak();
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7384, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  client = player->client;
  if ( !client || ent->client )
  {
    Scr_Error(COM_ERR_2229, scrContext, "Only view unlinks from ent to player are allowed.");
  }
  else
  {
    ViewLinkedEntityData = BG_GetViewLinkedEntityData(&client->ps, ent->s.number);
    v8 = ViewLinkedEntityData;
    if ( ViewLinkedEntityData )
    {
      Scr_SetString(&ViewLinkedEntityData->linkedTag, (scr_string_t)0);
      v9 = ((char *)v8 - (char *)client - 21264) >> 5;
      if ( v9 < client->ps.numViewLinkedEnts - 1 )
      {
        v10 = (__m256i *)&client->ps.viewLinkedEntityData[v9 + 1];
        do
        {
          ++v9;
          v10[-1] = *v10;
          v10->m256i_i64[0] = 0i64;
          v10->m256i_i64[1] = 0i64;
          v10->m256i_i64[2] = 0i64;
          v10->m256i_i64[3] = 0i64;
          ++v10;
        }
        while ( v9 < client->ps.numViewLinkedEnts - 1 );
      }
      EntHandle::setEnt(&ent->r.ownerNum, NULL);
      if ( client->ps.numViewLinkedEnts <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7418, ASSERT_TYPE_ASSERT, "(ps->numViewLinkedEnts > 0)", (const char *)&queryFormat, "ps->numViewLinkedEnts > 0") )
        __debugbreak();
      --client->ps.numViewLinkedEnts;
    }
    else
    {
      Scr_Error(COM_ERR_2230, scrContext, "Could not find entity to remove from player view link.");
    }
  }
}

/*
==============
GScrSP_ClearAITypeScriptTable
==============
*/
void GScrSP_ClearAITypeScriptTable(void)
{
  s_typeScriptTable = NULL;
  LODWORD(s_typeScriptTableCount) = 0;
}

/*
==============
GScrSP_FindAITypeScriptByClassname
==============
*/
const AITypeScript *GScrSP_FindAITypeScriptByClassname(const char *const classname)
{
  const char *Key; 

  Key = classname;
  return (const AITypeScript *)bsearch(&Key, s_typeScriptTable, (unsigned int)s_typeScriptTableCount, 0x18ui64, (_CoreCrtNonSecureSearchSortCompareFunction)GScr_CompareAITypeScriptByName);
}

/*
==============
GScrSP_SetScripts
==============
*/
void GScrSP_SetScripts(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts)
{
  int v4; 
  int v5; 
  __int64 count; 
  __int64 v7; 
  char *scriptfile; 
  char *v9; 
  char v10; 
  __int64 v11; 
  char v12; 
  int v13; 
  int v14; 
  __int64 v15; 
  unsigned __int64 v16; 
  char *v17; 
  char *v18; 
  char v19; 
  __int64 v20; 
  char v21; 
  int v22; 
  int v23; 
  __int64 v24; 
  __int64 v25; 
  char *v26; 
  char *v27; 
  char v28; 
  __int64 v29; 
  char v30; 
  int v31; 
  GameScriptDataSP *v32; 
  int NumWeapons; 
  unsigned __int16 v34; 
  GameScriptDataSP *i; 
  WeaponDef *v36; 
  const char *szScript; 
  __int64 v38; 
  int v39; 
  __int64 v40; 
  __int64 v41; 
  char *v42; 
  char *v43; 
  char v44; 
  __int64 v45; 
  char v46; 
  int v47; 
  int v48; 
  __int64 v49; 
  unsigned __int64 v50; 
  char *v51; 
  char *v52; 
  char v53; 
  __int64 v54; 
  char v55; 
  int v56; 
  int v57; 
  __int64 v58; 
  unsigned __int64 v59; 
  char *v60; 
  char *v61; 
  char v62; 
  __int64 v63; 
  char v64; 
  int v65; 
  int v66; 
  __int64 v67; 
  unsigned __int64 v68; 
  char *v69; 
  char *v70; 
  char v71; 
  __int64 v72; 
  char v73; 
  int v74; 
  int v75; 
  __int64 v76; 
  unsigned __int64 v77; 
  char *v78; 
  char *v79; 
  char v80; 
  __int64 v81; 
  char v82; 
  int v83; 
  int v84; 
  __int64 v85; 
  unsigned __int64 v86; 
  char *v87; 
  char *v88; 
  char v89; 
  __int64 v90; 
  char v91; 
  int v92; 
  int v93; 
  __int64 v94; 
  unsigned __int64 v95; 
  char *v96; 
  char *v97; 
  char v98; 
  __int64 v99; 
  char v100; 
  int v101; 
  int v102; 
  __int64 v103; 
  unsigned __int64 v104; 
  char *v105; 
  char *v106; 
  char v107; 
  __int64 v108; 
  char v109; 
  int v110; 
  int v111; 
  __int64 v112; 
  unsigned __int64 v113; 
  char *v114; 
  char *v115; 
  char v116; 
  __int64 v117; 
  char v118; 
  int v119; 
  int v120; 
  __int64 v121; 
  unsigned __int64 v122; 
  char *v123; 
  char *v124; 
  char v125; 
  __int64 v126; 
  char v127; 
  int v128; 
  int v129; 
  __int64 v130; 
  unsigned __int64 v131; 
  char *v132; 
  char *v133; 
  char v134; 
  __int64 v135; 
  char v136; 
  int v137; 
  __int64 v138; 
  char *v139; 
  char *v140; 
  char v141; 
  __int64 v142; 
  char v143; 
  int v144; 
  int v145; 
  scrContext_t *v146; 
  scrContext_t *v147; 
  __int64 v148; 
  __int64 v149; 
  GameScriptDataSP *GameScriptDataSP; 
  char dest[128]; 

  GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
  Core_strcpy(dest, 0x80ui64, "scripts/code/delete.gsc");
  v4 = 0;
  if ( G_MainSP_ShouldLoadScripts() )
  {
    count = functions->count;
    v7 = 0x7FFFFFFFi64;
    scriptfile = loadscripts->entries[count].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + 160 * count) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(160 * count + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v9 = (char *)(dest - scriptfile);
    do
    {
      v10 = scriptfile[(_QWORD)v9];
      v11 = v7;
      v12 = *scriptfile++;
      --v7;
      if ( !v11 )
        break;
      if ( v10 != v12 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v10 );
    v13 = functions->count;
    if ( v13 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v13 = functions->count;
    }
    if ( loadscripts->entries[v13].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v13 = functions->count;
    }
    v5 = functions->address[v13];
    functions->count = v13 + 1;
    if ( !v5 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "main", dest);
  }
  else
  {
    v5 = 0;
  }
  GameScriptDataSP->delete_ = v5;
  Core_strcpy(dest, 0x80ui64, "scripts/code/struct.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v15 = 0x7FFFFFFFi64;
    v16 = 160i64 * functions->count;
    v17 = loadscripts->entries[v16 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v16) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v16 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v18 = (char *)(dest - v17);
    do
    {
      v19 = v17[(_QWORD)v18];
      v20 = v15;
      v21 = *v17++;
      --v15;
      if ( !v20 )
        break;
      if ( v19 != v21 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v19 );
    v22 = functions->count;
    if ( v22 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v22 = functions->count;
    }
    if ( loadscripts->entries[v22].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v22 = functions->count;
    }
    v14 = functions->address[v22];
    functions->count = v22 + 1;
    if ( !v14 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "initstructs", dest);
  }
  else
  {
    v14 = 0;
  }
  GameScriptDataSP->initstructs = v14;
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v24 = 0x7FFFFFFFi64;
    v25 = functions->count;
    v26 = loadscripts->entries[v25].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v25 * 160) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v27 = (char *)(dest - v26);
    do
    {
      v28 = v27[(_QWORD)v26];
      v29 = v24;
      v30 = *v26++;
      --v24;
      if ( !v29 )
        break;
      if ( v28 != v30 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v28 );
    v31 = functions->count;
    if ( v31 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v31 = functions->count;
    }
    if ( loadscripts->entries[v31].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v31 = functions->count;
    }
    v23 = functions->address[v31];
    functions->count = v31 + 1;
    if ( !v23 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "createstruct", dest);
  }
  else
  {
    v23 = 0;
  }
  GameScriptDataSP->createstruct = v23;
  v32 = GameScriptDataSP::GetGameScriptDataSP();
  GScr_SetSingleAnimScript(functions, loadscripts, &v32->anim.death, "death", NULL);
  GScr_SetSingleAnimScript(functions, loadscripts, &v32->anim.init, "init", NULL);
  GScr_SetSingleAnimScript(functions, loadscripts, &v32->anim.pain, "pain", NULL);
  GScr_SetSingleAnimScript(functions, loadscripts, &v32->anim.scripted, "scripted", NULL);
  v32->scripted_init = GScr_SetScriptAndLabel("scripts/anim/scripted.gsc", "init", 1, functions, loadscripts);
  g_animScriptTable[1] = &v32->civilianAnim;
  g_animScriptTable[0] = &v32->anim;
  NumWeapons = BG_GetNumWeapons();
  v34 = 1;
  for ( i = GameScriptDataSP::GetGameScriptDataSP(); v34 < NumWeapons; ++v34 )
  {
    if ( v34 > bg_lastParsedWeaponIndex )
    {
      LODWORD(v149) = bg_lastParsedWeaponIndex;
      LODWORD(v148) = v34;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v148, v149) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[v34] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v36 = bg_weaponDefs[v34];
    if ( v36 && (szScript = v36->szScript) != NULL && *szScript )
    {
      v4 = 0;
      GScr_SetSingleAnimScript(functions, loadscripts, &i->anim.weapons[v34], szScript, NULL);
    }
    else
    {
      if ( v34 >= 0x226u )
      {
        LODWORD(v149) = 550;
        LODWORD(v148) = v34;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 335, ASSERT_TYPE_ASSERT, "(unsigned)( weaponslot.weaponIdx ) < (unsigned)( ( sizeof( *array_counter( gScrData->anim.weapons ) ) + 0 ) )", "weaponslot.weaponIdx doesn't index ARRAY_COUNT( gScrData->anim.weapons )\n\t%i not in [0, %i)", v148, v149) )
          __debugbreak();
      }
      v4 = 0;
      *(_QWORD *)&i->anim.weapons[v34].func = 0i64;
      i->anim.weapons[v34].name = 0;
    }
  }
  GScr_SetLevelScript(functions, loadscripts);
  GScr_BuildAITypeScriptTable(functions, loadscripts);
  Path_CallFunctionForNodes(GScr_SetScriptsForPathNode, functions);
  Core_strcpy(dest, 0x80ui64, "scripts/aitypes/bt_util.gsc");
  v38 = 0x7FFFFFFFi64;
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v40 = 0x7FFFFFFFi64;
    v41 = functions->count;
    v42 = loadscripts->entries[v41].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v41 * 160) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v43 = (char *)(dest - v42);
    do
    {
      v44 = v43[(_QWORD)v42];
      v45 = v40;
      v46 = *v42++;
      --v40;
      if ( !v45 )
        break;
      if ( v44 != v46 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v44 );
    v47 = functions->count;
    if ( v47 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v47 = functions->count;
    }
    if ( loadscripts->entries[v47].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v47 = functions->count;
    }
    v39 = functions->address[v47];
    functions->count = v47 + 1;
    if ( !v39 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "bt_getfunction", dest);
  }
  else
  {
    v39 = 0;
  }
  GameScriptDataSP->bt_getfunction = v39;
  Core_strcpy(dest, 0x80ui64, "scripts/asm/asm.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v49 = 0x7FFFFFFFi64;
    v50 = 160i64 * functions->count;
    v51 = loadscripts->entries[v50 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v50) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v50 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v52 = (char *)(dest - v51);
    do
    {
      v53 = v52[(_QWORD)v51];
      v54 = v49;
      v55 = *v51++;
      --v49;
      if ( !v54 )
        break;
      if ( v53 != v55 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v53 );
    v56 = functions->count;
    if ( v56 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v56 = functions->count;
    }
    if ( loadscripts->entries[v56].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v56 = functions->count;
    }
    v48 = functions->address[v56];
    functions->count = v56 + 1;
    if ( !v48 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "asm_getfunction", dest);
  }
  else
  {
    v48 = 0;
  }
  GameScriptDataSP->ai_asm_getfunction = v48;
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v58 = 0x7FFFFFFFi64;
    v59 = 160i64 * functions->count;
    v60 = loadscripts->entries[v59 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v59) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v59 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v61 = (char *)(dest - v60);
    do
    {
      v62 = v61[(_QWORD)v60];
      v63 = v58;
      v64 = *v60++;
      --v58;
      if ( !v63 )
        break;
      if ( v62 != v64 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v62 );
    v65 = functions->count;
    if ( v65 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v65 = functions->count;
    }
    if ( loadscripts->entries[v65].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v65 = functions->count;
    }
    v57 = functions->address[v65];
    functions->count = v65 + 1;
    if ( !v57 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "asm_getparams", dest);
  }
  else
  {
    v57 = 0;
  }
  GameScriptDataSP->ai_asm_getparams = v57;
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v67 = 0x7FFFFFFFi64;
    v68 = 160i64 * functions->count;
    v69 = loadscripts->entries[v68 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v68) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v68 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v70 = (char *)(dest - v69);
    do
    {
      v71 = v70[(_QWORD)v69];
      v72 = v67;
      v73 = *v69++;
      --v67;
      if ( !v72 )
        break;
      if ( v71 != v73 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v71 );
    v74 = functions->count;
    if ( v74 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v74 = functions->count;
    }
    if ( loadscripts->entries[v74].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v74 = functions->count;
    }
    v66 = functions->address[v74];
    functions->count = v74 + 1;
    if ( !v66 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "asm_getgenerichandler", dest);
  }
  else
  {
    v66 = 0;
  }
  GameScriptDataSP->ai_asm_getgenerichandler = v66;
  Core_strcpy(dest, 0x80ui64, "scripts/code/ai.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v76 = 0x7FFFFFFFi64;
    v77 = 160i64 * functions->count;
    v78 = loadscripts->entries[v77 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v77) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v77 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v79 = (char *)(dest - v78);
    do
    {
      v80 = v79[(_QWORD)v78];
      v81 = v76;
      v82 = *v78++;
      --v76;
      if ( !v81 )
        break;
      if ( v80 != v82 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v80 );
    v83 = functions->count;
    if ( v83 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v83 = functions->count;
    }
    if ( loadscripts->entries[v83].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v83 = functions->count;
    }
    v75 = functions->address[v83];
    functions->count = v83 + 1;
    if ( !v75 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "free_expendable", dest);
  }
  else
  {
    v75 = 0;
  }
  GameScriptDataSP->ai_free_expendable = v75;
  Core_strcpy(dest, 0x80ui64, "scripts/common/scriptable.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v85 = 0x7FFFFFFFi64;
    v86 = 160i64 * functions->count;
    v87 = loadscripts->entries[v86 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v86) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v86 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v88 = (char *)(dest - v87);
    do
    {
      v89 = v87[(_QWORD)v88];
      v90 = v85;
      v91 = *v87++;
      --v85;
      if ( !v90 )
        break;
      if ( v89 != v91 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v89 );
    v92 = functions->count;
    if ( v92 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v92 = functions->count;
    }
    if ( loadscripts->entries[v92].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v92 = functions->count;
    }
    v84 = functions->address[v92];
    functions->count = v92 + 1;
    if ( !v84 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "scriptable_initialize", dest);
  }
  else
  {
    v84 = 0;
  }
  GameScriptDataSP->scriptable_init = v84;
  Core_strcpy(dest, 0x80ui64, "scripts/common/scriptable.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v94 = 0x7FFFFFFFi64;
    v95 = 160i64 * functions->count;
    v96 = loadscripts->entries[v95 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v95) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v95 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v97 = (char *)(dest - v96);
    do
    {
      v98 = v96[(_QWORD)v97];
      v99 = v94;
      v100 = *v96++;
      --v94;
      if ( !v99 )
        break;
      if ( v98 != v100 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v98 );
    v101 = functions->count;
    if ( v101 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v101 = functions->count;
    }
    if ( loadscripts->entries[v101].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v101 = functions->count;
    }
    v93 = functions->address[v101];
    functions->count = v101 + 1;
    if ( !v93 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "scriptable_post_initialize", dest);
  }
  else
  {
    v93 = 0;
  }
  GameScriptDataSP->scriptable_postinit = v93;
  Core_strcpy(dest, 0x80ui64, "scripts/common/scriptable.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v103 = 0x7FFFFFFFi64;
    v104 = 160i64 * functions->count;
    v105 = loadscripts->entries[v104 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v104) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v104 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v106 = (char *)(dest - v105);
    do
    {
      v107 = v105[(_QWORD)v106];
      v108 = v103;
      v109 = *v105++;
      --v103;
      if ( !v108 )
        break;
      if ( v107 != v109 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v107 );
    v110 = functions->count;
    if ( v110 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v110 = functions->count;
    }
    if ( loadscripts->entries[v110].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v110 = functions->count;
    }
    v102 = functions->address[v110];
    functions->count = v110 + 1;
    if ( !v102 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "scriptable_used", dest);
  }
  else
  {
    v102 = 0;
  }
  GameScriptDataSP->scriptable_used = v102;
  Core_strcpy(dest, 0x80ui64, "scripts/common/scriptable.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v112 = 0x7FFFFFFFi64;
    v113 = 160i64 * functions->count;
    v114 = loadscripts->entries[v113 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v113) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v113 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v115 = (char *)(dest - v114);
    do
    {
      v116 = v114[(_QWORD)v115];
      v117 = v112;
      v118 = *v114++;
      --v112;
      if ( !v117 )
        break;
      if ( v116 != v118 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v116 );
    v119 = functions->count;
    if ( v119 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v119 = functions->count;
    }
    if ( loadscripts->entries[v119].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v119 = functions->count;
    }
    v111 = functions->address[v119];
    functions->count = v119 + 1;
    if ( !v111 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "scriptable_touched", dest);
  }
  else
  {
    v111 = 0;
  }
  GameScriptDataSP->scriptable_touched = v111;
  Core_strcpy(dest, 0x80ui64, "scripts/common/scriptable.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v121 = 0x7FFFFFFFi64;
    v122 = 160i64 * functions->count;
    v123 = loadscripts->entries[v122 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v122) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v122 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v124 = (char *)(dest - v123);
    do
    {
      v125 = v123[(_QWORD)v124];
      v126 = v121;
      v127 = *v123++;
      --v121;
      if ( !v126 )
        break;
      if ( v125 != v127 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v125 );
    v128 = functions->count;
    if ( v128 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v128 = functions->count;
    }
    if ( loadscripts->entries[v128].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v128 = functions->count;
    }
    v120 = functions->address[v128];
    functions->count = v128 + 1;
    if ( !v120 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "scriptable_notify_callback", dest);
  }
  else
  {
    v120 = 0;
  }
  GameScriptDataSP->scriptable_notify_callback = v120;
  Core_strcpy(dest, 0x80ui64, "scripts/common/interactive.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v130 = 0x7FFFFFFFi64;
    v131 = 160i64 * functions->count;
    v132 = loadscripts->entries[v131 / 0xA0].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v131) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v131 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v133 = (char *)(dest - v132);
    do
    {
      v134 = v132[(_QWORD)v133];
      v135 = v130;
      v136 = *v132++;
      --v130;
      if ( !v135 )
        break;
      if ( v134 != v136 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v134 );
    v137 = functions->count;
    if ( v137 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v137 = functions->count;
    }
    if ( loadscripts->entries[v137].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v137 = functions->count;
    }
    v129 = functions->address[v137];
    functions->count = v137 + 1;
    if ( !v129 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "entity_used", dest);
  }
  else
  {
    v129 = 0;
  }
  GameScriptDataSP->entity_used = v129;
  Core_strcpy(dest, 0x80ui64, "scripts/common/ui.gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    v138 = functions->count;
    v139 = loadscripts->entries[v138].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + v138 * 160) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v140 = (char *)(dest - v139);
    do
    {
      v141 = v140[(_QWORD)v139];
      v142 = v38;
      v143 = *v139++;
      --v38;
      if ( !v142 )
        break;
      if ( v141 != v143 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v141 );
    v144 = functions->count;
    if ( v144 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v144 = functions->count;
    }
    if ( loadscripts->entries[v144].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v144 = functions->count;
    }
    v145 = functions->address[v144];
    functions->count = v144 + 1;
    if ( !v145 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "lui_notify_callback", dest);
    v4 = v145;
  }
  GameScriptDataSP->lui_callback = v4;
  v146 = ScriptContext_Server();
  GScr_Main_UpdateClassMap();
  GScr_AddFieldsForPIPElems(v146);
  GScr_Main_PostLoadScriptsCommon();
  v147 = ScriptContext_Server();
  Scr_EndLoadScripts(v147);
}

/*
==============
GScr_BuildAITypeScriptTable
==============
*/
void GScr_BuildAITypeScriptTable(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts)
{
  char v3; 
  __int64 CountForType; 
  AITypeScript *v6; 
  unsigned int v7; 
  __int64 v8; 
  GameScriptDataSP *GameScriptDataSP; 
  AITypeScript *v10; 
  int v11; 
  __int64 v12; 
  unsigned __int64 v13; 
  char *scriptfile; 
  char *v15; 
  char v16; 
  __int64 v17; 
  char v18; 
  int count; 
  int v20; 
  __int64 v21; 
  unsigned __int64 v22; 
  char *v23; 
  char *v24; 
  char v25; 
  __int64 v26; 
  char v27; 
  int v28; 
  int v29; 
  __int64 v30; 
  unsigned __int64 v31; 
  char *v32; 
  char *v33; 
  char v34; 
  __int64 v35; 
  char v36; 
  int v37; 
  char v38; 
  char *outName; 
  char dest[128]; 

  v3 = 0;
  v38 = 0;
  CountForType = NetConstStrings_GetCountForType(NETCONSTSTRINGTYPE_AITYPE);
  if ( s_typeScriptTable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 234, ASSERT_TYPE_ASSERT, "( ( s_typeScriptTable == nullptr ) )", "( s_typeScriptTable ) = %p", s_typeScriptTable) )
    __debugbreak();
  if ( (_DWORD)s_typeScriptTableCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 235, ASSERT_TYPE_ASSERT, "( s_typeScriptTableCount ) == ( 0 )", "%s == %s\n\t%u, %u", "s_typeScriptTableCount", "0", s_typeScriptTableCount, 0i64) )
    __debugbreak();
  v6 = (AITypeScript *)G_Main_HunkAllocXAnimServer(24 * CountForType);
  v7 = 0;
  s_typeScriptTable = v6;
  LODWORD(s_typeScriptTableCount) = CountForType;
  if ( (_DWORD)CountForType )
  {
    v8 = 0i64;
    do
    {
      if ( !NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, v7, (const char **)&outName) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 243, ASSERT_TYPE_ASSERT, "(NetConstStrings_GetNameFromIndex( NETCONSTSTRINGTYPE_AITYPE, classnameIndex, &classname ))", (const char *)&queryFormat, "NetConstStrings_GetNameFromIndex( NETCONSTSTRINGTYPE_AITYPE, classnameIndex, &classname )") )
        __debugbreak();
      if ( !v3 && I_stristr(outName, "civilian_") )
      {
        v38 = 1;
        GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
        GScr_SetSingleAnimScript(functions, loadscripts, &GameScriptDataSP->civilianAnim.death, "civilian_death", "civilian");
        GScr_SetSingleAnimScript(functions, loadscripts, &GameScriptDataSP->civilianAnim.init, "civilian_init", "civilian");
        GScr_SetSingleAnimScript(functions, loadscripts, &GameScriptDataSP->civilianAnim.pain, "civilian_pain", "civilian");
        GScr_SetSingleAnimScript(functions, loadscripts, &GameScriptDataSP->civilianAnim.scripted, "civilian_scripted", "civilian");
      }
      Com_sprintf<128>((char (*)[128])dest, "aitype/%s.gsc", outName);
      v10 = &s_typeScriptTable[v8];
      s_typeScriptTable[v8].classname = outName;
      if ( G_MainSP_ShouldLoadScripts() )
      {
        v12 = 0x7FFFFFFFi64;
        v13 = 160i64 * functions->count;
        scriptfile = loadscripts->entries[v13 / 0xA0].scriptfile;
        if ( (EntryLoadScriptArray *)((char *)loadscripts + v13) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v13 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v15 = (char *)(dest - scriptfile);
        do
        {
          v16 = scriptfile[(_QWORD)v15];
          v17 = v12;
          v18 = *scriptfile++;
          --v12;
          if ( !v17 )
            break;
          if ( v16 != v18 )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
            break;
          }
        }
        while ( v16 );
        count = functions->count;
        if ( count >= functions->maxSize )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
          count = functions->count;
        }
        if ( loadscripts->entries[count].enforceExists != 1 )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
          count = functions->count;
        }
        v11 = functions->address[count];
        functions->count = count + 1;
        if ( !v11 )
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "main", dest);
      }
      else
      {
        v11 = 0;
      }
      v10->main = v11;
      if ( G_MainSP_ShouldLoadScripts() )
      {
        v21 = 0x7FFFFFFFi64;
        v22 = 160i64 * functions->count;
        v23 = loadscripts->entries[v22 / 0xA0].scriptfile;
        if ( (EntryLoadScriptArray *)((char *)loadscripts + v22) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v22 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v24 = (char *)(dest - v23);
        do
        {
          v25 = v23[(_QWORD)v24];
          v26 = v21;
          v27 = *v23++;
          --v21;
          if ( !v26 )
            break;
          if ( v25 != v27 )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
            break;
          }
        }
        while ( v25 );
        v28 = functions->count;
        if ( v28 >= functions->maxSize )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
          v28 = functions->count;
        }
        if ( loadscripts->entries[v28].enforceExists != 1 )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
          v28 = functions->count;
        }
        v20 = functions->address[v28];
        functions->count = v28 + 1;
        if ( !v20 )
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "precache", dest);
      }
      else
      {
        v20 = 0;
      }
      v10->precache = v20;
      if ( G_MainSP_ShouldLoadScripts() )
      {
        v30 = 0x7FFFFFFFi64;
        v31 = 160i64 * functions->count;
        v32 = loadscripts->entries[v31 / 0xA0].scriptfile;
        if ( (EntryLoadScriptArray *)((char *)loadscripts + v31) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(v31 + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v33 = (char *)(dest - v32);
        do
        {
          v34 = v33[(_QWORD)v32];
          v35 = v30;
          v36 = *v32++;
          --v30;
          if ( !v35 )
            break;
          if ( v34 != v36 )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
            break;
          }
        }
        while ( v34 );
        v37 = functions->count;
        if ( v37 >= functions->maxSize )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
          v37 = functions->count;
        }
        if ( loadscripts->entries[v37].enforceExists != 1 )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
          v37 = functions->count;
        }
        v29 = functions->address[v37];
        functions->count = v37 + 1;
        if ( !v29 )
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "spawner", dest);
      }
      else
      {
        v29 = 0;
      }
      v3 = v38;
      ++v7;
      v10->spawner = v29;
      ++v8;
    }
    while ( v7 < (unsigned int)CountForType );
    v6 = s_typeScriptTable;
    LODWORD(CountForType) = s_typeScriptTableCount;
  }
  qsort(v6, (unsigned int)CountForType, 0x18ui64, (_CoreCrtNonSecureSearchSortCompareFunction)GScr_CompareAITypeScriptByName);
}

/*
==============
GScr_CompareAITypeScriptByName
==============
*/
int GScr_CompareAITypeScriptByName(const void *const typeScriptPtr1, const void *const typeScriptPtr2)
{
  return I_strcmp(*(const char **)typeScriptPtr1, *(const char **)typeScriptPtr2);
}

/*
==============
GScr_MainSP_ParseChangeSoundParameterCommand
==============
*/
void GScr_MainSP_ParseChangeSoundParameterCommand(scrContext_t *scrContext, scr_entref_t entref, int event, const char *name, float maxParam)
{
  int NumParam; 
  int v10; 
  const char *v11; 
  gentity_s *Entity; 
  double Float; 
  const char *v14; 
  ComErrorCode v15; 
  int v16; 
  double v17; 
  float v18; 
  const char *v19; 
  ComErrorCode v20; 
  int v21; 

  if ( maxParam <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7747, ASSERT_TYPE_ASSERT, "(maxParam > 0.0f)", (const char *)&queryFormat, "maxParam > 0.0f") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7748, ASSERT_TYPE_ASSERT, "(name != 0)", (const char *)&queryFormat, "name != NULL") )
    __debugbreak();
  NumParam = Scr_GetNumParam(scrContext);
  v10 = NumParam;
  if ( NumParam > 2 || !NumParam )
  {
    v11 = j_va("Sound error. Wrong number of parameters to '%s'.\n", name);
    Scr_Error(COM_ERR_2244, scrContext, v11);
  }
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 7757, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float >= 0.0 )
  {
    if ( *(float *)&Float <= maxParam )
      goto LABEL_18;
    v14 = j_va("Sound error. First argument for '%s' must be less than %.2f.\n", name, maxParam);
    v15 = COM_ERR_2246;
  }
  else
  {
    v14 = j_va("Sound error. First argument for '%s' must be greater than zero.\n", name);
    v15 = COM_ERR_2245;
  }
  Scr_Error(v15, scrContext, v14);
LABEL_18:
  v16 = (int)(float)((float)(*(float *)&Float / maxParam) * 65535.0);
  if ( v10 != 2 )
  {
    v21 = 0;
    goto LABEL_26;
  }
  v17 = Scr_GetFloat(scrContext, 1u);
  v18 = *(float *)&v17 * 1000.0;
  if ( (float)(*(float *)&v17 * 1000.0) < 0.0 )
  {
    v19 = j_va("Sound error. Second argument for '%s' must be greater than zero.\n", name);
    v20 = COM_ERR_2247;
LABEL_23:
    Scr_Error(v20, scrContext, v19);
    goto LABEL_24;
  }
  if ( v18 > 65535.0 )
  {
    v19 = j_va("Sound error. Second argument for '%s' must be less than %.2f.\n", name, DOUBLE_65_53500366210938);
    v20 = COM_ERR_2248;
    goto LABEL_23;
  }
LABEL_24:
  v21 = (int)v18;
LABEL_26:
  Entity->r.svFlags &= ~1u;
  G_Utils_AddEvent(Entity, event, v21 | (v16 << 16));
  SND_SV_SetEntityHasParams(Entity->s.number);
}

/*
==============
GScr_MainSP_SetHealth
==============
*/
void GScr_MainSP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  const char *v5; 
  int Int; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  __int64 health; 
  actor_s *actor; 
  scr_string_t v12; 
  const char *v13; 

  v5 = "<not set>";
  Int = Scr_GetInt(scrContext, 0);
  if ( Int <= 0 )
  {
    targetname = ent->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<not set>";
    v9 = j_va("self.health must be greater than 0 (tried to set %i on ent %i, name %s)", (unsigned int)Int, (unsigned int)ent->s.number, v8);
    Scr_Error(COM_ERR_2313, scrContext, v9);
  }
  health = (unsigned int)ent->health;
  if ( (int)health <= 0 && ent->maxHealth || (actor = ent->actor) != NULL && actor->painDeath.delayedDeath )
  {
    v12 = ent->targetname;
    if ( v12 )
    {
      v13 = SL_ConvertToString(v12);
      health = (unsigned int)ent->health;
      v5 = v13;
    }
    Com_DPrintf(23, "^2Cannot set health on dead entities (health %i, max %i, ent %i, name %s)\n", health, (unsigned int)ent->maxHealth, ent->s.number, v5);
  }
  else
  {
    ent->maxHealth = Int;
    ent->health = Int;
  }
}

/*
==============
GScr_SetLevelScript
==============
*/
void GScr_SetLevelScript(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts)
{
  const char *MapName; 
  const char *v5; 
  __int64 v6; 
  __int64 v7; 
  GameScriptDataSP *GameScriptDataSP; 
  int v9; 
  __int64 v10; 
  int v11; 
  int v12; 
  int v13; 
  const char *v14; 
  __int64 v15; 
  int v16; 
  __int64 v17; 
  int v18; 
  int v19; 
  int v20; 
  const char *v21; 
  __int64 v22; 
  int v23; 
  __int64 v24; 
  int v25; 
  int v26; 
  int v27; 
  const char *v28; 
  int v29; 
  __int64 v30; 
  int v31; 
  int v32; 
  int v33; 
  char dest[128]; 

  MapName = SV_Game_GetMapName();
  v5 = "mp/";
  v6 = 3i64;
  v7 = 3i64;
  GameScriptDataSP = GameScriptDataSP::GetGameScriptDataSP();
  if ( !MapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  do
  {
    v9 = (unsigned __int8)v5[MapName - "mp/"];
    v10 = v7;
    v11 = *(unsigned __int8 *)v5++;
    --v7;
    if ( !v10 )
      break;
    if ( v9 != v11 )
    {
      v12 = v9 + 32;
      if ( (unsigned int)(v9 - 65) > 0x19 )
        v12 = v9;
      v9 = v12;
      v13 = v11 + 32;
      if ( (unsigned int)(v11 - 65) > 0x19 )
        v13 = v11;
      if ( v9 != v13 )
      {
        v14 = "mp\\";
        v15 = 3i64;
        if ( !MapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        while ( 1 )
        {
          v16 = (unsigned __int8)v14[MapName - "mp\\"];
          v17 = v15;
          v18 = *(unsigned __int8 *)v14++;
          --v15;
          if ( !v17 )
            goto LABEL_12;
          if ( v16 != v18 )
          {
            v19 = v16 + 32;
            if ( (unsigned int)(v16 - 65) > 0x19 )
              v19 = v16;
            v16 = v19;
            v20 = v18 + 32;
            if ( (unsigned int)(v18 - 65) > 0x19 )
              v20 = v18;
            if ( v16 != v20 )
            {
              v21 = "cp/";
              v22 = 3i64;
              if ( !MapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
                __debugbreak();
              while ( 1 )
              {
                v23 = (unsigned __int8)v21[MapName - "cp/"];
                v24 = v22;
                v25 = *(unsigned __int8 *)v21++;
                --v22;
                if ( !v24 )
                  goto LABEL_12;
                if ( v23 != v25 )
                {
                  v26 = v23 + 32;
                  if ( (unsigned int)(v23 - 65) > 0x19 )
                    v26 = v23;
                  v23 = v26;
                  v27 = v25 + 32;
                  if ( (unsigned int)(v25 - 65) > 0x19 )
                    v27 = v25;
                  if ( v23 != v27 )
                  {
                    v28 = "cp\\";
                    if ( !MapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
                      __debugbreak();
                    while ( 1 )
                    {
                      v29 = (unsigned __int8)v28[MapName - "cp\\"];
                      v30 = v6;
                      v31 = *(unsigned __int8 *)v28++;
                      --v6;
                      if ( !v30 )
                        goto LABEL_12;
                      if ( v29 != v31 )
                      {
                        v32 = v29 + 32;
                        if ( (unsigned int)(v29 - 65) > 0x19 )
                          v32 = v29;
                        v29 = v32;
                        v33 = v31 + 32;
                        if ( (unsigned int)(v31 - 65) > 0x19 )
                          v33 = v31;
                        if ( v29 != v33 )
                        {
                          Com_sprintf(dest, 0x80ui64, "scripts/sp/maps/%s/%s%s", MapName, MapName, ".gsc");
                          GameScriptDataSP->levelscript = GScr_SetScriptAndLabel(dest, "main", 0, functions, loadscripts);
                          return;
                        }
                      }
                      if ( !v29 )
                        goto LABEL_12;
                    }
                  }
                }
                if ( !v23 )
                  goto LABEL_12;
              }
            }
          }
          if ( !v16 )
            goto LABEL_12;
        }
      }
    }
  }
  while ( v9 );
LABEL_12:
  GameScriptDataSP->levelscript = 0;
}

/*
==============
GScr_SetScriptAndLabel
==============
*/
__int64 GScr_SetScriptAndLabel(const char *const scriptfile, const char *const label, const int enforceExists, ScriptFunctions *const functions, EntryLoadScriptArray *loadscripts)
{
  int count; 
  unsigned int v11; 

  if ( !G_MainSP_ShouldLoadScripts() )
    return 0i64;
  if ( I_strcmp(scriptfile, loadscripts->entries[functions->count].scriptfile) )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, scriptfile, loadscripts->entries[functions->count].scriptfile);
  count = functions->count;
  if ( count >= functions->maxSize )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
    count = functions->count;
  }
  if ( enforceExists != loadscripts->entries[count].enforceExists )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, scriptfile);
    count = functions->count;
  }
  v11 = functions->address[count];
  functions->count = count + 1;
  if ( !v11 && enforceExists )
  {
    if ( !scriptfile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_export.h", 295, ASSERT_TYPE_ASSERT, "(scriptfile)", (const char *)&queryFormat, "scriptfile") )
      __debugbreak();
    if ( !label && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_export.h", 296, ASSERT_TYPE_ASSERT, "(label)", (const char *)&queryFormat, "label") )
      __debugbreak();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, label, scriptfile);
  }
  return v11;
}

/*
==============
GScr_SetScriptsForPathNode
==============
*/
void GScr_SetScriptsForPathNode(pathnode_t *loadNode, void *data)
{
  unsigned __int16 type; 
  scr_string_t animscript; 
  vec3_t pos; 

  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 189, ASSERT_TYPE_ASSERT, "(functions)", (const char *)&queryFormat, "functions") )
    __debugbreak();
  type = loadNode->constant.type;
  if ( type )
  {
    animscript = loadNode->constant.animscript;
    if ( ((1 << type) & 0x68010000) != 0 )
    {
      if ( !animscript )
      {
        pathnode_t::GetPos(loadNode, &pos);
        Com_PrintError(1, "ERROR: Pathnode (%s) at (%g %g %g) has no animscript specified\n", nodeStringTable[loadNode->constant.type], pos.v[0], pos.v[1], pos.v[2]);
        Path_SetNodeTypeError(loadNode);
      }
    }
    else if ( animscript )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 196, ASSERT_TYPE_ASSERT, "(loadNode->constant.animscript == ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "loadNode->constant.animscript == NULL_SCR_STRING") )
        __debugbreak();
    }
  }
}

/*
==============
GScr_SetSingleAnimScript
==============
*/
void GScr_SetSingleAnimScript(ScriptFunctions *functions, EntryLoadScriptArray *loadscripts, GScrAnimScriptFunc *pAnim, const char *name, const char *subdir)
{
  int v9; 
  __int64 count; 
  __int64 v11; 
  char *scriptfile; 
  char *v13; 
  char v14; 
  __int64 v15; 
  char v16; 
  int v17; 
  char dest[128]; 

  if ( !pAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 287, ASSERT_TYPE_ASSERT, "(pAnim)", (const char *)&queryFormat, "pAnim") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 288, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( subdir )
    Com_sprintf(dest, 0x80ui64, "scripts/anim/%s/%s%s", subdir, name, ".gsc");
  else
    Com_sprintf(dest, 0x80ui64, "scripts/anim/%s%s", name, ".gsc");
  if ( G_MainSP_ShouldLoadScripts() )
  {
    count = functions->count;
    v11 = 0x7FFFFFFFi64;
    scriptfile = loadscripts->entries[count].scriptfile;
    if ( (EntryLoadScriptArray *)((char *)loadscripts + 160 * count) == (EntryLoadScriptArray *)-24i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, (AssertType)(160 * count + (_DWORD)loadscripts + 25), "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v13 = (char *)(dest - scriptfile);
    do
    {
      v14 = scriptfile[(_QWORD)v13];
      v15 = v11;
      v16 = *scriptfile++;
      --v11;
      if ( !v15 )
        break;
      if ( v14 != v16 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144360860, 239i64, dest, loadscripts->entries[functions->count].scriptfile);
        break;
      }
    }
    while ( v14 );
    v17 = functions->count;
    if ( v17 >= functions->maxSize )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14435C470, 240i64);
      v17 = functions->count;
    }
    if ( loadscripts->entries[v17].enforceExists != 1 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1443608E0, 241i64, dest);
      v17 = functions->count;
    }
    v9 = functions->address[v17];
    functions->count = v17 + 1;
    if ( !v9 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "main", dest);
  }
  else
  {
    v9 = 0;
  }
  pAnim->func = v9;
  pAnim->endFunc = GScr_SetScriptAndLabel(dest, "end_script", 0, functions, loadscripts);
  pAnim->name = GScr_AllocString(name);
}

/*
==============
GScr_StartRagdollInternal
==============
*/
void GScr_StartRagdollInternal(gentity_s *ent, bool bAutoUnlink)
{
  trajectory_t_secure *p_pos; 
  unsigned int v4; 
  unsigned int v5; 
  unsigned int v6; 
  XAnimTree *EntAnimTree; 
  vec3_t outPos; 
  GTrajectory v9; 
  __int64 v10; 
  float v11; 

  if ( bAutoUnlink )
    G_EntUnlink(ent);
  GTrajectory::GTrajectory(&v9, ent);
  p_pos = &ent->s.lerp.pos;
  if ( ent->s.lerp.pos.trType == TR_INTERPOLATE )
  {
    p_pos->trType = TR_RAGDOLL_INTERPOLATE;
  }
  else if ( ent->s.lerp.pos.trType == TR_GRAVITY )
  {
    p_pos->trType = TR_RAGDOLL_GRAVITY;
  }
  else
  {
    p_pos->trType = TR_FIRST_RAGDOLL;
    if ( ent == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared_inline.h", 107, ASSERT_TYPE_ASSERT, "(traj)", (const char *)&queryFormat, "traj", -2i64) )
      __debugbreak();
    if ( p_pos->trType == TR_LINEAR_STOP_SECURE )
    {
      *(_QWORD *)&outPos.y = *(_QWORD *)ent->s.lerp.pos.trBase.v ^ __PAIR64__(LODWORD(ent->s.lerp.pos.trBase.v[2]) ^ s_trbase_aab_Z, LODWORD(ent->s.lerp.pos.trBase.v[1]) ^ s_trbase_aab_Y);
      LODWORD(outPos.v[0]) = LODWORD(ent->s.lerp.pos.trBase.v[0]) ^ ~s_trbase_aab_X;
      memset(&v10, 0, sizeof(v10));
      v11 = outPos.v[0];
      if ( (LODWORD(outPos.v[0]) & 0x7F800000) == 2139095040 || (v11 = outPos.v[1], (LODWORD(outPos.v[1]) & 0x7F800000) == 2139095040) || (v11 = outPos.v[2], (LODWORD(outPos.v[2]) & 0x7F800000) == 2139095040) )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared_inline.h", 74, ASSERT_TYPE_SANITY, "( !IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] )") )
          __debugbreak();
      }
    }
    else
    {
      outPos = ent->s.lerp.pos.trBase;
    }
    BgTrajectory::EvaluatePosTrajectory(&v9, level.time, &outPos);
    if ( ent == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared_inline.h", 82, ASSERT_TYPE_ASSERT, "(traj)", (const char *)&queryFormat, "traj") )
      __debugbreak();
    if ( p_pos->trType == TR_LINEAR_STOP_SECURE )
    {
      v11 = outPos.v[0];
      if ( (LODWORD(outPos.v[0]) & 0x7F800000) == 2139095040 || (v11 = outPos.v[1], (LODWORD(outPos.v[1]) & 0x7F800000) == 2139095040) || (v11 = outPos.v[2], (LODWORD(outPos.v[2]) & 0x7F800000) == 2139095040) )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared_inline.h", 24, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
          __debugbreak();
      }
      v4 = LODWORD(outPos.v[0]) ^ ~s_trbase_aab_X;
      v5 = v4 ^ s_trbase_aab_Y ^ LODWORD(outPos.v[1]);
      v6 = v5 ^ s_trbase_aab_Z ^ LODWORD(outPos.v[2]);
      LODWORD(ent->s.lerp.pos.trBase.v[0]) = v4;
      LODWORD(ent->s.lerp.pos.trBase.v[1]) = v5;
      LODWORD(ent->s.lerp.pos.trBase.v[2]) = v6;
      memset(&v10, 0, sizeof(v10));
    }
    else
    {
      ent->s.lerp.pos.trBase = outPos;
    }
    *(_QWORD *)ent->s.lerp.pos.trDelta.v = 0i64;
    ent->s.lerp.pos.trDelta.v[2] = 0.0;
    memset(&outPos, 0, sizeof(outPos));
  }
  if ( ent->s.lerp.apos.trType == TR_INTERPOLATE )
  {
    ent->s.lerp.apos.trType = TR_RAGDOLL_INTERPOLATE;
  }
  else if ( ent->s.lerp.apos.trType == TR_GRAVITY )
  {
    ent->s.lerp.apos.trType = TR_RAGDOLL_GRAVITY;
  }
  else
  {
    ent->s.lerp.apos.trType = TR_FIRST_RAGDOLL;
    BgTrajectory::EvaluateAngTrajectory(&v9, level.time, &ent->s.lerp.apos.trBase);
    *(_QWORD *)ent->s.lerp.apos.trDelta.v = 0i64;
    ent->s.lerp.apos.trDelta.v[2] = 0.0;
  }
  EntAnimTree = G_Utils_GetEntAnimTree(ent);
  if ( EntAnimTree )
    XAnimSetClientNotifyFlag(EntAnimTree, 1);
}

/*
==============
GScriptSP::GetFunction
==============
*/
unsigned int GScriptSP::GetFunction(GScriptSP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceFunctions_Server);
  if ( !result )
  {
    result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceSPFunctions_Server);
    if ( !result )
    {
      result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_BothServer);
      if ( !result )
      {
        result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_Server);
        if ( !result )
        {
          result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrPhysicsFunctions_Server);
          if ( !result )
          {
            result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrSentientFunctions_Server);
            if ( !result )
            {
              result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrObjectivesFunctions_Server);
              if ( !result )
              {
                result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrAIFunctions_Server);
                if ( !result )
                {
                  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrWeaponFunctions_Server);
                  if ( !result )
                    return Scr_GetFunctionFromTable(v5, pName, type, &g_scrBuiltinSPFunctions_Server);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
GScriptSP::GetMethod
==============
*/
unsigned int GScriptSP::GetMethod(GScriptSP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceMethods_Server);
  if ( !result )
  {
    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceSPMethods_Server);
    if ( !result )
    {
      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMainMethods_Server);
      if ( !result )
      {
        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAIMethods_Server);
        if ( !result )
        {
          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrSentientMethods_Server);
          if ( !result )
          {
            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAnimationMethods_Server);
            if ( !result )
            {
              result = Scr_GetMethodFromTable(v5, pName, type, &g_scrClientScrSPMethods_Server);
              if ( !result )
              {
                result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPlayerCommonMethods_Server);
                if ( !result )
                {
                  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMoverMethods_Server);
                  if ( !result )
                  {
                    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPhysicsMethods_Server);
                    if ( !result )
                    {
                      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleMethods_Server);
                      if ( !result )
                      {
                        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleSPMethods_Server);
                        if ( !result )
                        {
                          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrHudElemMethods_Server);
                          if ( !result )
                          {
                            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrWeaponMethods_Server);
                            if ( !result )
                              return Scr_GetMethodFromTable(v5, pName, type, &g_scrBuiltinSPMethods_Server);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
ParsePlaySoundCmd
==============
*/
void ParsePlaySoundCmd(scrContext_t *scrContext, scr_entref_t entref, int event)
{
  unsigned int NumParam; 
  gentity_s *Entity; 
  const char *String; 
  const SndAliasList *Alias; 
  const char *v10; 
  const char *v11; 
  unsigned __int16 v12; 
  int Int; 
  unsigned int v14; 
  unsigned int v15; 
  scr_string_t ConstString; 
  char *fmt; 
  __int64 v18; 
  char dest[128]; 

  if ( event != 3 && event != 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2502, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled sound alias event type") )
    __debugbreak();
  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( !*String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2510, ASSERT_TYPE_ASSERT, "(pszSoundName[0])", (const char *)&queryFormat, "pszSoundName[0]") )
    __debugbreak();
  Alias = SND_TryFindAlias(String);
  if ( !Alias )
  {
    v10 = j_va("unknown sound alias '%s'", String);
    Scr_ParamError(COM_ERR_2062, scrContext, 0, v10);
  }
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v11 = j_va("'%s' is a looping alias, use 'playloopsound' instead", String);
    Scr_ParamError(COM_ERR_2063, scrContext, 0, v11);
  }
  v12 = G_CStringSP_SoundAliasIndexTransient(Alias->aliasName);
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 2521, ASSERT_TYPE_ASSERT, "(soundIndex)", (const char *)&queryFormat, "soundIndex") )
    __debugbreak();
  Entity->r.svFlags &= ~1u;
  Int = 0;
  v14 = NumParam - 1;
  if ( v14 )
  {
    v15 = v14 - 1;
    if ( v15 )
    {
      if ( v15 != 1 )
      {
        Scr_Error(COM_ERR_2064, scrContext, "Sound Error");
        return;
      }
      Int = Scr_GetInt(scrContext, 2u);
    }
    LODWORD(v18) = event - 3;
    LODWORD(fmt) = v12;
    ConstString = Scr_GetConstString(scrContext, 1u);
    Com_sprintf(dest, 0x80ui64, "snd %d %d %d", (unsigned int)Entity->s.number, fmt, v18);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
    G_UtilsSP_RegisterSoundWait(scrContext, Entity, v12, ConstString, Int);
  }
  else
  {
    G_Utils_AddEvent(Entity, event, v12);
  }
}

/*
==============
ScrCmd_SpawnInternal
==============
*/
void ScrCmd_SpawnInternal(scrContext_t *scrContext, scr_entref_t entref, enumForceSpawn forceSpawn, const char *funcName)
{
  bool v8; 
  int NumParam; 
  scr_string_t ConstString; 
  bool v11; 
  gentity_s *Entity; 
  gentity_s *v13; 
  const char *v14; 
  double v15; 
  double v16; 
  double v17; 
  const char *v18; 
  scr_string_t v19; 
  const char *v20; 
  const char *v21; 
  double v22; 
  double v23; 
  double v24; 
  const char *v25; 
  scr_string_t v26; 
  const char *v27; 
  const gentity_s *v28; 
  spawner_t *Spawner; 
  spawner_t *v30; 
  const char *v31; 
  scr_string_t targetname; 
  const char *v33; 
  const gentity_s *v34; 
  const char *ClassMapName; 
  const char *v36; 
  const char *v37; 
  EntityClass entclass; 

  entclass = entref.entclass;
  v8 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 1 )
    v8 = Scr_GetInt(scrContext, 0) != 0;
  ConstString = 0;
  if ( NumParam >= 2 )
    ConstString = Scr_GetConstString(scrContext, 1u);
  v11 = 0;
  if ( NumParam >= 3 )
    v11 = Scr_GetInt(scrContext, 2u) != 0;
  if ( entclass )
  {
    if ( entclass == ENTITY_CLASS_SPAWNER )
    {
      Spawner = G_GetSpawner(entref);
      v30 = Spawner;
      if ( v11 || Spawner->timestamp < level.time )
      {
        v34 = G_ActorSP_SpawnActorFromSpawner(Spawner, ConstString, forceSpawn, v8);
        if ( v34 )
        {
          v30->timestamp = level.time;
          GScr_AddEntity(v34);
        }
      }
      else
      {
        v31 = vtos(&Spawner->origin);
        targetname = v30->spawner->targetname;
        if ( targetname )
          v33 = SL_ConvertToString(targetname);
        else
          v33 = "<unnamed>";
        Com_PrintWarning(23, "WARNING: %s called twice in frame. Attempted to call %s on spawn with name '%s' at %s\n", funcName, funcName, v33, v31);
      }
    }
    else
    {
      ClassMapName = ScriptContext_GetClassMapName(scrContext, entclass);
      v36 = j_va("DoSpawn Unsupported class type %s", ClassMapName);
      Scr_Error(COM_ERR_2054, scrContext, v36);
    }
  }
  else
  {
    Entity = GetEntity(entref);
    v13 = Entity;
    v14 = "<unnamed>";
    if ( Entity->s.eType != ET_ACTOR_SPAWNER )
    {
      v15 = Entity->r.currentOrigin.v[2];
      v16 = Entity->r.currentOrigin.v[1];
      v17 = Entity->r.currentOrigin.v[0];
      v18 = SL_ConvertToString(Entity->classname);
      v19 = v13->targetname;
      v37 = v18;
      if ( v19 )
        v20 = SL_ConvertToString(v19);
      else
        v20 = "<unnamed>";
      v21 = j_va("%s can only be called on actor spawners\nattempted to call %s on entity with name '%s' of type '%s' at (%.0f %.0f %.0f)\n", funcName, funcName, v20, v37, v17, v16, v15);
      Scr_Error(COM_ERR_2053, scrContext, v21);
    }
    if ( v11 || v13->c.item[0].clipAmmoCount[0] < level.time )
    {
      v28 = G_ActorSP_SpawnActorFromEnt(v13, ConstString, forceSpawn, v8);
      if ( v28 )
      {
        v13->c.item[0].clipAmmoCount[0] = level.time;
        GScr_AddEntity(v28);
      }
    }
    else
    {
      v22 = v13->r.currentOrigin.v[2];
      v23 = v13->r.currentOrigin.v[1];
      v24 = v13->r.currentOrigin.v[0];
      v25 = SL_ConvertToString(v13->classname);
      v26 = v13->targetname;
      v27 = v25;
      if ( v26 )
        v14 = SL_ConvertToString(v26);
      Com_PrintWarning(23, "WARNING: %s called twice in frame. Attempted to call %s on entity with name '%s' of type '%s' at (%.0f %.0f %.0f)\n", funcName, funcName, v14, v27, v24, v23, v22);
    }
  }
}

/*
==============
Scr_CheckForSaveErrors
==============
*/
void Scr_CheckForSaveErrors(scrContext_t *scrContext, int saveId)
{
  if ( saveId == -2 )
  {
    Scr_Error(COM_ERR_2128, scrContext, "Attempting to save multiple times in a single frame.\n");
  }
  else if ( saveId == -1 )
  {
    Scr_Error(COM_ERR_2127, scrContext, "Attempting to save during a restart.\n");
  }
  else if ( saveId == -3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 4307, ASSERT_TYPE_ASSERT, "(saveId != INVALID_SAVE_PENDING_SAVE_BUFFER_EXCEEDED)", (const char *)&queryFormat, "saveId != INVALID_SAVE_PENDING_SAVE_BUFFER_EXCEEDED") )
  {
    __debugbreak();
  }
}

/*
==============
Scr_NonLocalizedStringErrorPrefix
==============
*/
__int64 Scr_NonLocalizedStringErrorPrefix(scrContext_t *scrContext, int parmIndex, unsigned int tokenLen, const char *errorContext, unsigned int stringLen, unsigned int stringLimit, char *string)
{
  const dvar_t *v7; 
  __int64 result; 
  const char *v13; 

  v7 = DCONST_DVARBOOL_loc_warnings;
  if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return stringLen;
  if ( tokenLen + stringLen + 14 >= stringLimit )
  {
    v13 = j_va("%s is too long. Max length is %i\n", errorContext, stringLimit);
    Scr_ParamError(COM_ERR_2030, scrContext, parmIndex, v13);
  }
  if ( stringLen + 13 >= stringLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 469, ASSERT_TYPE_ASSERT, "(stringLen + LOCALIZATION_ERROR_PREFIX_LENGTH < stringLimit)", (const char *)&queryFormat, "stringLen + LOCALIZATION_ERROR_PREFIX_LENGTH < stringLimit") )
    __debugbreak();
  result = stringLen + 13;
  *(double *)&string[stringLen] = *(double *)"UNLOCALIZED: ";
  qmemcpy(&string[stringLen + 8], "ZED: ", 5);
  return result;
}

/*
==============
Scr_ValidateNonLocalizedStringRef
==============
*/
char Scr_ValidateNonLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen, const char *errorContext)
{
  signed __int64 v5; 
  signed __int64 v9; 
  const char *v10; 
  char v11; 
  const char *v12; 
  const dvar_t *v14; 
  const dvar_t *v15; 
  const char *v16; 

  v5 = tokenLen;
  if ( !token && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\g_scr_main_sp.cpp", 435, ASSERT_TYPE_ASSERT, "(token)", (const char *)&queryFormat, "token") )
    __debugbreak();
  v9 = v5;
  if ( (int)v5 <= 0 )
    return 1;
  v10 = token;
  while ( 1 )
  {
    v11 = *v10;
    if ( (unsigned __int8)(*v10 - 30) <= 1u || v11 == 22 )
    {
      v12 = j_va("bad escape character (%i) present in string", (unsigned int)v11);
      Scr_ParamError(COM_ERR_2029, scrContext, parmIndex, v12);
      v11 = *v10;
    }
    if ( isalpha(v11) )
      break;
    if ( ++v10 - token >= v9 )
      return 1;
  }
  v14 = DCONST_DVARBOOL_loc_warnings;
  if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  if ( v14->current.enabled )
  {
    v15 = DCONST_DVARBOOL_loc_warningsAsErrors;
    if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    if ( v15->current.enabled )
    {
      v16 = j_va("non-localized %s strings are not allowed to have letters in them: \"%s\"", errorContext, token);
      Scr_LocalizationError(scrContext, parmIndex, v16);
      return 0;
    }
    Com_PrintWarning(23, "WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a localized string: \"%s\"\n", errorContext, token);
  }
  return 0;
}

