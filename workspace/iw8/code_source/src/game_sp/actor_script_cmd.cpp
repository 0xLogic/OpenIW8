/*
==============
AIActorInterface::ScrShouldTeleport_Strict
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Strict(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq, float checkDistSq)
{
  return ?ScrShouldTeleport_Strict@AIActorInterface@@UEBA_NAEAUscrContext_t@@AEBTvec3_t@@MM@Z(this, scrContext, teleportPos, distFromPosSq, checkDistSq);
}

/*
==============
AIActorInterface::OnScrCmd_StartScriptedAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_StartScriptedAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartScriptedAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleNotSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_VisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_VisibleNotSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetPupilDiameter
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetPupilDiameter(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPupilDiameter@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_Teleport
==============
*/

void __fastcall AIActorInterface::OnScrCmd_Teleport(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_Teleport@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AnimCustom
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AnimCustom(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AnimCustom@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetTalkToSpecies
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetTalkToSpecies(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTalkToSpecies@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CodeMoveAnimRate
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CodeMoveAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CodeMoveAnimRate@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AIClearAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AIClearAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIClearAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetTurretAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetTurretAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTurretAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimTime
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimTime(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimTime@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::ScrTeleport
==============
*/

void __fastcall AIScriptedInterface::ScrTeleport(AIScriptedInterface *this, scrContext_t *scrContext, TeleportCheckMode checkMode)
{
  ?ScrTeleport@AIScriptedInterface@@IEBAXAEAUscrContext_t@@W4TeleportCheckMode@@@Z(this, scrContext, checkMode);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Reset
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Reset(AIActorInterface *this, const vec3_t *teleportPos, float distFromPosSq)
{
  return ?ScrShouldTeleport_Reset@AIActorInterface@@UEBA_NAEBTvec3_t@@M@Z(this, teleportPos, distFromPosSq);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimBlendCurve
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimBlendCurve(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimBlendCurve@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_InitRiotshieldHealth
==============
*/

void __fastcall AIActorInterface::OnScrCmd_InitRiotshieldHealth(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_InitRiotshieldHealth@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnob
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnob@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CheckProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CheckProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CheckProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_GetTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_GetTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetLaserFlag
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetLaserFlag(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetLaserFlag@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_StopUseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_StopUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StopUseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOn
==============
*/

void __fastcall AIActorInterface::OnScrCmd_LaserAltOn(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_LaserAltOn@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_EnterProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_EnterProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnterProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOff
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AimAssistOff(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AimAssistOff@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobLimited
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnobLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnobLimited@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_UpdateProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_UpdateProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_UseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_UseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::SetAnimKnobInternal
==============
*/

void __fastcall AIActorInterface::SetAnimKnobInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  ?SetAnimKnobInternal@AIActorInterface@@CAXAEAUscrContext_t@@PEAUgentity_s@@I@Z(scrContext, ent, flags);
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOn
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AimAssistOn(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AimAssistOn@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::SetAnimInternal
==============
*/

void __fastcall AIActorInterface::SetAnimInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  ?SetAnimInternal@AIActorInterface@@CAXAEAUscrContext_t@@PEAUgentity_s@@I@Z(scrContext, ent, flags);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimRate
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimRate@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceTeleport
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceTeleport@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetProneAnimNodes
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetProneAnimNodes(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetProneAnimNodes@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShouldPlayMeleeDeathAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SafeTeleport
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SafeTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SafeTeleport@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_VisibleSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_VisibleSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_InvisibleNotSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_InvisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_InvisibleNotSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_ExitProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_ExitProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ExitProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Safe
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Safe(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq)
{
  return ?ScrShouldTeleport_Safe@AIActorInterface@@UEBA_NAEAUscrContext_t@@AEBTvec3_t@@M@Z(this, scrContext, teleportPos, distFromPosSq);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOff
==============
*/

void __fastcall AIActorInterface::OnScrCmd_LaserAltOff(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_LaserAltOff@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CanUseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CanUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanUseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimLimited
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimLimited@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetMoveAnimKnob
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetMoveAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetMoveAnimKnob@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobRestart
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnobRestart(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnobRestart@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AIClearAnim
==============
*/
void AIActorInterface::OnScrCmd_AIClearAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  AIActorInterface_vtbl *v7; 
  gentity_s *v8; 
  XAnimTree *EntAnimTree; 
  scr_string_t AnimsetName; 
  scr_string_t ConstString; 
  int Int; 
  const char *v14; 
  const char *String; 
  const char *v16; 
  unsigned int v17; 
  const XAnim_s *SubTreeAnims; 
  XAnimCurveID curveID; 
  DObj *ServerDObjForEnt; 
  float pOutGraftNode; 
  float pOutGraftNodea; 
  float pOutAnimSubtreeID; 
  float pOutAnimCurveID; 
  unsigned int pOutAnimIndex; 
  int pOutStateIndex; 
  float weight; 
  AnimsetState *outState; 
  XAnimCurveID v33; 
  XAnimSubTreeID v34; 

  v33 = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1568, scrContext, "AnimScripted entities are not supported in this game mode");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    v7 = this->__vftable;
    __asm { vmovaps [rsp+98h+var_38], xmm6 }
    v8 = v7->GetEntity(this);
    EntAnimTree = GScr_GetEntAnimTree(v8);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v8->s);
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    outState = NULL;
    __asm { vmovaps xmm6, xmm0 }
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v14 = SL_ConvertToString(AnimsetName);
      String = Scr_GetString(scrContext, 0);
      v16 = j_va("Unable to find state %s in animset %s", String, v14);
      Scr_Error(COM_ERR_1569, scrContext, v16);
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, (unsigned int *)&weight, &v34, &v33);
    if ( ShouldDumpAnimCommand(scrContext, v8->s.number, 3u) )
    {
      v17 = pOutAnimIndex;
      SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, v34);
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  dword ptr [rsp+98h+pOutAnimCurveID], xmm0
        vxorps  xmm1, xmm1, xmm1
        vmovss  dword ptr [rsp+98h+pOutAnimSubtreeID], xmm6
        vmovss  dword ptr [rsp+98h+pOutGraftNode], xmm1
      }
      DumpAnimCommandInternal("ClearAnim", SubTreeAnims, v17, -1, pOutGraftNode, pOutAnimSubtreeID, pOutAnimCurveID);
    }
    curveID = v33;
    ServerDObjForEnt = Com_GetServerDObjForEnt(v8);
    __asm { vmovss  dword ptr [rsp+98h+pOutGraftNode], xmm6 }
    XAnimClearTreeGoalWeights(EntAnimTree, LODWORD(weight), v34, pOutAnimIndex, pOutGraftNodea, 1, ServerDObjForEnt, curveID);
    __asm { vmovaps xmm6, [rsp+98h+var_38] }
  }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnim
==============
*/
void AIActorInterface::OnScrCmd_AISetAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v7; 
  unsigned int v9; 
  char v11; 
  int Int; 
  scr_string_t ConstString; 
  actor_s *m_pAI; 
  scr_string_t AnimsetName; 
  const Animset *v16; 
  const char *name; 
  const char *String; 
  const char *v19; 
  const char *v20; 
  const char *v21; 
  int v23; 
  int pOutStateIndex; 
  AnimsetState *outState; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1561, scrContext, "AnimScripted entities are not supported int this game mode");
  v7 = this->GetEntity(this);
  if ( !Com_GetServerDObjForEnt(v7) )
    Scr_ObjectError(COM_ERR_1562, scrContext, "No model exists.");
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v9 = Scr_GetNumParam(scrContext) - 2;
  if ( v9 )
  {
    if ( v9 != 1 )
      Scr_Error(COM_ERR_1563, scrContext, "incorrect number of parameters");
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    if ( v11 )
      Scr_ParamError(COM_ERR_1564, scrContext, 4u, "must set nonnegative rate for flagged anims");
  }
  Int = Scr_GetInt(scrContext, 1u);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetType(scrContext, 1u) != VAR_INTEGER )
    Scr_ParamError(COM_ERR_1565, scrContext, 1u, "Expecting int");
  m_pAI = this->m_pAI;
  outState = NULL;
  AnimsetName = BG_AnimationState_GetAnimsetName(&m_pAI->ent->s);
  v16 = Animset_Find(AnimsetName);
  BG_Animset_GetStateInfoByName(v16, ConstString, &outState, &pOutStateIndex);
  if ( !outState )
  {
    name = v16->name;
    String = Scr_GetString(scrContext, 0);
    v19 = j_va("Unable to find state %s in animset %s", String, name);
    Scr_ParamError(COM_ERR_1566, scrContext, 0, v19);
  }
  if ( Int < 0 )
  {
    v20 = Scr_GetString(scrContext, 0);
    v21 = j_va("invalid entry index %d for animset %s state %s", (unsigned int)Int, v16->name, v20);
    Scr_ParamError(COM_ERR_1567, scrContext, 1u, v21);
  }
  __asm { vmovss  [rsp+58h+var_38], xmm6 }
  ((void (__fastcall *)(AIActorInterface *, const Animset *, _QWORD, _QWORD, int))this->SetAnim)(this, v16, (unsigned int)pOutStateIndex, (unsigned int)Int, v23);
  __asm { vmovaps xmm6, [rsp+58h+var_28] }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimBlendCurve
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimBlendCurve(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  XAnimTree *v5; 
  unsigned int v6; 
  scr_string_t ConstString; 
  XAnimCurveID ID; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  unsigned int v12; 
  const char *v13; 
  const XAnim_s *SubTreeAnims; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int animIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1572, scrContext, "AnimScripted entities are not supported in this game mode");
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetNumParam(scrContext) > 4 )
    Scr_Error(COM_ERR_1573, scrContext, "incorrect number of parameters");
  v4 = this->GetEntity(this);
  v5 = this->GetAnimTree(this);
  animIndex = Scr_GetAnim(scrContext, 0, v5).index;
  v6 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &animIndex, NULL);
  ConstString = Scr_GetConstString(scrContext, 1u);
  ID = XAnimCurve_GetID(ConstString);
  if ( ID == CURVE_ASSET_END )
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("AISetAnimBlendCurve: could not find curve '%s'\n", v9);
    Scr_Error(COM_ERR_1574, scrContext, v10);
  }
  XAnimSetAnimCurve(v5, outGraftAnimIndex, outSubTreeID, animIndex, ID);
  if ( ShouldDumpAnimCommand(scrContext, v4->s.number, v6 + 2) )
  {
    v11 = SL_ConvertToString(ConstString);
    v12 = animIndex;
    v13 = v11;
    SubTreeAnims = XAnimGetSubTreeAnims(v5, outSubTreeID);
    DumpAnimSetCurveCommand("SetAnimCurve", SubTreeAnims, v12, -1, v13);
  }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnob
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 1u);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobLimited
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnobLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 0);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobRestart
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnobRestart(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 3u);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimLimited
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimInternal(scrContext, v3, 0);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimRate
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v7; 
  XAnimTree *v8; 
  scr_string_t AnimsetName; 
  unsigned int v10; 
  scr_string_t ConstString; 
  int Int; 
  const char *v14; 
  const char *String; 
  const char *v16; 
  unsigned int v17; 
  const XAnim_s *SubTreeAnims; 
  float pOutGraftNode; 
  float pOutGraftNodea; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  void *retaddr; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int outGraftAnimIndex; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1570, scrContext, "AnimScripted entities are not supported in this game mode");
  v7 = this->GetEntity(this);
  v8 = this->GetAnimTree(this);
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    AnimsetName = BG_AnimationState_GetAnimsetName(&v7->s);
    v10 = 1;
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    outState = NULL;
    __asm { vmovaps xmm6, xmm0 }
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v14 = SL_ConvertToString(AnimsetName);
      String = Scr_GetString(scrContext, 0);
      v16 = j_va("Unable to find state %s in animset %s", String, v14);
      Scr_Error(COM_ERR_1571, scrContext, v16);
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, &outGraftAnimIndex, &outSubTreeID, NULL);
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v8).index;
    v10 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  __asm { vmovss  dword ptr [rsp+98h+pOutGraftNode], xmm6 }
  XAnimSetAnimRate(v8, outGraftAnimIndex, outSubTreeID, pOutAnimIndex, pOutGraftNode);
  if ( ShouldDumpAnimCommand(scrContext, v7->s.number, v10 + 2) )
  {
    v17 = pOutAnimIndex;
    SubTreeAnims = XAnimGetSubTreeAnims(v8, outSubTreeID);
    __asm { vmovss  dword ptr [rsp+98h+pOutGraftNode], xmm6 }
    DumpAnimSetRateCommand("SetAnimRate", SubTreeAnims, v17, -1, pOutGraftNodea);
  }
  __asm { vmovaps xmm6, [rsp+98h+var_48] }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimTime
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimTime(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v7; 
  XAnimTree *v10; 
  unsigned int NumParam; 
  char v12; 
  char v13; 
  const char *v14; 
  ComErrorCode v15; 
  unsigned int v16; 
  const XAnim_s *SubTreeAnims; 
  int IsLeafNode; 
  bool v19; 
  float outAnimIndex; 
  float outAnimIndexa; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int animIndex; 
  unsigned int outGraftAnimIndex; 

  __asm
  {
    vmovaps [rsp+78h+var_38], xmm6
    vmovaps [rsp+78h+var_48], xmm8
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1575, scrContext, "AnimScripted entities are not supported in this game mode");
  v7 = this->GetEntity(this);
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vxorps  xmm6, xmm6, xmm6
  }
  v10 = this->GetAnimTree(this);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam - 2 > 2 )
      Scr_Error(COM_ERR_1576, scrContext, "too many parameters");
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm8
      vmovaps xmm6, xmm0
    }
    if ( v12 )
    {
      __asm { vxorps  xmm6, xmm6, xmm6 }
      v14 = "must be > 0";
      v15 = COM_ERR_1577;
    }
    else
    {
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( v12 | v13 )
        goto LABEL_11;
      __asm { vmovss  xmm6, cs:__real@3f800000 }
      v14 = "must be < 1";
      v15 = COM_ERR_1578;
    }
    Scr_ParamError(v15, scrContext, 1u, v14);
  }
LABEL_11:
  animIndex = Scr_GetAnim(scrContext, 0, v10).index;
  v16 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &animIndex, NULL);
  SubTreeAnims = XAnimGetSubTreeAnims(v10, outSubTreeID);
  IsLeafNode = XAnimIsLeafNode(SubTreeAnims, animIndex);
  v19 = IsLeafNode == 0;
  if ( !IsLeafNode )
    Scr_ParamError(COM_ERR_1579, scrContext, 0, "not a leaf animation");
  __asm { vucomiss xmm6, cs:__real@3f800000 }
  if ( v19 && XAnimIsLooped(SubTreeAnims, animIndex) )
    Scr_ParamError(COM_ERR_1580, scrContext, 1u, "cannot set time 1 on looping animation");
  __asm { vmovss  dword ptr [rsp+78h+outAnimIndex], xmm6 }
  XAnimSetTime(v10, outGraftAnimIndex, outSubTreeID, animIndex, outAnimIndex);
  G_FlagAnimForUpdate(v7);
  if ( ShouldDumpAnimCommand(scrContext, v7->s.number, v16 + 2) )
  {
    __asm { vmovss  dword ptr [rsp+78h+outAnimIndex], xmm6 }
    DumpAnimSetTimeCommand("SetAnimTime", SubTreeAnims, animIndex, -1, outAnimIndexa);
  }
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_38]
    vmovaps xmm8, [rsp+78h+var_48]
  }
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOff
==============
*/
void AIActorInterface::OnScrCmd_AimAssistOff(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel |= 4u;
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOn
==============
*/
void AIActorInterface::OnScrCmd_AimAssistOn(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel &= ~4u;
}

/*
==============
AIActorInterface::OnScrCmd_AnimCustom
==============
*/
void AIActorInterface::OnScrCmd_AnimCustom(AIActorInterface *this, scrContext_t *scrContext)
{
  actor_s *m_pAI; 
  int Func; 
  int v6; 

  m_pAI = this->m_pAI;
  if ( m_pAI->isTransitioningStates )
  {
    Com_PrintWarning(18, "WARNING: AnimCustom() called while transitioning states for AI #%i. The call will be ignored! Please report to code.\n", (unsigned int)m_pAI->ent->s.number);
  }
  else if ( AIScriptedInterface::PushState(this, AIS_CUSTOMANIM) )
  {
    Func = Scr_GetFunc(scrContext, 0);
    if ( Scr_GetNumParam(scrContext) <= 1 )
      v6 = 0;
    else
      v6 = Scr_GetFunc(scrContext, 1u);
    AIScriptedInterface::KillAnimScript(this);
    this->m_pAI->AnimScriptSpecific.func = Func;
    this->m_pAI->AnimScriptSpecific.endFunc = v6;
    Scr_SetString(&this->m_pAI->AnimScriptSpecific.name, scr_const._custom);
  }
}

/*
==============
AIActorInterface::OnScrCmd_CanUseTurret
==============
*/
void AIActorInterface::OnScrCmd_CanUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  bool CanUse; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_ParamError(COM_ERR_1557, scrContext, 0, "can only use a turret");
  CanUse = G_TurretSP_ActorCanUse(this->m_pAI, Entity);
  Scr_AddBool(scrContext, CanUse);
}

/*
==============
AIActorInterface::OnScrCmd_CheckProne
==============
*/
void AIActorInterface::OnScrCmd_CheckProne(AIActorInterface *this, scrContext_t *scrContext)
{
  GHandler *handler; 
  gentity_s *v10; 
  bool v19; 
  float v21; 
  float v22; 
  int proneValidFlags; 
  vec3_t vPos; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-28h], xmm6 }
  Scr_GetVector(scrContext, 0, &vPos);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  _EBX = Scr_GetInt(scrContext, 2u);
  handler = GHandler::getHandler();
  v10 = this->GetEntity(this);
  __asm { vmovss  xmm2, cs:__real@41c80000 }
  proneValidFlags = 0;
  __asm
  {
    vmovd   xmm1, edx
    vmovd   xmm0, ebx
    vpcmpeqd xmm3, xmm0, xmm1
    vmovss  xmm1, cs:__real@42480000
    vblendvps xmm0, xmm1, xmm2, xmm3
    vmovss  xmm3, cs:__real@42400000; fHeight
    vmovss  xmm2, cs:__real@41700000; fSize
    vmovss  [rsp+0D8h+var_70], xmm0
    vmovss  [rsp+0D8h+var_B8], xmm6
  }
  v19 = BG_CheckProneValid(v10->s.number, &vPos, *(const float *)&_XMM2, *(const float *)&_XMM3, v21, NULL, NULL, _EBX != 0, 1, 1, handler, PHYSICS_WORLD_ID_FIRST, PCT_ACTOR, v22, FEETDIR_BACK, NULL, NULL);
  Scr_AddBool(scrContext, v19);
  __asm { vmovaps xmm6, [rsp+0D8h+var_28] }
}

/*
==============
AIActorInterface::OnScrCmd_CodeMoveAnimRate
==============
*/
void AIActorInterface::OnScrCmd_CodeMoveAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+0E78h], xmm0 }
}

/*
==============
AIActorInterface::OnScrCmd_EnterProne
==============
*/
void AIActorInterface::OnScrCmd_EnterProne(AIActorInterface *this, scrContext_t *scrContext)
{
  BOOL v10; 
  const dvar_t *v12; 
  actor_s *m_pAI; 
  unsigned int animProneLow; 
  XAnimTree *v18; 
  unsigned int animProneLevel; 
  XAnimTree *v21; 
  unsigned int animProneHigh; 
  XAnimTree *v23; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float time; 
  float timea; 
  float timeb; 
  float rate; 
  float ratea; 
  float rateb; 

  _RAX = this->m_pAI;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm0, dword ptr [rax+0BD0h]
  }
  if ( !_RAX->prone.animProneLow || !_RAX->prone.animProneLevel || !_RAX->prone.animProneHigh )
    Scr_Error(COM_ERR_1553, scrContext, "Must call SetProneAnimNodes before calling EnterProne");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmulss  xmm1, xmm0, cs:__real@447a0000 }
  v10 = 1;
  __asm { vcvttss2si ebp, xmm1 }
  if ( Scr_GetNumParam(scrContext) > 1 )
    v10 = Scr_GetInt(scrContext, 1u) == 0;
  AIScriptedInterface::EnterProne(this, _EBP, (FeetDirection)v10);
  v12 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  m_pAI = this->m_pAI;
  if ( v12->current.integer == m_pAI->ent->s.number )
  {
    if ( m_pAI->prone.animProneLevel )
    {
      animProneLow = m_pAI->prone.animProneLow;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ebp
        vmovaps [rsp+68h+var_18], xmm6
        vmovaps [rsp+68h+var_28], xmm7
        vmulss  xmm7, xmm0, cs:__real@3a83126f
      }
      v18 = this->GetAnimTree(this);
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vmovss  [rsp+68h+rate], xmm6
        vmovss  [rsp+68h+time], xmm7
        vmovss  dword ptr [rsp+68h+fmt], xmm6
      }
      DumpAnimCommand("EnterProne", v18, animProneLow, -1, fmt, time, rate);
      animProneLevel = this->m_pAI->prone.animProneLevel;
      v21 = this->GetAnimTree(this);
      __asm
      {
        vmovss  [rsp+68h+rate], xmm6
        vmovss  [rsp+68h+time], xmm7
        vmovss  dword ptr [rsp+68h+fmt], xmm6
      }
      DumpAnimCommand("EnterProne", v21, animProneLevel, -1, fmta, timea, ratea);
      animProneHigh = this->m_pAI->prone.animProneHigh;
      v23 = this->GetAnimTree(this);
      __asm
      {
        vmovss  [rsp+68h+rate], xmm6
        vmovss  [rsp+68h+time], xmm7
        vmovss  dword ptr [rsp+68h+fmt], xmm6
      }
      DumpAnimCommand("EnterProne", v23, animProneHigh, -1, fmtb, timeb, rateb);
      __asm
      {
        vmovaps xmm7, [rsp+68h+var_28]
        vmovaps xmm6, [rsp+68h+var_18]
      }
    }
  }
}

/*
==============
AIActorInterface::OnScrCmd_ExitProne
==============
*/
void AIActorInterface::OnScrCmd_ExitProne(AIActorInterface *this, scrContext_t *scrContext)
{
  const dvar_t *v9; 
  actor_s *m_pAI; 
  unsigned int animProneLow; 
  XAnimTree *v15; 
  unsigned int animProneLevel; 
  XAnimTree *v19; 
  unsigned int animProneHigh; 
  XAnimTree *v21; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float time; 
  float timea; 
  float timeb; 
  float rate; 
  float ratea; 
  float rateb; 

  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vcvttss2si esi, xmm1
  }
  AIScriptedInterface::ExitProne(this, _ESI);
  v9 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  m_pAI = this->m_pAI;
  if ( v9->current.integer == m_pAI->ent->s.number )
  {
    if ( m_pAI->prone.animProneLevel )
    {
      animProneLow = m_pAI->prone.animProneLow;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovaps [rsp+78h+var_18], xmm6
        vcvtsi2ss xmm0, xmm0, esi
        vmovaps [rsp+78h+var_28], xmm7
        vmovaps [rsp+78h+var_38], xmm8
        vmulss  xmm8, xmm0, cs:__real@3a83126f
      }
      v15 = this->GetAnimTree(this);
      __asm
      {
        vmovss  xmm7, cs:__real@3f800000
        vmovss  [rsp+78h+rate], xmm7
        vxorps  xmm6, xmm6, xmm6
        vmovss  [rsp+78h+time], xmm8
        vmovss  dword ptr [rsp+78h+fmt], xmm6
      }
      DumpAnimCommand("ExitProne", v15, animProneLow, -1, fmt, time, rate);
      animProneLevel = this->m_pAI->prone.animProneLevel;
      v19 = this->GetAnimTree(this);
      __asm
      {
        vmovss  [rsp+78h+rate], xmm7
        vmovss  [rsp+78h+time], xmm8
        vmovss  dword ptr [rsp+78h+fmt], xmm6
      }
      DumpAnimCommand("ExitProne", v19, animProneLevel, -1, fmta, timea, ratea);
      animProneHigh = this->m_pAI->prone.animProneHigh;
      v21 = this->GetAnimTree(this);
      __asm
      {
        vmovss  [rsp+78h+rate], xmm7
        vmovss  [rsp+78h+time], xmm8
        vmovss  dword ptr [rsp+78h+fmt], xmm6
      }
      DumpAnimCommand("ExitProne", v21, animProneHigh, -1, fmtb, timeb, rateb);
      __asm
      {
        vmovaps xmm8, [rsp+78h+var_38]
        vmovaps xmm7, [rsp+78h+var_28]
        vmovaps xmm6, [rsp+78h+var_18]
      }
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceTeleport
==============
*/
void AIScriptedInterface::OnScrCmd_ForceTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_NONE);
}

/*
==============
AIActorInterface::OnScrCmd_GetTurret
==============
*/
void AIActorInterface::OnScrCmd_GetTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  if ( AICommonInterface::IsUsingTurret(this) )
  {
    if ( !this->m_pAI->turret.pTurret && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 890, ASSERT_TYPE_ASSERT, "(m_pAI->turret.pTurret)", (const char *)&queryFormat, "m_pAI->turret.pTurret") )
      __debugbreak();
    GScr_AddEntity(this->m_pAI->turret.pTurret);
  }
}

/*
==============
AIActorInterface::OnScrCmd_InitRiotshieldHealth
==============
*/
void AIActorInterface::OnScrCmd_InitRiotshieldHealth(AIActorInterface *this, scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v5; 
  WeaponDef **v6; 
  int riotShieldHealth; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    if ( BG_IsRiotShield(&outWeapon, 0) )
    {
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
        __debugbreak();
      v5 = bg_weaponDefs[weaponIdx] == NULL;
      v6 = &bg_weaponDefs[weaponIdx];
      if ( v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( (*v6)->riotShieldEnableDamage )
        riotShieldHealth = (*v6)->riotShieldHealth;
      else
        riotShieldHealth = 1;
      this->m_pAI->shieldHealth = riotShieldHealth;
      __asm { vmovups ymm0, ymmword ptr [rsp+98h+outWeapon.weaponIdx] }
      _RCX = this->m_pAI;
      __asm
      {
        vmovups ymmword ptr [rcx+0E84h], ymm0
        vmovups xmm1, xmmword ptr [rsp+98h+outWeapon.attachmentVariationIndices+5]
        vmovups xmmword ptr [rcx+0EA4h], xmm1
        vmovsd  xmm0, qword ptr [rsp+98h+outWeapon.attachmentVariationIndices+15h]
        vmovsd  qword ptr [rcx+0EB4h], xmm0
      }
      *(_DWORD *)&_RCX->shieldWeapon.weaponCamo = *(_DWORD *)&outWeapon.weaponCamo;
    }
  }
  else
  {
    Scr_Error(COM_ERR_1558, scrContext, "Can't find specified weapon");
  }
}

/*
==============
AIActorInterface::OnScrCmd_InvisibleNotSolid
==============
*/
void AIActorInterface::OnScrCmd_InvisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 0;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOff
==============
*/
void AIActorInterface::OnScrCmd_LaserAltOff(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel &= ~2u;
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOn
==============
*/
void AIActorInterface::OnScrCmd_LaserAltOn(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel |= 2u;
}

/*
==============
AIScriptedInterface::OnScrCmd_SafeTeleport
==============
*/
void AIScriptedInterface::OnScrCmd_SafeTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_STRICT);
}

/*
==============
AIActorInterface::OnScrCmd_SetLaserFlag
==============
*/
void AIActorInterface::OnScrCmd_SetLaserFlag(AIActorInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  gentity_s *ent; 
  unsigned __int8 flags; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( ConstLowercaseString == scr_const.none )
  {
    ent = this->m_pAI->ent;
    flags = ent->s.lerp.u.actor.flags;
    if ( (flags & 0x10) != 0 )
    {
      *(_QWORD *)&ent->s.lerp.u.scriptMover.animIndex = 0i64;
      ent->s.lerp.u.anonymous.data[5] = 0;
      flags = ent->s.lerp.u.actor.flags;
    }
    ent->s.lerp.u.actor.flags = flags & 0xE3;
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xAFu;
  }
  else if ( ConstLowercaseString == scr_const.interpolate )
  {
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 8u;
  }
  else if ( ConstLowercaseString == scr_const.lock )
  {
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 4u;
  }
  else if ( ConstLowercaseString == scr_const.target )
  {
    if ( Scr_GetNumParam(scrContext) < 2 )
      Scr_Error(COM_ERR_1559, scrContext, "Laser flag 'target' requires a target pos.");
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xAFu;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 0x10u;
    Scr_GetVector(scrContext, 1u, &this->m_pAI->ent->s.lerp.u.actor.impactVector);
  }
  else
  {
    Scr_Error(COM_ERR_1560, scrContext, "SetLaserFlag: Invalid parameter. Must be one of: (none,interpolate,lock,target)");
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetMoveAnimKnob
==============
*/
void AIActorInterface::OnScrCmd_SetMoveAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v4; 

  v4 = this->GetAnimTree(this);
  this->m_pAI->moveAnimKnob = Scr_GetAnim(scrContext, 0, v4).index;
}

/*
==============
AIActorInterface::OnScrCmd_SetProneAnimNodes
==============
*/
void AIActorInterface::OnScrCmd_SetProneAnimNodes(AIActorInterface *this, scrContext_t *scrContext)
{
  char v12; 
  char v13; 
  XAnimTree *v14; 
  const dvar_t *v20; 
  actor_s *m_pAI; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float time; 
  float timea; 
  float timeb; 
  float rate; 
  float ratea; 
  float rateb; 
  char v40; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
    vmovaps [rsp+88h+var_38], xmm8
    vmovaps [rsp+88h+var_48], xmm9
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm9, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovaps xmm7, xmm0
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm9, xmm6
  }
  v14 = this->GetAnimTree(this);
  if ( !v12 )
    Scr_Error(COM_ERR_1554, scrContext, "Down angle (parameter 1) must be set to be less than 0.");
  __asm { vcomiss xmm7, xmm6 }
  if ( v12 | v13 )
    Scr_Error(COM_ERR_1555, scrContext, "Up angle (parameter 2) must be set to be greater than 0.");
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vdivss  xmm0, xmm8, xmm9
    vdivss  xmm1, xmm8, xmm7
    vmovss  dword ptr [rax+0BD0h], xmm0
  }
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+0BD4h], xmm1 }
  this->m_pAI->prone.animProneLow = Scr_GetAnim(scrContext, 2u, v14).index;
  this->m_pAI->prone.animProneLevel = Scr_GetAnim(scrContext, 3u, v14).index;
  this->m_pAI->prone.animProneHigh = Scr_GetAnim(scrContext, 4u, v14).index;
  v20 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v20);
  m_pAI = this->m_pAI;
  if ( v20->current.integer == m_pAI->ent->s.number )
  {
    __asm
    {
      vmovss  [rsp+88h+rate], xmm8
      vmovss  [rsp+88h+time], xmm6
      vmovss  dword ptr [rsp+88h+fmt], xmm8
    }
    DumpAnimCommand("SetProneAnimNodes", v14, m_pAI->prone.animProneLow, -1, fmt, time, rate);
    __asm
    {
      vmovss  [rsp+88h+rate], xmm8
      vmovss  [rsp+88h+time], xmm6
      vmovss  dword ptr [rsp+88h+fmt], xmm8
    }
    DumpAnimCommand("SetProneAnimNodes", v14, this->m_pAI->prone.animProneLevel, -1, fmta, timea, ratea);
    __asm
    {
      vmovss  [rsp+88h+rate], xmm8
      vmovss  [rsp+88h+time], xmm6
      vmovss  dword ptr [rsp+88h+fmt], xmm8
    }
    DumpAnimCommand("SetProneAnimNodes", v14, this->m_pAI->prone.animProneHigh, -1, fmtb, timeb, rateb);
  }
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
  _R11 = &v40;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetPupilDiameter
==============
*/
void AIActorInterface::OnScrCmd_SetPupilDiameter(AIActorInterface *this, scrContext_t *scrContext)
{
  char v8; 
  char v9; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_5796, scrContext, "incorrect number of parameters");
  _RDI = this->GetEntity(this);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmovss  xmm6, cs:__real@40000000
    vcomiss xmm0, xmm6
  }
  if ( !v8 )
    goto LABEL_6;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
  }
  if ( v9 )
  {
LABEL_6:
    __asm
    {
      vmovss  xmm6, cs:__real@41000000
      vcomiss xmm0, xmm6
    }
    if ( v8 | v9 )
    {
      __asm
      {
        vmovaps xmm6, [rsp+38h+var_18]
        vmovss  dword ptr [rdi+70h], xmm0
      }
    }
    else
    {
      Scr_ParamError(COM_ERR_5798, scrContext, 0, "must be <= 8");
      __asm
      {
        vmovss  dword ptr [rdi+70h], xmm6
        vmovaps xmm6, [rsp+38h+var_18]
      }
    }
  }
  else
  {
    Scr_ParamError(COM_ERR_5797, scrContext, 0, "must be >= 2 or equal to 0");
    __asm
    {
      vmovss  dword ptr [rdi+70h], xmm6
      vmovaps xmm6, [rsp+38h+var_18]
    }
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetTalkToSpecies
==============
*/
void AIActorInterface::OnScrCmd_SetTalkToSpecies(AIActorInterface *this, scrContext_t *scrContext)
{
  int v4; 
  int v5; 
  scr_string_t ConstString; 
  char v7; 
  const scr_string_t **v8; 

  v4 = 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    while ( 1 )
    {
      ConstString = Scr_GetConstString(scrContext, 0);
      if ( ConstString == scr_const.all )
        break;
      v7 = 0;
      v8 = g_AISpeciesNames;
      while ( ConstString != **v8 )
      {
        ++v7;
        if ( (__int64)++v8 >= (__int64)&RDBG_WELCOME_RAW_502 )
          goto LABEL_8;
      }
      v4 |= 1 << v7;
LABEL_8:
      if ( ++v5 >= Scr_GetNumParam(scrContext) )
        goto LABEL_9;
    }
    this->m_pAI->talkToSpecies = -1;
  }
  else
  {
LABEL_9:
    this->m_pAI->talkToSpecies = v4;
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetTurretAnim
==============
*/
void AIActorInterface::OnScrCmd_SetTurretAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v4; 

  v4 = this->GetAnimTree(this);
  this->m_pAI->turret.turretAnim = Scr_GetAnim(scrContext, 0, v4).index;
  this->m_pAI->turret.turretAnimSet = 1;
}

/*
==============
AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim
==============
*/
void AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  int number; 
  const gentity_s *Entity; 
  int ShouldPlayMeleeChargeDeathAnim; 

  number = this->GetEntity(this)->s.number;
  Entity = GScr_GetEntity(0);
  ShouldPlayMeleeChargeDeathAnim = G_Weapon_ShouldPlayMeleeChargeDeathAnim(this->m_pAI->painDeath.damageMOD, Entity, number);
  Scr_AddBool(scrContext, ShouldPlayMeleeChargeDeathAnim);
}

/*
==============
AIActorInterface::OnScrCmd_StartScriptedAnim
==============
*/
void AIActorInterface::OnScrCmd_StartScriptedAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 

  if ( Scr_GetNumParam(scrContext) > 8 )
    Scr_Error(COM_ERR_1551, scrContext, "too many parameters");
  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_1552, scrContext, "too few parameters");
  v4 = this->GetEntity(this);
  ScrCmd_animscriptedInternal(scrContext, v4, 0);
}

/*
==============
AIActorInterface::OnScrCmd_StopUseTurret
==============
*/
void AIActorInterface::OnScrCmd_StopUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ((void (__fastcall *)(AIActorInterface *, scrContext_t *))this->StopUseTurret)(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_Teleport
==============
*/
void AIActorInterface::OnScrCmd_Teleport(AIActorInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_NORMAL);
}

/*
==============
AIActorInterface::OnScrCmd_UpdateProne
==============
*/
void AIActorInterface::OnScrCmd_UpdateProne(AIActorInterface *this, scrContext_t *scrContext)
{
  actor_s *m_pAI; 
  trajectory_t_secure *p_pos; 
  XAnimTree *v10; 
  unsigned int index; 
  unsigned int v12; 
  const DObj *ServerDObjForEnt; 
  const dvar_t *v17; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 

  if ( BG_ActorIsProne(&this->m_pAI->ProneInfo, level.time) )
  {
    m_pAI = this->m_pAI;
    p_pos = &m_pAI->ent->s.lerp.pos;
    if ( m_pAI->ent == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
      __debugbreak();
    if ( (unsigned int)(p_pos->trType - 23) > 5 )
    {
      __asm
      {
        vmovaps [rsp+0A8h+var_28], xmm6
        vmovaps [rsp+0A8h+var_38], xmm7
        vmovaps [rsp+0A8h+var_48], xmm8
      }
      v10 = this->GetAnimTree(this);
      index = Scr_GetAnim(scrContext, 0, v10).index;
      v12 = Scr_GetAnim(scrContext, 1u, v10).index;
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm { vmovaps xmm7, xmm0 }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
      __asm { vmovaps xmm8, xmm0 }
      ServerDObjForEnt = Com_GetServerDObjForEnt(this->m_pAI->ent);
      __asm
      {
        vmovss  [rsp+0A8h+rate], xmm8
        vmovss  [rsp+0A8h+goalTime], xmm7
        vmovss  dword ptr [rsp+0A8h+fmt], xmm6
      }
      XAnimSetCompleteGoalWeight(ServerDObjForEnt, 0, XANIM_SUBTREE_DEFAULT, index, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0A8h+rate], xmm8
        vmovss  [rsp+0A8h+goalTime], xmm7
        vmovss  dword ptr [rsp+0A8h+fmt], xmm6
      }
      XAnimSetCompleteGoalWeight(ServerDObjForEnt, 0, XANIM_SUBTREE_DEFAULT, v12, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
      this->UpdateProneInformation(this, 0);
      v17 = DVARINT_g_dumpAnimsCommands;
      if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v17);
      if ( v17->current.integer == this->m_pAI->ent->s.number )
      {
        __asm
        {
          vmovss  [rsp+0A8h+rate], xmm8
          vmovss  [rsp+0A8h+goalTime], xmm7
          vmovss  dword ptr [rsp+0A8h+fmt], xmm6
        }
        DumpAnimCommand("UpdateProne", v10, index, -1, fmtb, goalTimeb, rateb);
        __asm
        {
          vmovss  [rsp+0A8h+rate], xmm8
          vmovss  [rsp+0A8h+goalTime], xmm7
          vmovss  dword ptr [rsp+0A8h+fmt], xmm6
        }
        DumpAnimCommand("UpdateProne", v10, v12, -1, fmtc, goalTimec, ratec);
      }
      __asm
      {
        vmovaps xmm7, [rsp+0A8h+var_38]
        vmovaps xmm6, [rsp+0A8h+var_28]
        vmovaps xmm8, [rsp+0A8h+var_48]
      }
    }
  }
}

/*
==============
AIActorInterface::OnScrCmd_UseTurret
==============
*/
void AIActorInterface::OnScrCmd_UseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int v5; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_ParamError(COM_ERR_6619, scrContext, 0, "can only use a turret");
  v5 = this->UseTurret(this, Entity);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleNotSolid
==============
*/
void AIActorInterface::OnScrCmd_VisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 0;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleSolid
==============
*/
void AIActorInterface::OnScrCmd_VisibleSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 33685521;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Reset
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Reset(AIActorInterface *this, const vec3_t *teleportPos, double distFromPosSq)
{
  if ( level.loading )
    return 1;
  __asm { vcomiss xmm2, cs:__real@42c80000 }
  return level.loading != LOADING_DONE;
}

/*
==============
AIActorInterface::ScrShouldTeleport_Safe
==============
*/

char __fastcall AIActorInterface::ScrShouldTeleport_Safe(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, double distFromPosSq)
{
  actor_s *m_pAI; 
  gentity_s *v8; 
  gentity_s *ent; 
  int v10; 
  unsigned int number; 
  scrContext_t *v12; 
  actor_s *v14; 
  vec3_t vEyePosOut; 

  if ( level.loading == LOADING_DONE )
  {
    __asm { vcomiss xmm3, cs:__real@42c80000 }
    if ( level.loading )
    {
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities->r.isInUse != *g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !*g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 575, ASSERT_TYPE_ASSERT, "( G_IsEntityInUse( 0 ) )", (const char *)&queryFormat, "G_IsEntityInUse( 0 )") )
        __debugbreak();
      m_pAI = this->m_pAI;
      v8 = g_entities;
      ent = m_pAI->ent;
      if ( g_entities->classname != scr_const.player && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 527, ASSERT_TYPE_ASSERT, "(player->classname == scr_const.player)", (const char *)&queryFormat, "player->classname == scr_const.player") )
        __debugbreak();
      if ( !v8->sentient && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 528, ASSERT_TYPE_ASSERT, "(player->sentient)", (const char *)&queryFormat, "player->sentient") )
        __debugbreak();
      Sentient_GetEyePosition(v8->sentient, &vEyePosOut);
      v10 = G_ActorSP_PointCouldSeeSpawn(&vEyePosOut, teleportPos, v8->s.number, ent->s.number);
      number = ent->s.number;
      if ( v10 )
      {
        Com_DPrintf(18, "Teleport (of actor %i) failed because player could see goal pos.\n", number);
LABEL_22:
        v12 = ScriptContext_Server();
        Scr_AddInt(v12, 0);
        return 0;
      }
      if ( G_ActorSP_PointCouldSeeSpawn(&vEyePosOut, &ent->r.currentOrigin, v8->s.number, number) )
      {
        Com_DPrintf(18, "Teleport failed because player could see actor (%i).\n", (unsigned int)ent->s.number);
        goto LABEL_22;
      }
    }
    else if ( AICommonInterface::HasPath(this) )
    {
      v14 = this->m_pAI;
      if ( v14->iPathEndTime )
      {
        Com_DPrintf(18, "Teleport failed because actor (%i) in mid-stopping.\n", (unsigned int)v14->ent->s.number);
        Scr_AddBool(scrContext, 0);
        return 0;
      }
    }
  }
  return 1;
}

/*
==============
AIActorInterface::ScrShouldTeleport_Strict
==============
*/

char __fastcall AIActorInterface::ScrShouldTeleport_Strict(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, double distFromPosSq, float checkDistSq)
{
  if ( level.loading )
    return 1;
  __asm { vcomiss xmm3, [rsp+28h+checkDistSq] }
  if ( level.loading == LOADING_DONE )
    return 1;
  Com_DPrintf(18, "SafeTeleport (of actor %i) failed.\n", (unsigned int)this->m_pAI->ent->s.number);
  Scr_AddBool(scrContext, 0);
  return 0;
}

/*
==============
AIScriptedInterface::ScrTeleport
==============
*/
void AIScriptedInterface::ScrTeleport(AIScriptedInterface *this, scrContext_t *scrContext, TeleportCheckMode checkMode)
{
  vec3_t *v9; 
  bool v12; 
  AIScriptedInterface_vtbl *v26; 
  bool v27; 
  AIScriptedInterface_vtbl *v28; 
  bool v29; 
  ai_scripted_t *m_pAI; 
  ai_scripted_t *v33; 
  char v35; 
  char v36; 
  char v37; 
  int number; 
  Ai_Asm *v39; 
  ASM_Instance *Instance; 
  scr_string_t m_Name; 
  Ai_Asm *v42; 
  vec3_t vectorValue; 
  vec3_t v47; 

  __asm { vmovaps [rsp+0B8h+var_58], xmm7 }
  Sys_ProfBeginNamedEvent(0xFFFF0000, "AI_ScrTeleport");
  v9 = NULL;
  _RSI = this->GetEntity(this);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 1u, &v47);
    v9 = &v47;
  }
  __asm { vmovaps [rsp+0B8h+var_48], xmm6 }
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    __asm { vmovss  xmm6, cs:__real@42c80000 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmulss  xmm6, xmm0, xmm0 }
  }
  v12 = Scr_GetNumParam(scrContext) > 3 && Scr_GetInt(scrContext, 3u);
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+130h]
    vsubss  xmm3, xmm0, dword ptr [rsp+0B8h+vectorValue]
    vmovss  xmm1, dword ptr [rsi+134h]
    vmovss  xmm0, dword ptr [rsi+138h]
    vsubss  xmm2, xmm1, dword ptr [rsp+0B8h+vectorValue+4]
    vsubss  xmm4, xmm0, dword ptr [rsp+0B8h+vectorValue+8]
    vmulss  xmm2, xmm2, xmm2
    vmulss  xmm1, xmm3, xmm3
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm3, xmm2, xmm1
    vaddss  xmm7, xmm3, xmm0
  }
  if ( checkMode == TELEPORT_CHECK_STRICT )
  {
    __asm
    {
      vmovaps xmm3, xmm7
      vmovss  dword ptr [rsp+0B8h+updateBroadphase], xmm6
    }
    if ( !((unsigned __int8 (__fastcall *)(AIScriptedInterface *, scrContext_t *, vec3_t *))this->ScrShouldTeleport_Strict)(this, scrContext, &vectorValue) )
      goto LABEL_43;
    goto LABEL_15;
  }
  if ( checkMode != TELEPORT_CHECK_NONE )
  {
LABEL_15:
    __asm { vmovaps xmm3, xmm7 }
    if ( !((unsigned __int8 (__fastcall *)(AIScriptedInterface *, scrContext_t *, vec3_t *))this->ScrShouldTeleport_Safe)(this, scrContext, &vectorValue) )
      goto LABEL_43;
  }
  G_MotionWarp_Cancel(_RSI->s.number);
  if ( v9 )
  {
    G_SetOriginAndAngle(_RSI, &vectorValue, v9, 1, 1);
    v26 = this->__vftable;
    v27 = this->Is3D(this);
    v26->SetDesiredBodyAngles(this, &this->m_pAI->CodeOrient, &_RSI->r.currentAngles, v27);
    if ( (unsigned int)(this->m_pAI->ScriptOrient.eMode - 1) <= 1 )
    {
      v28 = this->__vftable;
      v29 = this->Is3D(this);
      v28->SetDesiredBodyAngles(this, &this->m_pAI->ScriptOrient, &_RSI->r.currentAngles, v29);
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rsi+140h]; fYaw
      vmovss  xmm1, dword ptr [rsi+13Ch]; fPitch
    }
    AIScriptedInterface::SetLookAngles(this, *(const float *)&_XMM1, *(const float *)&_XMM2);
  }
  else
  {
    G_SetOrigin(_RSI, &vectorValue, 1, 1);
  }
  m_pAI = this->m_pAI;
  *(_QWORD *)m_pAI->Physics.vVelocity.v = 0i64;
  m_pAI->Physics.vVelocity.v[2] = 0.0;
  v33 = this->m_pAI;
  *(_QWORD *)v33->Physics.vWishDelta.v = 0i64;
  v33->Physics.vWishDelta.v[2] = 0.0;
  AIScriptedInterface::Physics_HandleMovingPlatformTeleport(this);
  __asm { vmovaps xmm2, xmm7 }
  v35 = ((__int64 (__fastcall *)(AIScriptedInterface *, vec3_t *))this->ScrShouldTeleport_Reset)(this, &vectorValue);
  if ( this->UseEnemyGoal(this) && (v35 || !AICommonInterface::PointAtGoal(this, &vectorValue, &this->m_pAI->codeGoal)) )
    AIScriptedInterface::ClearUseEnemyGoal(this);
  if ( _RSI->tagInfo )
  {
    _RSI->s.lerp.eFlags.m_flags[0] ^= 4u;
  }
  else if ( v35 )
  {
    Sentient_InvalidateNearestNode(this->m_pAI->sentient);
    this->ClearPath(this);
    Sentient_InvalidateNearestTacPoint(this->m_pAI->sentient);
    __asm { vcomiss xmm7, cs:__real@46800000 }
    if ( !(v36 | v37) )
      _RSI->s.lerp.eFlags.m_flags[0] ^= 4u;
    if ( checkMode == TELEPORT_CHECK_NONE )
    {
      if ( !this->InScriptedState(this) )
        AIScriptedInterface::KillAnimScript(this);
      if ( v12 && this->IsAlive(this) )
      {
        number = _RSI->s.number;
        v39 = Ai_Asm::Singleton();
        Instance = Ai_Asm::GetInstance(v39, NULL, number);
        if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 713, ASSERT_TYPE_ASSERT, "( pInst )", (const char *)&queryFormat, "pInst") )
          __debugbreak();
        m_Name = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_pASM->m_StartState)->m_Name;
        v42 = Ai_Asm::Singleton();
        if ( Common_Asm::SetState(v42, NULL, Instance, m_Name, 0, NULL) )
          Scr_Error(COM_ERR_5754, scrContext, "Failed to reset ASM state in ForceTeleport()");
        if ( this->m_pAI->eState[this->m_pAI->stateLevel] != AIS_BEHAVE )
          AIScriptedInterface::ForceState(this, AIS_BEHAVE);
      }
    }
  }
  Nav_Teleport(this->m_pAI->pNavigator, &vectorValue);
  Scr_AddInt(scrContext, 1);
LABEL_43:
  Sys_ProfEndNamedEvent();
  __asm
  {
    vmovaps xmm6, [rsp+0B8h+var_48]
    vmovaps xmm7, [rsp+0B8h+var_58]
  }
}

/*
==============
AIActorInterface::SetAnimInternal
==============
*/
void AIActorInterface::SetAnimInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  XAnimTree *EntAnimTree; 
  unsigned int NumParam; 
  char v18; 
  unsigned int v20; 
  const char *v21; 
  unsigned int v22; 
  const XAnim_s *SubTreeAnims; 
  const DObj *ServerDObjForEnt; 
  int bRestart; 
  int v26; 
  float outAnimIndex; 
  float outAnimIndexa; 
  float outAnimIndexb; 
  float outBlendCurveID; 
  float outBlendCurveIDa; 
  float outBlendCurveIDb; 
  float v36; 
  float v37; 
  float v38; 
  unsigned int outGraftAnimIndex[4]; 
  void *retaddr; 
  XAnimSubTreeID outSubTreeID; 
  XAnimCurveID curveID; 
  unsigned int anim; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  curveID = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1546, scrContext, "AnimScripted entities are not supported in this game mode");
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovss  xmm7, cs:__real@3e4ccccd
    vmovaps xmm6, xmm8
  }
  EntAnimTree = GScr_GetEntAnimTree(ent);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    __asm
    {
      vmovaps [rsp+0D8h+var_68], xmm9
      vxorps  xmm9, xmm9, xmm9
    }
    if ( NumParam != 2 )
    {
      if ( NumParam != 3 )
      {
        if ( NumParam - 4 > 3 )
          Scr_Error(COM_ERR_1547, scrContext, "too many parameters");
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
        __asm { vmovaps xmm8, xmm0 }
      }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v18 )
        Scr_ParamError(COM_ERR_1548, scrContext, 2u, "must set nonnegative goal time");
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm9
      vmovaps xmm9, [rsp+0D8h+var_68]
      vmovaps xmm6, xmm0
    }
    if ( v18 )
      Scr_ParamError(COM_ERR_1549, scrContext, 1u, "must set nonnegative weight");
  }
  anim = Scr_GetAnim(scrContext, 0, EntAnimTree).index;
  v20 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 4u, outGraftAnimIndex, &outSubTreeID, &anim, &curveID);
  if ( ShouldDumpAnimCommand(scrContext, ent->s.number, v20 + 4) )
  {
    switch ( flags )
    {
      case 1u:
        v21 = "SetAnim";
        break;
      case 2u:
        v21 = "SetAnimLimitedRestart";
        break;
      case 3u:
        v21 = "SetAnimRestart";
        break;
      default:
        if ( flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 255, ASSERT_TYPE_ASSERT, "(flags == 0)", (const char *)&queryFormat, "flags == 0") )
          __debugbreak();
        v21 = "SetAnimLimited";
        break;
    }
    v22 = anim;
    SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, outSubTreeID);
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    DumpAnimCommandInternal(v21, SubTreeAnims, v22, -1, outAnimIndex, outBlendCurveID, v36);
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(ent);
  if ( !ServerDObjForEnt )
    Scr_ObjectError(COM_ERR_1550, scrContext, "No model exists.");
  bRestart = (flags >> 1) & 1;
  if ( (flags & 1) != 0 )
  {
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    v26 = XAnimSetCompleteGoalWeight(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, outAnimIndexa, outBlendCurveIDa, v37, (scr_string_t)0, 0, bRestart, curveID, NULL);
  }
  else
  {
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    v26 = XAnimSetGoalWeight(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, outAnimIndexb, outBlendCurveIDb, v38, (scr_string_t)0, 0, bRestart, curveID, NULL);
  }
  __asm
  {
    vmovaps xmm8, [rsp+0D8h+var_58]
    vmovaps xmm7, [rsp+0D8h+var_48]
    vmovaps xmm6, [rsp+0D8h+var_38]
  }
  if ( v26 )
    GScr_HandleAnimError(scrContext, v26);
  else
    G_FlagAnimForUpdate(ent);
}

/*
==============
AIActorInterface::SetAnimKnobInternal
==============
*/
void AIActorInterface::SetAnimKnobInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  XAnimTree *EntAnimTree; 
  unsigned int NumParam; 
  char v18; 
  unsigned int v20; 
  const char *v21; 
  unsigned int v22; 
  const XAnim_s *SubTreeAnims; 
  const DObj *ServerDObjForEnt; 
  int bRestart; 
  int v26; 
  float outAnimIndex; 
  float outAnimIndexa; 
  float outAnimIndexb; 
  float outBlendCurveID; 
  float outBlendCurveIDa; 
  float outBlendCurveIDb; 
  float v36; 
  float v37; 
  float v38; 
  unsigned int outGraftAnimIndex[4]; 
  void *retaddr; 
  XAnimSubTreeID outSubTreeID; 
  XAnimCurveID curveID; 
  unsigned int anim; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  curveID = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1541, scrContext, "AnimScripted entities are not supported in this game mode");
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovss  xmm7, cs:__real@3e4ccccd
    vmovaps xmm6, xmm8
  }
  EntAnimTree = GScr_GetEntAnimTree(ent);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    __asm
    {
      vmovaps [rsp+0D8h+var_68], xmm9
      vxorps  xmm9, xmm9, xmm9
    }
    if ( NumParam != 2 )
    {
      if ( NumParam != 3 )
      {
        if ( NumParam - 4 > 3 )
          Scr_Error(COM_ERR_1542, scrContext, "too many parameters");
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
        __asm { vmovaps xmm8, xmm0 }
      }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v18 )
        Scr_ParamError(COM_ERR_1543, scrContext, 2u, "must set nonnegative goal time");
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm9
      vmovaps xmm9, [rsp+0D8h+var_68]
      vmovaps xmm6, xmm0
    }
    if ( v18 )
      Scr_ParamError(COM_ERR_1544, scrContext, 1u, "must set nonnegative weight");
  }
  anim = Scr_GetAnim(scrContext, 0, EntAnimTree).index;
  v20 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 4u, outGraftAnimIndex, &outSubTreeID, &anim, &curveID);
  if ( ShouldDumpAnimCommand(scrContext, ent->s.number, v20 + 4) )
  {
    switch ( flags )
    {
      case 1u:
        v21 = "SetAnimKnob";
        break;
      case 2u:
        v21 = "SetAnimKnobLimitedRestart";
        break;
      case 3u:
        v21 = "SetAnimKnobRestart";
        break;
      default:
        if ( flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 141, ASSERT_TYPE_ASSERT, "(flags == 0)", (const char *)&queryFormat, "flags == 0") )
          __debugbreak();
        v21 = "SetAnimKnobLimited";
        break;
    }
    v22 = anim;
    SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, outSubTreeID);
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    DumpAnimCommandInternal(v21, SubTreeAnims, v22, -1, outAnimIndex, outBlendCurveID, v36);
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(ent);
  if ( !ServerDObjForEnt )
    Scr_ObjectError(COM_ERR_1545, scrContext, "No model exists.");
  bRestart = (flags >> 1) & 1;
  if ( (flags & 1) != 0 )
  {
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    v26 = XAnimSetCompleteGoalWeightKnob(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, outAnimIndexa, outBlendCurveIDa, v37, (scr_string_t)0, 0, bRestart, curveID);
  }
  else
  {
    __asm
    {
      vmovss  [rsp+0D8h+var_A8], xmm8
      vmovss  dword ptr [rsp+0D8h+outBlendCurveID], xmm7
      vmovss  dword ptr [rsp+0D8h+outAnimIndex], xmm6
    }
    v26 = XAnimSetGoalWeightKnob(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, outAnimIndexb, outBlendCurveIDb, v38, (scr_string_t)0, bRestart, curveID);
  }
  __asm
  {
    vmovaps xmm8, [rsp+0D8h+var_58]
    vmovaps xmm7, [rsp+0D8h+var_48]
    vmovaps xmm6, [rsp+0D8h+var_38]
  }
  if ( v26 )
    GScr_HandleAnimError(scrContext, v26);
  else
    G_FlagAnimForUpdate(ent);
}

