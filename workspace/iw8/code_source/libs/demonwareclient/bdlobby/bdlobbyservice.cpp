/*
==============
bdLobbyService::getCrossTitleLocalizedStrings
==============
*/

bdCrossTitleLocalizedStrings *__fastcall bdLobbyService::getCrossTitleLocalizedStrings(bdLobbyService *this)
{
  return ?getCrossTitleLocalizedStrings@bdLobbyService@@QEAAPEAVbdCrossTitleLocalizedStrings@@XZ(this);
}

/*
==============
bdLobbyService::isConnected
==============
*/

bool __fastcall bdLobbyService::isConnected(bdLobbyService *this)
{
  return ?isConnected@bdLobbyService@@QEAA_NXZ(this);
}

/*
==============
bdLobbyService::handleChannelUserPromotedV2
==============
*/

bool __fastcall bdLobbyService::handleChannelUserPromotedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelUserPromotedV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleChannelUserPromoted
==============
*/

bool __fastcall bdLobbyService::handleChannelUserPromoted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelUserPromoted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getCrossPlatformPresence
==============
*/

bdCrossPlatformPresence *__fastcall bdLobbyService::getCrossPlatformPresence(bdLobbyService *this)
{
  return ?getCrossPlatformPresence@bdLobbyService@@QEAAPEAVbdCrossPlatformPresence@@XZ(this);
}

/*
==============
bdLobbyService::getReportLogoffService
==============
*/

bdUserLogoffRecordsService *__fastcall bdLobbyService::getReportLogoffService(bdLobbyService *this)
{
  return ?getReportLogoffService@bdLobbyService@@QEAAPEAVbdUserLogoffRecordsService@@XZ(this);
}

/*
==============
bdLobbyService::pump
==============
*/

void __fastcall bdLobbyService::pump(bdLobbyService *this)
{
  ?pump@bdLobbyService@@QEAAXXZ(this);
}

/*
==============
bdLobbyService::deletePooledStorage
==============
*/

void __fastcall bdLobbyService::deletePooledStorage(bdLobbyService *this)
{
  ?deletePooledStorage@bdLobbyService@@QEAAXXZ(this);
}

/*
==============
bdLobbyService::getCrossPlatformUserLists
==============
*/

bdCrossPlatformUserLists *__fastcall bdLobbyService::getCrossPlatformUserLists(bdLobbyService *this)
{
  return ?getCrossPlatformUserLists@bdLobbyService@@QEAAPEAVbdCrossPlatformUserLists@@XZ(this);
}

/*
==============
bdLobbyService::handleTencentUserLeaveReason
==============
*/

bool __fastcall bdLobbyService::handleTencentUserLeaveReason(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentUserLeaveReason@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::unregisterPushMessageHandler
==============
*/

bool __fastcall bdLobbyService::unregisterPushMessageHandler(bdLobbyService *this, bdString sender)
{
  return ?unregisterPushMessageHandler@bdLobbyService@@QEAA_NVbdString@@@Z(this, sender);
}

/*
==============
bdLobbyService::handleTencentNameChanged
==============
*/

bool __fastcall bdLobbyService::handleTencentNameChanged(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentNameChanged@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getAuthInfo
==============
*/

bdAuthInfo *__fastcall bdLobbyService::getAuthInfo(bdLobbyService *this)
{
  return ?getAuthInfo@bdLobbyService@@QEAAPEAVbdAuthInfo@@XZ(this);
}

/*
==============
bdLobbyService::getAntiCheat
==============
*/

bdAntiCheat *__fastcall bdLobbyService::getAntiCheat(bdLobbyService *this)
{
  return ?getAntiCheat@bdLobbyService@@QEAAPEAVbdAntiCheat@@XZ(this);
}

/*
==============
bdLobbyService::handleNotWhiteListed
==============
*/

bool __fastcall bdLobbyService::handleNotWhiteListed(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleNotWhiteListed@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTOTPMessage
==============
*/

bool __fastcall bdLobbyService::handleTOTPMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTOTPMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getDML
==============
*/

bdDML *__fastcall bdLobbyService::getDML(bdLobbyService *this)
{
  return ?getDML@bdLobbyService@@QEAAPEAVbdDML@@XZ(this);
}

/*
==============
bdLobbyService::handleGMSGBroadcast
==============
*/

bool __fastcall bdLobbyService::handleGMSGBroadcast(bdLobbyService *this, bdEventType eventType, bdReference<bdByteBuffer> message)
{
  return ?handleGMSGBroadcast@bdLobbyService@@IEAA_NW4bdEventType@@V?$bdReference@VbdByteBuffer@@@@@Z(this, eventType, message);
}

/*
==============
bdLobbyService::handleMarketplaceItemsUpdated
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceItemsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceItemsUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleChannelUserKickedV2
==============
*/

bool __fastcall bdLobbyService::handleChannelUserKickedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelUserKickedV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getEventLog
==============
*/

bdEventLog *__fastcall bdLobbyService::getEventLog(bdLobbyService *this)
{
  return ?getEventLog@bdLobbyService@@QEAAPEAVbdEventLog@@XZ(this);
}

/*
==============
bdLobbyService::handleCODOTeamMarketplaceLevelChange
==============
*/

bool __fastcall bdLobbyService::handleCODOTeamMarketplaceLevelChange(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleCODOTeamMarketplaceLevelChange@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleChannelUserSubscription
==============
*/

bool __fastcall bdLobbyService::handleChannelUserSubscription(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  return ?handleChannelUserSubscription@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@W4bdEventType@@@Z(this, message, eventType);
}

/*
==============
bdLobbyService::handleTencentAntiBotPunish
==============
*/

bool __fastcall bdLobbyService::handleTencentAntiBotPunish(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentAntiBotPunish@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTencentAntiBotData
==============
*/

bool __fastcall bdLobbyService::handleTencentAntiBotData(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentAntiBotData@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/

void __fastcall bdLobbyService::bdLobbyService(bdLobbyService *this)
{
  ??0bdLobbyService@@QEAA@XZ(this);
}

/*
==============
bdLobbyService::connect
==============
*/

bool __fastcall bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, unsigned __int64 maxSendBufSize, unsigned __int64 maxRecvBufSize, const bool useEncryption)
{
  return ?connect@bdLobbyService@@QEAA_NVbdAddr@@PEBVbdAuthInfo@@_K2_N@Z(this, lobbyServiceAddr, authInfo, maxSendBufSize, maxRecvBufSize, useEncryption);
}

/*
==============
bdLobbyService::getCrossPlatformFriends
==============
*/

bdCrossPlatformFriends *__fastcall bdLobbyService::getCrossPlatformFriends(bdLobbyService *this)
{
  return ?getCrossPlatformFriends@bdLobbyService@@QEAAPEAVbdCrossPlatformFriends@@XZ(this);
}

/*
==============
bdLobbyService::setUploadThrottleRate
==============
*/

void __fastcall bdLobbyService::setUploadThrottleRate(bdLobbyService *this, unsigned int bytesPerSecond, unsigned int bucketSizeBytes)
{
  ?setUploadThrottleRate@bdLobbyService@@QEAAXII@Z(this, bytesPerSecond, bucketSizeBytes);
}

/*
==============
bdLobbyService::getRichPresence
==============
*/

bdRichPresenceService *__fastcall bdLobbyService::getRichPresence(bdLobbyService *this, const char *context)
{
  return ?getRichPresence@bdLobbyService@@QEAAPEAVbdRichPresenceService@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleTeamMemberUserNameUpdated
==============
*/

bool __fastcall bdLobbyService::handleTeamMemberUserNameUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTeamMemberUserNameUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::connect
==============
*/

bool __fastcall bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, const bool useEncryption)
{
  return ?connect@bdLobbyService@@QEAA_NVbdAddr@@PEBVbdAuthInfo@@_N@Z(this, lobbyServiceAddr, authInfo, useEncryption);
}

/*
==============
bdLobbyService::getCounter
==============
*/

bdCounter *__fastcall bdLobbyService::getCounter(bdLobbyService *this)
{
  return ?getCounter@bdLobbyService@@QEAAPEAVbdCounter@@XZ(this);
}

/*
==============
bdLobbyService::getMW4Service
==============
*/

bdMW4Service *__fastcall bdLobbyService::getMW4Service(bdLobbyService *this)
{
  return ?getMW4Service@bdLobbyService@@QEAAPEAVbdMW4Service@@XZ(this);
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV4
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceCouponsUpdatedV4(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceCouponsUpdatedV4@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getCODO
==============
*/

bdCODO *__fastcall bdLobbyService::getCODO(bdLobbyService *this)
{
  return ?getCODO@bdLobbyService@@QEAAPEAVbdCODO@@XZ(this);
}

/*
==============
bdLobbyService::setTasksAreThrottled
==============
*/

void __fastcall bdLobbyService::setTasksAreThrottled(bdLobbyService *this, bool areThrottled)
{
  ?setTasksAreThrottled@bdLobbyService@@QEAAX_N@Z(this, areThrottled);
}

/*
==============
bdLobbyService::getTitleUtilities
==============
*/

bdTitleUtilities *__fastcall bdLobbyService::getTitleUtilities(bdLobbyService *this)
{
  return ?getTitleUtilities@bdLobbyService@@QEAAPEAVbdTitleUtilities@@XZ(this);
}

/*
==============
bdLobbyService::setUploadThrottle
==============
*/

void __fastcall bdLobbyService::setUploadThrottle(bdLobbyService *this, bool isEnabled)
{
  ?setUploadThrottle@bdLobbyService@@QEAAX_N@Z(this, isEnabled);
}

/*
==============
bdLobbyService::getUmbrella
==============
*/

bdUmbrella *__fastcall bdLobbyService::getUmbrella(bdLobbyService *this)
{
  return ?getUmbrella@bdLobbyService@@QEAAPEAVbdUmbrella@@XZ(this);
}

/*
==============
bdLobbyService::handleChannelUserMuted
==============
*/

bool __fastcall bdLobbyService::handleChannelUserMuted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelUserMuted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getFeatureBan
==============
*/

bdFeatureBan *__fastcall bdLobbyService::getFeatureBan(bdLobbyService *this)
{
  return ?getFeatureBan@bdLobbyService@@QEAAPEAVbdFeatureBan@@XZ(this);
}

/*
==============
bdLobbyService::handleFriendDisconnected
==============
*/

bool __fastcall bdLobbyService::handleFriendDisconnected(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  return ?handleFriendDisconnected@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@W4bdEventType@@@Z(this, message, eventType);
}

/*
==============
bdLobbyService::pumpLSGLookup
==============
*/

bool __fastcall bdLobbyService::pumpLSGLookup(bdLobbyService *this, bdGetHostByName::bdStatus *status)
{
  return ?pumpLSGLookup@bdLobbyService@@QEAA_NPEAW4bdStatus@bdGetHostByName@@@Z(this, status);
}

/*
==============
bdLobbyService::disconnect
==============
*/

void __fastcall bdLobbyService::disconnect(bdLobbyService *this)
{
  ?disconnect@bdLobbyService@@QEAAXXZ(this);
}

/*
==============
bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceItemsGrantedWithInventoryQuantity@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getMarketplace
==============
*/

bdMarketplace *__fastcall bdLobbyService::getMarketplace(bdLobbyService *this, const char *context)
{
  return ?getMarketplace@bdLobbyService@@QEAAPEAVbdMarketplace@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::getPooledStorage
==============
*/

bdPooledStorage *__fastcall bdLobbyService::getPooledStorage(bdLobbyService *this)
{
  return ?getPooledStorage@bdLobbyService@@QEAAPEAVbdPooledStorage@@XZ(this);
}

/*
==============
bdLobbyService::getAchievementsEngineClientService
==============
*/

bdAchievementClient *__fastcall bdLobbyService::getAchievementsEngineClientService(bdLobbyService *this, const char *context)
{
  return ?getAchievementsEngineClientService@bdLobbyService@@QEAAPEAVbdAchievementClient@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleTencentAASRecord
==============
*/

bool __fastcall bdLobbyService::handleTencentAASRecord(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentAASRecord@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getMarketingComms
==============
*/

bdMarketingComms *__fastcall bdLobbyService::getMarketingComms(bdLobbyService *this, const char *context)
{
  return ?getMarketingComms@bdLobbyService@@QEAAPEAVbdMarketingComms@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleRewardAchievementMessage
==============
*/

bool __fastcall bdLobbyService::handleRewardAchievementMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleRewardAchievementMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::registerEventHandler
==============
*/

void __fastcall bdLobbyService::registerEventHandler(bdLobbyService *this, bdLobbyEventHandler *eventHandler)
{
  ?registerEventHandler@bdLobbyService@@QEAAXPEAVbdLobbyEventHandler@@@Z(this, eventHandler);
}

/*
==============
bdLobbyService::getProfiles
==============
*/

bdProfiles *__fastcall bdLobbyService::getProfiles(bdLobbyService *this)
{
  return ?getProfiles@bdLobbyService@@QEAAPEAVbdProfiles@@XZ(this);
}

/*
==============
bdLobbyService::getCrossPlatformIdentity
==============
*/

bdCrossPlatformIdentity *__fastcall bdLobbyService::getCrossPlatformIdentity(bdLobbyService *this)
{
  return ?getCrossPlatformIdentity@bdLobbyService@@QEAAPEAVbdCrossPlatformIdentity@@XZ(this);
}

/*
==============
bdLobbyService::handleTitleVersionDisabled
==============
*/

bool __fastcall bdLobbyService::handleTitleVersionDisabled(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTitleVersionDisabled@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleChannelChatMsgV2
==============
*/

bool __fastcall bdLobbyService::handleChannelChatMsgV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelChatMsgV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getServerInventory
==============
*/

bdServerInventory *__fastcall bdLobbyService::getServerInventory(bdLobbyService *this)
{
  return ?getServerInventory@bdLobbyService@@QEAAPEAVbdServerInventory@@XZ(this);
}

/*
==============
bdLobbyService::getTeams
==============
*/

bdTeams *__fastcall bdLobbyService::getTeams(bdLobbyService *this, const char *context)
{
  return ?getTeams@bdLobbyService@@QEAAPEAVbdTeams@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdated
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceCouponsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceCouponsUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTencentAntibotServerReady
==============
*/

bool __fastcall bdLobbyService::handleTencentAntibotServerReady(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentAntibotServerReady@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceDepositGranted
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceDepositGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceDepositGranted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getABTesting
==============
*/

bdABTesting *__fastcall bdLobbyService::getABTesting(bdLobbyService *this)
{
  return ?getABTesting@bdLobbyService@@QEAAPEAVbdABTesting@@XZ(this);
}

/*
==============
bdLobbyService::handleAchievementsUpdated
==============
*/

bool __fastcall bdLobbyService::handleAchievementsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleAchievementsUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleWebserviceStorageFileWrite
==============
*/

bool __fastcall bdLobbyService::handleWebserviceStorageFileWrite(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleWebserviceStorageFileWrite@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getObjectStore
==============
*/

bdObjectStore *__fastcall bdLobbyService::getObjectStore(bdLobbyService *this, const char *certificateAuthorityPath)
{
  return ?getObjectStore@bdLobbyService@@QEAAPEAVbdObjectStore@@PEBD@Z(this, certificateAuthorityPath);
}

/*
==============
bdLobbyService::handleChannelUserKicked
==============
*/

bool __fastcall bdLobbyService::handleChannelUserKicked(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelUserKicked@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::pumpDNSLookup
==============
*/

bool __fastcall bdLobbyService::pumpDNSLookup(bdLobbyService *this, bdGetHostByName::bdStatus *status)
{
  return ?pumpDNSLookup@bdLobbyService@@QEAA_NAEAW4bdStatus@bdGetHostByName@@@Z(this, status);
}

/*
==============
bdLobbyService::handleLinkedAccountStatusChange
==============
*/

bool __fastcall bdLobbyService::handleLinkedAccountStatusChange(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleLinkedAccountStatusChange@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleFeatureBan
==============
*/

bool __fastcall bdLobbyService::handleFeatureBan(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleFeatureBan@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getMLG
==============
*/

bdMLG *__fastcall bdLobbyService::getMLG(bdLobbyService *this)
{
  return ?getMLG@bdLobbyService@@QEAAPEAVbdMLG@@XZ(this);
}

/*
==============
bdLobbyService::getTeamShowcase
==============
*/

bdTeamShowcase *__fastcall bdLobbyService::getTeamShowcase(bdLobbyService *this, const char *context)
{
  return ?getTeamShowcase@bdLobbyService@@QEAAPEAVbdTeamShowcase@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handlePlayerDisconnected
==============
*/

bool __fastcall bdLobbyService::handlePlayerDisconnected(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handlePlayerDisconnected@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getMatchScheduler
==============
*/

bdMatchScheduler *__fastcall bdLobbyService::getMatchScheduler(bdLobbyService *this)
{
  return ?getMatchScheduler@bdLobbyService@@QEAAPEAVbdMatchScheduler@@XZ(this);
}

/*
==============
bdLobbyService::handleFriendRichPresenceUpdated
==============
*/

bool __fastcall bdLobbyService::handleFriendRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleFriendRichPresenceUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getMatchMaking
==============
*/

bdMatchMaking *__fastcall bdLobbyService::getMatchMaking(bdLobbyService *this, const char *context)
{
  return ?getMatchMaking@bdLobbyService@@QEAAPEAVbdMatchMaking@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleChannelChatMsg
==============
*/

bool __fastcall bdLobbyService::handleChannelChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChannelChatMsg@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleSessionInvitation
==============
*/

bool __fastcall bdLobbyService::handleSessionInvitation(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleSessionInvitation@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getKeyArchive
==============
*/

bdKeyArchive *__fastcall bdLobbyService::getKeyArchive(bdLobbyService *this)
{
  return ?getKeyArchive@bdLobbyService@@QEAAPEAVbdKeyArchive@@XZ(this);
}

/*
==============
bdLobbyService::handleGlobalInstantMessage
==============
*/

bool __fastcall bdLobbyService::handleGlobalInstantMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleGlobalInstantMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTeamChatMsg
==============
*/

bool __fastcall bdLobbyService::handleTeamChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTeamChatMsg@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getVoteRank
==============
*/

bdVoteRank *__fastcall bdLobbyService::getVoteRank(bdLobbyService *this)
{
  return ?getVoteRank@bdLobbyService@@QEAAPEAVbdVoteRank@@XZ(this);
}

/*
==============
bdLobbyService::getStorage
==============
*/

bdStorage *__fastcall bdLobbyService::getStorage(bdLobbyService *this, const char *context)
{
  return ?getStorage@bdLobbyService@@QEAAPEAVbdStorage@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::getMail
==============
*/

bdMail *__fastcall bdLobbyService::getMail(bdLobbyService *this, const char *context)
{
  return ?getMail@bdLobbyService@@QEAAPEAVbdMail@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handlePrivateProfileUpdate
==============
*/

bool __fastcall bdLobbyService::handlePrivateProfileUpdate(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handlePrivateProfileUpdate@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceCouponsGranted
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceCouponsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceCouponsGranted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMultipleLogons
==============
*/

bool __fastcall bdLobbyService::handleMultipleLogons(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMultipleLogons@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::registerPushMessageHandler
==============
*/

bool __fastcall bdLobbyService::registerPushMessageHandler(bdLobbyService *this, bdPushMessageHandler *handler)
{
  return ?registerPushMessageHandler@bdLobbyService@@QEAA_NPEAVbdPushMessageHandler@@@Z(this, handler);
}

/*
==============
bdLobbyErrorCodeToString
==============
*/

const char *__fastcall bdLobbyErrorCodeToString(const bdLobbyErrorCode code)
{
  return ?bdLobbyErrorCodeToString@@YAPEBDW4bdLobbyErrorCode@@@Z(code);
}

/*
==============
bdLobbyService::handleConsoleBanned
==============
*/

bool __fastcall bdLobbyService::handleConsoleBanned(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleConsoleBanned@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleRewardEventMessage
==============
*/

bool __fastcall bdLobbyService::handleRewardEventMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleRewardEventMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getDDL
==============
*/

bdDDL *__fastcall bdLobbyService::getDDL(bdLobbyService *this)
{
  return ?getDDL@bdLobbyService@@QEAAPEAVbdDDL@@XZ(this);
}

/*
==============
bdLobbyService::handleLogonTimeProhibited
==============
*/

bool __fastcall bdLobbyService::handleLogonTimeProhibited(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleLogonTimeProhibited@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::connect
==============
*/

bool __fastcall bdLobbyService::connect(bdLobbyService *this, const bdAuthInfo *authInfo, const bool useEncryption)
{
  return ?connect@bdLobbyService@@QEAA_NPEBVbdAuthInfo@@_N@Z(this, authInfo, useEncryption);
}

/*
==============
bdLobbyService::unregisterPushMessageHandler
==============
*/

bool __fastcall bdLobbyService::unregisterPushMessageHandler(bdLobbyService *this, bdPushMessageHandler *handler)
{
  return ?unregisterPushMessageHandler@bdLobbyService@@QEAA_NPEAVbdPushMessageHandler@@@Z(this, handler);
}

/*
==============
bdLobbyService::getRestTaskManager
==============
*/

bdRESTTaskManager *__fastcall bdLobbyService::getRestTaskManager(bdLobbyService *this)
{
  return ?getRestTaskManager@bdLobbyService@@QEAAPEAVbdRESTTaskManager@@XZ(this);
}

/*
==============
bdLobbyService::connect
==============
*/

bool __fastcall bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, void *__formal, unsigned __int64 sendBufSize, void *a6, unsigned __int64 recvBufSize, const bool useEncryption)
{
  return ?connect@bdLobbyService@@QEAA_NVbdAddr@@PEBVbdAuthInfo@@PEAX_K23_N@Z(this, lobbyServiceAddr, authInfo, __formal, sendBufSize, a6, recvBufSize, useEncryption);
}

/*
==============
bdLobbyService::handleSubscribedRichPresenceUpdated
==============
*/

bool __fastcall bdLobbyService::handleSubscribedRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleSubscribedRichPresenceUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getCODOTeamMarketplace
==============
*/

bdCODOTeamMarketplace *__fastcall bdLobbyService::getCODOTeamMarketplace(bdLobbyService *this)
{
  return ?getCODOTeamMarketplace@bdLobbyService@@QEAAPEAVbdCODOTeamMarketplace@@XZ(this);
}

/*
==============
bdLobbyService::getAchievementsEngineService
==============
*/

bdAchievementsEngineService *__fastcall bdLobbyService::getAchievementsEngineService(bdLobbyService *this)
{
  return ?getAchievementsEngineService@bdLobbyService@@QEAAPEAVbdAchievementsEngineService@@XZ(this);
}

/*
==============
bdLobbyService::getContentStreaming
==============
*/

bdContentStreaming *__fastcall bdLobbyService::getContentStreaming(bdLobbyService *this)
{
  return ?getContentStreaming@bdLobbyService@@QEAAPEAVbdContentStreaming@@XZ(this);
}

/*
==============
bdLobbyService::handlePushMessage
==============
*/

void __fastcall bdLobbyService::handlePushMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  ?handlePushMessage@bdLobbyService@@IEAAXV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::updateConnectionThrottleParams
==============
*/

void __fastcall bdLobbyService::updateConnectionThrottleParams(bdLobbyService *this)
{
  ?updateConnectionThrottleParams@bdLobbyService@@IEAAXXZ(this);
}

/*
==============
bdLobbyService::handleEventLogFilteredCategories
==============
*/

bool __fastcall bdLobbyService::handleEventLogFilteredCategories(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleEventLogFilteredCategories@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTeamMemberRichPresenceUpdated
==============
*/

bool __fastcall bdLobbyService::handleTeamMemberRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTeamMemberRichPresenceUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::onConnect
==============
*/

void __fastcall bdLobbyService::onConnect(bdLobbyService *this, bdReference<bdLobbyConnection> connection)
{
  ?onConnect@bdLobbyService@@MEAAXV?$bdReference@VbdLobbyConnection@@@@@Z(this, connection);
}

/*
==============
bdLobbyService::handleNewMail
==============
*/

bool __fastcall bdLobbyService::handleNewMail(bdLobbyService *this)
{
  return ?handleNewMail@bdLobbyService@@IEAA_NXZ(this);
}

/*
==============
bdLobbyService::getStatus
==============
*/

bdLobbyConnection::Status __fastcall bdLobbyService::getStatus(bdLobbyService *this)
{
  return ?getStatus@bdLobbyService@@QEBA?AW4Status@bdLobbyConnection@@XZ(this);
}

/*
==============
bdLobbyService::cleanup
==============
*/

void __fastcall bdLobbyService::cleanup(bdLobbyService *this)
{
  ?cleanup@bdLobbyService@@IEAAXXZ(this);
}

/*
==============
bdLobbyService::getRelayService
==============
*/

bdRelayService *__fastcall bdLobbyService::getRelayService(bdLobbyService *this)
{
  return ?getRelayService@bdLobbyService@@QEAAPEAVbdRelayService@@XZ(this);
}

/*
==============
bdLobbyService::handleMarketplaceEntitlementsGranted
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceEntitlementsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceEntitlementsGranted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV2
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceCouponsUpdatedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceCouponsUpdatedV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handlePlayerBanned
==============
*/

bool __fastcall bdLobbyService::handlePlayerBanned(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handlePlayerBanned@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/

void __fastcall bdLobbyService::bdLobbyService(bdLobbyService *this, const char *lsgAddress, const unsigned __int16 lsgPort)
{
  ??0bdLobbyService@@QEAA@PEBDG@Z(this, lsgAddress, lsgPort);
}

/*
==============
bdLobbyService::getStats
==============
*/

bdStats *__fastcall bdLobbyService::getStats(bdLobbyService *this)
{
  return ?getStats@bdLobbyService@@QEAAPEAVbdStats@@XZ(this);
}

/*
==============
bdLobbyService::handleTencentNoRewardReceived
==============
*/

bool __fastcall bdLobbyService::handleTencentNoRewardReceived(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentNoRewardReceived@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleTencentReward
==============
*/

bool __fastcall bdLobbyService::handleTencentReward(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentReward@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleChallengesReceived
==============
*/

bool __fastcall bdLobbyService::handleChallengesReceived(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleChallengesReceived@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handlePublisherVariablesUpdateMessage
==============
*/

bool __fastcall bdLobbyService::handlePublisherVariablesUpdateMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handlePublisherVariablesUpdateMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleStabilised
==============
*/

bool __fastcall bdLobbyService::handleStabilised(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleStabilised@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getHandleInfo
==============
*/

void __fastcall bdLobbyService::getHandleInfo(bdLobbyService *this, int *handle, bool *read, bool *write, float *timeout)
{
  ?getHandleInfo@bdLobbyService@@QEAAXAEAHAEA_N1AEAM@Z(this, handle, read, write, timeout);
}

/*
==============
bdLobbyService::getABTestingToken
==============
*/

char *__fastcall bdLobbyService::getABTestingToken(bdLobbyService *this)
{
  return ?getABTestingToken@bdLobbyService@@QEAAPEADXZ(this);
}

/*
==============
bdLobbyService::getGroup
==============
*/

bdGroup *__fastcall bdLobbyService::getGroup(bdLobbyService *this)
{
  return ?getGroup@bdLobbyService@@QEAAPEAVbdGroup@@XZ(this);
}

/*
==============
bdLobbyService::getTags
==============
*/

bdTags *__fastcall bdLobbyService::getTags(bdLobbyService *this)
{
  return ?getTags@bdLobbyService@@QEAAPEAVbdTags@@XZ(this);
}

/*
==============
bdLobbyService::handleTeamMemberConnection
==============
*/

bool __fastcall bdLobbyService::handleTeamMemberConnection(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  return ?handleTeamMemberConnection@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@W4bdEventType@@@Z(this, message, eventType);
}

/*
==============
bdLobbyService::handleMarketplaceBalanceUpdated
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceBalanceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceBalanceUpdated@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV3
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceCouponsUpdatedV3(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceCouponsUpdatedV3@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleLogonTimeProhibitedWarning
==============
*/

bool __fastcall bdLobbyService::handleLogonTimeProhibitedWarning(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleLogonTimeProhibitedWarning@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getErrorCode
==============
*/

bdLobbyErrorCode __fastcall bdLobbyService::getErrorCode(bdLobbyService *this)
{
  return ?getErrorCode@bdLobbyService@@QEAA?AW4bdLobbyErrorCode@@XZ(this);
}

/*
==============
bdLobbyService::handleClaimAchievement
==============
*/

bool __fastcall bdLobbyService::handleClaimAchievement(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleClaimAchievement@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::setABTestingTokenAndExpiry
==============
*/

bool __fastcall bdLobbyService::setABTestingTokenAndExpiry(bdLobbyService *this, const char *const abTestingToken, const unsigned __int64 abTestingTokenExpiresInSeconds)
{
  return ?setABTestingTokenAndExpiry@bdLobbyService@@QEAA_NQEBD_K@Z(this, abTestingToken, abTestingTokenExpiresInSeconds);
}

/*
==============
bdLobbyService::getRegulations
==============
*/

bdRegulations *__fastcall bdLobbyService::getRegulations(bdLobbyService *this)
{
  return ?getRegulations@bdLobbyService@@QEAAPEAVbdRegulations@@XZ(this);
}

/*
==============
bdLobbyService::handleMultipleLinkedAccountLogons
==============
*/

bool __fastcall bdLobbyService::handleMultipleLinkedAccountLogons(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMultipleLinkedAccountLogons@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getRewards
==============
*/

bdReward *__fastcall bdLobbyService::getRewards(bdLobbyService *this, const char *context)
{
  return ?getRewards@bdLobbyService@@QEAAPEAVbdReward@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleTSSResponse
==============
*/

bool __fastcall bdLobbyService::handleTSSResponse(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTSSResponse@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::onDisconnect
==============
*/

void __fastcall bdLobbyService::onDisconnect(bdLobbyService *this, bdReference<bdLobbyConnection> __formal)
{
  ?onDisconnect@bdLobbyService@@MEAAXV?$bdReference@VbdLobbyConnection@@@@@Z(this, __formal);
}

/*
==============
bdLobbyService::getMessaging
==============
*/

bdMessaging *__fastcall bdLobbyService::getMessaging(bdLobbyService *this)
{
  return ?getMessaging@bdLobbyService@@QEAAPEAVbdMessaging@@XZ(this);
}

/*
==============
bdLobbyService::registerPushMessageHandler
==============
*/

bool __fastcall bdLobbyService::registerPushMessageHandler(bdLobbyService *this, bdString sender, bdDemonataPushMessageHandler *handler)
{
  return ?registerPushMessageHandler@bdLobbyService@@QEAA_NVbdString@@PEAVbdDemonataPushMessageHandler@@@Z(this, sender, handler);
}

/*
==============
bdLobbyService::getUno
==============
*/

bdUno *__fastcall bdLobbyService::getUno(bdLobbyService *this)
{
  return ?getUno@bdLobbyService@@QEAAPEAVbdUno@@XZ(this);
}

/*
==============
bdLobbyService::handleTencentLoudSpeakerMessage
==============
*/

bool __fastcall bdLobbyService::handleTencentLoudSpeakerMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleTencentLoudSpeakerMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleDemonataPushMessage
==============
*/

bool __fastcall bdLobbyService::handleDemonataPushMessage(bdLobbyService *this, bdDemonataPushMessage *parsedMessage)
{
  return ?handleDemonataPushMessage@bdLobbyService@@IEAA_NAEAVbdDemonataPushMessage@@@Z(this, parsedMessage);
}

/*
==============
bdLobbyService::handleNotifyLeave
==============
*/

bool __fastcall bdLobbyService::handleNotifyLeave(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleNotifyLeave@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getPublisherVariables
==============
*/

bdPublisherVariables *__fastcall bdLobbyService::getPublisherVariables(bdLobbyService *this, const char *context)
{
  return ?getPublisherVariables@bdLobbyService@@QEAAPEAVbdPublisherVariables@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::getTaskManager
==============
*/

bdRemoteTaskManager *__fastcall bdLobbyService::getTaskManager(bdLobbyService *this)
{
  return ?getTaskManager@bdLobbyService@@QEAAPEAVbdRemoteTaskManager@@XZ(this);
}

/*
==============
bdLobbyService::~bdLobbyService
==============
*/

void __fastcall bdLobbyService::~bdLobbyService(bdLobbyService *this)
{
  ??1bdLobbyService@@UEAA@XZ(this);
}

/*
==============
bdLobbyService::getLootGeneration
==============
*/

bdLootGeneration *__fastcall bdLobbyService::getLootGeneration(bdLobbyService *this)
{
  return ?getLootGeneration@bdLobbyService@@QEAAPEAVbdLootGeneration@@XZ(this);
}

/*
==============
bdLobbyService::handleChannelUserSubscriptionV2
==============
*/

bool __fastcall bdLobbyService::handleChannelUserSubscriptionV2(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  return ?handleChannelUserSubscriptionV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@W4bdEventType@@@Z(this, message, eventType);
}

/*
==============
bdLobbyService::handleFriendChatMsg
==============
*/

bool __fastcall bdLobbyService::handleFriendChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleFriendChatMsg@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketingCommsAssignmentsAvailable
==============
*/

bool __fastcall bdLobbyService::handleMarketingCommsAssignmentsAvailable(bdLobbyService *this)
{
  return ?handleMarketingCommsAssignmentsAvailable@bdLobbyService@@IEAA_NXZ(this);
}

/*
==============
bdLobbyService::deleteContentStreaming
==============
*/

void __fastcall bdLobbyService::deleteContentStreaming(bdLobbyService *this)
{
  ?deleteContentStreaming@bdLobbyService@@QEAAXXZ(this);
}

/*
==============
bdLobbyService::handleNotWhiteListedWithMessage
==============
*/

bool __fastcall bdLobbyService::handleNotWhiteListedWithMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleNotWhiteListedWithMessage@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/

void __fastcall bdLobbyService::bdLobbyService(bdLobbyService *this, const bdLobbyServicesConnectionInfo *connectionInfo)
{
  ??0bdLobbyService@@QEAA@AEBVbdLobbyServicesConnectionInfo@@@Z(this, connectionInfo);
}

/*
==============
bdLobbyService::getRedeemableCodeService
==============
*/

bdRedeemableCodeService *__fastcall bdLobbyService::getRedeemableCodeService(bdLobbyService *this, const char *context)
{
  return ?getRedeemableCodeService@bdLobbyService@@QEAAPEAVbdRedeemableCodeService@@PEBD@Z(this, context);
}

/*
==============
bdLobbyService::handleMarketplaceBalanceUpdatedV2
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceBalanceUpdatedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceBalanceUpdatedV2@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceItemsExpired
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceItemsExpired(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceItemsExpired@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::handleMarketplaceItemsGranted
==============
*/

bool __fastcall bdLobbyService::handleMarketplaceItemsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  return ?handleMarketplaceItemsGranted@bdLobbyService@@IEAA_NV?$bdReference@VbdByteBuffer@@@@@Z(this, message);
}

/*
==============
bdLobbyService::getTencent
==============
*/

bdTencent *__fastcall bdLobbyService::getTencent(bdLobbyService *this)
{
  return ?getTencent@bdLobbyService@@QEAAPEAVbdTencent@@XZ(this);
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/
void bdLobbyService::bdLobbyService(bdLobbyService *this, const bdLobbyServicesConnectionInfo *connectionInfo)
{
  const char *Address; 
  bdGetHostByNameConfig *v22; 
  bdGetHostByNameConfig v25; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  bdLobbyConnectionListener::bdLobbyConnectionListener(this);
  this->__vftable = (bdLobbyService_vtbl *)&bdLobbyService::`vftable';
  this->m_taskManager = NULL;
  this->m_restTaskManager = NULL;
  __asm
  {
    vmovss  xmm6, cs:__real@3f400000
    vmovaps xmm2, xmm6; loadFactor
  }
  bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>(&this->m_services, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>(&this->m_pushHandlers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(&this->m_demonataPushHandlers, 4u, *(const float *)&_XMM2);
  this->m_profiles = NULL;
  this->m_messaging = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(&this->m_matchmakings, 4u, *(const float *)&_XMM2);
  this->m_statsManager = NULL;
  this->m_titleUtilitiesManager = NULL;
  this->m_eventLogManager = NULL;
  this->m_keyArchive = NULL;
  this->m_counter = NULL;
  this->m_group = NULL;
  this->m_contentStreamingManager = NULL;
  this->m_pooledStorageManager = NULL;
  this->m_tags = NULL;
  this->m_voteRankManager = NULL;
  this->m_antiCheat = NULL;
  this->m_DML = NULL;
  this->m_objectStore = NULL;
  this->m_achievementsEngineService = NULL;
  this->m_achievementsEngineClientService = NULL;
  this->m_abTesting = NULL;
  this->m_lootGeneration = NULL;
  this->m_mw4Service = NULL;
  this->m_reportLogoffService = NULL;
  this->m_crossPlatformUserLists = NULL;
  this->m_crossPlatformPresence = NULL;
  this->m_umbrella = NULL;
  this->m_uno = NULL;
  this->m_crossPlatformFriends = NULL;
  this->m_crossTitleLocalizedStrings = NULL;
  this->m_crossPlatformIdentity = NULL;
  this->m_regulations = NULL;
  this->m_featureBan = NULL;
  this->m_tencent = NULL;
  this->m_CODO = NULL;
  this->m_CODOTeamMarketplace = NULL;
  this->m_relayService = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(&this->m_marketingCommsManagers, 4u, *(const float *)&_XMM2);
  this->m_DDL = NULL;
  this->m_serverInventory = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(&this->m_redeemableCodeServiceManagers, 4u, *(const float *)&_XMM2);
  this->m_matchScheduler = NULL;
  this->m_mlg = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>(&this->m_marketplaceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>(&this->m_rewardManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(&this->m_publisherVariablesManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>(&this->m_storageManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>(&this->m_teamsManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(&this->m_teamShowcaseManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>(&this->m_mailManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(&this->m_richPresenceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(&this->m_playerVoteManagers, 4u, *(const float *)&_XMM2);
  bdGetHostByName::bdGetHostByName(&this->m_LSGLookup, 0);
  this->m_LSGPort = bdLobbyServicesConnectionInfo::getPort((bdLobbyServicesConnectionInfo *)connectionInfo);
  bdAddr::bdAddr(&this->m_resolvedLSGAddress);
  this->m_isResolved = 0;
  this->m_titleID = 0;
  this->m_eventHandler = NULL;
  this->m_lobbyConnection.m_ptr = NULL;
  this->m_lobbyConnectionEstablished = 0;
  *(_QWORD *)&this->m_authInfo.m_titleID = 0i64;
  this->m_authInfo.m_userID = 0i64;
  this->m_authInfo.m_authSessionKeyKDF = 0;
  memset_0(this->m_authInfo.m_data, 0, 0x98ui64);
  *(_QWORD *)this->m_authInfo.m_accountType = 0i64;
  *(_WORD *)&this->m_authInfo.m_accountType[8] = 0;
  *(_QWORD *)this->m_authInfo.m_clientID = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[8] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[16] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[24] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[32] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[40] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[48] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[56] = 0i64;
  this->m_errorCode = BD_NO_ERROR;
  *(_WORD *)&this->m_markTasksThrottled = 0;
  this->m_uploadThrottleBytesPerMs = 100;
  this->m_uploadThrottleBucketSize = 10000;
  Address = bdLobbyServicesConnectionInfo::getAddress((bdLobbyServicesConnectionInfo *)connectionInfo);
  bdStrlcpy(this->m_LSGAddress, Address, 0xFFui64);
  this->m_lastPumpTime = 0;
  bdGetHostByNameConfig::bdGetHostByNameConfig(&v25);
  bdGetHostByName::start(&this->m_LSGLookup, this->m_LSGAddress, LODWORD(v22->m_timeout));
  __asm { vmovaps xmm6, [rsp+58h+var_28] }
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/
void bdLobbyService::bdLobbyService(bdLobbyService *this, const char *lsgAddress, const unsigned __int16 lsgPort)
{
  bdGetHostByNameConfig *v23; 
  bdGetHostByNameConfig v26; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  bdLobbyConnectionListener::bdLobbyConnectionListener(this);
  this->__vftable = (bdLobbyService_vtbl *)&bdLobbyService::`vftable';
  this->m_taskManager = NULL;
  this->m_restTaskManager = NULL;
  __asm
  {
    vmovss  xmm6, cs:__real@3f400000
    vmovaps xmm2, xmm6; loadFactor
  }
  bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>(&this->m_services, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>(&this->m_pushHandlers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(&this->m_demonataPushHandlers, 4u, *(const float *)&_XMM2);
  this->m_profiles = NULL;
  this->m_messaging = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(&this->m_matchmakings, 4u, *(const float *)&_XMM2);
  this->m_statsManager = NULL;
  this->m_titleUtilitiesManager = NULL;
  this->m_eventLogManager = NULL;
  this->m_keyArchive = NULL;
  this->m_counter = NULL;
  this->m_group = NULL;
  this->m_contentStreamingManager = NULL;
  this->m_pooledStorageManager = NULL;
  this->m_tags = NULL;
  this->m_voteRankManager = NULL;
  this->m_antiCheat = NULL;
  this->m_DML = NULL;
  this->m_objectStore = NULL;
  this->m_achievementsEngineService = NULL;
  this->m_achievementsEngineClientService = NULL;
  this->m_abTesting = NULL;
  this->m_lootGeneration = NULL;
  this->m_mw4Service = NULL;
  this->m_reportLogoffService = NULL;
  this->m_crossPlatformUserLists = NULL;
  this->m_crossPlatformPresence = NULL;
  this->m_umbrella = NULL;
  this->m_uno = NULL;
  this->m_crossPlatformFriends = NULL;
  this->m_crossTitleLocalizedStrings = NULL;
  this->m_crossPlatformIdentity = NULL;
  this->m_regulations = NULL;
  this->m_featureBan = NULL;
  this->m_tencent = NULL;
  this->m_CODO = NULL;
  this->m_CODOTeamMarketplace = NULL;
  this->m_relayService = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(&this->m_marketingCommsManagers, 4u, *(const float *)&_XMM2);
  this->m_DDL = NULL;
  this->m_serverInventory = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(&this->m_redeemableCodeServiceManagers, 4u, *(const float *)&_XMM2);
  this->m_matchScheduler = NULL;
  this->m_mlg = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>(&this->m_marketplaceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>(&this->m_rewardManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(&this->m_publisherVariablesManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>(&this->m_storageManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>(&this->m_teamsManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(&this->m_teamShowcaseManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>(&this->m_mailManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(&this->m_richPresenceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(&this->m_playerVoteManagers, 4u, *(const float *)&_XMM2);
  bdGetHostByName::bdGetHostByName(&this->m_LSGLookup, 0);
  this->m_LSGPort = lsgPort;
  bdAddr::bdAddr(&this->m_resolvedLSGAddress);
  this->m_isResolved = 0;
  this->m_titleID = 0;
  this->m_eventHandler = NULL;
  this->m_lobbyConnection.m_ptr = NULL;
  this->m_lobbyConnectionEstablished = 0;
  *(_QWORD *)&this->m_authInfo.m_titleID = 0i64;
  this->m_authInfo.m_userID = 0i64;
  this->m_authInfo.m_authSessionKeyKDF = 0;
  memset_0(this->m_authInfo.m_data, 0, 0x98ui64);
  *(_QWORD *)this->m_authInfo.m_accountType = 0i64;
  *(_WORD *)&this->m_authInfo.m_accountType[8] = 0;
  *(_QWORD *)this->m_authInfo.m_clientID = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[8] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[16] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[24] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[32] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[40] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[48] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[56] = 0i64;
  this->m_errorCode = BD_NO_ERROR;
  *(_WORD *)&this->m_markTasksThrottled = 0;
  this->m_uploadThrottleBytesPerMs = 100;
  this->m_uploadThrottleBucketSize = 10000;
  bdStrlcpy(this->m_LSGAddress, lsgAddress, 0xFFui64);
  this->m_lastPumpTime = 0;
  bdGetHostByNameConfig::bdGetHostByNameConfig(&v26);
  bdGetHostByName::start(&this->m_LSGLookup, this->m_LSGAddress, LODWORD(v23->m_timeout));
  __asm { vmovaps xmm6, [rsp+58h+var_28] }
}

/*
==============
bdLobbyService::bdLobbyService
==============
*/
void bdLobbyService::bdLobbyService(bdLobbyService *this)
{
  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  bdLobbyConnectionListener::bdLobbyConnectionListener(this);
  this->__vftable = (bdLobbyService_vtbl *)&bdLobbyService::`vftable';
  this->m_taskManager = NULL;
  this->m_restTaskManager = NULL;
  __asm
  {
    vmovss  xmm6, cs:__real@3f400000
    vmovaps xmm2, xmm6; loadFactor
  }
  bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>(&this->m_services, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>(&this->m_pushHandlers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(&this->m_demonataPushHandlers, 4u, *(const float *)&_XMM2);
  this->m_profiles = NULL;
  this->m_messaging = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(&this->m_matchmakings, 4u, *(const float *)&_XMM2);
  this->m_statsManager = NULL;
  this->m_titleUtilitiesManager = NULL;
  this->m_eventLogManager = NULL;
  this->m_keyArchive = NULL;
  this->m_counter = NULL;
  this->m_group = NULL;
  this->m_contentStreamingManager = NULL;
  this->m_pooledStorageManager = NULL;
  this->m_tags = NULL;
  this->m_voteRankManager = NULL;
  this->m_antiCheat = NULL;
  this->m_DML = NULL;
  this->m_objectStore = NULL;
  this->m_achievementsEngineService = NULL;
  this->m_achievementsEngineClientService = NULL;
  this->m_abTesting = NULL;
  this->m_lootGeneration = NULL;
  this->m_mw4Service = NULL;
  this->m_reportLogoffService = NULL;
  this->m_crossPlatformUserLists = NULL;
  this->m_crossPlatformPresence = NULL;
  this->m_umbrella = NULL;
  this->m_uno = NULL;
  this->m_crossPlatformFriends = NULL;
  this->m_crossTitleLocalizedStrings = NULL;
  this->m_crossPlatformIdentity = NULL;
  this->m_regulations = NULL;
  this->m_featureBan = NULL;
  this->m_tencent = NULL;
  this->m_CODO = NULL;
  this->m_CODOTeamMarketplace = NULL;
  this->m_relayService = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(&this->m_marketingCommsManagers, 4u, *(const float *)&_XMM2);
  this->m_DDL = NULL;
  this->m_serverInventory = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(&this->m_redeemableCodeServiceManagers, 4u, *(const float *)&_XMM2);
  this->m_matchScheduler = NULL;
  this->m_mlg = NULL;
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>(&this->m_marketplaceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>(&this->m_rewardManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(&this->m_publisherVariablesManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>(&this->m_storageManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>(&this->m_teamsManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(&this->m_teamShowcaseManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>(&this->m_mailManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(&this->m_richPresenceManagers, 4u, *(const float *)&_XMM2);
  __asm { vmovaps xmm2, xmm6; loadFactor }
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(&this->m_playerVoteManagers, 4u, *(const float *)&_XMM2);
  bdGetHostByName::bdGetHostByName(&this->m_LSGLookup, 0);
  this->m_LSGPort = 0;
  bdAddr::bdAddr(&this->m_resolvedLSGAddress);
  this->m_isResolved = 0;
  this->m_titleID = 0;
  this->m_eventHandler = NULL;
  this->m_lobbyConnection.m_ptr = NULL;
  this->m_lobbyConnectionEstablished = 0;
  *(_QWORD *)&this->m_authInfo.m_titleID = 0i64;
  this->m_authInfo.m_userID = 0i64;
  this->m_authInfo.m_authSessionKeyKDF = 0;
  memset_0(this->m_authInfo.m_data, 0, 0x98ui64);
  *(_QWORD *)this->m_authInfo.m_accountType = 0i64;
  *(_WORD *)&this->m_authInfo.m_accountType[8] = 0;
  *(_QWORD *)this->m_authInfo.m_clientID = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[8] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[16] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[24] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[32] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[40] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[48] = 0i64;
  *(_QWORD *)&this->m_authInfo.m_clientID[56] = 0i64;
  *(_QWORD *)&this->m_errorCode = 0i64;
  *(_WORD *)&this->m_markTasksThrottled = 0;
  this->m_uploadThrottleBytesPerMs = 100;
  this->m_uploadThrottleBucketSize = 10000;
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
bdLobbyService::~bdLobbyService
==============
*/
void bdLobbyService::~bdLobbyService(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection *v3; 

  this->__vftable = (bdLobbyService_vtbl *)&bdLobbyService::`vftable';
  bdLobbyService::cleanup(this);
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
  {
    v3 = this->m_lobbyConnection.m_ptr;
    if ( v3 )
      ((void (__fastcall *)(bdLobbyConnection *, __int64))v3->~bdReferencable)(v3, 1i64);
    this->m_lobbyConnection.m_ptr = NULL;
  }
  bdGetHostByName::~bdGetHostByName(&this->m_LSGLookup);
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::~bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(&this->m_playerVoteManagers);
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear(&this->m_richPresenceManagers);
  bdMemory::deallocate(this->m_richPresenceManagers.m_map);
  bdHashMap<bdString,bdMail *,bdHashingClass>::clear(&this->m_mailManagers);
  bdMemory::deallocate(this->m_mailManagers.m_map);
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear(&this->m_teamShowcaseManagers);
  bdMemory::deallocate(this->m_teamShowcaseManagers.m_map);
  bdHashMap<bdString,bdTeams *,bdHashingClass>::clear(&this->m_teamsManagers);
  bdMemory::deallocate(this->m_teamsManagers.m_map);
  bdHashMap<bdString,bdStorage *,bdHashingClass>::clear(&this->m_storageManagers);
  bdMemory::deallocate(this->m_storageManagers.m_map);
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear(&this->m_publisherVariablesManagers);
  bdMemory::deallocate(this->m_publisherVariablesManagers.m_map);
  bdHashMap<bdString,bdReward *,bdHashingClass>::clear(&this->m_rewardManagers);
  bdMemory::deallocate(this->m_rewardManagers.m_map);
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear(&this->m_marketplaceManagers);
  bdMemory::deallocate(this->m_marketplaceManagers.m_map);
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear(&this->m_redeemableCodeServiceManagers);
  bdMemory::deallocate(this->m_redeemableCodeServiceManagers.m_map);
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear(&this->m_marketingCommsManagers);
  bdMemory::deallocate(this->m_marketingCommsManagers.m_map);
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear(&this->m_matchmakings);
  bdMemory::deallocate(this->m_matchmakings.m_map);
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear(&this->m_demonataPushHandlers);
  bdMemory::deallocate(this->m_demonataPushHandlers.m_map);
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::clear(&this->m_pushHandlers);
  bdMemory::deallocate(this->m_pushHandlers.m_map);
  bdHashMap<bdString,bdService *,bdHashingClass>::clear(&this->m_services);
  bdMemory::deallocate(this->m_services.m_map);
  bdLobbyConnectionListener::~bdLobbyConnectionListener(this);
}

/*
==============
bdLobbyErrorCodeToString
==============
*/
const char *bdLobbyErrorCodeToString(const bdLobbyErrorCode code)
{
  const char *v2; 
  char v3; 
  __int64 v4; 
  __int64 v6[746]; 
  int v7[748]; 

  memcpy_0(v7, &_static, 0xBA4ui64);
  v6[0] = (__int64)"BD_NO_ERROR";
  v6[1] = (__int64)"BD_TOO_MANY_TASKS";
  v6[2] = (__int64)"BD_NOT_CONNECTED";
  v6[3] = (__int64)"BD_SEND_FAILED";
  v6[4] = (__int64)"BD_HANDLE_TASK_FAILED";
  v6[5] = (__int64)"BD_START_TASK_FAILED";
  v6[6] = (__int64)"BD_RESULT_EXCEEDS_BUFFER_SIZE";
  v6[7] = (__int64)"BD_ACCESS_DENIED";
  v6[8] = (__int64)"BD_EXCEPTION_IN_DB";
  v6[9] = (__int64)"BD_MALFORMED_TASK_HEADER";
  v6[10] = (__int64)"BD_INVALID_ROW";
  v6[11] = (__int64)"BD_EMPTY_ARG_LIST";
  v6[12] = (__int64)"BD_PARAM_PARSE_ERROR";
  v6[13] = (__int64)"BD_PARAM_MISMATCHED_TYPE";
  v6[14] = (__int64)"BD_SERVICE_NOT_AVAILABLE";
  v6[15] = (__int64)"BD_CONNECTION_RESET";
  v6[16] = (__int64)"BD_INVALID_USER_ID";
  v6[17] = (__int64)"BD_LOBBY_PROTOCOL_VERSION_FAILURE";
  v6[18] = (__int64)"BD_LOBBY_INTERNAL_FAILURE";
  v6[19] = (__int64)"BD_LOBBY_PROTOCOL_ERROR";
  v6[20] = (__int64)"BD_LOBBY_FAILED_TO_DECODE_UTF8";
  v6[21] = (__int64)"BD_LOBBY_ASCII_EXPECTED";
  v6[22] = (__int64)"BD_INVALID_CONTEXT";
  v6[23] = (__int64)"BD_LOBBY_METHOD_DISABLED";
  v6[24] = (__int64)"BD_LOBBY_MIGRATION_FAILURE";
  v6[25] = (__int64)"BD_ASYNCHRONOUS_ERROR";
  v6[26] = (__int64)"BD_STREAMING_COMPLETE";
  v6[27] = (__int64)"BD_MEMBER_NO_PROPOSAL";
  v6[28] = (__int64)"BD_TEAMNAME_ALREADY_EXISTS";
  v6[29] = (__int64)"BD_MAX_TEAM_MEMBERSHIPS_LIMITED";
  v6[30] = (__int64)"BD_MAX_TEAM_OWNERSHIPS_LIMITED";
  v6[31] = (__int64)"BD_NOT_A_TEAM_MEMBER";
  v6[32] = (__int64)"BD_INVALID_TEAM_ID";
  v6[33] = (__int64)"BD_INVALID_TEAM_NAME";
  v6[34] = (__int64)"BD_NOT_A_TEAM_OWNER";
  v6[35] = (__int64)"BD_NOT_AN_ADMIN_OR_OWNER";
  v6[36] = (__int64)"BD_MEMBER_PROPOSAL_EXISTS";
  v6[37] = (__int64)"BD_MEMBER_EXISTS";
  v6[38] = (__int64)"BD_TEAM_FULL";
  v6[39] = (__int64)"BD_VULGAR_TEAM_NAME";
  v6[40] = (__int64)"BD_TEAM_USERID_BANNED";
  v6[41] = (__int64)"BD_TEAM_EMPTY";
  v6[42] = (__int64)"BD_INVALID_TEAM_PROFILE_QUERY_ID";
  v6[43] = (__int64)"BD_TEAMNAME_TOO_SHORT";
  v6[44] = (__int64)"BD_UNIQUE_PROFILE_DATA_EXISTS_ALREADY";
  v6[45] = (__int64)"BD_APPLICATION_EXISTS";
  v6[46] = (__int64)"BD_APPLICATIONS_MAX_EXCEEDED";
  v6[47] = (__int64)"BD_PAGE_SIZE_LIMIT_EXCEEDED";
  v6[48] = (__int64)"BD_APPLICATION_REJECTED_EXISTS";
  v6[49] = (__int64)"BD_APPLICATION_WITHDRAWN_EXISTS";
  v6[50] = (__int64)"BD_APPLICATION_DOES_NOT_EXIST";
  v6[51] = (__int64)"BD_APPLICATION_INVALID_STATE";
  v6[52] = (__int64)"BD_MEMBER_BAN_EXISTS";
  v6[53] = (__int64)"BD_MEMBER_BAN_DOES_NOT_EXIST";
  v6[54] = (__int64)"BD_OWNER_BAN_FORBIDDEN";
  v6[55] = (__int64)"BD_INVALID_ACCOUNT_TYPE";
  v6[56] = (__int64)"BD_CONFIGURED_ACCOUNT_TYPE_NOT_FOUND";
  v6[57] = (__int64)"BD_OWNER_OF_NON_EMPTY_TEAM";
  v6[58] = (__int64)"BD_CANNOT_APPLY_TO_PIRIVATE_TEAM";
  v6[59] = (__int64)"BD_MEMBER_IS_OWNER";
  v6[60] = (__int64)"BD_AUTO_JOINING_DISABLED";
  v6[61] = (__int64)"BD_TEAM_SHOWCASE_DISABLED";
  v6[62] = (__int64)"BD_INVALID_FILTER";
  v6[63] = (__int64)"BD_INVALID_TEAM_LEADERBOARD";
  v6[64] = (__int64)"BD_TEAM_LEADERBOARD_LOADING";
  v6[65] = (__int64)"BD_TEAM_SHOWCASE_COUNT_EXCEEDED";
  v6[66] = (__int64)"BD_USER_ALREADY_TEAM_OWNER";
  v6[67] = (__int64)"BD_UPPER_TEAM_MEMBER_LIMIT_EXCEEDED";
  v6[68] = (__int64)"BD_TEAM_MEMBER_LIMIT_NOT_SUPPORTED";
  v6[69] = (__int64)"BD_MISMATCHED_TEAM_PROFILE_COLLISION_FIELD";
  v6[70] = (__int64)"BD_INVALID_LEADERBOARD_ID";
  v6[71] = (__int64)"BD_INVALID_STATS_SET";
  v6[72] = (__int64)"BD_EMPTY_STATS_SET_IGNORED";
  v6[73] = (__int64)"BD_NO_DIRECT_ACCESS_TO_ARBITRATED_LBS";
  v6[74] = (__int64)"BD_STATS_WRITE_PERMISSION_DENIED";
  v6[75] = (__int64)"BD_STATS_WRITE_TYPE_DATA_TYPE_MISMATCH";
  v6[76] = (__int64)"BD_NO_STATS_FOR_USER";
  v6[77] = (__int64)"BD_INVALID_ACCESS_TO_UNRANKED_LB";
  v6[78] = (__int64)"BD_INVALID_EXTERNAL_TITLE_ID";
  v6[79] = (__int64)"BD_DIFFERENT_LEADERBOARD_SCHEMAS";
  v6[80] = (__int64)"BD_TOO_MANY_LEADERBOARDS_REQUESTED";
  v6[81] = (__int64)"BD_ENTITLEMENTS_ERROR";
  v6[82] = (__int64)"BD_ENTITLEMENTS_INVALID_TITLEID";
  v6[83] = (__int64)"BD_ENTITLEMENTS_INVALID_LEADERBOARDID";
  v6[84] = (__int64)"BD_ENTITLEMENTS_INVALID_GET_MODE_FOR_TITLE";
  v6[85] = (__int64)"BD_ENTITLEMENTS_URL_CONNECTION_ERROR";
  v6[86] = (__int64)"BD_ENTITLEMENTS_CONFIG_ERROR";
  v6[87] = (__int64)"BD_ENTITLEMENTS_NAMED_PARENT_ERROR";
  v6[88] = (__int64)"BD_ENTITLEMENTS_NAMED_KEY_ERROR";
  v6[89] = (__int64)"BD_TOO_MANY_ENTITY_IDS_REQUESTED";
  v6[90] = (__int64)"BD_STATS_READ_FAILED";
  v6[91] = (__int64)"BD_STATS_INVALID_WRITE_TO_VIRTUAL_LEADERBOARD";
  v6[92] = (__int64)"BD_STATS_INVALID_WRITE_TYPE_TO_MULTIRANK_LB";
  v6[93] = (__int64)"BD_STATS_INVALID_EXCLUDED_COLUMN";
  v6[94] = (__int64)"BD_STATS_INVALID_INCLUDED_COLUMN";
  v6[95] = (__int64)"BD_STATS_WRITE_NO_SCRIPT_MODULE";
  v6[96] = (__int64)"BD_STATS_WRITE_SCRIPT_MODULE_ERROR";
  v6[97] = (__int64)"BD_NON_READ_ON_READ_ONLY_LEADERBOARD";
  v6[98] = (__int64)"BD_INVALID_TITLE_ID";
  v6[99] = (__int64)"BD_DOWN_FOR_MAINTENANCE";
  v6[100] = (__int64)"BD_MESSAGING_INVALID_MAIL_ID";
  v6[101] = (__int64)"BD_SELF_BLOCK_NOT_ALLOWED";
  v6[102] = (__int64)"BD_GLOBAL_MESSAGE_ACCESS_DENIED";
  v6[103] = (__int64)"BD_GLOBAL_MESSAGES_USER_LIMIT_EXCEEDED";
  v6[104] = (__int64)"BD_MESSAGING_SENDER_DOES_NOT_EXIST";
  v6[105] = (__int64)"BD_AUTH_NO_ERROR";
  v6[106] = (__int64)"BD_AUTH_BAD_REQUEST";
  v6[107] = (__int64)"BD_AUTH_SERVER_CONFIG_ERROR";
  v6[108] = (__int64)"BD_AUTH_BAD_TITLE_ID";
  v6[109] = (__int64)"BD_AUTH_BAD_ACCOUNT";
  v6[110] = (__int64)"BD_AUTH_ILLEGAL_OPERATION";
  v6[111] = (__int64)"BD_AUTH_INCORRECT_LICENSE_CODE";
  v6[112] = (__int64)"BD_AUTH_CREATE_USERNAME_EXISTS";
  v6[113] = (__int64)"BD_AUTH_CREATE_USERNAME_ILLEGAL";
  v6[114] = (__int64)"BD_AUTH_CREATE_USERNAME_VULGAR";
  v6[115] = (__int64)"BD_AUTH_CREATE_MAX_ACC_EXCEEDED";
  v6[116] = (__int64)"BD_AUTH_MIGRATE_NOT_SUPPORTED";
  v6[117] = (__int64)"BD_AUTH_TITLE_DISABLED";
  v6[118] = (__int64)"BD_AUTH_ACCOUNT_EXPIRED";
  v6[119] = (__int64)"BD_AUTH_ACCOUNT_LOCKED";
  v6[120] = (__int64)"BD_AUTH_UNKNOWN_ERROR";
  v6[121] = (__int64)"BD_AUTH_INCORRECT_PASSWORD";
  v6[122] = (__int64)"BD_AUTH_IP_NOT_IN_ALLOWED_RANGE";
  v6[123] = (__int64)"BD_AUTH_WII_TOKEN_VERIFICATION_FAILED";
  v6[124] = (__int64)"BD_AUTH_WII_AUTHENTICATION_FAILED";
  v6[125] = (__int64)"BD_AUTH_IP_KEY_LIMIT_REACHED";
  v6[126] = (__int64)"BD_AUTH_INVALID_GSPID";
  v6[127] = (__int64)"BD_AUTH_INVALID_IP_RANGE_ID";
  v6[128] = (__int64)"BD_AUTH_3DS_TOKEN_VERIFICATION_FAILED";
  v6[129] = (__int64)"BD_AUTH_3DS_AUTHENTICATION_FAILED";
  v6[130] = (__int64)"BD_AUTH_STEAM_APP_ID_MISMATCH";
  v6[131] = (__int64)"BD_AUTH_ABACCOUNTS_APP_ID_MISMATCH";
  v6[132] = (__int64)"BD_AUTH_CODO_USERNAME_NOT_SET";
  v6[133] = (__int64)"BD_AUTH_WIIU_TOKEN_VERIFICATION_FAILED";
  v6[134] = (__int64)"BD_AUTH_WIIU_AUTHENTICATION_FAILED";
  v6[135] = (__int64)"BD_AUTH_CODO_USERNAME_NOT_BASE64";
  v6[136] = (__int64)"BD_AUTH_CODO_USERNAME_NOT_UTF8";
  v6[137] = (__int64)"BD_AUTH_TENCENT_TICKET_EXPIRED";
  v6[138] = (__int64)"BD_AUTH_PS3_SERVICE_ID_MISMATCH";
  v6[139] = (__int64)"BD_AUTH_CODOID_NOT_WHITELISTED";
  v6[140] = (__int64)"BD_AUTH_PLATFORM_TOKEN_RETRIEVAL_ERROR";
  v6[141] = (__int64)"BD_AUTH_JSON_FORMAT_ERROR";
  v6[142] = (__int64)"BD_AUTH_REPLY_CONTENT_ERROR";
  v6[143] = (__int64)"BD_AUTH_PLATFORM_TOKEN_EXPIRED";
  v6[144] = (__int64)"BD_AUTH_CONTINUING";
  v6[145] = (__int64)"BD_AUTH_PLATFORM_TOKEN_DECRYPTION_ERROR";
  v6[146] = (__int64)"BD_AUTH_PLATFORM_TOKEN_SIGNATURE_ERROR";
  v6[147] = (__int64)"BD_AUTH_DNS_RESOLUTION_ERROR";
  v6[148] = (__int64)"BD_AUTH_SSL_CERTIFICATE_ERROR";
  v6[149] = (__int64)"BD_AUTH_SERVER_UNAVAILABLE_ERROR";
  v6[150] = (__int64)"BD_AUTH_ENVIRONMENT_ERROR";
  v6[151] = (__int64)"BD_AUTH_PLATFORM_DEVICE_ID_ERROR";
  v6[152] = (__int64)"BD_AUTH_UNO_APP_ID_MISMATCH";
  v6[153] = (__int64)"BD_AUTH_UNICODE_DECODE_ERROR";
  v6[154] = (__int64)"BD_AUTH_STEAM_PUBLISHER_BAN";
  v6[155] = (__int64)"BD_AUTH_TICKET_DECRYPTION_ERROR";
  v6[156] = (__int64)"BD_AUTH_SIGNATURE_ERROR";
  v6[157] = (__int64)"BD_AUTH_REQUEST_TIMEOUT_ERROR";
  v6[158] = (__int64)"BD_AUTH_REQUEST_ABORTED_ERROR";
  v6[159] = (__int64)"BD_AUTH_SINGLE_IDENTITY_FLOW_DISABLED_ERROR";
  v6[160] = (__int64)"BD_AUTH_SINGLE_IDENTITY_TOKEN_MISSING_ERROR";
  v6[161] = (__int64)"BD_AUTH_SINGLE_IDENTITY_TOKEN_EXPIRED_ERROR";
  v6[162] = (__int64)"BD_AUTH_SINGLE_IDENTITY_TOKEN_INVALID_ERROR";
  v6[163] = (__int64)"BD_AUTH_SWITCH_TOKEN_VERIFICATION_FAILED";
  v6[164] = (__int64)"BD_AUTH_SWITCH_AUTHENTICATION_FAILED";
  v6[165] = (__int64)"BD_AUTH_BAD_DEVICE_KEY";
  v6[166] = (__int64)"BD_AUTH_BAD_DEVICE_TITLE_KEY";
  v6[167] = (__int64)"BD_AUTH_TSIG_EXPIRED";
  v6[168] = (__int64)"BD_AUTH_TOO_MANY_REQUESTS";
  v6[169] = (__int64)"BD_AUTH_COUNTRY_BLOCKED_ERROR";
  v6[170] = (__int64)"BD_NO_PROFILE_INFO_EXISTS";
  v6[171] = (__int64)"BD_PROFILE_COLLISION_FIELD_MISMATCH";
  v6[172] = (__int64)"BD_FRIENDSHIP_NOT_REQUSTED";
  v6[173] = (__int64)"BD_NOT_A_FRIEND";
  v6[174] = (__int64)"BD_SELF_FRIENDSHIP_NOT_ALLOWED";
  v6[175] = (__int64)"BD_FRIENDSHIP_EXISTS";
  v6[176] = (__int64)"BD_PENDING_FRIENDSHIP_EXISTS";
  v6[177] = (__int64)"BD_USERID_BANNED";
  v6[178] = (__int64)"BD_FRIENDS_FULL";
  v6[179] = (__int64)"BD_FRIENDS_NO_RICH_PRESENCE";
  v6[180] = (__int64)"BD_RICH_PRESENCE_TOO_LARGE";
  v6[181] = (__int64)"BD_FRIENDS_REMOTE_FULL";
  v6[182] = (__int64)"BD_NO_FILE";
  v6[183] = (__int64)"BD_PERMISSION_DENIED";
  v6[184] = (__int64)"BD_FILESIZE_LIMIT_EXCEEDED";
  v6[185] = (__int64)"BD_FILENAME_MAX_LENGTH_EXCEEDED";
  v6[186] = (__int64)"BD_EXTERNAL_STORAGE_SERVICE_ERROR";
  v6[187] = (__int64)"BD_VALIDATION_ERROR";
  v6[188] = (__int64)"BD_VALIDATION_TOKEN_ERROR";
  v6[189] = (__int64)"BD_VALIDATION_TOKEN_GENERATION_ERROR";
  v6[190] = (__int64)"BD_VALIDATION_TOKEN_VERIFICATION_ERROR";
  v6[191] = (__int64)"BD_STORAGE_SERVER_UNREACHABLE";
  v6[192] = (__int64)"BD_CHANNEL_DOES_NOT_EXIST";
  v6[193] = (__int64)"BD_CHANNEL_ALREADY_SUBSCRIBED";
  v6[194] = (__int64)"BD_CHANNEL_NOT_SUBSCRIBED";
  v6[195] = (__int64)"BD_CHANNEL_FULL";
  v6[196] = (__int64)"BD_CHANNEL_SUBSCRIPTIONS_FULL";
  v6[197] = (__int64)"BD_CHANNEL_NO_SELF_WHISPERING";
  v6[198] = (__int64)"BD_CHANNEL_ADMIN_REQUIRED";
  v6[199] = (__int64)"BD_CHANNEL_TARGET_NOT_SUBSCRIBED";
  v6[200] = (__int64)"BD_CHANNEL_REQUIRES_PASSWORD";
  v6[201] = (__int64)"BD_CHANNEL_TARGET_IS_SELF";
  v6[202] = (__int64)"BD_CHANNEL_PUBLIC_BAN_NOT_ALLOWED";
  v6[203] = (__int64)"BD_CHANNEL_USER_BANNED";
  v6[204] = (__int64)"BD_CHANNEL_PUBLIC_PASSWORD_NOT_ALLOWED";
  v6[205] = (__int64)"BD_CHANNEL_PUBLIC_KICK_NOT_ALLOWED";
  v6[206] = (__int64)"BD_CHANNEL_MUTED";
  v6[207] = (__int64)"BD_CONTENT_UNLOCK_UNKNOWN_ERROR";
  v6[208] = (__int64)"BD_UNLOCK_KEY_INVALID";
  v6[209] = (__int64)"BD_UNLOCK_KEY_ALREADY_USED_UP";
  v6[210] = (__int64)"BD_CONTENT_UNLOCK_LIMIT_REACHED";
  v6[211] = (__int64)"BD_DIFFERENT_HARDWARE_ID";
  v6[212] = (__int64)"BD_INVALID_CONTENT_OWNER";
  v6[213] = (__int64)"BD_CONTENT_UNLOCK_INVALID_USER";
  v6[214] = (__int64)"BD_CONTENT_UNLOCK_INVALID_CATEGORY";
  v6[215] = (__int64)"BD_KEY_ARCHIVE_INVALID_WRITE_TYPE";
  v6[216] = (__int64)"BD_KEY_ARCHIVE_EXCEEDED_MAX_IDS_PER_REQUEST";
  v6[217] = (__int64)"BD_BANDWIDTH_TEST_TRY_AGAIN";
  v6[218] = (__int64)"BD_BANDWIDTH_TEST_STILL_IN_PROGRESS";
  v6[219] = (__int64)"BD_BANDWIDTH_TEST_NOT_PROGRESS";
  v6[220] = (__int64)"BD_BANDWIDTH_TEST_SOCKET_ERROR";
  v6[221] = (__int64)"BD_INVALID_SESSION_NONCE";
  v6[222] = (__int64)"BD_ARBITRATION_FAILURE";
  v6[223] = (__int64)"BD_ARBITRATION_USER_NOT_REGISTERED";
  v6[224] = (__int64)"BD_ARBITRATION_NOT_CONFIGURED";
  v6[225] = (__int64)"BD_CONTENTSTREAMING_FILE_NOT_AVAILABLE";
  v6[226] = (__int64)"BD_CONTENTSTREAMING_STORAGE_SPACE_EXCEEDED";
  v6[227] = (__int64)"BD_CONTENTSTREAMING_NUM_FILES_EXCEEDED";
  v6[228] = (__int64)"BD_CONTENTSTREAMING_UPLOAD_BANDWIDTH_EXCEEDED";
  v6[229] = (__int64)"BD_CONTENTSTREAMING_FILENAME_MAX_LENGTH_EXCEEDED";
  v6[230] = (__int64)"BD_CONTENTSTREAMING_MAX_THUMB_DATA_SIZE_EXCEEDED";
  v6[231] = (__int64)"BD_CONTENTSTREAMING_DOWNLOAD_BANDWIDTH_EXCEEDED";
  v6[232] = (__int64)"BD_CONTENTSTREAMING_NOT_ENOUGH_DOWNLOAD_BUFFER_SPACE";
  v6[233] = (__int64)"BD_CONTENTSTREAMING_SERVER_NOT_CONFIGURED";
  v6[234] = (__int64)"BD_CONTENTSTREAMING_INVALID_APPLE_RECEIPT";
  v6[235] = (__int64)"BD_CONTENTSTREAMING_APPLE_STORE_NOT_AVAILABLE";
  v6[236] = (__int64)"BD_CONTENTSTREAMING_APPLE_RECEIPT_FILENAME_MISMATCH";
  v6[237] = (__int64)"BD_CONTENTSTREAMING_BATCH_DOWNLOAD_PARTIAL_FAILURE";
  v6[238] = (__int64)"BD_CONTENTSTREAMING_HTTP_ERROR";
  v6[239] = (__int64)"BD_CONTENTSTREAMING_FAILED_TO_START_HTTP";
  v6[240] = (__int64)"BD_CONTENTSTREAMING_LOCALE_INVALID";
  v6[241] = (__int64)"BD_CONTENTSTREAMING_LOCALE_MISSING";
  v6[242] = (__int64)"BD_VOTERANK_ERROR_EMPTY_RATING_SUBMISSION";
  v6[243] = (__int64)"BD_VOTERANK_ERROR_MAX_VOTES_EXCEEDED";
  v6[244] = (__int64)"BD_VOTERANK_ERROR_INVALID_RATING";
  v6[245] = (__int64)"BD_MAX_NUM_TAGS_EXCEEDED";
  v6[246] = (__int64)"BD_TAGGED_COLLECTION_DOES_NOT_EXIST";
  v6[247] = (__int64)"BD_EMPTY_TAG_ARRAY";
  v6[248] = (__int64)"BD_SEARCH_SERVER_UNREACHABLE";
  v6[249] = (__int64)"BD_ENTITY_ID_NOT_SPECIFIED";
  v6[250] = (__int64)"BD_INVALID_QUERY_ID";
  v6[251] = (__int64)"BD_NO_ENTRY_TO_UPDATE";
  v6[252] = (__int64)"BD_SESSION_INVITE_EXISTS";
  v6[253] = (__int64)"BD_INVALID_SESSION_ID";
  v6[254] = (__int64)"BD_ATTACHMENT_TOO_LARGE";
  v6[255] = (__int64)"BD_INVALID_FIELD_VALUE";
  v6[256] = (__int64)"BD_REQUEST_SESSION_NOT_SUPPORTED";
  v6[257] = (__int64)"BD_INVALID_GROUP_ID";
  v6[258] = (__int64)"BD_MAIL_INVALID_MAIL_ID_ERROR";
  v6[259] = (__int64)"BD_MAIL_PERMISSION_DENIED_ERROR";
  v6[260] = (__int64)"BD_TWITCH_SERVICE_ERROR";
  v6[261] = (__int64)"BD_TWITCH_ACCOUNT_ALREADY_LINKED";
  v6[262] = (__int64)"BD_TWITCH_NO_LINKED_ACCOUNT";
  v6[263] = (__int64)"BD_TWITTER_AUTH_ATTEMPT_FAILED";
  v6[264] = (__int64)"BD_TWITTER_AUTH_TOKEN_INVALID";
  v6[265] = (__int64)"BD_TWITTER_UPDATE_LIMIT_REACHED";
  v6[266] = (__int64)"BD_TWITTER_UNAVAILABLE";
  v6[267] = (__int64)"BD_TWITTER_ERROR";
  v6[268] = (__int64)"BD_TWITTER_TIMED_OUT";
  v6[269] = (__int64)"BD_TWITTER_ACCOUNT_AMBIGUOUS";
  v6[270] = (__int64)"BD_TWITTER_MAXIMUM_ACCOUNTS_REACHED";
  v6[271] = (__int64)"BD_TWITTER_ACCOUNT_NOT_REGISTERED";
  v6[272] = (__int64)"BD_TWITTER_DUPLICATE_STATUS";
  v6[273] = (__int64)"BD_TWITTER_ACCOUNT_ALREADY_REGISTERED";
  v6[274] = (__int64)"BD_FACEBOOK_AUTH_ATTEMPT_FAILED";
  v6[275] = (__int64)"BD_FACEBOOK_AUTH_TOKEN_INVALID";
  v6[276] = (__int64)"BD_FACEBOOK_PHOTO_DOES_NOT_EXIST";
  v6[277] = (__int64)"BD_FACEBOOK_PHOTO_INVALID";
  v6[278] = (__int64)"BD_FACEBOOK_PHOTO_ALBUM_FULL";
  v6[279] = (__int64)"BD_FACEBOOK_UNAVAILABLE";
  v6[280] = (__int64)"BD_FACEBOOK_ERROR";
  v6[281] = (__int64)"BD_FACEBOOK_TIMED_OUT";
  v6[282] = (__int64)"BD_FACEBOOK_DISABLED_FOR_USER";
  v6[283] = (__int64)"BD_FACEBOOK_ACCOUNT_AMBIGUOUS";
  v6[284] = (__int64)"BD_FACEBOOK_MAXIMUM_ACCOUNTS_REACHED";
  v6[285] = (__int64)"BD_FACEBOOK_INVALID_NUM_PICTURES_REQUESTED";
  v6[286] = (__int64)"BD_FACEBOOK_VIDEO_DOES_NOT_EXIST";
  v6[287] = (__int64)"BD_FACEBOOK_ACCOUNT_ALREADY_REGISTERED";
  v6[288] = (__int64)"BD_FACEBOOK_TARGET_OBJECT_ID_INVALID";
  v6[289] = (__int64)"BD_FACEBOOK_NO_SUCH_ACCOUNT";
  v6[290] = (__int64)"BD_APNS_INVALID_PAYLOAD";
  v6[291] = (__int64)"BD_APNS_INVALID_TOKEN_LENGTH_ERROR";
  v6[292] = (__int64)"BD_MAX_CONSOLEID_LENGTH_EXCEEDED";
  v6[293] = (__int64)"BD_MAX_WHITELIST_LENGTH_EXCEEDED";
  v6[294] = (__int64)"BD_TOTP_CHALLENGE_FAILED";
  v6[295] = (__int64)"BD_NO_TOTP_ACCOUNT";
  v6[296] = (__int64)"BD_EXTENDED_AUTH_INFO_ERROR";
  v6[297] = (__int64)"BD_EXTENDED_AUTH_INFO_LENGTH_EXCEEDED";
  v6[298] = (__int64)"BD_EXTENDED_AUTH_INFO_EXPIRED";
  v6[299] = (__int64)"BD_WHITELIST_TRAILING_WHITE_SPACE";
  v6[300] = (__int64)"BD_WHITELIST_MESSAGE_LENGTH_LIMIT_EXCEEDED";
  v6[301] = (__int64)"BD_BNET_SESSION_TOKEN_ERROR";
  v6[302] = (__int64)"BD_BNET_SESSION_CLAIMS_ERROR";
  v6[303] = (__int64)"BD_TRIAL_STATUS_ERROR";
  v6[304] = (__int64)"BD_TRIAL_STATUS_INVALID_DATA_ERROR";
  v6[305] = (__int64)"BD_TRIAL_STATUS_UNAVAILABLE_ERROR";
  v6[306] = (__int64)"BD_LOGON_SCHEDULE_ERROR";
  v6[307] = (__int64)"BD_LOGON_SCHEDULE_INVALID_TIME_RANGE_ERROR";
  v6[308] = (__int64)"BD_LOGON_SCHEDULE_INVALID_DAY_ERROR";
  v6[309] = (__int64)"BD_LOGON_SCHEDULE_INVALID_UPDATE_TYPE_ERROR";
  v6[310] = (__int64)"BD_LOGON_SCHEDULE_UPDATE_FAILED_ERROR";
  v6[311] = (__int64)"BD_USERGROUP_NAME_ALREADY_EXISTS";
  v6[312] = (__int64)"BD_INVALID_USERGROUP_ID";
  v6[313] = (__int64)"BD_USER_ALREADY_IN_USERGROUP";
  v6[314] = (__int64)"BD_USER_NOT_IN_USERGROUP";
  v6[315] = (__int64)"BD_INVALID_USERGROUP_MEMBER_TYPE";
  v6[316] = (__int64)"BD_TOO_MANY_MEMBERS_REQUESTED";
  v6[317] = (__int64)"BD_USERGROUP_NAME_TOO_SHORT";
  v6[318] = (__int64)"BD_RICH_PRESENCE_DATA_TOO_LARGE";
  v6[319] = (__int64)"BD_RICH_PRESENCE_TOO_MANY_USERS";
  v6[320] = (__int64)"BD_RICH_PRESENCE_ERROR";
  v6[321] = (__int64)"BD_RICH_PRESENCE_FEATURE_DISABLED_ERROR";
  v6[322] = (__int64)"BD_RICH_PRESENCE_TOO_MANY_UPDATES";
  v6[323] = (__int64)"BD_RICH_PRESENCE_SUBSCRIPTIONS_ERROR";
  v6[324] = (__int64)"BD_RICH_PRESENCE_TOO_MANY_SUBSCRIPTIONS_ERROR";
  v6[325] = (__int64)"BD_PRESENCE_DATA_TOO_LARGE";
  v6[326] = (__int64)"BD_PRESENCE_TOO_MANY_USERS";
  v6[327] = (__int64)"BD_USER_LOGGED_IN_OTHER_TITLE";
  v6[328] = (__int64)"BD_USER_NOT_LOGGED_IN";
  v6[329] = (__int64)"BD_PRESENCE_INVALID_PLATFORM";
  v6[330] = (__int64)"BD_SUBSCRIPTION_TOO_MANY_USERS";
  v6[331] = (__int64)"BD_SUBSCRIPTION_TICKET_PARSE_ERROR";
  v6[332] = (__int64)"BD_CODO_ID_INVALID_DATA";
  v6[333] = (__int64)"BD_INVALID_MESSAGE_FORMAT";
  v6[334] = (__int64)"BD_TLOG_TOO_MANY_MESSAGES";
  v6[335] = (__int64)"BD_CODO_ID_NOT_IN_WHITELIST";
  v6[336] = (__int64)"BD_TLOG_MESSAGE_TRANSFORMATION_ERROR";
  v6[337] = (__int64)"BD_REWARDS_NOT_ENABLED";
  v6[338] = (__int64)"BD_REWARDS_INVALID_RULE";
  v6[339] = (__int64)"BD_REDEEM_NAME_CHANGE_INTERNAL_ERROR";
  v6[340] = (__int64)"BD_REDEEM_NAME_CHANGE_INVALID_ITEM";
  v6[341] = (__int64)"BD_REDEEM_NAME_CHANGE_UNAVAILABLE_ITEM";
  v6[342] = (__int64)"BD_REDEEM_NAME_CHANGE_IN_PROGRESS";
  v6[343] = (__int64)"BD_REDEEM_NAME_CHANGE_INACTIVE_REQUEST";
  v6[344] = (__int64)"BD_REDEEM_NAME_CHANGE_INVALID_NAME";
  v6[345] = (__int64)"BD_REDEEM_NAME_CHANGE_SAME_NAME";
  v6[346] = (__int64)"BD_REDEEM_NAME_CHANGE_DUPLICATE_NAME";
  v6[347] = (__int64)"BD_TENCENT_NO_APPLICABLE_REWARDS";
  v6[348] = (__int64)"BD_TLOG_MESSAGE_DECOMPRESSION_ERROR";
  v6[349] = (__int64)"BD_REDEEM_TEAM_NAME_CHANGE_INTERNAL_ERROR";
  v6[350] = (__int64)"BD_REDEEM_TEAM_NAME_CHANGE_INVALID_ITEM";
  v6[351] = (__int64)"BD_REDEEM_TEAM_NAME_CHANGE_UNAVAILABLE_ITEM";
  v6[352] = (__int64)"BD_TENCENT_REWARD_NOT_FOUND";
  v6[353] = (__int64)"BD_MARKETPLACE_ERROR";
  v6[354] = (__int64)"BD_MARKETPLACE_RESOURCE_NOT_FOUND";
  v6[355] = (__int64)"BD_MARKETPLACE_INVALID_CURRENCY";
  v6[356] = (__int64)"BD_MARKETPLACE_INVALID_PARAMETER";
  v6[357] = (__int64)"BD_MARKETPLACE_RESOURCE_CONFLICT";
  v6[358] = (__int64)"BD_MARKETPLACE_STORAGE_ERROR";
  v6[359] = (__int64)"BD_MARKETPLACE_INTEGRITY_ERROR";
  v6[360] = (__int64)"BD_MARKETPLACE_INSUFFICIENT_FUNDS_ERROR";
  v6[361] = (__int64)"BD_MARKETPLACE_MMP_SERVICE_ERROR";
  v6[362] = (__int64)"BD_MARKETPLACE_PRECONDITION_REQUIRED";
  v6[363] = (__int64)"BD_MARKETPLACE_ITEM_MULTIPLE_PURCHASE_ERROR";
  v6[364] = (__int64)"BD_MARKETPLACE_MISSING_REQUIRED_ENTITLEMENT";
  v6[365] = (__int64)"BD_MARKETPLACE_VALIDATION_ERROR";
  v6[366] = (__int64)"BD_MARKETPLACE_TENCENT_PAYMENT_ERROR";
  v6[367] = (__int64)"BD_MARKETPLACE_SKU_NOT_COUPON_ENABLED_ERROR";
  v6[368] = (__int64)"BD_MARKETPLACE_TRANSACTION_ERROR";
  v6[369] = (__int64)"BD_MARKETPLACE_RECEIPT_USED";
  v6[370] = (__int64)"BD_MARKETPLACE_INVALID_RECEIPT";
  v6[371] = (__int64)"BD_MARKETPLACE_STEAM_REQUEST_FAILED";
  v6[372] = (__int64)"BD_MARKETPLACE_STEAM_NOT_APPROVED";
  v6[373] = (__int64)"BD_MARKETPLACE_PRODUCT_NOT_FOUND_IN_FP";
  v6[374] = (__int64)"BD_MARKETPLACE_STEAM_ALREADY_FINALIZED";
  v6[375] = (__int64)"BD_MARKETPLACE_STEAM_BAD_ORDER_ID";
  v6[376] = (__int64)"BD_MARKETPLACE_STEAM_CURRENCY_ERROR";
  v6[377] = (__int64)"BD_MARKETPLACE_PSN_INVALID_NP_TITLE_ID";
  v6[378] = (__int64)"BD_MARKETPLACE_PSN_INVALID_NP_AUTH_CODE";
  v6[379] = (__int64)"BD_MARKETPLACE_PSN_INVALID_ENTITLEMENT_ID";
  v6[380] = (__int64)"BD_MARKETPLACE_PSN_ENTITLEMENT_NOT_PRESENT";
  v6[381] = (__int64)"BD_MARKETPLACE_PSN_INTERNAL_ERROR";
  v6[382] = (__int64)"BD_MARKETPLACE_XB1_UNAUTHORISED_ERROR";
  v6[383] = (__int64)"BD_MARKETPLACE_XB1_REQUEST_REJECTED_ERROR";
  v6[384] = (__int64)"BD_MARKETPLACE_XB1_INSUFFICIENT_QUANTITY_ERROR";
  v6[385] = (__int64)"BD_MARKETPLACE_XB1_BAD_DELEGATION_TOKEN_ERROR";
  v6[386] = (__int64)"BD_MARKETPLACE_XB1_REQUEST_FAILED_ERROR";
  v6[387] = (__int64)"BD_MARKETPLACE_X360_REQUEST_FAILED";
  v6[388] = (__int64)"BD_MARKETPLACE_X360_ITEM_NOT_PRESENT";
  v6[389] = (__int64)"BD_MARKETPLACE_X360_CONNECTION_ERROR";
  v6[390] = (__int64)"BD_MARKETPLACE_USAGE_TIME_ERROR";
  v6[391] = (__int64)"BD_MARKETPLACE_DURABLE_ALREADY_GRANTED";
  v6[392] = (__int64)"BD_MARKETPLACE_FIRST_PARTY_DURABLE_EXISTS";
  v6[393] = (__int64)"BD_MARKETPLACE_ITEM_LIMIT_REACHED";
  v6[394] = (__int64)"BD_MARKETPLACE_OVER_ITEM_MAX_QUANTITY_ERROR";
  v6[395] = (__int64)"BD_MARKETPLACE_INSUFFICIENT_ITEM_QUANTITY";
  v6[396] = (__int64)"BD_MARKETPLACE_ENTITY_NOT_ENABLED";
  v6[397] = (__int64)"BD_MARKETPLACE_MISCONFIGURED";
  v6[398] = (__int64)"BD_MARKETPLACE_COUPON_NOT_CLAIMED_OR_FOUND";
  v6[399] = (__int64)"BD_MARKETPLACE_INVALID_DISCOUNT";
  v6[400] = (__int64)"BD_MARKETPLACE_INVALID_STORE_VERSION";
  v6[401] = (__int64)"BD_MARKETPLACE_SKU_SOLD_OUT";
  v6[402] = (__int64)"BD_MARKETPLACE_WIIU_AUTH_FAILED";
  v6[403] = (__int64)"BD_MARKETPLACE_WIIU_INVALID_PARAMETER";
  v6[404] = (__int64)"BD_MARKETPLACE_WIIU_TAX_LOCATION_NOT_SPECIFIED";
  v6[405] = (__int64)"BD_MARKETPLACE_WIIU_ACCOUNT_ERROR";
  v6[406] = (__int64)"BD_MARKETPLACE_WIIU_PURCHASING_ERROR";
  v6[407] = (__int64)"BD_MARKETPLACE_WIIU_BALANCE_ERROR";
  v6[408] = (__int64)"BD_MARKETPLACE_WIIU_SERVER_ERROR";
  v6[409] = (__int64)"BD_MARKETPLACE_WIIU_REQUEST_FAILED";
  v6[410] = (__int64)"BD_MARKETPLACE_WIIU_SERVER_MAINTENANCE";
  v6[411] = (__int64)"BD_MARKETPLACE_WIIU_SERVICE_TERMINATED";
  v6[412] = (__int64)"BD_MARKETPLACE_WIIU_ITEM_NOT_PRESENT";
  v6[413] = (__int64)"BD_MARKETPLACE_WIIU_TAX_LOCATION_INVALID";
  v6[414] = (__int64)"BD_MARKETPLACE_XB1_DURABLE_NOT_PRESENT";
  v6[415] = (__int64)"BD_MARKETPLACE_EXPECTED_PRICE_MISMATCH";
  v6[416] = (__int64)"BD_MARKETPLACE_ITEM_NOT_CONSUMABLE";
  v6[417] = (__int64)"BD_MARKETPLACE_IDEMPOTENT_REQUEST_COLLISION";
  v6[418] = (__int64)"BD_MARKETPLACE_COUPON_NOT_STARTED";
  v6[419] = (__int64)"BD_MARKETPLACE_MULTIPLE_OPERATIONS_ERROR";
  v6[420] = (__int64)"BD_MARKETPLACE_MISSING_PAYMENT_PROVIDER_CURRENCY_ERROR";
  v6[421] = (__int64)"BD_MARKETPLACE_WIIU_LANGUAGE_NOT_SUPPORTED";
  v6[422] = (__int64)"BD_MARKETPLACE_PAWN_CHOICE_EXPECTED";
  v6[423] = (__int64)"BD_MARKETPLACE_PAWN_CHOICE_UNSUPPORTED";
  v6[424] = (__int64)"BD_MARKETPLACE_INVALID_REWARD_ERROR";
  v6[425] = (__int64)"BD_MARKETPLACE_MISSING_REQUIRED_ITEMS_ERROR";
  v6[426] = (__int64)"BD_MARKETPLACE_MISSING_REQUIRED_CURRENCY_BALANCES_ERROR";
  v6[427] = (__int64)"BD_MARKETPLACE_MISSING_REQUIRED_ENTITLEMENTS_ERROR";
  v6[428] = (__int64)"BD_MARKETPLACE_UNREACHABLE_ERROR";
  v6[429] = (__int64)"BD_MARKETPLACE_ITEM_ALREADY_PERMANENTLY_OWNED";
  v6[430] = (__int64)"BD_MARKETPLACE_EXCEEDED_ITEM_MAX_USAGE_TIME";
  v6[431] = (__int64)"BD_MARKETPLACE_BNET_REQUEST_FAILED";
  v6[432] = (__int64)"BD_MARKETPLACE_WEGAME_SERVICE_ERROR";
  v6[433] = (__int64)"BD_MARKETPLACE_WEGAME_REQUEST_FAILED";
  v6[434] = (__int64)"BD_MARKETPLACE_SWITCH_SERVICE_ERROR";
  v6[435] = (__int64)"BD_MARKETPLACE_SWITCH_REQUEST_FAILED";
  v6[436] = (__int64)"BD_COMMS_SERVICE_NOT_AVAILABLE_ERROR";
  v6[437] = (__int64)"BD_COMMS_CLIENT_ERROR";
  v6[438] = (__int64)"BD_LEAGUE_INVALID_TEAM_SIZE";
  v6[439] = (__int64)"BD_LEAGUE_INVALID_TEAM";
  v6[440] = (__int64)"BD_LEAGUE_INVALID_SUBDIVISION";
  v6[441] = (__int64)"BD_LEAGUE_INVALID_LEAGUE";
  v6[442] = (__int64)"BD_LEAGUE_TOO_MANY_RESULTS_REQUESTED";
  v6[443] = (__int64)"BD_LEAGUE_METADATA_TOO_LARGE";
  v6[444] = (__int64)"BD_LEAGUE_TEAM_ICON_TOO_LARGE";
  v6[445] = (__int64)"BD_LEAGUE_TEAM_NAME_TOO_LONG";
  v6[446] = (__int64)"BD_LEAGUE_ARRAY_SIZE_MISMATCH";
  v6[447] = (__int64)"BD_LEAGUE_SUBDIVISION_MISMATCH";
  v6[448] = (__int64)"BD_LEAGUE_INVALID_WRITE_TYPE";
  v6[449] = (__int64)"BD_LEAGUE_INVALID_STATS_DATA";
  v6[450] = (__int64)"BD_LEAGUE_SUBDIVISION_UNRANKED";
  v6[451] = (__int64)"BD_LEAGUE_CROSS_TEAM_STATS_WRITE_PREVENTED";
  v6[452] = (__int64)"BD_LEAGUE_INVALID_STATS_SEASON";
  v6[453] = (__int64)"BD_CONNECTION_COUNTER_ERROR";
  v6[454] = (__int64)"BD_LINKED_ACCOUNTS_INVALID_CONTEXT";
  v6[455] = (__int64)"BD_LINKED_ACCOUNTS_INVALID_PLATFORM";
  v6[456] = (__int64)"BD_LINKED_ACCOUNTS_LINKED_ACCOUNTS_FETCH_ERROR";
  v6[457] = (__int64)"BD_LINKED_ACCOUNTS_INVALID_ACCOUNT";
  v6[458] = (__int64)"BD_LINKED_ACCOUNTS_INVALID_TOKEN";
  v6[459] = (__int64)"BD_QUEUED_MATCHING_ERROR";
  v6[460] = (__int64)"BD_QUEUED_MATCHING_NOT_FOUND";
  v6[461] = (__int64)"BD_QUEUED_MATCHING_WRONG_QUEUE_TYPE";
  v6[462] = (__int64)"BD_QUEUED_MATCHING_INVALID_QUEUE_ID";
  v6[463] = (__int64)"BD_LOGIN_QUEUE_NO_ERROR";
  v6[464] = (__int64)"BD_LOGIN_QUEUE_ENVIRONMENT_ERROR";
  v6[465] = (__int64)"BD_LOGIN_QUEUE_UNKNOWN_ERROR";
  v6[466] = (__int64)"BD_LOGIN_QUEUE_BAD_REQUEST";
  v6[467] = (__int64)"BD_LOGIN_QUEUE_SERVER_UNAVAILABLE_ERROR";
  v6[468] = (__int64)"BD_LOGIN_QUEUE_SSL_CERTIFICATE_ERROR";
  v6[469] = (__int64)"BD_LOGIN_QUEUE_DNS_RESOLUTION_ERROR";
  v6[470] = (__int64)"BD_LOGIN_QUEUE_JSON_FORMAT_ERROR";
  v6[471] = (__int64)"BD_LOGIN_QUEUE_TICKET_PARSE_ERROR";
  v6[472] = (__int64)"BD_LOGIN_QUEUE_INVALID_TITLE_ID";
  v6[473] = (__int64)"BD_LOGIN_QUEUE_INTERNAL_ERROR";
  v6[474] = (__int64)"BD_LOGIN_QUEUE_CLOSED_QUEUE";
  v6[475] = (__int64)"BD_LOGIN_QUEUE_INVALID_QUEUE_ID";
  v6[476] = (__int64)"BD_LOGIN_QUEUE_NOT_FOUND";
  v6[477] = (__int64)"BD_LOGIN_QUEUE_REPLY_CONTENT_ERROR";
  v6[478] = (__int64)"BD_LOGIN_QUEUE_TOO_MANY_REQUESTS";
  v6[479] = (__int64)"BD_VOTING_MAX_VALUE_EXCEEDED";
  v6[480] = (__int64)"BD_VOTING_INVALID_GROUP_NAME";
  v6[481] = (__int64)"BD_VOTING_IN_PROGRESS";
  v6[482] = (__int64)"BD_VOTING_NON_EXISTENT_GROUP";
  v6[483] = (__int64)"BD_USER_GENERATED_STATS_ERROR";
  v6[484] = (__int64)"BD_INVALID_ACCESS_TO_USER_GENERATED_LB_ERROR";
  v6[485] = (__int64)"BD_INVALID_ACCESS_TO_NON_USER_GENERATED_LB_ERROR";
  v6[486] = (__int64)"BD_SUB_LEADERBOARD_ID_MISMATCH_ERROR";
  v6[487] = (__int64)"BD_PUBLISHER_VARIABLES_SERVICE_ERROR";
  v6[488] = (__int64)"BD_PUBLISHER_VARIABLES_NOT_FOUND";
  v6[489] = (__int64)"BD_PUBLISHER_VARIABLES_INVALID_NAMESPACE";
  v6[490] = (__int64)"BD_PUBLISHER_VARIABLES_INVALID_GROUP_ID";
  v6[491] = (__int64)"BD_GMSG_INVALID_CATEGORY_ID";
  v6[492] = (__int64)"BD_GMSG_CATEGORY_MEMBERSHIPS_LIMIT";
  v6[493] = (__int64)"BD_GMSG_NONMEMBER_POST_DISALLOWED";
  v6[494] = (__int64)"BD_GMSG_CATEGORY_DISALLOWS_CLIENT_TYPE";
  v6[495] = (__int64)"BD_GMSG_PAYLOAD_TOO_BIG";
  v6[496] = (__int64)"BD_GMSG_MEMBER_POST_DISALLOWED";
  v6[497] = (__int64)"BD_GMSG_OVERLOADED";
  v6[498] = (__int64)"BD_GMSG_USER_PERCATEGORY_POST_RATE_EXCEEDED";
  v6[499] = (__int64)"BD_GMSG_USER_GLOBAL_POST_RATE_EXCEEDED";
  v6[500] = (__int64)"BD_GMSG_GROUP_POST_RATE_EXCEEDED";
  v6[501] = (__int64)"BD_GMSG_GROUP_LIMIT_REACHED";
  v6[502] = (__int64)"BD_GMSG_GROUP_MEMBERSHIP_LIMIT_REACHED";
  v6[503] = (__int64)"BD_SERVER_INVENTORY_SERVER_ERROR";
  v6[504] = (__int64)"BD_SERVER_INVENTORY_SERVER_ALLOCATED";
  v6[505] = (__int64)"BD_SERVER_INVENTORY_ENTRY_DOES_NOT_EXIST";
  v6[506] = (__int64)"BD_SERVER_INVENTORY_DATA_LAYER_ERROR";
  v6[507] = (__int64)"BD_SERVER_INVENTORY_NOT_ENABLED";
  v6[508] = (__int64)"BD_SERVER_INVENTORY_NO_SERVER_ALLOCATED";
  v6[509] = (__int64)"BD_SERVER_INVENTORY_MAX_REGISTRATION_LENGTH_EXCEEDED";
  v6[510] = (__int64)"BD_SERVER_INVENTORY_REGISTRATION_INVALID_CHARACTERS";
  v6[511] = (__int64)"BD_SERVER_INVENTORY_INVALID_PARAMETER";
  v6[512] = (__int64)"BD_CODO_CLAN_NO_TEMP_RESERVATION";
  v6[513] = (__int64)"BD_CODO_CLAN_TOO_MANY_MEMBERSHIPS";
  v6[514] = (__int64)"BD_CODO_CLAN_UNEXPECTED_FOUNDATION_STATE";
  v6[515] = (__int64)"BD_CODO_CLAN_UNABLE_TO_FIND_NAME";
  v6[516] = (__int64)"BD_CODO_CLAN_INTERNAL_MARKETPLACE_ERROR";
  v6[517] = (__int64)"BD_CODO_CLAN_INSUFFICIENT_FUNDS";
  v6[518] = (__int64)"BD_CODO_CLAN_UNSATISFIED_PRECONDITION";
  v6[519] = (__int64)"BD_CODO_CLAN_NO_CLAN";
  v6[520] = (__int64)"BD_CODO_CLAN_NO_CHANNEL";
  v6[521] = (__int64)"BD_CODO_CLAN_NOT_A_CLAN_MEMBER";
  v6[522] = (__int64)"BD_CODO_CLAN_DISBAND_TOO_MANY_MEMBERS";
  v6[523] = (__int64)"BD_CODO_CLAN_DISBAND_TOO_SOON";
  v6[524] = (__int64)"BD_NO_SUCH_ROLE";
  v6[525] = (__int64)"BD_NO_SUCH_PERMISSION";
  v6[526] = (__int64)"BD_BAD_ROLE_SPECIFICATION";
  v6[527] = (__int64)"BD_BAD_PERMISSION_SPECIFICATION";
  v6[528] = (__int64)"BD_REDEEMABLE_CODE_REGISTRY_SERVICE_GENERIC_ERROR";
  v6[529] = (__int64)"BD_REDEEMABLE_CODE_MARKETPLACE_SERVICE_GENERIC_ERROR";
  v6[530] = (__int64)"BAD_PAYLOAD_ERROR";
  v6[531] = (__int64)"INVALID_PAYLOAD_SIGNATURE_ERROR";
  v6[532] = (__int64)"GENERATE_PAYLOAD_SIGNATURE_ERROR";
  v6[533] = (__int64)"BD_REDEEMABLE_CODE_EXPIRED_CLIENT_TRANSACTION_ID";
  v6[534] = (__int64)"BD_REDEEMABLE_CODE_NOT_FOUND";
  v6[535] = (__int64)"BD_REDEEMABLE_CODE_USE_LIMIT_EXCEEDED";
  v6[536] = (__int64)"BD_REDEEMABLE_CODE_ALREADY_USED_BY_USER";
  v6[537] = (__int64)"BD_REDEEMABLE_CODE_EXPIRED";
  v6[538] = (__int64)"INVALID_CLIENT_TRANSACTION_ID";
  v6[539] = (__int64)"BD_ACHIEVEMENTS_ENGINE_CLIENT_ERROR";
  v6[540] = (__int64)"BD_ACHIEVEMENTS_ENGINE_SERVER_ERROR";
  v6[541] = (__int64)"BD_ACHIEVEMENTS_ENGINE_INSUFFICIENT_BALANCE_ERROR";
  v6[542] = (__int64)"BD_ACHIEVEMENTS_ENGINE_ACTIVATION_NOT_SCHEDULED_ERROR";
  v6[543] = (__int64)"BD_ACHIEVEMENTS_ENGINE_ACTIVE_LIMIT_EXCEEDED";
  v6[544] = (__int64)"BD_ACHIEVEMENTS_ENGINE_DUPLICATE_REQUEST_ID";
  v6[545] = (__int64)"BD_ACHIEVEMENTS_ENGINE_MULTI_STATUS";
  v6[546] = (__int64)"BD_MW4_BACKEND_SERVICE_NOT_AVAILABLE";
  v6[547] = (__int64)"BD_MW4_BACKEND_RESOURCE_NOT_FOUND";
  v6[548] = (__int64)"BD_MW4_BACKEND_BAD_REQUEST";
  v6[549] = (__int64)"BD_CLANS_PROPOSAL_DOES_NOT_EXIST";
  v6[550] = (__int64)"BD_CLANS_GROUP_NAME_NOT_UNIQUE";
  v6[551] = (__int64)"BD_CLANS_MAX_GROUP_MEMBERSHIPS_REACHED";
  v6[552] = (__int64)"BD_CLANS_MAX_GROUP_OWNERSHIPS_REACHED";
  v6[553] = (__int64)"BD_CLANS_GROUP_DOES_NOT_EXIST";
  v6[554] = (__int64)"BD_CLANS_GROUP_PERMISSION_DENIED";
  v6[555] = (__int64)"BD_CLANS_VULGAR_GROUP_NAME";
  v6[556] = (__int64)"BD_CLANS_GROUP_NAME_TOO_SHORT";
  v6[557] = (__int64)"BD_CLANS_GROUP_ATTACHMENT_LIMIT_EXCEEDED";
  v6[558] = (__int64)"BD_CLANS_GROUP_FULL";
  v6[559] = (__int64)"BD_CLANS_MAX_OUTGOING_PROPOSALS_REACHED";
  v6[560] = (__int64)"BD_CLANS_MEMBER_BAN_EXISTS";
  v6[561] = (__int64)"BD_CLANS_GROUP_KIND_NOT_CONFIGURED";
  v6[562] = (__int64)"BD_CLANS_INVALID_ROOT_KIND";
  v6[563] = (__int64)"BD_CLANS_GROUP_FILE_DOES_NOT_EXIST";
  v6[564] = (__int64)"BD_CLANS_GROUP_FILE_COLLISION_FIELD_MISMATCH";
  v6[565] = (__int64)"BD_CLANS_BATCH_REQUEST_LIMIT_EXCEEDED";
  v6[566] = (__int64)"BD_CLANS_INVALID_PAGE_TOKEN";
  v6[567] = (__int64)"BD_CLANS_INVALID_GROUP_FILTER";
  v6[568] = (__int64)"BD_CLANS_GROUP_TAG_NOT_UNIQUE";
  v6[569] = (__int64)"BD_CLANS_GROUP_TAG_TOO_SHORT";
  v6[570] = (__int64)"BD_CLANS_VULGAR_GROUP_TAG";
  v6[571] = (__int64)"BD_REWARD_NO_REWARD_TOKEN_FOUND";
  v6[572] = (__int64)"BD_REWARD_INVALID_ACHIEVEMENT_IDS_SPECIFIED";
  v6[573] = (__int64)"BD_REWARD_CLIENT_ACHIEVEMENTS_NOT_ENABLED";
  v6[574] = (__int64)"BD_REWARD_EVENTS_ERROR";
  v6[575] = (__int64)"BD_REWARD_EVENTS_NOT_ENABLED";
  v6[576] = (__int64)"BD_REWARD_EVENTS_RULES_ERROR";
  v6[577] = (__int64)"BD_REWARD_EVENTS_DATA_ERROR";
  v6[578] = (__int64)"BD_REWARD_EVENTS_TRANSACTION_ERROR";
  v6[579] = (__int64)"BD_REWARD_CONFIGURATION_ERROR";
  v6[580] = (__int64)"BD_REWARD_TOO_MANY_ACTIVE_CHALLENGES";
  v6[581] = (__int64)"BD_REWARD_EVENTS_TRANSACTION_EXPIRED";
  v6[582] = (__int64)"BD_REWARD_CHALLENGE_NOT_SCHEDULED";
  v6[583] = (__int64)"BD_REWARD_CHALLENGE_ALREADY_COMPLETED";
  v6[584] = (__int64)"BD_REWARD_CODO_TOO_MANY_REROLLS";
  v6[585] = (__int64)"BD_REWARD_CODO_BAD_REROLL_PARAMS";
  v6[586] = (__int64)"BD_UMBRELLA_PROVIDER_SERVER_ERROR";
  v6[587] = (__int64)"BD_UMBRELLA_PROVIDER_UNSUPPORTED_OPERATION";
  v6[588] = (__int64)"BD_UMBRELLA_ERROR";
  v6[589] = (__int64)"BD_UMBRELLA_INVALID_TITLE_ID";
  v6[590] = (__int64)"BD_UMBRELLA_INVALID_QUERY_STRING";
  v6[591] = (__int64)"BD_UMBRELLA_INVALID_DATA";
  v6[592] = (__int64)"BD_UMBRELLA_INVALID_CLIENT";
  v6[593] = (__int64)"BD_UMBRELLA_PROVIDER_NOT_SUPPORTED";
  v6[594] = (__int64)"BD_UMBRELLA_UNAUTHORIZED_ACCESS";
  v6[595] = (__int64)"BD_UMBRELLA_INVALID_TOKEN";
  v6[596] = (__int64)"BD_UMBRELLA_EXPIRED_PROVIDER_REFRESH_TOKEN";
  v6[597] = (__int64)"BD_UMBRELLA_NO_VALID_PROVIDER_TOKENS";
  v6[598] = (__int64)"BD_UMBRELLA_INVALID_LSG_TICKET";
  v6[599] = (__int64)"BD_UMBRELLA_TOKEN_NOT_FOUND";
  v6[600] = (__int64)"BD_UMBRELLA_USER_NOT_FOUND";
  v6[601] = (__int64)"BD_UMBRELLA_ACCOUNT_NOT_FOUND";
  v6[602] = (__int64)"BD_UMBRELLA_MERGE_CONFLICT";
  v6[603] = (__int64)"BD_UMBRELLA_PROVIDER_INACCESSIBLE";
  v6[604] = (__int64)"BD_UMBRELLA_MISSING_FIELD";
  v6[605] = (__int64)"BD_UMBRELLA_FIELD_INVALID";
  v6[606] = (__int64)"BD_UMBRELLA_PLAYER_BAN";
  v6[607] = (__int64)"BD_UMBRELLA_EXPIRED_TOKEN";
  v6[608] = (__int64)"BD_UNO_ERROR";
  v6[609] = (__int64)"BD_UNO_INVALID_DATA";
  v6[610] = (__int64)"BD_UNO_INVALID_DATE_OF_BIRTH";
  v6[611] = (__int64)"BD_UNO_UNAUTHORIZED_ACCESS";
  v6[612] = (__int64)"BD_UNO_INVALID_TOKEN";
  v6[613] = (__int64)"BD_UNO_EXPIRED_TOKEN";
  v6[614] = (__int64)"BD_UNO_EMAIL_NOT_VERIFIED";
  v6[615] = (__int64)"BD_UNO_TOS_VERSION_NOT_FOUND";
  v6[616] = (__int64)"BD_UNO_TOS_CONTENT_NOT_FOUND";
  v6[617] = (__int64)"BD_UNO_TOS_ALREADY_ACCEPTED";
  v6[618] = (__int64)"BD_UNO_MISSING_FIELD";
  v6[619] = (__int64)"BD_UNO_DNS_RESOLUTION_FAILED";
  v6[620] = (__int64)"BD_UNO_FIELD_INVALID";
  v6[621] = (__int64)"BD_UNO_INVALID_USERNAME";
  v6[622] = (__int64)"BD_UNO_INVALID_PASSWORD";
  v6[623] = (__int64)"BD_UNO_EMAIL_ALREADY_EXISTS";
  v6[624] = (__int64)"BD_UNO_DESERIALIZATION_FAILURE";
  v6[625] = (__int64)"BD_UMBRELLA_DESERIALIZATION_FAILURE";
  v6[626] = (__int64)"BD_UNO_NO_RENAME_TOKENS";
  v6[627] = (__int64)"BD_UNO_MARKETPLACE_ERROR";
  v6[628] = (__int64)"BD_SI_ERROR";
  v6[629] = (__int64)"BD_MATCH_SCHEDULER_ERROR";
  v6[630] = (__int64)"BD_MATCH_SCHEDULER_SCHEDULED_MATCH_DOES_NOT_EXIST";
  v6[631] = (__int64)"BD_MATCH_SCHEDULER_MAXIMUM_EVENTS_PER_MATCH_REACHED";
  v6[632] = (__int64)"BD_MLG_ERROR";
  v6[633] = (__int64)"BD_MLG_REMOTE_ERROR";
  v6[634] = (__int64)"BD_CODO_AUTO_JOIN_LEVEL_NOT_MET";
  v6[635] = (__int64)"BD_CODO_NOT_PERMITTED_TO_UPDATE_PROFILE_FIELD";
  v6[636] = (__int64)"BD_CODO_INVALID_PROFILE_VALUE";
  v6[637] = (__int64)"BD_CODO_PROFILE_COLUMN_DOES_NOT_EXIST";
  v6[638] = (__int64)"BD_CODO_LOUDSPEAKER_INVALID_TOKEN";
  v6[639] = (__int64)"BD_CODO_LOUDSPEAKER_INVALID_CATEGORY";
  v6[640] = (__int64)"BD_CODO_RESETTABLE_STATS_NOT_CONFIGURED";
  v6[641] = (__int64)"BD_CODO_REDEEM_INCREASE_TEAM_MEMBER_LIMIT_INVALID_ITEM";
  v6[642] = (__int64)"BD_CODO_REDEEM_INCREASE_TEAM_MEMBER_LIMIT_INTERNAL_ERROR";
  v6[643] = (__int64)"BD_CODO_REDEEM_INCREASE_TEAM_MEMBER_LIMIT_UNAVAILABLE_ITEM";
  v6[644] = (__int64)"BD_PLAYER_VOTE_REJECTED";
  v6[645] = (__int64)"BD_AMM_NOT_LOBBY_HOST";
  v6[646] = (__int64)"BD_AMM_NOT_PARTY_HOST";
  v6[647] = (__int64)"BD_AMM_NOT_LOBBY_MEMBER";
  v6[648] = (__int64)"BD_AMM_INVALID_MATCHMAKING_ID";
  v6[649] = (__int64)"BD_AMM_INVALID_LOBBY_ID";
  v6[650] = (__int64)"BD_AMM_SEARCH_IN_PROGRESS";
  v6[651] = (__int64)"BD_AMM_USER_ALREADY_MATCHMAKING";
  v6[652] = (__int64)"BD_AMM_INVALID_TOKEN";
  v6[653] = (__int64)"BD_AMM_INVALID_DOCUMENT_FORMAT";
  v6[654] = (__int64)"BD_AMM_PLAYER_INFO_UNAVAILABLE";
  v6[655] = (__int64)"BD_AMM_REQUEST_DESERIALIZATION_FAILED";
  v6[656] = (__int64)"BD_AMM_INVALID_QOS_TRANSACTION_ID";
  v6[657] = (__int64)"BD_AMM_INVALID_USER_ID_IN_GUEST_SLOTS";
  v6[658] = (__int64)"BD_AMM_NO_BUILD_NAME_SET";
  v6[659] = (__int64)"BD_AMM_LOBBY_MERGED";
  v6[660] = (__int64)"BD_AMM_BACKOFF_REQUESTED";
  v6[661] = (__int64)"BD_AMM_PLAYER_INFO_INCOMPATIBLE_BUILDS";
  v6[662] = (__int64)"BD_AMM_INVALID_DC_QOS_ADDRESS";
  v6[663] = (__int64)"BD_AMM_INVALID_PLAYER_INFO_DC_QOS_SETTINGS";
  v6[664] = (__int64)"BD_AMM_INVALID_PLAYER_INFO_LISTEN_SERVER_SETTINGS";
  v6[665] = (__int64)"BD_AMM_MIGRATION_NOT_PERMITTED";
  v6[666] = (__int64)"BD_AMM_INVALID_LOBBY_MEMBER_STATUS_TRANSITION";
  v6[667] = (__int64)"BD_AMM_LOBBY_MEMBER_STATUS_REPORTED_FOR_UNKNOWN_PLAYER";
  v6[668] = (__int64)"BD_AMM_DEDI_SHUTDOWN_NOT_PERMITTED";
  v6[669] = (__int64)"BD_AMM_INVALID_USER_ID_IN_PLAYER_RULESET_PAYLOADS";
  v6[670] = (__int64)"BD_AMM_INVALID_MAP_PACK";
  v6[671] = (__int64)"BD_AMM_TOURNAMENT_PLAYER_NOT_IN_TOURNAMENT";
  v6[672] = (__int64)"BD_AMM_TOURNAMENT_DUPLICATE_ACK_JOIN";
  v6[673] = (__int64)"BD_AMM_TOURNAMENT_INVALID_TOURNAMENT_STATUS";
  v6[674] = (__int64)"BD_AMM_TOURNAMENT_INVALID_TOURNAMENT_ID";
  v6[675] = (__int64)"BD_AMM_TOURNAMENT_LOBBY_NOT_IN_ROUND";
  v6[676] = (__int64)"BD_AMM_TOURNAMENT_TEAM_NOT_IN_MATCH";
  v6[677] = (__int64)"BD_AMM_TOURNAMENT_PLAYER_NOT_IN_ROUND";
  v6[678] = (__int64)"BD_AMM_TOURNAMENT_INVALID_LOBBY_DOC";
  v6[679] = (__int64)"BD_AMM_TOURNAMENT_ELIMINATED_PLAYER";
  v6[680] = (__int64)"BD_AMM_TOURNAMENT_LOBBY_ID_NOT_IN_TOURNAMENT";
  v6[681] = (__int64)"BD_AMM_TOURNAMENT_MATCH_ALREADY_HAS_RESULT";
  v6[682] = (__int64)"BD_AMM_TOURNAMENT_MATCH_IN_PROGRESS";
  v6[683] = (__int64)"BD_AMM_TOURNAMENT_FULL";
  v6[684] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_UNKNOWN_ERROR";
  v6[685] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_SELF_FRIENDSHIP_NOT_ALLOWED";
  v6[686] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_CALLER_FRIENDS_LIST_FULL";
  v6[687] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_OTHER_PLAYER_FRIENDS_LIST_FULL";
  v6[688] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_CALLER_OUTGOING_FRIEND_REQUESTS_FULL";
  v6[689] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_OTHER_PLAYER_INCOMING_FRIEND_REQUESTS_FULL";
  v6[690] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_INVALID_PAGE_TOKEN";
  v6[691] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_FRIENDSHIP_ALREADY_EXISTS";
  v6[692] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_INVITE_ALREADY_EXISTS";
  v6[693] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_BACKEND_UNAVAILABLE_ERROR";
  v6[694] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_INVITED_USER_IS_BLOCKED";
  v6[695] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_CALLER_IS_BLOCKED";
  v6[696] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_BLOCKED_USER_LIST_FULL";
  v6[697] = (__int64)"BD_CROSS_PLATFORM_FRIENDS_USER_IS_ALREADY_BLOCKED";
  v6[698] = (__int64)"BD_CROSS_PLATFORM_USERLISTS_UNKNOWN_ERROR";
  v6[699] = (__int64)"BD_CROSS_PLATFORM_USERLISTS_LIST_DOES_NOT_EXIST";
  v6[700] = (__int64)"BD_CROSS_PLATFORM_USERLISTS_LIST_ALREADY_EXISTS";
  v6[701] = (__int64)"BD_CROSS_PLATFORM_USERLISTS_INVALID_PAGE_TOKEN";
  v6[702] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_UNKNOWN_ERROR";
  v6[703] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_INVALID_PAGE_TOKEN";
  v6[704] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_SUBSCRIPTIONS_LIST_FULL";
  v6[705] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_SUBSCRIBERS_LIST_FULL";
  v6[706] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_INVALID_MAXIMUM_PAGE_SIZE";
  v6[707] = (__int64)"BD_CROSS_PLATFORM_PRESENCE_EXCEEDED_MAX_USERS_IN_REQUEST";
  v6[708] = (__int64)"BD_CROSS_TITLE_LOCALIZED_STRINGS_UNKNOWN_ERROR";
  v6[709] = (__int64)"BD_CROSS_TITLE_LOCALIZED_STRINGS_STRING_SET_DOES_NOT_EXIST_ERROR";
  v6[710] = (__int64)"BD_CROSS_TITLE_LOCALIZED_STRINGS_INVALID_FORMAT_STRING_ERROR";
  v6[711] = (__int64)"BD_CROSS_TITLE_LOCALIZED_STRINGS_INVALID_STRING_REF_ERROR";
  v6[712] = (__int64)"BD_CROSS_TITLE_LOCALIZED_STRINGS_NOT_ENOUGH_STRING_REFS_ERROR";
  v6[713] = (__int64)"BD_OBJECTSTORE_PROXY_OBJECT_NOT_FOUND";
  v6[714] = (__int64)"BD_OBJECTSTORE_PROXY_INVALID_ACCESS";
  v6[715] = (__int64)"BD_OBJECTSTORE_PROXY_SERVICE_UNAVAILABLE";
  v6[716] = (__int64)"BD_OBJECTSTORE_PROXY_OBJECT_TOO_BIG_FOR_REMAINING_SIZE_WINDOW_SPACE_ERROR";
  v6[717] = (__int64)"BD_OBJECTSTORE_PROXY_OBJECT_TOO_BIG_FOR_SIZE_WINDOW_ERROR";
  v6[718] = (__int64)"BD_OBJECTSTORE_HTTP_ERROR";
  v6[719] = (__int64)"BD_OBJECTSTORE_FAILED_TO_START_HTTP";
  v6[720] = (__int64)"BD_AB_TESTING_OBJECT_NOT_FOUND";
  v6[721] = (__int64)"BD_AB_TESTING_INVALID_ACCESS";
  v6[722] = (__int64)"BD_AB_TESTING_SERVICE_UNAVAILABLE";
  v6[723] = (__int64)"BD_REST_ERROR_TEMPORARY_REDIRECT";
  v6[724] = (__int64)"BD_REST_ERROR_PERMANENT_REDIRECT";
  v6[725] = (__int64)"BD_REST_ERROR_NOT_MODIFIED";
  v6[726] = (__int64)"BD_REST_ERROR_BAD_REQUEST";
  v2 = "Unknown bdLobbyErrorCode";
  v3 = 0;
  v6[727] = (__int64)"BD_REST_ERROR_UNAUTHORIZED";
  v4 = 0i64;
  v6[728] = (__int64)"BD_REST_ERROR_FORBIDDEN";
  v6[729] = (__int64)"BD_REST_ERROR_NOT_FOUND";
  v6[730] = (__int64)"BD_REST_ERROR_METHOD_NOT_ALLOWED";
  v6[731] = (__int64)"BD_REST_ERROR_NOT_ACCEPTABLE";
  v6[732] = (__int64)"BD_REST_ERROR_REQUEST_TIMEOUT";
  v6[733] = (__int64)"BD_REST_ERROR_CONFLICT";
  v6[734] = (__int64)"BD_REST_ERROR_PRECONDITION_FAILED";
  v6[735] = (__int64)"BD_REST_ERROR_PAYLOAD_TOO_LARGE";
  v6[736] = (__int64)"BD_REST_ERROR_REQUEST_URI_TOO_LONG";
  v6[737] = (__int64)"BD_REST_ERROR_REQUESTED_RANGE_NOT_SATISFIABLE";
  v6[738] = (__int64)"BD_REST_ERROR_INTERNAL_SERVER_ERROR";
  v6[739] = (__int64)"BD_REST_ERROR_BAD_GATEWAY";
  v6[740] = (__int64)"BD_REST_ERROR_SERVICE_UNAVAILABLE";
  v6[741] = (__int64)"BD_REST_ERROR_GATEWAY_TIMEOUT";
  v6[742] = (__int64)"BD_REST_ERROR_REQUEST_CANCELLED";
  v6[743] = (__int64)"BD_LOGIN_UNKOWN_ERROR";
  v6[744] = (__int64)"BD_MAX_ERROR_CODE";
  do
  {
    if ( (unsigned int)v4 >= 0x2E9 )
      break;
    if ( v7[v4] == code )
    {
      v2 = (const char *)v6[v4];
      v3 = 1;
    }
    v4 = (unsigned int)(v4 + 1);
  }
  while ( !v3 );
  return v2;
}

/*
==============
bdLobbyService::cleanup
==============
*/
void bdLobbyService::cleanup(bdLobbyService *this)
{
  bdRESTTaskManager *m_restTaskManager; 
  bdRemoteTaskManager *m_taskManager; 
  unsigned int v4; 
  unsigned int m_capacity; 
  __int64 v6; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **m_map; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v8; 
  unsigned int v9; 
  unsigned int v10; 
  __int64 v11; 
  bdProfiles *m_profiles; 
  bdMessaging *m_messaging; 
  unsigned int v14; 
  unsigned int v15; 
  __int64 v16; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v17; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v18; 
  bdMatchMaking *m_data; 
  unsigned int v20; 
  unsigned int v21; 
  __int64 v22; 
  bdStats *m_statsManager; 
  bdTitleUtilities *m_titleUtilitiesManager; 
  bdEventLog *m_eventLogManager; 
  bdKeyArchive *m_keyArchive; 
  bdCounter *m_counter; 
  bdGroup *m_group; 
  bdContentStreaming *m_contentStreamingManager; 
  bdPooledStorage *m_pooledStorageManager; 
  bdTags *m_tags; 
  bdVoteRank *m_voteRankManager; 
  bdAntiCheat *m_antiCheat; 
  bdDML *m_DML; 
  bdObjectStore *m_objectStore; 
  bdAchievementsEngineService *m_achievementsEngineService; 
  _BYTE *v37; 
  unsigned __int64 v38; 
  bdAchievementClient *m_achievementsEngineClientService; 
  bdABTesting *m_abTesting; 
  bdLootGeneration *m_lootGeneration; 
  bdMW4Service *m_mw4Service; 
  bdUserLogoffRecordsService *m_reportLogoffService; 
  bdCrossPlatformFriends *m_crossPlatformFriends; 
  bdCrossTitleLocalizedStrings *m_crossTitleLocalizedStrings; 
  bdCrossPlatformUserLists *m_crossPlatformUserLists; 
  bdCrossPlatformPresence *m_crossPlatformPresence; 
  bdCrossPlatformIdentity *m_crossPlatformIdentity; 
  bdRegulations *m_regulations; 
  bdUmbrella *m_umbrella; 
  bdUno *m_uno; 
  bdFeatureBan *m_featureBan; 
  bdTencent *m_tencent; 
  bdCODO *m_CODO; 
  bdCODOTeamMarketplace *m_CODOTeamMarketplace; 
  bdRelayService *m_relayService; 
  bdDDL *m_DDL; 
  bdServerInventory *m_serverInventory; 
  bdMatchScheduler *m_matchScheduler; 
  bdMLG *m_mlg; 
  unsigned int v61; 
  unsigned int v62; 
  __int64 v63; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v64; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v65; 
  bdRedeemableCodeService *v66; 
  unsigned int v67; 
  unsigned int v68; 
  __int64 v69; 
  unsigned int v70; 
  unsigned int v71; 
  __int64 v72; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v73; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v74; 
  bdMarketingComms *v75; 
  unsigned int v76; 
  unsigned int v77; 
  __int64 v78; 
  unsigned int v79; 
  unsigned int v80; 
  __int64 v81; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v82; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v83; 
  bdMarketplace *v84; 
  unsigned int v85; 
  unsigned int v86; 
  __int64 v87; 
  unsigned int v88; 
  unsigned int v89; 
  __int64 v90; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v91; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v92; 
  bdReward *v93; 
  unsigned int v94; 
  unsigned int v95; 
  __int64 v96; 
  unsigned int v97; 
  unsigned int v98; 
  __int64 v99; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v100; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v101; 
  unsigned int v102; 
  unsigned int v103; 
  __int64 v104; 
  unsigned int v105; 
  unsigned int v106; 
  __int64 v107; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v108; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v109; 
  unsigned int v110; 
  unsigned int v111; 
  __int64 v112; 
  unsigned int v113; 
  unsigned int v114; 
  __int64 v115; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v116; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v117; 
  unsigned int v118; 
  unsigned int v119; 
  __int64 v120; 
  unsigned int v121; 
  unsigned int v122; 
  __int64 v123; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v124; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v125; 
  unsigned int v126; 
  unsigned int v127; 
  __int64 v128; 
  unsigned int v129; 
  unsigned int v130; 
  __int64 v131; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v132; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v133; 
  bdPublisherVariables *v134; 
  unsigned int v135; 
  unsigned int v136; 
  __int64 v137; 
  unsigned int v138; 
  unsigned int v139; 
  __int64 v140; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v141; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v142; 
  bdRichPresenceService *v143; 
  unsigned int v144; 
  unsigned int v145; 
  __int64 v146; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection *v148; 

  m_restTaskManager = this->m_restTaskManager;
  if ( m_restTaskManager )
  {
    bdRESTTaskManager::~bdRESTTaskManager(this->m_restTaskManager);
    bdMemory::deallocate(m_restTaskManager);
    this->m_restTaskManager = NULL;
  }
  m_taskManager = this->m_taskManager;
  if ( m_taskManager )
  {
    ((void (__fastcall *)(bdRemoteTaskManager *, __int64))m_taskManager->~bdRemoteTaskManager)(m_taskManager, 1i64);
    this->m_taskManager = NULL;
  }
  if ( this->m_services.m_size )
  {
    v4 = 0;
    m_capacity = this->m_services.m_capacity;
    if ( m_capacity )
    {
      do
      {
        if ( this->m_services.m_map[v4] )
          break;
        ++v4;
      }
      while ( v4 < m_capacity );
    }
    v6 = v4;
    m_map = this->m_services.m_map;
    if ( m_map[v6] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_services.m_numIterators, 1u);
      m_map = this->m_services.m_map;
    }
    v8 = m_map[v6];
LABEL_12:
    if ( v8 )
    {
      while ( 1 )
      {
        if ( v8->m_data )
          ((void (__fastcall *)(bdService *, __int64))v8->m_data->~bdService)(v8->m_data, 1i64);
        if ( v8->m_next )
        {
          v8 = v8->m_next;
          goto LABEL_12;
        }
        v9 = bdHashingClass::getHash<bdString>(&this->m_services.m_hashClass, &v8->m_key);
        v10 = this->m_services.m_capacity;
        v11 = (v9 & (v10 - 1)) + 1;
        if ( (unsigned int)v11 >= v10 )
          break;
        while ( 1 )
        {
          v8 = this->m_services.m_map[v11];
          if ( v8 )
            break;
          v11 = (unsigned int)(v11 + 1);
          if ( (unsigned int)v11 >= v10 )
            goto LABEL_20;
        }
      }
LABEL_20:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_services.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdService *,bdHashingClass>::clear(&this->m_services);
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::clear(&this->m_pushHandlers);
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear(&this->m_demonataPushHandlers);
  m_profiles = this->m_profiles;
  if ( m_profiles )
  {
    bdProfiles::~bdProfiles(this->m_profiles);
    bdMemory::deallocate(m_profiles);
    this->m_profiles = NULL;
  }
  m_messaging = this->m_messaging;
  if ( m_messaging )
  {
    bdMessaging::~bdMessaging(this->m_messaging);
    bdMemory::deallocate(m_messaging);
    this->m_messaging = NULL;
  }
  if ( this->m_matchmakings.m_size )
  {
    v14 = 0;
    v15 = this->m_matchmakings.m_capacity;
    if ( v15 )
    {
      do
      {
        if ( this->m_matchmakings.m_map[v14] )
          break;
        ++v14;
      }
      while ( v14 < v15 );
    }
    v16 = v14;
    v17 = this->m_matchmakings.m_map;
    if ( v17[v16] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_matchmakings.m_numIterators, 1u);
      v17 = this->m_matchmakings.m_map;
    }
    v18 = v17[v16];
LABEL_32:
    if ( v18 )
    {
      while ( 1 )
      {
        m_data = v18->m_data;
        if ( v18->m_data )
        {
          bdMatchMaking::~bdMatchMaking(v18->m_data);
          bdMemory::deallocate(m_data);
        }
        if ( v18->m_next )
        {
          v18 = v18->m_next;
          goto LABEL_32;
        }
        v20 = bdHashingClass::getHash<bdString>(&this->m_matchmakings.m_hashClass, &v18->m_key);
        v21 = this->m_matchmakings.m_capacity;
        v22 = (v20 & (v21 - 1)) + 1;
        if ( (unsigned int)v22 >= v21 )
          break;
        while ( 1 )
        {
          v18 = this->m_matchmakings.m_map[v22];
          if ( v18 )
            break;
          v22 = (unsigned int)(v22 + 1);
          if ( (unsigned int)v22 >= v21 )
            goto LABEL_40;
        }
      }
LABEL_40:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_matchmakings.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear(&this->m_matchmakings);
  m_statsManager = this->m_statsManager;
  if ( m_statsManager )
  {
    bdStats::~bdStats(this->m_statsManager);
    bdMemory::deallocate(m_statsManager);
    this->m_statsManager = NULL;
  }
  m_titleUtilitiesManager = this->m_titleUtilitiesManager;
  if ( m_titleUtilitiesManager )
  {
    ((void (__fastcall *)(bdTitleUtilities *, __int64))m_titleUtilitiesManager->~bdService)(m_titleUtilitiesManager, 1i64);
    this->m_titleUtilitiesManager = NULL;
  }
  m_eventLogManager = this->m_eventLogManager;
  if ( m_eventLogManager )
  {
    bdEventLog::~bdEventLog(this->m_eventLogManager);
    bdMemory::deallocate(m_eventLogManager);
    this->m_eventLogManager = NULL;
  }
  m_keyArchive = this->m_keyArchive;
  if ( m_keyArchive )
  {
    bdKeyArchive::~bdKeyArchive(this->m_keyArchive);
    bdMemory::deallocate(m_keyArchive);
    this->m_keyArchive = NULL;
  }
  m_counter = this->m_counter;
  if ( m_counter )
  {
    bdCounter::~bdCounter(this->m_counter);
    bdMemory::deallocate(m_counter);
    this->m_counter = NULL;
  }
  m_group = this->m_group;
  if ( m_group )
  {
    bdGroup::~bdGroup(this->m_group);
    bdMemory::deallocate(m_group);
    this->m_group = NULL;
  }
  m_contentStreamingManager = this->m_contentStreamingManager;
  if ( m_contentStreamingManager )
  {
    ((void (__fastcall *)(bdContentStreaming *, __int64))m_contentStreamingManager->~bdContentStreamingBase)(m_contentStreamingManager, 1i64);
    this->m_contentStreamingManager = NULL;
  }
  m_pooledStorageManager = this->m_pooledStorageManager;
  if ( m_pooledStorageManager )
  {
    ((void (__fastcall *)(bdPooledStorage *, __int64))m_pooledStorageManager->~bdContentStreamingBase)(m_pooledStorageManager, 1i64);
    this->m_pooledStorageManager = NULL;
  }
  m_tags = this->m_tags;
  if ( m_tags )
  {
    bdTags::~bdTags(this->m_tags);
    bdMemory::deallocate(m_tags);
    this->m_tags = NULL;
  }
  m_voteRankManager = this->m_voteRankManager;
  if ( m_voteRankManager )
  {
    bdVoteRank::~bdVoteRank(this->m_voteRankManager);
    bdMemory::deallocate(m_voteRankManager);
    this->m_voteRankManager = NULL;
  }
  m_antiCheat = this->m_antiCheat;
  if ( m_antiCheat )
  {
    bdAntiCheat::~bdAntiCheat(this->m_antiCheat);
    bdMemory::deallocate(m_antiCheat);
    this->m_antiCheat = NULL;
  }
  m_DML = this->m_DML;
  if ( m_DML )
  {
    bdDML::~bdDML(this->m_DML);
    bdMemory::deallocate(m_DML);
    this->m_DML = NULL;
  }
  m_objectStore = this->m_objectStore;
  if ( m_objectStore )
  {
    bdObjectStore::~bdObjectStore(this->m_objectStore);
    bdMemory::deallocate(m_objectStore);
    this->m_objectStore = NULL;
  }
  m_achievementsEngineService = this->m_achievementsEngineService;
  if ( m_achievementsEngineService )
  {
    v37 = memchr_0(&m_achievementsEngineService->m_abTestingToken, 0, 0x1001ui64);
    v38 = 4097i64;
    if ( v37 )
      v38 = v37 - (_BYTE *)&m_achievementsEngineService->m_abTestingToken;
    bdHandleAssert(v38 < 0x1001, "bdStrnlen(m_buffer, BufferSize) < BufferSize", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbycommon\\bdstructfixedsizestring.inl", "bdStructFixedSizeString<4096>::~bdStructFixedSizeString", 0x1Fu, "Buffer overrun detected", -2i64);
    bdRESTResponse::~bdRESTResponse(&m_achievementsEngineService->m_reportEventsResponse);
    bdRESTResponse::~bdRESTResponse(&m_achievementsEngineService->m_responseDummy);
    bdMemory::deallocate(m_achievementsEngineService);
    this->m_achievementsEngineService = NULL;
  }
  m_achievementsEngineClientService = this->m_achievementsEngineClientService;
  if ( m_achievementsEngineClientService )
  {
    bdAchievementClient::~bdAchievementClient(this->m_achievementsEngineClientService);
    bdMemory::deallocate(m_achievementsEngineClientService);
    this->m_achievementsEngineClientService = NULL;
  }
  m_abTesting = this->m_abTesting;
  if ( m_abTesting )
  {
    bdABTesting::~bdABTesting(this->m_abTesting);
    bdMemory::deallocate(m_abTesting);
    this->m_abTesting = NULL;
  }
  m_lootGeneration = this->m_lootGeneration;
  if ( m_lootGeneration )
  {
    bdLootGeneration::~bdLootGeneration(this->m_lootGeneration);
    bdMemory::deallocate(m_lootGeneration);
    this->m_lootGeneration = NULL;
  }
  m_mw4Service = this->m_mw4Service;
  if ( m_mw4Service )
  {
    bdMemory::deallocate(m_mw4Service);
    this->m_mw4Service = NULL;
  }
  m_reportLogoffService = this->m_reportLogoffService;
  if ( m_reportLogoffService )
  {
    bdMemory::deallocate(m_reportLogoffService);
    this->m_reportLogoffService = NULL;
  }
  m_crossPlatformFriends = this->m_crossPlatformFriends;
  if ( m_crossPlatformFriends )
  {
    bdMemory::deallocate(m_crossPlatformFriends);
    this->m_crossPlatformFriends = NULL;
  }
  m_crossTitleLocalizedStrings = this->m_crossTitleLocalizedStrings;
  if ( m_crossTitleLocalizedStrings )
  {
    bdMemory::deallocate(m_crossTitleLocalizedStrings);
    this->m_crossTitleLocalizedStrings = NULL;
  }
  m_crossPlatformUserLists = this->m_crossPlatformUserLists;
  if ( m_crossPlatformUserLists )
  {
    bdMemory::deallocate(m_crossPlatformUserLists);
    this->m_crossPlatformUserLists = NULL;
  }
  m_crossPlatformPresence = this->m_crossPlatformPresence;
  if ( m_crossPlatformPresence )
  {
    bdMemory::deallocate(m_crossPlatformPresence);
    this->m_crossPlatformPresence = NULL;
  }
  m_crossPlatformIdentity = this->m_crossPlatformIdentity;
  if ( m_crossPlatformIdentity )
  {
    bdMemory::deallocate(m_crossPlatformIdentity);
    this->m_crossPlatformIdentity = NULL;
  }
  m_regulations = this->m_regulations;
  if ( m_regulations )
  {
    bdMemory::deallocate(m_regulations);
    this->m_regulations = NULL;
  }
  m_umbrella = this->m_umbrella;
  if ( m_umbrella )
  {
    ((void (__fastcall *)(bdUmbrella *, __int64))m_umbrella->~bdSingleIdentityBase)(m_umbrella, 1i64);
    this->m_umbrella = NULL;
  }
  m_uno = this->m_uno;
  if ( m_uno )
  {
    ((void (__fastcall *)(bdUno *, __int64))m_uno->~bdSingleIdentityBase)(m_uno, 1i64);
    this->m_uno = NULL;
  }
  m_featureBan = this->m_featureBan;
  if ( m_featureBan )
  {
    bdFeatureBan::~bdFeatureBan(this->m_featureBan);
    bdMemory::deallocate(m_featureBan);
    this->m_featureBan = NULL;
  }
  m_tencent = this->m_tencent;
  if ( m_tencent )
  {
    bdTencent::~bdTencent(this->m_tencent);
    bdMemory::deallocate(m_tencent);
    this->m_tencent = NULL;
  }
  m_CODO = this->m_CODO;
  if ( m_CODO )
  {
    ((void (__fastcall *)(bdCODO *, __int64))m_CODO->~bdCODO)(m_CODO, 1i64);
    this->m_CODO = NULL;
  }
  m_CODOTeamMarketplace = this->m_CODOTeamMarketplace;
  if ( m_CODOTeamMarketplace )
  {
    bdMemory::deallocate(m_CODOTeamMarketplace);
    this->m_CODOTeamMarketplace = NULL;
  }
  m_relayService = this->m_relayService;
  if ( m_relayService )
  {
    bdRelayService::~bdRelayService(this->m_relayService);
    bdMemory::deallocate(m_relayService);
    this->m_relayService = NULL;
  }
  m_DDL = this->m_DDL;
  if ( m_DDL )
  {
    bdDDL::~bdDDL(this->m_DDL);
    bdMemory::deallocate(m_DDL);
    this->m_DDL = NULL;
  }
  m_serverInventory = this->m_serverInventory;
  if ( m_serverInventory )
  {
    ((void (__fastcall *)(bdServerInventory *, __int64))m_serverInventory->~bdService)(m_serverInventory, 1i64);
    this->m_serverInventory = NULL;
  }
  m_matchScheduler = this->m_matchScheduler;
  if ( m_matchScheduler )
  {
    bdMatchScheduler::~bdMatchScheduler(this->m_matchScheduler);
    bdMemory::deallocate(m_matchScheduler);
    this->m_matchScheduler = NULL;
  }
  m_mlg = this->m_mlg;
  if ( m_mlg )
  {
    bdMLG::~bdMLG(this->m_mlg);
    bdMemory::deallocate(m_mlg);
    this->m_mlg = NULL;
  }
  if ( this->m_redeemableCodeServiceManagers.m_size )
  {
    v61 = 0;
    v62 = this->m_redeemableCodeServiceManagers.m_capacity;
    if ( v62 )
    {
      do
      {
        if ( this->m_redeemableCodeServiceManagers.m_map[v61] )
          break;
        ++v61;
      }
      while ( v61 < v62 );
    }
    v63 = v61;
    v64 = this->m_redeemableCodeServiceManagers.m_map;
    if ( v64[v63] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_redeemableCodeServiceManagers.m_numIterators, 1u);
      v64 = this->m_redeemableCodeServiceManagers.m_map;
    }
    v65 = v64[v63];
LABEL_122:
    if ( v65 )
    {
      while ( 1 )
      {
        v66 = v65->m_data;
        if ( v65->m_data )
        {
          bdRedeemableCodeService::~bdRedeemableCodeService(v65->m_data);
          bdMemory::deallocate(v66);
        }
        if ( v65->m_next )
        {
          v65 = v65->m_next;
          goto LABEL_122;
        }
        v67 = bdHashingClass::getHash<bdString>(&this->m_redeemableCodeServiceManagers.m_hashClass, &v65->m_key);
        v68 = this->m_redeemableCodeServiceManagers.m_capacity;
        v69 = (v67 & (v68 - 1)) + 1;
        if ( (unsigned int)v69 >= v68 )
          break;
        while ( 1 )
        {
          v65 = this->m_redeemableCodeServiceManagers.m_map[v69];
          if ( v65 )
            break;
          v69 = (unsigned int)(v69 + 1);
          if ( (unsigned int)v69 >= v68 )
            goto LABEL_130;
        }
      }
LABEL_130:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_redeemableCodeServiceManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear(&this->m_redeemableCodeServiceManagers);
  if ( this->m_marketingCommsManagers.m_size )
  {
    v70 = 0;
    v71 = this->m_marketingCommsManagers.m_capacity;
    if ( v71 )
    {
      do
      {
        if ( this->m_marketingCommsManagers.m_map[v70] )
          break;
        ++v70;
      }
      while ( v70 < v71 );
    }
    v72 = v70;
    v73 = this->m_marketingCommsManagers.m_map;
    if ( v73[v72] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 1u);
      v73 = this->m_marketingCommsManagers.m_map;
    }
    v74 = v73[v72];
LABEL_138:
    if ( v74 )
    {
      while ( 1 )
      {
        v75 = v74->m_data;
        if ( v74->m_data )
        {
          bdMarketingComms::~bdMarketingComms(v74->m_data);
          bdMemory::deallocate(v75);
        }
        if ( v74->m_next )
        {
          v74 = v74->m_next;
          goto LABEL_138;
        }
        v76 = bdHashingClass::getHash<bdString>(&this->m_marketingCommsManagers.m_hashClass, &v74->m_key);
        v77 = this->m_marketingCommsManagers.m_capacity;
        v78 = (v76 & (v77 - 1)) + 1;
        if ( (unsigned int)v78 >= v77 )
          break;
        while ( 1 )
        {
          v74 = this->m_marketingCommsManagers.m_map[v78];
          if ( v74 )
            break;
          v78 = (unsigned int)(v78 + 1);
          if ( (unsigned int)v78 >= v77 )
            goto LABEL_146;
        }
      }
LABEL_146:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear(&this->m_marketingCommsManagers);
  if ( this->m_marketplaceManagers.m_size )
  {
    v79 = 0;
    v80 = this->m_marketplaceManagers.m_capacity;
    if ( v80 )
    {
      do
      {
        if ( this->m_marketplaceManagers.m_map[v79] )
          break;
        ++v79;
      }
      while ( v79 < v80 );
    }
    v81 = v79;
    v82 = this->m_marketplaceManagers.m_map;
    if ( v82[v81] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketplaceManagers.m_numIterators, 1u);
      v82 = this->m_marketplaceManagers.m_map;
    }
    v83 = v82[v81];
LABEL_154:
    if ( v83 )
    {
      while ( 1 )
      {
        v84 = v83->m_data;
        if ( v83->m_data )
        {
          bdMarketplace::~bdMarketplace(v83->m_data);
          bdMemory::deallocate(v84);
        }
        if ( v83->m_next )
        {
          v83 = v83->m_next;
          goto LABEL_154;
        }
        v85 = bdHashingClass::getHash<bdString>(&this->m_marketplaceManagers.m_hashClass, &v83->m_key);
        v86 = this->m_marketplaceManagers.m_capacity;
        v87 = (v85 & (v86 - 1)) + 1;
        if ( (unsigned int)v87 >= v86 )
          break;
        while ( 1 )
        {
          v83 = this->m_marketplaceManagers.m_map[v87];
          if ( v83 )
            break;
          v87 = (unsigned int)(v87 + 1);
          if ( (unsigned int)v87 >= v86 )
            goto LABEL_162;
        }
      }
LABEL_162:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketplaceManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear(&this->m_marketplaceManagers);
  if ( this->m_rewardManagers.m_size )
  {
    v88 = 0;
    v89 = this->m_rewardManagers.m_capacity;
    if ( v89 )
    {
      do
      {
        if ( this->m_rewardManagers.m_map[v88] )
          break;
        ++v88;
      }
      while ( v88 < v89 );
    }
    v90 = v88;
    v91 = this->m_rewardManagers.m_map;
    if ( v91[v90] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_rewardManagers.m_numIterators, 1u);
      v91 = this->m_rewardManagers.m_map;
    }
    v92 = v91[v90];
LABEL_170:
    if ( v92 )
    {
      while ( 1 )
      {
        v93 = v92->m_data;
        if ( v92->m_data )
        {
          bdReward::~bdReward(v92->m_data);
          bdMemory::deallocate(v93);
        }
        if ( v92->m_next )
        {
          v92 = v92->m_next;
          goto LABEL_170;
        }
        v94 = bdHashingClass::getHash<bdString>(&this->m_rewardManagers.m_hashClass, &v92->m_key);
        v95 = this->m_rewardManagers.m_capacity;
        v96 = (v94 & (v95 - 1)) + 1;
        if ( (unsigned int)v96 >= v95 )
          break;
        while ( 1 )
        {
          v92 = this->m_rewardManagers.m_map[v96];
          if ( v92 )
            break;
          v96 = (unsigned int)(v96 + 1);
          if ( (unsigned int)v96 >= v95 )
            goto LABEL_178;
        }
      }
LABEL_178:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_rewardManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdReward *,bdHashingClass>::clear(&this->m_rewardManagers);
  if ( this->m_storageManagers.m_size )
  {
    v97 = 0;
    v98 = this->m_storageManagers.m_capacity;
    if ( v98 )
    {
      do
      {
        if ( this->m_storageManagers.m_map[v97] )
          break;
        ++v97;
      }
      while ( v97 < v98 );
    }
    v99 = v97;
    v100 = this->m_storageManagers.m_map;
    if ( v100[v99] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_storageManagers.m_numIterators, 1u);
      v100 = this->m_storageManagers.m_map;
    }
    v101 = v100[v99];
LABEL_186:
    if ( v101 )
    {
      while ( 1 )
      {
        if ( v101->m_data )
          ((void (__fastcall *)(bdStorage *, __int64))v101->m_data->~bdStorage)(v101->m_data, 1i64);
        if ( v101->m_next )
        {
          v101 = v101->m_next;
          goto LABEL_186;
        }
        v102 = bdHashingClass::getHash<bdString>(&this->m_storageManagers.m_hashClass, &v101->m_key);
        v103 = this->m_storageManagers.m_capacity;
        v104 = (v102 & (v103 - 1)) + 1;
        if ( (unsigned int)v104 >= v103 )
          break;
        while ( 1 )
        {
          v101 = this->m_storageManagers.m_map[v104];
          if ( v101 )
            break;
          v104 = (unsigned int)(v104 + 1);
          if ( (unsigned int)v104 >= v103 )
            goto LABEL_194;
        }
      }
LABEL_194:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_storageManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdStorage *,bdHashingClass>::clear(&this->m_storageManagers);
  if ( this->m_teamsManagers.m_size )
  {
    v105 = 0;
    v106 = this->m_teamsManagers.m_capacity;
    if ( v106 )
    {
      do
      {
        if ( this->m_teamsManagers.m_map[v105] )
          break;
        ++v105;
      }
      while ( v105 < v106 );
    }
    v107 = v105;
    v108 = this->m_teamsManagers.m_map;
    if ( v108[v107] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamsManagers.m_numIterators, 1u);
      v108 = this->m_teamsManagers.m_map;
    }
    v109 = v108[v107];
LABEL_202:
    if ( v109 )
    {
      while ( 1 )
      {
        if ( v109->m_data )
          ((void (__fastcall *)(bdTeams *, __int64))v109->m_data->~bdTeams)(v109->m_data, 1i64);
        if ( v109->m_next )
        {
          v109 = v109->m_next;
          goto LABEL_202;
        }
        v110 = bdHashingClass::getHash<bdString>(&this->m_teamsManagers.m_hashClass, &v109->m_key);
        v111 = this->m_teamsManagers.m_capacity;
        v112 = (v110 & (v111 - 1)) + 1;
        if ( (unsigned int)v112 >= v111 )
          break;
        while ( 1 )
        {
          v109 = this->m_teamsManagers.m_map[v112];
          if ( v109 )
            break;
          v112 = (unsigned int)(v112 + 1);
          if ( (unsigned int)v112 >= v111 )
            goto LABEL_210;
        }
      }
LABEL_210:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamsManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdTeams *,bdHashingClass>::clear(&this->m_teamsManagers);
  if ( this->m_teamShowcaseManagers.m_size )
  {
    v113 = 0;
    v114 = this->m_teamShowcaseManagers.m_capacity;
    if ( v114 )
    {
      do
      {
        if ( this->m_teamShowcaseManagers.m_map[v113] )
          break;
        ++v113;
      }
      while ( v113 < v114 );
    }
    v115 = v113;
    v116 = this->m_teamShowcaseManagers.m_map;
    if ( v116[v115] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamShowcaseManagers.m_numIterators, 1u);
      v116 = this->m_teamShowcaseManagers.m_map;
    }
    v117 = v116[v115];
LABEL_218:
    if ( v117 )
    {
      while ( 1 )
      {
        if ( v117->m_data )
          ((void (__fastcall *)(bdTeamShowcase *, __int64))v117->m_data->~bdTeamShowcase)(v117->m_data, 1i64);
        if ( v117->m_next )
        {
          v117 = v117->m_next;
          goto LABEL_218;
        }
        v118 = bdHashingClass::getHash<bdString>(&this->m_teamShowcaseManagers.m_hashClass, &v117->m_key);
        v119 = this->m_teamShowcaseManagers.m_capacity;
        v120 = (v118 & (v119 - 1)) + 1;
        if ( (unsigned int)v120 >= v119 )
          break;
        while ( 1 )
        {
          v117 = this->m_teamShowcaseManagers.m_map[v120];
          if ( v117 )
            break;
          v120 = (unsigned int)(v120 + 1);
          if ( (unsigned int)v120 >= v119 )
            goto LABEL_226;
        }
      }
LABEL_226:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamShowcaseManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear(&this->m_teamShowcaseManagers);
  if ( this->m_mailManagers.m_size )
  {
    v121 = 0;
    v122 = this->m_mailManagers.m_capacity;
    if ( v122 )
    {
      do
      {
        if ( this->m_mailManagers.m_map[v121] )
          break;
        ++v121;
      }
      while ( v121 < v122 );
    }
    v123 = v121;
    v124 = this->m_mailManagers.m_map;
    if ( v124[v123] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_mailManagers.m_numIterators, 1u);
      v124 = this->m_mailManagers.m_map;
    }
    v125 = v124[v123];
LABEL_234:
    if ( v125 )
    {
      while ( 1 )
      {
        if ( v125->m_data )
          ((void (__fastcall *)(bdMail *, __int64))v125->m_data->~bdMail)(v125->m_data, 1i64);
        if ( v125->m_next )
        {
          v125 = v125->m_next;
          goto LABEL_234;
        }
        v126 = bdHashingClass::getHash<bdString>(&this->m_mailManagers.m_hashClass, &v125->m_key);
        v127 = this->m_mailManagers.m_capacity;
        v128 = (v126 & (v127 - 1)) + 1;
        if ( (unsigned int)v128 >= v127 )
          break;
        while ( 1 )
        {
          v125 = this->m_mailManagers.m_map[v128];
          if ( v125 )
            break;
          v128 = (unsigned int)(v128 + 1);
          if ( (unsigned int)v128 >= v127 )
            goto LABEL_242;
        }
      }
LABEL_242:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_mailManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdMail *,bdHashingClass>::clear(&this->m_mailManagers);
  if ( this->m_publisherVariablesManagers.m_size )
  {
    v129 = 0;
    v130 = this->m_publisherVariablesManagers.m_capacity;
    if ( v130 )
    {
      do
      {
        if ( this->m_publisherVariablesManagers.m_map[v129] )
          break;
        ++v129;
      }
      while ( v129 < v130 );
    }
    v131 = v129;
    v132 = this->m_publisherVariablesManagers.m_map;
    if ( v132[v131] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_publisherVariablesManagers.m_numIterators, 1u);
      v132 = this->m_publisherVariablesManagers.m_map;
    }
    v133 = v132[v131];
LABEL_250:
    if ( v133 )
    {
      while ( 1 )
      {
        v134 = v133->m_data;
        if ( v133->m_data )
        {
          bdPublisherVariables::~bdPublisherVariables(v133->m_data);
          bdMemory::deallocate(v134);
        }
        if ( v133->m_next )
        {
          v133 = v133->m_next;
          goto LABEL_250;
        }
        v135 = bdHashingClass::getHash<bdString>(&this->m_publisherVariablesManagers.m_hashClass, &v133->m_key);
        v136 = this->m_publisherVariablesManagers.m_capacity;
        v137 = (v135 & (v136 - 1)) + 1;
        if ( (unsigned int)v137 >= v136 )
          break;
        while ( 1 )
        {
          v133 = this->m_publisherVariablesManagers.m_map[v137];
          if ( v133 )
            break;
          v137 = (unsigned int)(v137 + 1);
          if ( (unsigned int)v137 >= v136 )
            goto LABEL_258;
        }
      }
LABEL_258:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_publisherVariablesManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear(&this->m_publisherVariablesManagers);
  if ( this->m_richPresenceManagers.m_size )
  {
    v138 = 0;
    v139 = this->m_richPresenceManagers.m_capacity;
    if ( v139 )
    {
      do
      {
        if ( this->m_richPresenceManagers.m_map[v138] )
          break;
        ++v138;
      }
      while ( v138 < v139 );
    }
    v140 = v138;
    v141 = this->m_richPresenceManagers.m_map;
    if ( v141[v140] )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_richPresenceManagers.m_numIterators, 1u);
      v141 = this->m_richPresenceManagers.m_map;
    }
    v142 = v141[v140];
LABEL_266:
    if ( v142 )
    {
      while ( 1 )
      {
        v143 = v142->m_data;
        if ( v142->m_data )
        {
          bdRichPresenceService::~bdRichPresenceService(v142->m_data);
          bdMemory::deallocate(v143);
        }
        if ( v142->m_next )
        {
          v142 = v142->m_next;
          goto LABEL_266;
        }
        v144 = bdHashingClass::getHash<bdString>(&this->m_richPresenceManagers.m_hashClass, &v142->m_key);
        v145 = this->m_richPresenceManagers.m_capacity;
        v146 = (v144 & (v145 - 1)) + 1;
        if ( (unsigned int)v146 >= v145 )
          break;
        while ( 1 )
        {
          v142 = this->m_richPresenceManagers.m_map[v146];
          if ( v142 )
            break;
          v146 = (unsigned int)(v146 + 1);
          if ( (unsigned int)v146 >= v145 )
            goto LABEL_274;
        }
      }
LABEL_274:
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_richPresenceManagers.m_numIterators, 0xFFFFFFFF);
    }
  }
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear(&this->m_richPresenceManagers);
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
    {
      v148 = this->m_lobbyConnection.m_ptr;
      if ( v148 )
        ((void (__fastcall *)(bdLobbyConnection *, __int64))v148->~bdReferencable)(v148, 1i64);
    }
  }
  this->m_lobbyConnection.m_ptr = NULL;
  this->m_lobbyConnectionEstablished = 0;
}

/*
==============
bdLobbyService::connect
==============
*/
bool bdLobbyService::connect(bdLobbyService *this, const bdAuthInfo *authInfo, const bool useEncryption)
{
  bdAddr *v6; 
  bdAddr v8; 

  if ( !this->m_isResolved )
    return 0;
  bdAddr::bdAddr(&v8, &this->m_resolvedLSGAddress);
  return bdLobbyService::connect(this, v6, authInfo, 0xFFFFui64, 0xFFFFui64, useEncryption);
}

/*
==============
bdLobbyService::connect
==============
*/
bool bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, void *__formal, unsigned __int64 sendBufSize, void *a6, unsigned __int64 recvBufSize, const bool useEncryption)
{
  bdAddr *v10; 
  bdAddr v12; 

  bdAddr::bdAddr(&v12, lobbyServiceAddr);
  return bdLobbyService::connect(this, v10, authInfo, sendBufSize, recvBufSize, useEncryption);
}

/*
==============
bdLobbyService::connect
==============
*/
bool bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, unsigned __int64 maxSendBufSize, unsigned __int64 maxRecvBufSize, const bool useEncryption)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection *v27; 
  bdAddr *v28; 
  bdLobbyConnection *v29; 
  bdLobbyConnection *v30; 
  bdLobbyConnection *v31; 
  bdLobbyConnection *v32; 
  bool v33; 
  bdLobbyConnection *v34; 
  bdTokenBucket *ThrottleBucket; 
  bdTokenBucket *v36; 
  bdTokenBucket *v37; 
  bdAddr v38; 

  _RDI = authInfo;
  _RBX = this;
  if ( authInfo )
  {
    m_ptr = this->m_lobbyConnection.m_ptr;
    if ( m_ptr )
    {
      bdLobbyConnection::disconnect(m_ptr);
      bdLobbyService::cleanup(_RBX);
    }
    _RBX->m_encryptedConnection = useEncryption;
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rbx+728h], xmm0
      vmovups xmm1, xmmword ptr [rdi+10h]
      vmovups xmmword ptr [rbx+738h], xmm1
      vmovups xmm0, xmmword ptr [rdi+20h]
      vmovups xmmword ptr [rbx+748h], xmm0
      vmovups xmm1, xmmword ptr [rdi+30h]
      vmovups xmmword ptr [rbx+758h], xmm1
      vmovups xmm0, xmmword ptr [rdi+40h]
      vmovups xmmword ptr [rbx+768h], xmm0
      vmovups xmm1, xmmword ptr [rdi+50h]
      vmovups xmmword ptr [rbx+778h], xmm1
      vmovups xmm0, xmmword ptr [rdi+60h]
      vmovups xmmword ptr [rbx+788h], xmm0
      vmovups xmm0, xmmword ptr [rdi+70h]
      vmovups xmmword ptr [rbx+798h], xmm0
      vmovups xmm1, xmmword ptr [rdi+80h]
      vmovups xmmword ptr [rbx+7A8h], xmm1
      vmovups xmm0, xmmword ptr [rdi+90h]
      vmovups xmmword ptr [rbx+7B8h], xmm0
      vmovups xmm1, xmmword ptr [rdi+0A0h]
      vmovups xmmword ptr [rbx+7C8h], xmm1
      vmovups xmm0, xmmword ptr [rdi+0B0h]
      vmovups xmmword ptr [rbx+7D8h], xmm0
      vmovups xmm1, xmmword ptr [rdi+0C0h]
      vmovups xmmword ptr [rbx+7E8h], xmm1
      vmovups xmm0, xmmword ptr [rdi+0D0h]
      vmovups xmmword ptr [rbx+7F8h], xmm0
      vmovups xmm1, xmmword ptr [rdi+0E0h]
      vmovups xmmword ptr [rbx+808h], xmm1
    }
    *(_QWORD *)&_RBX->m_authInfo.m_clientID[62] = *(_QWORD *)&_RDI->m_clientID[62];
    v27 = (bdLobbyConnection *)bdMemory::allocate(0x798ui64);
    if ( v27 )
    {
      bdAddr::bdAddr(&v38, lobbyServiceAddr);
      bdLobbyConnection::bdLobbyConnection(v27, v28, _RBX, 1, !useEncryption, maxSendBufSize, maxRecvBufSize);
      v30 = v29;
    }
    else
    {
      v30 = NULL;
    }
    v31 = _RBX->m_lobbyConnection.m_ptr;
    if ( v31 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)&v31->m_refCount, 0xFFFFFFFF) == 1 )
      {
        v32 = _RBX->m_lobbyConnection.m_ptr;
        if ( v32 )
          ((void (__fastcall *)(bdLobbyConnection *, __int64))v32->~bdReferencable)(v32, 1i64);
      }
    }
    _RBX->m_lobbyConnection.m_ptr = v30;
    if ( v30 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v30->m_refCount, 1u);
    _RBX->m_lobbyConnectionEstablished = 0;
    v33 = bdLobbyConnection::connect(_RBX->m_lobbyConnection.m_ptr, &_RBX->m_authInfo);
    v34 = _RBX->m_lobbyConnection.m_ptr;
    if ( v34 )
    {
      ThrottleBucket = bdLobbyConnection::getThrottleBucket(v34);
      bdTokenBucket::setTokensRestricted(ThrottleBucket, _RBX->m_uploadThrottled);
      v36 = bdLobbyConnection::getThrottleBucket(_RBX->m_lobbyConnection.m_ptr);
      bdTokenBucket::setRates(v36, _RBX->m_uploadThrottleBytesPerMs, _RBX->m_uploadThrottleBucketSize);
      v37 = bdLobbyConnection::getThrottleBucket(_RBX->m_lobbyConnection.m_ptr);
      bdTokenBucket::setMinFragment(v37, 0x258u);
      bdLobbyConnection::setTasksAreThrottled(_RBX->m_lobbyConnection.m_ptr, _RBX->m_markTasksThrottled);
    }
    return v33;
  }
  else
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::connect", 0xD5u, "No authentication info specified");
    return 0;
  }
}

/*
==============
bdLobbyService::connect
==============
*/
bool bdLobbyService::connect(bdLobbyService *this, bdAddr *lobbyServiceAddr, const bdAuthInfo *authInfo, const bool useEncryption)
{
  bdAddr *v7; 
  bdAddr v9; 

  this->m_isResolved = 1;
  bdAddr::bdAddr(&v9, lobbyServiceAddr);
  return bdLobbyService::connect(this, v7, authInfo, 0xFFFFui64, 0xFFFFui64, useEncryption);
}

/*
==============
bdLobbyService::deleteContentStreaming
==============
*/
void bdLobbyService::deleteContentStreaming(bdLobbyService *this)
{
  bdContentStreaming *m_contentStreamingManager; 

  m_contentStreamingManager = this->m_contentStreamingManager;
  if ( m_contentStreamingManager )
  {
    ((void (__fastcall *)(bdContentStreaming *, __int64))m_contentStreamingManager->~bdContentStreamingBase)(m_contentStreamingManager, 1i64);
    this->m_contentStreamingManager = NULL;
  }
}

/*
==============
bdLobbyService::deletePooledStorage
==============
*/
void bdLobbyService::deletePooledStorage(bdLobbyService *this)
{
  bdPooledStorage *m_pooledStorageManager; 

  m_pooledStorageManager = this->m_pooledStorageManager;
  if ( m_pooledStorageManager )
  {
    ((void (__fastcall *)(bdPooledStorage *, __int64))m_pooledStorageManager->~bdContentStreamingBase)(m_pooledStorageManager, 1i64);
    this->m_pooledStorageManager = NULL;
  }
}

/*
==============
bdLobbyService::disconnect
==============
*/
void bdLobbyService::disconnect(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
    bdLobbyConnection::disconnect(m_ptr);
  this->m_titleID = 0;
  bdLobbyService::cleanup(this);
}

/*
==============
bdLobbyService::getABTesting
==============
*/
void bdLobbyService::getABTesting(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdABTesting *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_abTesting )
    {
      v4 = (bdABTesting *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdABTesting::bdABTesting(v4, this->m_taskManager, this);
      this->m_abTesting = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getABTesting", 0x3F9u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getABTestingToken
==============
*/
char *bdLobbyService::getABTestingToken(bdLobbyService *this)
{
  return this->m_abTestingToken;
}

/*
==============
bdLobbyService::getAchievementsEngineClientService
==============
*/
bdAchievementClient *bdLobbyService::getAchievementsEngineClientService(bdLobbyService *this, const char *context)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdAchievementClient *m_achievementsEngineClientService; 
  bdAchievementsEngineService *v7; 
  bdAchievementsEngineService *v8; 
  bdAchievementClient *v9; 
  bdAchievementClient *v11; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    m_achievementsEngineClientService = this->m_achievementsEngineClientService;
    if ( !m_achievementsEngineClientService )
    {
      if ( !this->m_achievementsEngineService )
      {
        v7 = (bdAchievementsEngineService *)bdMemory::allocate(0x1068ui64);
        if ( v7 )
          bdAchievementsEngineService::bdAchievementsEngineService(v7, this->m_taskManager, &this->m_authInfo);
        else
          v8 = NULL;
        this->m_achievementsEngineService = v8;
      }
      v9 = (bdAchievementClient *)bdMemory::allocate(0x920D8ui64);
      if ( v9 )
      {
        __asm { vmovss  xmm3, cs:__real@40a00000; flushIntervalSeconds }
        bdAchievementClient::bdAchievementClient(v9, this->m_achievementsEngineService, context, *(float *)&_XMM3, 3);
        m_achievementsEngineClientService = v11;
      }
      this->m_achievementsEngineClientService = m_achievementsEngineClientService;
    }
    return m_achievementsEngineClientService;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getAchievementsEngineClientService", 0x391u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getAchievementsEngineService
==============
*/
void bdLobbyService::getAchievementsEngineService(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdAchievementsEngineService *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_achievementsEngineService )
    {
      v4 = (bdAchievementsEngineService *)bdMemory::allocate(0x1068ui64);
      if ( v4 )
        bdAchievementsEngineService::bdAchievementsEngineService(v4, this->m_taskManager, &this->m_authInfo);
      this->m_achievementsEngineService = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getAchievementsEngineService", 0x380u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getAntiCheat
==============
*/
void bdLobbyService::getAntiCheat(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdAntiCheat *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_antiCheat )
    {
      v4 = (bdAntiCheat *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdAntiCheat::bdAntiCheat(v4, this->m_taskManager);
      this->m_antiCheat = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getAntiCheat", 0x353u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getAuthInfo
==============
*/
bdAuthInfo *bdLobbyService::getAuthInfo(bdLobbyService *this)
{
  return &this->m_authInfo;
}

/*
==============
bdLobbyService::getCODO
==============
*/
void bdLobbyService::getCODO(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCODO *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_CODO )
    {
      v4 = (bdCODO *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdCODO::bdCODO(v4, this->m_taskManager);
      this->m_CODO = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCODO", 0x4B7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCODOTeamMarketplace
==============
*/
void bdLobbyService::getCODOTeamMarketplace(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCODOTeamMarketplace *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_CODOTeamMarketplace )
    {
      v4 = (bdCODOTeamMarketplace *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCODOTeamMarketplace::bdCODOTeamMarketplace(v4, this->m_taskManager);
      this->m_CODOTeamMarketplace = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCODOTeamMarketplace", 0x4C7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getContentStreaming
==============
*/
void bdLobbyService::getContentStreaming(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdContentStreaming *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_contentStreamingManager )
    {
      v4 = (bdContentStreaming *)bdMemory::allocate(0x14B18ui64);
      if ( v4 )
        bdContentStreaming::bdContentStreaming(v4, this->m_taskManager);
      this->m_contentStreamingManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getContentStreaming", 0x305u, "Not connected to LSG. The Content Streaming service is therefore inaccessible.");
  }
}

/*
==============
bdLobbyService::getCounter
==============
*/
void bdLobbyService::getCounter(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCounter *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_counter )
    {
      v4 = (bdCounter *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCounter::bdCounter(v4, this->m_taskManager);
      this->m_counter = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCounter", 0x2E7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCrossPlatformFriends
==============
*/
void bdLobbyService::getCrossPlatformFriends(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCrossPlatformFriends *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_crossPlatformFriends )
    {
      v4 = (bdCrossPlatformFriends *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCrossPlatformFriends::bdCrossPlatformFriends(v4, this);
      this->m_crossPlatformFriends = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCrossPlatformFriends", 0x42Fu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCrossPlatformIdentity
==============
*/
void bdLobbyService::getCrossPlatformIdentity(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCrossPlatformIdentity *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_crossPlatformIdentity )
    {
      v4 = (bdCrossPlatformIdentity *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdCrossPlatformIdentity::bdCrossPlatformIdentity(v4, this->m_taskManager, this);
      this->m_crossPlatformIdentity = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCrossPlatformIdentity", 0x43Fu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCrossPlatformPresence
==============
*/
void bdLobbyService::getCrossPlatformPresence(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCrossPlatformPresence *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_crossPlatformPresence )
    {
      v4 = (bdCrossPlatformPresence *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCrossPlatformPresence::bdCrossPlatformPresence(v4, this);
      this->m_crossPlatformPresence = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCrossPlatformPresence", 0x3B8u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCrossPlatformUserLists
==============
*/
void bdLobbyService::getCrossPlatformUserLists(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCrossPlatformUserLists *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_crossPlatformUserLists )
    {
      v4 = (bdCrossPlatformUserLists *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCrossPlatformUserLists::bdCrossPlatformUserLists(v4, this);
      this->m_crossPlatformUserLists = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCrossPlatformUserLists", 0x3A7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getCrossTitleLocalizedStrings
==============
*/
void bdLobbyService::getCrossTitleLocalizedStrings(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdCrossTitleLocalizedStrings *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_crossTitleLocalizedStrings )
    {
      v4 = (bdCrossTitleLocalizedStrings *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdCrossTitleLocalizedStrings::bdCrossTitleLocalizedStrings(v4, this);
      this->m_crossTitleLocalizedStrings = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getCrossTitleLocalizedStrings", 0x3C8u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getDDL
==============
*/
void bdLobbyService::getDDL(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdDDL *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_DDL )
    {
      v4 = (bdDDL *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdDDL::bdDDL(v4, this->m_taskManager);
      this->m_DDL = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getDDL", 0x51Eu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getDML
==============
*/
void bdLobbyService::getDML(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdDML *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_DML )
    {
      v4 = (bdDML *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdDML::bdDML(v4, this->m_taskManager);
      this->m_DML = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getDML", 0x362u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getErrorCode
==============
*/
__int64 bdLobbyService::getErrorCode(bdLobbyService *this)
{
  return (unsigned int)this->m_errorCode;
}

/*
==============
bdLobbyService::getEventLog
==============
*/
void bdLobbyService::getEventLog(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdEventLog *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_eventLogManager )
    {
      v4 = (bdEventLog *)bdMemory::allocate(0x218ui64);
      if ( v4 )
        bdEventLog::bdEventLog(v4, this->m_taskManager, 1);
      this->m_eventLogManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getEventLog", 0x2C9u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getFeatureBan
==============
*/
void bdLobbyService::getFeatureBan(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdFeatureBan *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_featureBan )
    {
      v4 = (bdFeatureBan *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdFeatureBan::bdFeatureBan(v4, this->m_taskManager);
      this->m_featureBan = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getFeatureBan", 0x498u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getGroup
==============
*/
void bdLobbyService::getGroup(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdGroup *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_group )
    {
      v4 = (bdGroup *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdGroup::bdGroup(v4, this->m_taskManager);
      this->m_group = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getGroup", 0x2F6u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getHandleInfo
==============
*/
void bdLobbyService::getHandleInfo(bdLobbyService *this, int *handle, bool *read, bool *write, float *timeout)
{
  bdLobbyConnection *m_ptr; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
  {
    bdLobbyConnection::getHandleInfo(m_ptr, handle, read, write, timeout);
  }
  else
  {
    *handle = -1;
    *read = 0;
    *write = 0;
    *timeout = -1.0;
  }
}

/*
==============
bdLobbyService::getKeyArchive
==============
*/
void bdLobbyService::getKeyArchive(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdKeyArchive *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_keyArchive )
    {
      v4 = (bdKeyArchive *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdKeyArchive::bdKeyArchive(v4, this->m_taskManager);
      this->m_keyArchive = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getKeyArchive", 0x2D8u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getLootGeneration
==============
*/
void bdLobbyService::getLootGeneration(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdLootGeneration *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_lootGeneration )
    {
      v4 = (bdLootGeneration *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdLootGeneration::bdLootGeneration(v4, this->m_taskManager, this);
      this->m_lootGeneration = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getLootGeneration", 0x409u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getMLG
==============
*/
void bdLobbyService::getMLG(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdMLG *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_mlg )
    {
      v4 = (bdMLG *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdMLG::bdMLG(v4, this->m_taskManager);
      this->m_mlg = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMLG", 0x55Fu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getMW4Service
==============
*/
void bdLobbyService::getMW4Service(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdMW4Service *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_mw4Service )
    {
      v4 = (bdMW4Service *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdMW4Service::bdMW4Service(v4, this->m_taskManager);
      this->m_mw4Service = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMW4Service", 0x3D8u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getMail
==============
*/
bdMail *bdLobbyService::getMail(bdLobbyService *this, const char *context)
{
  bdMail *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v11; 
  bdMail *v12; 
  bdMail *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdMail **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdMail *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_mailManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_mailManagers.m_map[v9 & (this->m_mailManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_mailManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_mailManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_mailManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdMail *)bdMemory::allocate(0x20ui64);
      value = v12;
      if ( v12 )
      {
        bdMail::bdMail(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdMail *,bdHashingClass>::put(&this->m_mailManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdMail **)bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(&this->m_mailManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_mailManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_mailManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMail", 0x2AAu, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getMarketingComms
==============
*/
bdMarketingComms *bdLobbyService::getMarketingComms(bdLobbyService *this, const char *context)
{
  int v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v11; 
  bdMarketingComms *v12; 
  bdMarketingComms *v13; 
  unsigned __int64 v14; 
  const char *v15; 
  int j; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v17; 
  bdString key; 
  bdString v20; 
  bdMarketingComms *value; 

  v4 = 0;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&key, context);
    bdString::bdString(&v20, context);
    if ( !this->m_marketingCommsManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_marketingCommsManagers.m_map[v9 & (this->m_marketingCommsManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_marketingCommsManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdMarketingComms *)bdMemory::allocate(0x18ui64);
      value = v12;
      if ( v12 )
        bdMarketingComms::bdMarketingComms(v12, this->m_taskManager, context);
      else
        v13 = NULL;
      value = v13;
      bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put(&this->m_marketingCommsManagers, &key, &value);
    }
    if ( this->m_marketingCommsManagers.m_size )
    {
      v14 = bdString::getLength(&key);
      v15 = bdString::getBuffer(&key);
      for ( j = 0; v14; --v14 )
        v4 = (unsigned __int8)v15[j++] ^ (16777619 * v4);
      v17 = this->m_marketingCommsManagers.m_map[v4 & (this->m_marketingCommsManagers.m_capacity - 1)];
      if ( v17 )
      {
        while ( !bdString::operator==(&key, &v17->m_key) )
        {
          v17 = v17->m_next;
          if ( !v17 )
            goto LABEL_25;
        }
        _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 1u);
        value = v17->m_data;
        bdHandleAssert(this->m_marketingCommsManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
        _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketingCommsManagers.m_numIterators, 0xFFFFFFFF);
      }
    }
LABEL_25:
    bdString::~bdString(&key);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMarketingComms", 0x4E8u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getMarketplace
==============
*/
bdMarketplace *bdLobbyService::getMarketplace(bdLobbyService *this, const char *context)
{
  bdMarketplace *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v11; 
  bdMarketplace *v12; 
  bdMarketplace *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdMarketplace **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdMarketplace *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_marketplaceManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_marketplaceManagers.m_map[v9 & (this->m_marketplaceManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketplaceManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_marketplaceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketplaceManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdMarketplace *)bdMemory::allocate(0x18ui64);
      value = v12;
      if ( v12 )
      {
        bdMarketplace::bdMarketplace(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put(&this->m_marketplaceManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdMarketplace **)bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(&this->m_marketplaceManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_marketplaceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_marketplaceManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMarketplace", 0x472u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getMatchMaking
==============
*/
bdMatchMaking *bdLobbyService::getMatchMaking(bdLobbyService *this, const char *context)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdMatchMaking *v6; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v11; 
  char v12; 
  char *v13; 
  bdMatchMaking *v14; 
  bdString v16; 
  bdMatchMaking *value; 
  bdString key; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v16, context);
    v6 = NULL;
    if ( !this->m_matchmakings.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v16);
    Buffer = bdString::getBuffer(&v16);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_matchmakings.m_map[v9 & (this->m_matchmakings.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v16, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_matchmakings.m_numIterators, 1u);
      value = v11->m_data;
      bdHandleAssert(this->m_matchmakings.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_matchmakings.m_numIterators, 0xFFFFFFFF);
      v12 = 0;
    }
    else
    {
LABEL_10:
      v12 = 1;
    }
    bdString::~bdString(&v16);
    if ( v12 )
    {
      v13 = (char *)bdMemory::allocate(0x18ui64);
      v16.m_string = v13;
      if ( v13 )
      {
        bdMatchMaking::bdMatchMaking((bdMatchMaking *)v13, this->m_taskManager, context);
        v6 = v14;
      }
      value = v6;
      bdString::bdString(&key, context);
      bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put(&this->m_matchmakings, &key, &value);
      bdString::~bdString(&key);
      return v6;
    }
    else
    {
      return value;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMatchMaking", 0x248u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getMatchScheduler
==============
*/
void bdLobbyService::getMatchScheduler(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdMatchScheduler *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_matchScheduler )
    {
      v4 = (bdMatchScheduler *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdMatchScheduler::bdMatchScheduler(v4, this->m_taskManager);
      this->m_matchScheduler = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMatchScheduler", 0x54Fu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getMessaging
==============
*/
void bdLobbyService::getMessaging(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdMessaging *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_messaging )
    {
      v4 = (bdMessaging *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdMessaging::bdMessaging(v4, this->m_taskManager);
      this->m_messaging = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getMessaging", 0x239u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getObjectStore
==============
*/
void bdLobbyService::getObjectStore(bdLobbyService *this, const char *certificateAuthorityPath)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdObjectStore *v6; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_objectStore )
    {
      v6 = (bdObjectStore *)bdMemory::allocate(0x508ui64);
      if ( v6 )
        bdObjectStore::bdObjectStore(v6, this->m_taskManager, this, certificateAuthorityPath);
      this->m_objectStore = v6;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getObjectStore", 0x371u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getPooledStorage
==============
*/
void bdLobbyService::getPooledStorage(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdPooledStorage *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_pooledStorageManager )
    {
      v4 = (bdPooledStorage *)bdMemory::allocate(0x14B00ui64);
      if ( v4 )
        bdPooledStorage::bdPooledStorage(v4, this->m_taskManager);
      this->m_pooledStorageManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getPooledStorage", 0x31Du, "Not connected to LSG. The Pooled Storage service is therefore inaccessible.");
  }
}

/*
==============
bdLobbyService::getProfiles
==============
*/
void bdLobbyService::getProfiles(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdProfiles *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_profiles )
    {
      v4 = (bdProfiles *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdProfiles::bdProfiles(v4, this->m_taskManager);
      this->m_profiles = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getProfiles", 0x22Au, "Not connected.");
  }
}

/*
==============
bdLobbyService::getPublisherVariables
==============
*/
bdPublisherVariables *bdLobbyService::getPublisherVariables(bdLobbyService *this, const char *context)
{
  bdPublisherVariables *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v11; 
  bdPublisherVariables *v12; 
  bdPublisherVariables *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdPublisherVariables **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdPublisherVariables *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_publisherVariablesManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_publisherVariablesManagers.m_map[v9 & (this->m_publisherVariablesManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_publisherVariablesManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_publisherVariablesManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_publisherVariablesManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdPublisherVariables *)bdMemory::allocate(0x70ui64);
      value = v12;
      if ( v12 )
      {
        bdPublisherVariables::bdPublisherVariables(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put(&this->m_publisherVariablesManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdPublisherVariables **)bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(&this->m_publisherVariablesManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_publisherVariablesManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_publisherVariablesManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getPublisherVariables", 0x50Du, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getRedeemableCodeService
==============
*/
bdRedeemableCodeService *bdLobbyService::getRedeemableCodeService(bdLobbyService *this, const char *context)
{
  bdRedeemableCodeService *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v11; 
  bdRedeemableCodeService *v12; 
  bdRedeemableCodeService *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdRedeemableCodeService **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdRedeemableCodeService *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_redeemableCodeServiceManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_redeemableCodeServiceManagers.m_map[v9 & (this->m_redeemableCodeServiceManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_redeemableCodeServiceManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_redeemableCodeServiceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_redeemableCodeServiceManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdRedeemableCodeService *)bdMemory::allocate(0x18ui64);
      value = v12;
      if ( v12 )
      {
        bdRedeemableCodeService::bdRedeemableCodeService(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put(&this->m_redeemableCodeServiceManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdRedeemableCodeService **)bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(&this->m_redeemableCodeServiceManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_redeemableCodeServiceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_redeemableCodeServiceManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getRedeemableCodeService", 0x53Du, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getRegulations
==============
*/
void bdLobbyService::getRegulations(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdRegulations *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_regulations )
    {
      v4 = (bdRegulations *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdRegulations::bdRegulations(v4, this->m_taskManager, this);
      this->m_regulations = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getRegulations", 0x44Fu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getRelayService
==============
*/
void bdLobbyService::getRelayService(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdRelayService *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_relayService )
    {
      v4 = (bdRelayService *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdRelayService::bdRelayService(v4, this->m_taskManager);
      this->m_relayService = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getRelayService", 0x4D7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getReportLogoffService
==============
*/
void bdLobbyService::getReportLogoffService(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdUserLogoffRecordsService *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_reportLogoffService )
    {
      v4 = (bdUserLogoffRecordsService *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdUserLogoffRecordsService::bdUserLogoffRecordsService(v4, this->m_taskManager);
      this->m_reportLogoffService = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getReportLogoffService", 0x3E8u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getRestTaskManager
==============
*/
void bdLobbyService::getRestTaskManager(bdLobbyService *this)
{
  bdRESTTaskManager *v2; 

  if ( !this->m_restTaskManager )
  {
    v2 = (bdRESTTaskManager *)bdMemory::allocate(0x30ui64);
    if ( v2 )
      bdRESTTaskManager::bdRESTTaskManager(v2, &restConfig, this);
    this->m_restTaskManager = v2;
  }
}

/*
==============
bdLobbyService::getRewards
==============
*/
bdReward *bdLobbyService::getRewards(bdLobbyService *this, const char *context)
{
  bdReward *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v11; 
  bdReward *v12; 
  bdReward *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdReward **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdReward *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_rewardManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_rewardManagers.m_map[v9 & (this->m_rewardManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_rewardManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_rewardManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_rewardManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdReward *)bdMemory::allocate(0x18ui64);
      value = v12;
      if ( v12 )
      {
        bdReward::bdReward(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdReward *,bdHashingClass>::put(&this->m_rewardManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdReward **)bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(&this->m_rewardManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_rewardManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_rewardManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getRewards", 0x4FBu, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getRichPresence
==============
*/
bdRichPresenceService *bdLobbyService::getRichPresence(bdLobbyService *this, const char *context)
{
  bdRichPresenceService *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v11; 
  bdRichPresenceService *v12; 
  bdRichPresenceService *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdRichPresenceService **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdRichPresenceService *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_richPresenceManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_richPresenceManagers.m_map[v9 & (this->m_richPresenceManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_richPresenceManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_richPresenceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_richPresenceManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdRichPresenceService *)bdMemory::allocate(0x18ui64);
      value = v12;
      if ( v12 )
      {
        bdRichPresenceService::bdRichPresenceService(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put(&this->m_richPresenceManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdRichPresenceService **)bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(&this->m_richPresenceManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_richPresenceManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_richPresenceManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getRichPresence", 0x460u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getServerInventory
==============
*/
void bdLobbyService::getServerInventory(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdServerInventory *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_serverInventory )
    {
      v4 = (bdServerInventory *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdServerInventory::bdServerInventory(v4, this->m_taskManager);
      this->m_serverInventory = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getServerInventory", 0x52Du, "Not connected.");
  }
}

/*
==============
bdLobbyService::getStats
==============
*/
void bdLobbyService::getStats(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdStats *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_statsManager )
    {
      v4 = (bdStats *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdStats::bdStats(v4, this->m_taskManager);
      this->m_statsManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getStats", 0x261u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getStatus
==============
*/
bdLobbyConnection::Status bdLobbyService::getStatus(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status result; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( !m_ptr )
    return 0;
  result = bdLobbyConnection::getStatus(m_ptr);
  if ( !this->m_lobbyConnectionEstablished && result == BD_NOT_CONNECTED )
    return 1;
  return result;
}

/*
==============
bdLobbyService::getStorage
==============
*/
bdStorage *bdLobbyService::getStorage(bdLobbyService *this, const char *context)
{
  bdStorage *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v11; 
  bdStorage *v12; 
  bdStorage *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdStorage **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdStorage *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_storageManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_storageManagers.m_map[v9 & (this->m_storageManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_storageManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_storageManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_storageManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdStorage *)bdMemory::allocate(0x20ui64);
      value = v12;
      if ( v12 )
      {
        bdStorage::bdStorage(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdStorage *,bdHashingClass>::put(&this->m_storageManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdStorage **)bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(&this->m_storageManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_storageManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_storageManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getStorage", 0x297u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getTags
==============
*/
void bdLobbyService::getTags(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdTags *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_tags )
    {
      v4 = (bdTags *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdTags::bdTags(v4, this->m_taskManager);
      this->m_tags = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTags", 0x335u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getTaskManager
==============
*/
bdRemoteTaskManager *bdLobbyService::getTaskManager(bdLobbyService *this)
{
  return this->m_taskManager;
}

/*
==============
bdLobbyService::getTeamShowcase
==============
*/
bdTeamShowcase *bdLobbyService::getTeamShowcase(bdLobbyService *this, const char *context)
{
  bdTeamShowcase *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v11; 
  bdTeamShowcase *v12; 
  bdTeamShowcase *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdTeamShowcase **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdTeamShowcase *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_teamShowcaseManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_teamShowcaseManagers.m_map[v9 & (this->m_teamShowcaseManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamShowcaseManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_teamShowcaseManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamShowcaseManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdTeamShowcase *)bdMemory::allocate(0x20ui64);
      value = v12;
      if ( v12 )
      {
        bdTeamShowcase::bdTeamShowcase(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put(&this->m_teamShowcaseManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdTeamShowcase **)bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(&this->m_teamShowcaseManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_teamShowcaseManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamShowcaseManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTeamShowcase", 0x283u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getTeams
==============
*/
bdTeams *bdLobbyService::getTeams(bdLobbyService *this, const char *context)
{
  bdTeams *v4; 
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v9; 
  int i; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v11; 
  bdTeams *v12; 
  bdTeams *v13; 
  const bdString *v14; 
  const bdString *v15; 
  bdTeams **Iterator; 
  bdString v18; 
  __int64 v19; 
  bdString v20; 
  bdTeams *value; 
  bdString v22; 

  v19 = -2i64;
  v4 = NULL;
  value = NULL;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    bdString::bdString(&v20, context);
    if ( !this->m_teamsManagers.m_size )
      goto LABEL_10;
    Length = bdString::getLength(&v20);
    Buffer = bdString::getBuffer(&v20);
    v9 = 0;
    for ( i = 0; Length; --Length )
      v9 = (unsigned __int8)Buffer[i++] ^ (16777619 * v9);
    v11 = this->m_teamsManagers.m_map[v9 & (this->m_teamsManagers.m_capacity - 1)];
    if ( v11 )
    {
      while ( !bdString::operator==(&v20, &v11->m_key) )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_10;
      }
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamsManagers.m_numIterators, 1u);
      bdHandleAssert(this->m_teamsManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamsManagers.m_numIterators, 0xFFFFFFFF);
    }
    else
    {
LABEL_10:
      v11 = NULL;
    }
    bdString::~bdString(&v20);
    if ( !v11 )
    {
      v12 = (bdTeams *)bdMemory::allocate(0x20ui64);
      value = v12;
      if ( v12 )
      {
        bdTeams::bdTeams(v12, this->m_taskManager, context);
        v4 = v13;
      }
      value = v4;
      bdString::bdString(&v22, context);
      bdHashMap<bdString,bdTeams *,bdHashingClass>::put(&this->m_teamsManagers, v14, &value);
      bdString::~bdString(&v22);
    }
    bdString::bdString(&v18, context);
    Iterator = (bdTeams **)bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(&this->m_teamsManagers, v15);
    if ( Iterator )
    {
      value = *Iterator;
      bdHandleAssert(this->m_teamsManagers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_teamsManagers.m_numIterators, 0xFFFFFFFF);
    }
    bdString::~bdString(&v18);
    return value;
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTeams", 0x271u, "Not connected.");
    return 0i64;
  }
}

/*
==============
bdLobbyService::getTencent
==============
*/
void bdLobbyService::getTencent(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdTencent *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_tencent )
    {
      v4 = (bdTencent *)bdMemory::allocate(0x50018ui64);
      if ( v4 )
        bdTencent::bdTencent(v4, this->m_taskManager);
      this->m_tencent = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTencent", 0x4A7u, "Not connected.");
  }
}

/*
==============
bdLobbyService::getTitleUtilities
==============
*/
void bdLobbyService::getTitleUtilities(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdTitleUtilities *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_titleUtilitiesManager )
    {
      v4 = (bdTitleUtilities *)bdMemory::allocate(0x10ui64);
      if ( v4 )
        bdTitleUtilities::bdTitleUtilities(v4, this->m_taskManager);
      this->m_titleUtilitiesManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTitleUtilities", 0x2BBu, "Not connected.");
  }
}

/*
==============
bdLobbyService::getUmbrella
==============
*/
bdUmbrella *bdLobbyService::getUmbrella(bdLobbyService *this)
{
  bdUmbrella *result; 
  bdUmbrella *v3; 
  bdUmbrella *v4; 

  result = this->m_umbrella;
  if ( !result )
  {
    v3 = (bdUmbrella *)bdMemory::allocate(0x1A0ui64);
    v4 = v3;
    if ( v3 )
    {
      memset_0(v3, 0, sizeof(bdUmbrella));
      bdSingleIdentityBase::bdSingleIdentityBase(v4);
      v4->__vftable = (bdUmbrella_vtbl *)&bdUmbrella::`vftable';
    }
    else
    {
      v4 = NULL;
    }
    this->m_umbrella = v4;
    return v4;
  }
  return result;
}

/*
==============
bdLobbyService::getUno
==============
*/
void bdLobbyService::getUno(bdLobbyService *this)
{
  bdUno *v2; 

  if ( !this->m_uno )
  {
    v2 = (bdUno *)bdMemory::allocate(0x1B0ui64);
    if ( v2 )
      bdUno::bdUno(v2);
    this->m_uno = v2;
  }
}

/*
==============
bdLobbyService::getVoteRank
==============
*/
void bdLobbyService::getVoteRank(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdLobbyConnection::Status Status; 
  bdVoteRank *v4; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr && (Status = bdLobbyConnection::getStatus(m_ptr), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    if ( !this->m_voteRankManager )
    {
      v4 = (bdVoteRank *)bdMemory::allocate(8ui64);
      if ( v4 )
        bdVoteRank::bdVoteRank(v4, this->m_taskManager);
      this->m_voteRankManager = v4;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getVoteRank", 0x344u, "Not connected.");
  }
}

/*
==============
bdLobbyService::handleAchievementsUpdated
==============
*/
_BOOL8 bdLobbyService::handleAchievementsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  char *v6; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  bdAchievementsUpdatedPushMessage serializable[2]; 
  bdReference<bdByteBuffer> buffer; 

  bdAchievementsUpdatedPushMessage::bdAchievementsUpdatedPushMessage(serializable);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = bdStructBufferDeserializerHelpers::deserializeFromBuffer((bdReference<bdByteBuffer>)&buffer, serializable);
  if ( v5 )
    this->m_eventHandler->onAchievementsUpdated(this->m_eventHandler, serializable);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleAchievementsUpdated", 0xF13u, "Failed to deserialize bdAchievementsUpdatedPushMessage");
  v6 = (char *)*((_QWORD *)&serializable[0].__vftable + 2);
  if ( *((_DWORD *)&serializable[0].__vftable + 7) )
  {
    v7 = 0i64;
    v8 = 0i64;
    v9 = *((_QWORD *)&serializable[0].__vftable + 2) + 8i64;
    v10 = *((unsigned int *)&serializable[0].__vftable + 7);
    do
    {
      (**(void (__fastcall ***)(__int64, _QWORD))&v6[*(int *)(*(_QWORD *)v9 + 4i64) + 8 + v7])((__int64)&v6[*(int *)(*(_QWORD *)v9 + 4i64) + 8 + v8], 0i64);
      v8 += 552i64;
      v7 += 552i64;
      v9 += 552i64;
      --v10;
    }
    while ( v10 );
    v6 = (char *)*((_QWORD *)&serializable[0].__vftable + 2);
  }
  bdMemory::deallocate(v6);
  *((_QWORD *)&serializable[0].__vftable + 2) = 0i64;
  *((_QWORD *)&serializable[0].__vftable + 3) = 0i64;
  bdStructBufferSerializable::~bdStructBufferSerializable((bdStructBufferSerializable *)(&serializable[0].__vftable + 2));
  bdReferencable::~bdReferencable((bdReferencable *)serializable[0].gap20);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleCODOTeamMarketplaceLevelChange
==============
*/
__int64 bdLobbyService::handleCODOTeamMarketplaceLevelChange(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned __int64 v6[5]; 
  unsigned int v7; 
  unsigned int u; 

  v6[1] = -2i64;
  v6[0] = 0i64;
  u = 0;
  v7 = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, v6) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v7) )
  {
    v4 = 1;
    this->m_eventHandler->onCODOTeamMarketplaceLevelChange(this->m_eventHandler, v6[0], u, v7);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleChallengesReceived
==============
*/
__int64 bdLobbyService::handleChallengesReceived(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  bdAntiCheatChallenges *v6; 
  bdAntiCheatChallenges *v7; 
  bdAntiCheatChallenges *v8; 
  bdByteBuffer *v9; 
  unsigned __int8 v10; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onChallengesReceived)(bdLobbyEventHandler *, unsigned __int64, bdReference<bdAntiCheatChallenges>); 
  bdAntiCheatChallenges *v14; 
  bdReference<bdByteBuffer> buffer; 
  unsigned __int64 u[4]; 
  char s[8]; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  v6 = (bdAntiCheatChallenges *)bdMemory::allocate(0x18ui64);
  v14 = v6;
  if ( v6 )
  {
    bdAntiCheatChallenges::bdAntiCheatChallenges(v6);
    v8 = v7;
  }
  else
  {
    v8 = NULL;
  }
  u[3] = (unsigned __int64)v8;
  if ( v8 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
  if ( !v5 )
    goto LABEL_17;
  v9 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v9;
  if ( v9 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v9->m_refCount, 1u);
  if ( bdAntiCheatChallenges::deserialize(v8, (bdReference<bdByteBuffer>)&buffer) )
  {
    v10 = 1;
    m_eventHandler = this->m_eventHandler;
    onChallengesReceived = m_eventHandler->onChallengesReceived;
    v14 = v8;
    if ( v8 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
    ((void (__fastcall *)(bdLobbyEventHandler *, unsigned __int64, bdAntiCheatChallenges **))onChallengesReceived)(m_eventHandler, u[0], &v14);
  }
  else
  {
LABEL_17:
    v10 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChallengesReceived", 0xA4Eu, "Failed to read challenges.");
  }
  if ( v8 && _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 0xFFFFFFFF) == 1 )
    ((void (__fastcall *)(bdAntiCheatChallenges *, __int64))v8->~bdReferencable)(v8, 1i64);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v10;
}

/*
==============
bdLobbyService::handleChannelChatMsg
==============
*/
__int64 bdLobbyService::handleChannelChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  char v5; 
  unsigned __int8 v6; 
  unsigned int length[2]; 
  unsigned __int64 v9; 
  unsigned __int64 u[4]; 
  char s[8]; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  if ( !UInt64 || !bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    v9 = 0i64;
    goto LABEL_6;
  }
  v9 = 0i64;
  if ( !bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v9) )
  {
LABEL_6:
    v5 = 0;
    goto LABEL_7;
  }
  v5 = 1;
LABEL_7:
  memset_0(blob, 0, sizeof(blob));
  length[1] = 1024;
  if ( !v5 || !bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length[1]) )
  {
    length[0] = 0;
    goto LABEL_12;
  }
  length[0] = 0;
  if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, length) )
  {
LABEL_12:
    v6 = 0;
    goto LABEL_13;
  }
  v6 = 1;
  this->m_eventHandler->onChatChannelMessage(this->m_eventHandler, v9, u[0], s, length[0], blob, length[1]);
LABEL_13:
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleChannelChatMsgV2
==============
*/
__int64 bdLobbyService::handleChannelChatMsgV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  char v6; 
  unsigned __int8 v7; 
  unsigned int length[2]; 
  unsigned __int64 v10; 
  unsigned __int64 u[3]; 
  char v12[8]; 
  __int64 v13; 
  char s[8]; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  *(_QWORD *)v12 = 0i64;
  v13 = 0i64;
  if ( !v5 || !bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, v12, 0x10ui64) )
  {
    v10 = 0i64;
    goto LABEL_10;
  }
  v10 = 0i64;
  if ( !bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v10) )
  {
LABEL_10:
    v6 = 0;
    goto LABEL_11;
  }
  v6 = 1;
LABEL_11:
  memset_0(blob, 0, sizeof(blob));
  length[1] = 1024;
  if ( !v6 || !bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length[1]) )
  {
    length[0] = 0;
    goto LABEL_16;
  }
  length[0] = 0;
  if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, length) )
  {
LABEL_16:
    v7 = 0;
    goto LABEL_17;
  }
  v7 = 1;
  this->m_eventHandler->onChatChannelMessage(this->m_eventHandler, v12, v10, u[0], s, length[0], blob, length[1]);
LABEL_17:
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v7;
}

/*
==============
bdLobbyService::handleChannelUserKicked
==============
*/
_BOOL8 bdLobbyService::handleChannelUserKicked(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  bdByteBuffer *v5; 
  bdByteBuffer *v6; 
  bdByteBuffer *v7; 
  bool line; 
  unsigned __int8 b; 
  bool v11; 
  unsigned int u; 
  bdReference<bdByteBuffer> v13; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v18; 
  bdChannelMember v19; 
  bdChannelMember v20; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelInfo::bdChannelInfo(&v18);
  bdChannelMember::bdChannelMember(&v20);
  bdChannelMember::bdChannelMember(&v19);
  u = 0;
  v11 = 0;
  b = 0;
  v4 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, &b);
  if ( v4 && b >= 2u )
  {
    v5 = (bdByteBuffer *)message.m_ptr->__vftable;
    buffer.m_ptr = v5;
    if ( v5 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
    if ( !bdChannelInfo::deserialize(&v18, (bdReference<bdByteBuffer>)&buffer) )
      goto LABEL_15;
    v6 = (bdByteBuffer *)message.m_ptr->__vftable;
    v14.m_ptr = v6;
    if ( v6 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_refCount, 1u);
    if ( !bdChannelMember::deserialize(&v20, (bdReference<bdByteBuffer>)&v14) )
      goto LABEL_15;
    v7 = (bdByteBuffer *)message.m_ptr->__vftable;
    v13.m_ptr = v7;
    if ( v7 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
    if ( bdChannelMember::deserialize(&v19, (bdReference<bdByteBuffer>)&v13) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readBool((bdByteBuffer *)message.m_ptr->__vftable, &v11) )
    {
      v4 = 1;
      line = v11;
      this->m_eventHandler->onChatChannelUserKicked(this->m_eventHandler, &v18, &v20, &v19, u, line);
      this->m_eventHandler->onChatChannelUpdate(this->m_eventHandler, &v18, &v19, 0);
    }
    else
    {
LABEL_15:
      v4 = 0;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChannelUserKicked", 0x9C0u, "Recieved a BD_CHANNEL_USER_KICKED message with an invalid version field.");
  }
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v19.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v19.m_subscribedTimestamp + 2));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v20.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v20.m_subscribedTimestamp + 2));
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v18.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v18.m_dataVersion + 1));
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleChannelUserKickedV2
==============
*/
__int64 bdLobbyService::handleChannelUserKickedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bdByteBuffer *v6; 
  unsigned __int8 v7; 
  bool line; 
  bool b; 
  unsigned int u; 
  bdReference<bdByteBuffer> v12; 
  bdReference<bdByteBuffer> v13; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v15; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v17; 
  bdChannelMember v18; 
  bdChannelMember v19; 

  v15 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelInfo::bdChannelInfo(&v17);
  bdChannelMember::bdChannelMember(&v19);
  bdChannelMember::bdChannelMember(&v18);
  u = 0;
  b = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !bdChannelInfo::deserializeWithCategory(&v17, (bdReference<bdByteBuffer>)&buffer) )
    goto LABEL_13;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v13.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( !bdChannelMember::deserialize(&v19, (bdReference<bdByteBuffer>)&v13) )
    goto LABEL_13;
  v6 = (bdByteBuffer *)message.m_ptr->__vftable;
  v12.m_ptr = v6;
  if ( v6 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_refCount, 1u);
  if ( bdChannelMember::deserialize(&v18, (bdReference<bdByteBuffer>)&v12) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readBool((bdByteBuffer *)message.m_ptr->__vftable, &b) )
  {
    v7 = 1;
    line = b;
    this->m_eventHandler->onChatChannelUserKicked(this->m_eventHandler, &v17, &v19, &v18, u, line);
    this->m_eventHandler->onChatChannelUpdate(this->m_eventHandler, &v17, &v18, 0);
  }
  else
  {
LABEL_13:
    v7 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChannelUserKickedV2", 0x9DBu, "Received a BD_CHANNEL_USER_KICKED_V2 message with an invalid field.");
  }
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v18.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v18.m_subscribedTimestamp + 2));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v19.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v19.m_subscribedTimestamp + 2));
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v17.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v17.m_dataVersion + 1));
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v7;
}

/*
==============
bdLobbyService::handleChannelUserMuted
==============
*/
__int64 bdLobbyService::handleChannelUserMuted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned __int64 v6; 
  unsigned __int64 u; 

  u = 0i64;
  v6 = 0i64;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v6) )
  {
    v4 = 1;
    this->m_eventHandler->onPlayerMuted(this->m_eventHandler, u, v6);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleChannelUserPromoted
==============
*/
_BOOL8 bdLobbyService::handleChannelUserPromoted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UByte8; 
  bdByteBuffer *v5; 
  bdByteBuffer *v6; 
  bdByteBuffer *v7; 
  unsigned __int8 b[8]; 
  bdReference<bdByteBuffer> v10; 
  bdReference<bdByteBuffer> v11; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v13; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v15; 
  bdChannelMember v16; 
  bdChannelMember v17; 

  v13 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelInfo::bdChannelInfo(&v15);
  bdChannelMember::bdChannelMember(&v17);
  bdChannelMember::bdChannelMember(&v16);
  b[0] = 0;
  UByte8 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b);
  if ( UByte8 && b[0] >= 2u )
  {
    v5 = (bdByteBuffer *)message.m_ptr->__vftable;
    buffer.m_ptr = v5;
    if ( v5 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
    if ( !bdChannelInfo::deserialize(&v15, (bdReference<bdByteBuffer>)&buffer) )
      goto LABEL_13;
    v6 = (bdByteBuffer *)message.m_ptr->__vftable;
    v11.m_ptr = v6;
    if ( v6 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_refCount, 1u);
    if ( !bdChannelMember::deserialize(&v17, (bdReference<bdByteBuffer>)&v11) )
      goto LABEL_13;
    v7 = (bdByteBuffer *)message.m_ptr->__vftable;
    v10.m_ptr = v7;
    if ( v7 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
    if ( bdChannelMember::deserialize(&v16, (bdReference<bdByteBuffer>)&v10) )
    {
      UByte8 = 1;
      this->m_eventHandler->onChatChannelUserPromoted(this->m_eventHandler, &v15, &v17, &v16);
    }
    else
    {
LABEL_13:
      UByte8 = 0;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChannelUserPromoted", 0x989u, "Received a BD_CHANNEL_USER_PROMOTED message with invalid version field.");
  }
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v16.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v16.m_subscribedTimestamp + 2));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v17.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v17.m_subscribedTimestamp + 2));
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v15.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v15.m_dataVersion + 1));
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return UByte8;
}

/*
==============
bdLobbyService::handleChannelUserPromotedV2
==============
*/
__int64 bdLobbyService::handleChannelUserPromotedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bdByteBuffer *v6; 
  unsigned __int8 v7; 
  bdReference<bdByteBuffer> v9; 
  bdReference<bdByteBuffer> v10; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v12; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v14; 
  bdChannelMember v15; 
  bdChannelMember v16; 

  v12 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelInfo::bdChannelInfo(&v14);
  bdChannelMember::bdChannelMember(&v16);
  bdChannelMember::bdChannelMember(&v15);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !bdChannelInfo::deserializeWithCategory(&v14, (bdReference<bdByteBuffer>)&buffer) )
    goto LABEL_11;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v10.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( !bdChannelMember::deserialize(&v16, (bdReference<bdByteBuffer>)&v10) )
    goto LABEL_11;
  v6 = (bdByteBuffer *)message.m_ptr->__vftable;
  v9.m_ptr = v6;
  if ( v6 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_refCount, 1u);
  if ( bdChannelMember::deserialize(&v15, (bdReference<bdByteBuffer>)&v9) )
  {
    v7 = 1;
    this->m_eventHandler->onChatChannelUserPromoted(this->m_eventHandler, &v14, &v16, &v15);
  }
  else
  {
LABEL_11:
    v7 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChannelUserPromotedV2", 0x99Eu, "Received a BD_CHANNEL_USER_PROMOTED_V2 message with invalid field.");
  }
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v15.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v15.m_subscribedTimestamp + 2));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v16.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v16.m_subscribedTimestamp + 2));
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v14.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v14.m_dataVersion + 1));
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v7;
}

/*
==============
bdLobbyService::handleChannelUserSubscription
==============
*/
_BOOL8 bdLobbyService::handleChannelUserSubscription(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  bool v6; 
  bool v7; 
  bdByteBuffer *v8; 
  unsigned __int8 b[8]; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v12; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v14; 
  bdChannelMember v15; 

  v12 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelMember::bdChannelMember(&v15);
  bdChannelInfo::bdChannelInfo(&v14);
  v6 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, (unsigned __int64 *)v15._bytes_20) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, &v15._bytes_20[8], 0x40ui64) && bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v14.m_channelID);
  v7 = eventType == BD_CHANNEL_USER_SUBSCRIBED;
  b[0] = 0;
  if ( v6 )
  {
    if ( bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b) && b[0] >= 2u )
    {
      if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v15.m_subscribedTimestamp) )
        goto LABEL_21;
      v8 = (bdByteBuffer *)message.m_ptr->__vftable;
      buffer.m_ptr = v8;
      if ( v8 )
        _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
      if ( !bdChannelInfo::deserialize(&v14, (bdReference<bdByteBuffer>)&buffer) )
      {
LABEL_21:
        v6 = 0;
        goto LABEL_15;
      }
      v6 = 1;
    }
    this->m_eventHandler->onChatChannelUpdate(this->m_eventHandler, &v14, &v15, v7);
  }
LABEL_15:
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v14.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v14.m_dataVersion + 1));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v15.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v15.m_subscribedTimestamp + 2));
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleChannelUserSubscriptionV2
==============
*/
__int64 bdLobbyService::handleChannelUserSubscriptionV2(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  bool v6; 
  bool v7; 
  bdByteBuffer *v8; 
  unsigned __int8 v9; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v12; 
  bdByteBuffer *m_ptr; 
  bdChannelInfo v14; 
  bdChannelMember v15; 

  v12 = -2i64;
  m_ptr = message.m_ptr;
  bdChannelMember::bdChannelMember(&v15);
  bdChannelInfo::bdChannelInfo(&v14);
  v6 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, (unsigned __int64 *)v15._bytes_20) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, &v15._bytes_20[8], 0x40ui64) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, v14._bytes_20, 0x10ui64) && bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v14.m_channelID);
  v7 = eventType == BD_CHANNEL_USER_SUBSCRIBED_V2;
  if ( !v6 || !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v15.m_subscribedTimestamp) )
    goto LABEL_13;
  v8 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v8;
  if ( v8 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
  if ( bdChannelInfo::deserializeWithCategory(&v14, (bdReference<bdByteBuffer>)&buffer) )
  {
    v9 = 1;
    this->m_eventHandler->onChatChannelUpdate(this->m_eventHandler, &v14, &v15, v7);
  }
  else
  {
LABEL_13:
    v9 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleChannelUserSubscriptionV2", 0x96Eu, "Received a BD_CHANNEL_USER_(UN)SUBSCRIBED_V2 message with invalid field.");
  }
  bdChannelInfo::~bdChannelInfo((bdChannelInfo *)(&v14.m_dataVersion + 1));
  bdReferencable::~bdReferencable((bdReferencable *)(&v14.m_dataVersion + 1));
  bdChannelMember::~bdChannelMember((bdChannelMember *)(&v15.m_subscribedTimestamp + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v15.m_subscribedTimestamp + 2));
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v9;
}

/*
==============
bdLobbyService::handleClaimAchievement
==============
*/
_BOOL8 bdLobbyService::handleClaimAchievement(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  unsigned int i; 
  const bdUserAccountID *v8; 
  bdByteBuffer_vtbl *v9; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onClaimAchievement)(bdLobbyEventHandler *, bdUserAccountID, char *, unsigned int, unsigned int, const bdMarketplaceInventory *); 
  unsigned int v12; 
  unsigned int v13; 
  __int64 v14; 
  unsigned int v16; 
  unsigned int u; 
  bdReference<bdByteBuffer> v18; 
  bdByteBuffer_vtbl *v19; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v21; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v23; 
  bdUserAccountID v24; 
  bdUserAccountID userID; 
  _QWORD ptr[928]; 
  char context[8]; 
  __int64 v28; 

  v21 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0xE8ui64, 0x20ui64, (void (__fastcall *)(void *))bdMarketplaceInventory::bdMarketplaceInventory, (void (__fastcall *)(void *))bdMarketplaceInventory::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v28 = 0i64;
  u = 0;
  v16 = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v18.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v18, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v16);
  if ( v16 > 0x20 )
  {
    v16 = 32;
    bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleClaimAchievement", 0xDA6u, "Too many [%d] item updates in push message. Code can only handle %d.", 32, 32);
  }
  for ( i = 0; i < v16; ++i )
  {
    if ( !v6 )
      goto LABEL_18;
    bdUserAccountID::bdUserAccountID(&v23, &userID);
    v9 = message.m_ptr->__vftable;
    v19 = v9;
    if ( v9 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v9->allocateBuffer, 1u);
    if ( bdMarketplaceInventory::deserialize((bdMarketplaceInventory *)&ptr[29 * i], (bdReference<bdByteBuffer>)&v19, v8) )
      v6 = 1;
    else
LABEL_18:
      v6 = 0;
  }
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onClaimAchievement = m_eventHandler->onClaimAchievement;
    v12 = v16;
    v13 = u;
    bdUserAccountID::bdUserAccountID(&v24, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int, _QWORD *))onClaimAchievement)(m_eventHandler, v14, context, v13, v12, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleClaimAchievement", 0xDB2u, "Failed to parse Marketplace item expiry message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0xE8ui64, 0x20ui64, (void (__fastcall *)(void *))bdMarketplaceInventory::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleConsoleBanned
==============
*/
_BOOL8 bdLobbyService::handleConsoleBanned(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned __int64 u; 

  u = 0i64;
  v4 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v4 )
    this->m_eventHandler->onConsoleBanned(this->m_eventHandler, u);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleDemonataPushMessage
==============
*/
char bdLobbyService::handleDemonataPushMessage(bdLobbyService *this, bdDemonataPushMessage *parsedMessage)
{
  const char *Schema; 
  const char *Sender; 
  bdDemonataPushMessageHandler *m_data; 
  const char *v7; 
  unsigned __int64 Length; 
  const char *Buffer; 
  int v10; 
  int i; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v12; 
  char v13; 
  const char *ContentType; 
  const char *BodyRaw; 
  bdString v17; 

  Schema = bdDemonataPushMessage::getSchema(parsedMessage);
  Sender = bdDemonataPushMessage::getSender(parsedMessage);
  bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleDemonataPushMessage", 0xFD4u, "Received Push Message from sender [%s] of schema [%s]", Sender, Schema);
  m_data = NULL;
  v7 = bdDemonataPushMessage::getSender(parsedMessage);
  bdString::bdString(&v17, v7);
  if ( !this->m_demonataPushHandlers.m_size )
    goto LABEL_7;
  Length = bdString::getLength(&v17);
  Buffer = bdString::getBuffer(&v17);
  v10 = 0;
  for ( i = 0; Length; --Length )
    v10 = (unsigned __int8)Buffer[i++] ^ (16777619 * v10);
  v12 = this->m_demonataPushHandlers.m_map[v10 & (this->m_demonataPushHandlers.m_capacity - 1)];
  if ( v12 )
  {
    while ( !bdString::operator==(&v17, &v12->m_key) )
    {
      v12 = v12->m_next;
      if ( !v12 )
        goto LABEL_7;
    }
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_demonataPushHandlers.m_numIterators, 1u);
    m_data = v12->m_data;
    bdHandleAssert(this->m_demonataPushHandlers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_demonataPushHandlers.m_numIterators, 0xFFFFFFFF);
    v13 = 1;
  }
  else
  {
LABEL_7:
    v13 = 0;
  }
  bdString::~bdString(&v17);
  if ( v13 )
  {
    m_data->handlePushMessage(m_data, parsedMessage);
    return 1;
  }
  else
  {
    ContentType = bdDemonataPushMessage::getContentType(parsedMessage);
    if ( _strcmpi(ContentType, "application/json") )
    {
      bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleDemonataPushMessage", 0xFE2u, "No handler registered for Demonata Push Message");
    }
    else
    {
      BodyRaw = (const char *)bdDemonataPushMessage::getBodyRaw(parsedMessage);
      bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleDemonataPushMessage", 0xFDEu, "No handler registered for Demonata JSON Push Message with content [%s]", BodyRaw);
    }
    return 0;
  }
}

/*
==============
bdLobbyService::handleEventLogFilteredCategories
==============
*/
_BOOL8 bdLobbyService::handleEventLogFilteredCategories(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdEventLog *m_eventLogManager; 
  bool v5; 
  unsigned int i; 
  unsigned int v8; 
  bdByteBuffer *m_ptr; 
  unsigned int u; 

  m_ptr = message.m_ptr;
  v8 = 0;
  u = 0;
  m_eventLogManager = this->m_eventLogManager;
  if ( !m_eventLogManager )
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleEventLogFilteredCategories", 0xC52u, "No event log manager to handle filtered categories");
LABEL_3:
    v5 = 0;
    goto LABEL_4;
  }
  bdEventLog::resetFilteredCategories(m_eventLogManager);
  if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v8) )
    goto LABEL_3;
  v5 = 1;
LABEL_4:
  for ( i = 0; i < v8; ++i )
    v5 = v5 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdEventLog::addFilteredCategory(this->m_eventLogManager, u);
  if ( v5 )
    bdEventLog::setReceivedCategoryData(this->m_eventLogManager, 1);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleEventLogFilteredCategories", 0xC64u, "Failed to parse filtered categories");
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleFeatureBan
==============
*/
_BOOL8 bdLobbyService::handleFeatureBan(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  bool v5; 
  unsigned int i; 
  bdByteBuffer *v7; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v10; 
  bdFeatureBanInfo v11; 
  unsigned __int8 v12; 
  unsigned int u; 

  v10 = -2i64;
  v12 = 0;
  v4 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, &v12);
  u = 0;
  v5 = v4 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v12 == 1 )
  {
    for ( i = 0; i < u; ++i )
    {
      if ( !v5 )
        break;
      bdFeatureBanInfo::bdFeatureBanInfo(&v11);
      v7 = (bdByteBuffer *)message.m_ptr->__vftable;
      buffer.m_ptr = v7;
      if ( v7 )
        _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
      if ( bdFeatureBanInfo::deserialize(&v11, (bdReference<bdByteBuffer>)&buffer) )
      {
        v5 = 1;
        this->m_eventHandler->onFeatureBan(this->m_eventHandler, &v11);
      }
      else
      {
        v5 = 0;
      }
      bdFeatureBanInfo::~bdFeatureBanInfo((bdFeatureBanInfo *)v11.gap20);
      bdReferencable::~bdReferencable((bdReferencable *)v11.gap20);
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleFeatureBan", 0xAFFu, "Unsupported feature ban message version.");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleFriendChatMsg
==============
*/
__int64 bdLobbyService::handleFriendChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  unsigned __int8 v6; 
  unsigned int length; 
  unsigned __int64 u[3]; 
  char s[8]; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  memset_0(blob, 0, sizeof(blob));
  length = 1024;
  if ( v5 && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v6 = 1;
    this->m_eventHandler->onInstantMessage(this->m_eventHandler, u[0], s, blob, length, 0i64);
  }
  else
  {
    v6 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleFriendDisconnected
==============
*/
__int64 bdLobbyService::handleFriendDisconnected(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  bool UInt64; 
  __int64 v7; 
  unsigned __int8 v8; 
  unsigned __int64 u[4]; 
  char s[8]; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  char v19; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0;
  if ( UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    v8 = 1;
    LOBYTE(v7) = eventType == BD_FRIEND_CONNECTED;
    this->m_eventHandler->onPlayerStatusUpdate(this->m_eventHandler, u[0], s, v7);
  }
  else
  {
    v8 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v8;
}

/*
==============
bdLobbyService::handleFriendRichPresenceUpdated
==============
*/
__int64 bdLobbyService::handleFriendRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  unsigned __int8 v5; 
  unsigned int length; 
  unsigned __int64 u[3]; 
  char s[8]; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  if ( !UInt64 || !bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    length = 1024;
    goto LABEL_6;
  }
  length = 1024;
  if ( !bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
LABEL_6:
    v5 = 0;
    goto LABEL_7;
  }
  v5 = 1;
  this->m_eventHandler->onRichPresenceUpdate(this->m_eventHandler, u[0], s, blob, length, 0i64);
LABEL_7:
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleGMSGBroadcast
==============
*/
__int64 bdLobbyService::handleGMSGBroadcast(bdLobbyService *this, bdEventType eventType, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v6; 
  bdLobbyEventHandler *m_eventHandler; 
  bdLobbyEventHandler_vtbl *v8; 
  unsigned int length; 
  unsigned __int64 u[3]; 
  char s[64]; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  s[0] = 0;
  memset_0(blob, 0, sizeof(blob));
  length = 1024;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v6 = 1;
    m_eventHandler = this->m_eventHandler;
    v8 = m_eventHandler->__vftable;
    if ( eventType == BD_GMSG_GROUP_MESSAGE )
      v8->onGroupMessagingMessage(m_eventHandler, u[0], s, blob, length);
    else
      v8->onBroadcastMessage(m_eventHandler, u[0], s, blob, length);
  }
  else
  {
    v6 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleGMSGBroadcast", 0xB1Fu, "Failed to deserialize group messaging message.");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleGlobalInstantMessage
==============
*/
__int64 bdLobbyService::handleGlobalInstantMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  unsigned __int8 v6; 
  unsigned int length; 
  unsigned __int64 u[3]; 
  char s[8]; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  unsigned __int8 blob[4096]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  memset_0(blob, 0, sizeof(blob));
  length = 4096;
  if ( v5 && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v6 = 1;
    this->m_eventHandler->onGlobalInstantMessage(this->m_eventHandler, u[0], s, blob, length);
  }
  else
  {
    v6 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleLinkedAccountStatusChange
==============
*/
_BOOL8 bdLobbyService::handleLinkedAccountStatusChange(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onLinkedAccountStatusChange)(bdLobbyEventHandler *, bdUserAccountID); 
  __int64 v8; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v11; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v13; 
  bdUserAccountID userID; 

  v11 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  if ( v5 )
  {
    m_eventHandler = this->m_eventHandler;
    onLinkedAccountStatusChange = m_eventHandler->onLinkedAccountStatusChange;
    bdUserAccountID::bdUserAccountID(&v13, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64))onLinkedAccountStatusChange)(m_eventHandler, v8);
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleLogonTimeProhibited
==============
*/
_BOOL8 bdLobbyService::handleLogonTimeProhibited(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned int length; 
  __int64 v7; 
  bdByteBuffer *m_ptr; 
  unsigned __int8 blob[1024]; 

  v7 = -2i64;
  m_ptr = message.m_ptr;
  memset_0(blob, 0, sizeof(blob));
  length = 1024;
  v4 = bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length);
  if ( v4 )
    this->m_eventHandler->onLogonTimeProhibited(this->m_eventHandler, blob, length);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleLogonTimeProhibitedWarning
==============
*/
__int64 bdLobbyService::handleLogonTimeProhibitedWarning(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned int length; 
  unsigned int u; 
  __int64 v8; 
  bdByteBuffer *m_ptr; 
  unsigned __int8 blob[1024]; 

  v8 = -2i64;
  m_ptr = message.m_ptr;
  u = 0;
  memset_0(blob, 0, sizeof(blob));
  length = 1024;
  if ( bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v4 = 1;
    this->m_eventHandler->onLogonTimeProhibitedWarning(this->m_eventHandler, u, blob, length);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleMarketingCommsAssignmentsAvailable
==============
*/
char bdLobbyService::handleMarketingCommsAssignmentsAvailable(bdLobbyService *this)
{
  this->m_eventHandler->onMarketingCommsAssignmentsAvailable(this->m_eventHandler);
  return 1;
}

/*
==============
bdLobbyService::handleMarketplaceBalanceUpdated
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceBalanceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  unsigned int i; 
  bdByteBuffer *v7; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onBalanceUpdate)(bdLobbyEventHandler *, const bdUserAccountID, const unsigned int, const bdMarketplaceCurrency *); 
  unsigned int v10; 
  __int64 v11; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v18; 
  bdUserAccountID userID; 
  _QWORD ptr[42]; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x38ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCurrency::bdMarketplaceCurrency, (void (__fastcall *)(void *))bdMarketplaceCurrency::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  if ( u[0] > 6 )
  {
    u[0] = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceBalanceUpdated", 0xD72u, "Too many [%d] updates in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v5 )
      goto LABEL_15;
    v7 = (bdByteBuffer *)message.m_ptr->__vftable;
    v14.m_ptr = v7;
    if ( v7 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
    if ( bdMarketplaceCurrency::deserialize((bdMarketplaceCurrency *)&ptr[7 * i], (bdReference<bdByteBuffer>)&v14) )
      v5 = 1;
    else
LABEL_15:
      v5 = 0;
  }
  if ( v5 )
  {
    m_eventHandler = this->m_eventHandler;
    onBalanceUpdate = m_eventHandler->onBalanceUpdate;
    v10 = u[0];
    bdUserAccountID::bdUserAccountID(&v18, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, _QWORD, _QWORD *))onBalanceUpdate)(m_eventHandler, v11, v10, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceBalanceUpdated", 0xD7Eu, "Failed to parse Marketplace balance update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x38ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCurrency::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleMarketplaceBalanceUpdatedV2
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceBalanceUpdatedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v8; 
  bdByteBuffer *m_ptr; 
  bdMarketplaceBalanceUpdatePushMessage v10; 

  v8 = -2i64;
  m_ptr = message.m_ptr;
  bdMarketplaceBalanceUpdatePushMessage::bdMarketplaceBalanceUpdatePushMessage(&v10);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = bdStructBufferDeserializerHelpers::deserializeFromBuffer((bdReference<bdByteBuffer>)&buffer, &v10);
  if ( v5 )
    this->m_eventHandler->onBalanceUpdate(this->m_eventHandler, &v10);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceBalanceUpdatedV2", 0xD8Eu, "Failed to parse Marketplace balance update v2 message");
  bdMarketplaceBalanceUpdatePushMessage::~bdMarketplaceBalanceUpdatePushMessage((bdMarketplaceBalanceUpdatePushMessage *)v10.gap378);
  bdReferencable::~bdReferencable((bdReferencable *)v10.gap378);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleMarketplaceCouponsGranted
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceCouponsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  unsigned int i; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onMarketplaceCouponsGranted)(bdLobbyEventHandler *, bdUserAccountID, char *, unsigned int, unsigned int, char (*)[25]); 
  unsigned int v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v15; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v17; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v19; 
  bdUserAccountID userID; 
  char context[8]; 
  __int64 v22; 
  char s[160]; 

  v17 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v22 = 0i64;
  u[1] = 0;
  u[0] = 0;
  memset_0(s, 0, 0x96ui64);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v15.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v15, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u[1]) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  for ( i = 0; i < u[0]; ++i )
    v6 = v6 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, &s[25 * i], 0x19ui64);
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onMarketplaceCouponsGranted = m_eventHandler->onMarketplaceCouponsGranted;
    v10 = u[0];
    v11 = u[1];
    bdUserAccountID::bdUserAccountID(&v19, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int, char *))onMarketplaceCouponsGranted)(m_eventHandler, v12, context, v11, v10, s);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsGranted", 0xC86u, "Failed to parse Marketplace coupon message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdated
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceCouponsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  unsigned int i; 
  bdByteBuffer *v8; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onInventoryCouponUpdate)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const bdMarketplaceCouponInventory *); 
  unsigned int v11; 
  __int64 v12; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v15; 
  bdReference<bdByteBuffer> v16; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v18; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v20; 
  bdUserAccountID userID; 
  _QWORD ptr[246]; 
  char context[8]; 
  __int64 v24; 

  v18 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x148ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventory::bdMarketplaceCouponInventory, (void (__fastcall *)(void *))bdMarketplaceCouponInventory::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v24 = 0i64;
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v16.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v16, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  if ( u[0] > 6 )
  {
    u[0] = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdated", 0xCE4u, "Too many [%d] updates in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v6 )
      goto LABEL_17;
    v8 = (bdByteBuffer *)message.m_ptr->__vftable;
    v15.m_ptr = v8;
    if ( v8 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
    if ( bdMarketplaceCouponInventory::deserialize((bdMarketplaceCouponInventory *)&ptr[41 * i], (bdReference<bdByteBuffer>)&v15) )
      v6 = 1;
    else
LABEL_17:
      v6 = 0;
  }
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onInventoryCouponUpdate = m_eventHandler->onInventoryCouponUpdate;
    v11 = u[0];
    bdUserAccountID::bdUserAccountID(&v20, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, _QWORD *))onInventoryCouponUpdate)(m_eventHandler, v12, context, v11, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdated", 0xCF0u, "Failed to parse Marketplace coupon update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x148ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventory::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV2
==============
*/
__int64 bdLobbyService::handleMarketplaceCouponsUpdatedV2(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  unsigned __int8 v6; 
  unsigned int i; 
  bdByteBuffer *v8; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onInventoryCouponUpdateV2)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const bdMarketplaceCouponInventoryV2 *); 
  unsigned int v11; 
  __int64 v12; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v15; 
  bdReference<bdByteBuffer> v16; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v18; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v20; 
  bdUserAccountID userID; 
  _QWORD ptr[246]; 
  char context[8]; 
  __int64 v24; 

  v18 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x148ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV2::bdMarketplaceCouponInventoryV2, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV2::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v24 = 0i64;
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) )
    goto LABEL_9;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v16.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( ContextSerialization::readContext((bdReference<bdByteBuffer>)&v16, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u) )
    v6 = 1;
  else
LABEL_9:
    v6 = 0;
  if ( u[0] > 6 )
  {
    u[0] = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV2", 0xD08u, "Too many [%d] updates in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v6 )
      goto LABEL_18;
    v8 = (bdByteBuffer *)message.m_ptr->__vftable;
    v15.m_ptr = v8;
    if ( v8 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
    if ( bdMarketplaceCouponInventoryV2::deserialize((bdMarketplaceCouponInventoryV2 *)&ptr[41 * i], (bdReference<bdByteBuffer>)&v15) )
      v6 = 1;
    else
LABEL_18:
      v6 = 0;
  }
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onInventoryCouponUpdateV2 = m_eventHandler->onInventoryCouponUpdateV2;
    v11 = u[0];
    bdUserAccountID::bdUserAccountID(&v20, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, _QWORD *))onInventoryCouponUpdateV2)(m_eventHandler, v12, context, v11, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV2", 0xD14u, "Failed to parse Marketplace coupon update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x148ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV2::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV3
==============
*/
__int64 bdLobbyService::handleMarketplaceCouponsUpdatedV3(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  unsigned __int8 v6; 
  unsigned int i; 
  bdByteBuffer *v8; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onInventoryCouponUpdateV3)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const bdMarketplaceCouponInventoryV3 *); 
  unsigned int v11; 
  __int64 v12; 
  int v14; 
  int v15; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v17; 
  bdReference<bdByteBuffer> v18; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v20; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v22; 
  bdUserAccountID userID; 
  _OWORD ptr[126]; 
  char context[8]; 
  __int64 v26; 

  v20 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x150ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV3::bdMarketplaceCouponInventoryV3, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV3::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v26 = 0i64;
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) )
    goto LABEL_9;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v18.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( ContextSerialization::readContext((bdReference<bdByteBuffer>)&v18, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u) )
    v6 = 1;
  else
LABEL_9:
    v6 = 0;
  if ( u[0] > 6 )
  {
    u[0] = 6;
    v15 = 6;
    v14 = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV3", 0xD2Cu, "Too many [%d] updates in push message. Code can only handle %d.", v14, v15);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v6 )
      goto LABEL_18;
    v8 = (bdByteBuffer *)message.m_ptr->__vftable;
    v17.m_ptr = v8;
    if ( v8 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
    if ( bdMarketplaceCouponInventoryV3::deserialize((bdMarketplaceCouponInventoryV3 *)&ptr[21 * i], (bdReference<bdByteBuffer>)&v17) )
      v6 = 1;
    else
LABEL_18:
      v6 = 0;
  }
  if ( v6 && (m_eventHandler = this->m_eventHandler) != NULL )
  {
    onInventoryCouponUpdateV3 = m_eventHandler->onInventoryCouponUpdateV3;
    v11 = u[0];
    bdUserAccountID::bdUserAccountID(&v22, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, _OWORD *))onInventoryCouponUpdateV3)(m_eventHandler, v12, context, v11, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV3", 0xD38u, "Failed to parse Marketplace coupon update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x150ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV3::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceCouponsUpdatedV4
==============
*/
__int64 bdLobbyService::handleMarketplaceCouponsUpdatedV4(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  unsigned __int8 v6; 
  unsigned int i; 
  bdByteBuffer *v8; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onInventoryCouponUpdateV4)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const bdMarketplaceCouponInventoryV4 *); 
  unsigned int v11; 
  __int64 v12; 
  int v14; 
  int v15; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v17; 
  bdReference<bdByteBuffer> v18; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v20; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v22; 
  bdUserAccountID userID; 
  _OWORD ptr[126]; 
  char context[8]; 
  __int64 v26; 

  v20 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x150ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV4::bdMarketplaceCouponInventoryV4, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV4::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v26 = 0i64;
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) )
    goto LABEL_9;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v18.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( ContextSerialization::readContext((bdReference<bdByteBuffer>)&v18, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u) )
    v6 = 1;
  else
LABEL_9:
    v6 = 0;
  if ( u[0] > 6 )
  {
    u[0] = 6;
    v15 = 6;
    v14 = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV4", 0xD50u, "Too many [%d] updates in push message. Code can only handle %d.", v14, v15);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v6 )
      goto LABEL_18;
    v8 = (bdByteBuffer *)message.m_ptr->__vftable;
    v17.m_ptr = v8;
    if ( v8 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
    if ( bdMarketplaceCouponInventoryV4::deserialize((bdMarketplaceCouponInventoryV4 *)&ptr[21 * i], (bdReference<bdByteBuffer>)&v17) )
      v6 = 1;
    else
LABEL_18:
      v6 = 0;
  }
  if ( v6 && (m_eventHandler = this->m_eventHandler) != NULL )
  {
    onInventoryCouponUpdateV4 = m_eventHandler->onInventoryCouponUpdateV4;
    v11 = u[0];
    bdUserAccountID::bdUserAccountID(&v22, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, _OWORD *))onInventoryCouponUpdateV4)(m_eventHandler, v12, context, v11, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceCouponsUpdatedV4", 0xD5Cu, "Failed to parse Marketplace coupon update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x150ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCouponInventoryV4::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceDepositGranted
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceDepositGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  unsigned int i; 
  bdByteBuffer *v7; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onDepositGranted)(bdLobbyEventHandler *, const bdUserAccountID, const unsigned int, const bdMarketplaceCurrency *); 
  unsigned int v10; 
  __int64 v11; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v18; 
  bdUserAccountID userID; 
  _QWORD ptr[42]; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0x38ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCurrency::bdMarketplaceCurrency, (void (__fastcall *)(void *))bdMarketplaceCurrency::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  if ( u[0] > 6 )
  {
    u[0] = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceDepositGranted", 0xDC8u, "Too many [%d] deposits granted in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v5 )
      goto LABEL_15;
    v7 = (bdByteBuffer *)message.m_ptr->__vftable;
    v14.m_ptr = v7;
    if ( v7 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
    if ( bdMarketplaceCurrency::deserialize((bdMarketplaceCurrency *)&ptr[7 * i], (bdReference<bdByteBuffer>)&v14) )
      v5 = 1;
    else
LABEL_15:
      v5 = 0;
  }
  if ( v5 )
  {
    m_eventHandler = this->m_eventHandler;
    onDepositGranted = m_eventHandler->onDepositGranted;
    v10 = u[0];
    bdUserAccountID::bdUserAccountID(&v18, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, _QWORD, _QWORD *))onDepositGranted)(m_eventHandler, v11, v10, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceDepositGranted", 0xDD4u, "Failed to parse Marketplace balance update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0x38ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceCurrency::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleMarketplaceEntitlementsGranted
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceEntitlementsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  __int64 i; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onEntitlementsGranted)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const unsigned int *); 
  unsigned int v10; 
  __int64 v11; 
  unsigned int u; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v18; 
  bdUserAccountID userID; 
  unsigned int v20[6]; 
  char context[8]; 
  __int64 v22; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v22 = 0i64;
  u = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v14.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v14, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( u > 6 )
  {
    u = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceEntitlementsGranted", 0xE39u, "Too many [%d] entitlements granted in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0i64; (unsigned int)i < u; i = (unsigned int)(i + 1) )
    v6 = v6 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v20[i]);
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onEntitlementsGranted = m_eventHandler->onEntitlementsGranted;
    v10 = u;
    bdUserAccountID::bdUserAccountID(&v18, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int *))onEntitlementsGranted)(m_eventHandler, v11, context, v10, v20);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceEntitlementsGranted", 0xE45u, "Failed to parse Marketplace entitlements granted message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceItemsExpired
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceItemsExpired(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  __int64 i; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onMarketplaceItemsExpired)(bdLobbyEventHandler *, bdUserAccountID, char *, unsigned int, unsigned int, unsigned int *); 
  unsigned int v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v15; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v17; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v19; 
  bdUserAccountID userID; 
  unsigned int v21[128]; 
  char context[8]; 
  __int64 v23; 

  v17 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v23 = 0i64;
  u[1] = 0;
  u[0] = 0;
  memset_0(v21, 0, sizeof(v21));
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v15.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v15, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u[1]) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  for ( i = 0i64; (unsigned int)i < u[0]; i = (unsigned int)(i + 1) )
    v6 = v6 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v21[i]);
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onMarketplaceItemsExpired = m_eventHandler->onMarketplaceItemsExpired;
    v10 = u[0];
    v11 = u[1];
    bdUserAccountID::bdUserAccountID(&v19, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int, unsigned int *))onMarketplaceItemsExpired)(m_eventHandler, v12, context, v11, v10, v21);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsExpired", 0xCA7u, "Failed to parse Marketplace item expiry message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceItemsGranted
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceItemsGranted(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  __int64 i; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onItemsGranted)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const unsigned int *); 
  unsigned int v10; 
  __int64 v11; 
  unsigned int u; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v18; 
  bdUserAccountID userID; 
  unsigned int v20[6]; 
  char context[8]; 
  __int64 v22; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v22 = 0i64;
  u = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v14.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v14, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( u > 6 )
  {
    u = 6;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsGranted", 0xDEDu, "Too many [%d] items granted in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0i64; (unsigned int)i < u; i = (unsigned int)(i + 1) )
    v6 = v6 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v20[i]);
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onItemsGranted = m_eventHandler->onItemsGranted;
    v10 = u;
    bdUserAccountID::bdUserAccountID(&v18, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int *))onItemsGranted)(m_eventHandler, v11, context, v10, v20);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsGranted", 0xDF9u, "Failed to parse Marketplace items granted message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  __int64 i; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onItemsGranted)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const unsigned int *, const unsigned int *); 
  unsigned int v10; 
  __int64 v11; 
  unsigned int u; 
  bdReference<bdByteBuffer> v14; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v16; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v18; 
  bdUserAccountID userID; 
  unsigned int v20[6]; 
  unsigned int v21[6]; 
  char context[8]; 
  __int64 v23; 

  v16 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v23 = 0i64;
  u = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v14.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v14, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( u > 6 )
  {
    u = 6;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity", 0xE13u, "Too many [%d] items granted in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0i64; (unsigned int)i < u; i = (unsigned int)(i + 1) )
    v6 = v6 && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v21[i]) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v20[i]);
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onItemsGranted = m_eventHandler->onItemsGranted;
    v10 = u;
    bdUserAccountID::bdUserAccountID(&v18, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, unsigned int *, unsigned int *))onItemsGranted)(m_eventHandler, v11, context, v10, v21, v20);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity", 0xE20u, "Failed to parse Marketplace items granted message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMarketplaceItemsUpdated
==============
*/
_BOOL8 bdLobbyService::handleMarketplaceItemsUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  bool v6; 
  unsigned int i; 
  const bdUserAccountID *v8; 
  bdByteBuffer_vtbl *v9; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onInventoryItemUpdate)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const unsigned int, const bdMarketplaceInventory *); 
  unsigned int v12; 
  __int64 v13; 
  unsigned int u[2]; 
  bdReference<bdByteBuffer> v16; 
  bdByteBuffer_vtbl *v17; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v19; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v21; 
  bdUserAccountID v22; 
  bdUserAccountID userID; 
  _QWORD ptr[174]; 
  char context[8]; 
  __int64 v26; 

  v19 = -2i64;
  m_ptr = message.m_ptr;
  `eh vector vbase constructor iterator'(ptr, 0xE8ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceInventory::bdMarketplaceInventory, (void (__fastcall *)(void *))bdMarketplaceInventory::`vbase destructor);
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v26 = 0i64;
  u[0] = 0;
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v16.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  v6 = ContextSerialization::readContext((bdReference<bdByteBuffer>)&v16, context, 0x10u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, u);
  if ( u[0] > 6 )
  {
    u[0] = 6;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsUpdated", 0xCC0u, "Too many [%d] updates in push message. Code can only handle %d.", 6, 6);
  }
  for ( i = 0; i < u[0]; ++i )
  {
    if ( !v6 )
      goto LABEL_17;
    bdUserAccountID::bdUserAccountID(&v21, &userID);
    v9 = message.m_ptr->__vftable;
    v17 = v9;
    if ( v9 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v9->allocateBuffer, 1u);
    if ( bdMarketplaceInventory::deserialize((bdMarketplaceInventory *)&ptr[29 * i], (bdReference<bdByteBuffer>)&v17, v8) )
      v6 = 1;
    else
LABEL_17:
      v6 = 0;
  }
  if ( v6 )
  {
    m_eventHandler = this->m_eventHandler;
    onInventoryItemUpdate = m_eventHandler->onInventoryItemUpdate;
    v12 = u[0];
    bdUserAccountID::bdUserAccountID(&v22, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, _QWORD, _QWORD *))onInventoryItemUpdate)(m_eventHandler, v13, context, v12, ptr);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceItemsUpdated", 0xCCCu, "Failed to parse Marketplace item update message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  `eh vector destructor iterator'(ptr, 0xE8ui64, 6ui64, (void (__fastcall *)(void *))bdMarketplaceInventory::`vbase destructor);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleMultipleLinkedAccountLogons
==============
*/
_BOOL8 bdLobbyService::handleMultipleLinkedAccountLogons(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onMultipleLinkedAccountLogons)(bdLobbyEventHandler *, bdUserAccountID); 
  __int64 v8; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v11; 
  bdByteBuffer *m_ptr; 
  bdUserAccountID v13; 
  bdUserAccountID userID; 

  v11 = -2i64;
  m_ptr = message.m_ptr;
  bdUserAccountID::bdUserAccountID(&userID);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID);
  if ( v5 )
  {
    m_eventHandler = this->m_eventHandler;
    onMultipleLinkedAccountLogons = m_eventHandler->onMultipleLinkedAccountLogons;
    bdUserAccountID::bdUserAccountID(&v13, &userID);
    ((void (__fastcall *)(bdLobbyEventHandler *, __int64))onMultipleLinkedAccountLogons)(m_eventHandler, v8);
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleMultipleLogons
==============
*/
_BOOL8 bdLobbyService::handleMultipleLogons(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned __int64 u; 

  u = 0i64;
  v4 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v4 )
    this->m_eventHandler->onMultipleLogon(this->m_eventHandler, u);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleNewMail
==============
*/
char bdLobbyService::handleNewMail(bdLobbyService *this)
{
  this->m_eventHandler->onNewMail(this->m_eventHandler);
  return 1;
}

/*
==============
bdLobbyService::handleNotWhiteListed
==============
*/
_BOOL8 bdLobbyService::handleNotWhiteListed(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned __int64 u; 

  u = 0i64;
  v4 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v4 )
    this->m_eventHandler->onNotWhiteListed(this->m_eventHandler, u);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleNotWhiteListedWithMessage
==============
*/
__int64 bdLobbyService::handleNotWhiteListedWithMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  unsigned __int8 v5; 
  unsigned __int64 u[4]; 
  char s[144]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  memset_0(s, 0, 0x8Dui64);
  if ( UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x8Cui64) )
  {
    v5 = 1;
    this->m_eventHandler->onNotWhiteListedWithMessage(this->m_eventHandler, u[0], s);
  }
  else
  {
    v5 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleNotifyLeave
==============
*/
__int64 bdLobbyService::handleNotifyLeave(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  unsigned __int8 v6; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onNotifyLeave)(bdLobbyEventHandler *, unsigned __int64, bdSessionID); 
  __int64 v9; 
  unsigned int length[2]; 
  unsigned __int64 u[4]; 
  bdSessionID v13; 
  bdSessionID other; 
  char s[8]; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  bdSessionID::bdSessionID(&other);
  length[0] = 8;
  if ( v5 && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, other._bytes_20, length) )
  {
    v6 = 1;
    m_eventHandler = this->m_eventHandler;
    onNotifyLeave = m_eventHandler->onNotifyLeave;
    bdSessionID::bdSessionID(&v13, &other);
    ((void (__fastcall *)(bdLobbyEventHandler *, unsigned __int64, __int64))onNotifyLeave)(m_eventHandler, u[0], v9);
  }
  else
  {
    v6 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleNotifyLeave", 0xA30u, "Failed to read sessionID for session invite.");
  }
  bdSecurityID::~bdSecurityID((bdSecurityID *)other._bytes_20);
  bdSerializable::~bdSerializable((bdSerializable *)other._bytes_20);
  bdTaskResult::~bdTaskResult((bdTaskResult *)(&other.__vftable + 2));
  bdReferencable::~bdReferencable((bdReferencable *)&other._bytes_20[8]);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handlePlayerBanned
==============
*/
__int64 bdLobbyService::handlePlayerBanned(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  __int64 i; 
  unsigned __int64 v7[8]; 
  unsigned int v8; 
  unsigned int u; 

  v7[1] = -2i64;
  v7[0] = 0i64;
  u = 0;
  i = -1i64;
  v8 = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, v7) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readInt64((bdByteBuffer *)message.m_ptr->__vftable, &i) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v8) )
  {
    v4 = 1;
    this->m_eventHandler->onPlayerBanned(this->m_eventHandler, v7[0], u, i, v8);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handlePlayerDisconnected
==============
*/
__int64 bdLobbyService::handlePlayerDisconnected(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned int v6; 
  unsigned __int64 u; 

  u = 0i64;
  v6 = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v6) )
  {
    v4 = 1;
    this->m_eventHandler->onPlayerDisconnected(this->m_eventHandler, u, (bdAntiCheat::bdAntiCheatReason)v6);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handlePrivateProfileUpdate
==============
*/
_BOOL8 bdLobbyService::handlePrivateProfileUpdate(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  bool b; 
  bdByteBuffer *m_ptr; 

  m_ptr = message.m_ptr;
  b = 0;
  this->m_eventHandler->onUserPrivateProfileUpdated(this->m_eventHandler);
  v4 = bdByteBuffer::readBool((bdByteBuffer *)message.m_ptr->__vftable, &b);
  if ( v4 )
    this->m_eventHandler->onUserPrivateProfileUpdatedWithCallerInfo(this->m_eventHandler, b);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePrivateProfileUpdate", 0xF74u, "Failed to parse bdProfileService (Private profile updated) push message");
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handlePublisherVariablesUpdateMessage
==============
*/
__int64 bdLobbyService::handlePublisherVariablesUpdateMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  bool b; 
  unsigned int u; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v9; 
  bdByteBuffer *m_ptr; 
  __int64 context[2]; 
  __int64 s[4]; 

  v9 = -2i64;
  m_ptr = message.m_ptr;
  u = 0;
  context[0] = 0i64;
  context[1] = 0i64;
  memset(s, 0, sizeof(s));
  b = 0;
  buffer.m_ptr = (bdByteBuffer *)message.m_ptr->__vftable;
  if ( buffer.m_ptr )
    _InterlockedExchangeAdd((volatile signed __int32 *)&buffer.m_ptr->m_refCount, 1u);
  if ( ContextSerialization::readContext((bdReference<bdByteBuffer>)&buffer, (char *)context, 0x10u) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, (char *const)s, 0x20ui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readBool((bdByteBuffer *)message.m_ptr->__vftable, &b) )
  {
    v4 = 1;
    this->m_eventHandler->onPublisherVariablesUpdate(this->m_eventHandler, (const char *)context, (const char *)s, HIWORD(u), u, b);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePublisherVariablesUpdateMessage", 0xF35u, "Failed to parse bdPublisherVariables message");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handlePushMessage
==============
*/
void bdLobbyService::handlePushMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned int v4; 
  bool String; 
  bdRemoteTaskManager *m_taskManager; 
  bdByteBuffer *v7; 
  bdByteBuffer *v8; 
  bdByteBuffer *v9; 
  bdByteBuffer *v10; 
  bdEventLog *m_eventLogManager; 
  bool v12; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v13; 
  bdPushMessageHandler *m_data; 
  void (__fastcall *handlePushMessage)(bdPushMessageHandler *, bdEventType, bdReference<bdByteBuffer>); 
  bdByteBuffer_vtbl *v16; 
  const char *v17; 
  bdByteBuffer *v18; 
  bool v19; 
  __int64 v20; 
  bdByteBuffer *v21; 
  bdByteBuffer *v22; 
  bool v23; 
  char v24; 
  bdByteBuffer_vtbl *v25; 
  bdByteBuffer *v26; 
  bool UInt64; 
  char v28; 
  bdByteBuffer *v29; 
  bdByteBuffer *v30; 
  bdByteBuffer *v31; 
  bdByteBuffer *v32; 
  bdByteBuffer *v33; 
  bdByteBuffer *v34; 
  bdByteBuffer *v35; 
  bdByteBuffer *v36; 
  bool v37; 
  bool v38; 
  bdByteBuffer *v39; 
  bdByteBuffer *v40; 
  bool v41; 
  bdByteBuffer *v42; 
  bool v43; 
  bool v44; 
  bdLobbyEventHandler *v45; 
  void (__fastcall *onNotifyLeave)(bdLobbyEventHandler *, unsigned __int64, bdSessionID); 
  __int64 v47; 
  bdByteBuffer *v48; 
  bdByteBuffer *v49; 
  bdByteBuffer *v50; 
  bdByteBuffer *v51; 
  bdByteBuffer *v52; 
  bdByteBuffer *v53; 
  bdLobbyEventHandler *v54; 
  void (__fastcall *onMultipleLinkedAccountLogons)(bdLobbyEventHandler *, bdUserAccountID); 
  __int64 v56; 
  bdByteBuffer *v57; 
  bdLobbyEventHandler *v58; 
  void (__fastcall *onLinkedAccountStatusChange)(bdLobbyEventHandler *, bdUserAccountID); 
  __int64 v60; 
  bdByteBuffer *v61; 
  bdByteBuffer *v62; 
  bool v63; 
  bdByteBuffer *v64; 
  bool v65; 
  bool v66; 
  bdByteBuffer *v67; 
  bool v68; 
  bdByteBuffer *v69; 
  bdByteBuffer *v70; 
  bdLobbyEventHandler *v71; 
  bdLobbyEventHandler_vtbl *v72; 
  bdByteBuffer *v73; 
  bdByteBuffer *v74; 
  bdByteBuffer *v75; 
  bdByteBuffer *v76; 
  bdByteBuffer *v77; 
  bdByteBuffer *v78; 
  bdByteBuffer *v79; 
  bdByteBuffer *v80; 
  bdByteBuffer *v81; 
  bdByteBuffer *v82; 
  bdByteBuffer *v83; 
  bdByteBuffer *v84; 
  bdByteBuffer *v85; 
  bdByteBuffer *v86; 
  bdByteBuffer *v87; 
  bdByteBuffer *v88; 
  bdByteBuffer *v89; 
  bdByteBuffer *v90; 
  bdByteBuffer *v91; 
  bdByteBuffer *v92; 
  bdByteBuffer *v93; 
  bdByteBuffer *v94; 
  bdByteBuffer *v95; 
  bdByteBuffer *v96; 
  bdByteBuffer *v97; 
  bdByteBuffer *v98; 
  bdByteBuffer *v99; 
  bdByteBuffer *v100; 
  bdByteBuffer *v101; 
  bdByteBuffer *v102; 
  bdByteBuffer *v103; 
  bdByteBuffer *v104; 
  bdByteBuffer *v105; 
  bdTencent *m_tencent; 
  bdByteBuffer *v107; 
  bdByteBuffer *v108; 
  bdByteBuffer *v109; 
  bdByteBuffer *m_ptr; 
  bdByteBuffer *v111; 
  bdByteBuffer *v112; 
  bdByteBuffer *v113; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onTencentUsernameChanged)(bdLobbyEventHandler *, const char *, unsigned int); 
  _BYTE *v116; 
  bdEventType v117; 
  BOOL function; 
  unsigned int line; 
  __int64 v120; 
  const char *v121; 
  const char *v122; 
  unsigned __int8 b; 
  bool v124; 
  bool v125; 
  unsigned __int8 v126; 
  bdEventType eventType; 
  unsigned int u; 
  bdReference<bdByteBuffer> v129; 
  unsigned int v130; 
  bdByteBuffer *v131; 
  bdByteBuffer *v132; 
  bdReference<bdByteBuffer> v133; 
  unsigned int v134; 
  unsigned int v135; 
  unsigned int v136; 
  unsigned int v137; 
  unsigned int v138; 
  bdReference<bdByteBuffer> v139; 
  bdReference<bdByteBuffer> v140; 
  bdReference<bdByteBuffer> v141; 
  bdReference<bdByteBuffer> v142; 
  bdReference<bdByteBuffer> v143; 
  bdByteBuffer *v144; 
  bdByteBuffer *v145; 
  bdReference<bdByteBuffer> v146; 
  bdReference<bdByteBuffer> v147; 
  bdReference<bdByteBuffer> v148; 
  bdReference<bdByteBuffer> v149; 
  bdReference<bdByteBuffer> v150; 
  unsigned int category; 
  unsigned int length; 
  unsigned int v153; 
  unsigned int v154; 
  unsigned int v155; 
  unsigned int v156; 
  unsigned int v157; 
  unsigned int v158; 
  unsigned int v159; 
  unsigned int v160; 
  unsigned int v161; 
  unsigned int v162; 
  unsigned int interval; 
  unsigned int v164; 
  unsigned int v165; 
  bdByteBuffer *v166; 
  bdReference<bdByteBuffer> v167; 
  bdReference<bdByteBuffer> v168; 
  bdReference<bdByteBuffer> v169; 
  bdReference<bdByteBuffer> v170; 
  bdReference<bdByteBuffer> v171; 
  bdReference<bdByteBuffer> v172; 
  bdReference<bdByteBuffer> v173; 
  unsigned int v174; 
  bdReference<bdByteBuffer> v175; 
  bdReference<bdByteBuffer> v176; 
  bdReference<bdByteBuffer> v177; 
  bdReference<bdByteBuffer> v178; 
  bdReference<bdByteBuffer> v179; 
  bdReference<bdByteBuffer> v180; 
  bdReference<bdByteBuffer> v181; 
  bdReference<bdByteBuffer> v182; 
  bdReference<bdByteBuffer> v183; 
  bdReference<bdByteBuffer> v184; 
  bdReference<bdByteBuffer> v185; 
  bdReference<bdByteBuffer> v186; 
  bdReference<bdByteBuffer> v187; 
  unsigned int v188; 
  unsigned __int64 v189; 
  bdReference<bdByteBuffer> v190; 
  bdReference<bdByteBuffer> v191; 
  bdReference<bdByteBuffer> v192; 
  bdReference<bdByteBuffer> v193; 
  bdReference<bdByteBuffer> v194; 
  bdReference<bdByteBuffer> v195; 
  unsigned __int64 v196; 
  unsigned __int64 v197; 
  bdReference<bdByteBuffer> messagea; 
  bdReference<bdByteBuffer> v199; 
  bdReference<bdByteBuffer> v200; 
  bdReference<bdByteBuffer> v201; 
  bdReference<bdByteBuffer> v202; 
  bdReference<bdByteBuffer> v203; 
  bdReference<bdByteBuffer> v204; 
  unsigned __int64 v205; 
  bdReference<bdByteBuffer> v206; 
  unsigned __int64 v207; 
  unsigned __int64 v208; 
  bdReference<bdByteBuffer> v209; 
  unsigned __int64 v210; 
  unsigned __int64 v211; 
  __int64 i; 
  unsigned __int64 v213; 
  unsigned __int64 v214; 
  bdReference<bdByteBuffer> buffer; 
  bdReference<bdByteBuffer> v216; 
  unsigned __int64 v217; 
  unsigned __int64 v218; 
  unsigned __int64 v219; 
  bdReference<bdByteBuffer> v220; 
  unsigned __int64 v221; 
  bdByteBuffer_vtbl *v222; 
  unsigned __int64 v223; 
  unsigned __int64 v224; 
  unsigned __int64 v225; 
  unsigned __int64 v226; 
  bdReference<bdByteBuffer> v227; 
  bdReference<bdByteBuffer> v228; 
  bdReference<bdByteBuffer> v229; 
  bdReference<bdByteBuffer> v230; 
  bdReference<bdByteBuffer> v231; 
  bdReference<bdByteBuffer> v232; 
  bdReference<bdByteBuffer> v233; 
  bdReference<bdByteBuffer> v234; 
  unsigned __int64 v235; 
  bdReference<bdByteBuffer> v236; 
  bdReference<bdByteBuffer> v237; 
  bdReference<bdByteBuffer> v238; 
  bdReference<bdByteBuffer> v239; 
  bdReference<bdByteBuffer> v240; 
  bdReference<bdByteBuffer> v241; 
  bdReference<bdByteBuffer> v242; 
  bdReference<bdByteBuffer> v243; 
  bdReference<bdByteBuffer> v244; 
  bdReference<bdByteBuffer> v245; 
  unsigned __int64 v246; 
  unsigned __int64 v247; 
  unsigned __int64 v248; 
  unsigned __int64 v249; 
  bdReference<bdByteBuffer> v250; 
  bdReference<bdByteBuffer> v251; 
  bdReference<bdByteBuffer> v252; 
  bdReference<bdByteBuffer> v253; 
  bdReference<bdByteBuffer> v254; 
  unsigned __int64 v255; 
  unsigned __int64 v256; 
  unsigned __int64 v257; 
  unsigned __int64 v258[3]; 
  bdFeatureBanInfo v259; 
  bdTencentAASRecord v260; 
  bdSessionID v261; 
  bdUserAccountID v262; 
  bdUserAccountID v263; 
  bdSessionID other; 
  bdUserAccountID userID; 
  bdUserAccountID v266; 
  bdMarketplaceBalanceUpdatePushMessage v267; 
  bdTSSStructMessage v268; 
  bdSessionInvite v269; 
  bdDemonataPushMessage parsedMessage; 
  bdDemonataPushMessage v271; 
  char s[8]; 
  __int64 v273; 
  __int64 v274; 
  __int64 v275; 
  __int64 v276; 
  __int64 v277; 
  __int64 v278; 
  __int64 v279; 
  char v280; 
  char v281[8]; 
  __int64 v282; 
  __int64 v283; 
  __int64 v284; 
  __int64 v285; 
  __int64 v286; 
  __int64 v287; 
  __int64 v288; 
  char v289; 
  char v290[8]; 
  __int64 v291; 
  __int64 v292; 
  __int64 v293; 
  __int64 v294; 
  __int64 v295; 
  __int64 v296; 
  __int64 v297; 
  char v298; 
  char v299[8]; 
  __int64 v300; 
  __int64 v301; 
  __int64 v302; 
  __int64 v303; 
  __int64 v304; 
  __int64 v305; 
  __int64 v306; 
  char v307[8]; 
  __int64 v308; 
  __int64 v309; 
  __int64 v310; 
  __int64 v311; 
  __int64 v312; 
  __int64 v313; 
  __int64 v314; 
  char v315[8]; 
  __int64 v316; 
  __int64 v317; 
  __int64 v318; 
  __int64 v319; 
  __int64 v320; 
  __int64 v321; 
  __int64 v322; 
  char v323[8]; 
  __int64 v324; 
  __int64 v325; 
  __int64 v326; 
  __int64 v327; 
  __int64 v328; 
  __int64 v329; 
  __int64 v330; 
  char v331[8]; 
  __int64 v332; 
  __int64 v333; 
  __int64 v334; 
  __int64 v335; 
  __int64 v336; 
  __int64 v337; 
  __int64 v338; 
  char v339[64]; 
  char v340[48]; 
  char v341[48]; 
  char v342[80]; 
  char v343[144]; 
  char Buf[1024]; 
  unsigned __int8 v345[1024]; 
  unsigned __int8 blob[1024]; 
  unsigned __int8 v347[1024]; 
  unsigned __int8 v348[1024]; 
  unsigned __int8 v349[1024]; 
  unsigned __int8 v350[1024]; 
  unsigned __int8 v351[1024]; 
  unsigned __int8 v352[4096]; 
  unsigned __int8 v353[4096]; 

  v258[2] = -2i64;
  v258[1] = (unsigned __int64)message.m_ptr;
  v4 = 0;
  u = 0;
  String = bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( String )
  {
    eventType = u;
    switch ( u )
    {
      case 0x14u:
        m_taskManager = this->m_taskManager;
        v7 = (bdByteBuffer *)message.m_ptr->__vftable;
        buffer.m_ptr = v7;
        if ( v7 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
        bdRemoteTaskManager::handleAsyncResult(m_taskManager, (const bdReference<bdByteBuffer>)&buffer);
        goto LABEL_3;
      case 0xC7u:
        bdDemonataPushMessage::bdDemonataPushMessage(&parsedMessage);
        v8 = (bdByteBuffer *)message.m_ptr->__vftable;
        v216.m_ptr = v8;
        if ( v8 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
        bdDemonataPushMessage::initFromBuffer(&parsedMessage, (bdReference<bdByteBuffer>)&v216);
        bdLobbyService::handleDemonataPushMessage(this, &parsedMessage);
LABEL_467:
        bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>((bdReference<bdByteBuffer> *)message.m_ptr);
        return;
      case 0xC8u:
        bdDemonataPushMessage::bdDemonataPushMessage(&v271);
        v9 = (bdByteBuffer *)message.m_ptr->__vftable;
        v220.m_ptr = v9;
        if ( v9 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v9->m_refCount, 1u);
        bdDemonataPushMessage::initFromBufferWithProtobuf(&v271, (bdReference<bdByteBuffer>)&v220);
        bdLobbyService::handleDemonataPushMessage(this, &v271);
        goto LABEL_467;
    }
    if ( u != 45 )
    {
      if ( this->m_pushHandlers.m_size && (v13 = this->m_pushHandlers.m_map[(this->m_pushHandlers.m_capacity - 1) & (HIBYTE(u) ^ (16777619 * (BYTE2(u) ^ (16777619 * (BYTE1(u) ^ (16777619 * (unsigned __int8)u))))))]) != NULL )
      {
        while ( u != v13->m_key )
        {
          v13 = v13->m_next;
          if ( !v13 )
            goto LABEL_48;
        }
        _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_pushHandlers.m_numIterators, 1u);
        m_data = v13->m_data;
        bdHandleAssert(this->m_pushHandlers.m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<enum bdEventType,class bdPushMessageHandler *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
        _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_pushHandlers.m_numIterators, 0xFFFFFFFF);
        handlePushMessage = m_data->handlePushMessage;
        v16 = message.m_ptr->__vftable;
        v222 = v16;
        if ( v16 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v16->allocateBuffer, 1u);
        ((void (__fastcall *)(bdPushMessageHandler *, _QWORD, bdByteBuffer_vtbl **))handlePushMessage)(m_data, (unsigned int)eventType, &v222);
      }
      else
      {
LABEL_48:
        if ( this->m_eventHandler )
        {
          v17 = bdEventTypeToString((const bdEventType)u);
          bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x7CBu, "Push Message of type [%d][%s]", eventType, v17);
          if ( eventType > BD_TENCENT_ANTIBOT_DATA )
          {
            switch ( eventType )
            {
              case BD_TENCENT_ANTIBOT_PUNISH:
                v104 = (bdByteBuffer *)message.m_ptr->__vftable;
                v252.m_ptr = v104;
                if ( v104 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v104->m_refCount, 1u);
                String = bdLobbyService::handleTencentAntiBotPunish(this, (bdReference<bdByteBuffer>)&v252);
                break;
              case BD_TENCENT_REWARD:
                m_ptr = (bdByteBuffer *)message.m_ptr->__vftable;
                v133.m_ptr = m_ptr;
                if ( m_ptr )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
                  m_ptr = v133.m_ptr;
                }
                v255 = 0i64;
                v164 = 0;
                v130 = 0;
                if ( bdByteBuffer::readUInt64(m_ptr, &v255) && bdByteBuffer::readUInt32(v133.m_ptr, &v164) && bdByteBuffer::readString(v133.m_ptr, v340, 0x2Dui64) && bdByteBuffer::readUInt32(v133.m_ptr, &v130) && v130 <= 0x1000 && bdByteBuffer::readBlob(v133.m_ptr, v353, &v130) )
                {
                  String = 1;
                  this->m_eventHandler->onTencentPlayerReward(this->m_eventHandler, v255, v164, v340, v130, v353);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentReward", 0xC0Du, "Failed to parse reward message");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v133);
                break;
              case BD_TENCENT_ANTIBOT_SERVER_READY:
                v105 = (bdByteBuffer *)message.m_ptr->__vftable;
                v173.m_ptr = v105;
                if ( v105 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v105->m_refCount, 1u);
                  v105 = v173.m_ptr;
                }
                v126 = 0;
                String = bdByteBuffer::readUByte8(v105, &v126);
                interval = 30;
                bdByteBuffer::readUInt32(v173.m_ptr, &interval);
                if ( bdLobbyService::getStatus(this) == BD_NOT_CONNECTED )
                {
                  m_tencent = this->m_tencent;
                  if ( m_tencent )
                    goto LABEL_417;
                  v107 = (bdByteBuffer *)bdMemory::allocate(0x50018ui64);
                  v129.m_ptr = v107;
                  if ( v107 )
                    bdTencent::bdTencent((bdTencent *)v107, this->m_taskManager);
                  else
                    m_tencent = NULL;
                  this->m_tencent = m_tencent;
                  if ( m_tencent )
LABEL_417:
                    bdTencent::setAntibotSendDataInterval(m_tencent, interval);
                }
                else
                {
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTencent", 0x4A7u, "Not connected.");
                }
                if ( String )
                {
                  if ( v126 == 1 )
                    this->m_eventHandler->onTencentAntibotServerReady(this->m_eventHandler);
                  else
                    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAntibotServerReady", 0xB9Du, "Invalid antibot server ready message version.");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v173);
                break;
              case BD_TENCENT_NAME_CHANGED:
                v113 = (bdByteBuffer *)message.m_ptr->__vftable;
                v185.m_ptr = v113;
                if ( v113 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v113->m_refCount, 1u);
                  v113 = v185.m_ptr;
                }
                memset_0(Buf, 0, sizeof(Buf));
                String = bdByteBuffer::readString(v113, Buf, 0x400ui64);
                if ( String )
                {
                  m_eventHandler = this->m_eventHandler;
                  onTencentUsernameChanged = m_eventHandler->onTencentUsernameChanged;
                  v116 = memchr_0(Buf, 0, 0x400ui64);
                  if ( v116 )
                    onTencentUsernameChanged(m_eventHandler, Buf, v116 - Buf);
                  else
                    onTencentUsernameChanged(m_eventHandler, Buf, 1024u);
                }
                else
                {
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentNameChanged", 0xC44u, "Failed to parse name change connection data");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v185);
                break;
              case BD_TENCENT_USER_LEAVE_REASON:
                v108 = (bdByteBuffer *)message.m_ptr->__vftable;
                v253.m_ptr = v108;
                if ( v108 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v108->m_refCount, 1u);
                String = bdLobbyService::handleTencentUserLeaveReason(this, (bdReference<bdByteBuffer>)&v253);
                break;
              case BD_TENCENT_LOUDSPEAKER_MESSAGE:
                v109 = (bdByteBuffer *)message.m_ptr->__vftable;
                v254.m_ptr = v109;
                if ( v109 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v109->m_refCount, 1u);
                String = bdLobbyService::handleTencentLoudSpeakerMessage(this, (bdReference<bdByteBuffer>)&v254);
                break;
              case BD_TENCENT_NO_REWARD:
                v111 = (bdByteBuffer *)message.m_ptr->__vftable;
                v143.m_ptr = v111;
                if ( v111 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v111->m_refCount, 1u);
                  v111 = v143.m_ptr;
                }
                v256 = 0i64;
                v174 = 0;
                if ( bdByteBuffer::readUInt64(v111, &v256) && bdByteBuffer::readUInt32(v143.m_ptr, &v174) && bdByteBuffer::readString(v143.m_ptr, v341, 0x2Dui64) )
                {
                  String = 1;
                  this->m_eventHandler->onTencentPlayerNoReward(this->m_eventHandler, v256, v174, v341);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentNoRewardReceived", 0xC22u, "Failed to parse reward message");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v143);
                break;
              case BD_TENCENT_SECURITY_RATING:
                v112 = (bdByteBuffer *)message.m_ptr->__vftable;
                v184.m_ptr = v112;
                if ( v112 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v112->m_refCount, 1u);
                bdTSSStructMessage::bdTSSStructMessage(&v268);
                v129.m_ptr = v184.m_ptr;
                if ( v184.m_ptr )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v184.m_ptr->m_refCount, 1u);
                String = bdStructBufferDeserializerHelpers::deserializeFromBuffer((bdReference<bdByteBuffer>)&v129, &v268);
                if ( String )
                  this->m_eventHandler->onTSSResponseReceived(this->m_eventHandler, &v268);
                else
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTSSResponse", 0xC33u, "Failed to deserialize TSS message");
                bdTSSStructMessage::~bdTSSStructMessage((bdTSSStructMessage *)v268.gap418);
                bdReferencable::~bdReferencable((bdReferencable *)v268.gap418);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v184);
                break;
              default:
LABEL_464:
                LODWORD(v120) = eventType;
                bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x8B6u, "Received Push Message of invalid type[%d]", v120);
                break;
            }
          }
          else if ( eventType == BD_TENCENT_ANTIBOT_DATA )
          {
            v103 = (bdByteBuffer *)message.m_ptr->__vftable;
            v251.m_ptr = v103;
            if ( v103 )
              _InterlockedExchangeAdd((volatile signed __int32 *)&v103->m_refCount, 1u);
            String = bdLobbyService::handleTencentAntiBotData(this, (bdReference<bdByteBuffer>)&v251);
          }
          else
          {
            switch ( eventType )
            {
              case BD_NEW_NOTIFICATION:
                this->m_eventHandler->onNewNotification(this->m_eventHandler);
                break;
              case BD_FRIENDSHIP_PROPOSAL:
                this->m_eventHandler->onFriendshipProposal(this->m_eventHandler);
                break;
              case BD_TEAM_PROPOSAL:
                this->m_eventHandler->onTeamProposal(this->m_eventHandler);
                break;
              case BD_FRIEND_CONNECTED:
              case BD_FRIEND_DISCONNECTED:
                v18 = (bdByteBuffer *)message.m_ptr->__vftable;
                v145 = v18;
                if ( v18 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v18->m_refCount, 1u);
                  v18 = v145;
                }
                v235 = 0i64;
                v19 = bdByteBuffer::readUInt64(v18, &v235);
                *(_QWORD *)s = 0i64;
                v273 = 0i64;
                v274 = 0i64;
                v275 = 0i64;
                v276 = 0i64;
                v277 = 0i64;
                v278 = 0i64;
                v279 = 0i64;
                v280 = 0;
                if ( v19 && bdByteBuffer::readString(v145, s, 0x40ui64) )
                {
                  String = 1;
                  LOBYTE(v20) = eventType == BD_FRIEND_CONNECTED;
                  this->m_eventHandler->onPlayerStatusUpdate(this->m_eventHandler, v235, s, v20);
                }
                else
                {
                  String = 0;
                }
                if ( !v145 || _InterlockedExchangeAdd((volatile signed __int32 *)&v145->m_refCount, 0xFFFFFFFF) != 1 )
                  break;
                v21 = v145;
                goto LABEL_68;
              case BD_SESSION_INVITATION:
                v25 = message.m_ptr->__vftable;
                v166 = (bdByteBuffer *)v25;
                if ( v25 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v25->allocateBuffer, 1u);
                bdSessionInvite::bdSessionInvite(&v269);
                v190.m_ptr = v166;
                if ( v166 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v166->m_refCount, 1u);
                String = bdSessionInvite::deserialize(&v269, (bdReference<bdByteBuffer>)&v190);
                if ( String )
                  this->m_eventHandler->onSessionInvite(this->m_eventHandler, &v269);
                else
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleSessionInvitation", 0x8F7u, "Failed to read session invite.");
                bdSessionInvite::~bdSessionInvite((bdSessionInvite *)&v269.gap494[4]);
                bdReferencable::~bdReferencable((bdReferencable *)&v269.gap494[4]);
                if ( !v166 || _InterlockedExchangeAdd((volatile signed __int32 *)&v166->m_refCount, 0xFFFFFFFF) != 1 )
                  break;
                v21 = v166;
                goto LABEL_68;
              case BD_CHANNEL_CHAT_BROADCAST_MSG:
              case BD_CHANNEL_CHAT_WHISPER_MSG:
                v26 = (bdByteBuffer *)message.m_ptr->__vftable;
                v131 = v26;
                if ( v26 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v26->m_refCount, 1u);
                  v26 = v131;
                }
                v258[0] = 0i64;
                UInt64 = bdByteBuffer::readUInt64(v26, v258);
                *(_QWORD *)v299 = 0i64;
                v300 = 0i64;
                v301 = 0i64;
                v302 = 0i64;
                v303 = 0i64;
                v304 = 0i64;
                v305 = 0i64;
                v306 = 0i64;
                if ( UInt64 && bdByteBuffer::readString(v131, v299, 0x40ui64) )
                {
                  v197 = 0i64;
                  if ( bdByteBuffer::readUInt64(v131, &v197) )
                  {
                    v28 = 1;
                    goto LABEL_103;
                  }
                }
                else
                {
                  v197 = 0i64;
                }
                v28 = 0;
LABEL_103:
                memset_0(blob, 0, sizeof(blob));
                length = 1024;
                if ( v28 && bdByteBuffer::readBlob(v131, blob, &length) )
                {
                  v135 = 0;
                  if ( bdByteBuffer::readUInt32(v131, &v135) )
                  {
                    String = 1;
                    this->m_eventHandler->onChatChannelMessage(this->m_eventHandler, v197, v258[0], v299, v135, blob, length);
                    goto LABEL_109;
                  }
                }
                else
                {
                  v135 = 0;
                }
                String = 0;
LABEL_109:
                if ( !v131 || _InterlockedExchangeAdd((volatile signed __int32 *)&v131->m_refCount, 0xFFFFFFFF) != 1 )
                  break;
                v21 = v131;
                goto LABEL_68;
              case BD_CHANNEL_USER_SUBSCRIBED:
              case BD_CHANNEL_USER_UNSUBSCRIBED:
                v30 = (bdByteBuffer *)message.m_ptr->__vftable;
                v199.m_ptr = v30;
                if ( v30 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v30->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserSubscription(this, (bdReference<bdByteBuffer>)&v199, eventType);
                break;
              case BD_TEAMMEMBER_CONNECTED:
              case BD_TEAMMEMBER_DISCONNECTED:
                v22 = (bdByteBuffer *)message.m_ptr->__vftable;
                v132 = v22;
                if ( v22 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v22->m_refCount, 1u);
                  v22 = v132;
                }
                v257 = 0i64;
                v23 = bdByteBuffer::readUInt64(v22, &v257);
                *(_QWORD *)v290 = 0i64;
                v291 = 0i64;
                v292 = 0i64;
                v293 = 0i64;
                v294 = 0i64;
                v295 = 0i64;
                v296 = 0i64;
                v297 = 0i64;
                v298 = 0;
                if ( v23 && bdByteBuffer::readString(v132, v290, 0x40ui64) )
                {
                  v196 = 0i64;
                  if ( bdByteBuffer::readUInt64(v132, &v196) )
                  {
                    v24 = 1;
                    goto LABEL_78;
                  }
                }
                else
                {
                  v196 = 0i64;
                }
                v24 = 0;
LABEL_78:
                *(_QWORD *)v281 = 0i64;
                v282 = 0i64;
                v283 = 0i64;
                v284 = 0i64;
                v285 = 0i64;
                v286 = 0i64;
                v287 = 0i64;
                v288 = 0i64;
                v289 = 0;
                if ( v24 && bdByteBuffer::readString(v132, v281, 0x40ui64) )
                {
                  String = 1;
                  LOBYTE(line) = eventType == BD_TEAMMEMBER_CONNECTED;
                  this->m_eventHandler->onTeamMemberStatusUpdate(this->m_eventHandler, v257, v290, v196, v281, line);
                }
                else
                {
                  String = 0;
                }
                if ( v132 && _InterlockedExchangeAdd((volatile signed __int32 *)&v132->m_refCount, 0xFFFFFFFF) == 1 )
                {
                  v21 = v132;
LABEL_68:
                  if ( v21 )
                    ((void (__fastcall *)(bdByteBuffer *, __int64))v21->~bdReferencable)(v21, 1i64);
                }
                break;
              case BD_FRIEND_RICH_PRESENCE_UPDATED:
                v40 = (bdByteBuffer *)message.m_ptr->__vftable;
                v147.m_ptr = v40;
                if ( v40 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v40->m_refCount, 1u);
                  v40 = v147.m_ptr;
                }
                v207 = 0i64;
                v41 = bdByteBuffer::readUInt64(v40, &v207);
                *(_QWORD *)v315 = 0i64;
                v316 = 0i64;
                v317 = 0i64;
                v318 = 0i64;
                v319 = 0i64;
                v320 = 0i64;
                v321 = 0i64;
                v322 = 0i64;
                if ( v41 && bdByteBuffer::readString(v147.m_ptr, v315, 0x40ui64) )
                {
                  v136 = 1024;
                  if ( bdByteBuffer::readBlob(v147.m_ptr, v350, &v136) )
                  {
                    String = 1;
                    this->m_eventHandler->onRichPresenceUpdate(this->m_eventHandler, v207, v315, v350, v136, 0i64);
                    goto LABEL_155;
                  }
                }
                else
                {
                  v136 = 1024;
                }
                String = 0;
LABEL_155:
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v147);
                break;
              case BD_FRIEND_CHAT_MSG:
                v36 = (bdByteBuffer *)message.m_ptr->__vftable;
                v146.m_ptr = v36;
                if ( v36 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v36->m_refCount, 1u);
                  v36 = v146.m_ptr;
                }
                v205 = 0i64;
                v37 = bdByteBuffer::readUInt64(v36, &v205);
                *(_QWORD *)v307 = 0i64;
                v308 = 0i64;
                v309 = 0i64;
                v310 = 0i64;
                v311 = 0i64;
                v312 = 0i64;
                v313 = 0i64;
                v314 = 0i64;
                v38 = v37 && bdByteBuffer::readString(v146.m_ptr, v307, 0x40ui64);
                memset_0(v347, 0, sizeof(v347));
                v153 = 1024;
                if ( v38 && bdByteBuffer::readBlob(v146.m_ptr, v347, &v153) )
                {
                  String = 1;
                  this->m_eventHandler->onInstantMessage(this->m_eventHandler, v205, v307, v347, v153, 0i64);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v146);
                break;
              case BD_TEAM_CHAT_MSG:
                v39 = (bdByteBuffer *)message.m_ptr->__vftable;
                v206.m_ptr = v39;
                if ( v39 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v39->m_refCount, 1u);
                String = bdLobbyService::handleTeamChatMsg(this, (bdReference<bdByteBuffer>)&v206);
                break;
              case BD_NOTIFY_LEAVE:
                v42 = (bdByteBuffer *)message.m_ptr->__vftable;
                v148.m_ptr = v42;
                if ( v42 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v42->m_refCount, 1u);
                  v42 = v148.m_ptr;
                }
                v208 = 0i64;
                v43 = bdByteBuffer::readUInt64(v42, &v208);
                *(_QWORD *)v331 = 0i64;
                v332 = 0i64;
                v333 = 0i64;
                v334 = 0i64;
                v335 = 0i64;
                v336 = 0i64;
                v337 = 0i64;
                v338 = 0i64;
                v44 = v43 && bdByteBuffer::readString(v148.m_ptr, v331, 0x40ui64);
                bdSessionID::bdSessionID(&other);
                v188 = 8;
                if ( v44 && bdByteBuffer::readBlob(v148.m_ptr, other._bytes_20, &v188) )
                {
                  String = 1;
                  v45 = this->m_eventHandler;
                  onNotifyLeave = v45->onNotifyLeave;
                  bdSessionID::bdSessionID(&v261, &other);
                  ((void (__fastcall *)(bdLobbyEventHandler *, unsigned __int64, __int64))onNotifyLeave)(v45, v208, v47);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleNotifyLeave", 0xA30u, "Failed to read sessionID for session invite.");
                }
                bdSecurityID::~bdSecurityID((bdSecurityID *)other._bytes_20);
                bdSerializable::~bdSerializable((bdSerializable *)other._bytes_20);
                bdTaskResult::~bdTaskResult((bdTaskResult *)(&other.__vftable + 2));
                bdReferencable::~bdReferencable((bdReferencable *)&other._bytes_20[8]);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v148);
                break;
              case BD_NEW_MAIL:
                this->m_eventHandler->onNewMail(this->m_eventHandler);
                goto LABEL_467;
              case BD_CHALLENGES_RECEIVED:
                v48 = (bdByteBuffer *)message.m_ptr->__vftable;
                v209.m_ptr = v48;
                if ( v48 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v48->m_refCount, 1u);
                String = bdLobbyService::handleChallengesReceived(this, (bdReference<bdByteBuffer>)&v209);
                break;
              case BD_ASYNCHRONOUS_RESULT:
              case BD_DEMONATA_PUSH_MESSAGE:
                break;
              case BD_GLOBAL_INSTANT_MESSAGE:
                v64 = (bdByteBuffer *)message.m_ptr->__vftable;
                v150.m_ptr = v64;
                if ( v64 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v64->m_refCount, 1u);
                  v64 = v150.m_ptr;
                }
                v219 = 0i64;
                v65 = bdByteBuffer::readUInt64(v64, &v219);
                *(_QWORD *)v323 = 0i64;
                v324 = 0i64;
                v325 = 0i64;
                v326 = 0i64;
                v327 = 0i64;
                v328 = 0i64;
                v329 = 0i64;
                v330 = 0i64;
                v66 = v65 && bdByteBuffer::readString(v150.m_ptr, v323, 0x40ui64);
                memset_0(v352, 0, sizeof(v352));
                v157 = 4096;
                if ( v66 && bdByteBuffer::readBlob(v150.m_ptr, v352, &v157) )
                {
                  String = 1;
                  this->m_eventHandler->onGlobalInstantMessage(this->m_eventHandler, v219, v323, v352, v157);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v150);
                break;
              case BD_CHANNEL_CHAT_BROADCAST_MSG_V2:
              case BD_CHANNEL_CHAT_WHISPER_MSG_V2:
                v29 = (bdByteBuffer *)message.m_ptr->__vftable;
                messagea.m_ptr = v29;
                if ( v29 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v29->m_refCount, 1u);
                String = bdLobbyService::handleChannelChatMsgV2(this, (bdReference<bdByteBuffer>)&messagea);
                break;
              case BD_CHANNEL_USER_SUBSCRIBED_V2:
              case BD_CHANNEL_USER_UNSUBSCRIBED_V2:
                v31 = (bdByteBuffer *)message.m_ptr->__vftable;
                v200.m_ptr = v31;
                if ( v31 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v31->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserSubscriptionV2(this, (bdReference<bdByteBuffer>)&v200, eventType);
                break;
              case BD_CHANNEL_USER_PROMOTED_V2:
                v33 = (bdByteBuffer *)message.m_ptr->__vftable;
                v202.m_ptr = v33;
                if ( v33 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v33->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserPromotedV2(this, (bdReference<bdByteBuffer>)&v202);
                break;
              case BD_CHANNEL_USER_KICKED_V2:
                v35 = (bdByteBuffer *)message.m_ptr->__vftable;
                v204.m_ptr = v35;
                if ( v35 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v35->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserKickedV2(this, (bdReference<bdByteBuffer>)&v204);
                break;
              case BD_MULTIPLE_LOGONS:
                v49 = (bdByteBuffer *)message.m_ptr->__vftable;
                v187.m_ptr = v49;
                if ( v49 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v49->m_refCount, 1u);
                  v49 = v187.m_ptr;
                }
                v210 = 0i64;
                String = bdByteBuffer::readUInt64(v49, &v210);
                if ( String )
                  this->m_eventHandler->onMultipleLogon(this->m_eventHandler, v210);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v187);
                break;
              case BD_PLAYER_BANNED:
                v51 = (bdByteBuffer *)message.m_ptr->__vftable;
                v139.m_ptr = v51;
                if ( v51 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v51->m_refCount, 1u);
                  v51 = v139.m_ptr;
                }
                v213 = 0i64;
                v156 = 0;
                i = -1i64;
                v155 = 0;
                if ( bdByteBuffer::readUInt64(v51, &v213) && bdByteBuffer::readUInt32(v139.m_ptr, &v156) && bdByteBuffer::readInt64(v139.m_ptr, &i) && bdByteBuffer::readUInt32(v139.m_ptr, &v155) )
                {
                  String = 1;
                  this->m_eventHandler->onPlayerBanned(this->m_eventHandler, v213, v156, i, v155);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v139);
                break;
              case BD_CHANNEL_USER_PROMOTED:
                v32 = (bdByteBuffer *)message.m_ptr->__vftable;
                v201.m_ptr = v32;
                if ( v32 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v32->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserPromoted(this, (bdReference<bdByteBuffer>)&v201);
                break;
              case BD_CHANNEL_USER_KICKED:
                v34 = (bdByteBuffer *)message.m_ptr->__vftable;
                v203.m_ptr = v34;
                if ( v34 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v34->m_refCount, 1u);
                String = bdLobbyService::handleChannelUserKicked(this, (bdReference<bdByteBuffer>)&v203);
                break;
              case BD_FEATURE_BAN:
                v67 = (bdByteBuffer *)message.m_ptr->__vftable;
                v140.m_ptr = v67;
                if ( v67 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v67->m_refCount, 1u);
                  v67 = v140.m_ptr;
                }
                b = 0;
                v68 = bdByteBuffer::readUByte8(v67, &b);
                v137 = 0;
                String = v68 && bdByteBuffer::readUInt32(v140.m_ptr, &v137);
                if ( b == 1 )
                {
                  if ( v137 )
                  {
                    do
                    {
                      if ( !String )
                        break;
                      bdFeatureBanInfo::bdFeatureBanInfo(&v259);
                      v193.m_ptr = v140.m_ptr;
                      if ( v140.m_ptr )
                        _InterlockedExchangeAdd((volatile signed __int32 *)&v140.m_ptr->m_refCount, 1u);
                      if ( bdFeatureBanInfo::deserialize(&v259, (bdReference<bdByteBuffer>)&v193) )
                      {
                        String = 1;
                        this->m_eventHandler->onFeatureBan(this->m_eventHandler, &v259);
                      }
                      else
                      {
                        String = 0;
                      }
                      bdFeatureBanInfo::~bdFeatureBanInfo((bdFeatureBanInfo *)v259.gap20);
                      bdReferencable::~bdReferencable((bdReferencable *)v259.gap20);
                      ++v4;
                    }
                    while ( v4 < v137 );
                  }
                }
                else
                {
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleFeatureBan", 0xAFFu, "Unsupported feature ban message version.");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v140);
                break;
              case BD_GMSG_GROUP_MESSAGE:
              case BD_GMSG_BROADCAST:
                v70 = (bdByteBuffer *)message.m_ptr->__vftable;
                v141.m_ptr = v70;
                if ( v70 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v70->m_refCount, 1u);
                  v70 = v141.m_ptr;
                }
                v189 = 0i64;
                v339[0] = 0;
                memset_0(v345, 0, sizeof(v345));
                v138 = 1024;
                if ( bdByteBuffer::readUInt64(v70, &v189) && bdByteBuffer::readString(v141.m_ptr, v339, 0x40ui64) && bdByteBuffer::readBlob(v141.m_ptr, v345, &v138) )
                {
                  String = 1;
                  v71 = this->m_eventHandler;
                  v72 = v71->__vftable;
                  if ( eventType == BD_GMSG_GROUP_MESSAGE )
                    v72->onGroupMessagingMessage(v71, v189, v339, v345, v138);
                  else
                    v72->onBroadcastMessage(v71, v189, v339, v345, v138);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleGMSGBroadcast", 0xB1Fu, "Failed to deserialize group messaging message.");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v141);
                break;
              case BD_TENCENT_AAS_RECORD:
                v73 = (bdByteBuffer *)message.m_ptr->__vftable;
                v179.m_ptr = v73;
                if ( v73 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v73->m_refCount, 1u);
                bdTencentAASRecord::bdTencentAASRecord(&v260);
                v194.m_ptr = v179.m_ptr;
                if ( v179.m_ptr )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v179.m_ptr->m_refCount, 1u);
                String = bdTencentAASRecord::deserialize(&v260, (bdReference<bdByteBuffer>)&v194);
                if ( String )
                  this->m_eventHandler->onTencentAASRecordReceived(this->m_eventHandler, &v260);
                else
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAASRecord", 0xB2Fu, "Failed to deserialize Tencent AAS record message.");
                bdTencentAASRecord::~bdTencentAASRecord((bdTencentAASRecord *)&v260.gap24[4]);
                bdReferencable::~bdReferencable((bdReferencable *)&v260.gap24[4]);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v179);
                break;
              case BD_NOT_WHITE_LISTED:
                v61 = (bdByteBuffer *)message.m_ptr->__vftable;
                v178.m_ptr = v61;
                if ( v61 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v61->m_refCount, 1u);
                  v61 = v178.m_ptr;
                }
                v217 = 0i64;
                String = bdByteBuffer::readUInt64(v61, &v217);
                if ( String )
                  this->m_eventHandler->onNotWhiteListed(this->m_eventHandler, v217);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v178);
                break;
              case BD_CHANNEL_USER_MUTED:
                v74 = (bdByteBuffer *)message.m_ptr->__vftable;
                v169.m_ptr = v74;
                if ( v74 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v74->m_refCount, 1u);
                  v74 = v169.m_ptr;
                }
                v224 = 0i64;
                v223 = 0i64;
                if ( bdByteBuffer::readUInt64(v74, &v224) && bdByteBuffer::readUInt64(v169.m_ptr, &v223) )
                {
                  String = 1;
                  this->m_eventHandler->onPlayerMuted(this->m_eventHandler, v224, v223);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v169);
                break;
              case BD_STABILISED:
                v75 = (bdByteBuffer *)message.m_ptr->__vftable;
                v170.m_ptr = v75;
                if ( v75 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v75->m_refCount, 1u);
                  v75 = v170.m_ptr;
                }
                v226 = 0i64;
                v225 = 0i64;
                if ( bdByteBuffer::readUInt64(v75, &v226) && bdByteBuffer::readUInt64(v170.m_ptr, &v225) )
                {
                  String = 1;
                  this->m_eventHandler->onPlayerStabilised(this->m_eventHandler, v226, v225);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v170);
                break;
              case BD_CONSOLE_BANNED:
                v52 = (bdByteBuffer *)message.m_ptr->__vftable;
                v175.m_ptr = v52;
                if ( v52 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v52->m_refCount, 1u);
                  v52 = v175.m_ptr;
                }
                v214 = 0i64;
                String = bdByteBuffer::readUInt64(v52, &v214);
                if ( String )
                  this->m_eventHandler->onConsoleBanned(this->m_eventHandler, v214);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v175);
                break;
              case BD_MULTIPLE_LINKED_ACCOUNT_LOGONS:
                v53 = (bdByteBuffer *)message.m_ptr->__vftable;
                v176.m_ptr = v53;
                if ( v53 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v53->m_refCount, 1u);
                bdUserAccountID::bdUserAccountID(&userID);
                v191.m_ptr = v176.m_ptr;
                if ( v176.m_ptr )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v176.m_ptr->m_refCount, 1u);
                String = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&v191, &userID);
                if ( String )
                {
                  v54 = this->m_eventHandler;
                  onMultipleLinkedAccountLogons = v54->onMultipleLinkedAccountLogons;
                  bdUserAccountID::bdUserAccountID(&v263, &userID);
                  ((void (__fastcall *)(bdLobbyEventHandler *, __int64))onMultipleLinkedAccountLogons)(v54, v56);
                }
                bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
                bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v176);
                break;
              case BD_LINKED_ACCOUNT_STATUS_CHANGE:
                v57 = (bdByteBuffer *)message.m_ptr->__vftable;
                v177.m_ptr = v57;
                if ( v57 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v57->m_refCount, 1u);
                bdUserAccountID::bdUserAccountID(&v266);
                v192.m_ptr = v177.m_ptr;
                if ( v177.m_ptr )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v177.m_ptr->m_refCount, 1u);
                String = ContextSerialization::readUserID((bdReference<bdByteBuffer>)&v192, &v266);
                if ( String )
                {
                  v58 = this->m_eventHandler;
                  onLinkedAccountStatusChange = v58->onLinkedAccountStatusChange;
                  bdUserAccountID::bdUserAccountID(&v262, &v266);
                  ((void (__fastcall *)(bdLobbyEventHandler *, __int64))onLinkedAccountStatusChange)(v58, v60);
                }
                bdUserAccountID::~bdUserAccountID((bdUserAccountID *)v266.gap38);
                bdReferencable::~bdReferencable((bdReferencable *)v266.gap38);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v177);
                break;
              case BD_MARKETPLACE_COUPONS_GRANTED:
                v76 = (bdByteBuffer *)message.m_ptr->__vftable;
                v227.m_ptr = v76;
                if ( v76 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v76->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceCouponsGranted(this, (bdReference<bdByteBuffer>)&v227);
                break;
              case BD_TOTP_CHALLENGE:
                v69 = (bdByteBuffer *)message.m_ptr->__vftable;
                v186.m_ptr = v69;
                if ( v69 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v69->m_refCount, 1u);
                  v69 = v186.m_ptr;
                }
                v221 = 0i64;
                String = bdByteBuffer::readUInt64(v69, &v221);
                if ( String )
                  this->m_eventHandler->onTOTPMessage(this->m_eventHandler, v221);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v186);
                break;
              case BD_MARKETPLACE_ITEMS_EXPIRED:
                v77 = (bdByteBuffer *)message.m_ptr->__vftable;
                v228.m_ptr = v77;
                if ( v77 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v77->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceItemsExpired(this, (bdReference<bdByteBuffer>)&v228);
                break;
              case BD_MARKETPLACE_ITEMS_UPDATED:
                v78 = (bdByteBuffer *)message.m_ptr->__vftable;
                v229.m_ptr = v78;
                if ( v78 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v78->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceItemsUpdated(this, (bdReference<bdByteBuffer>)&v229);
                break;
              case BD_MARKETPLACE_COUPONS_UPDATED:
                v79 = (bdByteBuffer *)message.m_ptr->__vftable;
                v230.m_ptr = v79;
                if ( v79 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v79->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceCouponsUpdated(this, (bdReference<bdByteBuffer>)&v230);
                break;
              case BD_REWARD_ACHIEVEMENT_CLAIMED:
                v85 = (bdByteBuffer *)message.m_ptr->__vftable;
                v236.m_ptr = v85;
                if ( v85 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v85->m_refCount, 1u);
                String = bdLobbyService::handleClaimAchievement(this, (bdReference<bdByteBuffer>)&v236);
                break;
              case BD_MARKETPLACE_BALANCE_UPDATED:
                v83 = (bdByteBuffer *)message.m_ptr->__vftable;
                v234.m_ptr = v83;
                if ( v83 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v83->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceBalanceUpdated(this, (bdReference<bdByteBuffer>)&v234);
                break;
              case BD_MARKETPLACE_DEPOSIT_GRANTED:
                v86 = (bdByteBuffer *)message.m_ptr->__vftable;
                v237.m_ptr = v86;
                if ( v86 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v86->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceDepositGranted(this, (bdReference<bdByteBuffer>)&v237);
                break;
              case BD_MARKETPLACE_ITEMS_GRANTED:
                v87 = (bdByteBuffer *)message.m_ptr->__vftable;
                v238.m_ptr = v87;
                if ( v87 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v87->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceItemsGranted(this, (bdReference<bdByteBuffer>)&v238);
                break;
              case BD_MARKETPLACE_ENTITLEMENTS_GRANTED:
                v89 = (bdByteBuffer *)message.m_ptr->__vftable;
                v240.m_ptr = v89;
                if ( v89 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v89->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceEntitlementsGranted(this, (bdReference<bdByteBuffer>)&v240);
                break;
              case BD_STORAGE_WEBSERVICE_WRITE:
                v90 = (bdByteBuffer *)message.m_ptr->__vftable;
                v241.m_ptr = v90;
                if ( v90 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v90->m_refCount, 1u);
                String = bdLobbyService::handleWebserviceStorageFileWrite(this, (bdReference<bdByteBuffer>)&v241);
                break;
              case BD_REWARD_EVENT_MESSAGE:
                v91 = (bdByteBuffer *)message.m_ptr->__vftable;
                v242.m_ptr = v91;
                if ( v91 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v91->m_refCount, 1u);
                String = bdLobbyService::handleRewardEventMessage(this, (bdReference<bdByteBuffer>)&v242);
                break;
              case BD_MARKETING_COMMS_ASSIGNMENTS_AVAILABLE:
                this->m_eventHandler->onMarketingCommsAssignmentsAvailable(this->m_eventHandler);
                goto LABEL_467;
              case BD_PUBLISHER_VARIABLES_UPDATE_MESSAGE:
                v94 = (bdByteBuffer *)message.m_ptr->__vftable;
                v245.m_ptr = v94;
                if ( v94 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v94->m_refCount, 1u);
                String = bdLobbyService::handlePublisherVariablesUpdateMessage(this, (bdReference<bdByteBuffer>)&v245);
                break;
              case BD_MARKETPLACE_COUPONS_UPDATED_V2:
                v80 = (bdByteBuffer *)message.m_ptr->__vftable;
                v231.m_ptr = v80;
                if ( v80 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v80->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceCouponsUpdatedV2(this, (bdReference<bdByteBuffer>)&v231);
                break;
              case BD_MARKETPLACE_ITEMS_GRANTED_WITH_INVENTORY_QUANTITY:
                v88 = (bdByteBuffer *)message.m_ptr->__vftable;
                v239.m_ptr = v88;
                if ( v88 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v88->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceItemsGrantedWithInventoryQuantity(this, (bdReference<bdByteBuffer>)&v239);
                break;
              case BD_USER_PRIVATE_PROFILE_UPDATED:
                v95 = (bdByteBuffer *)message.m_ptr->__vftable;
                v181.m_ptr = v95;
                if ( v95 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v95->m_refCount, 1u);
                v124 = 0;
                this->m_eventHandler->onUserPrivateProfileUpdated(this->m_eventHandler);
                String = bdByteBuffer::readBool(v181.m_ptr, &v124);
                if ( String )
                  this->m_eventHandler->onUserPrivateProfileUpdatedWithCallerInfo(this->m_eventHandler, v124);
                else
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePrivateProfileUpdate", 0xF74u, "Failed to parse bdProfileService (Private profile updated) push message");
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v181);
                break;
              case BD_TEAM_MEMBER_RICH_PRESENCE_UPDATED:
                v96 = (bdByteBuffer *)message.m_ptr->__vftable;
                v142.m_ptr = v96;
                if ( v96 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v96->m_refCount, 1u);
                  v96 = v142.m_ptr;
                }
                v246 = 0i64;
                v158 = 1024;
                v125 = 0;
                if ( bdByteBuffer::readUInt64(v96, &v246) && bdByteBuffer::readBlob(v142.m_ptr, v351, &v158) && bdByteBuffer::readBool(v142.m_ptr, &v125) )
                {
                  String = 1;
                  LOBYTE(function) = v125;
                  this->m_eventHandler->onTeamMemberRichPresenceUpdate(this->m_eventHandler, v246, v351, v158, function);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTeamMemberRichPresenceUpdated", 0xF4Cu, "Failed to parse bdTeamsService (RichPresence Updated) push message");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v142);
                break;
              case BD_TITLE_VERSION_DISABLED:
                v98 = (bdByteBuffer *)message.m_ptr->__vftable;
                v182.m_ptr = v98;
                if ( v98 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v98->m_refCount, 1u);
                  v98 = v182.m_ptr;
                }
                v248 = 0i64;
                String = bdByteBuffer::readUInt64(v98, &v248);
                if ( String )
                  this->m_eventHandler->onTitleVersionDisabled(this->m_eventHandler, v248);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v182);
                break;
              case BD_TEAM_MEMBER_USER_NAME_UPDATED:
                v97 = (bdByteBuffer *)message.m_ptr->__vftable;
                v171.m_ptr = v97;
                if ( v97 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v97->m_refCount, 1u);
                  v97 = v171.m_ptr;
                }
                v247 = 0i64;
                if ( bdByteBuffer::readUInt64(v97, &v247) && bdByteBuffer::readString(v171.m_ptr, v342, 0x40ui64) )
                {
                  String = 1;
                  this->m_eventHandler->onTeamMemberUserNameUpdate(this->m_eventHandler, v247, v342);
                }
                else
                {
                  String = 0;
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTeamMemberUserNameUpdated", 0xF60u, "Failed to parse bdTeamsService (User Name Changed) push message");
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v171);
                break;
              case BD_MARKETPLACE_COUPONS_UPDATED_V3:
                v81 = (bdByteBuffer *)message.m_ptr->__vftable;
                v232.m_ptr = v81;
                if ( v81 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v81->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceCouponsUpdatedV3(this, (bdReference<bdByteBuffer>)&v232);
                break;
              case BD_REWARD_ACHIEVEMENT_MESSAGE:
                v92 = (bdByteBuffer *)message.m_ptr->__vftable;
                v243.m_ptr = v92;
                if ( v92 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v92->m_refCount, 1u);
                String = bdLobbyService::handleRewardAchievementMessage(this, (bdReference<bdByteBuffer>)&v243);
                break;
              case BD_PLAYER_DISCONNECTED:
                v50 = (bdByteBuffer *)message.m_ptr->__vftable;
                v167.m_ptr = v50;
                if ( v50 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v50->m_refCount, 1u);
                  v50 = v167.m_ptr;
                }
                v211 = 0i64;
                v154 = 0;
                if ( bdByteBuffer::readUInt64(v50, &v211) && bdByteBuffer::readUInt32(v167.m_ptr, &v154) )
                {
                  String = 1;
                  this->m_eventHandler->onPlayerDisconnected(this->m_eventHandler, v211, (bdAntiCheat::bdAntiCheatReason)v154);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v167);
                break;
              case BD_CODO_TEAM_MARKETPLACE_LEVEL_CHANGED:
                v99 = (bdByteBuffer *)message.m_ptr->__vftable;
                v149.m_ptr = v99;
                if ( v99 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v99->m_refCount, 1u);
                  v99 = v149.m_ptr;
                }
                v249 = 0i64;
                v165 = 0;
                v159 = 0;
                if ( bdByteBuffer::readUInt64(v99, &v249) && bdByteBuffer::readUInt32(v149.m_ptr, &v165) && bdByteBuffer::readUInt32(v149.m_ptr, &v159) )
                {
                  String = 1;
                  this->m_eventHandler->onCODOTeamMarketplaceLevelChange(this->m_eventHandler, v249, v165, v159);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v149);
                break;
              case BD_SUBSCRIBED_RICH_PRESENCE_UPDATED:
                v100 = (bdByteBuffer *)message.m_ptr->__vftable;
                v250.m_ptr = v100;
                if ( v100 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v100->m_refCount, 1u);
                String = bdLobbyService::handleSubscribedRichPresenceUpdated(this, (bdReference<bdByteBuffer>)&v250);
                break;
              case BD_PLAYER_LOGON_TIME_PROHIBITED:
                v101 = (bdByteBuffer *)message.m_ptr->__vftable;
                v183.m_ptr = v101;
                if ( v101 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v101->m_refCount, 1u);
                  v101 = v183.m_ptr;
                }
                memset_0(v348, 0, sizeof(v348));
                v160 = 1024;
                String = bdByteBuffer::readBlob(v101, v348, &v160);
                if ( String )
                  this->m_eventHandler->onLogonTimeProhibited(this->m_eventHandler, v348, v160);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v183);
                break;
              case BD_PLAYER_LOGON_TIME_PROHIBITED_WARNING:
                v102 = (bdByteBuffer *)message.m_ptr->__vftable;
                v172.m_ptr = v102;
                if ( v102 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v102->m_refCount, 1u);
                  v102 = v172.m_ptr;
                }
                v162 = 0;
                memset_0(v349, 0, sizeof(v349));
                v161 = 1024;
                if ( bdByteBuffer::readUInt32(v102, &v162) && bdByteBuffer::readBlob(v172.m_ptr, v349, &v161) )
                {
                  String = 1;
                  this->m_eventHandler->onLogonTimeProhibitedWarning(this->m_eventHandler, v162, v349, v161);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v172);
                break;
              case BD_MARKETPLACE_COUPONS_UPDATED_V4:
                v82 = (bdByteBuffer *)message.m_ptr->__vftable;
                v233.m_ptr = v82;
                if ( v82 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v82->m_refCount, 1u);
                String = bdLobbyService::handleMarketplaceCouponsUpdatedV4(this, (bdReference<bdByteBuffer>)&v233);
                break;
              case BD_NOT_WHITE_LISTED_WITH_MESSAGE:
                v62 = (bdByteBuffer *)message.m_ptr->__vftable;
                v168.m_ptr = v62;
                if ( v62 )
                {
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v62->m_refCount, 1u);
                  v62 = v168.m_ptr;
                }
                v218 = 0i64;
                v63 = bdByteBuffer::readUInt64(v62, &v218);
                memset_0(v343, 0, 0x8Dui64);
                if ( v63 && bdByteBuffer::readString(v168.m_ptr, v343, 0x8Cui64) )
                {
                  String = 1;
                  this->m_eventHandler->onNotWhiteListedWithMessage(this->m_eventHandler, v218, v343);
                }
                else
                {
                  String = 0;
                }
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v168);
                break;
              case BD_ACHIEVEMENTS_UPDATED:
                v93 = (bdByteBuffer *)message.m_ptr->__vftable;
                v244.m_ptr = v93;
                if ( v93 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v93->m_refCount, 1u);
                String = bdLobbyService::handleAchievementsUpdated(this, (bdReference<bdByteBuffer>)&v244);
                break;
              case BD_MARKETPLACE_BALANCE_UPDATED_V2:
                v84 = (bdByteBuffer *)message.m_ptr->__vftable;
                v180.m_ptr = v84;
                if ( v84 )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v84->m_refCount, 1u);
                bdMarketplaceBalanceUpdatePushMessage::bdMarketplaceBalanceUpdatePushMessage(&v267);
                v195.m_ptr = v180.m_ptr;
                if ( v180.m_ptr )
                  _InterlockedExchangeAdd((volatile signed __int32 *)&v180.m_ptr->m_refCount, 1u);
                String = bdStructBufferDeserializerHelpers::deserializeFromBuffer((bdReference<bdByteBuffer>)&v195, &v267);
                if ( String )
                  this->m_eventHandler->onBalanceUpdate(this->m_eventHandler, &v267);
                else
                  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleMarketplaceBalanceUpdatedV2", 0xD8Eu, "Failed to parse Marketplace balance update v2 message");
                bdMarketplaceBalanceUpdatePushMessage::~bdMarketplaceBalanceUpdatePushMessage((bdMarketplaceBalanceUpdatePushMessage *)v267.gap378);
                bdReferencable::~bdReferencable((bdReferencable *)v267.gap378);
                bdReference<bdByteBuffer>::~bdReference<bdByteBuffer>(&v180);
                break;
              default:
                goto LABEL_464;
            }
          }
          if ( !String )
          {
            v117 = eventType;
            v122 = bdEventTypeToString(eventType);
            LODWORD(v120) = v117;
            bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x8BDu, "Error handling Push Message of type[%d][%s]", v120, v122);
          }
        }
        else
        {
          v121 = bdEventTypeToString((const bdEventType)u);
          bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x7C6u, "Received Push Message of type[%d][%s], but no bdLobbyEventHandler registered - ignoring", eventType, v121);
        }
      }
      goto LABEL_467;
    }
    v10 = (bdByteBuffer *)message.m_ptr->__vftable;
    v144 = v10;
    if ( v10 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v10->m_refCount, 1u);
    v134 = 0;
    category = 0;
    m_eventLogManager = this->m_eventLogManager;
    if ( m_eventLogManager )
    {
      bdEventLog::resetFilteredCategories(m_eventLogManager);
      if ( bdByteBuffer::readUInt32(v144, &v134) )
      {
        v12 = 1;
        goto LABEL_26;
      }
    }
    else
    {
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleEventLogFilteredCategories", 0xC52u, "No event log manager to handle filtered categories");
    }
    v12 = 0;
LABEL_26:
    if ( v134 )
    {
      do
      {
        v12 = v12 && bdByteBuffer::readUInt32(v144, &category) && bdEventLog::addFilteredCategory(this->m_eventLogManager, category);
        ++v4;
      }
      while ( v4 < v134 );
    }
    if ( v12 )
      bdEventLog::setReceivedCategoryData(this->m_eventLogManager, 1);
    else
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleEventLogFilteredCategories", 0xC64u, "Failed to parse filtered categories");
    if ( v144 && _InterlockedExchangeAdd((volatile signed __int32 *)&v144->m_refCount, 0xFFFFFFFF) == 1 && v144 )
      ((void (__fastcall *)(bdByteBuffer *, __int64))v144->~bdReferencable)(v144, 1i64);
    if ( !v12 )
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x7B5u, "Error handling BD_EVENT_LOG_FILTERED_CATEGORIES Push Message");
    goto LABEL_467;
  }
  bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handlePushMessage", 0x792u, "Failed to deserialize the bdEventType of Push Message.");
LABEL_3:
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
}

/*
==============
bdLobbyService::handleRewardAchievementMessage
==============
*/
__int64 bdLobbyService::handleRewardAchievementMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UByte8; 
  unsigned __int8 v5; 
  unsigned int v6; 
  bdByteBuffer *v7; 
  bdByteBuffer *v8; 
  unsigned int v9; 
  bdByteBuffer *v10; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onRewardAchievementJSONMessage)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const bdRewardEventJSONV2 *); 
  __int64 v13; 
  const char *JsonData; 
  bdLobbyEventHandler *v15; 
  void (__fastcall *v16)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const bdRewardEventJSON *); 
  __int64 v17; 
  __int64 v19; 
  unsigned __int8 b[4]; 
  unsigned int u; 
  int i[2]; 
  bdReference<bdByteBuffer> v23; 
  bdReference<bdByteBuffer> v24; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v26; 
  bdByteBuffer *m_ptr; 
  bdRewardEventJSONV2 v28; 
  bdUserAccountID v29; 
  bdUserAccountID v30; 
  bdUserAccountID userID; 
  bdRewardEventJSON v32; 
  char context[8]; 
  __int64 v34; 

  v26 = -2i64;
  m_ptr = message.m_ptr;
  b[0] = 0;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v34 = 0i64;
  i[0] = 0;
  u = 0;
  UByte8 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b);
  if ( b[0] != 1 )
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardAchievementMessage", 0xF06u, "Unsupported RewardAchievement Push Message version.");
LABEL_3:
    v5 = 0;
    goto LABEL_4;
  }
  if ( !UByte8 )
    goto LABEL_3;
  v7 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v7;
  if ( v7 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
  if ( !ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) )
    goto LABEL_3;
  v8 = (bdByteBuffer *)message.m_ptr->__vftable;
  v24.m_ptr = v8;
  if ( v8 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
  if ( !ContextSerialization::readContext((bdReference<bdByteBuffer>)&v24, context, 0x10u) || !bdByteBuffer::readInt32((bdByteBuffer *)message.m_ptr->__vftable, i) || !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) )
    goto LABEL_3;
  v5 = 1;
LABEL_4:
  v6 = u;
  if ( u > 0xA )
  {
    u = 10;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardAchievementMessage", 0xF06u, "Too many[%d] bdRewardAchievements in push message. Maximum[%d]", 10, 10);
    v6 = u;
  }
  if ( i[0] == 1 )
  {
    v9 = 0;
    if ( v6 )
    {
      do
      {
        bdRewardEventJSONV2::bdRewardEventJSONV2(&v28);
        if ( !v5 )
          goto LABEL_24;
        v10 = (bdByteBuffer *)message.m_ptr->__vftable;
        v23.m_ptr = v10;
        if ( v10 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v10->m_refCount, 1u);
        if ( bdRewardEventJSONV2::deserialize(&v28, (bdReference<bdByteBuffer>)&v23) )
          v5 = 1;
        else
LABEL_24:
          v5 = 0;
        if ( v5 )
        {
          m_eventHandler = this->m_eventHandler;
          onRewardAchievementJSONMessage = m_eventHandler->onRewardAchievementJSONMessage;
          bdUserAccountID::bdUserAccountID(&v29, &userID);
          ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, bdRewardEventJSONV2 *))onRewardAchievementJSONMessage)(m_eventHandler, v13, context, &v28);
          bdRewardEventJSON::bdRewardEventJSON(&v32);
          JsonData = bdRewardEventJSONV2::getJsonData(&v28);
          bdRewardEventJSON::set(&v32, JsonData);
          v15 = this->m_eventHandler;
          v16 = v15->onRewardAchievementJSONMessage;
          bdUserAccountID::bdUserAccountID(&v30, &userID);
          ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, bdRewardEventJSON *))v16)(v15, v17, context, &v32);
          bdRewardEventJSON::~bdRewardEventJSON((bdRewardEventJSON *)v32.gap828);
          bdReferencable::~bdReferencable((bdReferencable *)v32.gap828);
        }
        bdRewardEventJSONV2::~bdRewardEventJSONV2((bdRewardEventJSONV2 *)v28.gap30);
        bdReferencable::~bdReferencable((bdReferencable *)v28.gap30);
        ++v9;
      }
      while ( v9 < u );
    }
  }
  else
  {
    LODWORD(v19) = i[0];
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardAchievementMessage", 0xF06u, "Failed to parse Unknown bdRewardEventType[%d]", v19);
    v5 = 0;
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleRewardEventMessage
==============
*/
__int64 bdLobbyService::handleRewardEventMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UByte8; 
  unsigned __int8 v5; 
  unsigned int v6; 
  bdByteBuffer *v7; 
  bdByteBuffer *v8; 
  unsigned int v9; 
  bdByteBuffer *v10; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onRewardEventJSONMessage)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const bdRewardEventJSONV2 *); 
  __int64 v13; 
  const char *JsonData; 
  bdLobbyEventHandler *v15; 
  void (__fastcall *v16)(bdLobbyEventHandler *, const bdUserAccountID, const char *, const bdRewardEventJSON *); 
  __int64 v17; 
  __int64 v19; 
  unsigned __int8 b[4]; 
  unsigned int u; 
  int i; 
  bdReference<bdByteBuffer> v23; 
  bdReference<bdByteBuffer> v24; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v26; 
  bdByteBuffer *m_ptr; 
  bdRewardEventJSONV2 v28; 
  bdUserAccountID v29; 
  bdUserAccountID v30; 
  bdUserAccountID userID; 
  bdRewardEventJSON v32; 
  char context[8]; 
  __int64 v34; 

  v26 = -2i64;
  m_ptr = message.m_ptr;
  b[0] = 0;
  bdUserAccountID::bdUserAccountID(&userID);
  *(_QWORD *)context = 0i64;
  v34 = 0i64;
  i = 0;
  u = 0;
  UByte8 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b);
  if ( b[0] != 1 )
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardEventMessage", 0xEC1u, "Unsupported RewardEvent Push Message version.");
LABEL_3:
    v5 = 0;
    goto LABEL_4;
  }
  if ( !UByte8 )
    goto LABEL_3;
  v7 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v7;
  if ( v7 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_refCount, 1u);
  if ( !ContextSerialization::readUserID((bdReference<bdByteBuffer>)&buffer, &userID) )
    goto LABEL_3;
  v8 = (bdByteBuffer *)message.m_ptr->__vftable;
  v24.m_ptr = v8;
  if ( v8 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v8->m_refCount, 1u);
  if ( !ContextSerialization::readContext((bdReference<bdByteBuffer>)&v24, context, 0x10u) || !bdByteBuffer::readInt32((bdByteBuffer *)message.m_ptr->__vftable, &i) || !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) )
    goto LABEL_3;
  v5 = 1;
LABEL_4:
  v6 = u;
  if ( u > 0xA )
  {
    u = 10;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardEventMessage", 0xEC1u, "Too many[%d] bdRewardEvents in push message. Maximum[%d]", 10, 10);
    v6 = u;
  }
  if ( i == 1 )
  {
    v9 = 0;
    if ( v6 )
    {
      do
      {
        bdRewardEventJSONV2::bdRewardEventJSONV2(&v28);
        if ( !v5 )
          goto LABEL_24;
        v10 = (bdByteBuffer *)message.m_ptr->__vftable;
        v23.m_ptr = v10;
        if ( v10 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v10->m_refCount, 1u);
        if ( bdRewardEventJSONV2::deserialize(&v28, (bdReference<bdByteBuffer>)&v23) )
          v5 = 1;
        else
LABEL_24:
          v5 = 0;
        if ( v5 )
        {
          m_eventHandler = this->m_eventHandler;
          onRewardEventJSONMessage = m_eventHandler->onRewardEventJSONMessage;
          bdUserAccountID::bdUserAccountID(&v29, &userID);
          ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, bdRewardEventJSONV2 *))onRewardEventJSONMessage)(m_eventHandler, v13, context, &v28);
          bdRewardEventJSON::bdRewardEventJSON(&v32);
          JsonData = bdRewardEventJSONV2::getJsonData(&v28);
          bdRewardEventJSON::set(&v32, JsonData);
          v15 = this->m_eventHandler;
          v16 = v15->onRewardEventJSONMessage;
          bdUserAccountID::bdUserAccountID(&v30, &userID);
          ((void (__fastcall *)(bdLobbyEventHandler *, __int64, char *, bdRewardEventJSON *))v16)(v15, v17, context, &v32);
          bdRewardEventJSON::~bdRewardEventJSON((bdRewardEventJSON *)v32.gap828);
          bdReferencable::~bdReferencable((bdReferencable *)v32.gap828);
        }
        else
        {
          bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardEventMessage", 0xEC1u, "Failed to parse bdRewardEvent messages");
        }
        bdRewardEventJSONV2::~bdRewardEventJSONV2((bdRewardEventJSONV2 *)v28.gap30);
        bdReferencable::~bdReferencable((bdReferencable *)v28.gap30);
        ++v9;
      }
      while ( v9 < u );
    }
  }
  else
  {
    LODWORD(v19) = i;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleRewardEventMessage", 0xEC1u, "Failed to parse Unknown bdRewardEventType[%d]", v19);
    v5 = 0;
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)userID.gap38);
  bdReferencable::~bdReferencable((bdReferencable *)userID.gap38);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleSessionInvitation
==============
*/
_BOOL8 bdLobbyService::handleSessionInvitation(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v8; 
  bdByteBuffer *m_ptr; 
  bdSessionInvite v10; 

  v8 = -2i64;
  m_ptr = message.m_ptr;
  bdSessionInvite::bdSessionInvite(&v10);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = bdSessionInvite::deserialize(&v10, (bdReference<bdByteBuffer>)&buffer);
  if ( v5 )
    this->m_eventHandler->onSessionInvite(this->m_eventHandler, &v10);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleSessionInvitation", 0x8F7u, "Failed to read session invite.");
  bdSessionInvite::~bdSessionInvite((bdSessionInvite *)&v10.gap494[4]);
  bdReferencable::~bdReferencable((bdReferencable *)&v10.gap494[4]);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleStabilised
==============
*/
__int64 bdLobbyService::handleStabilised(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned __int64 v6; 
  unsigned __int64 u; 

  u = 0i64;
  v6 = 0i64;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v6) )
  {
    v4 = 1;
    this->m_eventHandler->onPlayerStabilised(this->m_eventHandler, u, v6);
  }
  else
  {
    v4 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleSubscribedRichPresenceUpdated
==============
*/
__int64 bdLobbyService::handleSubscribedRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bdByteBuffer *v5; 
  unsigned __int8 v6; 
  unsigned __int8 b[4]; 
  unsigned int u; 
  bdReference<bdByteBuffer> v10; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v12; 
  bdByteBuffer *m_ptr; 
  bdRichPresenceData v14; 
  char context[8]; 
  __int64 v16; 

  v12 = -2i64;
  m_ptr = message.m_ptr;
  *(_QWORD *)context = 0i64;
  v16 = 0i64;
  u = 0;
  b[0] = 0;
  bdRichPresenceData::bdRichPresenceData(&v14);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  if ( !ContextSerialization::readContext((bdReference<bdByteBuffer>)&buffer, context, 0x10u) || !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) || !bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b) )
    goto LABEL_10;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  v10.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( bdRichPresenceData::deserialize(&v14, (bdReference<bdByteBuffer>)&v10) )
  {
    v6 = 1;
    this->m_eventHandler->onSubscribedRichPresenceUpdate(this->m_eventHandler, context, u, b[0], &v14);
  }
  else
  {
LABEL_10:
    v6 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleSubscribedRichPresenceUpdated", 0xFABu, "Failed to parse bdRichPresence (Presence Updated) push message");
  }
  bdUserAccountID::~bdUserAccountID((bdUserAccountID *)&v14.m_userAccountID[40]);
  bdReferencable::~bdReferencable((bdReferencable *)&v14.m_userAccountID[40]);
  bdSerializable::~bdSerializable((bdSerializable *)v14._bytes_20);
  bdTaskResult::~bdTaskResult((bdTaskResult *)(&v14.__vftable + 2));
  bdReferencable::~bdReferencable((bdReferencable *)(&v14.m_presenceDataSize + 1));
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleTOTPMessage
==============
*/
_BOOL8 bdLobbyService::handleTOTPMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned __int64 u; 

  u = 0i64;
  v4 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v4 )
    this->m_eventHandler->onTOTPMessage(this->m_eventHandler, u);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTSSResponse
==============
*/
_BOOL8 bdLobbyService::handleTSSResponse(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v8; 
  bdByteBuffer *m_ptr; 
  bdTSSStructMessage v10; 

  v8 = -2i64;
  m_ptr = message.m_ptr;
  bdTSSStructMessage::bdTSSStructMessage(&v10);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = bdStructBufferDeserializerHelpers::deserializeFromBuffer((bdReference<bdByteBuffer>)&buffer, &v10);
  if ( v5 )
    this->m_eventHandler->onTSSResponseReceived(this->m_eventHandler, &v10);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTSSResponse", 0xC33u, "Failed to deserialize TSS message");
  bdTSSStructMessage::~bdTSSStructMessage((bdTSSStructMessage *)v10.gap418);
  bdReferencable::~bdReferencable((bdReferencable *)v10.gap418);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleTeamChatMsg
==============
*/
__int64 bdLobbyService::handleTeamChatMsg(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  char v5; 
  bool v6; 
  unsigned __int8 v7; 
  unsigned int length[2]; 
  unsigned __int64 v10; 
  unsigned __int64 u[4]; 
  char s[8]; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  char v20[8]; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  char v28; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  if ( !UInt64 || !bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    v10 = 0i64;
    goto LABEL_6;
  }
  v10 = 0i64;
  if ( !bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v10) )
  {
LABEL_6:
    v5 = 0;
    goto LABEL_7;
  }
  v5 = 1;
LABEL_7:
  *(_QWORD *)v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0;
  v6 = v5 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, v20, 0x40ui64);
  memset_0(blob, 0, sizeof(blob));
  length[0] = 1024;
  if ( v6 && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, length) )
  {
    v7 = 1;
    this->m_eventHandler->onInstantMessage(this->m_eventHandler, u[0], s, blob, length[0], v10);
  }
  else
  {
    v7 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v7;
}

/*
==============
bdLobbyService::handleTeamMemberConnection
==============
*/
__int64 bdLobbyService::handleTeamMemberConnection(bdLobbyService *this, bdReference<bdByteBuffer> message, bdEventType eventType)
{
  bool UInt64; 
  char v7; 
  unsigned __int8 v8; 
  bool v10; 
  unsigned __int64 v11; 
  unsigned __int64 u[3]; 
  char v13[8]; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  char v21; 
  char s[8]; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  char v30; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0;
  if ( !UInt64 || !bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    v11 = 0i64;
    goto LABEL_6;
  }
  v11 = 0i64;
  if ( !bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &v11) )
  {
LABEL_6:
    v7 = 0;
    goto LABEL_7;
  }
  v7 = 1;
LABEL_7:
  *(_QWORD *)v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0;
  if ( v7 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, v13, 0x40ui64) )
  {
    v8 = 1;
    v10 = eventType == BD_TEAMMEMBER_CONNECTED;
    this->m_eventHandler->onTeamMemberStatusUpdate(this->m_eventHandler, u[0], s, v11, v13, v10);
  }
  else
  {
    v8 = 0;
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v8;
}

/*
==============
bdLobbyService::handleTeamMemberRichPresenceUpdated
==============
*/
__int64 bdLobbyService::handleTeamMemberRichPresenceUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  bool function; 
  bool b; 
  unsigned int length; 
  unsigned __int64 u[3]; 
  unsigned __int8 blob[1024]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  length = 1024;
  b = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u) && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) && bdByteBuffer::readBool((bdByteBuffer *)message.m_ptr->__vftable, &b) )
  {
    v4 = 1;
    function = b;
    this->m_eventHandler->onTeamMemberRichPresenceUpdate(this->m_eventHandler, u[0], blob, length, function);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTeamMemberRichPresenceUpdated", 0xF4Cu, "Failed to parse bdTeamsService (RichPresence Updated) push message");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTeamMemberUserNameUpdated
==============
*/
__int64 bdLobbyService::handleTeamMemberUserNameUpdated(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned __int64 u[4]; 
  char s[80]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) )
  {
    v4 = 1;
    this->m_eventHandler->onTeamMemberUserNameUpdate(this->m_eventHandler, u[0], s);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTeamMemberUserNameUpdated", 0xF60u, "Failed to parse bdTeamsService (User Name Changed) push message");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentAASRecord
==============
*/
_BOOL8 bdLobbyService::handleTencentAASRecord(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bdByteBuffer *v4; 
  bool v5; 
  bdTencentAASRecord v7; 
  bdReference<bdByteBuffer> buffer; 

  bdTencentAASRecord::bdTencentAASRecord(&v7);
  v4 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  v5 = bdTencentAASRecord::deserialize(&v7, (bdReference<bdByteBuffer>)&buffer);
  if ( v5 )
    this->m_eventHandler->onTencentAASRecordReceived(this->m_eventHandler, &v7);
  else
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAASRecord", 0xB2Fu, "Failed to deserialize Tencent AAS record message.");
  bdTencentAASRecord::~bdTencentAASRecord((bdTencentAASRecord *)&v7.gap24[4]);
  bdReferencable::~bdReferencable((bdReferencable *)&v7.gap24[4]);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v5;
}

/*
==============
bdLobbyService::handleTencentAntiBotData
==============
*/
_BOOL8 bdLobbyService::handleTencentAntiBotData(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  _BYTE *v5; 
  signed __int64 v6; 
  unsigned __int8 b[4]; 
  unsigned int u; 
  __int64 v10; 
  bdByteBuffer *m_ptr; 
  char dest[32768]; 
  char s[43696]; 

  v10 = -2i64;
  m_ptr = message.m_ptr;
  u = 0;
  b[0] = 0;
  v4 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0xAAADui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  memset_0(dest, 0, sizeof(dest));
  v5 = memchr_0(s, 0, 0xAAADui64);
  if ( v5 )
    v6 = v5 - s;
  else
    LODWORD(v6) = 43693;
  if ( v4 )
  {
    if ( b[0] == 1 )
    {
      bdBase64::decode(s, v6, dest, 0x8000u);
      this->m_eventHandler->onTencentAntibotData(this->m_eventHandler, dest, u);
    }
    else
    {
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAntiBotData", 0xB4Du, "Invalid Tencent antibot data version.");
    }
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentAntiBotPunish
==============
*/
_BOOL8 bdLobbyService::handleTencentAntiBotPunish(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  _BYTE *v5; 
  signed __int64 v6; 
  _BYTE *v7; 
  signed __int64 v8; 
  unsigned __int8 b[4]; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 
  unsigned int u; 
  __int64 v15; 
  bdByteBuffer *m_ptr; 
  char v17[8192]; 
  char dest[8192]; 
  char s[10928]; 
  char Buf[10928]; 

  v15 = -2i64;
  m_ptr = message.m_ptr;
  u = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  b[0] = 0;
  v4 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v13) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x2AADui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v12) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, Buf, 0x2AADui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v11);
  memset_0(dest, 0, sizeof(dest));
  v5 = memchr_0(s, 0, 0x2AADui64);
  if ( v5 )
    v6 = v5 - s;
  else
    LODWORD(v6) = 10925;
  memset_0(v17, 0, sizeof(v17));
  v7 = memchr_0(Buf, 0, 0x2AADui64);
  if ( v7 )
    v8 = v7 - Buf;
  else
    LODWORD(v8) = 10925;
  if ( v4 )
  {
    if ( b[0] == 1 )
    {
      bdBase64::decode(s, v6, dest, 0x2000u);
      bdBase64::decode(Buf, v8, v17, 0x2000u);
      this->m_eventHandler->onTencentAntibotPunish(this->m_eventHandler, u, v13, dest, v12, v17, v11);
    }
    else
    {
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAntiBotPunish", 0xB7Cu, "Invalid Tencent antibot punish info version.");
    }
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentAntibotServerReady
==============
*/
_BOOL8 bdLobbyService::handleTencentAntibotServerReady(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  bdLobbyConnection *v5; 
  bdLobbyConnection::Status Status; 
  bdTencent *m_tencent; 
  unsigned __int8 b; 
  bdByteBuffer *m_ptr; 
  unsigned int u; 
  bdTencent *v12; 

  m_ptr = message.m_ptr;
  b = 0;
  v4 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, &b);
  u = 30;
  bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u);
  v5 = this->m_lobbyConnection.m_ptr;
  if ( v5 && (Status = bdLobbyConnection::getStatus(v5), this->m_lobbyConnectionEstablished) && Status == BD_NOT_CONNECTED )
  {
    m_tencent = this->m_tencent;
    if ( m_tencent )
      goto LABEL_8;
    m_tencent = (bdTencent *)bdMemory::allocate(0x50018ui64);
    v12 = m_tencent;
    if ( m_tencent )
      bdTencent::bdTencent(m_tencent, this->m_taskManager);
    this->m_tencent = m_tencent;
    if ( m_tencent )
LABEL_8:
      bdTencent::setAntibotSendDataInterval(m_tencent, u);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::getTencent", 0x4A7u, "Not connected.");
  }
  if ( v4 )
  {
    if ( b == 1 )
      this->m_eventHandler->onTencentAntibotServerReady(this->m_eventHandler);
    else
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentAntibotServerReady", 0xB9Du, "Invalid antibot server ready message version.");
  }
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentLoudSpeakerMessage
==============
*/
__int64 bdLobbyService::handleTencentLoudSpeakerMessage(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned int length; 
  unsigned int v7; 
  unsigned __int64 u[3]; 
  char s[8]; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  unsigned __int8 blob[4096]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  *(_QWORD *)s = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v7 = 0;
  memset_0(blob, 0, sizeof(blob));
  length = 4096;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v7) && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v4 = 1;
    this->m_eventHandler->onTencentLoudSpeakerMessage(this->m_eventHandler, u[0], s, (bdCODOLoudSpeakerType)v7, blob, length);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentLoudSpeakerMessage", 0xBD7u, "Failed to read data from Tencent LoudSpeaker push message.");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentNameChanged
==============
*/
_BOOL8 bdLobbyService::handleTencentNameChanged(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool String; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onTencentUsernameChanged)(bdLobbyEventHandler *, const char *, unsigned int); 
  _BYTE *v7; 
  char s[1024]; 

  memset_0(s, 0, sizeof(s));
  String = bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x400ui64);
  if ( String )
  {
    m_eventHandler = this->m_eventHandler;
    onTencentUsernameChanged = m_eventHandler->onTencentUsernameChanged;
    v7 = memchr_0(s, 0, 0x400ui64);
    if ( v7 )
      onTencentUsernameChanged(m_eventHandler, s, v7 - s);
    else
      onTencentUsernameChanged(m_eventHandler, s, 1024u);
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentNameChanged", 0xC44u, "Failed to parse name change connection data");
  }
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return String;
}

/*
==============
bdLobbyService::handleTencentNoRewardReceived
==============
*/
__int64 bdLobbyService::handleTencentNoRewardReceived(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned int u; 
  unsigned __int64 v7[3]; 
  char s[48]; 

  v7[1] = -2i64;
  v7[2] = (unsigned __int64)message.m_ptr;
  v7[0] = 0i64;
  u = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, v7) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x2Dui64) )
  {
    v4 = 1;
    this->m_eventHandler->onTencentPlayerNoReward(this->m_eventHandler, v7[0], u, s);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentNoRewardReceived", 0xC22u, "Failed to parse reward message");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentReward
==============
*/
__int64 bdLobbyService::handleTencentReward(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  unsigned __int8 v4; 
  unsigned int length; 
  unsigned int v7; 
  unsigned __int64 u[3]; 
  char s[48]; 
  unsigned __int8 blob[4096]; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  v7 = 0;
  length = 0;
  if ( bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &v7) && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x2Dui64) && bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &length) && length <= 0x1000 && bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, blob, &length) )
  {
    v4 = 1;
    this->m_eventHandler->onTencentPlayerReward(this->m_eventHandler, u[0], v7, s, length, blob);
  }
  else
  {
    v4 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentReward", 0xC0Du, "Failed to parse reward message");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleTencentUserLeaveReason
==============
*/
__int64 bdLobbyService::handleTencentUserLeaveReason(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UInt64; 
  bool v5; 
  unsigned __int8 v6; 
  bdLobbyEventHandler *m_eventHandler; 
  void (__fastcall *onTencentNotifyLeaveReason)(bdLobbyEventHandler *, unsigned __int64, bdSessionID, unsigned int); 
  unsigned int v9; 
  __int64 v10; 
  unsigned int length[2]; 
  unsigned __int64 u[4]; 
  bdSessionID v14; 
  bdSessionID other; 
  char s[8]; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 

  u[1] = -2i64;
  u[2] = (unsigned __int64)message.m_ptr;
  u[0] = 0i64;
  UInt64 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, u);
  *(_QWORD *)s = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v5 = UInt64 && bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x40ui64);
  bdSessionID::bdSessionID(&other);
  length[1] = 8;
  if ( !v5 || !bdByteBuffer::readBlob((bdByteBuffer *)message.m_ptr->__vftable, other._bytes_20, &length[1]) )
  {
    length[0] = 0;
    goto LABEL_10;
  }
  length[0] = 0;
  if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, length) )
  {
LABEL_10:
    v6 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleTencentUserLeaveReason", 0xBB9u, "Failed to read data from Tencent User Leave Reason push message.");
    goto LABEL_11;
  }
  v6 = 1;
  m_eventHandler = this->m_eventHandler;
  onTencentNotifyLeaveReason = m_eventHandler->onTencentNotifyLeaveReason;
  v9 = length[0];
  bdSessionID::bdSessionID(&v14, &other);
  ((void (__fastcall *)(bdLobbyEventHandler *, unsigned __int64, __int64, _QWORD))onTencentNotifyLeaveReason)(m_eventHandler, u[0], v10, v9);
LABEL_11:
  bdSecurityID::~bdSecurityID((bdSecurityID *)other._bytes_20);
  bdSerializable::~bdSerializable((bdSerializable *)other._bytes_20);
  bdTaskResult::~bdTaskResult((bdTaskResult *)(&other.__vftable + 2));
  bdReferencable::~bdReferencable((bdReferencable *)&other._bytes_20[8]);
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::handleTitleVersionDisabled
==============
*/
_BOOL8 bdLobbyService::handleTitleVersionDisabled(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool v4; 
  unsigned __int64 u; 

  u = 0i64;
  v4 = bdByteBuffer::readUInt64((bdByteBuffer *)message.m_ptr->__vftable, &u);
  if ( v4 )
    this->m_eventHandler->onTitleVersionDisabled(this->m_eventHandler, u);
  if ( message.m_ptr->__vftable && !_InterlockedDecrement((volatile signed __int32 *)&message.m_ptr->allocateBuffer) )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v4;
}

/*
==============
bdLobbyService::handleWebserviceStorageFileWrite
==============
*/
__int64 bdLobbyService::handleWebserviceStorageFileWrite(bdLobbyService *this, bdReference<bdByteBuffer> message)
{
  bool UByte8; 
  bdByteBuffer *v5; 
  unsigned __int8 v6; 
  unsigned int v7; 
  unsigned __int8 b[4]; 
  unsigned int u; 
  bdReference<bdByteBuffer> buffer; 
  __int64 v12; 
  bdByteBuffer *m_ptr; 
  char context[8]; 
  __int64 v15; 
  char s[128]; 

  v12 = -2i64;
  m_ptr = message.m_ptr;
  b[0] = 0;
  UByte8 = bdByteBuffer::readUByte8((bdByteBuffer *)message.m_ptr->__vftable, b);
  if ( b[0] != 1 )
  {
    UByte8 = 0;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleWebserviceStorageFileWrite", 0xE54u, "Unsupported webservice storage write push message version.");
  }
  *(_QWORD *)context = 0i64;
  v15 = 0i64;
  if ( !UByte8 )
    goto LABEL_10;
  v5 = (bdByteBuffer *)message.m_ptr->__vftable;
  buffer.m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  if ( !ContextSerialization::readContext((bdReference<bdByteBuffer>)&buffer, context, 0x10u) )
  {
LABEL_10:
    u = 0;
    goto LABEL_11;
  }
  u = 0;
  if ( !bdByteBuffer::readUInt32((bdByteBuffer *)message.m_ptr->__vftable, &u) )
  {
LABEL_11:
    v6 = 0;
    goto LABEL_12;
  }
  v6 = 1;
  if ( u > 0x40 )
  {
    u = 64;
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleWebserviceStorageFileWrite", 0xE63u, "Too many file names sent in push message. Code can only handle %d.", 64);
  }
LABEL_12:
  v7 = 0;
  if ( v6 )
  {
    while ( v7 < u )
    {
      if ( bdByteBuffer::readString((bdByteBuffer *)message.m_ptr->__vftable, s, 0x80ui64) )
      {
        v6 = 1;
        this->m_eventHandler->onWebserviceStorageFileWrite(this->m_eventHandler, context, s);
      }
      else
      {
        v6 = 0;
      }
      ++v7;
      if ( !v6 )
        goto LABEL_20;
    }
  }
  else
  {
LABEL_20:
    bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::handleWebserviceStorageFileWrite", 0xE74u, "Failed to parse webservice storage file write message.");
  }
  if ( message.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&message.m_ptr->allocateBuffer, 0xFFFFFFFF) == 1 )
  {
    if ( message.m_ptr->__vftable )
      (*(void (__fastcall **)(bdByteBuffer_vtbl *, __int64))message.m_ptr->~bdReferencable)(message.m_ptr->__vftable, 1i64);
    message.m_ptr->__vftable = NULL;
  }
  return v6;
}

/*
==============
bdLobbyService::isConnected
==============
*/
bool bdLobbyService::isConnected(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  return m_ptr && bdLobbyConnection::getStatus(m_ptr) == BD_NOT_CONNECTED;
}

/*
==============
bdLobbyService::onConnect
==============
*/
void bdLobbyService::onConnect(bdLobbyService *this, bdReference<bdLobbyConnection> connection)
{
  bdRemoteTaskManager *v4; 
  bool m_encryptedConnection; 
  bdLobbyConnection *v6; 
  bdRemoteTaskManager *v7; 
  bdRemoteTaskManager *v8; 
  bdRESTTaskManager *m_restTaskManager; 
  bdReference<bdLobbyConnection> connectiona; 
  bdLobbyConnection *m_ptr; 
  void *v12; 

  m_ptr = connection.m_ptr;
  this->m_lobbyConnectionEstablished = 0;
  bdHandleAssert(this->m_taskManager == NULL, "m_taskManager == BD_NULL", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::onConnect", 0x625u, "onConnect() called twice without a call to cleanup().  This will leak!");
  v4 = (bdRemoteTaskManager *)bdMemory::allocate(0x80ui64);
  v12 = v4;
  if ( v4 )
  {
    m_encryptedConnection = this->m_encryptedConnection;
    v6 = (bdLobbyConnection *)connection.m_ptr->__vftable;
    connectiona.m_ptr = v6;
    if ( v6 )
      _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_refCount, 1u);
    bdRemoteTaskManager::bdRemoteTaskManager(v4, (bdReference<bdLobbyConnection>)&connectiona, m_encryptedConnection);
    v8 = v7;
  }
  else
  {
    v8 = NULL;
  }
  this->m_taskManager = v8;
  m_restTaskManager = this->m_restTaskManager;
  if ( !m_restTaskManager )
  {
    m_restTaskManager = (bdRESTTaskManager *)bdMemory::allocate(0x30ui64);
    v12 = m_restTaskManager;
    if ( m_restTaskManager )
      bdRESTTaskManager::bdRESTTaskManager(m_restTaskManager, &restConfig, this);
    this->m_restTaskManager = m_restTaskManager;
  }
  bdRemoteTaskManager::setRESTTaskManager(v8, m_restTaskManager);
  bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::onConnect", 0x628u, "Connected to MatchMaking Service.");
  if ( connection.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&connection.m_ptr->sendTask, 0xFFFFFFFF) == 1 )
  {
    if ( connection.m_ptr->__vftable )
      (*(void (__fastcall **)(bdLobbyConnection_vtbl *, __int64))connection.m_ptr->~bdReferencable)(connection.m_ptr->__vftable, 1i64);
    connection.m_ptr->__vftable = NULL;
  }
}

/*
==============
bdLobbyService::onDisconnect
==============
*/
void bdLobbyService::onDisconnect(bdLobbyService *this, bdReference<bdLobbyConnection> __formal)
{
  bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::onDisconnect", 0x62Eu, "Disconnected from MatchMaking Service.");
  if ( __formal.m_ptr->__vftable && _InterlockedExchangeAdd((volatile signed __int32 *)&__formal.m_ptr->sendTask, 0xFFFFFFFF) == 1 )
  {
    if ( __formal.m_ptr->__vftable )
      (*(void (__fastcall **)(bdLobbyConnection_vtbl *, __int64))__formal.m_ptr->~bdReferencable)(__formal.m_ptr->__vftable, 1i64);
    __formal.m_ptr->__vftable = NULL;
  }
}

/*
==============
bdLobbyService::pump
==============
*/

void __fastcall bdLobbyService::pump(bdLobbyService *this, double _XMM1_8, double _XMM2_8)
{
  unsigned int LoResTimeStamp; 
  char v6; 
  char v12; 
  bdLobbyConnection *m_ptr; 
  bdRemoteTaskManager *v15; 
  unsigned int v16; 
  bdRemoteTaskManager *v17; 
  bdRemoteTaskManager *m_taskManager; 
  bdRESTTaskManager *m_restTaskManager; 
  unsigned int line; 
  char *format; 
  __int64 v22; 
  double v23; 
  unsigned __int64 u; 
  bdReference<bdByteBuffer> message; 
  bdReference<bdByteBuffer> v26; 
  __int64 v27; 
  unsigned __int8 type; 
  unsigned int v29; 
  bdReference<bdByteBuffer> payload; 
  bdReference<bdByteBuffer> buffer; 

  v27 = -2i64;
  LoResTimeStamp = bdPlatformTiming::getLoResTimeStamp();
  bdPlatformTiming::getLoResElapsedTime(this->m_lastPumpTime, LoResTimeStamp);
  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rdx
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, rdx
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm1, xmm0
  }
  if ( !v12 )
  {
    __asm { vcomiss xmm2, cs:__real@41200000 }
    if ( !v6 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm2, xmm2
        vmovsd  [rsp+68h+var_30], xmm0
      }
      bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x170u, "\nSTARVATION - bdLobbyService has been starved for %.2f seconds\n", v23);
    }
  }
  this->m_lastPumpTime = LoResTimeStamp;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
  {
    payload.m_ptr = NULL;
    type = 0;
    while ( 1 )
    {
      if ( !bdLobbyConnection::getMessageToDispatch(m_ptr, &type, &payload) )
      {
LABEL_34:
        m_taskManager = this->m_taskManager;
        if ( m_taskManager )
          bdRemoteTaskManager::cleanUpAsyncState(m_taskManager);
        m_restTaskManager = this->m_restTaskManager;
        if ( m_restTaskManager )
          bdRESTTaskManager::pump(m_restTaskManager);
        if ( payload.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&payload.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( payload.m_ptr )
            ((void (__fastcall *)(bdByteBuffer *, __int64))payload.m_ptr->~bdReferencable)(payload.m_ptr, 1i64);
        }
        return;
      }
      switch ( type )
      {
        case 1u:
          bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x190u, "Received message of type: BD_LOBBY_SERVICE_TASK_REPLY");
          v17 = this->m_taskManager;
          if ( !v17 || !payload.m_ptr )
          {
            format = "Null message or no task manager.";
            line = 408;
            goto LABEL_32;
          }
          v26.m_ptr = payload.m_ptr;
          _InterlockedExchangeAdd((volatile signed __int32 *)&payload.m_ptr->m_refCount, 1u);
          bdRemoteTaskManager::handleLSGTaskReply(v17, (const bdReference<bdByteBuffer>)&v26);
          break;
        case 2u:
          bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x19Eu, "Received message of type: BD_LOBBY_SERVICE_PUSH_MESSAGE");
          message.m_ptr = payload.m_ptr;
          if ( payload.m_ptr )
            _InterlockedExchangeAdd((volatile signed __int32 *)&payload.m_ptr->m_refCount, 1u);
          bdLobbyService::handlePushMessage(this, (bdReference<bdByteBuffer>)&message);
          break;
        case 3u:
          if ( bdByteBuffer::readUInt32(payload.m_ptr, &v29) )
          {
            v16 = v29;
            this->m_errorCode = v29;
            LODWORD(v22) = v16;
            bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x1A8u, "Received LSG error: %u", v22);
          }
          else
          {
            bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x1ACu, "Received LSG error message, but cannot read out errorCode.");
          }
          break;
        case 4u:
          if ( bdByteBuffer::readUInt64(payload.m_ptr, &u) )
          {
            if ( this->m_taskManager )
            {
              bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x1B7u, "Received LSG connection ID:%I64u", u);
              this->m_taskManager->m_connectionID = u;
              this->m_lobbyConnectionEstablished = 1;
            }
            else
            {
              bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x1BDu, "No task manager to assign connection ID to.");
            }
            break;
          }
          format = "Received LSG connection ID header, but couldn't read ID.";
          line = 450;
          goto LABEL_32;
        case 5u:
          bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x182u, "Received message of type: BD_LSG_SERVICE_TASK_REPLY");
          v15 = this->m_taskManager;
          if ( !v15 || !payload.m_ptr )
          {
            format = "Null message or no task manager.";
            line = 394;
LABEL_32:
            bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", line, format);
            break;
          }
          buffer.m_ptr = payload.m_ptr;
          _InterlockedExchangeAdd((volatile signed __int32 *)&payload.m_ptr->m_refCount, 1u);
          bdRemoteTaskManager::handleTaskReply(v15, (const bdReference<bdByteBuffer>)&buffer);
          break;
        default:
          LODWORD(v22) = type;
          bdLogMessage(BD_LOG_WARNING, "warn/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pump", 0x1C8u, "Received unknown message type: %u.", v22);
          break;
      }
      m_ptr = this->m_lobbyConnection.m_ptr;
      if ( !m_ptr )
        goto LABEL_34;
    }
  }
}

/*
==============
bdLobbyService::pumpDNSLookup
==============
*/
_BOOL8 bdLobbyService::pumpDNSLookup(bdLobbyService *this, bdGetHostByName::bdStatus *status)
{
  bdGetHostByName::bdStatus v4; 
  bdGetHostByName::bdStatus v6; 
  bdSockAddr result; 
  char str[24]; 

  if ( !this->m_isResolved )
  {
    v4 = bdGetHostByName::getStatus(&this->m_LSGLookup);
    *status = v4;
    if ( v4 )
    {
      if ( v4 == BD_LOOKUP_PENDING )
      {
        bdGetHostByName::pump(&this->m_LSGLookup);
        return this->m_isResolved;
      }
      if ( v4 == BD_LOOKUP_SUCCEEDED )
      {
        if ( !bdGetHostByName::getNumAddresses(&this->m_LSGLookup) )
          return this->m_isResolved;
        bdGetHostByName::getAddressAt(&this->m_LSGLookup, &result, 0);
        bdAddr::set(&this->m_resolvedLSGAddress, &result, this->m_LSGPort);
        bdAddr::toString(&this->m_resolvedLSGAddress, str, 0x16ui64);
        bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pumpDNSLookup", 0x118u, "Lobby DNS lookup success (%s)", str);
        goto LABEL_7;
      }
      if ( (unsigned int)(v4 - 3) > 3 )
        return this->m_isResolved;
    }
    v6 = v4;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pumpDNSLookup", 0x123u, "Lobby DNS Lookup Error (status: %u)", v6);
LABEL_7:
    this->m_isResolved = 1;
    return this->m_isResolved;
  }
  return this->m_isResolved;
}

/*
==============
bdLobbyService::pumpLSGLookup
==============
*/
_BOOL8 bdLobbyService::pumpLSGLookup(bdLobbyService *this, bdGetHostByName::bdStatus *status)
{
  bdGetHostByName::bdStatus *v2; 
  bdGetHostByName::bdStatus v4; 
  bdGetHostByName::bdStatus v6; 
  char v7; 
  bdSockAddr result; 
  char str[24]; 

  v2 = (bdGetHostByName::bdStatus *)&v7;
  if ( status )
    v2 = status;
  if ( !this->m_isResolved )
  {
    v4 = bdGetHostByName::getStatus(&this->m_LSGLookup);
    *v2 = v4;
    if ( v4 )
    {
      if ( v4 == BD_LOOKUP_PENDING )
      {
        bdGetHostByName::pump(&this->m_LSGLookup);
        return this->m_isResolved;
      }
      if ( v4 == BD_LOOKUP_SUCCEEDED )
      {
        if ( !bdGetHostByName::getNumAddresses(&this->m_LSGLookup) )
          return this->m_isResolved;
        bdGetHostByName::getAddressAt(&this->m_LSGLookup, &result, 0);
        bdAddr::set(&this->m_resolvedLSGAddress, &result, this->m_LSGPort);
        bdAddr::toString(&this->m_resolvedLSGAddress, str, 0x16ui64);
        bdLogMessage(BD_LOG_INFO, "info/", "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pumpDNSLookup", 0x118u, "Lobby DNS lookup success (%s)", str);
        goto LABEL_9;
      }
      if ( (unsigned int)(v4 - 3) > 3 )
        return this->m_isResolved;
    }
    v6 = v4;
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "lobby service", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlobbyservice.cpp", "bdLobbyService::pumpDNSLookup", 0x123u, "Lobby DNS Lookup Error (status: %u)", v6);
LABEL_9:
    this->m_isResolved = 1;
    return this->m_isResolved;
  }
  return this->m_isResolved;
}

/*
==============
bdLobbyService::registerEventHandler
==============
*/
void bdLobbyService::registerEventHandler(bdLobbyService *this, bdLobbyEventHandler *eventHandler)
{
  this->m_eventHandler = eventHandler;
}

/*
==============
bdLobbyService::registerPushMessageHandler
==============
*/
char bdLobbyService::registerPushMessageHandler(bdLobbyService *this, bdPushMessageHandler *handler)
{
  bdPushMessageHandler *v3; 
  bdLobbyService *v4; 
  char v5; 
  unsigned int i; 
  __int64 v7; 
  __int64 m_capacity; 
  __int64 v9; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node **m_map; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v11; 
  unsigned int m_size; 
  unsigned int PowerOf2; 
  __int64 v14; 
  unsigned int v15; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node **v19; 
  __int64 v20; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v21; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v22; 
  _DWORD *v23; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v24; 
  __int64 v26; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node **v27; 
  __int64 v28; 
  unsigned int v31; 
  _DWORD *v32; 

  v28 = -2i64;
  v3 = handler;
  v4 = this;
  v5 = 1;
  if ( !handler )
    return 0;
  v26 = 0i64;
  v31 = 0;
  handler->getEventTypes(handler, (const bdEventType **)&v26, &v31);
  for ( i = 0; i < v31; v4 = this )
  {
    if ( v5 )
    {
      v7 = v26;
      bdHandleAssert(v4->m_pushHandlers.m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<enum bdEventType,class bdPushMessageHandler *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap");
      LODWORD(v32) = *(unsigned __int8 *)(v7 + 4i64 * i + 3) ^ (16777619 * (*(unsigned __int8 *)(v7 + 4i64 * i + 2) ^ (16777619 * (*(unsigned __int8 *)(v7 + 4i64 * i + 1) ^ (16777619 * *(unsigned __int8 *)(v7 + 4i64 * i))))));
      m_capacity = v4->m_pushHandlers.m_capacity;
      v9 = (unsigned int)v32 & ((_DWORD)m_capacity - 1);
      m_map = v4->m_pushHandlers.m_map;
      v27 = m_map;
      v11 = m_map[v9];
      if ( !v11 )
      {
LABEL_7:
        m_size = v4->m_pushHandlers.m_size;
        if ( m_size + 1 > v4->m_pushHandlers.m_threshold )
        {
          PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
          v14 = PowerOf2;
          v15 = v4->m_pushHandlers.m_capacity;
          if ( PowerOf2 > v15 )
          {
            v4->m_pushHandlers.m_capacity = PowerOf2;
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, rcx
              vmulss  xmm0, xmm0, dword ptr [rdi+40h]
              vcvttss2si rax, xmm0
            }
            v4->m_pushHandlers.m_threshold = _RAX;
            v19 = (bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node **)bdMemory::allocate(8 * v14);
            v4->m_pushHandlers.m_map = v19;
            v4->m_pushHandlers.m_size = 0;
            memset_0(v19, 0, 8i64 * v4->m_pushHandlers.m_capacity);
            if ( (_DWORD)m_capacity )
            {
              v20 = m_capacity;
              do
              {
                v21 = *m_map;
                while ( v21 )
                {
                  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::put(&v4->m_pushHandlers, &v21->m_key, &v21->m_data);
                  v22 = v21;
                  v21 = v21->m_next;
                  bdMemory::deallocate(v22);
                }
                ++m_map;
                --v20;
              }
              while ( v20 );
              m_map = v27;
              v3 = handler;
            }
            bdMemory::deallocate(m_map);
            v15 = this->m_pushHandlers.m_capacity;
          }
          v9 = (unsigned int)v32 & (v15 - 1);
          m_size = v4->m_pushHandlers.m_size;
        }
        v4->m_pushHandlers.m_size = m_size + 1;
        v23 = bdMemory::allocate(0x18ui64);
        v32 = v23;
        if ( v23 )
        {
          v24 = v4->m_pushHandlers.m_map[v9];
          *(_QWORD *)v23 = v3;
          v23[2] = *(_DWORD *)(v7 + 4i64 * i);
          *((_QWORD *)v23 + 2) = v24;
          v4->m_pushHandlers.m_map[(unsigned int)v9] = (bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *)v23;
        }
        else
        {
          v4->m_pushHandlers.m_map[(unsigned int)v9] = NULL;
        }
        v5 = 1;
        goto LABEL_22;
      }
      while ( *(_DWORD *)(v7 + 4i64 * i) != v11->m_key )
      {
        v11 = v11->m_next;
        if ( !v11 )
          goto LABEL_7;
      }
    }
    v5 = 0;
LABEL_22:
    ++i;
  }
  return v5;
}

/*
==============
bdLobbyService::registerPushMessageHandler
==============
*/
_BOOL8 bdLobbyService::registerPushMessageHandler(bdLobbyService *this, bdString sender, bdDemonataPushMessageHandler *handler)
{
  bool v4; 
  bdDemonataPushMessageHandler *value; 

  value = handler;
  v4 = handler && bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put(&this->m_demonataPushHandlers, (const bdString *)sender.m_string, &value);
  bdString::~bdString((bdString *)sender.m_string);
  return v4;
}

/*
==============
bdLobbyService::setABTestingTokenAndExpiry
==============
*/
bool bdLobbyService::setABTestingTokenAndExpiry(bdLobbyService *this, const char *const abTestingToken, const unsigned __int64 abTestingTokenExpiresInSeconds)
{
  this->m_abTestingTokenExpiresInSeconds = abTestingTokenExpiresInSeconds;
  return bdStrlcpy(this->m_abTestingToken, abTestingToken, 0x1000ui64) < 0x1000;
}

/*
==============
bdLobbyService::setTasksAreThrottled
==============
*/
void bdLobbyService::setTasksAreThrottled(bdLobbyService *this, bool areThrottled)
{
  this->m_markTasksThrottled = areThrottled;
  bdLobbyService::updateConnectionThrottleParams(this);
}

/*
==============
bdLobbyService::setUploadThrottle
==============
*/
void bdLobbyService::setUploadThrottle(bdLobbyService *this, bool isEnabled)
{
  bdLobbyConnection *m_ptr; 
  bdTokenBucket *ThrottleBucket; 

  this->m_uploadThrottled = isEnabled;
  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
  {
    ThrottleBucket = bdLobbyConnection::getThrottleBucket(m_ptr);
    bdTokenBucket::setTokensRestricted(ThrottleBucket, isEnabled);
  }
}

/*
==============
bdLobbyService::setUploadThrottleRate
==============
*/
void bdLobbyService::setUploadThrottleRate(bdLobbyService *this, unsigned int bytesPerSecond, unsigned int bucketSizeBytes)
{
  unsigned int v3; 
  unsigned int v4; 

  if ( bytesPerSecond < 0x7D0 )
    v3 = 1;
  else
    v3 = bytesPerSecond / 0x3E8;
  v4 = 600;
  this->m_uploadThrottleBytesPerMs = v3;
  if ( bucketSizeBytes > 0x258 )
    v4 = bucketSizeBytes;
  this->m_uploadThrottleBucketSize = v4;
  bdLobbyService::updateConnectionThrottleParams(this);
}

/*
==============
bdLobbyService::unregisterPushMessageHandler
==============
*/
char bdLobbyService::unregisterPushMessageHandler(bdLobbyService *this, bdPushMessageHandler *handler)
{
  char v3; 
  __int64 i; 
  unsigned __int8 *v5; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node **v6; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v7; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *v8; 
  bdHashMap<enum bdEventType,bdPushMessageHandler *,bdHashingClass>::Node *m_next; 
  __int64 v11; 
  unsigned int v12; 
  __int64 v13; 

  v11 = -2i64;
  v3 = 1;
  if ( !handler )
    return 0;
  v13 = 0i64;
  v12 = 0;
  handler->getEventTypes(handler, (const bdEventType **)&v13, &v12);
  for ( i = 0i64; (unsigned int)i < v12; i = (unsigned int)(i + 1) )
  {
    if ( v3 && (v5 = (unsigned __int8 *)(v13 + 4 * i), bdHandleAssert(this->m_pushHandlers.m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<enum bdEventType,class bdPushMessageHandler *,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", v11), v6 = &this->m_pushHandlers.m_map[(this->m_pushHandlers.m_capacity - 1) & (v5[3] ^ (16777619 * (v5[2] ^ (16777619 * (v5[1] ^ (16777619 * *v5))))))], v7 = *v6, v8 = NULL, *v6) )
    {
      while ( *(_DWORD *)v5 != v7->m_key )
      {
        v8 = v7;
        v7 = v7->m_next;
        if ( !v7 )
          goto LABEL_7;
      }
      m_next = v7->m_next;
      if ( v8 )
        v8->m_next = m_next;
      else
        *v6 = m_next;
      bdMemory::deallocate(v7);
      --this->m_pushHandlers.m_size;
      v3 = 1;
    }
    else
    {
LABEL_7:
      v3 = 0;
    }
  }
  return v3;
}

/*
==============
bdLobbyService::unregisterPushMessageHandler
==============
*/
__int64 bdLobbyService::unregisterPushMessageHandler(bdLobbyService *this, bdString sender)
{
  __int64 v4; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v5; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v6; 
  unsigned __int8 v7; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_demonataPushHandlers.m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = bdHashingClass::getHash<bdString>(&this->m_demonataPushHandlers.m_hashClass, (const bdString *)sender.m_string) & (this->m_demonataPushHandlers.m_capacity - 1);
  v5 = this->m_demonataPushHandlers.m_map[v4];
  v6 = NULL;
  if ( v5 )
  {
    while ( !bdString::operator==((bdString *)sender.m_string, &v5->m_key) )
    {
      v6 = v5;
      v5 = v5->m_next;
      if ( !v5 )
        goto LABEL_4;
    }
    m_next = v5->m_next;
    if ( v6 )
      v6->m_next = m_next;
    else
      this->m_demonataPushHandlers.m_map[v4] = m_next;
    bdString::~bdString((bdString *)&v5->m_key);
    bdMemory::deallocate(v5);
    --this->m_demonataPushHandlers.m_size;
    v7 = 1;
  }
  else
  {
LABEL_4:
    v7 = 0;
  }
  bdString::~bdString((bdString *)sender.m_string);
  return v7;
}

/*
==============
bdLobbyService::updateConnectionThrottleParams
==============
*/
void bdLobbyService::updateConnectionThrottleParams(bdLobbyService *this)
{
  bdLobbyConnection *m_ptr; 
  bdTokenBucket *ThrottleBucket; 
  bdTokenBucket *v4; 
  bdTokenBucket *v5; 

  m_ptr = this->m_lobbyConnection.m_ptr;
  if ( m_ptr )
  {
    ThrottleBucket = bdLobbyConnection::getThrottleBucket(m_ptr);
    bdTokenBucket::setTokensRestricted(ThrottleBucket, this->m_uploadThrottled);
    v4 = bdLobbyConnection::getThrottleBucket(this->m_lobbyConnection.m_ptr);
    bdTokenBucket::setRates(v4, this->m_uploadThrottleBytesPerMs, this->m_uploadThrottleBucketSize);
    v5 = bdLobbyConnection::getThrottleBucket(this->m_lobbyConnection.m_ptr);
    bdTokenBucket::setMinFragment(v5, 0x258u);
    bdLobbyConnection::setTasksAreThrottled(this->m_lobbyConnection.m_ptr, this->m_markTasksThrottled);
  }
}

