/*
==============
AIScriptedInterface::OnScrCmd_CodeMoveRequested
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CodeMoveRequested(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CodeMoveRequested@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FlagEnemyUnattackable@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceThreatUpdate@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishTraverse
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishTraverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishTraverse@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBTGoal
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearBTGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearBTGoal@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOnPath
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPosOnPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPosOnPath@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IW7ShipHack_SetMayMoveTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcAnimStartPos
==============
*/

void __fastcall AIScriptedInterface::CalcAnimStartPos(const vec3_t *stopPos, const float stopYaw, const vec3_t *animDelta, const float animAngleDelta, vec3_t *outPos)
{
  ?CalcAnimStartPos@AIScriptedInterface@@SAXAEBTvec3_t@@M0MAEAT2@@Z(stopPos, stopYaw, animDelta, animAngleDelta, outPos);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInGoal
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsInGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInGoal@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/

void __fastcall AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindLastPointOnPathWithinVolume@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSuppressEnemy
==============
*/

bool __fastcall AIScriptedInterface::CanSuppressEnemy(AIScriptedInterface *this)
{
  return ?CanSuppressEnemy@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsStanceAllowed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsStanceAllowed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsStanceAllowed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartCoverArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartCoverArrival@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_ClearPath
==============
*/

void __fastcall AICommonInterface::OnScrCmd_ClearPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPath@AICommonInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShouldCautiousStrafe@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CalcSharpTurnAnim@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_Melee
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_Melee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_Melee@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateLastCoverTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateLastCoverTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBaseArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBaseArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle3D
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetMotionAngle3D(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetMotionAngle3D@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSee
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanSee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanSee@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupDoorOpen
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetupDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetupDoorOpen@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsSuppressed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetCoverSelectionFocusEnt@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYaw
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeHideYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeHideYaw@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::ClearIdleFacingUseAlliesPos
==============
*/

void __fastcall AIScriptedInterface::ClearIdleFacingUseAlliesPos(AIScriptedInterface *this)
{
  ?ClearIdleFacingUseAlliesPos@AIScriptedInterface@@IEBAXXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGunAdditive
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGunAdditive(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGunAdditive@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetStrafeReverse
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetStrafeReverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetStrafeReverse@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIPlayGesture
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIPlayGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIPlayGesture@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPotentialThreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPotentialThreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ChooseArrivalType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ChooseArrivalType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ChooseArrivalType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::HasSuppressableEnemy
==============
*/

bool __fastcall AIScriptedInterface::HasSuppressableEnemy(AIScriptedInterface *this)
{
  return ?HasSuppressableEnemy@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressionWaiting
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsSuppressionWaiting@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverTacPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetCoverTacPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetCoverTacPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushGetNextAmbushNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetLastPathPointWithinGoal@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_DropWeaponNoVelocity@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateSharpTurnAnim
==============
*/

bool __fastcall AIScriptedInterface::CalculateSharpTurnAnim(AIScriptedInterface *this, unsigned int angleIndexCount, int *angleIndices, scr_string_t animsetName, scr_string_t stateName, const vec3_t *corner, const vec3_t *nextPathPoint, const char *footPrefix, const char *optionalPrefix, const char *optionalSuffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  return ?CalculateSharpTurnAnim@AIScriptedInterface@@QEBA_NIPEAHW4scr_string_t@@1Tvec3_t@@2PEBD33PEAUscr_anim_t@@00@Z(this, angleIndexCount, angleIndices, animsetName, stateName, corner, nextPathPoint, footPrefix, optionalPrefix, optionalSuffix, outAnim, outAngleIndex, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceUpdateGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsGunBlockedByWall
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsGunBlockedByWall@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CheckPitchVisibility
==============
*/

bool __fastcall AIScriptedInterface::CheckPitchVisibility(AIScriptedInterface *this, const vec3_t *fromPoint, const vec3_t *toPoint, const pathnode_t *pNode)
{
  return ?CheckPitchVisibility@AIScriptedInterface@@IEBA_NAEBTvec3_t@@0PEBUpathnode_t@@@Z(this, fromPoint, toPoint, pNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShoot
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanShoot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanShoot@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPitchOrient
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPitchOrient@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateAimInfo
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateAimInfo(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateAimInfo@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_BTGoalValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_BTGoalValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_BTGoalValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationStartNode
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationStartNode(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationStartNode@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIGetAnimTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIGetAnimTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_IsInBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_IsInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishCoverArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishCoverArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundSlope
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGroundSlope(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGroundSlope@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNearbyNegotiationInfo@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireClear
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireClear(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireClear@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::GetEnemySuppressPos
==============
*/

void __fastcall AIScriptedInterface::GetEnemySuppressPos(AIScriptedInterface *this, vec3_t *outEnemyEyePos)
{
  ?GetEnemySuppressPos@AIScriptedInterface@@IEBAXAEATvec3_t@@@Z(this, outEnemyEyePos);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsCoverValidAgainstEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PreCalcShouldStartArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTraversals
==============
*/

void __fastcall AICommonInterface::OnScrCmd_EnableTraversals(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnableTraversals@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShootEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanShootEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanShootEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_NearClaimNodeAndAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBaseArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetBaseArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetReacquireState
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetReacquireState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetReacquireState@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDefaultAimLimits
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetDefaultAimLimits@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsLegacyAgent
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsLegacyAgent(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsLegacyAgent@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetSpeedScaleMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetSpeedScaleMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetSecondaryTargets
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetSecondaryTargets(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetSecondaryTargets@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushIsCurrentNodeValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAdjustedExitDirection@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsMoveSuppressed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsMoveSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsMoveSuppressed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireMove
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireMove@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFacialIndexFromASM@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalEnt
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalEnt@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndex
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFacialIndex(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFacialIndex@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveCheckFriendlyFire@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPathDistToGoal
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPathDistToGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPathDistToGoal@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPotentialThreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPotentialThreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPitchOrient
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPitchOrient@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_SetC8ObstacleFlag
==============
*/

void __fastcall AICommonInterface::OnScrCmd_SetC8ObstacleFlag(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetC8ObstacleFlag@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTeamwalking
==============
*/

void __fastcall AICommonInterface::OnScrCmd_EnableTeamwalking(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnableTeamwalking@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeHideYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::AISuppressAI
==============
*/

bool __fastcall AIScriptedInterface::AISuppressAI(AIScriptedInterface *this)
{
  return ?AISuppressAI@AIScriptedInterface@@QEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetWorldWeaponOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimPitchOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanAimWhileMoving
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanAimWhileMoving(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanAimWhileMoving@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsAtValidLongDeathSpot@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsWithinScriptGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverList
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindBestCoverList(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindBestCoverList@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetTargetSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetTargetSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAnglesToLikelyEnemyPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishZeroArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishZeroArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanDoTurnAnim
==============
*/

bool __fastcall AIScriptedInterface::CanDoTurnAnim(AIScriptedInterface *this, scr_anim_t turnAnim, const vec3_t *corner, const vec3_t *nextPathPoint)
{
  return ?CanDoTurnAnim@AIScriptedInterface@@QEBA_NUscr_anim_t@@Tvec3_t@@1@Z(this, turnAnim, corner, nextPathPoint);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanBoundingOverwatchMove@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOutsideBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPosOutsideBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPosOutsideBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_IsNodeInBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_IsNodeInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsNodeInBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetApproxEyePos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetApproxEyePos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetApproxEyePos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeeEnemyFromExposed
==============
*/

bool __fastcall AIScriptedInterface::CanSeeEnemyFromExposed(AIScriptedInterface *this, const pathnode_t *pNode)
{
  return ?CanSeeEnemyFromExposed@AIScriptedInterface@@IEBA_NPEBUpathnode_t@@@Z(this, pNode);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndPos
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationEndPos(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationEndPos@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PointInFOV
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PointInFOV(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PointInFOV@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireStep
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireStep(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireStep@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SeeRecently
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SeeRecently(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SeeRecently@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimPitch@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartTraverseArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartTraverseArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartTraverseArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeeAndShootPoint
==============
*/

bool __fastcall AIScriptedInterface::CanSeeAndShootPoint(AIScriptedInterface *this, const vec3_t *vPoint)
{
  return ?CanSeeAndShootPoint@AIScriptedInterface@@IEBA_NAEBTvec3_t@@@Z(this, vPoint);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBlackboard
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetBlackboard@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeSnapYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMinDist
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEngagementMinDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEngagementMinDist@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsPathDirect
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsPathDirect(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsPathDirect@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetMotionAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetMotionAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeapon
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_DropWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_DropWeapon@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetDesiredScaledSpeedForPosAlongPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcGoodShootPos
==============
*/

bool __fastcall AIScriptedInterface::CalcGoodShootPos(AIScriptedInterface *this)
{
  return ?CalcGoodShootPos@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateCoverExposeType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateCoverExposeType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateSharpTurnExitAnim
==============
*/

bool __fastcall AIScriptedInterface::CalculateSharpTurnExitAnim(AIScriptedInterface *this, int *angleIndices, unsigned int angleIndexCount, scr_string_t animsetName, scr_string_t stateName, const char *prefix, const char *suffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  return ?CalculateSharpTurnExitAnim@AIScriptedInterface@@QEBA_NQEAHIW4scr_string_t@@1PEBD2PEAUscr_anim_t@@PEAH4@Z(this, angleIndices, angleIndexCount, animsetName, stateName, prefix, suffix, outAnim, outAngleIndex, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ConstrainToScriptGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AISuppressAI
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AISuppressAI(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISuppressAI@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_SetNavLayer
==============
*/

void __fastcall AICommonInterface::OnScrCmd_SetNavLayer(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetNavLayer@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetRiotshieldWeapon@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateStopAnim
==============
*/

scr_anim_t __fastcall AIScriptedInterface::CalculateStopAnim(AIScriptedInterface *this, int angleIndex, scr_string_t animsetName, scr_string_t stateName, const char *footPrefix, const char *optionalPrefix, const char *speedString, int *outAnimEntryIndex)
{
  return ?CalculateStopAnim@AIScriptedInterface@@QEBA?AUscr_anim_t@@HW4scr_string_t@@0PEBD11PEAH@Z(this, angleIndex, animsetName, stateName, footPrefix, optionalPrefix, speedString, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_AnimMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AnimMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AnimMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AtDangerousNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AtDangerousNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AtDangerousNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetStairsStateAtDist
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetStairsStateAtDist(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetStairsStateAtDist@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsCurrentEnemyValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AllowedStances
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AllowedStances(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AllowedStances@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindBestCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindBestCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanDoRetreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanDoRetreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanDoRetreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_NearClaimNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_NearClaimNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcStopData
==============
*/

bool __fastcall AIScriptedInterface::CalcStopData(AIScriptedInterface *this, const vec3_t *targetPos, const vec3_t *targetAngles, const vec3_t *animTargetAngles, const vec3_t *codeApproachDir, bool bApproachDirValid, const scr_string_t *stateName, const char *footPrefix, const char *optionalPrefix, float maxLerpScale, float overShootRatio, const scr_string_t *nodeType, const scr_string_t *startNotetrack, const scr_string_t *endNotetrack, const char *speedString, AIAnimStopData *outStopData)
{
  return ?CalcStopData@AIScriptedInterface@@QEBA_NAEBTvec3_t@@000_NAEBW4scr_string_t@@PEBD3MM2223AEAUAIAnimStopData@@@Z(this, targetPos, targetAngles, animTargetAngles, codeApproachDir, bApproachDirValid, stateName, footPrefix, optionalPrefix, maxLerpScale, overShootRatio, nodeType, startNotetrack, endNotetrack, speedString, outStopData);
}

/*
==============
AIScriptedInterface::SetupMotionWarpForTurn
==============
*/

bool __fastcall AIScriptedInterface::SetupMotionWarpForTurn(AIScriptedInterface *this, const vec3_t *corner, const vec3_t *nextPathPoint, const vec3_t *turnStartAnimTranslation, const vec3_t *turnStartAnimRot, float turnStartSecs)
{
  return ?SetupMotionWarpForTurn@AIScriptedInterface@@QEBA_NTvec3_t@@000M@Z(this, corner, nextPathPoint, turnStartAnimTranslation, turnStartAnimRot, turnStartSecs);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeePointFromExposedAtNode
==============
*/

bool __fastcall AIScriptedInterface::CanSeePointFromExposedAtNode(AIScriptedInterface *this, const vec3_t *point, const pathnode_t *pNode, ai_stance_e stance)
{
  return ?CanSeePointFromExposedAtNode@AIScriptedInterface@@IEBA_NAEBTvec3_t@@PEBUpathnode_t@@W4ai_stance_e@@@Z(this, point, pNode, stance);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFlashBanged
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFlashBanged(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFlashBanged@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPointAfterNegotiation@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveFromPointToPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_StairsWithinDistance
==============
*/

void __fastcall AICommonInterface::OnScrCmd_StairsWithinDistance(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StairsWithinDistance@AICommonInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcStopData
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CalcStopData(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CalcStopData@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetAimAngles
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetAimAngles(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetAimAngles@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindNearbyCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindNearbyCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEntityTarget
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearEntityTarget@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetupMotionWarpForTurn@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsKnownEnemyInVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalHeight
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalHeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalHeight@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMaxDist
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEngagementMaxDist@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UseCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UseCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UseCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PushPlayer
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PushPlayer(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PushPlayer@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartZeroArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartZeroArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::SetIdleFacingUseAlliesPos
==============
*/

void __fastcall AIScriptedInterface::SetIdleFacingUseAlliesPos(AIScriptedInterface *this, const vec3_t *pos)
{
  ?SetIdleFacingUseAlliesPos@AIScriptedInterface@@IEBAXAEBTvec3_t@@@Z(this, pos);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInScriptedState
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsInScriptedState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInScriptedState@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindReacquireDirectPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindReacquireDirectPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_OrientMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_OrientMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_OrientMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetTargetSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTargetSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimWeight
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIGetAnimWeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIGetAnimWeight@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ResetThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ResetThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ResetThreatUpdate@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBlackboard
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearBlackboard@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimYaw@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushCheckPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushCheckPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushCheckPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndNode
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationEndNode(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationEndNode@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSeePeripheral
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanSeePeripheral(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanSeePeripheral@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAimAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAimAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAimAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalVolumeAuto@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEntityTarget
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEntityTarget@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShootBlank
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ShootBlank(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShootBlank@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsKnownEnemyInRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::FindGoodSuppressSpot
==============
*/

bool __fastcall AIScriptedInterface::FindGoodSuppressSpot(AIScriptedInterface *this, const vec3_t *startOffset)
{
  return ?FindGoodSuppressSpot@AIScriptedInterface@@IEBA_NAEBTvec3_t@@@Z(this, startOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundEntType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGroundEntType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGroundEntType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalEntity
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalEntity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalEntity@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartBeam
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartBeam@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::NeedRecalculateSuppressSpot
==============
*/

bool __fastcall AIScriptedInterface::NeedRecalculateSuppressSpot(AIScriptedInterface *this)
{
  return ?NeedRecalculateSuppressSpot@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIClearGesture
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIClearGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIClearGesture@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDoorOpen
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearDoorOpen@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBackupCoverFromPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StopBeam
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StopBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StopBeam@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindShuffleCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindShuffleCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveToPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveToPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
ChooseArrivalPose
==============
*/
__int64 ChooseArrivalPose(const AIScriptedInterface *pAI, const pathnode_t *pNode, const vec3_t *nodePos)
{
  __int16 **v6; 
  int v7; 
  bool v8; 
  bool v9; 
  __int64 result; 
  double TargetSpeed; 

  v6 = (__int16 **)pAI->GetAI(&pAI->AICommonInterface);
  v7 = *((_DWORD *)v6 + 120);
  v8 = (!pNode || Path_DoesNodeAllowStance(pNode, (const scr_string_t)scr_const.stand)) && AIScriptedInterface::IsStanceAllowed((AIScriptedInterface *)pAI, STANCE_STAND);
  v9 = (!pNode || Path_DoesNodeAllowStance(pNode, (const scr_string_t)scr_const.crouch)) && AIScriptedInterface::IsStanceAllowed((AIScriptedInterface *)pAI, STANCE_CROUCH) && v7 != scr_const.casual && v7 != scr_const.casual_gun;
  if ( v8 )
  {
    TargetSpeed = AIScriptedInterface::GetTargetSpeed((AIScriptedInterface *)pAI);
    if ( *(float *)&TargetSpeed < 115.0 )
      return 1i64;
  }
  else if ( !v9 )
  {
    return 4i64;
  }
  if ( ((int)(float)((float)((float)(nodePos->v[1] + nodePos->v[0]) + nodePos->v[2]) + (float)**v6) & 1) == 0 && v8 )
    return 1i64;
  result = 2i64;
  if ( !v9 )
    return 1i64;
  return result;
}

/*
==============
GScr_BtRegisterTree
==============
*/
void GScr_BtRegisterTree(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  AI_BT_RegisterBehaviorTree(String);
}

/*
==============
AIScr_SetSpeedThreshold
==============
*/
void AIScr_SetSpeedThreshold(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int Int; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  if ( Int <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 110, ASSERT_TYPE_ASSERT, "(thresholdValue > 0)", "%s\n\tSpeed threshold values need to be greater than 0", "thresholdValue > 0") )
    __debugbreak();
  SetSpeedThresholdEntry(ConstString, v3, Int);
}

/*
==============
AIScr_InitMaxSpeedForPathLengthTable
==============
*/

void __fastcall AIScr_InitMaxSpeedForPathLengthTable(scrContext_t *scrContext)
{
  InitializeMaxSpeedForPathLengthTable();
}

/*
==============
AIScr_AnimSpeedThresholdsExist
==============
*/
void AIScr_AnimSpeedThresholdsExist(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  bool v3; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = HasAnimSpeedThresholdsForArchetype(ConstString);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScr_HasAnimSpeedThresholdString
==============
*/
void AIScr_HasAnimSpeedThresholdString(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  bool v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = HasAnimSpeedThresholdEntryForArchetype(ConstString, v3);
  Scr_AddBool(scrContext, v4);
}

/*
==============
AIScr_GetAnimSpeedThreshold
==============
*/
void AIScr_GetAnimSpeedThreshold(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int AnimSpeedThresholdValue; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  AnimSpeedThresholdValue = GetAnimSpeedThresholdValue(ConstString, v3);
  if ( AnimSpeedThresholdValue < 0 )
    Scr_AddUndefined(scrContext);
  else
    Scr_AddInt(scrContext, AnimSpeedThresholdValue);
}

/*
==============
AIScr_GetNearestSpeedThresholdName
==============
*/
void AIScr_GetNearestSpeedThresholdName(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  double Float; 
  scr_string_t NearestSpeedThresholdString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  Float = Scr_GetFloat(scrContext, 1u);
  NearestSpeedThresholdString = GetNearestSpeedThresholdString(ConstString, *(float *)&Float);
  if ( NearestSpeedThresholdString )
    Scr_AddConstString(scrContext, NearestSpeedThresholdString);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
AIScr_GetNextLowestSpeedThresholdString
==============
*/
void AIScr_GetNextLowestSpeedThresholdString(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  double Float; 
  scr_string_t NextLowestSpeedThresholdName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  Float = Scr_GetFloat(scrContext, 1u);
  NextLowestSpeedThresholdName = GetNextLowestSpeedThresholdName(ConstString, *(float *)&Float);
  if ( NextLowestSpeedThresholdName )
    Scr_AddConstString(scrContext, NextLowestSpeedThresholdName);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
AIScr_GetAnimSpeedBetweenThresholds
==============
*/
void AIScr_GetAnimSpeedBetweenThresholds(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  double Float; 
  double AnimSpeedBetweenThresholdEntries; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  Float = Scr_GetFloat(scrContext, 3u);
  AnimSpeedBetweenThresholdEntries = GetAnimSpeedBetweenThresholdEntries(ConstString, v3, v4, *(float *)&Float);
  if ( *(float *)&AnimSpeedBetweenThresholdEntries < 0.0 )
    Scr_AddUndefined(scrContext);
  else
    Scr_AddFloat(scrContext, *(float *)&AnimSpeedBetweenThresholdEntries);
}

/*
==============
AIScr_GetCoverAngleLimits
==============
*/
void AIScr_GetCoverAngleLimits(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  ai_stance_e v3; 
  int v4; 
  unsigned __int16 type; 
  unsigned __int16 coverMultiType; 
  const char *v7; 
  unsigned __int16 v8; 
  const char *v9; 
  float *CoverAngleLimits; 
  int outLimitsCount; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = STANCE_ANY;
  if ( Scr_GetConstString(scrContext, 1u) == scr_const.stand )
    v3 = STANCE_STAND;
  v4 = 0;
  outLimitsCount = 0;
  type = Pathnode->constant.type;
  if ( type == 31 )
    coverMultiType = Pathnode->dynamic.coverMultiType;
  else
    coverMultiType = Pathnode->constant.type;
  if ( ((1 << type) & 0x1E300000) != 0 || ((1 << type) & 0x400000) != 0 )
  {
    pathnode_t::GetPos(Pathnode, &pos);
    v7 = vtos(&pos);
    v8 = Path_ConvertNodeToIndex(Pathnode);
    v9 = j_va("Cannot get cover angle limits for 3D node %d at %s", v8, v7);
    Scr_Error(COM_ERR_5903, scrContext, v9);
  }
  CoverAngleLimits = (float *)GetCoverAngleLimits(coverMultiType, v3, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      Scr_AddFloat(scrContext, *CoverAngleLimits);
      Scr_AddArray(scrContext);
      ++v4;
      ++CoverAngleLimits;
    }
    while ( v4 < outLimitsCount );
  }
}

/*
==============
AIScr_Get3DCoverAngleLimits
==============
*/
void AIScr_Get3DCoverAngleLimits(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v3; 
  float *v4; 
  int outLimitsCount; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = 0;
  outLimitsCount = 0;
  v4 = (float *)Get3DCoverAngleLimits(Pathnode->constant.type, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      Scr_AddFloat(scrContext, *v4);
      Scr_AddArray(scrContext);
      ++v3;
      ++v4;
    }
    while ( v3 < outLimitsCount );
  }
}

/*
==============
AIScr_GetCoverCrouchAngleLimits
==============
*/
void AIScr_GetCoverCrouchAngleLimits(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  int v3; 
  float *CoverCrouchAngleLimits; 
  int outLimitsCount; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v3 = 0;
  outLimitsCount = 0;
  CoverCrouchAngleLimits = (float *)GetCoverCrouchAngleLimits(ConstLowercaseString, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      Scr_AddFloat(scrContext, *CoverCrouchAngleLimits);
      Scr_AddArray(scrContext);
      ++v3;
      ++CoverCrouchAngleLimits;
    }
    while ( v3 < outLimitsCount );
  }
}

/*
==============
GScr_GetAngleIndices
==============
*/
void GScr_GetAngleIndices(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  __int64 v5; 
  unsigned int outAngleIndexCount; 
  int outAngleIndices[4]; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) == 2 )
    v4 = Scr_GetFloat(scrContext, 1u);
  else
    *(float *)&v4 = FLOAT_10_0;
  v5 = 0i64;
  outAngleIndexCount = 0;
  G_GetAngleIndices(v3, *(const float *)&v4, outAngleIndices, &outAngleIndexCount);
  Scr_MakeArray(scrContext);
  if ( outAngleIndexCount )
  {
    do
    {
      Scr_AddInt(scrContext, outAngleIndices[v5]);
      Scr_AddArray(scrContext);
      v5 = (unsigned int)(v5 + 1);
    }
    while ( (unsigned int)v5 < outAngleIndexCount );
  }
}

/*
==============
GScr_GetAngleIndex
==============
*/
void GScr_GetAngleIndex(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  int AngleIndex; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) == 2 )
    v4 = Scr_GetFloat(scrContext, 1u);
  else
    *(float *)&v4 = FLOAT_10_0;
  AngleIndex = G_GetAngleIndex(v3, *(const float *)&v4);
  Scr_AddInt(scrContext, AngleIndex);
}

/*
==============
GScr_HasRoomToPlayPeekout
==============
*/
void GScr_HasRoomToPlayPeekout(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v3; 
  scr_string_t dir; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = 1;
  if ( Pathnode->constant.totalLinkCount )
  {
    dir = Scr_GetConstString(scrContext, 1u);
    v3 = HasRoomToPlayPeekout(Pathnode, &dir);
  }
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScr_FindClosestLOSPointWithinVolume
==============
*/
void AIScr_FindClosestLOSPointWithinVolume(scrContext_t *scrContext)
{
  int numIgnoreVecs; 
  const gentity_s *Entity; 
  const tacpoint_t *ClosestPoint; 
  double Float; 
  const tacpoint_t *ClosestPointWithVisWithinVolumeIgnorePoints; 
  vec3_t pos; 
  vec3_t vectorValue; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  numIgnoreVecs = 1;
  Entity = GScr_GetEntity(0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 2u, &pos);
    if ( (int)Scr_GetNumParam(scrContext) <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED )
      goto LABEL_9;
    if ( Scr_GetType(scrContext, 3u) == VAR_VECTOR )
      Scr_GetVector(scrContext, 3u, &pVecArray);
    else
      numIgnoreVecs = GetVectorArray(scrContext, 3, &pVecArray, 128);
    Float = Scr_GetFloat(scrContext, 4u);
    if ( numIgnoreVecs )
      ClosestPointWithVisWithinVolumeIgnorePoints = TacGraph_FindClosestPointWithVisWithinVolumeIgnorePoints(Entity, &pos, ClosestPoint, &pVecArray, numIgnoreVecs, *(float *)&Float);
    else
LABEL_9:
      ClosestPointWithVisWithinVolumeIgnorePoints = TacGraph_FindClosestPointWithVisWithinVolume(Entity, &pos, ClosestPoint);
    if ( ClosestPointWithVisWithinVolumeIgnorePoints )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithVisWithinVolumeIgnorePoints, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
}

/*
==============
AIScr_FindClosestLOSPointWithinRadius
==============
*/
void AIScr_FindClosestLOSPointWithinRadius(scrContext_t *scrContext)
{
  int numIgnoreVecs; 
  double Float; 
  float v4; 
  const tacpoint_t *ClosestPoint; 
  double v6; 
  const tacpoint_t *ClosestPointWithVisWithinRadiusIgnorePoints; 
  vec3_t v8; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  numIgnoreVecs = 1;
  Float = Scr_GetFloat(scrContext, 1u);
  v4 = *(float *)&Float;
  Scr_GetVector(scrContext, 2u, &pos);
  ClosestPoint = TacGraph_FindClosestPoint(&pos);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 3u, &v8);
    if ( (int)Scr_GetNumParam(scrContext) <= 4 || Scr_GetType(scrContext, 4u) == VAR_UNDEFINED )
      goto LABEL_9;
    if ( Scr_GetType(scrContext, 4u) == VAR_VECTOR )
      Scr_GetVector(scrContext, 4u, &pVecArray);
    else
      numIgnoreVecs = GetVectorArray(scrContext, 4, &pVecArray, 64);
    v6 = Scr_GetFloat(scrContext, 5u);
    if ( numIgnoreVecs )
      ClosestPointWithVisWithinRadiusIgnorePoints = TacGraph_FindClosestPointWithVisWithinRadiusIgnorePoints(&vectorValue, v4, &v8, ClosestPoint, &pVecArray, numIgnoreVecs, *(float *)&v6);
    else
LABEL_9:
      ClosestPointWithVisWithinRadiusIgnorePoints = TacGraph_FindClosestPointWithVisWithinRadius(&vectorValue, v4, &v8, ClosestPoint);
    if ( ClosestPointWithVisWithinRadiusIgnorePoints )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithVisWithinRadiusIgnorePoints, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
}

/*
==============
AIScr_FindClosestNonLOSPointWithinVolume
==============
*/
void AIScr_FindClosestNonLOSPointWithinVolume(scrContext_t *scrContext)
{
  float v1; 
  int numIgnoreVecs; 
  const gentity_s *Entity; 
  const tacpoint_t *ClosestPoint; 
  int NumParam; 
  double Float; 
  double v8; 
  const tacpoint_t *ClosestPointWithoutVisWithinVolume; 
  vec3_t pos; 
  vec3_t vectorValue; 
  vec3_t dir; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  v1 = FLOAT_N1_0;
  numIgnoreVecs = 0;
  Entity = GScr_GetEntity(0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 2u, &pos);
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
    {
      if ( NumParam < 5 )
        Scr_Error(COM_ERR_3814, scrContext, "ignore points specified without providing radius.");
      Float = Scr_GetFloat(scrContext, 4u);
      v1 = *(float *)&Float;
      if ( *(float *)&Float <= 0.0 )
        Scr_Error(COM_ERR_3815, scrContext, "ignore radius must be > 0");
      if ( Scr_GetType(scrContext, 3u) == VAR_VECTOR )
      {
        Scr_GetVector(scrContext, 3u, &pVecArray);
        numIgnoreVecs = 1;
      }
      else
      {
        numIgnoreVecs = GetVectorArray(scrContext, 3, &pVecArray, 96);
      }
    }
    if ( NumParam <= 5 )
    {
      if ( numIgnoreVecs <= 0 )
        ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisWithinVolume(Entity, &pos, ClosestPoint);
      else
        ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisWithinVolumeIgnorePoints(Entity, &pos, ClosestPoint, &pVecArray, numIgnoreVecs, v1);
    }
    else
    {
      if ( NumParam < 7 )
        Scr_Error(COM_ERR_3816, scrContext, "direction specified without providing weight.");
      Scr_GetVector(scrContext, 5u, &dir);
      v8 = Scr_GetFloat(scrContext, 6u);
      if ( numIgnoreVecs > 0 )
        Scr_Error(COM_ERR_3817, scrContext, "no one was using this function, so did not bother implementing an ignorepoints version.");
      ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisNearConeWithinVolume(Entity, &pos, ClosestPoint, &dir, *(float *)&v8);
    }
    if ( ClosestPointWithoutVisWithinVolume )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinVolume, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
}

/*
==============
AIScr_FindClosestNonLOSPointWithinRadius
==============
*/
void AIScr_FindClosestNonLOSPointWithinRadius(scrContext_t *scrContext)
{
  float v1; 
  int numIgnoreVecs; 
  double Float; 
  float v5; 
  const tacpoint_t *ClosestPoint; 
  int NumParam; 
  double v8; 
  double v9; 
  const tacpoint_t *ClosestPointWithoutVisWithinRadius; 
  vec3_t v11; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t dir; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  v1 = FLOAT_N1_0;
  numIgnoreVecs = 0;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v5 = *(float *)&Float;
  Scr_GetVector(scrContext, 2u, &pos);
  ClosestPoint = TacGraph_FindClosestPoint(&pos);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 3u, &v11);
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam > 4 && Scr_GetType(scrContext, 4u) )
    {
      v8 = Scr_GetFloat(scrContext, 5u);
      v1 = *(float *)&v8;
      if ( *(float *)&v8 <= 0.0 )
        Scr_Error(COM_ERR_3819, scrContext, "ignore radius must be > 0");
      if ( Scr_GetType(scrContext, 4u) == VAR_VECTOR )
      {
        Scr_GetVector(scrContext, 4u, &pVecArray);
        numIgnoreVecs = 1;
      }
      else
      {
        numIgnoreVecs = GetVectorArray(scrContext, 4, &pVecArray, 64);
      }
    }
    if ( NumParam <= 6 )
    {
      if ( numIgnoreVecs <= 0 )
        ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisWithinRadius(&vectorValue, v5, &v11, ClosestPoint);
      else
        ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisWithinRadiusIgnorePoints(&vectorValue, v5, &v11, ClosestPoint, &pVecArray, numIgnoreVecs, v1);
    }
    else
    {
      if ( NumParam < 8 )
        Scr_Error(COM_ERR_3820, scrContext, "direction specified without providing weight.");
      Scr_GetVector(scrContext, 6u, &dir);
      v9 = Scr_GetFloat(scrContext, 7u);
      if ( numIgnoreVecs > 0 )
        Scr_Error(COM_ERR_3821, scrContext, "no one was using this function, so did not bother implementing an ignorepoints version.");
      ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisNearConeWithinRadius(&vectorValue, v5, &v11, ClosestPoint, &dir, *(float *)&v9);
    }
    if ( ClosestPointWithoutVisWithinRadius )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinRadius, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
}

/*
==============
AIScr_FindOpenLookDir
==============
*/
void AIScr_FindOpenLookDir(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  double Float; 
  float v4; 
  float v5; 
  double v6; 
  ai_common_t *AICommon; 
  AINavigator *pNavigator; 
  AINavigator2D *v9; 
  const bfx::AreaHandle *CurArea; 
  int BestSlice; 
  vec3_t angles; 
  vec3_t vectorValue; 
  vec3_t forward; 
  float pResults[16]; 

  Entity = NULL;
  if ( Scr_GetType(scrContext, 0) == VAR_VECTOR )
    Scr_GetVector(scrContext, 0, &vectorValue);
  else
    Entity = GScr_GetEntity(0);
  Float = Scr_GetFloat(scrContext, 1u);
  v4 = *(float *)&Float;
  v5 = 0.0;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    v6 = Scr_GetFloat(scrContext, 2u);
    v5 = *(float *)&v6;
  }
  if ( Entity )
  {
    AICommon = AI_GetAICommon(Entity);
    if ( !AICommon )
      Scr_Error(COM_ERR_3822, scrContext, "ent (arg1) was not an AI");
    pNavigator = AICommon->pNavigator;
    if ( !pNavigator )
    {
      Scr_Error(COM_ERR_3823, scrContext, "AI (arg1) does not have a navigator");
      pNavigator = AICommon->pNavigator;
    }
    v9 = pNavigator->Get2DNavigator(pNavigator);
    if ( !v9 )
      Scr_Error(COM_ERR_3824, scrContext, "FindOpenLookDir only works with AI with 2D nav");
    CurArea = AINavigator2D::GetCurArea(v9);
    TacGraph_CalcOpenView(&Entity->r.currentOrigin, v4, CurArea, pResults, 16);
  }
  else
  {
    TacGraph_CalcOpenView(&vectorValue, v4, pResults, 16);
  }
  BestSlice = FindBestSlice(pResults, 16, v5);
  if ( BestSlice >= 0 || (BestSlice = FindBestSlice(pResults, 16, 0.0), BestSlice >= 0) )
  {
    angles.v[1] = (float)((float)BestSlice * 22.5) + 11.25;
    angles.v[0] = 0.0;
    angles.v[2] = 0.0;
    AngleVectors(&angles, &forward, NULL, NULL);
    Scr_AddVector(scrContext, forward.v);
  }
}

/*
==============
AIScr_FindClosestPointByApproxPathDist
==============
*/
void AIScr_FindClosestPointByApproxPathDist(scrContext_t *scrContext)
{
  unsigned int ArrayObject; 
  const char *v3; 
  float m_approxPathCost; 
  int v5; 
  unsigned int FirstSibling; 
  __int64 v7; 
  char v8; 
  VariableType type; 
  unsigned int EntNum; 
  __int64 v11; 
  ai_common_t *AICommon; 
  ai_common_t *v13; 
  AINavigator *pNavigator; 
  AINavigator2D *v15; 
  AINavigator2D *v16; 
  const bfx::AreaHandle *CurArea; 
  bfx::AreaHandle *pOutArea; 
  bfx::AreaHandle *pOutAreaa; 
  __int64 numGoals; 
  __int64 numGoalsa; 
  bfx::Vector3 startPos; 
  VariableValue out; 
  bfx::AreaHandle startArea; 
  bfx::MultiPathSpec multiPathSpec; 
  bfx::MultiPathRCPtr result; 
  bfx::MultiPathGoal pGoalArray; 
  __int64 v28; 
  bfx::MultiPathGoalOutput goalOut; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t outPos; 
  vec3_t v33; 
  bfx::Vector3 value[2]; 
  bfx::PathSpec pathSpec; 
  bfx::PathSpec pPathSpec; 

  v28 = -2i64;
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  pPathSpec.m_pathSharingPenalty = 0.0;
  pPathSpec.m_maxPathSharingPenalty = 0.0;
  pPathSpec.m_maxSearchDist = 0.0;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  multiPathSpec.m_generatePaths = 0;
  multiPathSpec.m_maxNumCorners = -1;
  bfx::MultiPathGoal::MultiPathGoal(&pGoalArray);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Nav_GetClosestVerticalPosInMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, -1.0, &pPathSpec, &vectorValue, &pGoalArray.m_goalArea);
  pGoalArray.m_goalPos = (bfx::Vector3)vectorValue;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  if ( GetArraySize(scrContext, ArrayObject) > 0x10 )
  {
    v3 = j_va("Exceeded max number of elements (%d).", 16i64);
    Scr_ParamError(COM_ERR_5904, scrContext, 0, v3);
  }
  m_approxPathCost = FLOAT_999999_0;
  v5 = 2047;
  bfx::AreaHandle::AreaHandle(&startArea);
  FirstSibling = FindFirstSibling(scrContext, ArrayObject);
  if ( FirstSibling )
  {
    while ( 1 )
    {
      LODWORD(v7) = 2047;
      pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
      *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
      *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
      pathSpec.m_usePathSharingPenalty = 0;
      pathSpec.m_pathSharingPenalty = 0.0;
      pathSpec.m_maxPathSharingPenalty = 0.0;
      pathSpec.m_maxSearchDist = 0.0;
      bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
      pathSpec.m_snapMode = SNAP_CLOSEST;
      v8 = 1;
      Scr_EvalVariable_Out(scrContext, FirstSibling, &out);
      type = out.type;
      if ( out.type == VAR_VECTOR )
      {
        Nav_GetClosestVerticalPosInMostLikelySpace((const vec3_t *)out.u.vectorValue, NAV_LAYER_HUMAN, -1.0, &pPathSpec, &outPos, &startArea);
        startPos = (bfx::Vector3)outPos;
      }
      else
      {
        if ( out.type == VAR_POINTER )
        {
          if ( GetObjectType(scrContext, out.u.uintValue) == VAR_ENTITY )
          {
            EntNum = Scr_GetEntNum(scrContext, out.u.uintValue);
            v7 = (int)EntNum;
            if ( EntNum >= 0x800 )
            {
              LODWORD(numGoals) = 2048;
              LODWORD(pOutArea) = EntNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1026, ASSERT_TYPE_ASSERT, "(unsigned)( testEntNum ) < (unsigned)( ( 2048 ) )", "testEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", pOutArea, numGoals) )
                __debugbreak();
              LODWORD(numGoalsa) = 2048;
              LODWORD(pOutAreaa) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", pOutAreaa, numGoalsa) )
                __debugbreak();
            }
            if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
              __debugbreak();
            v11 = v7;
            if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
              __debugbreak();
            if ( !g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1027, ASSERT_TYPE_ASSERT, "(G_IsEntityInUse( testEntNum ))", (const char *)&queryFormat, "G_IsEntityInUse( testEntNum )") )
              __debugbreak();
            AICommon = AI_GetAICommon(&g_entities[v11]);
            v13 = AICommon;
            if ( AICommon && (pNavigator = AICommon->pNavigator) != NULL )
            {
              pNavigator->GetCurPos(pNavigator, &pos);
              startPos = (bfx::Vector3)pos;
              v15 = v13->pNavigator->Get2DNavigator(v13->pNavigator);
              v16 = v15;
              if ( v15 )
              {
                CurArea = AINavigator2D::GetCurArea(v15);
                bfx::AreaHandle::operator=(&startArea, CurArea);
                pathSpec = v16->m_BasePathSpec;
                if ( !bfx::AreaHandle::IsUsable(&pGoalArray.m_goalArea, &pathSpec) )
                  v8 = 0;
              }
              else
              {
                Nav_GetClosestVerticalPosInMostLikelySpace(&pos, NAV_LAYER_HUMAN, -1.0, &pPathSpec, &pos, &startArea);
              }
            }
            else
            {
              Nav_GetClosestVerticalPosInMostLikelySpace(&g_entities[v11].r.currentOrigin, NAV_LAYER_HUMAN, -1.0, &pPathSpec, &v33, &startArea);
              startPos = (bfx::Vector3)v33;
            }
            goto LABEL_31;
          }
          type = out.type;
        }
        RemoveRefToValue(scrContext, (unsigned __int8)type, out.u);
        Scr_Error(COM_ERR_5905, scrContext, "Some element of array is neither a vector nor an entity.");
      }
LABEL_31:
      RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      if ( v8 )
      {
        bfx::SearchToMultipleGoals(&result, &startArea, &startPos, &pathSpec, &multiPathSpec, &pGoalArray, 1);
        bfx::MultiPathGoalOutput::MultiPathGoalOutput(&goalOut);
        if ( bfx::MultiPathRCPtr::GetGoalOutput(&result, 0, &goalOut) && goalOut.m_goalReached && goalOut.m_approxPathCost < m_approxPathCost )
        {
          m_approxPathCost = goalOut.m_approxPathCost;
          value[0] = startPos;
          v5 = v7;
        }
        bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&goalOut.m_path);
        bfx::AreaHandle::~AreaHandle(&goalOut.m_goalArea);
        bfx::MultiPathRCPtr::~MultiPathRCPtr(&result);
      }
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
      if ( !FirstSibling )
      {
        if ( m_approxPathCost < 999999.0 )
        {
          if ( v5 == 2047 )
            Scr_AddVector(scrContext, &value[0].m_x);
          else
            Scr_AddEntityNum(scrContext, v5, ENTITY_CLASS_GENTITY);
        }
        break;
      }
    }
  }
  bfx::AreaHandle::~AreaHandle(&startArea);
  bfx::AreaHandle::~AreaHandle(&pGoalArray.m_goalArea);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalPos
==============
*/
void AICallback_OnScrCmd_SetBTGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalNode
==============
*/
void AICallback_OnScrCmd_SetBTGoalNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalEnt
==============
*/
void AICallback_OnScrCmd_SetBTGoalEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalEnt(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalVolume
==============
*/
void AICallback_OnScrCmd_SetBTGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearBTGoal
==============
*/
void AICallback_OnScrCmd_ClearBTGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearBTGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalRadius
==============
*/
void AICallback_OnScrCmd_SetBTGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalHeight
==============
*/
void AICallback_OnScrCmd_SetBTGoalHeight(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalHeight(m_pAI, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_StairsWithinDistance
==============
*/
void AICommonInterface::OnScrCmd_StairsWithinDistance(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  unsigned __int8 v7; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("StairsWithinDistance: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_5907, scrContext, v6);
  }
  Scr_GetFloat(scrContext, 0);
  v7 = ((__int64 (__fastcall *)(AINavigator *))Navigator->GetStairsWithinDist)(Navigator);
  Scr_AddBool(scrContext, v7);
}

/*
==============
AICommonInterface::OnScrCmd_ClearPath
==============
*/
void AICommonInterface::OnScrCmd_ClearPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ((void (__fastcall *)(AICommonInterface *, scrContext_t *))this->ClearPath)(this, scrContext);
}

/*
==============
AICallback_OnScrCmd_BTGoalValid
==============
*/
void AICallback_OnScrCmd_BTGoalValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_BTGoalValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsWithinScriptGoalRadius
==============
*/
void AICallback_OnScrCmd_IsWithinScriptGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ConstrainToScriptGoalRadius
==============
*/
void AICallback_OnScrCmd_ConstrainToScriptGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/
void AICallback_OnScrCmd_FindLastPointOnPathWithinVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetLastPathPointWithinGoal
==============
*/
void AICallback_OnScrCmd_GetLastPathPointWithinGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPosOnPath
==============
*/
void AICallback_OnScrCmd_GetPosOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPosOnPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsAtValidLongDeathSpot
==============
*/
void AICallback_OnScrCmd_IsAtValidLongDeathSpot(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetStairsStateAtDist
==============
*/
void AICallback_OnScrCmd_GetStairsStateAtDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetStairsStateAtDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StairsWithinDistance
==============
*/
void AICallback_OnScrCmd_StairsWithinDistance(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
   AICommonInterface::`vcall'{440,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPathDistToGoal
==============
*/
void AICallback_OnScrCmd_GetPathDistToGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPathDistToGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_EnableTeamwalking
==============
*/
void AICallback_OnScrCmd_EnableTeamwalking(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_EnableTeamwalking(m_pAI, scrContext);
}

/*
==============
GScr_BtRegisterTreeInstance
==============
*/
void GScr_BtRegisterTreeInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  const char *v5; 
  gentity_s *Entity; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = SL_ConvertToString(ConstString);
  SL_AddRefToString(ConstString);
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1651, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  AI_BT_CreateBehaviorTreeInstance(v5, Entity->s.number, 1);
  SL_RemoveRefToString(ConstString);
  Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_BtTerminateTreeInstance
==============
*/
void GScr_BtTerminateTreeInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1673, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  number = Entity->s.number;
  AI_BT_Terminate(number);
  AI_BT_FreeTreeInstance(number);
}

/*
==============
GScr_BtTick
==============
*/
void GScr_BtTick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  AI_BT_Tick(Entity->s.number);
}

/*
==============
AICallback_OnScrCmd_GetSecondaryTargets
==============
*/
void AICallback_OnScrCmd_GetSecondaryTargets(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetSecondaryTargets(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationStartNode
==============
*/
void AICallback_OnScrCmd_GetNegotiationStartNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationStartNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNearbyNegotiationInfo
==============
*/
void AICallback_OnScrCmd_GetNearbyNegotiationInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationEndNode
==============
*/
void AICallback_OnScrCmd_GetNegotiationEndNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationEndNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationEndPos
==============
*/
void AICallback_OnScrCmd_GetNegotiationEndPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationEndPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindBestCoverNode
==============
*/
void AICallback_OnScrCmd_FindBestCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindBestCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushIsCurrentNodeValid
==============
*/
void AICallback_OnScrCmd_AmbushIsCurrentNodeValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushGetNextAmbushNode
==============
*/
void AICallback_OnScrCmd_AmbushGetNextAmbushNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushCheckPath
==============
*/
void AICallback_OnScrCmd_AmbushCheckPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushCheckPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindBestCoverList
==============
*/
void AICallback_OnScrCmd_FindBestCoverList(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindBestCoverList(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UseCoverNode
==============
*/
void AICallback_OnScrCmd_UseCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UseCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsCoverValidAgainstEnemy
==============
*/
void AICallback_OnScrCmd_IsCoverValidAgainstEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsSuppressed
==============
*/
void AICallback_OnScrCmd_IsSuppressed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsSuppressed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsMoveSuppressed
==============
*/
void AICallback_OnScrCmd_IsMoveSuppressed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsMoveSuppressed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanDoRetreat
==============
*/
void AICallback_OnScrCmd_CanDoRetreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanDoRetreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindShuffleCoverNode
==============
*/
void AICallback_OnScrCmd_FindShuffleCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindNearbyCoverNode
==============
*/
void AICallback_OnScrCmd_FindNearbyCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindCoverNode
==============
*/
void AICallback_OnScrCmd_FindCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetCoverNode
==============
*/
void AICallback_OnScrCmd_GetCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SeeRecently
==============
*/
void AICallback_OnScrCmd_SeeRecently(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SeeRecently(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsStanceAllowed
==============
*/
void AICallback_OnScrCmd_IsStanceAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsStanceAllowed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateLastCoverTime
==============
*/
void AICallback_OnScrCmd_UpdateLastCoverTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalNode
==============
*/
void AICallback_OnScrCmd_SetGoalNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalPos
==============
*/
void AICallback_OnScrCmd_SetGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalEntity
==============
*/
void AICallback_OnScrCmd_SetGoalEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalEntity(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalPath
==============
*/
void AICallback_OnScrCmd_SetGoalPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalVolume
==============
*/
void AICallback_OnScrCmd_SetGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalVolumeAuto
==============
*/
void AICallback_OnScrCmd_SetGoalVolumeAuto(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGoalVolume
==============
*/
void AICallback_OnScrCmd_GetGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearGoalVolume
==============
*/
void AICallback_OnScrCmd_ClearGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetCoverTacPoint
==============
*/
void AICallback_OnScrCmd_GetCoverTacPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetCoverTacPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInGoal
==============
*/
void AICallback_OnScrCmd_IsInGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsInGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBackupCoverFromPos
==============
*/
void AICallback_OnScrCmd_SetBackupCoverFromPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanShootEnemy
==============
*/
void AICallback_OnScrCmd_CanShootEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanShootEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsGunBlockedByWall
==============
*/
void AICallback_OnScrCmd_IsGunBlockedByWall(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_EnableTraversals
==============
*/
void AICallback_OnScrCmd_EnableTraversals(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_EnableTraversals(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetC8ObstacleFlag
==============
*/
void AICallback_OnScrCmd_SetC8ObstacleFlag(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_SetC8ObstacleFlag(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetNavLayer
==============
*/
void AICallback_OnScrCmd_SetNavLayer(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_SetNavLayer(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInBadplace
==============
*/
void AICallback_OnScrCmd_IsInBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_IsInBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPosOutsideBadplace
==============
*/
void AICallback_OnScrCmd_GetPosOutsideBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPosOutsideBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsNodeInBadplace
==============
*/
void AICallback_OnScrCmd_IsNodeInBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_IsNodeInBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CodeMoveRequested
==============
*/
void AICallback_OnScrCmd_CodeMoveRequested(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CodeMoveRequested(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetDesiredSpeed
==============
*/
void AICallback_OnScrCmd_SetDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearDesiredSpeed
==============
*/
void AICallback_OnScrCmd_ClearDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetDesiredSpeed
==============
*/
void AICallback_OnScrCmd_GetDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetSpeedScaleMode
==============
*/
void AICallback_OnScrCmd_SetSpeedScaleMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetTargetSpeed
==============
*/
void AICallback_OnScrCmd_GetTargetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetTargetSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetTargetSpeed
==============
*/
void AICallback_OnScrCmd_SetTargetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetTargetSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/
void AICallback_OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanBoundingOverwatchMove
==============
*/
void AICallback_OnScrCmd_CanBoundingOverwatchMove(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetCoverSelectionFocusEnt
==============
*/
void AICallback_OnScrCmd_SetCoverSelectionFocusEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_OrientMode
==============
*/
void AICallback_OnScrCmd_OrientMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_OrientMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AnimMode
==============
*/
void AICallback_OnScrCmd_AnimMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AnimMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanShoot
==============
*/
void AICallback_OnScrCmd_CanShoot(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanShoot(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanSee
==============
*/
void AICallback_OnScrCmd_CanSee(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanSee(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanSeePeripheral
==============
*/
void AICallback_OnScrCmd_CanSeePeripheral(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanSeePeripheral(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ShootBlank
==============
*/
void AICallback_OnScrCmd_ShootBlank(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ShootBlank(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_Melee
==============
*/
void AICallback_OnScrCmd_Melee(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_Melee(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_NearClaimNode
==============
*/
void AICallback_OnScrCmd_NearClaimNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_NearClaimNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_NearClaimNodeAndAngle
==============
*/
void AICallback_OnScrCmd_NearClaimNodeAndAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetDefaultAimLimits
==============
*/
void AICallback_OnScrCmd_SetDefaultAimLimits(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsSuppressionWaiting
==============
*/
void AICallback_OnScrCmd_IsSuppressionWaiting(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetMotionAngle
==============
*/
void AICallback_OnScrCmd_GetMotionAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetMotionAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetMotionAngle3D
==============
*/
void AICallback_OnScrCmd_GetMotionAngle3D(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetMotionAngle3D(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFlashBanged
==============
*/
void AICallback_OnScrCmd_SetFlashBanged(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFlashBanged(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FlagEnemyUnattackable
==============
*/
void AICallback_OnScrCmd_FlagEnemyUnattackable(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveToPoint
==============
*/
void AICallback_OnScrCmd_MayMoveToPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveToPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AtDangerousNode
==============
*/
void AICallback_OnScrCmd_AtDangerousNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AtDangerousNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveCheckFriendlyFire
==============
*/
void AICallback_OnScrCmd_MayMoveCheckFriendlyFire(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveFromPointToPoint
==============
*/
void AICallback_OnScrCmd_MayMoveFromPointToPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsKnownEnemyInVolume
==============
*/
void AICallback_OnScrCmd_IsKnownEnemyInVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsKnownEnemyInRadius
==============
*/
void AICallback_OnScrCmd_IsKnownEnemyInRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsPathDirect
==============
*/
void AICallback_OnScrCmd_IsPathDirect(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsPathDirect(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPath
==============
*/
void AICallback_OnScrCmd_ClearPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
   AICommonInterface::`vcall'{448,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearEnemy
==============
*/
void AICallback_OnScrCmd_ClearEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGroundEntType
==============
*/
void AICallback_OnScrCmd_GetGroundEntType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGroundEntType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearEntityTarget
==============
*/
void AICallback_OnScrCmd_ClearEntityTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearEntityTarget(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPotentialThreat
==============
*/
void AICallback_OnScrCmd_ClearPotentialThreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearPotentialThreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetPotentialThreat
==============
*/
void AICallback_OnScrCmd_SetPotentialThreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetPotentialThreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PointInFOV
==============
*/
void AICallback_OnScrCmd_PointInFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PointInFOV(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AllowedStances
==============
*/
void AICallback_OnScrCmd_AllowedStances(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AllowedStances(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEngagementMinDist
==============
*/
void AICallback_OnScrCmd_SetEngagementMinDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEngagementMinDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEngagementMaxDist
==============
*/
void AICallback_OnScrCmd_SetEngagementMaxDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/
void AICallback_OnScrCmd_GetAnglesToLikelyEnemyPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateAimInfo
==============
*/
void AICallback_OnScrCmd_UpdateAimInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateAimInfo(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGunAdditive
==============
*/
void AICallback_OnScrCmd_SetGunAdditive(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGunAdditive(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFacialIndex
==============
*/
void AICallback_OnScrCmd_SetFacialIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFacialIndex(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFacialIndexFromASM
==============
*/
void AICallback_OnScrCmd_SetFacialIndexFromASM(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsCurrentEnemyValid
==============
*/
void AICallback_OnScrCmd_IsCurrentEnemyValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAimAngle
==============
*/
void AICallback_OnScrCmd_GetAimAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAimAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetAimAngles
==============
*/
void AICallback_OnScrCmd_SetAimAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetAimAngles(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_SetFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_GetFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_ClearFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEntityTarget
==============
*/
void AICallback_OnScrCmd_SetEntityTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEntityTarget(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ResetThreatUpdate
==============
*/
void AICallback_OnScrCmd_ResetThreatUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ResetThreatUpdate(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireClear
==============
*/
void AICallback_OnScrCmd_ReacquireClear(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireClear(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireStep
==============
*/
void AICallback_OnScrCmd_ReacquireStep(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireStep(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindReacquireDirectPath
==============
*/
void AICallback_OnScrCmd_FindReacquireDirectPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireMove
==============
*/
void AICallback_OnScrCmd_ReacquireMove(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireMove(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetReacquireState
==============
*/
void AICallback_OnScrCmd_GetReacquireState(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetReacquireState(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartCoverArrival
==============
*/
void AICallback_OnScrCmd_StartCoverArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1312,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishCoverArrival
==============
*/
void AICallback_OnScrCmd_FinishCoverArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FinishCoverArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartZeroArrival
==============
*/
void AICallback_OnScrCmd_StartZeroArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartZeroArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishZeroArrival
==============
*/
void AICallback_OnScrCmd_FinishZeroArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FinishZeroArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartTraverseArrival
==============
*/
void AICallback_OnScrCmd_StartTraverseArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartTraverseArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPointAfterNegotiation
==============
*/
void AICallback_OnScrCmd_GetPointAfterNegotiation(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_DropWeapon
==============
*/
void AICallback_OnScrCmd_DropWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_DropWeapon(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_DropWeaponNoVelocity
==============
*/
void AICallback_OnScrCmd_DropWeaponNoVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPitchOrient
==============
*/
void AICallback_OnScrCmd_ClearPitchOrient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearPitchOrient(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetPitchOrient
==============
*/
void AICallback_OnScrCmd_SetPitchOrient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetPitchOrient(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeHideYaw
==============
*/
void AICallback_OnScrCmd_GetNodeHideYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeHideYaw(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeHideYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeHideYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeSnapYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeSnapYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimYaw
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimPitch
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimPitchOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ChooseArrivalType
==============
*/
void AICallback_OnScrCmd_ChooseArrivalType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ChooseArrivalType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/
void AICallback_OnScrCmd_IW7ShipHack_SetMayMoveTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CalcSharpTurnAnim
==============
*/
void AICallback_OnScrCmd_CalcSharpTurnAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PreCalcShouldStartArrival
==============
*/
void AICallback_OnScrCmd_PreCalcShouldStartArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CalcStopData
==============
*/
void AICallback_OnScrCmd_CalcStopData(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CalcStopData(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetupMotionWarpForTurn
==============
*/
void AICallback_OnScrCmd_SetupMotionWarpForTurn(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGroundSlope
==============
*/
void AICallback_OnScrCmd_GetGroundSlope(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGroundSlope(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PushPlayer
==============
*/
void AICallback_OnScrCmd_PushPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PushPlayer(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInScriptedState
==============
*/
void AICallback_OnScrCmd_IsInScriptedState(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsInScriptedState(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetBlackboard
==============
*/
void AICallback_OnScrCmd_GetBlackboard(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetBlackboard(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearBlackboard
==============
*/
void AICallback_OnScrCmd_ClearBlackboard(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearBlackboard(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsLegacyAgent
==============
*/
void AICallback_OnScrCmd_IsLegacyAgent(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1328,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIGetAnimWeight
==============
*/
void AICallback_OnScrCmd_AIGetAnimWeight(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIGetAnimWeight(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIGetAnimTime
==============
*/
void AICallback_OnScrCmd_AIGetAnimTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIGetAnimTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishTraverse
==============
*/
void AICallback_OnScrCmd_FinishTraverse(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1320,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ForceUpdateGoalPos
==============
*/
void AICallback_OnScrCmd_ForceUpdateGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetApproxEyePos
==============
*/
void AICallback_OnScrCmd_GetApproxEyePos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetApproxEyePos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartBeam
==============
*/
void AICallback_OnScrCmd_StartBeam(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartBeam(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StopBeam
==============
*/
void AICallback_OnScrCmd_StopBeam(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StopBeam(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIPlayGesture
==============
*/
void AICallback_OnScrCmd_AIPlayGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIPlayGesture(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIClearGesture
==============
*/
void AICallback_OnScrCmd_AIClearGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIClearGesture(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetWorldWeaponOffset
==============
*/
void AICallback_OnScrCmd_GetWorldWeaponOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ForceThreatUpdate
==============
*/
void AICallback_OnScrCmd_ForceThreatUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ForceThreatUpdate(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetupDoorOpen
==============
*/
void AICallback_OnScrCmd_SetupDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetupDoorOpen(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearDoorOpen
==============
*/
void AICallback_OnScrCmd_ClearDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearDoorOpen(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ShouldCautiousStrafe
==============
*/
void AICallback_OnScrCmd_ShouldCautiousStrafe(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAdjustedExitDirection
==============
*/
void AICallback_OnScrCmd_GetAdjustedExitDirection(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateCoverExposeType
==============
*/
void AICallback_OnScrCmd_UpdateCoverExposeType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetStrafeReverse
==============
*/
void AICallback_OnScrCmd_SetStrafeReverse(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetStrafeReverse(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetRiotshieldWeapon
==============
*/
void AICallback_OnScrCmd_SetRiotshieldWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{936,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AISuppressAI
==============
*/
void AICallback_OnScrCmd_AISuppressAI(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AISuppressAI(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetOverrideArchetype
==============
*/
void AICallback_OnScrCmd_SetOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearOverrideArchetype
==============
*/
void AICallback_OnScrCmd_ClearOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindOverrideArchetype
==============
*/
void AICallback_OnScrCmd_FindOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetBaseArchetype
==============
*/
void AICallback_OnScrCmd_GetBaseArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetBaseArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBaseArchetype
==============
*/
void AICallback_OnScrCmd_SetBaseArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBaseArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanAimWhileMoving
==============
*/
void AICallback_OnScrCmd_CanAimWhileMoving(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanAimWhileMoving(m_pAI, scrContext);
}

/*
==============
AIScriptedInterface::AISuppressAI
==============
*/
char AIScriptedInterface::AISuppressAI(AIScriptedInterface *this)
{
  sentient_s *TargetSentient; 
  sentient_s *v3; 
  ai_scripted_t *AIScripted; 
  const gentity_s *ent; 
  AIScriptedInterface *m_pAI; 
  const pathnode_t *CoverNode; 
  pathnode_t *v9; 
  AIWrapper v12; 
  vec3_t outEyePos; 
  vec3_t outOffset; 
  vec3_t pos; 
  vec3_t muzzleOffset; 

  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( !TargetSentient )
    return 0;
  v3 = this->GetSentient(this);
  if ( !Sentient_HasDecentVis(v3, TargetSentient) && !this->m_pAI->bForceSuppressAI )
    return 0;
  _XMM6 = 0i64;
  outEyePos.v[0] = 0.0;
  outEyePos.v[1] = 0.0;
  outEyePos.v[2] = 0.0;
  AIScripted = AI_GetAIScripted(TargetSentient->ent);
  if ( AIScripted )
  {
    AIActorInterface::AIActorInterface(&v12.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v12.m_newAgentInterface);
    ent = AIScripted->ent;
    v12.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    v12.m_pAI = NULL;
    AIWrapper::Setup(&v12, ent);
    m_pAI = v12.m_pAI;
    CoverNode = AIScriptedInterface::GetCoverNode(v12.m_pAI);
    v9 = (pathnode_t *)CoverNode;
    if ( CoverNode )
    {
      GetNodeExposedOffset(CoverNode, &outOffset);
      pathnode_t::GetPos(v9, &pos);
      outEyePos.v[0] = pos.v[0] + outOffset.v[0];
      outEyePos.v[2] = pos.v[2] + outOffset.v[2];
      outEyePos.v[1] = pos.v[1] + outOffset.v[1];
    }
    else
    {
      AIScriptedInterface::GetApproxEyePos(m_pAI, &outEyePos, 0);
    }
  }
  else
  {
    Sentient_GetEyePosition(TargetSentient, &outEyePos);
  }
  __asm { vunpcklps xmm0, xmm6, xmm6 }
  outOffset.v[2] = 0.0;
  muzzleOffset.v[2] = 0.0;
  *(double *)muzzleOffset.v = *(double *)&_XMM0;
  if ( !AIScriptedInterface::CanShoot(this, &outEyePos, &muzzleOffset, 0) && !this->m_pAI->bForceSuppressAI )
    return 0;
  this->m_pAI->vGoodShootPos = outEyePos;
  this->m_pAI->bGoodShootPos = 1;
  return 1;
}

/*
==============
AIScriptedInterface::CalcAnimStartPos
==============
*/
void AIScriptedInterface::CalcAnimStartPos(const vec3_t *stopPos, const float stopYaw, const vec3_t *animDelta, const float animAngleDelta, vec3_t *outPos)
{
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  float v12; 
  float v13; 
  float v14; 
  vec3_t v15; 
  tmat33_t<vec3_t> v16; 
  char v17; 

  v15.v[0] = 0.0;
  v15.v[1] = stopYaw - animAngleDelta;
  v15.v[2] = 0.0;
  AnglesToAxis(&v15, &v16);
  if ( animDelta == (const vec3_t *)&v17 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
    __debugbreak();
  v7 = animDelta->v[1];
  v8 = animDelta->v[0];
  v9 = animDelta->v[2];
  v10 = animDelta->v[0] * v16.m[0].v[1];
  v11 = v7 * v16.m[1].v[1];
  outPos->v[0] = stopPos->v[0] - (float)((float)((float)(animDelta->v[0] * v16.m[0].v[0]) + (float)(v7 * v16.m[1].v[0])) + (float)(v9 * v16.m[2].v[0]));
  v12 = v10 + v11;
  v13 = v8 * v16.m[0].v[2];
  v14 = v7 * v16.m[1].v[2];
  outPos->v[1] = stopPos->v[1] - (float)(v12 + (float)(v9 * v16.m[2].v[1]));
  outPos->v[2] = stopPos->v[2] - (float)((float)(v13 + v14) + (float)(v9 * v16.m[2].v[2]));
}

/*
==============
AIScriptedInterface::CalcGoodShootPos
==============
*/
char AIScriptedInterface::CalcGoodShootPos(AIScriptedInterface *this)
{
  const sentient_s *TargetSentient; 
  gentity_s *TargetEntity; 
  bool GoodSuppressSpot; 
  bool v6; 
  const dvar_t *v7; 
  ai_scripted_t *m_pAI; 
  gentity_s *ent; 
  vec3_t outEyePos; 

  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( this->CanSee(this, TargetSentient->ent, -1) && AIScriptedInterface::CanShootEnemy(this, 250, 0, 0) )
  {
    Sentient_GetEyePosition(TargetSentient, &this->m_pAI->vGoodShootPos);
    this->m_pAI->bGoodShootPos = 1;
    return 1;
  }
  if ( !AICommonInterface::GetTargetSentient(this) || !this->m_pAI->sight.lastEnemySightPosValid || !AIScriptedInterface::IsCurrentEnemyValid(this) || !this->m_pAI->bGoodShootPos && !AIScriptedInterface::NeedRecalculateSuppressSpot(this) || this->m_pAI->combat.doingAmbush )
  {
    this->m_pAI->bGoodShootPos = 0;
    goto LABEL_18;
  }
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  if ( TargetEntity && !TargetEntity->client )
  {
    GoodSuppressSpot = AIScriptedInterface::AISuppressAI(this);
    goto LABEL_15;
  }
  AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
  if ( !AIScriptedInterface::CheckPitchVisibility(this, &outEyePos, &this->m_pAI->sight.lastEnemySightPos, NULL) )
  {
LABEL_18:
    v6 = 0;
    goto LABEL_19;
  }
  GoodSuppressSpot = AIScriptedInterface::FindGoodSuppressSpot(this, &outEyePos);
LABEL_15:
  v6 = GoodSuppressSpot;
  if ( !GoodSuppressSpot )
  {
LABEL_19:
    v7 = DVARBOOL_ai_whyaminotshooting;
    if ( !DVARBOOL_ai_whyaminotshooting && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_whyaminotshooting") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.enabled )
    {
      m_pAI = this->m_pAI;
      ent = m_pAI->ent;
      *(_QWORD *)outEyePos.v = *(_QWORD *)m_pAI->ent->r.currentOrigin.v;
      outEyePos.v[2] = ent->r.currentOrigin.v[2] - 12.0;
      G_Main_AddDebugStringWithDuration(&outEyePos, &colorRed, 0.75, "cant suppr", 1);
    }
  }
  return v6;
}

/*
==============
AIScriptedInterface::CalcStopData
==============
*/
bool AIScriptedInterface::CalcStopData(AIScriptedInterface *this, const vec3_t *targetPos, const vec3_t *targetAngles, const vec3_t *animTargetAngles, const vec3_t *codeApproachDir, bool bApproachDirValid, const scr_string_t *stateName, const char *footPrefix, const char *optionalPrefix, float maxLerpScale, float overShootRatio, const scr_string_t *nodeType, const scr_string_t *startNotetrack, const scr_string_t *endNotetrack, const char *speedString)
{
  ai_scripted_t *m_pAI; 
  const entityState_t *p_s; 
  scr_string_t AnimsetName; 
  ai_scripted_t *v21; 
  float v22; 
  gentity_s *ent; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  unsigned int AngleIndex; 
  scr_string_t v32; 
  char *fmt; 
  int entryIndex; 
  scr_string_t name; 
  vec3_t *v38; 
  int *outAnimEntryIndex; 
  char *v40; 
  char *v41; 
  const scr_string_t *v42; 
  const vec3_t *v43; 
  vec3_t end; 
  vec3_t vec; 
  vec3_t angles; 

  m_pAI = this->m_pAI;
  v38 = (vec3_t *)codeApproachDir;
  p_s = &m_pAI->ent->s;
  v40 = (char *)footPrefix;
  v41 = (char *)optionalPrefix;
  v42 = startNotetrack;
  *(_QWORD *)end.v = endNotetrack;
  outAnimEntryIndex = (int *)speedString;
  v43 = targetAngles;
  AnimsetName = BG_AnimationState_GetAnimsetName(p_s);
  v21 = this->m_pAI;
  v22 = targetPos->v[0];
  name = AnimsetName;
  ent = v21->ent;
  v24 = v22 - v21->ent->r.currentOrigin.v[0];
  v25 = targetPos->v[1];
  vec.v[0] = v24;
  v26 = v25 - ent->r.currentOrigin.v[1];
  v27 = targetPos->v[2];
  vec.v[1] = v26;
  v28 = (float)((float)(v26 * v26) + (float)(v24 * v24)) + (float)((float)(v27 - ent->r.currentOrigin.v[2]) * (float)(v27 - ent->r.currentOrigin.v[2]));
  vec.v[2] = v27 - ent->r.currentOrigin.v[2];
  vectoangles(&vec, &angles);
  _XMM8 = 0i64;
  __asm { vroundss xmm2, xmm8, xmm1, 1 }
  AngleIndex = G_GetAngleIndex((float)((float)((float)(targetAngles->v[1] - angles.v[1]) * 0.0027777778) - *(float *)&_XMM2) * 360.0, 22.5);
  v32 = AngleIndex;
  if ( bApproachDirValid && (v28 < 5625.0 || AngleIndex <= 1 || AngleIndex - 7 <= 1) )
  {
    vectoangles(v38, &angles);
    __asm { vroundss xmm4, xmm8, xmm3, 1 }
    v32 = G_GetAngleIndex((float)((float)((float)(targetAngles->v[1] - angles.v[1]) * 0.0027777778) - *(float *)&_XMM4) * 360.0, 22.5);
  }
  if ( DebugArrivalsOnActor(this->m_pAI->ent->s.number) )
    Com_Printf(18, "Trying arrival index %d.\n", (unsigned int)v32);
  SLODWORD(fmt) = *stateName;
  entryIndex = -1;
  AIScriptedInterface::CalculateStopAnim(this, (int)&v40, v32, name, fmt, v40, v41, outAnimEntryIndex);
  this->m_pAI->bArrivalFailed = 1;
  return 0;
}

/*
==============
AIScriptedInterface::CalculateSharpTurnAnim
==============
*/
char AIScriptedInterface::CalculateSharpTurnAnim(AIScriptedInterface *this, unsigned int angleIndexCount, int *angleIndices, scr_string_t animsetName, scr_string_t stateName, const vec3_t *corner, const vec3_t *nextPathPoint, const char *footPrefix, const char *optionalPrefix, const char *optionalSuffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  int *v14; 
  unsigned int v16; 
  __int64 v17; 
  int v18; 
  const char *v19; 
  scr_string_t String; 
  const char *v21; 
  scr_string_t v22; 
  double v24; 
  float v25; 
  int *v26; 
  double v27; 
  float v28; 
  int *v29; 
  vec3_t s1; 
  unsigned int v32; 
  int v33; 
  int v34; 
  vec3_t v35; 
  vec3_t v36; 
  const char *v37; 
  scr_anim_t *v38; 
  int *v39; 
  int *v40; 
  __m256i v41; 
  int v42; 

  v14 = angleIndices;
  v37 = optionalSuffix;
  v38 = outAnim;
  v39 = outAngleIndex;
  v40 = outAnimEntryIndex;
  v32 = angleIndexCount;
  *(_QWORD *)s1.v = footPrefix;
  if ( !angleIndices && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6023, ASSERT_TYPE_ASSERT, "(angleIndices)", (const char *)&queryFormat, "angleIndices") )
    __debugbreak();
  if ( !footPrefix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6024, ASSERT_TYPE_ASSERT, "(footPrefix)", (const char *)&queryFormat, "footPrefix") )
    __debugbreak();
  v16 = 0;
  v42 = 2;
  v41 = _ymm;
  if ( angleIndexCount )
  {
    while ( 1 )
    {
      v17 = *v14;
      if ( (unsigned int)v17 > 2 && (unsigned int)(v17 - 6) > 2 )
        return 0;
      v18 = v41.m256i_i32[v17];
      if ( v18 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6038, ASSERT_TYPE_ASSERT, "(keyPadDirection[angleIndex] > 0)", (const char *)&queryFormat, "keyPadDirection[angleIndex] > 0") )
        __debugbreak();
      v19 = j_va("%s%d%s", *(const char **)s1.v, (unsigned int)v18, v37);
      String = SL_FindString(v19);
      if ( String )
      {
        ((void (__fastcall *)(AIScriptedInterface *, vec3_t *, _QWORD, _QWORD, scr_string_t, int *))this->GetRandomAlias)(this, &v35, (unsigned int)animsetName, (unsigned int)stateName, String, &v33);
        if ( *(_QWORD *)v35.v )
          break;
      }
      if ( optionalPrefix )
      {
        if ( *optionalPrefix )
        {
          if ( I_stricmp(optionalPrefix, *(const char **)s1.v) )
          {
            v21 = j_va("%s%d%s", optionalPrefix, (unsigned int)v18, v37);
            v22 = SL_FindString(v21);
            if ( v22 )
            {
              ((void (__fastcall *)(AIScriptedInterface *, vec3_t *, _QWORD, _QWORD, scr_string_t, int *))this->GetRandomAlias)(this, &v36, (unsigned int)animsetName, (unsigned int)stateName, v22, &v34);
              if ( *(_QWORD *)v36.v )
              {
                v27 = *(double *)nextPathPoint->v;
                s1.v[2] = nextPathPoint->v[2];
                *(double *)s1.v = v27;
                v28 = corner->v[2];
                *(_QWORD *)v35.v = *(_QWORD *)corner->v;
                v35.v[2] = v28;
                if ( !AIScriptedInterface::CanDoTurnAnim(this, *(scr_anim_t *)v36.v, &v35, &s1) )
                  return 0;
                *v38 = *(scr_anim_t *)v36.v;
                v29 = v40;
                *v39 = v17;
                if ( v29 )
                  *v29 = v34;
                return 1;
              }
            }
          }
        }
      }
      ++v16;
      ++v14;
      if ( v16 >= v32 )
        return 0;
    }
    v24 = *(double *)nextPathPoint->v;
    s1.v[2] = nextPathPoint->v[2];
    *(double *)s1.v = v24;
    v25 = corner->v[2];
    *(_QWORD *)v36.v = *(_QWORD *)corner->v;
    v36.v[2] = v25;
    if ( !AIScriptedInterface::CanDoTurnAnim(this, *(scr_anim_t *)v35.v, &v36, &s1) )
      return 0;
    *v38 = *(scr_anim_t *)v35.v;
    v26 = v40;
    *v39 = v17;
    if ( v26 )
    {
      *v26 = v33;
      return 1;
    }
    return 1;
  }
  return 0;
}

/*
==============
AIScriptedInterface::CalculateSharpTurnExitAnim
==============
*/
char AIScriptedInterface::CalculateSharpTurnExitAnim(AIScriptedInterface *this, int *angleIndices, unsigned int angleIndexCount, scr_string_t animsetName, scr_string_t stateName, const char *prefix, const char *suffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  scr_string_t v11; 
  int *v15; 
  gentity_s *v16; 
  unsigned int v17; 
  float v19; 
  ai_scripted_t *m_pAI; 
  float v21; 
  __int128 v22; 
  float v23; 
  __int128 v24; 
  AINavigator2D *v29; 
  const bfx::AreaHandle *CurArea; 
  __int64 v32; 
  const char *v33; 
  const char *v34; 
  scr_string_t String; 
  scrContext_t *v36; 
  scr_string_t code_move; 
  const XAnim_s *Anims; 
  float v41; 
  scr_anim_t anim; 
  scr_string_t v44; 
  bfx::AreaHandle hStartArea; 
  const char *v46; 
  const char *v47; 
  vec3_t *angles; 
  int *v49; 
  scr_anim_t *v50; 
  int *v51; 
  __int64 v52; 
  vec3_t outMoveDelta; 
  vec3_t outCurPos; 
  vec3_t forward; 
  tmat33_t<vec3_t> axis; 
  __int64 v57[4]; 
  __int128 v58; 
  const char *v59; 
  const char *v60; 
  __int64 v61; 

  v52 = -2i64;
  v11 = animsetName;
  v44 = animsetName;
  v47 = prefix;
  v46 = suffix;
  v50 = outAnim;
  v51 = outAngleIndex;
  v15 = outAnimEntryIndex;
  v49 = outAnimEntryIndex;
  v16 = this->GetEntity(this);
  v57[0] = (__int64)"exit2";
  v57[1] = (__int64)"exit3";
  v57[2] = (__int64)"exit6";
  v17 = 0;
  v57[3] = 0i64;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v58 = _XMM0;
  v59 = "exit4";
  v60 = "exit1";
  v61 = 0i64;
  angles = &v16->r.currentAngles;
  AngleVectors(&v16->r.currentAngles, &forward, NULL, NULL);
  v19 = (float)((float)(this->m_pAI->Physics.vVelocity.v[0] * this->m_pAI->Physics.vVelocity.v[0]) + (float)(this->m_pAI->Physics.vVelocity.v[1] * this->m_pAI->Physics.vVelocity.v[1])) + (float)(this->m_pAI->Physics.vVelocity.v[2] * this->m_pAI->Physics.vVelocity.v[2]);
  if ( !outAnimEntryIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5964, ASSERT_TYPE_ASSERT, "(outAnimEntryIndex)", (const char *)&queryFormat, "outAnimEntryIndex") )
    __debugbreak();
  *outAnimEntryIndex = -1;
  m_pAI = this->m_pAI;
  v21 = m_pAI->Physics.vVelocity.v[1];
  v22 = LODWORD(m_pAI->Physics.vVelocity.v[0]);
  v23 = m_pAI->Physics.vVelocity.v[2];
  v24 = v22;
  *(float *)&v24 = fsqrt((float)((float)(*(float *)&v22 * *(float *)&v22) + (float)(v21 * v21)) + (float)(v23 * v23));
  _XMM3 = v24;
  __asm { vcmpless xmm0, xmm3, cs:__real@80000000 }
  _XMM10 = LODWORD(FLOAT_1_0);
  __asm { vblendvps xmm1, xmm3, xmm10, xmm0 }
  if ( v19 < 1.0 || (float)((float)((float)((float)(v21 * (float)(1.0 / *(float *)&_XMM1)) * forward.v[1]) + (float)((float)(*(float *)&v22 * (float)(1.0 / *(float *)&_XMM1)) * forward.v[0])) + (float)((float)(v23 * (float)(1.0 / *(float *)&_XMM1)) * forward.v[2])) < 0.17299999 )
  {
    Nav_GetPos(m_pAI->pNavigator, &outCurPos);
    bfx::AreaHandle::AreaHandle(&hStartArea);
    v29 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
    if ( v29 )
    {
      CurArea = AINavigator2D::GetCurArea(v29);
      bfx::AreaHandle::operator=(&hStartArea, CurArea);
    }
    if ( angleIndexCount )
    {
      _XMM11 = 0i64;
      do
      {
        v32 = *angleIndices;
        v33 = (const char *)v57[v32];
        if ( v33 )
        {
          v34 = j_va("%s%s%s", v47, v33, v46);
          String = SL_FindString(v34);
          if ( String )
          {
            ((void (__fastcall *)(AIScriptedInterface *, scr_anim_t *, _QWORD, _QWORD, scr_string_t, int *))this->GetRandomAlias)(this, &anim, (unsigned int)v11, (unsigned int)stateName, String, v15);
            if ( anim )
            {
              v36 = ScriptContext_Server();
              code_move = scr_const.code_move;
              Anims = Scr_GetAnims(v36, anim.tree);
              XAnimGetNotetrackTime(Anims, anim.index, code_move);
              __asm
              {
                vcmpltss xmm1, xmm11, xmm0
                vblendvps xmm3, xmm10, xmm0, xmm1; endTime
              }
              G_GetMoveDelta(v36, anim, 0.0, *(const float *)&_XMM3, &outMoveDelta);
              AnglesToAxis(angles, &axis);
              v41 = (float)((float)(outMoveDelta.v[0] * axis.m[0].v[1]) + (float)(outMoveDelta.v[1] * axis.m[1].v[1])) + (float)(outMoveDelta.v[2] * axis.m[2].v[1]);
              *(float *)&_XMM3 = (float)((float)(outMoveDelta.v[0] * axis.m[0].v[2]) + (float)(outMoveDelta.v[1] * axis.m[1].v[2])) + (float)(outMoveDelta.v[2] * axis.m[2].v[2]);
              outMoveDelta.v[0] = (float)((float)((float)(outMoveDelta.v[0] * axis.m[0].v[0]) + (float)(outMoveDelta.v[1] * axis.m[1].v[0])) + (float)(outMoveDelta.v[2] * axis.m[2].v[0])) + outCurPos.v[0];
              outMoveDelta.v[1] = v41 + outCurPos.v[1];
              outMoveDelta.v[2] = *(float *)&_XMM3 + outCurPos.v[2];
              if ( AIScriptedInterface::MayMoveFromPointToPoint(this, &outCurPos, &hStartArea, &outMoveDelta, 1, 1) )
              {
                *v50 = anim;
                *v51 = v32;
                bfx::AreaHandle::~AreaHandle(&hStartArea);
                return 1;
              }
              v15 = v49;
              v11 = v44;
            }
          }
        }
        ++v17;
        ++angleIndices;
      }
      while ( v17 < angleIndexCount );
    }
    bfx::AreaHandle::~AreaHandle(&hStartArea);
  }
  return 0;
}

/*
==============
AIScriptedInterface::CalculateStopAnim
==============
*/
scr_anim_t AIScriptedInterface::CalculateStopAnim(AIScriptedInterface *this, unsigned __int64 *angleIndex, scr_string_t animsetName, scr_string_t stateName, const char *footPrefix, const char *optionalPrefix, const char *speedString, int *outAnimEntryIndex, __int64 a9)
{
  __int64 v9; 
  const char **v12; 
  scr_string_t String; 
  const dvar_t *v14; 
  scr_string_t v15; 
  char *fmt; 
  char *fmta; 
  __int64 v20; 
  __int64 v21[2]; 
  char dest[136]; 

  v21[1] = -2i64;
  v9 = animsetName;
  v20 = a9;
  Sys_ProfBeginNamedEvent(0xFF808080, "CalculateStopAnim");
  if ( keyPadDirection[v9] <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6175, ASSERT_TYPE_ASSERT, "(keyPadDirection[angleIndex] > 0)", (const char *)&queryFormat, "keyPadDirection[angleIndex] > 0") )
    __debugbreak();
  if ( outAnimEntryIndex && *(_BYTE *)outAnimEntryIndex )
  {
    v12 = &keyPadModifier[v9];
    LODWORD(fmt) = keyPadDirection[v9];
    Com_sprintf(dest, 0x80ui64, "%s%d%s%s", optionalPrefix, fmt, *v12, (const char *)outAnimEntryIndex);
  }
  else
  {
    v12 = &keyPadModifier[v9];
    LODWORD(fmt) = keyPadDirection[v9];
    Com_sprintf(dest, 0x80ui64, "%s%d%s", optionalPrefix, fmt, *v12);
  }
  String = SL_FindString(dest);
  if ( String && (((void (__fastcall *)(AIScriptedInterface *, __int64 *, _QWORD, _QWORD, scr_string_t, __int64))this->GetRandomAlias)(this, v21, (unsigned int)stateName, (unsigned int)footPrefix, String, v20), v21[0]) )
  {
    v14 = DCONST_DVARBOOL_ai_showArrivalCalcInfo;
    if ( !DCONST_DVARBOOL_ai_showArrivalCalcInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_showArrivalCalcInfo") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    if ( v14->current.enabled )
      G_DebugString(&this->m_pAI->ent->r.currentOrigin, &colorGreen, 1.0, dest, 1);
    *angleIndex = v21[0];
    Sys_ProfEndNamedEvent();
  }
  else
  {
    if ( !speedString || speedString == optionalPrefix )
      goto LABEL_27;
    if ( outAnimEntryIndex && *(_BYTE *)outAnimEntryIndex )
    {
      LODWORD(fmta) = keyPadDirection[v9];
      Com_sprintf(dest, 0x80ui64, "%s%d%s%s", speedString, fmta, *v12, (const char *)outAnimEntryIndex);
    }
    else
    {
      LODWORD(fmta) = keyPadDirection[v9];
      Com_sprintf(dest, 0x80ui64, "%s%d%s", speedString, fmta, *v12);
    }
    v15 = SL_FindString(dest);
    if ( v15 && (((void (__fastcall *)(AIScriptedInterface *, __int64 *, _QWORD, _QWORD, scr_string_t, __int64))this->GetRandomAlias)(this, &v20, (unsigned int)stateName, (unsigned int)footPrefix, v15, v20), v20) )
    {
      if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_ai_showArrivalCalcInfo, "ai_showArrivalCalcInfo") )
        G_DebugString(&this->m_pAI->ent->r.currentOrigin, &colorGreen, 1.0, dest, 1);
      *angleIndex = v20;
      Sys_ProfEndNamedEvent();
    }
    else
    {
LABEL_27:
      *angleIndex = UNDEFINED_ANIM_3.linkPointer;
      Sys_ProfEndNamedEvent();
    }
  }
  return (scr_anim_t)angleIndex;
}

/*
==============
AIScriptedInterface::CanDoTurnAnim
==============
*/
char AIScriptedInterface::CanDoTurnAnim(AIScriptedInterface *this, scr_anim_t turnAnim, const vec3_t *corner, const vec3_t *nextPathPoint)
{
  __int128 v4; 
  unsigned __int64 v6; 
  const gentity_s *v9; 
  const scrContext_t *v10; 
  scr_string_t code_move; 
  scrContext_t *v12; 
  const XAnim_s *Anims; 
  scr_string_t v14; 
  float v15; 
  const XAnim_s *v16; 
  const XAnim_s *v19; 
  const char *AnimName; 
  const char *v21; 
  ai_scripted_t *m_pAI; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v32; 
  const dvar_t *v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  const vec4_t *v40; 
  float v42; 
  vec3_t end; 
  vec3_t outMoveDelta; 
  vec3_t local; 
  vec3_t outWorld; 

  v6 = turnAnim.linkPointer >> 16;
  v9 = (const gentity_s *)((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))this->GetEntity)(this, turnAnim, corner, nextPathPoint);
  v10 = ScriptContext_Server();
  code_move = scr_const.code_move;
  v12 = (scrContext_t *)v10;
  Anims = Scr_GetAnims(v10, (unsigned __int16)v6);
  *(double *)&v4 = XAnimGetNotetrackTime(Anims, turnAnim.index, code_move);
  v14 = scr_const.corner;
  v15 = *(float *)&v4;
  v16 = Scr_GetAnims(v12, (unsigned __int16)v6);
  *(double *)&v4 = XAnimGetNotetrackTime(v16, turnAnim.index, v14);
  _XMM9 = 0i64;
  _XMM7 = v4;
  if ( v15 < 0.0 )
  {
    v19 = Scr_GetAnims(v12, (unsigned __int16)v6);
    AnimName = XAnimGetAnimName(v19, turnAnim.index);
    v21 = j_va("Turn anim %s does not have code_move notetrack!", AnimName);
    Scr_Error(COM_ERR_3901, v12, v21);
    v15 = FLOAT_1_0;
  }
  __asm
  {
    vcmpltss xmm1, xmm7, xmm9
    vblendvps xmm0, xmm7, xmm0, xmm1
  }
  if ( v15 > 1.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5891, ASSERT_TYPE_ASSERT, "(codeMoveTime <= 1.f)", (const char *)&queryFormat, "codeMoveTime <= 1.f") )
    __debugbreak();
  G_GetMoveDelta(v12, turnAnim, 0.0, v15, &outMoveDelta);
  G_LocalToWorldCoords(v9, &outMoveDelta, &outWorld);
  G_GetMoveDelta(v12, turnAnim, 0.0, *(const float *)&_XMM0, &local);
  G_LocalToWorldCoords(v9, &local, &end);
  m_pAI = this->m_pAI;
  v25 = v9->r.currentOrigin.v[0];
  v26 = v9->r.currentOrigin.v[1];
  v27 = v9->r.currentOrigin.v[2];
  v28 = corner->v[0] - v25;
  v29 = corner->v[1] - v26;
  v30 = corner->v[2] - v27;
  _XMM0 = m_pAI->pNavigator->m_TimeOfLastPathUpdate;
  v32 = fsqrt((float)((float)(v29 * v29) + (float)(v28 * v28)) + (float)(v30 * v30));
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm0, xmm9, xmm4, xmm2
  }
  v42 = fsqrt((float)((float)(m_pAI->Physics.vWishDelta.v[0] * m_pAI->Physics.vWishDelta.v[0]) + (float)(m_pAI->Physics.vWishDelta.v[1] * m_pAI->Physics.vWishDelta.v[1])) + (float)(m_pAI->Physics.vWishDelta.v[2] * m_pAI->Physics.vWishDelta.v[2]));
  if ( v32 >= (float)(*(float *)&_XMM0 + 1.0) )
  {
    v35 = DVARBOOL_ai_debugTurns;
    v36 = end.v[0] - v25;
    v37 = end.v[2] - v27;
    v38 = fsqrt((float)((float)((float)(end.v[1] - v26) * (float)(end.v[1] - v26)) + (float)(v36 * v36)) + (float)(v37 * v37));
    v39 = (float)(end.v[2] - v27) * (float)(1.0 / v38);
    if ( (float)((float)((float)((float)(v29 * (float)(1.0 / v32)) * (float)(end.v[1] - v26)) + (float)((float)(v28 * (float)(1.0 / v32)) * v36)) + (float)((float)(v30 * (float)(1.0 / v32)) * v37)) < (float)(v32 - v42) )
    {
      if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v35);
      if ( !v35->current.enabled )
        return 0;
      v40 = &colorOrangeHeat;
LABEL_19:
      G_DebugLineWithDuration(&v9->r.currentOrigin, &end, v40, 0, 10);
      return 0;
    }
    if ( (float)((float)((float)((float)((float)(end.v[1] - v26) * (float)(1.0 / v38)) * v29) + (float)((float)(v36 * (float)(1.0 / v38)) * v28)) + (float)(v30 * v39)) < (float)(v38 * 0.5) )
    {
      if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v35);
      if ( !v35->current.enabled )
        return 0;
      v40 = &colorRedHeat;
      goto LABEL_19;
    }
    if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v35);
    if ( v35->current.enabled )
      G_DebugLineWithDuration(&v9->r.currentOrigin, &end, &colorTeal, 0, 10);
  }
  return 1;
}

/*
==============
AIScriptedInterface::CanSeeAndShootPoint
==============
*/
bool AIScriptedInterface::CanSeeAndShootPoint(AIScriptedInterface *this, const vec3_t *vPoint)
{
  bool result; 
  vec3_t outEyePos; 
  vec3_t outOrigin; 

  result = 0;
  if ( this->GetEquippedWeapon(this)->weaponIdx )
  {
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( AICommonInterface::SightTrace(this, &outEyePos, vPoint, 2047, NORMAL_FOLIAGE_CHECKS) )
    {
      AIScriptedInterface::GetMuzzlePosApprox(this, &outOrigin);
      if ( AICommonInterface::SightTrace(this, &outOrigin, vPoint, 2047, NORMAL_FOLIAGE_CHECKS) )
        return 1;
    }
  }
  return result;
}

/*
==============
AIScriptedInterface::CanSeeEnemyFromExposed
==============
*/
_BOOL8 AIScriptedInterface::CanSeeEnemyFromExposed(AIScriptedInterface *this, const pathnode_t *pNode)
{
  gentity_s *TargetEntity; 
  bool CanSeePointFromExposedAtNode; 
  const sentient_s *sentient; 
  int v7; 
  AIWrapper v9; 
  vec3_t outEyePos; 

  Sys_ProfBeginNamedEvent(0xFF808080, "AIScr_CanSeeEnemyFromExposed");
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  if ( TargetEntity )
  {
    AIActorInterface::AIActorInterface(&v9.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
    v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    v9.m_pAI = NULL;
    AIWrapper::Setup(&v9, TargetEntity);
    if ( pNode )
    {
      if ( v9.m_pAI )
      {
        AIScriptedInterface::GetApproxEyePos(v9.m_pAI, &outEyePos, 0);
      }
      else
      {
        sentient = TargetEntity->sentient;
        if ( sentient )
          Sentient_GetEyePosition(sentient, &outEyePos);
        else
          G_Utils_EntityCentroid(TargetEntity, &outEyePos);
      }
      if ( this->Is3D(this) )
      {
        v7 = 1 << LOBYTE(pNode->constant.type);
        if ( (v7 & 0x1E300000) != 0 || (v7 & 0x400000) != 0 )
        {
          CanSeePointFromExposedAtNode = AIScriptedInterface::CanSeePointFromExposedAtNode(this, &outEyePos, pNode, this->m_pAI->eCurrentStance);
          if ( CanSeePointFromExposedAtNode )
            goto LABEL_16;
          outEyePos.v[0] = (float)(outEyePos.v[0] + TargetEntity->r.currentOrigin.v[0]) * 0.5;
          outEyePos.v[1] = (float)(outEyePos.v[1] + TargetEntity->r.currentOrigin.v[1]) * 0.5;
          outEyePos.v[2] = (float)(outEyePos.v[2] + TargetEntity->r.currentOrigin.v[2]) * 0.5;
        }
      }
      CanSeePointFromExposedAtNode = AIScriptedInterface::CanSeePointFromExposedAtNode(this, &outEyePos, pNode, this->m_pAI->eCurrentStance);
      goto LABEL_16;
    }
    CanSeePointFromExposedAtNode = AICommonInterface::CanSeeEnemy(this) != 0;
  }
  else
  {
    CanSeePointFromExposedAtNode = 0;
  }
LABEL_16:
  Sys_ProfEndNamedEvent();
  return CanSeePointFromExposedAtNode;
}

/*
==============
AIScriptedInterface::CanSeePointFromExposedAtNode
==============
*/
bool AIScriptedInterface::CanSeePointFromExposedAtNode(AIScriptedInterface *this, const vec3_t *point, const pathnode_t *pNode, ai_stance_e stance)
{
  unsigned __int16 type; 
  float v9; 
  float v10; 
  double Angle; 
  float v14; 
  gentity_s *TargetEntity; 
  int v16; 
  int number; 
  ai_scripted_t *m_pAI; 
  int ignoreEnt2; 
  vec3_t pos; 
  vec3_t fromPoint; 
  vec2_t vec; 
  float v24; 
  vec3_t out; 
  vec3_t vector; 
  vec3_t outEyeOffset; 
  vec4_t quat; 

  pathnode_t::GetPos((pathnode_t *)pNode, &pos);
  type = pNode->constant.type;
  if ( type == 31 )
    type = pNode->dynamic.coverMultiType;
  if ( (unsigned int)type - 6 <= 1 )
  {
    v9 = point->v[1] - pos.v[1];
    vec.v[0] = point->v[0] - pos.v[0];
    v24 = point->v[2] - pos.v[2];
    vec.v[1] = v9;
    v10 = COERCE_FLOAT(COERCE_UNSIGNED_INT64(vectoyaw(&vec)));
    Angle = pathnode_t::GetAngle((pathnode_t *)pNode);
    _XMM1 = 0i64;
    __asm { vroundss xmm4, xmm1, xmm3, 1 }
    v14 = (float)((float)((float)(v10 - *(float *)&Angle) * 0.0027777778) - *(float *)&_XMM4) * 360.0;
    if ( COERCE_FLOAT(LODWORD(v14) & _xmm) > 60.0 || type == 7 && v14 < -14.0 )
      return 0;
    if ( v14 > 12.0 )
      return 0;
  }
  GetNodeExposedEyeOffset(type, stance, &outEyeOffset);
  pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
  AnglesToQuat(&vector, &quat);
  QuatTransform(&quat, &outEyeOffset, &out);
  fromPoint.v[0] = out.v[0] + pos.v[0];
  fromPoint.v[2] = out.v[2] + pos.v[2];
  fromPoint.v[1] = out.v[1] + pos.v[1];
  if ( !AIScriptedInterface::CheckPitchVisibility(this, &fromPoint, point, pNode) )
    return 0;
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  v16 = 2047;
  if ( TargetEntity )
    number = TargetEntity->s.number;
  else
    number = 2047;
  if ( AIScriptedInterface::SightTracePassed(this, &fromPoint, point, number, this->m_pAI->ent->s.number, 1, 0, 0) )
    return 1;
  if ( (unsigned __int16)(pNode->constant.type - 3) > 1u )
    return 0;
  m_pAI = this->m_pAI;
  fromPoint.v[0] = pos.v[0];
  fromPoint.v[2] = pos.v[2] + 64.0;
  fromPoint.v[1] = pos.v[1];
  ignoreEnt2 = m_pAI->ent->s.number;
  if ( TargetEntity )
    v16 = TargetEntity->s.number;
  return AIScriptedInterface::SightTracePassed(this, &fromPoint, point, v16, ignoreEnt2, 1, 0, 0);
}

/*
==============
AIScriptedInterface::CanSuppressEnemy
==============
*/
bool AIScriptedInterface::CanSuppressEnemy(AIScriptedInterface *this)
{
  gentity_s *TargetEntity; 
  vec3_t outEyePos; 

  if ( AICommonInterface::GetTargetSentient(this) && this->m_pAI->sight.lastEnemySightPosValid && AIScriptedInterface::IsCurrentEnemyValid(this) && (this->m_pAI->bGoodShootPos || AIScriptedInterface::NeedRecalculateSuppressSpot(this)) && !this->m_pAI->combat.doingAmbush )
  {
    TargetEntity = AICommonInterface::GetTargetEntity(this);
    if ( TargetEntity && !TargetEntity->client )
      return AIScriptedInterface::AISuppressAI(this);
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( AIScriptedInterface::CheckPitchVisibility(this, &outEyePos, &this->m_pAI->sight.lastEnemySightPos, NULL) )
      return AIScriptedInterface::FindGoodSuppressSpot(this, &outEyePos);
  }
  else
  {
    this->m_pAI->bGoodShootPos = 0;
  }
  return 0;
}

/*
==============
AIScriptedInterface::CheckPitchVisibility
==============
*/
bool AIScriptedInterface::CheckPitchVisibility(AIScriptedInterface *this, const vec3_t *fromPoint, const vec3_t *toPoint, const pathnode_t *pNode)
{
  ai_scripted_t *m_pAI; 
  float upAimLimit; 
  float v8; 
  AIScriptedInterface_vtbl *v9; 
  float v10; 
  float v11; 
  int v12; 
  double v13; 
  float v14; 
  float v17; 
  vec3_t in; 
  vec3_t vector; 
  vec4_t quat; 
  vec4_t v22; 
  vec3_t out; 

  m_pAI = this->m_pAI;
  upAimLimit = m_pAI->sight.upAimLimit;
  v8 = m_pAI->sight.downAimLimit + 20.0;
  v9 = this->__vftable;
  v10 = upAimLimit - 20.0;
  v11 = toPoint->v[1] - fromPoint->v[1];
  in.v[0] = toPoint->v[0] - fromPoint->v[0];
  in.v[2] = toPoint->v[2] - fromPoint->v[2];
  in.v[1] = v11;
  if ( v9->Is3D(this) )
  {
    if ( pNode && ((v12 = 1 << LOBYTE(pNode->constant.type), (v12 & 0x1E300000) != 0) || (v12 & 0x400000) != 0) )
      pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
    else
      vector = this->m_pAI->ent->r.currentAngles;
    AnglesToQuat(&vector, &quat);
    LODWORD(v22.v[0]) = LODWORD(quat.v[0]) ^ _xmm;
    LODWORD(v22.v[1]) = LODWORD(quat.v[1]) ^ _xmm;
    LODWORD(v22.v[2]) = LODWORD(quat.v[2]) ^ _xmm;
    v22.v[3] = quat.v[3];
    QuatTransform(&v22, &in, &out);
    in = out;
  }
  v13 = vectopitch(&in);
  v14 = *(float *)&v13 * 0.0027777778;
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 1 }
  v17 = (float)(v14 - *(float *)&_XMM4) * 360.0;
  return v17 >= v10 && (v17 <= v8 || (!pNode || (unsigned __int16)(pNode->constant.type - 3) <= 1u) && v17 <= (float)(v8 + 55.0));
}

/*
==============
AIScriptedInterface::ClearIdleFacingUseAlliesPos
==============
*/
void AIScriptedInterface::ClearIdleFacingUseAlliesPos(AIScriptedInterface *this)
{
  this->m_pAI->bCachedIdleFacingPosValid = 0;
}

/*
==============
CullCoverPosesForShort
==============
*/
__int64 CullCoverPosesForShort(ai_scripted_t *pScripted, const pathnode_t *pNode, scr_string_t *possiblePoses, int numPossiblePoses, const scr_string_t *curCoverPose)
{
  __int64 v5; 
  __int16 type; 
  __m256i *v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  scr_string_t v15; 
  __int64 v16; 
  const vec3_t *v17; 
  const vec4_t *v18; 
  const dvar_t *v19; 
  __m256i *v21; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v24; 
  vec3_t out; 
  vec3_t endPos; 
  vec3_t pos; 
  vec3_t vector; 
  tmat33_t<vec3_t> axis; 
  __m256i v30; 
  float v31; 
  __m256i v32; 
  float v33; 
  __m256i v34; 
  float v35; 

  v5 = (unsigned int)numPossiblePoses;
  Sys_ProfBeginNamedEvent(0xFF808080, "AIScr_CullCoverPosesForShort");
  v30 = _ymm;
  v31 = 0.0;
  v32 = _ymm_c200000000000000421000004200000000000000421000000000000000000000;
  v33 = FLOAT_36_0;
  v34 = _ymm;
  v35 = 0.0;
  type = pNode->constant.type;
  if ( type == 31 )
    type = pNode->dynamic.turretEntNumber;
  switch ( type )
  {
    case 2:
    case 10:
      v10 = &v30;
      goto LABEL_7;
    case 3:
    case 4:
    case 11:
      v10 = &v32;
      goto LABEL_7;
    case 6:
    case 7:
      v10 = &v34;
LABEL_7:
      v21 = v10;
      pathnode_t::GetPos((pathnode_t *)pNode, &pos);
      pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
      AnglesToAxis(&vector, &axis);
      AIActorInterface::AIActorInterface(&v24.m_actorInterface);
      AIAgentInterface::AIAgentInterface(&v24.m_newAgentInterface);
      v24.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      v24.m_pAI = NULL;
      AIWrapper::Setup(&v24, pScripted->ent);
      m_pAI = v24.m_pAI;
      if ( !v24.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7700, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      v11 = 0;
      if ( (int)v5 <= 0 )
        goto LABEL_41;
      v12 = 0i64;
      v13 = 0i64;
      v14 = v5;
      break;
    default:
      v11 = v5;
      goto LABEL_41;
  }
  do
  {
    v15 = possiblePoses[v13];
    if ( v15 == scr_const.full_exposed || v15 == *curCoverPose )
    {
      if ( v12 <= v13 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7709, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
        goto LABEL_24;
      __debugbreak();
      possiblePoses[v12] = possiblePoses[v13];
      ++v11;
      ++v12;
    }
    else
    {
      if ( v15 == scr_const.left )
      {
        v16 = 1i64;
      }
      else
      {
        v16 = 0i64;
        if ( v15 == scr_const.right )
          v16 = 2i64;
      }
      v17 = (const vec3_t *)((char *)v10 + 12 * v16);
      if ( v17->v[0] == 0.0 && v17->v[1] == 0.0 && v17->v[2] == 0.0 )
      {
        if ( v12 > v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7752, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
          __debugbreak();
LABEL_24:
        possiblePoses[v12] = possiblePoses[v13];
        ++v11;
        ++v12;
        goto LABEL_35;
      }
      MatrixTransformVector(v17, &axis, &out);
      out.v[0] = pos.v[0] + out.v[0];
      out.v[1] = pos.v[1] + out.v[1];
      out.v[2] = pos.v[2] + out.v[2];
      endPos.v[0] = (float)(32.0 * axis.m[0].v[0]) + out.v[0];
      endPos.v[1] = (float)(32.0 * axis.m[0].v[1]) + out.v[1];
      endPos.v[2] = (float)(32.0 * axis.m[0].v[2]) + out.v[2];
      v18 = &colorRed;
      if ( AIScriptedInterface::SightTracePassed(m_pAI, &out, &endPos, pScripted->ent->s.number, 2047, 1, 0, 1) )
      {
        if ( v12 > v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7736, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
          __debugbreak();
        possiblePoses[v12] = possiblePoses[v13];
        ++v11;
        ++v12;
        v18 = &colorGreen;
      }
      v19 = DVARBOOL_ai_debugShort;
      if ( !DVARBOOL_ai_debugShort && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugShort") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v19);
      if ( v19->current.enabled )
        G_DebugLineWithDuration(&out, &endPos, v18, 0, 20);
    }
LABEL_35:
    ++v13;
    --v14;
    v10 = v21;
  }
  while ( v14 );
LABEL_41:
  Sys_ProfEndNamedEvent();
  return v11;
}

/*
==============
DebugArrivalPosition
==============
*/
void DebugArrivalPosition(const gentity_s *const pEnt, const vec3_t *goalOrigin, const vec3_t *arrivalAngles)
{
  float v5; 
  vec3_t end; 
  vec3_t forward; 
  vec4_t color; 

  if ( DebugArrivalsOnActor(pEnt->s.number) )
  {
    AngleVectors(arrivalAngles, &forward, NULL, NULL);
    color = (vec4_t)_xmm;
    end.v[0] = (float)(16.0 * forward.v[0]) + goalOrigin->v[0];
    end.v[1] = (float)(16.0 * forward.v[1]) + goalOrigin->v[1];
    end.v[2] = (float)(16.0 * forward.v[2]) + goalOrigin->v[2];
    G_DebugLineWithDuration(goalOrigin, &end, &color, 0, 1);
    v5 = goalOrigin->v[1];
    end.v[0] = goalOrigin->v[0];
    end.v[2] = goalOrigin->v[2] + 64.0;
    end.v[1] = v5;
    G_DebugLineWithDuration(goalOrigin, &end, &color, 0, 1);
  }
}

/*
==============
DebugArrivalsOnActor
==============
*/
bool DebugArrivalsOnActor(const int entnum)
{
  const dvar_t *v1; 
  const char *string; 

  v1 = DVARSTR_debug_arrivals;
  if ( !DVARSTR_debug_arrivals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "debug_arrivals") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  string = v1->current.string;
  return I_strcmp(string, "off") && (!I_strcmp(string, "on") || atoi(string) == entnum);
}

/*
==============
FindBestSlice
==============
*/
__int64 FindBestSlice(const float *results, int maxSlices, float minDist)
{
  int v3; 
  __int64 v4; 
  int v5; 
  int v6; 
  int v7; 
  int v9; 
  float v10; 
  const float *i; 
  int v14; 
  int v15; 
  const float *v16; 
  int v18; 
  bool v19; 

  v3 = 0;
  v4 = maxSlices;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v9 = -1;
  v10 = 0.0;
  LODWORD(_XMM3) = 0;
  if ( maxSlices <= 0 )
    return (unsigned int)v9;
  for ( i = results; ; ++i )
  {
    _XMM0 = *(unsigned int *)i;
    if ( *(float *)&_XMM0 > minDist )
    {
      ++v6;
      __asm { vmaxss  xmm3, xmm0, xmm3 }
      if ( !v5 )
      {
        v14 = v4 - 1;
        if ( (_DWORD)v4 != 1 )
        {
          v15 = -1;
          v16 = &results[v4 - 1];
          do
          {
            _XMM0 = *(unsigned int *)v16;
            v18 = v6;
            if ( *(float *)&_XMM0 <= 0.0 )
            {
              if ( *(float *)&_XMM0 < 0.0 )
                goto LABEL_24;
            }
            else
            {
              __asm { vmaxss  xmm3, xmm0, xmm3 }
            }
            ++v6;
            --v16;
            v7 = v15--;
            if ( *(float *)&_XMM0 <= 0.0 )
              v6 = v18;
            --v14;
          }
          while ( v14 );
        }
      }
      goto LABEL_24;
    }
    if ( *(float *)&_XMM0 != 0.0 || v5 == (_DWORD)v4 - 1 && v6 >= v3 )
      break;
LABEL_24:
    if ( ++v5 >= (int)v4 )
      return (unsigned int)v9;
  }
  if ( v6 != (_DWORD)v4 )
  {
    v19 = v6 > v3;
    if ( v6 == v3 )
      v19 = *(float *)&_XMM3 > v10;
    if ( v19 )
    {
      v3 = v6;
      v9 = (v7 + v5) / 2;
      v10 = *(float *)&_XMM3;
      if ( v9 < 0 )
        v9 += v4;
    }
    v7 = v5 + 1;
    v6 = 0;
    LODWORD(_XMM3) = 0;
    goto LABEL_24;
  }
  return 0xFFFFFFFFi64;
}

/*
==============
AIScriptedInterface::FindGoodSuppressSpot
==============
*/
char AIScriptedInterface::FindGoodSuppressSpot(AIScriptedInterface *this, const vec3_t *startOffset)
{
  unsigned int *TargetSentient; 
  ai_scripted_t *m_pAI; 
  float v8; 
  float v9; 
  ai_scripted_t *v11; 
  gentity_s *ent; 
  ai_scripted_t *v13; 
  ai_scripted_t *v14; 
  const sentient_s *v15; 
  ai_scripted_t *v16; 
  ai_scripted_t *v17; 
  int lastEnemySuppressTime; 
  bool PathGoalPos; 
  ai_scripted_t *v20; 
  bool v21; 
  ai_scripted_t *v22; 
  float v23; 
  float v24; 
  float v25; 
  vec3_t outEyePos; 
  vec3_t vEyePosOut; 

  TargetSentient = (unsigned int *)AICommonInterface::GetTargetSentient(this);
  if ( TargetSentient )
  {
    _XMM0 = TargetSentient[12];
    __asm { vminss  xmm1, xmm0, cs:__real@44800000 }
    m_pAI = this->m_pAI;
    v8 = *(float *)(*(_QWORD *)TargetSentient + 304i64) - m_pAI->ent->r.currentOrigin.v[0];
    v9 = *(float *)(*(_QWORD *)TargetSentient + 308i64) - m_pAI->ent->r.currentOrigin.v[1];
    if ( (float)((float)(v9 * v9) + (float)(v8 * v8)) > (float)((float)(*(float *)&_XMM1 + 768.0) * (float)(*(float *)&_XMM1 + 768.0)) )
    {
      m_pAI->bGoodShootPos = 0;
      return 0;
    }
  }
  if ( AIScriptedInterface::NeedRecalculateSuppressSpot(this) )
  {
    v11 = this->m_pAI;
    ent = v11->ent;
    v11->sight.vLastEnemySightPosSelfOrigin.v[0] = v11->ent->r.currentOrigin.v[0];
    v11->sight.vLastEnemySightPosSelfOrigin.v[1] = ent->r.currentOrigin.v[1];
    v11->sight.vLastEnemySightPosSelfOrigin.v[2] = ent->r.currentOrigin.v[2];
    this->m_pAI->sight.bLastEnemySightPosSelfOrigin = 1;
    v13 = this->m_pAI;
    v13->sight.vLastEnemySightPosOld.v[0] = v13->sight.lastEnemySightPos.v[0];
    v13->sight.vLastEnemySightPosOld.v[1] = v13->sight.lastEnemySightPos.v[1];
    v13->sight.vLastEnemySightPosOld.v[2] = v13->sight.lastEnemySightPos.v[2];
    this->m_pAI->sight.bLastEnemySightPosOld = 1;
    v14 = this->m_pAI;
    if ( v14->bSuppressUseLastEnemySightPos )
    {
      v14->vGoodShootPos.v[0] = v14->sight.lastEnemySightPos.v[0];
      v14->vGoodShootPos.v[1] = v14->sight.lastEnemySightPos.v[1];
      v14->vGoodShootPos.v[2] = v14->sight.lastEnemySightPos.v[2];
      return 1;
    }
    v15 = AICommonInterface::GetTargetSentient(this);
    if ( v15 )
    {
      Sentient_GetEyePosition(v15, &vEyePosOut);
      this->m_pAI->vLastEnemySuppressPos = vEyePosOut;
      v16 = this->m_pAI;
      outEyePos = vEyePosOut;
      v16->lastEnemySuppressTime = level.time;
      v17 = this->m_pAI;
    }
    else
    {
      v17 = this->m_pAI;
      lastEnemySuppressTime = v17->lastEnemySuppressTime;
      if ( lastEnemySuppressTime <= 0 || lastEnemySuppressTime + 3000 >= level.time )
      {
        AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
        v17 = this->m_pAI;
        outEyePos.v[0] = (float)(196.0 * v17->orientation.vLookForward.v[0]) + outEyePos.v[0];
        outEyePos.v[1] = (float)(196.0 * v17->orientation.vLookForward.v[1]) + outEyePos.v[1];
        outEyePos.v[2] = (float)(196.0 * v17->orientation.vLookForward.v[2]) + outEyePos.v[2];
      }
      else
      {
        outEyePos = v17->vLastEnemySuppressPos;
      }
    }
    this->m_pAI->bGoodShootPos = this->CalcSuppressSpot(this, startOffset, &outEyePos, -1, &v17->vGoodShootPos);
  }
  else
  {
    PathGoalPos = AIScriptedInterface::GetPathGoalPos(this, &vEyePosOut);
    v20 = this->m_pAI;
    v21 = PathGoalPos;
    v22 = v20;
    if ( !v20->bGoodShootPos )
      return v22->bGoodShootPos;
    if ( !v21 )
      return v22->bGoodShootPos;
    v23 = v20->vGoodShootPos.v[1] - v20->ent->r.currentOrigin.v[1];
    v24 = v20->vGoodShootPos.v[0] - v20->ent->r.currentOrigin.v[0];
    v25 = v20->vGoodShootPos.v[2] - v20->ent->r.currentOrigin.v[2];
    v22 = this->m_pAI;
    if ( (float)((float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25)) >= 1024.0 )
      return v22->bGoodShootPos;
    v20->bGoodShootPos = 0;
  }
  v22 = this->m_pAI;
  return v22->bGoodShootPos;
}

/*
==============
AIScriptedInterface::GetEnemySuppressPos
==============
*/
void AIScriptedInterface::GetEnemySuppressPos(AIScriptedInterface *this, vec3_t *outEnemyEyePos)
{
  const sentient_s *TargetSentient; 
  float v5; 
  ai_scripted_t *m_pAI; 
  int lastEnemySuppressTime; 
  ai_scripted_t *v8; 
  vec3_t vEyePosOut; 

  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( TargetSentient )
  {
    Sentient_GetEyePosition(TargetSentient, &vEyePosOut);
    this->m_pAI->vLastEnemySuppressPos = vEyePosOut;
    v5 = vEyePosOut.v[1];
    outEnemyEyePos->v[0] = vEyePosOut.v[0];
    outEnemyEyePos->v[2] = vEyePosOut.v[2];
    outEnemyEyePos->v[1] = v5;
    this->m_pAI->lastEnemySuppressTime = level.time;
  }
  else
  {
    m_pAI = this->m_pAI;
    lastEnemySuppressTime = m_pAI->lastEnemySuppressTime;
    if ( lastEnemySuppressTime <= 0 || lastEnemySuppressTime + 3000 >= level.time )
    {
      AIScriptedInterface::GetApproxEyePos(this, outEnemyEyePos, 0);
      v8 = this->m_pAI;
      outEnemyEyePos->v[0] = (float)(196.0 * v8->orientation.vLookForward.v[0]) + outEnemyEyePos->v[0];
      outEnemyEyePos->v[1] = (float)(196.0 * v8->orientation.vLookForward.v[1]) + outEnemyEyePos->v[1];
      outEnemyEyePos->v[2] = (float)(196.0 * v8->orientation.vLookForward.v[2]) + outEnemyEyePos->v[2];
    }
    else
    {
      outEnemyEyePos->v[0] = m_pAI->vLastEnemySuppressPos.v[0];
      outEnemyEyePos->v[1] = m_pAI->vLastEnemySuppressPos.v[1];
      outEnemyEyePos->v[2] = m_pAI->vLastEnemySuppressPos.v[2];
    }
  }
}

/*
==============
GetVectorArray
==============
*/
__int64 GetVectorArray(scrContext_t *scrContext, int argIdx, vec3_t *pVecArray, int maxNumVecs)
{
  unsigned int v8; 
  const char *v9; 
  unsigned int Object; 
  int ArraySize; 
  const char *v12; 
  unsigned int FirstSibling; 
  float *v15; 
  VariableType type; 
  const char *v17; 
  VariableUnion u; 
  VariableValue out; 

  if ( !pVecArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 510, ASSERT_TYPE_ASSERT, "(pVecArray)", (const char *)&queryFormat, "pVecArray") )
    __debugbreak();
  if ( maxNumVecs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 511, ASSERT_TYPE_ASSERT, "(maxNumVecs > 0)", (const char *)&queryFormat, "maxNumVecs > 0") )
    __debugbreak();
  v8 = 0;
  if ( Scr_GetPointerType(scrContext, argIdx) != VAR_ARRAY )
  {
    v9 = j_va("arg %d expecting array.", (unsigned int)argIdx);
    Scr_Error(COM_ERR_3811, scrContext, v9);
  }
  Object = Scr_GetObject(scrContext, argIdx);
  ArraySize = GetArraySize(scrContext, Object);
  if ( ArraySize > maxNumVecs )
  {
    v12 = j_va("exceeded max number of points (%d)", (unsigned int)maxNumVecs);
    Scr_Error(COM_ERR_3812, scrContext, v12);
  }
  if ( !ArraySize )
    return 0i64;
  FirstSibling = FindFirstSibling(scrContext, Object);
  if ( FirstSibling )
  {
    v15 = &pVecArray->v[2];
    do
    {
      Scr_EvalVariable_Out(scrContext, FirstSibling, &out);
      type = out.type;
      if ( out.type != VAR_VECTOR )
      {
        v17 = j_va("element %d in array is not a valid vector.", v8);
        Scr_Error(COM_ERR_3813, scrContext, v17);
        type = out.type;
      }
      u = out.u;
      *(v15 - 2) = *out.u.vectorValue;
      *(v15 - 1) = *(float *)(u.scriptCodePosValue + 4);
      *v15 = *(float *)(u.scriptCodePosValue + 8);
      RemoveRefToValue(scrContext, (unsigned __int8)type, u);
      ++v8;
      v15 += 3;
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
    }
    while ( FirstSibling );
  }
  return v8;
}

/*
==============
HasRoomToPlayPeekout
==============
*/
char HasRoomToPlayPeekout(const pathnode_t *pNode, const scr_string_t *dir)
{
  unsigned __int16 totalLinkCount; 
  unsigned __int16 v5; 
  __int64 nodeNum; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  bool v11; 
  vec2_t forward; 
  float v14; 

  pathnode_t::GetForward((pathnode_t *)pNode, &forward);
  totalLinkCount = pNode->constant.totalLinkCount;
  v5 = 0;
  v14 = 0.0;
  if ( !totalLinkCount )
    return 1;
  while ( 1 )
  {
    nodeNum = pNode->constant.Links[v5].nodeNum;
    v7 = pathData.nodes[nodeNum].constant.vLocalOrigin.v[0] - pNode->constant.vLocalOrigin.v[0];
    v8 = pathData.nodes[nodeNum].constant.vLocalOrigin.v[1] - pNode->constant.vLocalOrigin.v[1];
    v9 = pathData.nodes[nodeNum].constant.vLocalOrigin.v[2] - pNode->constant.vLocalOrigin.v[2];
    if ( (float)((float)((float)(v8 * v8) + (float)(v7 * v7)) + (float)(v9 * v9)) < 8836.0 )
    {
      v10 = (float)(forward.v[0] * v8) - (float)(forward.v[1] * v7);
      v11 = v10 < 0.0;
      if ( v10 > 0.0 )
      {
        if ( *dir == scr_const.left )
          return 0;
        v11 = v10 < 0.0;
      }
      if ( v11 && *dir == scr_const.right )
        break;
    }
    if ( ++v5 >= totalLinkCount )
      return 1;
  }
  return 0;
}

/*
==============
AIScriptedInterface::HasSuppressableEnemy
==============
*/
bool AIScriptedInterface::HasSuppressableEnemy(AIScriptedInterface *this)
{
  return AICommonInterface::GetTargetSentient(this) && this->m_pAI->sight.lastEnemySightPosValid && AIScriptedInterface::IsCurrentEnemyValid(this) && (this->m_pAI->bGoodShootPos || AIScriptedInterface::NeedRecalculateSuppressSpot(this));
}

/*
==============
AIScriptedInterface::NeedRecalculateSuppressSpot
==============
*/
char AIScriptedInterface::NeedRecalculateSuppressSpot(AIScriptedInterface *this)
{
  ai_scripted_t *m_pAI; 
  const vec3_t *p_vGoodShootPos; 
  float v4; 
  float v5; 
  float v6; 
  float v7; 
  float v8; 
  vec3_t outEyePos; 
  vec3_t outOrigin; 

  m_pAI = this->m_pAI;
  if ( m_pAI->bGoodShootPos )
  {
    p_vGoodShootPos = &m_pAI->vGoodShootPos;
    if ( !this->GetEquippedWeapon(this)->weaponIdx )
      return 0;
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( !AICommonInterface::SightTrace(this, &outEyePos, p_vGoodShootPos, 2047, NORMAL_FOLIAGE_CHECKS) )
      return 0;
    AIScriptedInterface::GetMuzzlePosApprox(this, &outOrigin);
    if ( !AICommonInterface::SightTrace(this, &outOrigin, p_vGoodShootPos, 2047, NORMAL_FOLIAGE_CHECKS) )
      return 0;
    m_pAI = this->m_pAI;
  }
  if ( m_pAI->sight.bLastEnemySightPosOld )
  {
    v4 = m_pAI->sight.lastEnemySightPos.v[0] - m_pAI->sight.vLastEnemySightPosOld.v[0];
    v5 = m_pAI->sight.lastEnemySightPos.v[1] - m_pAI->sight.vLastEnemySightPosOld.v[1];
    v6 = m_pAI->sight.lastEnemySightPos.v[2] - m_pAI->sight.vLastEnemySightPosOld.v[2];
    if ( (float)((float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6)) <= 256.0 )
    {
      v7 = m_pAI->ent->r.currentOrigin.v[1] - m_pAI->sight.vLastEnemySightPosSelfOrigin.v[1];
      v8 = m_pAI->ent->r.currentOrigin.v[2] - m_pAI->sight.vLastEnemySightPosSelfOrigin.v[2];
      if ( (float)((float)((float)(v7 * v7) + (float)((float)(m_pAI->ent->r.currentOrigin.v[0] - m_pAI->sight.vLastEnemySightPosSelfOrigin.v[0]) * (float)(m_pAI->ent->r.currentOrigin.v[0] - m_pAI->sight.vLastEnemySightPosSelfOrigin.v[0]))) + (float)(v8 * v8)) <= 1024.0 )
        return 0;
    }
  }
  return 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_AIClearGesture
==============
*/
void AIScriptedInterface::OnScrCmd_AIClearGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->animData.gestureIndex = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimTime
==============
*/
void AIScriptedInterface::OnScrCmd_AIGetAnimTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  XAnimTree *v5; 
  scr_string_t ConstString; 
  int Int; 
  scr_string_t AnimsetName; 
  unsigned int v9; 
  const XAnim_s *SubTreeAnims; 
  double Time; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_3912, scrContext, "AnimScripted entities are not supported in this game mode");
  v4 = this->GetEntity(this);
  v5 = this->GetAnimTree(this);
  if ( !v5 )
    Scr_Error(COM_ERR_6352, scrContext, "ent does not have a valid anim tree.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v4->s);
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, &outGraftAnimIndex, &outSubTreeID, NULL);
  }
  else
  {
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v5).index;
    AIScriptedInterface::FixupExtraAnimParams(scrContext, 1u, &outGraftAnimIndex, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  v9 = pOutAnimIndex;
  SubTreeAnims = XAnimGetSubTreeAnims(v5, outSubTreeID);
  if ( !XAnimHasTime(SubTreeAnims, v9) )
    Scr_ParamError(COM_ERR_3913, scrContext, 0, "blended nonsynchronized animation has no concept of time");
  Time = XAnimGetTime(v5, outGraftAnimIndex, outSubTreeID, pOutAnimIndex);
  Scr_AddFloat(scrContext, *(float *)&Time);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimWeight
==============
*/
void AIScriptedInterface::OnScrCmd_AIGetAnimWeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v4; 
  gentity_s *v5; 
  scr_string_t ConstString; 
  int Int; 
  scr_string_t AnimsetName; 
  scr_string_t v9; 
  double Weight; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int pOutGraftNode; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_3911, scrContext, "AnimScripted entities are not supported in this game mode");
  v4 = this->GetAnimTree(this);
  if ( !v4 )
    Scr_Error(COM_ERR_6351, scrContext, "ent does not have a valid anim tree.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    v5 = this->GetEntity(this);
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v5->s);
    outState = NULL;
    v9 = AnimsetName;
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6988, ASSERT_TYPE_ASSERT, "(pState)", (const char *)&queryFormat, "pState") )
      __debugbreak();
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(v9, pOutStateIndex, Int, &pOutAnimIndex, &pOutGraftNode, &outSubTreeID, NULL);
  }
  else
  {
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v4).index;
    AIScriptedInterface::FixupExtraAnimParams(scrContext, 1u, &pOutGraftNode, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  Weight = XAnimGetWeight(v4, pOutGraftNode, outSubTreeID, pOutAnimIndex);
  Scr_AddFloat(scrContext, *(float *)&Weight);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIPlayGesture
==============
*/
void AIScriptedInterface::OnScrCmd_AIPlayGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const XAnimTree *v4; 
  scr_string_t ConstString; 
  __int64 v6; 
  __int64 v7; 
  unsigned __int16 *v8; 
  unsigned __int16 *v9; 
  scr_string_t AnimsetNameByIndex; 
  signed int v11; 
  const XAnim_s *SubTreeAnims; 
  unsigned int ChildAt; 
  XAnimSubTreeID outSubtreeID; 
  scr_anim_t outAnim; 
  scr_anim_t value; 

  if ( Scr_GetNumParam(scrContext) != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7196, ASSERT_TYPE_ASSERT, "(Scr_GetNumParam( scrContext ) == 1)", (const char *)&queryFormat, "Scr_GetNumParam( scrContext ) == 1") )
    __debugbreak();
  v4 = this->GetAnimTree(this);
  if ( !v4 )
    Scr_Error(COM_ERR_6353, scrContext, "ent does not have a valid anim tree.");
  ConstString = Scr_GetConstString(scrContext, 0);
  v6 = tls_index;
  if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v7 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v6) + 272i64);
  v8 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 32i64))(v7, (unsigned int)this->m_pAI->ent->s.number);
  v9 = v8;
  if ( v8 )
  {
    AnimsetNameByIndex = BG_AnimationState_GetAnimsetNameByIndex(*v8);
    v11 = 0;
    if ( BG_Animset_GetAddonAnimFromBlendtree(AnimsetNameByIndex, v9[1], v9[2], ANIMSTATE_GESTURE, (const scr_string_t)scr_const.gesture_knob, (const scr_string_t)scr_const.gesture, &outAnim, NULL) && BG_Animset_GetAddonAnimFromBlendtree(AnimsetNameByIndex, v9[1], v9[2], ANIMSTATE_GESTURE, ConstString, (const scr_string_t)scr_const.gesture, &value, &outSubtreeID) )
    {
      SubTreeAnims = XAnimGetSubTreeAnims(v4, outSubtreeID);
      if ( XAnimGetNumChildren(SubTreeAnims, outAnim.index) > 0 )
      {
        while ( 1 )
        {
          ChildAt = XAnimGetChildAt(SubTreeAnims, outAnim.index, v11);
          if ( value.index == ChildAt )
            break;
          if ( ++v11 >= XAnimGetNumChildren(SubTreeAnims, outAnim.index) )
            return;
        }
        if ( v11 >= 128 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7229, ASSERT_TYPE_ASSERT, "(childIndex < 2 << 6)", (const char *)&queryFormat, "childIndex < 2 << NUM_AI_GESTURE_BITS") )
          __debugbreak();
        this->m_pAI->animData.gestureIndex = v11 + 1;
        Scr_AddAnim(scrContext, value);
      }
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AISuppressAI
==============
*/
void AIScriptedInterface::OnScrCmd_AISuppressAI(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = AIScriptedInterface::AISuppressAI(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_AllowedStances
==============
*/
void AIScriptedInterface::OnScrCmd_AllowedStances(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  signed int v5; 
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 
  ai_scripted_t *m_pAI; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_3892, scrContext, "no stances given in allowedStances()\n");
  v5 = 0;
  for ( this->m_pAI->eAllowedStances = STANCE_BAD; v5 < NumParam; ++v5 )
  {
    ConstString = Scr_GetConstString(scrContext, v5);
    if ( ConstString == scr_const.stand )
    {
      this->m_pAI->eAllowedStances |= 1u;
    }
    else if ( ConstString == scr_const.crouch )
    {
      this->m_pAI->eAllowedStances |= 2u;
    }
    else if ( ConstString == scr_const.prone )
    {
      this->m_pAI->eAllowedStances |= 4u;
    }
    else
    {
      v7 = SL_ConvertToString(ConstString);
      v8 = j_va("invalid stance '%s' in allowedStances()\n", v7);
      Scr_Error(COM_ERR_3893, scrContext, v8);
    }
  }
  m_pAI = this->m_pAI;
  if ( m_pAI->eAllowedStances == STANCE_BAD )
  {
    m_pAI->eAllowedStances = STANCE_ANY;
    Scr_Error(COM_ERR_3894, scrContext, "no allowed stances given");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushCheckPath
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushCheckPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 
  bool v5; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v5 = AIScriptedInterface::Ambush_CheckPathToNode(this, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *AmbushNode; 

  AmbushNode = AIScriptedInterface::Ambush_GetAmbushNode(this);
  if ( AmbushNode )
    Scr_AddPathnode(AmbushNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::Ambush_IsCurrentNodeValid(this);
  Scr_AddBool(scrContext, this->m_pAI->combat.currentAmbushNodeValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_AnimMode
==============
*/
void AIScriptedInterface::OnScrCmd_AnimMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int64 ConstString; 
  const char *v5; 
  const char *v6; 

  ConstString = (unsigned int)Scr_GetConstString(scrContext, 0);
  if ( !this->SetAnimMode(this, (scr_string_t)ConstString) )
  {
    v5 = SL_ConvertToString((scr_string_t)ConstString);
    v6 = j_va("illegal call to animmode(%s)", v5);
    Scr_Error(COM_ERR_3882, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AtDangerousNode
==============
*/
void AIScriptedInterface::OnScrCmd_AtDangerousNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  unsigned __int64 eTeam; 
  const bitarray<224> *AllCombatTeamFlags; 
  const bitarray<224> *v7; 
  int IsReallyDangerousNode; 
  __int64 v9; 

  v4 = this->GetSentient(this);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3877, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  if ( !AIScriptedInterface::AtClaimNode(this) )
    goto LABEL_16;
  eTeam = (unsigned int)v4->eTeam;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    AllCombatTeamFlags = Com_TeamsSP_GetAllCombatTeamFlags();
  else
    AllCombatTeamFlags = Com_TeamsMP_GetAllTeamFlags();
  v7 = AllCombatTeamFlags;
  if ( (unsigned int)eTeam >= 0xE0 )
  {
    LODWORD(v9) = eTeam;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, 224) )
      __debugbreak();
  }
  if ( ((0x80000000 >> (eTeam & 0x1F)) & v7->array[eTeam >> 5]) != 0 )
  {
    if ( !v4->pClaimedNode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3881, ASSERT_TYPE_ASSERT, "(sentient->pClaimedNode)", (const char *)&queryFormat, "sentient->pClaimedNode") )
      __debugbreak();
    IsReallyDangerousNode = Path_ActorIsReallyDangerousNode(v4->pClaimedNode, v4->eTeam);
  }
  else
  {
LABEL_16:
    IsReallyDangerousNode = 0;
  }
  Scr_AddBool(scrContext, IsReallyDangerousNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_BTGoalValid
==============
*/
void AIScriptedInterface::OnScrCmd_BTGoalValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsBTGoalValid; 

  IsBTGoalValid = AIScriptedInterface::IsBTGoalValid(this);
  Scr_AddBool(scrContext, IsBTGoalValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim
==============
*/
void AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  ai_scripted_t *m_pAI; 
  scr_string_t AnimsetName; 
  scr_string_t stateName; 
  double Float; 
  const char *String; 
  const char *suffix; 
  const char *prefix; 
  float v14; 
  scrContext_t *v15; 
  bool v16; 
  int value; 
  unsigned int outAngleIndexCount; 
  int outAngleIndex[2]; 
  scr_anim_t outAnim; 
  vec3_t v21; 
  vec3_t v22; 
  vec3_t v23; 
  vec3_t vectorValue; 
  vec3_t vec; 
  vec3_t angles; 
  int outAngleIndices[4]; 

  v4 = this->GetEntity(this);
  m_pAI = this->m_pAI;
  *(_QWORD *)outAngleIndex = v4;
  AnimsetName = BG_AnimationState_GetAnimsetName(&m_pAI->ent->s);
  stateName = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v23);
  Float = Scr_GetFloat(scrContext, 3u);
  String = Scr_GetString(scrContext, 4u);
  suffix = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetType(scrContext, 5u) )
    prefix = Scr_GetString(scrContext, 5u);
  else
    prefix = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetType(scrContext, 6u) )
    suffix = Scr_GetString(scrContext, 6u);
  vec.v[0] = v23.v[0] - vectorValue.v[0];
  vec.v[2] = v23.v[2] - vectorValue.v[2];
  vec.v[1] = v23.v[1] - vectorValue.v[1];
  vectoangles(&vec, &angles);
  _XMM1 = 0i64;
  __asm { vroundss xmm3, xmm1, xmm2, 1 }
  v14 = (float)((float)((float)(angles.v[1] - *(float *)(*(_QWORD *)outAngleIndex + 320i64)) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
  outAngleIndexCount = 0;
  value = -1;
  G_GetAngleIndices(v14, *(const float *)&Float, outAngleIndices, &outAngleIndexCount);
  if ( AIScriptedInterface::CalculateSharpTurnExitAnim(this, outAngleIndices, outAngleIndexCount, AnimsetName, stateName, prefix, suffix, &outAnim, outAngleIndex, &value) )
  {
    Scr_MakeArray(scrContext);
    v15 = scrContext;
  }
  else
  {
    v21 = v23;
    v22 = vectorValue;
    v16 = AIScriptedInterface::CalculateSharpTurnAnim(this, outAngleIndexCount, outAngleIndices, AnimsetName, stateName, &v22, &v21, String, prefix, suffix, &outAnim, outAngleIndex, &value);
    Scr_MakeArray(scrContext);
    v15 = scrContext;
    if ( !v16 )
    {
      Scr_AddUndefined(scrContext);
      Scr_AddArray(scrContext);
      Scr_AddUndefined(scrContext);
      goto LABEL_11;
    }
  }
  Scr_AddInt(v15, value);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, outAngleIndex[0]);
LABEL_11:
  Scr_AddArray(scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcStopData
==============
*/
void AIScriptedInterface::OnScrCmd_CalcStopData(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  bool v5; 
  int Int; 
  bool v7; 
  float v8; 
  vec3_t *p_currentAngles; 
  double Float; 
  scr_string_t ConstString; 
  __int64 v12; 
  __int64 v13; 
  double v14; 
  const char *footPrefix; 
  const char *optionalPrefix; 
  scr_string_t v17; 
  const char *speedString; 
  VariableType Type; 
  bool bApproachDirValid; 
  float v21; 
  double v22; 
  float v23; 
  double v24; 
  scr_string_t endNotetrack; 
  scr_string_t startNotetrack; 
  scr_string_t nodeType; 
  scr_string_t stateName; 
  __int64 v29; 
  vec3_t vectorValue; 
  vec3_t animTargetAngles; 
  vec3_t v32; 
  vec3_t angles; 
  vec3_t v34; 
  vec3_t vec; 
  vec3_t v36; 
  vec2_t v37; 
  float v38; 
  vec3_t vFinalGoal; 
  vec3_t codeApproachDir; 
  int v41[5]; 
  bfx::AreaHandle v42; 
  bfx::LinkHandle v43; 
  AIAnimStopData pStopData; 

  v29 = -2i64;
  v4 = this->GetEntity(this);
  Scr_GetVector(scrContext, 0, &vectorValue);
  v5 = Scr_GetType(scrContext, 2u) != VAR_UNDEFINED;
  Int = Scr_GetInt(scrContext, 4u);
  v7 = Int != 0;
  if ( Int )
    Scr_GetVector(scrContext, 1u, &v34);
  if ( v5 )
    Scr_GetVector(scrContext, 2u, &v36);
  vec.v[0] = vectorValue.v[0] - v4->r.currentOrigin.v[0];
  vec.v[1] = vectorValue.v[1] - v4->r.currentOrigin.v[1];
  vec.v[2] = vectorValue.v[2] - v4->r.currentOrigin.v[2];
  if ( v5 )
  {
    v8 = v36.v[1];
    p_currentAngles = &v36;
  }
  else if ( v7 )
  {
    v8 = v34.v[1];
    p_currentAngles = &v34;
  }
  else
  {
    vectoangles(&vec, &angles);
    v8 = angles.v[1];
    p_currentAngles = &v4->r.currentAngles;
  }
  DebugArrivalPosition(v4, &vectorValue, p_currentAngles);
  angles.v[0] = 0.0;
  angles.v[1] = v8;
  angles.v[2] = 0.0;
  stateName = Scr_GetConstString(scrContext, 5u);
  if ( v7 )
  {
    vFinalGoal = vectorValue;
    v32 = v34;
    animTargetAngles.v[0] = 0.0;
    animTargetAngles.v[2] = 0.0;
    Float = Scr_GetFloat(scrContext, 6u);
    animTargetAngles.v[1] = *(float *)&Float;
  }
  else
  {
    AICommonInterface::GetPathFinalGoal(this, &vFinalGoal);
    vectoangles(&vec, &v32);
    animTargetAngles = v32;
  }
  if ( v5 )
  {
    v32 = v36;
    animTargetAngles = v36;
  }
  ConstString = Scr_GetConstString(scrContext, 0xBu);
  nodeType = ConstString;
  if ( (ConstString == scr_const.exposed_cc || ConstString == scr_const.exposed_crouch_cc) && !v5 && !v7 )
  {
    this->m_pAI->pNavigator->GetPathDistToGoal(this->m_pAI->pNavigator);
    bfx::AreaHandle::AreaHandle(&v42);
    bfx::LinkHandle::LinkHandle(&v43);
    LOBYTE(v12) = 1;
    ((void (__fastcall *)(AINavigator *, __int64, __int64, int *, _BYTE))this->m_pAI->pNavigator->GetPosAlongPath)(this->m_pAI->pNavigator, v13, v12, v41, 0);
    v37.v[0] = vectorValue.v[0] - *(float *)v41;
    v37.v[1] = vectorValue.v[1] - *(float *)&v41[1];
    v38 = vectorValue.v[2] - *(float *)&v41[2];
    v14 = vectoyaw(&v37);
    animTargetAngles.v[0] = 0.0;
    animTargetAngles.v[1] = *(float *)&v14;
    animTargetAngles.v[2] = 0.0;
    v32.v[0] = 0.0;
    v32.v[1] = *(float *)&v14;
    v32.v[2] = 0.0;
    bfx::LinkHandle::~LinkHandle(&v43);
    bfx::AreaHandle::~AreaHandle(&v42);
  }
  footPrefix = Scr_GetString(scrContext, 7u);
  optionalPrefix = Scr_GetString(scrContext, 8u);
  v17 = Scr_GetConstString(scrContext, 8u);
  speedString = NULL;
  if ( Scr_GetConstString(scrContext, 7u) == v17 )
    optionalPrefix = NULL;
  Type = Scr_GetType(scrContext, 3u);
  bApproachDirValid = Type != VAR_UNDEFINED;
  if ( Type )
    Scr_GetVector(scrContext, 3u, &codeApproachDir);
  v21 = FLOAT_N1_0;
  if ( Scr_GetType(scrContext, 9u) )
  {
    v22 = Scr_GetFloat(scrContext, 9u);
    v23 = *(float *)&v22;
  }
  else
  {
    v23 = FLOAT_N1_0;
  }
  if ( Scr_GetType(scrContext, 0xAu) )
  {
    v24 = Scr_GetFloat(scrContext, 0xAu);
    v21 = *(float *)&v24;
  }
  startNotetrack = 0;
  endNotetrack = 0;
  if ( Scr_GetType(scrContext, 0xCu) )
    startNotetrack = Scr_GetConstString(scrContext, 0xCu);
  if ( Scr_GetType(scrContext, 0xDu) )
    endNotetrack = Scr_GetConstString(scrContext, 0xDu);
  if ( Scr_GetNumParam(scrContext) > 0xE && Scr_GetType(scrContext, 0xEu) )
    speedString = Scr_GetString(scrContext, 0xEu);
  if ( AIScriptedInterface::CalcStopData(this, &vectorValue, &angles, &animTargetAngles, &codeApproachDir, bApproachDirValid, &stateName, footPrefix, optionalPrefix, v23, v21, &nodeType, &startNotetrack, &endNotetrack, speedString, &pStopData) )
    PushStopDataToScript(scrContext, v4, &pStopData);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanAimWhileMoving
==============
*/
void AIScriptedInterface::OnScrCmd_CanAimWhileMoving(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool CanAimWhileMoving; 

  CanAimWhileMoving = AIScriptedInterface::CanAimWhileMoving(this);
  Scr_AddBool(scrContext, CanAimWhileMoving);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove
==============
*/
void AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool CanBoundingOverwatchMove; 

  CanBoundingOverwatchMove = AIScriptedInterface::CanBoundingOverwatchMove(this);
  Scr_AddBool(scrContext, CanBoundingOverwatchMove);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanDoRetreat
==============
*/
void AIScriptedInterface::OnScrCmd_CanDoRetreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->1 = ($100FDAAC881F89A16E895B934846A44F)(this->m_pAI->postGoldPadding & 0xFD | (Scr_GetInt(scrContext, 0) != 0 ? 2 : 0));
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSee
==============
*/
void AIScriptedInterface::OnScrCmd_CanSee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 
  bool v6; 

  Int = -1;
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3500, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  v6 = this->CanSee(this, Entity, Int);
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSeePeripheral
==============
*/
void AIScriptedInterface::OnScrCmd_CanSeePeripheral(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 
  bool v6; 

  Int = -1;
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3528, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( !Entity->sentient )
    Scr_Error(COM_ERR_3883, scrContext, "Sorry, CanSeePeripheral only works with sentient targets.");
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  v6 = this->CanSeePeripheral(this, Entity, Int);
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShoot
==============
*/
void AIScriptedInterface::OnScrCmd_CanShoot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  bool v5; 
  bool CanShoot; 
  vec3_t muzzleOffset; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    Scr_GetVector(scrContext, 1u, &muzzleOffset);
  }
  else
  {
    muzzleOffset.v[0] = 0.0;
    muzzleOffset.v[1] = 0.0;
    muzzleOffset.v[2] = 0.0;
  }
  v5 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v5 = Scr_GetInt(scrContext, 2u) != 0;
  CanShoot = AIScriptedInterface::CanShoot(this, &vectorValue, &muzzleOffset, v5);
  Scr_AddInt(scrContext, CanShoot);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShootEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_CanShootEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  gentity_s *v5; 
  const char *v6; 
  int NumParam; 
  int Int; 
  bool v9; 
  bool v10; 
  bool CanShootEnemy; 

  if ( !this->GetEntity(this) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2753, ASSERT_TYPE_ASSERT, "(GetEntity())", (const char *)&queryFormat, "GetEntity()") )
    __debugbreak();
  if ( !this->GetSentient(this) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2754, ASSERT_TYPE_ASSERT, "(GetSentient())", (const char *)&queryFormat, "GetSentient()") )
    __debugbreak();
  v4 = this->GetSentient(this);
  if ( !EntHandle::isDefined(&v4->targetEnt) )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("CanShootEnemy() called with no enemy set for entity %d", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3861, scrContext, v6);
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 250;
  v9 = 0;
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
    v9 = Scr_GetInt(scrContext, 1u) != 0;
  v10 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v10 = Scr_GetInt(scrContext, 2u) != 0;
  CanShootEnemy = AIScriptedInterface::CanShootEnemy(this, Int, v9, v10);
  Scr_AddInt(scrContext, CanShootEnemy);
}

/*
==============
AIScriptedInterface::OnScrCmd_ChooseArrivalType
==============
*/
void AIScriptedInterface::OnScrCmd_ChooseArrivalType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  unsigned int Object; 
  scr_string_t cover_crouch_cc; 
  ai_stance_e v8; 
  scrContext_t *v9; 
  ai_stance_e v10; 
  ai_stance_e v11; 
  vec3_t origin; 

  Sys_ProfBeginNamedEvent(0xFF808080, "ScrCmd_ChooseArrivalType");
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  Object = Scr_GetObject(scrContext, 0);
  AddRefToObject(scrContext, Object);
  Scr_ClearOutParams(scrContext);
  Scr_GetObjectOrigin(scrContext, Object, &origin);
  RemoveRefToObject(scrContext, Object);
  cover_crouch_cc = scr_const.cover_crouch_cc;
  if ( ConstString == scr_const.cover_crouch_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.conceal_crouch_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.cover_crouch_window_cc )
    goto LABEL_21;
  cover_crouch_cc = scr_const.cover_stand_cc;
  if ( ConstString == scr_const.cover_stand_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.conceal_stand_cc )
    goto LABEL_21;
  cover_crouch_cc = scr_const.cover_prone_cc;
  if ( ConstString == scr_const.cover_prone_cc || ConstString == scr_const.conceal_prone_cc )
    goto LABEL_21;
  if ( ConstString != scr_const.path_cc && ConstString != scr_const.exposed_cc )
  {
    if ( ConstString == scr_const.cover_right_cc )
    {
      v8 = ChooseArrivalPose_0(this, Pathnode, &origin);
      v9 = scrContext;
      if ( v8 == STANCE_CROUCH )
        cover_crouch_cc = scr_const.cover_right_crouch_cc;
      else
        cover_crouch_cc = scr_const.cover_right_cc;
      goto LABEL_22;
    }
    if ( ConstString == scr_const.cover_left_cc )
    {
      v10 = ChooseArrivalPose_0(this, Pathnode, &origin);
      v9 = scrContext;
      if ( v10 == STANCE_CROUCH )
        cover_crouch_cc = scr_const.cover_left_crouch_cc;
      else
        cover_crouch_cc = scr_const.cover_left_cc;
      goto LABEL_22;
    }
    cover_crouch_cc = ConstString;
LABEL_21:
    v9 = scrContext;
    goto LABEL_22;
  }
  v11 = ChooseArrivalPose_0(this, Pathnode, &origin);
  if ( v11 == STANCE_PRONE )
  {
    cover_crouch_cc = scr_const.cover_prone_cc;
    goto LABEL_21;
  }
  v9 = scrContext;
  if ( v11 == STANCE_CROUCH )
    cover_crouch_cc = scr_const.exposed_crouch_cc;
  else
    cover_crouch_cc = scr_const.exposed_cc;
LABEL_22:
  Scr_AddConstString(v9, cover_crouch_cc);
  Sys_ProfEndNamedEvent();
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBTGoal
==============
*/
void AIScriptedInterface::OnScrCmd_ClearBTGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1215, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  AIScriptedInterface::ClearBTGoal(this, (ai_bt_goal_priority_t)Int);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBlackboard
==============
*/
void AIScriptedInterface::OnScrCmd_ClearBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int16 *v3; 

  v3 = (__int16 *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetEntity)(this, scrContext);
  Scr_ClearBlackboard(*v3);
  this->InitBlackboard(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->script_desiredSpeedEnabled = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDoorOpen
==============
*/
void AIScriptedInterface::OnScrCmd_ClearDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->animData.doorIndex = 0;
  this->m_pAI->animData.doorSpeedIndex = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_ClearEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v3; 
  sentient_s *TargetSentient; 
  gentity_s *v5; 

  v3 = (sentient_s *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetSentient)(this, scrContext);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4077, ASSERT_TYPE_ASSERT, "(pSentient)", (const char *)&queryFormat, "pSentient") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( TargetSentient )
  {
    if ( !this->m_pAI->sentientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4083, ASSERT_TYPE_ASSERT, "( m_pAI->sentientInfo )", (const char *)&queryFormat, "m_pAI->sentientInfo") )
      __debugbreak();
    this->m_pAI->sentientInfo[TargetSentient - level.sentients].lastKnownPosTime = 0;
  }
  if ( EntHandle::isDefined(&v3->scriptTargetEnt) )
  {
    v5 = EntHandle::ent(&v3->scriptTargetEnt);
    if ( AICommonInterface::GetTargetEntity(this) == v5 )
    {
      EntHandle::setEnt(&v3->scriptTargetEnt, NULL);
      v3->scriptTargetHasTagEye = 0;
    }
  }
  Sentient_SetEnemy(v3, NULL, 1, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEntityTarget
==============
*/
void AIScriptedInterface::OnScrCmd_ClearEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v3; 
  gentity_s *v4; 

  v3 = (sentient_s *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetSentient)(this, scrContext);
  if ( EntHandle::isDefined(&v3->scriptTargetEnt) )
  {
    v4 = EntHandle::ent(&v3->scriptTargetEnt);
    if ( AICommonInterface::GetTargetEntity(this) == v4 )
      Sentient_SetEnemy(v3, NULL, 1, 1);
  }
  EntHandle::setEnt(&v3->scriptTargetEnt, NULL);
  v3->scriptTargetHasTagEye = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  EntHandle::setEnt(&this->m_pAI->fixedNodeSafeVolume, NULL);
  this->m_pAI->fixedNodeSafeVolumeRadiusSq = 0.0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ClearGoalVolume(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  bool v5; 
  unsigned int v6; 
  unsigned int v7; 
  scr_string_t ConstString; 
  ArcOverridePriority v9; 

  v4 = 0;
  v5 = 0;
  v6 = Scr_GetNumParam(scrContext) - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 != 1 )
      {
        Scr_Error(COM_ERR_6529, scrContext, "Invalid parameter count to setoverridearchetype");
        return;
      }
      v5 = Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
    }
    v4 = Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = AI_StringToArcOverridePriority(ConstString);
  if ( v9 == ARC_PRIORITY_COUNT )
    Scr_Error(COM_ERR_6530, scrContext, "invalid priority string");
  else
    AIScriptedInterface::ClearOverrideArchetype(this, v9, v4, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPitchOrient
==============
*/
void AIScriptedInterface::OnScrCmd_ClearPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ProneInfo.prone = 0;
  this->m_pAI->ProneInfo.orientPitch = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPotentialThreat
==============
*/
void AIScriptedInterface::OnScrCmd_ClearPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( !this->m_pAI || Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_3888, scrContext, "illegal call to ClearPotentialThreat()");
  if ( this->Is3D(this) )
    Scr_Error(COM_ERR_3889, scrContext, "3D actors cannot use ClearPotentialThreat()");
  AIScriptedInterface::ClearPotentialThreat(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_CodeMoveRequested
==============
*/
void AIScriptedInterface::OnScrCmd_CodeMoveRequested(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = this->IsCodeMoveRequested(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  AIScriptedInterface::ConstrainToScriptGoalRadius(this, &vectorValue);
  Scr_AddVector(scrContext, vectorValue.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeapon
==============
*/
void AIScriptedInterface::OnScrCmd_DropWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int128 v2; 
  __int128 v3; 
  scr_string_t ConstString; 
  double Float; 
  float v8; 
  scr_string_t tag_weapon_left; 
  ai_scripted_t *v10; 
  ActorDelayedWeaponDrop *weapDrops; 
  float *p_speedScaleMultiplier; 
  gentity_s *v13; 
  gentity_s *v14; 
  ai_scripted_t *m_pAI; 
  const dvar_t *v16; 
  ai_scripted_t *v20; 
  float v21; 
  __int128 v22; 
  float v23; 
  float v24; 
  unsigned __int16 weaponIdx; 
  __int64 v29; 
  __int64 v30; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  tmat43_t<vec3_t> matrix; 
  __int128 v34; 
  __int128 v35; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !outWeapon.weaponIdx )
    return;
  ConstString = Scr_GetConstString(scrContext, 1u);
  Float = Scr_GetFloat(scrContext, 2u);
  v8 = *(float *)&Float;
  if ( ConstString == scr_const.left )
  {
    tag_weapon_left = scr_const.tag_weapon_left;
  }
  else if ( ConstString == scr_const.right )
  {
    tag_weapon_left = scr_const.tag_weapon_right;
  }
  else if ( ConstString == scr_const.chest )
  {
    tag_weapon_left = scr_const.tag_weapon_chest;
  }
  else if ( ConstString == scr_const.back )
  {
    tag_weapon_left = scr_const.tag_stowed_back;
  }
  else
  {
    if ( ConstString != scr_const.thigh )
    {
      tag_weapon_left = 0;
      goto LABEL_20;
    }
    tag_weapon_left = scr_const.tag_stowed_thigh;
  }
  if ( !tag_weapon_left || BGMovingPlatforms::IsMovingPlatform(this->m_pAI->Physics.groundEntNum) || (v10 = this->m_pAI, weapDrops = v10->weapDrops, p_speedScaleMultiplier = &v10->speedScaleMultiplier, weapDrops == (ActorDelayedWeaponDrop *)p_speedScaleMultiplier) )
  {
LABEL_20:
    G_Items_GetStateFromTag(this->m_pAI->ent, tag_weapon_left, NULL, &matrix, 0);
    v13 = G_Items_DropWeapon(this->m_pAI->ent, &outWeapon, 1, 1, &matrix);
    v14 = v13;
    if ( v13 )
    {
      m_pAI = this->m_pAI;
      v35 = v2;
      G_Items_SetStateFromTag(m_pAI->ent, tag_weapon_left, v13, 0);
      if ( *(float *)&Float == 0.0 )
      {
        *(_QWORD *)v14->s.lerp.pos.trDelta.v = 0i64;
        v14->s.lerp.pos.trDelta.v[2] = 0.0;
      }
      else
      {
        v16 = DVARFLT_actorDropItemMaxVelocity;
        v34 = v3;
        if ( !DVARFLT_actorDropItemMaxVelocity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "actorDropItemMaxVelocity") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v16);
        _XMM0 = v16->current.unsignedInt;
        if ( v8 < 0.0 )
        {
          _XMM0 = _XMM0 ^ _xmm;
          __asm { vmaxss  xmm8, xmm0, xmm6 }
        }
        else
        {
          __asm { vminss  xmm8, xmm0, xmm6 }
        }
        v20 = this->m_pAI;
        v22 = LODWORD(v14->r.currentOrigin.v[1]);
        v21 = v14->r.currentOrigin.v[1] - v20->ent->r.currentOrigin.v[1];
        v23 = v14->r.currentOrigin.v[0] - v20->ent->r.currentOrigin.v[0];
        v24 = (float)(v14->r.currentOrigin.v[2] - (float)(v20->ent->r.box.halfSize.v[2] + v20->ent->r.currentOrigin.v[2])) + 2.0;
        *(float *)&v22 = fsqrt((float)((float)(v21 * v21) + (float)(v23 * v23)) + (float)(v24 * v24));
        _XMM3 = v22;
        __asm
        {
          vcmpless xmm0, xmm3, cs:__real@80000000
          vblendvps xmm0, xmm3, xmm1, xmm0
        }
        v14->s.lerp.pos.trDelta.v[0] = (float)(v23 * (float)(1.0 / *(float *)&_XMM0)) * *(float *)&_XMM8;
        v14->s.lerp.pos.trDelta.v[2] = (float)(v24 * (float)(1.0 / *(float *)&_XMM0)) * *(float *)&_XMM8;
        v14->s.lerp.pos.trDelta.v[1] = (float)(v21 * (float)(1.0 / *(float *)&_XMM0)) * *(float *)&_XMM8;
      }
      v14->s.lerp.pos.trTime = level.time;
      if ( ((LODWORD(v14->s.lerp.pos.trDelta.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(v14->s.lerp.pos.trDelta.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(v14->s.lerp.pos.trDelta.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5370, ASSERT_TYPE_SANITY, "( !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] )") )
        __debugbreak();
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v30) = bg_lastParsedWeaponIndex;
        LODWORD(v29) = outWeapon.weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v29, v30) )
          __debugbreak();
      }
      if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( !GMovingPlatformEntityTracking::DropItem(&v14->movingPlatformTrack, this->m_pAI->Physics.groundEntNum) )
        G_Items_EnablePhysics(v14);
      GScr_AddEntity(v14);
      GScr_Notify(this->m_pAI->ent, scr_const.weapon_dropped, 1u);
    }
    return;
  }
  while ( weapDrops->state )
  {
    if ( ++weapDrops == (ActorDelayedWeaponDrop *)p_speedScaleMultiplier )
      goto LABEL_20;
  }
  weapDrops->weapon = outWeapon;
  weapDrops->tagName = tag_weapon_left;
  weapDrops->state = ACTOR_WEAP_DROP_GRAB_INITIAL_VALUE;
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity
==============
*/
void AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t tag_weapon_left; 
  gentity_s *v6; 
  gentity_s *v7; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  tmat43_t<vec3_t> matrix; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    ConstString = Scr_GetConstString(scrContext, 1u);
    if ( ConstString == scr_const.left )
    {
      tag_weapon_left = scr_const.tag_weapon_left;
    }
    else if ( ConstString == scr_const.right )
    {
      tag_weapon_left = scr_const.tag_weapon_right;
    }
    else if ( ConstString == scr_const.chest )
    {
      tag_weapon_left = scr_const.tag_weapon_chest;
    }
    else
    {
      tag_weapon_left = 0;
      if ( ConstString == scr_const.back )
        tag_weapon_left = scr_const.tag_stowed_back;
    }
    G_Items_GetStateFromTag(this->m_pAI->ent, tag_weapon_left, NULL, &matrix, 0);
    v6 = G_Items_DropWeapon(this->m_pAI->ent, &outWeapon, 1, 1, &matrix);
    v7 = v6;
    if ( v6 )
    {
      G_Items_SetStateFromTag(this->m_pAI->ent, tag_weapon_left, v6, 0);
      *(_QWORD *)v7->s.lerp.pos.trDelta.v = 0i64;
      v7->s.lerp.pos.trDelta.v[2] = 0.0;
      v7->s.lerp.pos.trTime = level.time;
      if ( ((LODWORD(v7->s.lerp.pos.trDelta.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(v7->s.lerp.pos.trDelta.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(v7->s.lerp.pos.trDelta.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5440, ASSERT_TYPE_SANITY, "( !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] )") )
        __debugbreak();
      BG_WeaponDef(&outWeapon, 0);
      if ( !GMovingPlatformEntityTracking::DropItem(&v7->movingPlatformTrack, this->m_pAI->Physics.groundEntNum) )
        G_Items_EnablePhysics(v7);
      GScr_AddEntity(v7);
      GScr_Notify(this->m_pAI->ent, scr_const.weapon_dropped, 1u);
    }
  }
}

/*
==============
AICommonInterface::OnScrCmd_EnableTeamwalking
==============
*/
void AICommonInterface::OnScrCmd_EnableTeamwalking(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  bool v7; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("EnableTeamwalking: Entity %d does not have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3833, scrContext, v6);
  }
  v7 = 1;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v7 = Scr_GetInt(scrContext, 0) != 0;
  Navigator->EnableTeamWalking(Navigator, v7);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTraversals
==============
*/
void AICommonInterface::OnScrCmd_EnableTraversals(AICommonInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  ai_common_t *m_pAI; 
  const char *v6; 
  unsigned int v7; 
  unsigned int i; 
  scr_string_t ConstLowercaseString; 
  const char **v10; 
  char v11; 
  gentity_s *ent; 
  ai_common_t *v13; 
  AIWrapper v14; 

  v4 = 1;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  m_pAI = this->m_pAI;
  if ( !m_pAI->pNavigator )
  {
    v6 = j_va("EnableTraversals: AI %d does not have a valid navigator.", (unsigned int)m_pAI->ent->s.number);
    Scr_Error(COM_ERR_3862, scrContext, v6);
    m_pAI = this->m_pAI;
  }
  if ( v4 )
  {
    if ( SV_BotIsBotEnt(m_pAI->ent) )
    {
      this->m_pAI->pNavigator->SetLinkUsageFlags(this->m_pAI->pNavigator, 1792u);
    }
    else
    {
      v7 = 0;
      for ( i = 1; Scr_GetNumParam(scrContext) > i; ++i )
      {
        ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, i);
        v10 = g_AILinkUsageNames;
        v11 = 0;
        while ( SL_FindLowercaseString(*v10) != ConstLowercaseString )
        {
          ++v11;
          if ( (__int64)++v10 >= (__int64)&unk_147926BF0 )
            goto LABEL_16;
        }
        v7 |= 1 << v11;
LABEL_16:
        ;
      }
      ent = this->m_pAI->ent;
      AIActorInterface::AIActorInterface(&v14.m_actorInterface);
      AIAgentInterface::AIAgentInterface(&v14.m_newAgentInterface);
      v14.m_pAI = NULL;
      v14.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      AIWrapper::Setup(&v14, ent);
      if ( v7 )
      {
        Nav_SetLinkUsageFlags(this->m_pAI->pNavigator, v7);
      }
      else if ( v14.m_pAI )
      {
        v13 = v14.m_pAI->GetAI(v14.m_pAI);
        Nav_SetLinkUsageFlagsForUnitType(this->m_pAI->pNavigator, LODWORD(v13[6].sight.fovDotPeriph));
      }
      else
      {
        Scr_Error(COM_ERR_3863, scrContext, "EnableTraversals: improper usageflag set.");
      }
    }
  }
  else
  {
    m_pAI->pNavigator->SetLinkUsageFlags(m_pAI->pNavigator, 0);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverList
==============
*/
void AIScriptedInterface::OnScrCmd_FindBestCoverList(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  bool searchCenteredOnAI; 
  __int64 v6; 
  __int64 BestCoverList; 
  float outBestScore[4]; 
  CoverNodeMetricParams metricParams; 
  pathnode_t *bestNodes[256]; 

  AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
  v4 = this->GetSentient(this);
  if ( v4 && v4->eTeam == TEAM_FIVE && Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    Scr_Error(COM_ERR_3838, scrContext, "FindBestCoverList: Called on a dead actor!");
  searchCenteredOnAI = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    searchCenteredOnAI = Scr_GetInt(scrContext, 0) != 0;
  v6 = 0i64;
  BestCoverList = AIScriptedInterface::Cover_FindBestCoverList(this, bestNodes, 256, this->m_pAI->combat.combatMode, searchCenteredOnAI, (scr_string_t)0, &metricParams, outBestScore);
  Scr_MakeArray(scrContext);
  if ( BestCoverList > 0 )
  {
    do
    {
      Scr_AddPathnode(bestNodes[v6]);
      Scr_AddArray(scrContext);
      ++v6;
    }
    while ( v6 < BestCoverList );
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindBestCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  bool v5; 
  bool v6; 
  scr_string_t ConstString; 
  const pathnode_t *BestCover; 
  float outBestScore[4]; 
  CoverNodeMetricParams metricParams; 

  v4 = this->GetSentient(this);
  if ( v4 && v4->eTeam == TEAM_FIVE && Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    Scr_Error(COM_ERR_3837, scrContext, "FindBestCoverNode: Called on a dead actor!");
  v5 = 0;
  v6 = 0;
  ConstString = 0;
  AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_STRING )
    ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) == VAR_INTEGER )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 2u, &metricParams.lastKnownEnemyOrigin);
    metricParams.lastKnownValid = 1;
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
    v6 = Scr_GetInt(scrContext, 3u) != 0;
  BestCover = AIScriptedInterface::Cover_FindBestCover(this, ConstString, v5, v6, &metricParams, outBestScore);
  if ( BestCover )
    Scr_AddPathnode(BestCover);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::Cover_FindCoverNode(this, this->m_pAI->combat.combatMode);
}

/*
==============
AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/
void AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  gentity_s *Entity; 
  vec3_t vectorValue; 
  vec3_t value; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("FindLastPointOnPathWithinVolume: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3828, scrContext, v6);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  if ( Navigator->FindLastPointOnPathWithinRegion(Navigator, &vectorValue, Entity, &value) )
    Scr_AddVector(scrContext, value.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindNearbyCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  gentity_s *v4; 
  const pathnode_t *v5; 

  Float = Scr_GetFloat(scrContext, 0);
  v4 = this->GetEntity(this);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2191, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  v5 = AIScriptedInterface::Cover_FindNearByCoverNode(this, &v4->r.currentOrigin, *(float *)&Float, this->m_pAI->combat.combatMode);
  if ( v5 )
    Scr_AddPathnode(v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_FindOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  ArcOverridePriority v5; 
  scr_string_t OverrideArchetype; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = AI_StringToArcOverridePriority(ConstString);
  if ( v5 == ARC_PRIORITY_COUNT )
  {
    Scr_Error(COM_ERR_6531, scrContext, "invalid priority string");
  }
  else
  {
    OverrideArchetype = AIScriptedInterface::FindOverrideArchetype(this, v5);
    if ( OverrideArchetype )
      Scr_AddConstString(scrContext, OverrideArchetype);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindReacquireDirectPath
==============
*/
void AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_GetInt(scrContext, 0);
  AIScriptedInterface::Behave_FindReacquireDirectPath(this, 1);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindShuffleCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *ShuffleCoverNode; 

  ShuffleCoverNode = AIScriptedInterface::Cover_FindShuffleCoverNode(this);
  if ( ShuffleCoverNode )
    Scr_AddPathnode(ShuffleCoverNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishCoverArrival
==============
*/
void AIScriptedInterface::OnScrCmd_FinishCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arriving = 0;
  this->m_pAI->pushable = 1;
  this->m_pAI->bUseGoalWeight = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishTraverse
==============
*/
void AIScriptedInterface::OnScrCmd_FinishTraverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( AIScriptedInterface::IsTraversing(this) )
    Scr_SetString(&this->m_pAI->traverseName, (scr_string_t)0);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishZeroArrival
==============
*/
void AIScriptedInterface::OnScrCmd_FinishZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arrivalTimeLeft = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::FlagEnemyUnattackable(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::UpdateThreatImmediate(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_scripted_t *m_pAI; 
  float v4; 
  float v5; 
  float v6; 
  pathnode_t *node; 
  ai_scripted_t *v8; 
  pathnode_t *v9; 
  bool v10; 
  bool v11; 
  ai_scripted_t *v12; 
  bool fixedNodeNudged; 
  ai_scripted_t *v14; 

  m_pAI = this->m_pAI;
  v4 = m_pAI->codeGoal.pos.v[0];
  v5 = m_pAI->codeGoal.pos.v[1];
  v6 = m_pAI->codeGoal.pos.v[2];
  node = m_pAI->codeGoal.node;
  AIScriptedInterface::UpdateGoalPos(this);
  v8 = this->m_pAI;
  v9 = v8->codeGoal.node;
  v10 = !v9 || v9 != node;
  v11 = (v4 != v8->codeGoal.pos.v[0] || v5 != v8->codeGoal.pos.v[1] || v6 != v8->codeGoal.pos.v[2]) && v10;
  v8->goalPosChanged = v11;
  v12 = this->m_pAI;
  if ( v12->goalPosChanged )
  {
    fixedNodeNudged = v12->fixedNodeNudged;
    v12->nodeSelect.nextFindBestCoverTime = 0;
    AIScriptedInterface::GoalChanged(this);
    v14 = this->m_pAI;
    if ( v14->fixedNode )
    {
      v14->fixedNodeNudged = fixedNodeNudged;
      this->m_pAI->commitToFixedNode = 0;
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection
==============
*/
void AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned int NumParam; 
  double Float; 
  float v6; 
  double TargetSpeed; 
  int avoidance_active; 
  ai_scripted_t *m_pAI; 
  unsigned int v12; 
  bool AvoidanceDelta; 
  vec3_t velocity; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 2 )
    Scr_Error(COM_ERR_6049, scrContext, "GetAdjustedExitDirection takes between 1 and 4 args.");
  Float = Scr_GetFloat(scrContext, 0);
  v6 = *(float *)&Float;
  TargetSpeed = AIScriptedInterface::GetTargetSpeed(this);
  avoidance_active = 2;
  this->m_pAI->pre_avoidance_desiredSpeed = *(float *)&TargetSpeed;
  m_pAI = this->m_pAI;
  _XMM3 = LODWORD(m_pAI->Physics.vVelocity.v[0]);
  velocity = m_pAI->Physics.vVelocity;
  __asm { vunpcklps xmm0, xmm3, xmm2 }
  vectorValue.v[2] = velocity.v[2];
  *(double *)velocity.v = *(double *)&_XMM0;
  *(double *)vectorValue.v = *(double *)&_XMM0;
  v12 = NumParam - 2;
  if ( v12 )
  {
    if ( v12 != 1 )
      goto LABEL_7;
    Scr_GetVector(scrContext, 2u, &vectorValue);
  }
  Scr_GetVector(scrContext, 1u, &velocity);
LABEL_7:
  AvoidanceDelta = AIScriptedInterface::GetAvoidanceDelta(this, v6, 0, &velocity, &vectorValue);
  Scr_MakeArray(scrContext);
  if ( !AvoidanceDelta )
    avoidance_active = this->m_pAI->avoidance_active;
  Scr_AddInt(scrContext, avoidance_active);
  Scr_AddArray(scrContext);
  Scr_AddVector(scrContext, vectorValue.v);
  Scr_AddArray(scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAimAngle
==============
*/
void AIScriptedInterface::OnScrCmd_GetAimAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddVector(scrContext, this->m_pAI->aimAngles.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/
void AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( AIScriptedInterface::GetAnglesToLikelyEnemyPath(this) )
    Scr_AddVector(scrContext, this->m_pAI->sight.anglesToLikelyEnemyPath.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetApproxEyePos
==============
*/
void AIScriptedInterface::OnScrCmd_GetApproxEyePos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t outEyePos; 

  AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
  Scr_AddVector(scrContext, outEyePos.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBaseArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_GetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t BaseOverrideArchetype; 

  BaseOverrideArchetype = AIScriptedInterface::GetBaseOverrideArchetype(this);
  if ( BaseOverrideArchetype )
    Scr_AddConstString(scrContext, BaseOverrideArchetype);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBlackboard
==============
*/
void AIScriptedInterface::OnScrCmd_GetBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int16 *v2; 

  v2 = (__int16 *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetEntity)(this, scrContext);
  Scr_AddBlackboard(*v2);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_GetCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *CoverNode; 

  CoverNode = AIScriptedInterface::Cover_GetCoverNode(this);
  if ( CoverNode )
    Scr_AddPathnode(CoverNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverTacPoint
==============
*/
void AIScriptedInterface::OnScrCmd_GetCoverTacPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const tacpoint_t *CoverTacPoint; 
  vec3_t outPos; 

  CoverTacPoint = AIScriptedInterface::GetCoverTacPoint(this);
  if ( CoverTacPoint )
  {
    if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
      TacGraph_GetApproxGroundPosForPoint(CoverTacPoint, &outPos);
    else
      outPos = CoverTacPoint->m_Pos;
    Scr_AddVector(scrContext, outPos.v);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/
void AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  float v5; 
  double TargetSpeed; 
  bool outUsingCachedValue; 
  float outTargetSpeed; 
  vec3_t outNextCorner; 

  if ( Scr_GetNumParam(scrContext) )
  {
    if ( AICommonInterface::HasPath(this) )
    {
      Float = Scr_GetFloat(scrContext, 0);
      v5 = *(float *)&Float;
      TargetSpeed = AIScriptedInterface::GetTargetSpeed(this);
      outTargetSpeed = *(float *)&TargetSpeed;
      AIScriptedInterface::ProcessSharpTurnSpeedScale(this, v5, &outNextCorner, &outTargetSpeed, &outUsingCachedValue);
      Scr_AddFloat(scrContext, outTargetSpeed);
    }
    else
    {
      Scr_Error(COM_ERR_3873, scrContext, "GetDesiredScaledSpeedForPosAlongPath: AI doesn't have path yet");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3872, scrContext, "GetDesiredScaledSpeedForPosAlongPath: Invalid argument count");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_GetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double DefaultSpeed; 

  DefaultSpeed = AIScriptedInterface::GetDefaultSpeed(this);
  Scr_AddFloat(scrContext, *(float *)&DefaultSpeed);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v3; 

  if ( EntHandle::isDefined(&this->m_pAI->fixedNodeSafeVolume) )
  {
    v3 = EntHandle::ent(&this->m_pAI->fixedNodeSafeVolume);
    GScr_AddEntity(v3);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_GetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v3; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hVolume) )
  {
    v3 = EntHandle::ent(&this->m_pAI->scriptGoal.hVolume);
    GScr_AddEntity(v3);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundEntType
==============
*/
void AIScriptedInterface::OnScrCmd_GetGroundEntType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned __int16 GroundEntNum; 
  scr_string_t world; 

  GroundEntNum = AIScriptedInterface::GetGroundEntNum(this);
  if ( GroundEntNum == 2047 )
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
  else
  {
    world = scr_const.world;
    if ( (level.gentities[GroundEntNum].flags.m_flags[0] & 0x100) != 0 )
      world = scr_const.obstacle;
    Scr_AddConstString(scrContext, world);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundSlope
==============
*/
void AIScriptedInterface::OnScrCmd_GetGroundSlope(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, this->m_pAI->Physics.groundplaneSlope);
}

/*
==============
AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal
==============
*/
void AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  ai_goal_t *v7; 
  float value[4]; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("GetLastPathPointWithinGoal: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3829, scrContext, v6);
  }
  v7 = this->GetScriptGoal(this);
  if ( v7 )
  {
    if ( ((unsigned __int8 (__fastcall *)(AINavigator *, ai_goal_t *, bool (__fastcall *)(AINavigator *, const vec3_t *, float, vec3_t *), float *))Navigator->GetLastPathPointWithinRadius)(Navigator, v7, Navigator->GetLastPathPointWithinRadius, value) )
      Scr_AddVector(scrContext, value);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle3D
==============
*/
void AIScriptedInterface::OnScrCmd_GetMotionAngle3D(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float value[4]; 

  this->GetMotionAngles(this, (vec3_t *)value);
  Scr_AddVector(scrContext, value);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle
==============
*/
void AIScriptedInterface::OnScrCmd_GetMotionAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v3[4]; 
  float v4; 

  this->GetMotionAngles(this, (vec3_t *)v3);
  Scr_AddFloat(scrContext, v4);
}

/*
==============
AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo
==============
*/
void AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(AICommonInterface *this, scrContext_t *scrContext)
{
  double Float; 
  const pathnode_t *StartNodeFromLink; 
  const pathnode_t *EndNodeFromLink; 
  vec3_t outEndPos; 
  nav_posAlongPathResults_t pResults; 

  Float = Scr_GetFloat(scrContext, 0);
  bfx::AreaHandle::AreaHandle(&pResults.m_hArea);
  bfx::LinkHandle::LinkHandle(&pResults.m_hLink);
  if ( Nav_GetPosAlongPath(this->m_pAI->pNavigator, *(float *)&Float, 1, &pResults) && pResults.m_PosType == POS_ON_LINK )
  {
    StartNodeFromLink = Nav_GetStartNodeFromLink(&pResults.m_hLink);
    if ( StartNodeFromLink )
    {
      Nav_GetEndPosFromLink(&pResults.m_hLink, &outEndPos);
      EndNodeFromLink = Nav_GetEndNodeFromLink(&pResults.m_hLink);
      Scr_MakeArray(scrContext);
      Scr_AddPathnode(StartNodeFromLink);
      Scr_AddArrayStringIndexed(scrContext, scr_const.node);
      Scr_AddVector(scrContext, outEndPos.v);
      Scr_AddArrayStringIndexed(scrContext, scr_const.position);
      if ( EndNodeFromLink )
      {
        Scr_AddPathnode(EndNodeFromLink);
        Scr_AddArrayStringIndexed(scrContext, scr_const.finish);
      }
    }
  }
  bfx::LinkHandle::~LinkHandle(&pResults.m_hLink);
  bfx::AreaHandle::~AreaHandle(&pResults.m_hArea);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndNode
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationEndNode(AICommonInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *EndNodeFromLink; 

  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    EndNodeFromLink = Nav_GetEndNodeFromLink(&this->m_pAI->pNavigator->m_hLink);
    if ( EndNodeFromLink )
      Scr_AddPathnode(EndNodeFromLink);
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndPos
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationEndPos(AICommonInterface *this, scrContext_t *scrContext)
{
  vec3_t outEndPos; 

  if ( !this->m_pAI->pNavigator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1838, ASSERT_TYPE_ASSERT, "( m_pAI->pNavigator )", (const char *)&queryFormat, "m_pAI->pNavigator") )
    __debugbreak();
  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    Nav_GetEndPosFromLink(&this->m_pAI->pNavigator->m_hLink, &outEndPos);
    Scr_AddVector(scrContext, outEndPos.v);
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationStartNode
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationStartNode(AICommonInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *StartNodeFromLink; 

  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    StartNodeFromLink = Nav_GetStartNodeFromLink(&this->m_pAI->pNavigator->m_hLink);
    if ( StartNodeFromLink )
      Scr_AddPathnode(StartNodeFromLink);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYaw
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeHideYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v8; 
  scr_string_t v9; 
  scr_string_t AnimsetName; 
  double NodeHideYawOffset; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v8 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v9 = v8;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v8) )
        HighestNodeStance = v9;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeHideYawOffset = BG_Animset_GetNodeHideYawOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeHideYawOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 
  double NodeHideYawOffset; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeHideYawOffset = BG_Animset_GetNodeHideYawOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeHideYawOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v8; 
  scr_string_t v9; 
  scr_string_t AnimsetName; 
  double NodeLeanAimPitchOffset; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v8 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v9 = v8;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v8) )
        HighestNodeStance = v9;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeLeanAimPitchOffset = BG_Animset_GetNodeLeanAimPitchOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeLeanAimPitchOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 
  double NodeLeanAimPitchOffset; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeLeanAimPitchOffset = BG_Animset_GetNodeLeanAimPitchOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeLeanAimPitchOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v8; 
  scr_string_t v9; 
  scr_string_t AnimsetName; 
  double NodeLeanAimYawOffset; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v8 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v9 = v8;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v8) )
        HighestNodeStance = v9;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeLeanAimYawOffset = BG_Animset_GetNodeLeanAimYawOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeLeanAimYawOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 
  double NodeLeanAimYawOffset; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeLeanAimYawOffset = BG_Animset_GetNodeLeanAimYawOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeLeanAimYawOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 
  double NodeSnapYawOffset; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  NodeSnapYawOffset = BG_Animset_GetNodeSnapYawOffset(AnimsetName, ConstString);
  Scr_AddFloat(scrContext, *(float *)&NodeSnapYawOffset);
}

/*
==============
AICommonInterface::OnScrCmd_GetPathDistToGoal
==============
*/
void AICommonInterface::OnScrCmd_GetPathDistToGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  double v2; 
  AINavigator *Navigator; 
  gentity_s *v6; 
  const char *v7; 
  bool v8; 
  AINavigator_vtbl *v9; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v6 = this->GetEntity(this);
    v7 = j_va("PathDistToGoal: Entity %d must have a navigator.", (unsigned int)v6->s.number);
    Scr_Error(COM_ERR_3832, scrContext, v7);
  }
  v8 = 0;
  if ( Scr_GetNumParam(scrContext) )
    v8 = Scr_GetInt(scrContext, 0) != 0;
  v9 = Navigator->__vftable;
  if ( v8 )
    v9->GetPathDistToGoalOrLink(Navigator);
  else
    v2 = ((double (__fastcall *)(AINavigator *))v9->GetPathDistToGoal)(Navigator);
  Scr_AddFloat(scrContext, *(float *)&v2);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation
==============
*/
void AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float value[4]; 

  if ( this->m_pAI->pNavigator->HasPath(this->m_pAI->pNavigator) && this->m_pAI->pNavigator->GetNextCornerAfterLink(this->m_pAI->pNavigator, (vec3_t *)value) )
    Scr_AddVector(scrContext, value);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOnPath
==============
*/
void AICommonInterface::OnScrCmd_GetPosOnPath(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  __int64 v7; 
  __int64 v8; 
  float value[5]; 
  bfx::AreaHandle v10; 
  bfx::LinkHandle v11; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("GetPosOnPath: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3830, scrContext, v6);
  }
  Scr_GetFloat(scrContext, 0);
  bfx::AreaHandle::AreaHandle(&v10);
  bfx::LinkHandle::LinkHandle(&v11);
  LOBYTE(v7) = 1;
  ((void (__fastcall *)(AINavigator *, __int64, __int64, float *, _BYTE))Navigator->GetPosAlongPath)(Navigator, v8, v7, value, 0);
  Scr_AddVector(scrContext, value);
  bfx::LinkHandle::~LinkHandle(&v11);
  bfx::AreaHandle::~AreaHandle(&v10);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOutsideBadplace
==============
*/
void AICommonInterface::OnScrCmd_GetPosOutsideBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  double Float; 
  ai_common_t *m_pAI; 
  gentity_s *ent; 
  vec3_t outPos; 

  Float = Scr_GetFloat(scrContext, 0);
  m_pAI = this->m_pAI;
  outPos.v[0] = *(float *)&Float;
  outPos.v[1] = *(float *)&Float;
  outPos.v[2] = 0.0;
  ent = m_pAI->ent;
  outPos.v[0] = *(float *)&Float + m_pAI->ent->r.currentOrigin.v[0];
  outPos.v[1] = *(float *)&Float + ent->r.currentOrigin.v[1];
  outPos.v[2] = ent->r.currentOrigin.v[2];
  if ( AICommonInterface::FindSafePosOutsideBadplace(this, *(float *)&Float, &outPos) )
    Scr_AddVector(scrContext, outPos.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetReacquireState
==============
*/
void AIScriptedInterface::OnScrCmd_GetReacquireState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_reacquire_state_t Reacquire; 
  __int64 v4; 

  Reacquire = AIScriptedInterface::GetReacquire(this);
  v4 = Reacquire;
  if ( (unsigned int)Reacquire >= AI_REACQUIRE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5128, ASSERT_TYPE_ASSERT, "(unsigned)( reacquireState ) < (unsigned)( AI_REACQUIRE_COUNT )", "reacquireState doesn't index AI_REACQUIRE_COUNT\n\t%i not in [0, %i)", Reacquire, 4) )
    __debugbreak();
  Scr_AddConstString(scrContext, *AIReacquireStateStrings[v4]);
}

/*
==============
AICommonInterface::OnScrCmd_GetSecondaryTargets
==============
*/
void AICommonInterface::OnScrCmd_GetSecondaryTargets(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  int v5; 
  __int64 v6; 
  AISecondaryTarget *v7; 
  unsigned __int16 number; 
  __int64 v9; 
  unsigned int v10; 
  __int64 v11; 
  ai_common_t *v12; 
  int v13; 
  AISecondaryTarget *v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 

  if ( this->m_pAI->threat.numSecondaryTarget > 0 )
  {
    Scr_MakeArray(scrContext);
    m_pAI = this->m_pAI;
    v5 = 0;
    if ( m_pAI->threat.numSecondaryTarget > 0 )
    {
      v6 = 0i64;
      do
      {
        v7 = &m_pAI->threat.secondaryTargets[v6];
        number = v7->entity.number;
        if ( v7->entity.number )
        {
          v9 = number;
          v10 = number - 1;
          if ( v10 >= 0x800 )
          {
            LODWORD(v18) = 2048;
            LODWORD(v17) = v10;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v17, v18) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v11 = v9 - 1;
          if ( g_entities[v11].r.isInUse != g_entityIsInUse[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v11] )
          {
            LODWORD(v18) = v7->entity.number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v18) )
              __debugbreak();
          }
          if ( v7->entity.number )
          {
            v12 = this->m_pAI;
            v13 = v12->threat.secondaryTargets[v6].entity.number;
            v14 = &v12->threat.secondaryTargets[v6];
            if ( (unsigned int)(v13 - 1) >= 0x7FF )
            {
              LODWORD(v18) = 2047;
              LODWORD(v17) = v13 - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v17, v18) )
                __debugbreak();
            }
            v15 = v14->entity.number;
            if ( (unsigned int)(v15 - 1) >= 0x800 )
            {
              LODWORD(v18) = 2048;
              LODWORD(v17) = v15 - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v17, v18) )
                __debugbreak();
            }
            if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
              __debugbreak();
            v16 = v15 - 1;
            if ( g_entities[v16].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
              __debugbreak();
            if ( !g_entityIsInUse[v16] )
            {
              LODWORD(v18) = v14->entity.number - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v18) )
                __debugbreak();
            }
            GScr_AddEntity(&g_entities[v14->entity.number - 1]);
            Scr_AddArray(scrContext);
          }
        }
        m_pAI = this->m_pAI;
        ++v5;
        ++v6;
      }
      while ( v5 < m_pAI->threat.numSecondaryTarget );
    }
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetStairsStateAtDist
==============
*/
void AICommonInterface::OnScrCmd_GetStairsStateAtDist(AICommonInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  AINavigator *Navigator; 
  const char *v6; 
  const nav_space_s **v7; 
  __int64 v8; 
  int v9; 
  int skipEntity; 
  scrContext_t *v11; 
  scr_string_t up; 
  float v13; 
  float v14; 
  float v15; 
  vec3_t outUp; 
  vec3_t end; 
  vec3_t start; 
  trace_t results; 

  v4 = this->GetEntity(this);
  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v6 = j_va("GetStairsStateAtDist: Entity %d must have a navigator.", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_5906, scrContext, v6);
  }
  v7 = (const nav_space_s **)Navigator->Get2DNavigator(Navigator);
  if ( v7 )
  {
    Scr_GetFloat(scrContext, 0);
    v9 = (*(__int64 (__fastcall **)(const nav_space_s **, __int64, float *))&(*v7)->obstacleList.m_BoundaryPlanes[8].m_DistFromCenter)(v7, v8, &v13);
    if ( !v9 )
      goto LABEL_15;
    if ( ((LODWORD(v13) & 0x7F800000) == 2139095040 || (LODWORD(v14) & 0x7F800000) == 2139095040 || (LODWORD(v15) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1515, ASSERT_TYPE_SANITY, "( !IS_NAN( ( posAtDist )[0] ) && !IS_NAN( ( posAtDist )[1] ) && !IS_NAN( ( posAtDist )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( posAtDist )[0] ) && !IS_NAN( ( posAtDist )[1] ) && !IS_NAN( ( posAtDist )[2] )") )
      __debugbreak();
    Nav_GetSpaceUp(v7[2], &outUp);
    skipEntity = v4->s.number;
    start.v[0] = (float)(32.0 * outUp.v[0]) + v13;
    start.v[1] = (float)(32.0 * outUp.v[1]) + v14;
    start.v[2] = (float)(32.0 * outUp.v[2]) + v15;
    end.v[0] = v13 - (float)(32.0 * outUp.v[0]);
    end.v[1] = v14 - (float)(32.0 * outUp.v[1]);
    end.v[2] = v15 - (float)(32.0 * outUp.v[2]);
    PhysicsQuery_LegacyTrace(PHYSICS_WORLD_ID_FIRST, &results, &start, &end, &bounds_origin, skipEntity, 1, 33685521, 0, NULL, All);
    if ( Path_TraceHitStairs(&results) )
    {
      v11 = scrContext;
      if ( v9 == 1 )
        up = scr_const.up;
      else
        up = scr_const.down;
    }
    else
    {
LABEL_15:
      up = scr_const.none;
      v11 = scrContext;
    }
    Scr_AddConstString(v11, up);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetTargetSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_GetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, this->m_pAI->animData.desiredSpeed);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ApproxGunParams pOutGunParams; 
  float value[4]; 
  tmat33_t<vec3_t> axis; 

  AIScriptedInterface::GetApproxAdjustedGunParams(this, &pOutGunParams);
  AnglesToAxis(&this->m_pAI->ent->r.currentAngles, &axis);
  value[0] = (float)((float)(axis.m[0].v[0] * pOutGunParams.m_offset.v[0]) + (float)(axis.m[1].v[0] * pOutGunParams.m_offset.v[1])) + (float)(pOutGunParams.m_offset.v[2] * axis.m[2].v[0]);
  value[1] = (float)((float)(axis.m[0].v[1] * pOutGunParams.m_offset.v[0]) + (float)(axis.m[1].v[1] * pOutGunParams.m_offset.v[1])) + (float)(pOutGunParams.m_offset.v[2] * axis.m[2].v[1]);
  value[2] = (float)((float)(axis.m[0].v[2] * pOutGunParams.m_offset.v[0]) + (float)(axis.m[1].v[2] * pOutGunParams.m_offset.v[1])) + (float)(pOutGunParams.m_offset.v[2] * axis.m[2].v[2]);
  Scr_AddVector(scrContext, value);
}

/*
==============
AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/
void AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->mayMoveTime = Scr_GetInt(scrContext, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot
==============
*/
void AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  gentity_s *v5; 
  const char *v6; 
  int v7; 
  vec3_t outUp; 
  vec3_t vectorValue; 
  vec3_t end; 
  vec3_t start; 
  trace_t results; 

  v4 = this->GetEntity(this);
  v5 = v4;
  if ( !this->m_pAI->pNavigator )
  {
    v6 = j_va("IsAtValidLongDeathSpot: Entity %d must have a navigator.", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_3831, scrContext, v6);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_VECTOR )
    Scr_GetVector(scrContext, 0, &vectorValue);
  else
    this->m_pAI->pNavigator->GetCurPos(this->m_pAI->pNavigator, &vectorValue);
  Nav_GetSpaceUp(this->m_pAI->pNavigator->m_pSpace, &outUp);
  start.v[0] = (float)(32.0 * outUp.v[0]) + vectorValue.v[0];
  start.v[1] = (float)(32.0 * outUp.v[1]) + vectorValue.v[1];
  start.v[2] = (float)(32.0 * outUp.v[2]) + vectorValue.v[2];
  end.v[0] = vectorValue.v[0] - (float)(8.0 * outUp.v[0]);
  v7 = 0;
  end.v[2] = vectorValue.v[2] - (float)(8.0 * outUp.v[2]);
  end.v[1] = vectorValue.v[1] - (float)(8.0 * outUp.v[1]);
  PhysicsQuery_LegacyTrace(PHYSICS_WORLD_ID_FIRST, &results, &start, &end, &bounds_origin, v5->s.number, 1, 33685521, 0, NULL, All);
  if ( (float)((float)((float)(results.normal.v[1] * outUp.v[1]) + (float)(results.normal.v[0] * outUp.v[0])) + (float)(results.normal.v[2] * outUp.v[2])) >= 0.96499997 && !Path_TraceHitStairs(&results) )
    LOBYTE(v7) = results.fraction < 1.0;
  Scr_AddBool(scrContext, v7);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  const pathnode_t *pClaimedNode; 
  int NumParam; 
  int IsValidAgainstEnemy; 
  bool v8; 

  v4 = this->GetSentient(this);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2070, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  pClaimedNode = v4->pClaimedNode;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
    pClaimedNode = Scr_GetPathnode(scrContext, 0);
  if ( pClaimedNode )
  {
    v8 = 1;
    if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
      v8 = Scr_GetInt(scrContext, 1u) != 0;
    IsValidAgainstEnemy = AIScriptedInterface::Cover_IsValidAgainstEnemy(this, pClaimedNode, v8);
  }
  else
  {
    IsValidAgainstEnemy = 0;
  }
  Scr_AddBool(scrContext, IsValidAgainstEnemy);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid
==============
*/
void AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsCurrentEnemyValid; 

  IsCurrentEnemyValid = AIScriptedInterface::IsCurrentEnemyValid(this);
  Scr_AddBool(scrContext, IsCurrentEnemyValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsGunBlockedByWall
==============
*/
void AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float v3; 
  double Float; 
  int IsGunBlockedByWall; 

  v3 = FLOAT_12_0;
  if ( Scr_GetNumParam(scrContext) )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v3 = *(float *)&Float;
  }
  IsGunBlockedByWall = AIScriptedInterface::IsGunBlockedByWall(this, v3);
  Scr_AddInt(scrContext, IsGunBlockedByWall);
}

/*
==============
AICommonInterface::OnScrCmd_IsInBadplace
==============
*/
void AICommonInterface::OnScrCmd_IsInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  bool isInBadPlace; 

  m_pAI = this->m_pAI;
  isInBadPlace = m_pAI->navigation.isInBadPlace;
  if ( m_pAI->ent && m_pAI->ent->tagInfo )
    isInBadPlace = 0;
  Scr_AddBool(scrContext, isInBadPlace);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInGoal
==============
*/
void AIScriptedInterface::OnScrCmd_IsInGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    v4 = AICommonInterface::PointAtGoal(this, &vectorValue, &this->m_pAI->codeGoal);
    Scr_AddBool(scrContext, v4);
  }
  else
  {
    Scr_Error(COM_ERR_3856, scrContext, "illegal call to isingoal()");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInScriptedState
==============
*/
void AIScriptedInterface::OnScrCmd_IsInScriptedState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = this->InScriptedState(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius
==============
*/
void AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  int Int; 
  double Float; 
  vec3_t vectorValue; 

  v4 = 0;
  Int = 0;
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 2 )
    Int = Scr_GetInt(scrContext, 2u);
  Float = Scr_GetFloat(scrContext, 1u);
  LOBYTE(v4) = AIScriptedInterface::IsKnownEnemyInRegion(this, NULL, &vectorValue, *(float *)&Float, Int != 0) != NULL;
  Scr_AddInt(scrContext, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume
==============
*/
void AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v3; 
  int Int; 
  const gentity_s *Entity; 

  v3 = 0;
  Int = 0;
  Entity = GScr_GetEntity(0);
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  LOBYTE(v3) = AIScriptedInterface::IsKnownEnemyInRegion(this, Entity, &vec3_origin, 0.0, Int != 0) != NULL;
  Scr_AddInt(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsLegacyAgent
==============
*/
void AIScriptedInterface::OnScrCmd_IsLegacyAgent(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsMoveSuppressed
==============
*/
void AIScriptedInterface::OnScrCmd_IsMoveSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsMoveSuppressed; 

  IsMoveSuppressed = AIScriptedInterface::IsMoveSuppressed(this);
  Scr_AddInt(scrContext, IsMoveSuppressed);
}

/*
==============
AICommonInterface::OnScrCmd_IsNodeInBadplace
==============
*/
void AICommonInterface::OnScrCmd_IsNodeInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v5; 
  unsigned __int64 eTeam; 
  int v7; 
  bitarray<224> teamFlags; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  pathnode_t::GetPos(Pathnode, &pos);
  v5 = 0;
  eTeam = (unsigned int)this->m_pAI->sentient->eTeam;
  memset(&teamFlags, 0, sizeof(teamFlags));
  if ( (unsigned int)eTeam >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", eTeam, 224) )
    __debugbreak();
  teamFlags.array[eTeam >> 5] |= 0x80000000 >> (eTeam & 0x1F);
  v7 = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&teamFlags);
  if ( Nav_IsPointInRepulsorBadplace(&pos, v7, this->m_pAI->ent->s.number, 2047) )
    v5 = 1;
  else
    LOBYTE(v5) = !this->m_pAI->pNavigator->IsNodeUsable(this->m_pAI->pNavigator, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsPathDirect
==============
*/
void AIScriptedInterface::OnScrCmd_IsPathDirect(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsStraightLineToGoal; 

  if ( AICommonInterface::HasPath(this) )
  {
    IsStraightLineToGoal = Nav_IsStraightLineToGoal(this->m_pAI->pNavigator);
    Scr_AddInt(scrContext, IsStraightLineToGoal);
  }
  else
  {
    Scr_AddInt(scrContext, 0);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_IsStanceAllowed
==============
*/
void AIScriptedInterface::OnScrCmd_IsStanceAllowed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int v5; 
  ai_stance_e v6; 
  const char *v7; 
  const char *v8; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = 0;
  v6 = STANCE_BAD;
  if ( ConstString == scr_const.stand )
  {
    v6 = STANCE_STAND;
  }
  else if ( ConstString == scr_const.crouch )
  {
    v6 = STANCE_CROUCH;
  }
  else if ( ConstString == scr_const.prone )
  {
    v6 = STANCE_PRONE;
  }
  else
  {
    v7 = SL_ConvertToString(ConstString);
    v8 = j_va("invalid stance '%s' in isStanceAllowed()\n", v7);
    Scr_Error(COM_ERR_3841, scrContext, v8);
  }
  LOBYTE(v5) = AIScriptedInterface::IsStanceAllowed(this, v6);
  Scr_AddInt(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressed
==============
*/
void AIScriptedInterface::OnScrCmd_IsSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsSuppressed; 

  IsSuppressed = AIScriptedInterface::IsSuppressed(this);
  Scr_AddInt(scrContext, IsSuppressed);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressionWaiting
==============
*/
void AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsSuppressionWaiting; 

  IsSuppressionWaiting = AIScriptedInterface::IsSuppressionWaiting(this);
  Scr_AddInt(scrContext, IsSuppressionWaiting);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  gentity_s *v5; 
  float v6; 
  double Float; 
  bool IsWithinScriptGoalRadius; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  v5 = this->GetEntity(this);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
    Scr_GetVector(scrContext, 0, &vectorValue);
  else
    vectorValue = v5->r.currentOrigin;
  v6 = 0.0;
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    Float = Scr_GetFloat(scrContext, 1u);
    v6 = *(float *)&Float;
  }
  IsWithinScriptGoalRadius = AIScriptedInterface::IsWithinScriptGoalRadius(this, &vectorValue, v6);
  Scr_AddBool(scrContext, IsWithinScriptGoalRadius);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = AIScriptedInterface::MayMove_CheckFriendlyFire(this, &this->m_pAI->ent->r.currentOrigin, &vectorValue);
  Scr_AddBool(scrContext, v4 == 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int checkDrop; 
  int ignoreActors; 
  bool MayMoveFromPointToPoint; 
  bfx::AreaHandle hStartArea; 
  __int64 v8; 
  vec3_t vEnd; 
  vec3_t vectorValue; 

  v8 = -2i64;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &vEnd);
  checkDrop = 0;
  ignoreActors = Scr_GetNumParam(scrContext) > 3 && Scr_GetInt(scrContext, 3u) != 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
    checkDrop = 1;
  else
    LOBYTE(checkDrop) = Scr_GetInt(scrContext, 2u) != 0;
  bfx::AreaHandle::AreaHandle(&hStartArea);
  MayMoveFromPointToPoint = AIScriptedInterface::MayMoveFromPointToPoint(this, &vectorValue, &hStartArea, &vEnd, ignoreActors, checkDrop);
  Scr_AddBool(scrContext, MayMoveFromPointToPoint);
  bfx::AreaHandle::~AreaHandle(&hStartArea);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveToPoint
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  int checkDrop; 
  int ignoreActors; 
  gentity_s *v7; 
  const vec3_t *p_currentOrigin; 
  ai_scripted_t *m_pAI; 
  __int64 v10; 
  AINavigator2D *v11; 
  const bfx::AreaHandle *CurArea; 
  vec3_t vectorValue; 
  vec3_t vStart; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = 0;
  checkDrop = Scr_GetNumParam(scrContext) <= 1 || Scr_GetInt(scrContext, 1u) != 0;
  ignoreActors = Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) != 0;
  v7 = this->GetEntity(this);
  p_currentOrigin = &v7->r.currentOrigin;
  if ( v7->tagInfo )
  {
    AIScriptedInterface::MayMove_Debug(&v7->r.currentOrigin, &vectorValue, &colorMagenta, DEBUGMAYMOVE_LIFTED);
  }
  else if ( !AIScriptedInterface::MayMove_CheckFriendlyFire(this, &v7->r.currentOrigin, &vectorValue) )
  {
    m_pAI = this->m_pAI;
    if ( !m_pAI->pNavigator )
    {
      Scr_Error(COM_ERR_3886, scrContext, "AI does not have a navigator");
      m_pAI = this->m_pAI;
    }
    v10 = (__int64)m_pAI->pNavigator->Get2DNavigator(m_pAI->pNavigator);
    v11 = (AINavigator2D *)v10;
    if ( v10 )
    {
      (*(void (__fastcall **)(__int64, vec3_t *))(*(_QWORD *)v10 + 16i64))(v10, &vStart);
      CurArea = AINavigator2D::GetCurArea(v11);
      if ( !AIScriptedInterface::MayMoveFromPointToPoint(this, &vStart, CurArea, &vectorValue, ignoreActors, checkDrop) )
        goto LABEL_17;
    }
    else
    {
      Scr_Error(COM_ERR_3887, scrContext, "MayMoveToPoint does not work with 3D nav.  Use a nav trace (allow edge) instead.");
    }
    this->SetMayMoveTime(this, level.time);
    AIScriptedInterface::MayMove_Debug(p_currentOrigin, &vectorValue, &colorGreen, DEBUGMAYMOVE_LIFTED);
    v4 = 1;
  }
LABEL_17:
  Scr_AddBool(scrContext, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_Melee
==============
*/
void AIScriptedInterface::OnScrCmd_Melee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t *p_vectorValue; 
  int NumParam; 
  int Int; 
  float v7; 
  double Float; 
  float v9; 
  float v10; 
  double v11; 
  double v12; 
  const gentity_s *v13; 
  vec3_t vectorValue; 

  p_vectorValue = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    p_vectorValue = &vectorValue;
  }
  Int = -1;
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
    Int = Scr_GetInt(scrContext, 1u);
  v7 = FLOAT_64_0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    v7 = *(float *)&Float;
  }
  v9 = 0.0;
  v10 = 0.0;
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
  {
    v11 = Scr_GetFloat(scrContext, 3u);
    v10 = *(float *)&v11;
  }
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) )
  {
    v12 = Scr_GetFloat(scrContext, 4u);
    v9 = *(float *)&v12;
  }
  v13 = AIScriptedInterface::Melee(this, p_vectorValue, Int, v7, v10, v9);
  if ( v13 )
    GScr_AddEntity(v13);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNode
==============
*/
void AIScriptedInterface::OnScrCmd_NearClaimNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = AIScriptedInterface::AtClaimNode(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle
==============
*/
void AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v3; 

  v3 = AIScriptedInterface::AtClaimNodeAndAngle(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_OrientMode
==============
*/
void AIScriptedInterface::OnScrCmd_OrientMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int128 v2; 
  scr_string_t ConstString; 
  double Float; 
  bool v7; 
  bool v8; 
  _BOOL8 v9; 
  bool v10; 
  bool v11; 
  gentity_s *v12; 
  float v13; 
  AIScriptedInterface_vtbl *v14; 
  float v15; 
  float v16; 
  bool v17; 
  ai_scripted_t *m_pAI; 
  int number; 
  Ai_Asm *v20; 
  ASM_Instance *Instance; 
  const ASM_State *State; 
  const char *v23; 
  const char *v24; 
  vec3_t vectorValue; 
  vec3_t v26; 
  __int128 v27; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.face_angle )
  {
    if ( this->Is3D(this) )
      Scr_Error(COM_ERR_3874, scrContext, "Invalid OrientMode 'face angle' on a 3D actor.  Did you mean to use 'face angle 3d'?");
    Float = Scr_GetFloat(scrContext, 1u);
    vectorValue.v[0] = 0.0;
    vectorValue.v[1] = *(float *)&Float;
    vectorValue.v[2] = 0.0;
    if ( (LODWORD(Float) & 0x7F800000) == 2139095040 )
      Scr_Error(COM_ERR_3875, scrContext, "OrientMode - invalid angle provided to 'face angle'");
    v7 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v7 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceAngles(this, &vectorValue, 0, v7);
  }
  else if ( ConstString == scr_const.face_angle_3d )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    v8 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v8 = Scr_GetInt(scrContext, 2u) == 0;
    if ( (LODWORD(vectorValue.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(vectorValue.v[2]) & 0x7F800000) == 2139095040 )
      Scr_Error(COM_ERR_3876, scrContext, "OrientMode - invalid angles provided to 'face angle 3d'");
    LOBYTE(v9) = 1;
    this->OrientMode_FaceAngles(this, &vectorValue, v9, v8);
  }
  else if ( ConstString == scr_const.face_current )
  {
    v10 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v10 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceCurrent(this, v10);
  }
  else if ( ConstString == scr_const.face_direction )
  {
    v27 = v2;
    Scr_GetVector(scrContext, 1u, &vectorValue);
    if ( vectorValue.v[0] == 0.0 )
    {
      if ( vectorValue.v[1] == 0.0 && !this->Is3D(this) )
        Scr_Error(COM_ERR_3877, scrContext, "2D Actor cannot face (0, 0, *)");
      if ( vectorValue.v[0] == 0.0 && vectorValue.v[1] == 0.0 && vectorValue.v[2] == 0.0 )
        Scr_Error(COM_ERR_3878, scrContext, "cannot face (0, 0, 0)");
    }
    v11 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v11 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceDirection(this, &vectorValue, v11);
  }
  else if ( ConstString == scr_const.face_enemy )
  {
    this->OrientMode(this, AI_ORIENT_TO_ENEMY);
  }
  else if ( ConstString == scr_const.face_enemy_or_motion )
  {
    this->OrientMode(this, AI_ORIENT_TO_ENEMY_OR_MOTION);
  }
  else if ( ConstString == scr_const.face_goal )
  {
    this->OrientMode(this, AI_ORIENT_TO_GOAL);
  }
  else if ( ConstString == scr_const.face_motion )
  {
    this->OrientMode(this, AI_ORIENT_TO_MOTION);
  }
  else if ( ConstString == scr_const.face_point )
  {
    Scr_GetVector(scrContext, 1u, &v26);
    v12 = this->GetEntity(this);
    vectorValue.v[0] = v26.v[0] - v12->r.currentOrigin.v[0];
    vectorValue.v[1] = v26.v[1] - v12->r.currentOrigin.v[1];
    v13 = v26.v[2] - v12->r.currentOrigin.v[2];
    v14 = this->__vftable;
    vectorValue.v[2] = v13;
    v15 = vectorValue.v[1] * vectorValue.v[1];
    v16 = vectorValue.v[0] * vectorValue.v[0];
    if ( v14->Is3D(this) )
      v17 = (float)((float)(v15 + v16) + (float)(vectorValue.v[2] * vectorValue.v[2])) < 1.0;
    else
      v17 = (float)(v15 + v16) < 1.0;
    if ( !v17 )
      this->OrientMode_FaceDirection(this, &vectorValue, 0);
  }
  else if ( ConstString == scr_const.face_default )
  {
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_iw7, "ai_iw7") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3371, ASSERT_TYPE_ASSERT, "( !Dvar_GetBool_Internal_DebugName( DVARBOOL_ai_iw7, \"ai_iw7\" ) )", "OrientMode face default is not supported with iw7 ai.") )
      __debugbreak();
  }
  else if ( ConstString == scr_const.face_current_angles )
  {
    this->OrientMode(this, AI_ORIENT_CURRENT_ANGLES);
  }
  else
  {
    Scr_Error(COM_ERR_3879, scrContext, "orientMode must be 'face angle', 'face angle 3d', 'face current', 'face direction', 'face enemy', 'face enemy or motion', 'face goal', 'face motion', 'face point', or 'face default'\n'face direction' and 'face point' take a second argument that is a vector giving the way to face\n'face angle' takes a second argument that is a yaw angle\n");
  }
  if ( G_MotionWarp_Active(this->m_pAI->ent->s.number) )
  {
    m_pAI = this->m_pAI;
    if ( m_pAI->ScriptOrient.eMode > (unsigned int)AI_ORIENT_DONT_CHANGE_RELATIVE )
    {
      number = m_pAI->ent->s.number;
      v20 = Ai_Asm::Singleton();
      Instance = Ai_Asm::GetInstance(v20, NULL, number);
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3387, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
        __debugbreak();
      State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
      v23 = SL_ConvertToString(State->m_Name);
      v24 = j_va("Script OrientMode must be set to face_angles during motionwarp. Current ASM State: %s", v23);
      Scr_Error(COM_ERR_3880, scrContext, v24);
    }
  }
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) > 0 )
  {
    if ( this->Is3D(this) )
      Scr_Error(COM_ERR_3881, scrContext, "Invalid OrientMode option used on a 3D actor");
    this->OrientMode_Sync(this);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_PointInFOV
==============
*/
void AIScriptedInterface::OnScrCmd_PointInFOV(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = AICommonInterface::PointInFov(this, &vectorValue);
  Scr_AddInt(scrContext, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival
==============
*/
void AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_scripted_t *m_pAI; 
  float v5; 
  ai_scripted_t *v6; 
  AIUnitType unitType; 
  float v8; 
  float v9; 
  scr_string_t NearestSpeedThresholdString; 
  int AnimSpeedThresholdValue; 
  vec3_t vFinalGoal; 

  if ( AICommonInterface::HasPath(this) )
  {
    AICommonInterface::GetPathFinalGoal(this, &vFinalGoal);
    m_pAI = this->m_pAI;
    v5 = (float)((float)((float)(vFinalGoal.v[1] - m_pAI->ent->r.currentOrigin.v[1]) * (float)(vFinalGoal.v[1] - m_pAI->ent->r.currentOrigin.v[1])) + (float)((float)(vFinalGoal.v[0] - m_pAI->ent->r.currentOrigin.v[0]) * (float)(vFinalGoal.v[0] - m_pAI->ent->r.currentOrigin.v[0]))) + (float)((float)(vFinalGoal.v[2] - m_pAI->ent->r.currentOrigin.v[2]) * (float)(vFinalGoal.v[2] - m_pAI->ent->r.currentOrigin.v[2]));
    if ( v5 <= 65536.0 )
    {
      AIScriptedInterface::GetDefaultSpeed(this);
      Scr_MakeArray(scrContext);
      v6 = this->m_pAI;
      unitType = v6->unitType;
      if ( (unitType == AI_UNITTYPE_SOLDIER || unitType == AI_UNITTYPE_JUGGERNAUT) && v6->blackboard.m_MoveType == scr_const.combat )
      {
        v8 = fsqrt(v5);
        v9 = fsqrt((float)((float)(v6->Physics.vVelocity.v[0] * v6->Physics.vVelocity.v[0]) + (float)(v6->Physics.vVelocity.v[1] * v6->Physics.vVelocity.v[1])) + (float)(v6->Physics.vVelocity.v[2] * v6->Physics.vVelocity.v[2]));
        if ( v8 >= 64.0 && v8 <= 110.0 )
          v9 = (float)((float)(1.0 - (float)((float)(v8 - 64.0) * 0.021739131)) * v6->animData.desiredSpeed) + (float)((float)((float)(v8 - 64.0) * 0.021739131) * v9);
        Scr_AddFloat(scrContext, v9);
        Scr_AddArrayStringIndexed(scrContext, scr_const.desiredspeed);
        NearestSpeedThresholdString = GetNearestSpeedThresholdString(this->m_pAI->baseArchetype, v9);
        AnimSpeedThresholdValue = GetAnimSpeedThresholdValue(this->m_pAI->baseArchetype, NearestSpeedThresholdString);
        Scr_AddFloat(scrContext, (float)AnimSpeedThresholdValue);
        Scr_AddArrayStringIndexed(scrContext, scr_const.targetspeed);
        Scr_AddConstString(scrContext, NearestSpeedThresholdString);
        Scr_AddArrayStringIndexed(scrContext, scr_const.speed);
      }
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_PushPlayer
==============
*/
void AIScriptedInterface::OnScrCmd_PushPlayer(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v4; 
  unsigned int v5; 
  int Int; 
  ai_scripted_t *m_pAI; 
  int iTraceMask; 
  unsigned int v9; 
  sentient_s *v10; 

  v4 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v4 )
    Scr_Error(COM_ERR_6577, scrContext, "Cannot push player on non-2D navigator");
  v5 = v4->GetObstacleBlockageFlags(v4);
  Int = Scr_GetInt(scrContext, 0);
  m_pAI = this->m_pAI;
  iTraceMask = m_pAI->Physics.iTraceMask;
  if ( Int )
  {
    m_pAI->Physics.iTraceMask = iTraceMask & 0xFDFFFFFF;
    v9 = v5 & 0xFFFFBFFF;
    this->m_pAI->avoidance.pushPlayerEnabled = 1;
LABEL_8:
    v4->SetObstacleBlockageFlags(v4, v9);
    return;
  }
  m_pAI->Physics.iTraceMask = iTraceMask | 0x2000000;
  this->m_pAI->avoidance.pushPlayerEnabled = 0;
  v10 = this->GetSentient(this);
  if ( v10 && v10->eTeam == TEAM_TWO )
  {
    v9 = v5 | 0x4000;
    goto LABEL_8;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireClear
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireClear(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::SetReacquire(this, AI_REACQUIRE_DISABLED, 2047);
  AIScriptedInterface::ClearBTGoal(this, AI_BT_GOAL_PRIORITY_URGENT);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireMove
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool started; 

  started = AIScriptedInterface::Behave_StartReacquireMove(this);
  Scr_AddBool(scrContext, started);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireStep
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireStep(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  bool v5; 

  Float = Scr_GetFloat(scrContext, 0);
  v5 = AIScriptedInterface::Behave_ReacquireStepMove(this, *(float *)&Float);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_ResetThreatUpdate
==============
*/
void AIScriptedInterface::OnScrCmd_ResetThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->threat.threatUpdateTime = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_SeeRecently
==============
*/
void AIScriptedInterface::OnScrCmd_SeeRecently(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  double Float; 
  int CanSeeEntity; 

  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2257, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( Entity->sentient )
  {
    Float = Scr_GetFloat(scrContext, 1u);
    CanSeeEntity = AICommonInterface::RecentlySeeSentient(this, Entity->sentient, (int)(float)(*(float *)&Float * 1000.0));
  }
  else
  {
    CanSeeEntity = AICommonInterface::CanSeeEntity(this, Entity);
  }
  Scr_AddBool(scrContext, CanSeeEntity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetAimAngles
==============
*/
void AIScriptedInterface::OnScrCmd_SetAimAngles(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const dvar_t *v2; 
  bool enabled; 
  ai_scripted_t *m_pAI; 
  gentity_s *ent; 
  int Int; 
  double Float; 
  vec3_t vectorValue; 
  vec3_t shootFromPos; 
  vec3_t angles; 
  vec3_t v13; 
  ActorAimAngleParam params; 

  v2 = DCONST_DVARBOOL_ai_debugaim;
  if ( !DCONST_DVARBOOL_ai_debugaim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugaim") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  enabled = v2->current.enabled;
  vectorValue.v[0] = 0.0;
  vectorValue.v[1] = 0.0;
  vectorValue.v[2] = 0.0;
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    if ( !enabled )
      goto LABEL_13;
    angles.v[2] = vectorValue.v[2];
    m_pAI = this->m_pAI;
    *(double *)angles.v = *(double *)vectorValue.v;
    ent = m_pAI->ent;
    *(_QWORD *)shootFromPos.v = *(_QWORD *)m_pAI->ent->r.currentOrigin.v;
    shootFromPos.v[2] = ent->r.currentOrigin.v[2] + 60.0;
  }
  else
  {
    Scr_GetVector(scrContext, 0, &shootFromPos);
    Scr_GetVector(scrContext, 1u, &v13);
    Int = Scr_GetInt(scrContext, 2u);
    Scr_GetVector(scrContext, 3u, &params.angleOffset);
    Float = Scr_GetFloat(scrContext, 4u);
    params.stepOutYaw = *(float *)&Float;
    params.useStepoutYaw = Scr_GetInt(scrContext, 5u) != 0;
    params.zeroIfNotInLimits = Scr_GetInt(scrContext, 6u) != 0;
    if ( Int )
    {
      params.shootDir.v[0] = v13.v[0] - shootFromPos.v[0];
      params.shootDir.v[2] = v13.v[2] - shootFromPos.v[2];
      params.shootDir.v[1] = v13.v[1] - shootFromPos.v[1];
      AIScriptedInterface::GetDesiredAimAngles(this, &params, &vectorValue);
    }
    else
    {
      AIScriptedInterface::GetAimAnglesForNoShootPos(this, &params, &shootFromPos, &vectorValue);
    }
    angles = vectorValue;
    AIScriptedInterface::ClampAimAngles(this, params.zeroIfNotInLimits, &vectorValue);
  }
  if ( enabled )
    AI_DrawSetAngleCalc(&this->m_pAI->ent->r.currentOrigin, &this->m_pAI->ent->r.currentAngles, &shootFromPos, &angles, &vectorValue);
LABEL_13:
  this->m_pAI->aimAngles = vectorValue;
  Scr_AddVector(scrContext, vectorValue.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalEnt
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1162, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Entity = GScr_GetEntity(1u);
  AIScriptedInterface::SetBTGoalEnt(this, (ai_bt_goal_priority_t)Int, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalHeight
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalHeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  __int64 v5; 
  double Float; 

  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1260, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Float = Scr_GetFloat(scrContext, 1u);
  this->m_pAI->btGoals[v5].height = *(float *)&Float;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalNode
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  pathnode_t *Pathnode; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1140, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Pathnode = Scr_GetPathnode(scrContext, 1u);
  AIScriptedInterface::SetBTGoalNode(this, (ai_bt_goal_priority_t)Int, Pathnode);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  vec3_t vectorValue; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1117, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Scr_GetVector(scrContext, 1u, &vectorValue);
  AIScriptedInterface::SetBTGoalPos(this, (ai_bt_goal_priority_t)Int, &vectorValue);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  double Float; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1237, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Float = Scr_GetFloat(scrContext, 1u);
  AIScriptedInterface::SetBTGoalRadius(this, (ai_bt_goal_priority_t)Int, *(float *)&Float);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  __int64 v5; 
  gentity_s *Entity; 

  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1187, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Entity = GScr_GetEntity(1u);
  if ( EntHandle::isDefined(&this->m_pAI->btGoals[v5].hEnt) )
    Scr_Error(COM_ERR_3827, scrContext, "cannot set goal volume when a goal entity is set");
  AIScriptedInterface::SetBTGoalVolume(this, (ai_bt_goal_priority_t)v5, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &this->m_pAI->backupCoverFromPos);
    this->m_pAI->bUseBackupCoverFromPos = 1;
  }
  else
  {
    this->m_pAI->bUseBackupCoverFromPos = 0;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBaseArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_SetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AIScriptedInterface::SetBaseOverrideArchetype(this, ConstString);
}

/*
==============
AICommonInterface::OnScrCmd_SetC8ObstacleFlag
==============
*/
void AICommonInterface::OnScrCmd_SetC8ObstacleFlag(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  __int64 v5; 
  bool v6; 
  int v7; 
  unsigned int v8; 

  m_pAI = this->m_pAI;
  if ( m_pAI->ent->actor )
  {
    Scr_Error(COM_ERR_3864, scrContext, "SetC8ObstacleFlag - doesn't apply to actors.  C8s should use their own nav layer and have obstacles applied to those layers.");
    m_pAI = this->m_pAI;
  }
  v5 = (__int64)m_pAI->pNavigator->Get2DNavigator(m_pAI->pNavigator);
  if ( !v5 )
    Scr_Error(COM_ERR_3865, scrContext, "SetC8ObstacleFlag - only applies to 2D navigators.");
  v6 = 1;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 104i64))(v5);
  if ( Scr_GetNumParam(scrContext) )
    v6 = Scr_GetInt(scrContext, 0) != 0;
  if ( v6 )
    v8 = v7 | 0x1000;
  else
    v8 = v7 & 0xFFFFEFFF;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 112i64))(v5, v8);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt
==============
*/
void AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_scripted_t *m_pAI; 
  const gentity_s *Entity; 

  m_pAI = this->m_pAI;
  Entity = GScr_GetEntity(0);
  EntHandle::setEnt(&m_pAI->coverSelectionFocusEnt, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDefaultAimLimits
==============
*/
void AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 

  Pathnode = NULL;
  if ( Scr_GetNumParam(scrContext) )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  AIScriptedInterface::Cover_SetAimLimits(this, Pathnode);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_SetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  double v5; 
  const char *v6; 
  const char *v7; 

  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  if ( *(float *)&Float < 0.0 )
  {
    v6 = j_va("AISetDesiredSpeed: speed cannot be negative. (%.2f)", v5);
    Scr_Error(COM_ERR_3869, scrContext, v6);
  }
  if ( *(float *)&Float > 300.0 )
  {
    v7 = j_va("AISetDesiredSpeed: speed way larger than anything we were expecting: %.2f", v5);
    Scr_Error(COM_ERR_3870, scrContext, v7);
  }
  this->m_pAI->script_desiredSpeed = *(float *)&Float;
  this->m_pAI->script_desiredSpeedEnabled = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMaxDist
==============
*/
void AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  double v5; 
  ai_scripted_t *m_pAI; 
  float engageMaxFalloffDist; 
  float engageMaxDist; 
  const char *v9; 

  Float = Scr_GetFloat(scrContext, 0);
  this->m_pAI->nodeSelect.engageMaxDist = *(float *)&Float;
  v5 = Scr_GetFloat(scrContext, 1u);
  this->m_pAI->nodeSelect.engageMaxFalloffDist = *(float *)&v5;
  m_pAI = this->m_pAI;
  engageMaxFalloffDist = m_pAI->nodeSelect.engageMaxFalloffDist;
  engageMaxDist = m_pAI->nodeSelect.engageMaxDist;
  if ( engageMaxFalloffDist < engageMaxDist )
  {
    v9 = j_va("Max dist falloff must be >= max dist. [%f > %f]", engageMaxDist, engageMaxFalloffDist);
    Scr_Error(COM_ERR_3896, scrContext, v9);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMinDist
==============
*/
void AIScriptedInterface::OnScrCmd_SetEngagementMinDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  double v5; 
  ai_scripted_t *m_pAI; 
  float engageMinFalloffDist; 
  float engageMinDist; 
  const char *v9; 

  Float = Scr_GetFloat(scrContext, 0);
  this->m_pAI->nodeSelect.engageMinDist = *(float *)&Float;
  v5 = Scr_GetFloat(scrContext, 1u);
  this->m_pAI->nodeSelect.engageMinFalloffDist = *(float *)&v5;
  m_pAI = this->m_pAI;
  engageMinFalloffDist = m_pAI->nodeSelect.engageMinFalloffDist;
  engageMinDist = m_pAI->nodeSelect.engageMinDist;
  if ( engageMinFalloffDist > engageMinDist )
  {
    v9 = j_va("Min dist falloff must be <= min dist. [%f < %f]", engageMinDist, engageMinFalloffDist);
    Scr_Error(COM_ERR_3895, scrContext, v9);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEntityTarget
==============
*/
void AIScriptedInterface::OnScrCmd_SetEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  sentient_s *v5; 
  double Float; 
  float v7; 
  gentity_s *v8; 
  const char *v9; 

  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4976, ASSERT_TYPE_ASSERT, "(targetEnt)", (const char *)&queryFormat, "targetEnt") )
    __debugbreak();
  if ( Entity->sentient )
    Scr_Error(COM_ERR_3898, scrContext, "Do not use setentitytarget to set an AI or player as a target");
  v5 = this->GetSentient(this);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4983, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  EntHandle::setEnt(&v5->scriptTargetEnt, Entity);
  v5->scriptTargetHasTagEye = SV_Game_DObjGetBoneIndex(Entity, scr_const.tag_eye) >= 0;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    v5->entityTargetThreat = 1.0;
LABEL_16:
    Sentient_SetEnemy(v5, Entity, 1, 1);
    return;
  }
  Float = Scr_GetFloat(scrContext, 1u);
  v7 = *(float *)&Float;
  if ( *(float *)&Float <= 0.0 || *(float *)&Float > 1.0 )
  {
    v8 = this->GetEntity(this);
    v9 = j_va("Threat fraction must be in (0, 1] for AI %d", (unsigned int)v8->s.number);
    Scr_Error(COM_ERR_3899, scrContext, v9);
    I_fclamp(*(float *)&Float, 0.0, 1.0);
  }
  v5->entityTargetThreat = v7;
  if ( v7 == 1.0 )
    goto LABEL_16;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndex
==============
*/
void AIScriptedInterface::OnScrCmd_SetFacialIndex(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned __int8 v5; 
  const char *String; 
  const char *v7; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = AI_StringToFacialIndex(ConstString);
  if ( v5 == 12 )
  {
    String = Scr_GetString(scrContext, 0);
    v7 = j_va("Unknown facial state %s", String);
    Scr_Error(COM_ERR_5691, scrContext, v7);
  }
  this->m_pAI->animData.facialIndex = v5;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM
==============
*/
void AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  scr_string_t AnimsetName; 
  Animset *v11; 
  const char *name; 
  const char *String; 
  const char *v14; 
  int Int; 
  DObj *ServerDObjForEnt; 
  unsigned __int16 index; 
  __int64 v18; 
  unsigned int numAnimAliases; 
  AnimsetAlias *animAliases; 
  __int64 v21; 
  unsigned int numAnims; 
  const char *v23; 
  const char *v24; 
  const char *v25; 
  int pOutStateIndex; 
  AnimsetState *outState; 

  number = this->m_pAI->ent->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)this->m_pAI->ent->s.number);
    Scr_Error(COM_ERR_6494, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4729, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name == ConstString )
  {
    AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
    v11 = Animset_Find(AnimsetName);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4735, ASSERT_TYPE_ASSERT, "( pAnimset )", (const char *)&queryFormat, "pAnimset") )
      __debugbreak();
    outState = NULL;
    if ( !BG_Animset_GetStateInfoByName(v11, v9, &outState, &pOutStateIndex) )
    {
      name = v11->name;
      String = Scr_GetString(scrContext, 1u);
      v14 = j_va("Unable to find state %s in animset %s", String, name);
      Scr_Error(COM_ERR_6495, scrContext, v14);
    }
    if ( Scr_GetType(scrContext, 2u) )
    {
      if ( Scr_GetType(scrContext, 2u) == VAR_INTEGER )
      {
        Int = Scr_GetInt(scrContext, 2u);
      }
      else
      {
        ServerDObjForEnt = Com_GetServerDObjForEnt(this->m_pAI->ent);
        if ( !ServerDObjForEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4754, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
          __debugbreak();
        index = Scr_GetAnim(scrContext, 2u, ServerDObjForEnt->tree).index;
        Int = 0;
        v18 = 0i64;
        numAnimAliases = outState->numAnimAliases;
        if ( numAnimAliases )
        {
          animAliases = outState->animAliases;
          while ( 1 )
          {
            v21 = 0i64;
            numAnims = animAliases[v18].numAnims;
            if ( numAnims )
              break;
LABEL_24:
            v18 = (unsigned int)(v18 + 1);
            if ( (unsigned int)v18 >= numAnimAliases )
              goto LABEL_25;
          }
          while ( animAliases[v18].anims[v21].anim.index != index )
          {
            ++Int;
            v21 = (unsigned int)(v21 + 1);
            if ( (unsigned int)v21 >= numAnims )
              goto LABEL_24;
          }
        }
        else
        {
LABEL_25:
          v23 = v11->name;
          v24 = Scr_GetString(scrContext, 1u);
          v25 = j_va("Unable to find anim in state %s in animset %s", v24, v23);
          Scr_Error(COM_ERR_6496, scrContext, v25);
        }
      }
    }
    else
    {
      Int = -1;
    }
    AIScriptedInterface::SetFacialIndexFromASM(this, Instance, v11, pOutStateIndex, Int);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  float v4; 
  float v5; 

  Entity = GScr_GetEntity(0);
  EntHandle::setEnt(&this->m_pAI->fixedNodeSafeVolume, Entity);
  v4 = COERCE_FLOAT(LODWORD(Entity->r.box.midPoint.v[0]) & _xmm) + Entity->r.box.halfSize.v[0];
  v5 = COERCE_FLOAT(LODWORD(Entity->r.box.midPoint.v[1]) & _xmm) + Entity->r.box.halfSize.v[1];
  this->m_pAI->fixedNodeSafeVolumeRadiusSq = (float)(v4 * v4) + (float)(v5 * v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFlashBanged
==============
*/
void AIScriptedInterface::OnScrCmd_SetFlashBanged(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  AIScriptedInterface::SetFlashed(this, Int == 1);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalEntity
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalEntity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 

  Entity = GScr_GetEntity(0);
  this->ClearKeepClaimedNode(this);
  AIScriptedInterface::SetScriptGoalEntity(this, Entity);
  if ( Scr_GetNumParam(scrContext) > 1 )
    this->m_pAI->scriptGoal.entUpdateInterval = Scr_GetInt(scrContext, 1u);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalNode
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  const char *v5; 
  gentity_s *v6; 
  const char *v7; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  pathnode_t::GetPos(Pathnode, &pos);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &pos, Pathnode) )
  {
    v5 = vtos(&pos);
    v6 = this->GetEntity(this);
    v7 = j_va("SetGoalNode( ent %d, node pos %s ) : Unable to find navmesh in this area.  Either no mesh is loaded, or this is a moving platform where all of the mesh has been invalidated due to an obstacle.", (unsigned int)v6->s.number, v5);
    Scr_Error(COM_ERR_3842, scrContext, v7);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPath
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface *v2; 
  pathnode_t *NodeFromEntref; 
  unsigned int ArrayObject; 
  int ArraySize; 
  int v7; 
  const char *v8; 
  int v9; 
  unsigned int LastSibling; 
  float *v11; 
  VariableUnion u; 
  float v13; 
  int v14; 
  unsigned int Object; 
  const char *v16; 
  const char *v17; 
  scr_entref_t EntityIdRef; 
  const char *v19; 
  AINavigator *pNavigator; 
  vec3_t *p_origin; 
  float *v22; 
  __int64 v23; 
  float v24; 
  const char *v25; 
  const char *v26; 
  VariableValue out; 
  AIScriptedInterface *v28; 
  vec3_t origin; 
  char v30; 

  v2 = this;
  v28 = this;
  NodeFromEntref = NULL;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v7 = ArraySize;
  if ( ArraySize > 16 )
  {
    v8 = j_va("SetGoalPath: %d exceeds max allowed scripted path points (%d)", (unsigned int)ArraySize, 16i64);
    Scr_Error(COM_ERR_3844, scrContext, v8);
  }
  v9 = 0;
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  LastSibling = FindLastSibling(scrContext, ArrayObject);
  if ( LastSibling )
  {
    v11 = &origin.v[2];
    do
    {
      Scr_EvalVariable_Out(scrContext, LastSibling, &out);
      if ( out.type == VAR_VECTOR )
      {
        u = out.u;
        v13 = *(float *)(out.u.scriptCodePosValue + 8);
        v14 = *(_DWORD *)out.u.vectorValue;
        *(v11 - 1) = *(float *)(out.u.scriptCodePosValue + 4);
        *v11 = v13;
        *((_DWORD *)v11 - 2) = v14;
        RemoveRefToValue(scrContext, 4, u);
      }
      else if ( out.type == VAR_POINTER )
      {
        Object = FindObject(scrContext, LastSibling);
        if ( !Object )
        {
          RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
          RemoveRefToObject(scrContext, ArrayObject);
          v16 = j_va("SetGoalPath: Invalid object %d in array.", (unsigned int)v9);
          Scr_Error(COM_ERR_3845, scrContext, v16);
        }
        if ( !Scr_GetObjectOrigin(scrContext, Object, &origin + v9) )
        {
          RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
          RemoveRefToObject(scrContext, ArrayObject);
          v17 = j_va("SetGoalPath: Unable to find origin vector in object %d in array.", (unsigned int)v9);
          Scr_Error(COM_ERR_3846, scrContext, v17);
        }
        if ( v9 == v7 - 1 && GetObjectType(scrContext, Object) == VAR_ENTITY )
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, Object);
          if ( EntityIdRef.entclass == ENTITY_CLASS_PATHNODE )
            NodeFromEntref = Path_GetNodeFromEntref(scrContext, EntityIdRef);
        }
        RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      }
      else
      {
        RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
        RemoveRefToObject(scrContext, ArrayObject);
        v19 = j_va("SetGoalPath: array element %d is not a vector.", (unsigned int)v9);
        Scr_Error(COM_ERR_3847, scrContext, v19);
      }
      ++v9;
      v11 += 3;
      LastSibling = FindPrevSibling(scrContext, LastSibling);
    }
    while ( LastSibling );
    v2 = v28;
  }
  RemoveRefToObject(scrContext, ArrayObject);
  if ( !v9 )
    Scr_Error(COM_ERR_3848, scrContext, "SetGoalPath: no path points provided.");
  pNavigator = v2->m_pAI->pNavigator;
  if ( !pNavigator || pNavigator->Get3DNavigator(pNavigator) )
    Scr_Error(COM_ERR_3849, scrContext, "SetGoalPath called on ent with invalid/unsupported navigator type.");
  if ( v9 > 1 && v9 - 1 > 0 )
  {
    p_origin = &origin;
    v22 = (float *)&v30;
    v23 = (unsigned int)(v9 - 1);
    do
    {
      if ( (float)((float)(*(v22 - 3) - *v22) * (float)(*(v22 - 3) - *v22)) <= 0.0000010000001 )
      {
        v24 = *(v22 - 2) - v22[1];
        if ( (float)(v24 * v24) <= 0.0000010000001 )
        {
          v25 = vtos(p_origin);
          v26 = j_va("SetGoalPath called with duplicated path point %s", v25);
          Scr_Error(COM_ERR_3850, scrContext, v26);
        }
      }
      ++p_origin;
      v22 += 3;
      --v23;
    }
    while ( v23 );
    v2 = v28;
  }
  AIScriptedInterface::SetScriptGoalPath(v2, &origin, v9);
  if ( NodeFromEntref )
  {
    v2->m_pAI->nodeSelect.keepClaimedNode = 0;
    v2->m_pAI->scriptGoal.node = NodeFromEntref;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v4; 
  gentity_s *v5; 
  const char *v6; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &vectorValue, NULL) )
  {
    v4 = vtos(&vectorValue);
    v5 = this->GetEntity(this);
    v6 = j_va("SetGoalPos( ent %d, pos %s ) : Unable to find navmesh at this position.  Either there is no mesh loaded, or this is a moving platform where the whole mesh has been invalidated by an obstacle.", (unsigned int)v5->s.number, v4);
    Scr_Error(COM_ERR_3843, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v4; 
  ai_scripted_t *m_pAI; 
  gentity_s *Entity; 
  unsigned int Instance; 
  const char *v8; 
  unsigned int number; 
  const char *v10; 
  const char *v11; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hEnt) )
  {
    v4 = j_va("Cannot set goal volume when a goal entity is set. AI: %d", (unsigned int)this->m_pAI->ent->s.number);
    Scr_Error(COM_ERR_3851, scrContext, v4);
  }
  m_pAI = this->m_pAI;
  if ( m_pAI->fixedNode )
    Com_PrintError(18, "Setting goal volume for fixed node AI: %d\n", (unsigned int)m_pAI->ent->s.number);
  Entity = GScr_GetEntity(0);
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, Entity);
  if ( !PhysicsQuery_LegacyEntityContactPoint(PHYSICS_WORLD_ID_FIRST, &this->m_pAI->scriptGoal.pos, Instance, Entity) )
  {
    v8 = vtos(&this->m_pAI->scriptGoal.pos);
    number = this->m_pAI->ent->s.number;
    v10 = vtos(&Entity->r.currentOrigin);
    v11 = j_va("Cannot set goal volume (%s) on AI %d which does not contain goal position %s.", v10, number, v8);
    Scr_Error(COM_ERR_3852, scrContext, v11);
  }
  this->ClearKeepClaimedNode(this);
  AIScriptedInterface::SetScriptGoalVolume(this, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int128 v2; 
  gentity_s *Entity; 
  const char *v6; 
  const char *v7; 
  __int128 v8; 
  __int128 v11; 
  pathnode_t *BestCover; 
  pathnode_t *v16; 
  float outBestScore; 
  vec3_t vectorValue; 
  CoverNodeMetricParams metricParams; 
  __int128 v20; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hEnt) )
    Scr_Error(COM_ERR_3853, scrContext, "cannot set goal volume when a goal entity is set");
  Entity = GScr_GetEntity(0);
  EntHandle::setEnt(&this->m_pAI->scriptGoal.hVolume, NULL);
  if ( !Scr_IsTouchingInternal(scrContext, this->m_pAI->ent, Entity) )
    this->ClearKeepClaimedNode(this);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &Entity->r.absBox.midPoint, NULL) )
  {
    v6 = vtos(&Entity->r.absBox.midPoint);
    v7 = j_va("SetGoalVolumeAuto( ent %d, vol midpt %s ): Unable to find navmesh at this position.  Either no mesh is loaded, or this is a moving platform that has had all of its mesh invalidated.", (unsigned int)this->m_pAI->ent->s.number, v6);
    Scr_Error(COM_ERR_3854, scrContext, v7);
  }
  v8 = LODWORD(Entity->r.absBox.halfSize.v[0]);
  *(float *)&v8 = fsqrt((float)(Entity->r.absBox.halfSize.v[0] * Entity->r.absBox.halfSize.v[0]) + (float)(Entity->r.absBox.halfSize.v[1] * Entity->r.absBox.halfSize.v[1])) + 15.0;
  _XMM3 = v8;
  __asm { vmaxss  xmm1, xmm3, cs:__real@42800000 }
  this->m_pAI->scriptGoal.radius = *(float *)&_XMM1;
  this->m_pAI->scriptGoal.height = Entity->r.absBox.halfSize.v[2] + 36.0;
  AIScriptedInterface::SetScriptGoalVolume(this, Entity);
  if ( !AICommonInterface::GetTargetEntity(this) && Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
  {
    if ( Scr_GetType(scrContext, 1u) == VAR_VECTOR )
    {
      v20 = v2;
      Scr_GetVector(scrContext, 1u, &vectorValue);
      v11 = LODWORD(vectorValue.v[0]);
      *(float *)&v11 = fsqrt((float)((float)(*(float *)&v11 * *(float *)&v11) + (float)(vectorValue.v[1] * vectorValue.v[1])) + (float)(vectorValue.v[2] * vectorValue.v[2]));
      _XMM3 = v11;
      __asm
      {
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
      }
      vectorValue.v[0] = vectorValue.v[0] * (float)(1.0 / *(float *)&_XMM0);
      vectorValue.v[2] = vectorValue.v[2] * (float)(1.0 / *(float *)&_XMM0);
      vectorValue.v[1] = vectorValue.v[1] * (float)(1.0 / *(float *)&_XMM0);
      AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
      *(float *)&v11 = fsqrt((float)((float)(Entity->r.absBox.halfSize.v[0] * Entity->r.absBox.halfSize.v[0]) + (float)(Entity->r.absBox.halfSize.v[1] * Entity->r.absBox.halfSize.v[1])) + (float)(Entity->r.absBox.halfSize.v[2] * Entity->r.absBox.halfSize.v[2])) * 4.0;
      metricParams.lastKnownEnemyOrigin.v[0] = (float)(*(float *)&v11 * vectorValue.v[0]) + Entity->r.currentOrigin.v[0];
      metricParams.lastKnownEnemyOrigin.v[1] = (float)(*(float *)&v11 * vectorValue.v[1]) + Entity->r.currentOrigin.v[1];
      *(float *)&v11 = (float)(*(float *)&v11 * vectorValue.v[2]) + Entity->r.currentOrigin.v[2];
      metricParams.lastKnownValid = 1;
      metricParams.lastKnownEnemyOrigin.v[2] = *(float *)&v11;
      AIScriptedInterface::UpdateGoalPos(this);
      BestCover = AIScriptedInterface::Cover_FindBestCover(this, (scr_string_t)0, 0, 0, &metricParams, &outBestScore);
      v16 = BestCover;
      if ( BestCover )
      {
        if ( BestCover != this->m_pAI->sentient->pClaimedNode )
        {
          this->ClearKeepClaimedNode(this);
          AIScriptedInterface::Cover_UseCoverNode(this, v16);
        }
      }
    }
    else
    {
      Scr_Error(COM_ERR_3855, scrContext, "SetGoalVolumeAuto: Parameter 1 must be a vector or undefined.");
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGunAdditive
==============
*/
void AIScriptedInterface::OnScrCmd_SetGunAdditive(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  if ( !this->m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4659, ASSERT_TYPE_ASSERT, "( m_pAI )", (const char *)&queryFormat, "m_pAI") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.gun_additive_disable )
  {
    this->m_pAI->animData.gunAdditiveIndex = 0;
  }
  else if ( ConstString == scr_const.gun_additive_gun_down )
  {
    this->m_pAI->animData.gunAdditiveIndex = 1;
  }
  else if ( ConstString == scr_const.gun_additive_ready )
  {
    this->m_pAI->animData.gunAdditiveIndex = 2;
  }
  else if ( ConstString == scr_const.gun_additive_ads )
  {
    this->m_pAI->animData.gunAdditiveIndex = 3;
  }
  else
  {
    Scr_Error(COM_ERR_3897, scrContext, " Invalid argument to SetGunAdditive(), check function description for valid options ");
  }
}

/*
==============
AICommonInterface::OnScrCmd_SetNavLayer
==============
*/
void AICommonInterface::OnScrCmd_SetNavLayer(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v3; 
  scr_string_t ConstLowercaseString; 
  unsigned int v5; 
  const char *String; 
  unsigned int LayersLoaded; 
  const char *v8; 
  const char *v9; 

  v3 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v3 )
    Scr_Error(COM_ERR_3866, scrContext, "SetNavLayer - only applies to 2D navigators.");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v5 = -1;
  if ( ConstLowercaseString == scr_const.human )
  {
    v5 = 0;
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    if ( I_stricmp(String, "superslasher") )
      Scr_Error(COM_ERR_3867, scrContext, "SetNavLayer - unknown nav layer name.");
    else
      v5 = 1;
  }
  LayersLoaded = bfx::GetLayersLoaded();
  if ( !_bittest((const int *)&LayersLoaded, v5) )
  {
    v8 = SL_ConvertToString(ConstLowercaseString);
    v9 = j_va("SetNavLayer - no navmesh present for layer %s", v8);
    Scr_Error(COM_ERR_3868, scrContext, v9);
  }
  v3->SetLayer(v3, (AINavLayer)v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_SetOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  unsigned int v5; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  ArcOverridePriority v8; 

  v4 = 0;
  v5 = Scr_GetNumParam(scrContext) - 2;
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      Scr_Error(COM_ERR_6527, scrContext, "Invalid parameter count to setoverridearchetype");
      return;
    }
    v4 = Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v7 = Scr_GetConstString(scrContext, 1u);
  v8 = AI_StringToArcOverridePriority(ConstString);
  if ( v8 == ARC_PRIORITY_COUNT )
    Scr_Error(COM_ERR_6528, scrContext, "invalid priority string");
  else
    AIScriptedInterface::SetOverrideArchetype(this, v8, v7, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPitchOrient
==============
*/
void AIScriptedInterface::OnScrCmd_SetPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ProneInfo.prone = 1;
  this->m_pAI->ProneInfo.orientPitch = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPotentialThreat
==============
*/
void AIScriptedInterface::OnScrCmd_SetPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 

  if ( !this->m_pAI || Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3890, scrContext, "illegal call to SetPotentialThreat()");
  if ( this->Is3D(this) )
    Scr_Error(COM_ERR_3891, scrContext, "3D actors cannot use SetPotentialThreat()");
  Float = Scr_GetFloat(scrContext, 0);
  AIScriptedInterface::SetPotentialThreat(this, *(float *)&Float);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon
==============
*/
void AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  this->SetRiotshieldWeapon(this, &outWeapon);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetSpeedScaleMode
==============
*/
void AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  const char *v6; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.none )
  {
    this->m_pAI->speedScaleMode[0] = 0;
  }
  else if ( ConstString == scr_const.speed )
  {
    this->m_pAI->speedScaleMode[0] = 1;
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.desiredspeed);
  }
  else if ( ConstString == scr_const.strafe )
  {
    this->m_pAI->speedScaleMode[0] = 2;
    AIScriptedInterface::DecideOrientation(this);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.desiredspeed);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.groundslope);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.strafeyaw);
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = j_va("invalid speedscale mode %s. supports none, speed, strafe.", String);
    Scr_Error(COM_ERR_3871, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetStrafeReverse
==============
*/
void AIScriptedInterface::OnScrCmd_SetStrafeReverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = Scr_GetInt(scrContext, 0) != 0;
  *(_BYTE *)(this->GetAI(this) + 1742) = v3;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetTargetSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_SetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 

  Float = Scr_GetFloat(scrContext, 0);
  this->m_pAI->animData.desiredSpeed = *(float *)&Float;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupDoorOpen
==============
*/
void AIScriptedInterface::OnScrCmd_SetupDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v4; 
  double Float; 
  float v6; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  unsigned __int8 v12; 
  scr_string_t NearestSpeedThresholdString; 
  scr_string_t soldier; 
  scr_string_t v15; 
  __int64 *v16; 
  int v17; 
  const char *String; 
  const char *v19; 
  int v20; 
  vec3_t outModifierDir; 
  vec3_t outApproachDir; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  __int64 v25[4]; 
  __int64 v26[4]; 
  __int64 v27[5]; 
  __int64 v28[6]; 

  if ( !AICommonInterface::HasPath(this) )
    Scr_Error(COM_ERR_5727, scrContext, "Cannot setup door open on AI without a path.");
  v4 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v4 )
    Scr_Error(COM_ERR_5725, scrContext, "Cannot setup door on non-2D navigator");
  Float = Scr_GetFloat(scrContext, 1u);
  if ( AINavigator2D::GetModifierApproachDir(v4, 0x10000000u, 200.0, *(float *)&Float, &outStartPoint, &outEndPoint, &outApproachDir, &outModifierDir) )
  {
    v8 = outModifierDir.v[2];
    v7 = outModifierDir.v[1];
    v6 = outModifierDir.v[0];
    v10 = outApproachDir.v[2];
    v9 = outApproachDir.v[1];
    v11 = outApproachDir.v[0];
  }
  else
  {
    v6 = FLOAT_1_0;
    v7 = 0.0;
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    outModifierDir.v[0] = FLOAT_1_0;
    outModifierDir.v[1] = 0.0;
    outModifierDir.v[2] = 0.0;
    outApproachDir.v[0] = FLOAT_1_0;
    outApproachDir.v[1] = 0.0;
    outApproachDir.v[2] = 0.0;
    v11 = FLOAT_1_0;
  }
  if ( (float)((float)((float)(v9 * v7) + (float)(v11 * v6)) + (float)(v10 * v8)) <= 0.866 )
  {
    v12 = 3;
    if ( (float)((float)(COERCE_FLOAT(LODWORD(v9) ^ _xmm) * v6) - (float)(COERCE_FLOAT(LODWORD(v11) ^ _xmm) * v7)) > 0.0 )
      v12 = 1;
    this->m_pAI->animData.doorIndex = v12;
  }
  else
  {
    this->m_pAI->animData.doorIndex = 2;
  }
  NearestSpeedThresholdString = GetNearestSpeedThresholdString(this->m_pAI->baseArchetype, this->m_pAI->animData.desiredSpeed);
  soldier = scr_const.soldier;
  v28[5] = (__int64)&scr_const.run;
  v27[4] = (__int64)&scr_const.run;
  v25[3] = (__int64)&scr_const.run;
  v15 = NearestSpeedThresholdString;
  v26[3] = (__int64)&scr_const.run;
  v28[0] = (__int64)&scr_const.none;
  v28[1] = (__int64)&scr_const.shuffle;
  v28[2] = (__int64)&scr_const.walk;
  v28[3] = (__int64)&scr_const.fast;
  v27[2] = (__int64)&scr_const.fast;
  v28[4] = (__int64)&scr_const.jog;
  v27[0] = (__int64)&scr_const.none;
  v27[1] = (__int64)&scr_const.walk;
  v27[3] = (__int64)&scr_const.jog;
  v25[0] = (__int64)&scr_const.none;
  v25[1] = (__int64)&scr_const.walk;
  v25[2] = (__int64)&scr_const.jog;
  v26[0] = (__int64)&scr_const.none;
  v26[1] = (__int64)&scr_const.walk;
  v26[2] = (__int64)&scr_const.jog;
  if ( Scr_GetNumParam(scrContext) > 2 )
    soldier = Scr_GetConstString(scrContext, 2u);
  v16 = v28;
  v17 = 6;
  if ( soldier == scr_const.civilian )
  {
    v16 = v27;
    v17 = 5;
  }
  else if ( soldier == scr_const.civilian_panic )
  {
    v16 = v25;
    v17 = 4;
  }
  else if ( soldier == scr_const.juggernaut )
  {
    v16 = v26;
    v17 = 4;
  }
  else if ( soldier != scr_const.soldier )
  {
    String = Scr_GetString(scrContext, 2u);
    v19 = j_va("Unsupported door-open lookup type %s", String);
    Scr_Error(COM_ERR_5728, scrContext, v19);
  }
  v20 = 0;
  while ( v15 != *(_DWORD *)v16[v20] )
  {
    if ( ++v20 >= v17 )
      return;
  }
  this->m_pAI->animData.doorSpeedIndex = v20;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn
==============
*/
void AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  vec3_t v5; 
  vec3_t v6; 
  vec3_t v7; 
  vec3_t v8; 
  vec3_t v9; 
  vec3_t v10; 
  vec3_t v11; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &v11);
  Scr_GetVector(scrContext, 2u, &v10);
  Scr_GetVector(scrContext, 3u, &v9);
  Float = Scr_GetFloat(scrContext, 4u);
  v5 = v9;
  v6 = v10;
  v7 = v11;
  v8 = vectorValue;
  AIScriptedInterface::SetupMotionWarpForTurn(this, &v8, &v7, &v6, &v5, *(float *)&Float);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShootBlank
==============
*/
void AIScriptedInterface::OnScrCmd_ShootBlank(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const Weapon *Weapon; 
  bool IsAlternate; 
  const char *WeaponNameComplete; 
  const char *v7; 
  char output[1024]; 

  Weapon = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)this->m_pAI->currentWeapon);
  IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)this->m_pAI->currentWeapon);
  if ( BG_GetWeaponType(Weapon, IsAlternate) != WEAPTYPE_BULLET )
  {
    WeaponNameComplete = BG_GetWeaponNameComplete(Weapon, IsAlternate, output, 0x400u);
    v7 = j_va("ShootBlank() only works with bullet weapons.  Using weapon [%s]", WeaponNameComplete);
    Scr_Error(COM_ERR_3885, scrContext, v7);
  }
  AIScriptedInterface::ShootBlank(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe
==============
*/
void AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool ShouldCautiousStrafe; 

  ShouldCautiousStrafe = AIScriptedInterface::ShouldCautiousStrafe(this);
  Scr_AddBool(scrContext, ShouldCautiousStrafe);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartBeam
==============
*/
void AIScriptedInterface::OnScrCmd_StartBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned int NumParam; 
  ai_scripted_t *m_pAI; 
  const gentity_s *Entity; 

  NumParam = Scr_GetNumParam(scrContext);
  m_pAI = this->m_pAI;
  if ( NumParam )
    Entity = GScr_GetEntity(0);
  else
    Entity = NULL;
  EntHandle::setEnt(&m_pAI->pBeamTargetEnt, Entity);
  this->m_pAI->bContinuousFire = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_StartCoverArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::StartArrivalState(this, AIS_BEHAVE);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartTraverseArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartTraverseArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  double Float; 
  const char *v5; 
  pathnode_t *StartNodeFromLink; 
  const char *v7; 
  ComErrorCode v8; 
  nav_posAlongPathResults_t pResults; 

  Float = Scr_GetFloat(scrContext, 0);
  bfx::AreaHandle::AreaHandle(&pResults.m_hArea);
  bfx::LinkHandle::LinkHandle(&pResults.m_hLink);
  if ( !Nav_GetPosAlongPath(this->m_pAI->pNavigator, *(float *)&Float, 1, &pResults) )
  {
    v7 = "AI cannot start traverse when there is no path.";
    v8 = COM_ERR_5660;
    goto LABEL_16;
  }
  if ( !bfx::LinkHandle::IsValid(&pResults.m_hLink) )
  {
    v5 = j_va("Unable to find valid traverse within %.f units down the path.", *(float *)&Float);
    Scr_Error(COM_ERR_5909, scrContext, v5);
  }
  StartNodeFromLink = Nav_GetStartNodeFromLink(&pResults.m_hLink);
  if ( !StartNodeFromLink )
    Scr_Error(COM_ERR_5658, scrContext, "Unable to find start node for traverse.");
  if ( !AIScriptedInterface::PushState(this, AIS_NEGOTIATION) )
  {
    v7 = "Failed to properly start negotiation.";
    v8 = COM_ERR_5659;
LABEL_16:
    Scr_Error(v8, scrContext, v7);
    goto LABEL_17;
  }
  bfx::LinkHandle::operator=(&this->m_pAI->pNavigator->m_hLink, &pResults.m_hLink);
  if ( ((1 << LOBYTE(StartNodeFromLink->constant.type)) & 0x68010000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5239, ASSERT_TYPE_ASSERT, "( Path_IsNegotiationBegin( pStartNode ) )", (const char *)&queryFormat, "Path_IsNegotiationBegin( pStartNode )", -2i64) )
    __debugbreak();
  if ( !StartNodeFromLink->constant.animscript && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5240, ASSERT_TYPE_ASSERT, "( pStartNode->constant.animscript != ( static_cast< scr_string_t >( 0 ) ) )", (const char *)&queryFormat, "pStartNode->constant.animscript != NULL_SCR_STRING") )
    __debugbreak();
  Scr_SetString(&this->m_pAI->traverseName, StartNodeFromLink->constant.animscript);
  this->m_pAI->bInTraverseState = 1;
LABEL_17:
  bfx::LinkHandle::~LinkHandle(&pResults.m_hLink);
  bfx::AreaHandle::~AreaHandle(&pResults.m_hArea);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartZeroArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arrivalTimeLeft = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_StopBeam
==============
*/
void AIScriptedInterface::OnScrCmd_StopBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ClearLookAtEntity(this);
  this->m_pAI->bContinuousFire = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateAimInfo
==============
*/
void AIScriptedInterface::OnScrCmd_UpdateAimInfo(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *TargetSentient; 
  int CanSeeEnemy; 
  const gentity_s *ent; 
  const sentient_s *sentient; 
  bool v8; 
  ai_scripted_t *m_pAI; 
  const tacpoint_t *v10; 
  const tacpoint_t *v11; 
  pathnode_t *CoverNode; 
  ai_scripted_t *v13; 
  ai_scripted_t *v14; 
  double v15; 
  float v16; 
  ai_scripted_t *v19; 
  gentity_s *v20; 
  ai_scripted_t *v21; 
  int v22; 
  __int128 v23; 
  sentient_s *v24; 
  pathnode_t *pClaimedNode; 
  ai_scripted_t *v26; 
  double Angle; 
  double v28; 
  __int128 v29; 
  ai_scripted_t *v30; 
  gentity_s *v31; 
  const vec4_t *v32; 
  vec3_t *p_outEyePos; 
  pathnode_t *PrevCoverNode; 
  double v35; 
  gentity_s *v36; 
  const tacpoint_t *pTargetPoint; 
  gentity_s *v38; 
  const tacpoint_t *ClosestPointWithVisWithinConeWithinRadius; 
  const vec3_t *p_m_Pos; 
  ai_scripted_t *v41; 
  const tacpoint_t *ClosestPointWithoutVisWithinConeWithinRadius; 
  const tacpoint_t *v43; 
  ai_scripted_t *v44; 
  bool v45; 
  ai_scripted_t *v46; 
  AINavigator2D *v47; 
  const bfx::AreaHandle *CurArea; 
  double v49; 
  int BestSlice; 
  ai_scripted_t *v51; 
  gentity_s *v52; 
  vec3_t outLastKnownPos; 
  vec3_t forward; 
  vec3_t outEyePos; 
  vec3_t outPos; 
  bitarray<224> result; 
  char v58[16]; 
  float pResults[14]; 

  Sys_ProfBeginNamedEvent(0xFF808080, "UpdateAimInfo");
  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( this->InScriptedState(this) || this->IsInPain(this) )
    goto LABEL_78;
  if ( TargetSentient )
  {
    CanSeeEnemy = AICommonInterface::CanSeeEnemy(this);
    ent = TargetSentient->ent;
    if ( CanSeeEnemy )
    {
LABEL_17:
      Scr_AddVector(scrContext, ent->r.currentOrigin.v);
      goto LABEL_78;
    }
    Sentient_GetLastKnownEnemyPos(this->m_pAI->sentient, ent, &outLastKnownPos);
    outLastKnownPos.v[2] = outLastKnownPos.v[2] + 50.0;
    if ( AICommonInterface::HasPath(this) || AICommonInterface::RecentlySeeEnemy(this) )
      goto LABEL_76;
    sentient = TargetSentient->ent->sentient;
    if ( sentient )
      v8 = level.time - Sentient_GetSentientInfo(this->m_pAI->sentient, sentient)->lastKnownPosTime < 10000;
    else
      v8 = AICommonInterface::RecentlySeeSentient(this, TargetSentient, 10000) != 0;
    if ( v8 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH_ADS) )
      {
        m_pAI = this->m_pAI;
        if ( !m_pAI->combat.doingAmbush )
        {
          v10 = Sentient_NearestTacPoint(m_pAI->sentient);
          v11 = Sentient_NearestTacPoint(TargetSentient);
          if ( v10 )
          {
            if ( v11 && TacVisGraph_HasVis(v10, v11) )
            {
              ent = TargetSentient->ent;
              goto LABEL_17;
            }
          }
        }
      }
      if ( AIScriptedInterface::GetAnglesToLikelyEnemyPath(this) )
      {
        forward = this->m_pAI->sight.faceLikelyEnemyCornerPos;
        AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 1);
        forward.v[2] = forward.v[2] + 50.0;
        if ( (float)((float)((float)(forward.v[1] - outEyePos.v[1]) * (float)(forward.v[1] - outEyePos.v[1])) + (float)((float)(forward.v[0] - outEyePos.v[0]) * (float)(forward.v[0] - outEyePos.v[0]))) > 1024.0 )
        {
LABEL_36:
          Scr_AddVector(scrContext, forward.v);
          goto LABEL_78;
        }
      }
    }
  }
  CoverNode = AIScriptedInterface::GetCoverNode(this);
  if ( AICommonInterface::HasPath(this) || CoverNode && this->m_pAI->sentient->pClaimedNode || (v13 = this->m_pAI, v13->arrivalInfo.arriving) || v13->sentient->eTeam != TEAM_TWO || AIScriptedInterface::IsDoingReacquire(this) || !EntHandle::isDefined(&this->m_pAI->grenade.pGrenade) && (v14 = this->m_pAI, !v14->fixedNodeNudged) && (!v14->fixedNode || AIScriptedInterface::IsFixedNodeUseable(this, 1)) )
  {
    this->m_pAI->iLastIdleFacingUseAlliesTime = 0;
    goto LABEL_78;
  }
  if ( this->m_pAI->sentient->pClaimedNode && AICommonInterface::NearClaimNode(this, 12.0) )
  {
    pathnode_t::GetAngles(this->m_pAI->sentient->pClaimedNode, &outLastKnownPos);
    if ( CoverNode )
    {
      v15 = ((double (__fastcall *)(AIScriptedInterface *, pathnode_t *))this->GetNodeAngleYawOffset)(this, CoverNode);
      v16 = (float)(*(float *)&v15 + outLastKnownPos.v[1]) * 0.0027777778;
      _XMM1 = 0i64;
      __asm { vroundss xmm0, xmm1, xmm3, 1 }
      outLastKnownPos.v[1] = (float)(v16 - *(float *)&_XMM0) * 360.0;
    }
    AngleVectors(&outLastKnownPos, &forward, NULL, NULL);
    v19 = this->m_pAI;
    v20 = v19->ent;
    forward.v[0] = (float)(120.0 * forward.v[0]) + v19->ent->r.currentOrigin.v[0];
    forward.v[1] = (float)(120.0 * forward.v[1]) + v20->r.currentOrigin.v[1];
    forward.v[2] = (float)(120.0 * forward.v[2]) + v20->r.currentOrigin.v[2];
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
      G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &forward, &colorWhite, 0);
    goto LABEL_36;
  }
  v21 = this->m_pAI;
  if ( level.time - v21->iLastIdleFacingUseAlliesTime > 1000 )
  {
    v21->iLastIdleFacingUseAlliesTime = level.time;
    v22 = 0;
    v23 = 0i64;
    Com_Teams_GetTeamFlag(&result, this->m_pAI->sentient->eTeam);
    v24 = Sentient_FirstSentient(&result);
    if ( !v24 )
      goto LABEL_48;
    do
    {
      if ( v24 != this->m_pAI->sentient )
      {
        if ( v24->ai )
        {
          pClaimedNode = v24->pClaimedNode;
          if ( pClaimedNode )
          {
            pathnode_t::GetPos(pClaimedNode, &outLastKnownPos);
            v26 = this->m_pAI;
            if ( (float)((float)((float)((float)(v26->ent->r.currentOrigin.v[1] - outLastKnownPos.v[1]) * (float)(v26->ent->r.currentOrigin.v[1] - outLastKnownPos.v[1])) + (float)((float)(v26->ent->r.currentOrigin.v[0] - outLastKnownPos.v[0]) * (float)(v26->ent->r.currentOrigin.v[0] - outLastKnownPos.v[0]))) + (float)((float)(v26->ent->r.currentOrigin.v[2] - outLastKnownPos.v[2]) * (float)(v26->ent->r.currentOrigin.v[2] - outLastKnownPos.v[2]))) <= 262144.0 )
            {
              Angle = pathnode_t::GetAngle(v24->pClaimedNode);
              v28 = AngleNormalize360(*(const float *)&Angle);
              v29 = v23;
              *(float *)&v29 = *(float *)&v23 + *(float *)&v28;
              v23 = v29;
              ++v22;
            }
          }
        }
      }
      v24 = Sentient_NextSentient(v24, &result);
    }
    while ( v24 );
    if ( v22 > 0 )
    {
      outLastKnownPos.v[0] = 0.0;
      outLastKnownPos.v[1] = *(float *)&v23 / (float)v22;
      outLastKnownPos.v[2] = 0.0;
      AngleVectors(&outLastKnownPos, &forward, NULL, NULL);
      if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
      {
        v30 = this->m_pAI;
        v31 = v30->ent;
        outEyePos.v[0] = (float)(60.0 * forward.v[0]) + v30->ent->r.currentOrigin.v[0];
        outEyePos.v[1] = (float)(60.0 * forward.v[1]) + v31->r.currentOrigin.v[1];
        outEyePos.v[2] = (float)(60.0 * forward.v[2]) + v31->r.currentOrigin.v[2];
        v32 = &colorLtOrange;
        p_outEyePos = &outEyePos;
LABEL_51:
        G_DebugLine(&v30->ent->r.currentOrigin, p_outEyePos, v32, 0);
      }
    }
    else
    {
LABEL_48:
      PrevCoverNode = AIScriptedInterface::GetPrevCoverNode(this);
      if ( !PrevCoverNode )
      {
LABEL_63:
        this->m_pAI->bCachedIdleFacingPosValid = 0;
        v21 = this->m_pAI;
LABEL_64:
        v45 = v21->pNavigator->Get2DNavigator(v21->pNavigator) == NULL;
        v46 = this->m_pAI;
        if ( v45 )
        {
          TacGraph_CalcOpenView(&v46->ent->r.currentOrigin, 128.0, pResults, 12);
        }
        else
        {
          v47 = v46->pNavigator->Get2DNavigator(v46->pNavigator);
          CurArea = AINavigator2D::GetCurArea(v47);
          TacGraph_CalcOpenView(&this->m_pAI->ent->r.currentOrigin, 128.0, CurArea, pResults, 12);
        }
        v49 = AngleNormalize360(this->m_pAI->ent->r.currentAngles.v[1]);
        if ( pResults[(float)(*(float *)&v49 * 0.033333335)] >= 64.0 )
          goto LABEL_78;
        BestSlice = FindBestSlice(pResults, 12, 36.0);
        if ( BestSlice < 0 )
        {
          BestSlice = FindBestSlice(pResults, 12, 0.0);
          if ( BestSlice < 0 )
            goto LABEL_78;
        }
        outEyePos.v[0] = 0.0;
        outEyePos.v[1] = (float)((float)BestSlice * 30.0) + 15.0;
        outEyePos.v[2] = 0.0;
        AngleVectors(&outEyePos, &forward, NULL, NULL);
        v51 = this->m_pAI;
        v52 = v51->ent;
        outLastKnownPos.v[0] = (float)(120.0 * forward.v[0]) + v51->ent->r.currentOrigin.v[0];
        outLastKnownPos.v[1] = (float)(120.0 * forward.v[1]) + v52->r.currentOrigin.v[1];
        outLastKnownPos.v[2] = (float)(120.0 * forward.v[2]) + v52->r.currentOrigin.v[2];
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &outLastKnownPos, &colorMdCyan, 0);
LABEL_76:
        Scr_AddVector(scrContext, outLastKnownPos.v);
        goto LABEL_78;
      }
      outEyePos.v[0] = 0.0;
      v35 = pathnode_t::GetAngle(PrevCoverNode);
      outEyePos.v[1] = *(float *)&v35;
      outEyePos.v[2] = 0.0;
      AngleVectors(&outEyePos, &forward, NULL, NULL);
      if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
      {
        v30 = this->m_pAI;
        v36 = v30->ent;
        outLastKnownPos.v[0] = (float)(60.0 * forward.v[0]) + v30->ent->r.currentOrigin.v[0];
        outLastKnownPos.v[1] = (float)(60.0 * forward.v[1]) + v36->r.currentOrigin.v[1];
        outLastKnownPos.v[2] = (float)(60.0 * forward.v[2]) + v36->r.currentOrigin.v[2];
        v32 = &colorPink;
        p_outEyePos = &outLastKnownPos;
        goto LABEL_51;
      }
    }
    pTargetPoint = Sentient_NearestTacPoint(this->m_pAI->sentient);
    if ( pTargetPoint )
    {
      v38 = this->m_pAI->ent;
      *(_QWORD *)outLastKnownPos.v = *(_QWORD *)v38->r.currentOrigin.v;
      outLastKnownPos.v[2] = v38->r.currentOrigin.v[2] + 60.0;
      ClosestPointWithVisWithinConeWithinRadius = TacGraph_FindClosestPointWithVisWithinConeWithinRadius(&outLastKnownPos, 60.0, 512.0, &outLastKnownPos, pTargetPoint, &forward, 0.94, 0);
      p_m_Pos = &ClosestPointWithVisWithinConeWithinRadius->m_Pos;
      if ( ClosestPointWithVisWithinConeWithinRadius )
      {
        v41 = this->m_pAI;
        v41->cachedIdleFacingUseAlliesPos.v[0] = ClosestPointWithVisWithinConeWithinRadius->m_Pos.v[0];
        v41->cachedIdleFacingUseAlliesPos.v[1] = ClosestPointWithVisWithinConeWithinRadius->m_Pos.v[1];
        v41->cachedIdleFacingUseAlliesPos.v[2] = ClosestPointWithVisWithinConeWithinRadius->m_Pos.v[2];
        this->m_pAI->bCachedIdleFacingPosValid = 1;
        Scr_AddVector(scrContext, ClosestPointWithVisWithinConeWithinRadius->m_Pos.v);
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, p_m_Pos, &colorLtYellow, 0);
        goto LABEL_78;
      }
      ClosestPointWithoutVisWithinConeWithinRadius = TacGraph_FindClosestPointWithoutVisWithinConeWithinRadius(&outLastKnownPos, 60.0, 512.0, &outLastKnownPos, pTargetPoint, &forward, 0.94, 0);
      if ( ClosestPointWithoutVisWithinConeWithinRadius )
      {
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &ClosestPointWithoutVisWithinConeWithinRadius->m_Pos, &colorLtGrey, 0);
        TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinConeWithinRadius, &outPos);
        this->m_pAI->pNavigator->GetCurPos(this->m_pAI->pNavigator, &outEyePos);
        v43 = this->m_pAI->pNavigator->FindLastTacPointOnPathWithVis(this->m_pAI->pNavigator, &outPos, pTargetPoint, &outEyePos, v58);
        if ( v43 )
        {
          if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
            G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &v43->m_Pos, &colorLtGreen, 0);
          v44 = this->m_pAI;
          v44->cachedIdleFacingUseAlliesPos.v[0] = v43->m_Pos.v[0];
          v44->cachedIdleFacingUseAlliesPos.v[1] = v43->m_Pos.v[1];
          v44->cachedIdleFacingUseAlliesPos.v[2] = v43->m_Pos.v[2];
          this->m_pAI->bCachedIdleFacingPosValid = 1;
          Scr_AddVector(scrContext, v43->m_Pos.v);
          goto LABEL_78;
        }
      }
    }
    goto LABEL_63;
  }
  if ( !v21->bCachedIdleFacingPosValid )
    goto LABEL_64;
  if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
    G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &this->m_pAI->cachedIdleFacingUseAlliesPos, &colorLtGrey, 0);
  Scr_AddVector(scrContext, this->m_pAI->cachedIdleFacingUseAlliesPos.v);
LABEL_78:
  Sys_ProfEndNamedEvent();
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateCoverExposeType
==============
*/
void AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *CoverNode; 
  double Float; 
  float v6; 
  double v7; 
  bool v8; 
  int Int; 
  ai_scripted_t *m_pAI; 
  unsigned int v11; 
  scr_string_t m_CoverExposeType; 
  bool v13; 
  bool v14; 
  int v15; 
  bool v16; 
  unsigned __int16 type; 
  unsigned __int16 coverMultiType; 
  const float *CoverAngleLimits; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  bool v24; 
  const Weapon *v25; 
  weapClass_t WeaponClass; 
  ai_scripted_t *v27; 
  scrContext_t *v28; 
  bool v29; 
  scrContext_t *v30; 
  bool v31; 
  bool v32; 
  scr_string_t *v33; 
  int v34; 
  scr_string_t m_CrouchArrivalType; 
  const float *CoverCrouchAngleLimits; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  scr_string_t aim; 
  __int64 v44; 
  scr_string_t left; 
  __int64 v46; 
  scr_string_t right; 
  __int64 v48; 
  scr_string_t standhigh; 
  __int64 v50; 
  scr_string_t *p_m_CoverExposeType; 
  scr_string_t exposed; 
  __int64 v53; 
  unsigned int v54; 
  unsigned int spawnflags; 
  scr_string_t *v56; 
  scr_string_t *p_m_CoverState; 
  bool v58; 
  bool v60; 
  int v61; 
  int outLimitsCount; 
  scr_string_t possiblePoses; 
  int v64[9]; 

  CoverNode = AIScriptedInterface::GetCoverNode(this);
  if ( !CoverNode )
    Scr_Error(COM_ERR_6179, scrContext, "UpdateCoverExposeType called with invalid cover node.");
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "AIScr_UpdateCoverExposeType");
  Float = Scr_GetFloat(scrContext, 0);
  v6 = *(float *)&Float;
  v7 = Scr_GetFloat(scrContext, 1u);
  v60 = Scr_GetInt(scrContext, 2u) != 0;
  v8 = Scr_GetInt(scrContext, 3u) != 0;
  Int = Scr_GetInt(scrContext, 4u);
  m_pAI = this->m_pAI;
  v11 = 0;
  v61 = Int;
  m_CoverExposeType = m_pAI->blackboard.m_CoverExposeType;
  v13 = m_CoverExposeType && m_CoverExposeType != scr_const.none;
  v58 = v13;
  v14 = m_pAI->blackboard.m_CoverState == scr_const.exposed;
  if ( !v13 || m_pAI->blackboard.m_CoverState == scr_const.exposed )
  {
    v16 = 1;
  }
  else
  {
    v15 = G_irand(0, 100);
    v13 = v58;
    v16 = v15 < 20;
  }
  type = CoverNode->constant.type;
  if ( type == 31 )
    coverMultiType = CoverNode->dynamic.coverMultiType;
  else
    coverMultiType = CoverNode->constant.type;
  if ( (unsigned int)coverMultiType - 6 > 1 )
  {
    if ( (unsigned __int16)(type - 3) <= 1u )
    {
      m_CrouchArrivalType = this->m_pAI->blackboard.m_CrouchArrivalType;
      if ( m_CrouchArrivalType == scr_const.cover_right_crouch_cc || m_CrouchArrivalType == scr_const.cover_left_crouch_cc )
      {
        CoverCrouchAngleLimits = GetCoverCrouchAngleLimits(m_CrouchArrivalType, &v61);
        if ( v61 < 18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7947, ASSERT_TYPE_ASSERT, "(numLimits >= 18)", (const char *)&queryFormat, "numLimits >= 18") )
          __debugbreak();
        v37 = CoverCrouchAngleLimits[4];
        v38 = CoverCrouchAngleLimits[8];
        v39 = CoverCrouchAngleLimits[10];
        v40 = CoverCrouchAngleLimits[11];
        v41 = CoverCrouchAngleLimits[12];
        v42 = CoverCrouchAngleLimits[13];
        if ( *(float *)&v7 > 40.0 && v6 >= CoverCrouchAngleLimits[6] && v6 < CoverCrouchAngleLimits[7] )
        {
          v30 = scrContext;
          possiblePoses = scr_const.overlean;
          aim = v64[G_irand(0, 1) - 1];
          goto LABEL_135;
        }
        if ( v58 && v14 )
        {
          if ( CoverCrouchAngleLimits[2] <= v6 && v6 < CoverCrouchAngleLimits[3] && (v16 || m_CoverExposeType != scr_const.aim) )
          {
            v11 = 1;
            possiblePoses = scr_const.aim;
          }
          if ( v37 <= v6 && v6 < CoverCrouchAngleLimits[5] && (v16 || m_CoverExposeType != scr_const.full_exposed) )
          {
            v44 = v11++;
            v64[v44 - 1] = scr_const.full_exposed;
          }
          if ( (CoverNode->constant.spawnflags & 0x200000) != 0 && (CoverNode->constant.spawnflags & 8) == 0 && v38 <= v6 && v6 < CoverCrouchAngleLimits[9] && HasRoomToPlayPeekout(CoverNode, &scr_const.left) && ((left = scr_const.left, v16) || m_CoverExposeType != scr_const.left) )
          {
            v30 = scrContext;
            if ( v11 >= 0xA )
            {
              Scr_Error(COM_ERR_6246, scrContext, "UpdateCoverExposeType exceeded max possible pose count.");
              left = scr_const.left;
            }
            v46 = v11++;
            v64[v46 - 1] = left;
          }
          else
          {
            v30 = scrContext;
          }
          if ( (CoverNode->constant.spawnflags & 0x400000) != 0 && (CoverNode->constant.spawnflags & 8) == 0 && v39 <= v6 && v6 < v40 )
          {
            if ( HasRoomToPlayPeekout(CoverNode, &scr_const.right) )
            {
              right = scr_const.right;
              if ( v16 || m_CoverExposeType != scr_const.right )
              {
                if ( v11 >= 0xA )
                {
                  Scr_Error(COM_ERR_6246, v30, "UpdateCoverExposeType exceeded max possible pose count.");
                  right = scr_const.right;
                }
                v48 = v11++;
                v64[v48 - 1] = right;
              }
            }
          }
          if ( v41 <= v6 && v6 < v42 )
          {
            standhigh = scr_const.standhigh;
            if ( v16 || m_CoverExposeType != scr_const.standhigh )
            {
              if ( v11 >= 0xA )
              {
                Scr_Error(COM_ERR_6246, v30, "UpdateCoverExposeType exceeded max possible pose count.");
                standhigh = scr_const.standhigh;
              }
              v50 = v11++;
              v64[v50 - 1] = standhigh;
            }
          }
          if ( v11 )
          {
            aim = v64[G_irand(0, v11) - 1];
            goto LABEL_135;
          }
        }
        else
        {
          v30 = scrContext;
        }
        aim = scr_const.aim;
LABEL_135:
        p_m_CoverExposeType = &this->m_pAI->blackboard.m_CoverExposeType;
        if ( *p_m_CoverExposeType != aim )
          Scr_SetString(p_m_CoverExposeType, aim);
        goto LABEL_179;
      }
    }
    if ( coverMultiType == 21 )
    {
      if ( !v13 || v14 )
      {
        exposed = scr_const.exposed;
        goto LABEL_176;
      }
LABEL_178:
      v30 = scrContext;
LABEL_179:
      p_m_CoverState = &this->m_pAI->blackboard.m_CoverState;
      if ( *p_m_CoverState != scr_const.exposed )
        Scr_SetString(p_m_CoverState, scr_const.exposed);
      v28 = v30;
      goto LABEL_182;
    }
    if ( v13 && v14 )
      goto LABEL_178;
    if ( (unsigned __int16)(type - 3) <= 1u )
    {
      if ( *(float *)&v7 > 14.0 )
        goto LABEL_149;
      if ( *(float *)&v7 <= 10.0 )
        goto LABEL_151;
      if ( v8 )
      {
LABEL_149:
        exposed = scr_const.leanover;
      }
      else
      {
        if ( !Path_DoesNodeAllowStance(CoverNode, (const scr_string_t)scr_const.stand) )
          goto LABEL_151;
        exposed = scr_const.full_exposed;
      }
      if ( exposed )
      {
LABEL_176:
        v56 = &this->m_pAI->blackboard.m_CoverExposeType;
        if ( *v56 != exposed )
          Scr_SetString(v56, exposed);
        goto LABEL_178;
      }
    }
LABEL_151:
    if ( (unsigned __int16)(CoverNode->constant.type - 3) > 1u )
    {
      LODWORD(v53) = 1;
      spawnflags = CoverNode->constant.spawnflags;
      possiblePoses = scr_const.full_exposed;
      if ( (spawnflags & 0x100000) != 0 && (spawnflags & 8) == 0 || (spawnflags & 0x200) != 0 && (spawnflags & 4) == 0 )
      {
        LODWORD(v53) = 2;
        v64[0] = scr_const.exposed;
      }
      goto LABEL_173;
    }
    if ( v8 || Path_DoesNodeAllowStance(CoverNode, (const scr_string_t)scr_const.stand) )
    {
      v11 = 1;
      possiblePoses = scr_const.full_exposed;
    }
    v53 = v11 + 1;
    v54 = CoverNode->constant.spawnflags;
    v64[v11 - 1] = scr_const.exposed;
    if ( (v54 & 0x200000) == 0 || (v54 & 8) != 0 )
    {
      if ( (v54 & 0x400) == 0 || (v54 & 0x204) != 0 )
      {
LABEL_162:
        if ( (v54 & 0x400000) == 0 || (v54 & 8) != 0 )
        {
          if ( (v54 & 0x800) != 0 && (v54 & 0x204) == 0 )
          {
            v64[v53 - 1] = scr_const.right;
            LODWORD(v53) = v53 + 1;
          }
        }
        else
        {
          v64[v53 - 1] = scr_const.right;
          LODWORD(v53) = v53 + 1;
        }
LABEL_173:
        if ( v8 )
          LODWORD(v53) = CullCoverPosesForShort(this->m_pAI, CoverNode, &possiblePoses, v53, &this->m_pAI->blackboard.m_CoverExposeType);
        exposed = v64[G_irand(0, v53) - 1];
        goto LABEL_176;
      }
      v64[v11] = scr_const.left;
    }
    else
    {
      v64[v53 - 1] = scr_const.left;
    }
    v53 = v11 + 2;
    goto LABEL_162;
  }
  CoverAngleLimits = GetCoverAngleLimits(coverMultiType, this->m_pAI->eCurrentStance, &outLimitsCount);
  if ( outLimitsCount < 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7821, ASSERT_TYPE_ASSERT, "( numLimits >= 6 )", (const char *)&queryFormat, "numLimits >= 6") )
    __debugbreak();
  v20 = CoverAngleLimits[2];
  v21 = CoverAngleLimits[3];
  v22 = CoverAngleLimits[4];
  v23 = CoverAngleLimits[5];
  v24 = m_CoverExposeType == scr_const.lean && v14;
  v25 = this->GetEquippedWeapon(this);
  WeaponClass = BG_GetWeaponClass(v25, 0);
  if ( WeaponClass == WEAPCLASS_ROCKETLAUNCHER || WeaponClass == WEAPCLASS_MG || v14 && m_CoverExposeType == scr_const.covertype_b || v20 > v6 || v6 >= v21 )
  {
    if ( v24 )
    {
      v30 = scrContext;
      goto LABEL_80;
    }
  }
  else
  {
    v27 = this->m_pAI;
    if ( v27->combat.doingAmbush )
    {
      if ( v27->blackboard.m_CoverState != scr_const.exposed )
      {
        Scr_SetString(&v27->blackboard.m_CoverState, scr_const.exposed);
        v27 = this->m_pAI;
      }
      goto LABEL_32;
    }
    if ( v24 )
    {
LABEL_32:
      if ( v27->blackboard.m_CoverExposeType != scr_const.lean )
        Scr_SetString(&v27->blackboard.m_CoverExposeType, scr_const.lean);
      v28 = scrContext;
LABEL_182:
      v34 = 1;
      goto LABEL_183;
    }
    if ( !v14 && (v16 || m_CoverExposeType != scr_const.lean) )
    {
      possiblePoses = scr_const.lean;
      v11 = 1;
    }
  }
  v29 = v58;
  if ( v58 && v14 )
  {
    if ( m_CoverExposeType == scr_const.covertype_a )
    {
      v22 = v22 + -5.0;
      v23 = v23 + 5.0;
    }
    else
    {
      v22 = v22 + 5.0;
      v23 = v23 + -5.0;
    }
  }
  if ( !v60 )
  {
    if ( v61 < 5000 && (m_CoverExposeType == scr_const.covertype_a || m_CoverExposeType == scr_const.covertype_b) )
    {
      v64[v11 - 1] = m_CoverExposeType;
    }
    else if ( v22 > v6 || v6 >= v23 )
    {
      if ( !v16 && m_CoverExposeType == scr_const.covertype_b )
        goto LABEL_52;
      v31 = v14 && m_CoverExposeType == scr_const.covertype_b || AIScriptedInterface::HasRoomToFullExposeCorner(this, CoverNode);
      v32 = this->ShouldArriveToCoverExposedStepOut(this);
      if ( !v31 || !this->m_pAI->combat.doingAmbush && !v32 && !AIScriptedInterface::CanSeeEnemyFromExposed(this, CoverNode) )
      {
        v30 = scrContext;
        if ( !v11 )
          goto LABEL_80;
LABEL_74:
        m_CoverExposeType = v64[G_irand(0, v11) - 1];
        goto LABEL_75;
      }
      v64[v11 - 1] = scr_const.covertype_b;
    }
    else
    {
      if ( !v16 && m_CoverExposeType == scr_const.covertype_a )
        goto LABEL_52;
      v64[v11 - 1] = scr_const.covertype_a;
    }
    ++v11;
LABEL_51:
    v29 = v58;
LABEL_52:
    v30 = scrContext;
    goto LABEL_53;
  }
  if ( this->m_pAI->fixedNode )
    goto LABEL_51;
  Sys_ProfEndNamedEvent();
  v30 = scrContext;
  Scr_Error(COM_ERR_6180, scrContext, "only allowed to disable stepouts if we're in fixednode.");
  v29 = v58;
LABEL_53:
  if ( v11 )
    goto LABEL_74;
  if ( v29 )
  {
LABEL_75:
    v33 = &this->m_pAI->blackboard.m_CoverExposeType;
    if ( *v33 != m_CoverExposeType )
      Scr_SetString(v33, m_CoverExposeType);
    goto LABEL_179;
  }
LABEL_80:
  v34 = 0;
  v28 = v30;
LABEL_183:
  Scr_AddBool(v28, v34);
  Sys_ProfEndNamedEvent();
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateLastCoverTime
==============
*/
void AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->lastCoverTime = level.time;
}

/*
==============
AIScriptedInterface::OnScrCmd_UseCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_UseCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  bool v5; 

  if ( this->m_pAI->fixedNode )
    Scr_Error(COM_ERR_3839, scrContext, "cannot change node when using fixedNode mode");
  if ( AIScriptedInterface::KeepClaimedNode(this) )
    Scr_Error(COM_ERR_3840, scrContext, "cannot change node when nodeSelect.keepClaimedNode is set");
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetType(scrContext, 1u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 1u) )
    this->ClearPath(this);
  Pathnode = Scr_GetPathnode(scrContext, 0);
  v5 = AIScriptedInterface::Cover_UseCoverNode(this, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
PushStopDataToScript
==============
*/
void PushStopDataToScript(scrContext_t *scrContext, const gentity_s *pEnt, const AIAnimStopData *pStopData)
{
  unsigned int CanonicalString; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  nav_space_s *m_pSpace; 
  int parentEntNum; 
  scrContext_t *v15; 
  const char *v16; 
  gentity_s *v17; 
  unsigned int v18; 
  unsigned int v19; 
  __int64 v20; 

  if ( !pEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6420, ASSERT_TYPE_ASSERT, "( pEnt )", (const char *)&queryFormat, "pEnt") )
    __debugbreak();
  if ( !pStopData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6421, ASSERT_TYPE_ASSERT, "( pStopData )", (const char *)&queryFormat, "pStopData") )
    __debugbreak();
  Scr_MakeStruct(scrContext);
  Scr_AddInt(scrContext, pStopData->stopAnimIndex);
  CanonicalString = SL_GetCanonicalString("stopanim");
  Scr_AddStructField(scrContext, CanonicalString);
  Scr_AddInt(scrContext, pStopData->angleIndex);
  v7 = SL_GetCanonicalString("angleindex");
  Scr_AddStructField(scrContext, v7);
  Scr_AddVector(scrContext, pStopData->startPos.v);
  v8 = SL_GetCanonicalString("startpos");
  Scr_AddStructField(scrContext, v8);
  Scr_AddFloat(scrContext, pStopData->angleDelta);
  v9 = SL_GetCanonicalString("angledelta");
  Scr_AddStructField(scrContext, v9);
  Scr_AddVector(scrContext, pStopData->angles.v);
  v10 = SL_GetCanonicalString("angles");
  Scr_AddStructField(scrContext, v10);
  Scr_AddVector(scrContext, pStopData->finalAngles.v);
  v11 = SL_GetCanonicalString("finalangles");
  Scr_AddStructField(scrContext, v11);
  Scr_AddVector(scrContext, pStopData->moveDelta.v);
  v12 = SL_GetCanonicalString("movedelta");
  Scr_AddStructField(scrContext, v12);
  m_pSpace = Nav_GetNavigator(pEnt)->m_pSpace;
  parentEntNum = m_pSpace->parentEntNum;
  if ( parentEntNum != 2047 )
  {
    if ( !G_IsEntityInUse(parentEntNum) )
    {
      v15 = ScriptContext_Server();
      v16 = j_va("GetNavSpaceEnt : Space has invalid parent ent %d.", (unsigned int)m_pSpace->parentEntNum);
      Scr_Error(COM_ERR_3903, v15, v16);
    }
    if ( m_pSpace->parentEntNum >= 0x800u )
    {
      LODWORD(v20) = m_pSpace->parentEntNum;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6310, ASSERT_TYPE_ASSERT, "(unsigned)( pSpace->parentEntNum ) < (unsigned)( ( 2048 ) )", "pSpace->parentEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, 2048) )
        __debugbreak();
    }
    v17 = &g_entities[m_pSpace->parentEntNum];
    if ( v17 )
    {
      Scr_AddVector(scrContext, v17->r.currentOrigin.v);
      v18 = SL_GetCanonicalString("parentpos");
      Scr_AddStructField(scrContext, v18);
      Scr_AddVector(scrContext, v17->r.currentAngles.v);
      v19 = SL_GetCanonicalString("parentangles");
      Scr_AddStructField(scrContext, v19);
    }
  }
}

/*
==============
AIScriptedInterface::SetIdleFacingUseAlliesPos
==============
*/
void AIScriptedInterface::SetIdleFacingUseAlliesPos(AIScriptedInterface *this, const vec3_t *pos)
{
  ai_scripted_t *m_pAI; 

  m_pAI = this->m_pAI;
  m_pAI->cachedIdleFacingUseAlliesPos = *pos;
  m_pAI->bCachedIdleFacingPosValid = 1;
}

/*
==============
AIScriptedInterface::SetupMotionWarpForTurn
==============
*/
char AIScriptedInterface::SetupMotionWarpForTurn(AIScriptedInterface *this, const vec3_t *corner, const vec3_t *nextPathPoint, const vec3_t *turnStartAnimTranslation, const vec3_t *turnStartAnimRot, float turnStartSecs)
{
  gentity_s *ent; 
  float v11; 
  __int128 v13; 
  ai_scripted_t *m_pAI; 
  gentity_s *v18; 
  ai_scripted_t *v19; 
  float v20; 
  float v21; 
  vec3_t out; 
  vec4_t quat; 
  vec3_t forward; 
  int v26[4]; 
  vec3_t animStartPos; 
  vec4_t v28; 
  vec4_t v29; 
  vec3_t targetAngles; 

  if ( !this->m_pAI->pNavigator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6247, ASSERT_TYPE_ASSERT, "(m_pAI->pNavigator)", (const char *)&queryFormat, "m_pAI->pNavigator") )
    __debugbreak();
  ent = this->m_pAI->ent;
  v11 = corner->v[0] - ent->r.currentOrigin.v[0];
  v13 = LODWORD(corner->v[2]);
  *(float *)&v13 = corner->v[2] - ent->r.currentOrigin.v[2];
  _XMM6 = v13;
  *(float *)&v13 = corner->v[1] - ent->r.currentOrigin.v[1];
  _XMM0 = this->Is3D(this);
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm6, xmm6, xmm7, xmm2
  }
  AngleVectors(&this->m_pAI->ent->r.currentAngles, &forward, NULL, NULL);
  if ( (float)((float)((float)(*(float *)&v13 * forward.v[1]) + (float)(v11 * forward.v[0])) + (float)(*(float *)&_XMM6 * forward.v[2])) < 0.0 )
    return 0;
  AnglesToQuat(&this->m_pAI->ent->r.currentAngles, &quat);
  QuatTransform(&quat, turnStartAnimTranslation, &out);
  m_pAI = this->m_pAI;
  v18 = m_pAI->ent;
  *(float *)v26 = out.v[0] + m_pAI->ent->r.currentOrigin.v[0];
  *(float *)&v26[1] = out.v[1] + v18->r.currentOrigin.v[1];
  *(float *)&v26[2] = out.v[2] + v18->r.currentOrigin.v[2];
  if ( m_pAI->pNavigator->IsStraightLineReachable(m_pAI->pNavigator, (const vec3_t *)v26, nextPathPoint) )
    return 0;
  AnglesToQuat(turnStartAnimRot, &v28);
  v29.v[0] = (float)((float)((float)(v28.v[0] * quat.v[3]) + (float)(quat.v[0] * v28.v[3])) + (float)(v28.v[1] * quat.v[2])) - (float)(v28.v[2] * quat.v[1]);
  v29.v[1] = (float)((float)((float)(quat.v[1] * v28.v[3]) - (float)(quat.v[2] * v28.v[0])) + (float)(v28.v[1] * quat.v[3])) + (float)(v28.v[2] * quat.v[0]);
  v29.v[2] = (float)((float)((float)(quat.v[1] * v28.v[0]) + (float)(quat.v[2] * v28.v[3])) - (float)(v28.v[1] * quat.v[0])) + (float)(v28.v[2] * quat.v[3]);
  v29.v[3] = (float)((float)((float)(quat.v[3] * v28.v[3]) - (float)(v28.v[0] * quat.v[0])) - (float)(quat.v[1] * v28.v[1])) - (float)(v28.v[2] * quat.v[2]);
  QuatToAngles(&v29, &targetAngles);
  v19 = this->m_pAI;
  v20 = corner->v[1] - out.v[1];
  animStartPos.v[0] = corner->v[0] - out.v[0];
  v21 = corner->v[2] - out.v[2];
  animStartPos.v[1] = v20;
  animStartPos.v[2] = v21;
  G_MotionWarp_StartWithAnim(v19->ent->s.number, &animStartPos, &v19->ent->r.currentAngles, corner, &targetAngles, (int)(float)(turnStartSecs * 1000.0));
  return 1;
}

