/*
==============
ParticleModuleInitMaterial::InitParticles
==============
*/

void __fastcall ParticleModuleInitMaterial::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitMaterial@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSound::InitParticles
==============
*/

void __fastcall ParticleModuleInitSound::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSound@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawn::Init
==============
*/

void __fastcall ParticleModuleInitSpawn::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawn@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitParticleSim::Init
==============
*/

void __fastcall ParticleModuleInitParticleSim::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitParticleSim@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitVolumetric::InitParticles
==============
*/

void __fastcall ParticleModuleInitVolumetric::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitVolumetric@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeBox@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::GetDimensions(ParticleModuleInitSpawnShapeCylinder *this, const ParticleState *pParticleState, float *halfHeight, float *radiusMin, float *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeCylinder@@QEBAXPEBVParticleState@@AEAM11@Z(this, pParticleState, halfHeight, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitOcclusionQuery::InitParticles
==============
*/

void __fastcall ParticleModuleInitOcclusionQuery::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitOcclusionQuery@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRunner::Init
==============
*/

void __fastcall ParticleModuleInitRunner::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitRunner@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeSphere@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitVolumetric::Init
==============
*/

void __fastcall ParticleModuleInitVolumetric::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitVolumetric@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitParticleSim::InitParticles
==============
*/

void __fastcall ParticleModuleInitParticleSim::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitParticleSim@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::GetDimensions(ParticleModuleInitSpawnShapeBox *this, const ParticleState *pParticleState, float4 *dimensionsMin, float4 *dimensionsMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeBox@@QEBAXPEBVParticleState@@AEAUfloat4@@1@Z(this, pParticleState, dimensionsMin, dimensionsMax);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeSphere@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitBeam::Init
==============
*/

void __fastcall ParticleModuleInitBeam::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitBeam@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitOrientedSprite::InitParticles
==============
*/

void __fastcall ParticleModuleInitOrientedSprite::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitOrientedSprite@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeBox@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitFlare::Init
==============
*/

void __fastcall ParticleModuleInitFlare::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitFlare@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, float4 *outOffset)
{
  ?GetOffsetForShape@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleEmitter@@AEAUfloat4@@@Z(this, pEmitter, outOffset);
}

/*
==============
ParticleModuleInitGeoTrail::Init
==============
*/

void __fastcall ParticleModuleInitGeoTrail::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitGeoTrail@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeCylinder::GetVolumeSize(ParticleModuleInitSpawnShapeCylinder *this, const float halfHeight, const float radiusMin, const float radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeCylinder@@QEBAMMMM@Z(this, halfHeight, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitAtlas::Init
==============
*/

void __fastcall ParticleModuleInitAtlas::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitAtlas@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitFlare::InitParticles
==============
*/

void __fastcall ParticleModuleInitFlare::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitFlare@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRunner::InitParticles
==============
*/

void __fastcall ParticleModuleInitRunner::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRunner@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitLightSpot::InitParticles
==============
*/

void __fastcall ParticleModuleInitLightSpot::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitLightSpot@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeBox@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitBeam::DebugDraw
==============
*/

void __fastcall ParticleModuleInitBeam::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitBeam@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitPlayerFacing::InitParticles
==============
*/

void __fastcall ParticleModuleInitPlayerFacing::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitPlayerFacing@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, float4 *outOffset)
{
  ?GetOffsetForShape@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleState@@AEAUfloat4@@@Z(this, pParticleState, outOffset);
}

/*
==============
ParticleModuleInitVolumetric::DebugDraw
==============
*/

void __fastcall ParticleModuleInitVolumetric::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitVolumetric@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeCylinder@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitLightOmni::InitParticles
==============
*/

void __fastcall ParticleModuleInitLightOmni::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitLightOmni@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticleSize
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleSize(const ParticleModuleInitAttributes *pModule, float4 *sizeArray, const int *randomSeedArray, unsigned int particleCountEmit)
{
  ?InitParticleSize@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHI@Z(pModule, sizeArray, randomSeedArray, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShape::GetVolumeSize(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShape@@QEBAMPEBVParticleState@@@Z(this, pParticleState);
  return result;
}

/*
==============
ParticleModuleInitLightOmni::DebugDraw
==============
*/

void __fastcall ParticleModuleInitLightOmni::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitLightOmni@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitModel::InitPhysicsParticles
==============
*/

void __fastcall ParticleModuleInitModel::InitPhysicsParticles(ParticleModuleInitModel *this, ParticleData *pParticleData, const unsigned int particleCountEmit, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, FxPhysics *physicsInstanceIDList)
{
  ?InitPhysicsParticles@ParticleModuleInitModel@@QEBAXPEAUParticleData@@IPEBVParticleEmitter@@PEBVParticleState@@PEAUFxPhysics@@@Z(this, pParticleData, particleCountEmit, pEmitterOwner, pParticleState, physicsInstanceIDList);
}

/*
==============
ParticleModuleInitDecal::InitParticles
==============
*/

void __fastcall ParticleModuleInitDecal::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitDecal@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::DebugDraw
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitModel::InitParticles
==============
*/

void __fastcall ParticleModuleInitModel::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitModel@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticleColor
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleColor(const ParticleModuleInitAttributes *pModule, float4 *colorArray, const int *randomSeedArray, unsigned int particleCountEmit)
{
  ?InitParticleColor@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHI@Z(pModule, colorArray, randomSeedArray, particleCountEmit);
}

/*
==============
ParticleModuleInitOcclusionQuery::Init
==============
*/

void __fastcall ParticleModuleInitOcclusionQuery::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitOcclusionQuery@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawn::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawn::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawn@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeCylinder@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitKillWrapBox::InitParticles
==============
*/

void __fastcall ParticleModuleInitKillWrapBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitKillWrapBox@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitMirrorTexture::InitParticles
==============
*/

void __fastcall ParticleModuleInitMirrorTexture::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitMirrorTexture@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitRotation::InitParticles
==============
*/

void __fastcall ParticleModuleInitRotation::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRotation@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitTail::InitParticles
==============
*/

void __fastcall ParticleModuleInitTail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitTail@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitDismember::InitParticles
==============
*/

void __fastcall ParticleModuleInitDismember::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitDismember@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCloud::InitParticles
==============
*/

void __fastcall ParticleModuleInitCloud::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitCloud@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitLightOmni::Init
==============
*/

void __fastcall ParticleModuleInitLightOmni::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitLightOmni@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeMesh::InitParticles
==============
*/

void __fastcall ParticleModuleInitSpawnShapeMesh::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitSpawnShapeMesh@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCameraOffset::InitParticles
==============
*/

void __fastcall ParticleModuleInitCameraOffset::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitCameraOffset@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetRandomSeed
==============
*/

int __fastcall ParticleModuleInitSpawnShape::GetRandomSeed(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, ParticleData *pParticleData, const int particleIndex)
{
  return ?GetRandomSeed@ParticleModuleInitSpawnShape@@QEBAHPEBVParticleState@@PEAUParticleData@@H@Z(this, pParticleState, pParticleData, particleIndex);
}

/*
==============
ParticleModuleInitBeam::InitParticles
==============
*/

void __fastcall ParticleModuleInitBeam::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitBeam@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitOrientedSprite::Init
==============
*/

void __fastcall ParticleModuleInitOrientedSprite::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitOrientedSprite@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeSphere::GetVolumeSize(ParticleModuleInitSpawnShapeSphere *this, const float radiusMin, const float radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeSphere@@QEBAMMM@Z(this, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitDecal::Init
==============
*/

void __fastcall ParticleModuleInitDecal::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitDecal@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeSphere@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize(ParticleModuleInitSpawnShapeEllipsoid *this, const float4 *radiusMin, const float4 *radiusMax)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeEllipsoid@@QEBAMAEBUfloat4@@0@Z(this, radiusMin, radiusMax);
  return result;
}

/*
==============
ParticleModuleInitAtlas::InitParticles
==============
*/

void __fastcall ParticleModuleInitAtlas::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitAtlas@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShape::GetCalculationOffset
==============
*/

void __fastcall ParticleModuleInitSpawnShape::GetCalculationOffset(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, const ParticleState *pParticleState, float4 *outCalculationOffset)
{
  ?GetCalculationOffset@ParticleModuleInitSpawnShape@@QEBAXPEBVParticleEmitter@@PEBVParticleState@@AEAUfloat4@@@Z(this, pEmitter, pParticleState, outCalculationOffset);
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeSphere::GetDimensions(ParticleModuleInitSpawnShapeSphere *this, const ParticleState *pParticleState, float *radiusMin, float *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeSphere@@QEBAXPEBVParticleState@@AEAM1@Z(this, pParticleState, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitRelativeVelocity::InitParticles
==============
*/

void __fastcall ParticleModuleInitRelativeVelocity::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRelativeVelocity@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::InitParticles
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitAttributes@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitCloud::Init
==============
*/

void __fastcall ParticleModuleInitCloud::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitCloud@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitGeoTrail::InitParticles
==============
*/

void __fastcall ParticleModuleInitGeoTrail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitGeoTrail@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitKillWrapBox::DebugDraw
==============
*/

void __fastcall ParticleModuleInitKillWrapBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitKillWrapBox@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitSpawnShapeMesh::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeMesh::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeMesh@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeEllipsoid@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitLightSpot::DebugDraw
==============
*/

void __fastcall ParticleModuleInitLightSpot::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleInitLightSpot@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModuleInitRotation3D::InitParticles
==============
*/

void __fastcall ParticleModuleInitRotation3D::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitRotation3D@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::Init
==============
*/

void __fastcall ParticleModuleInitSpawnShapeCylinder::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitSpawnShapeCylinder@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitDismember::Init
==============
*/

void __fastcall ParticleModuleInitDismember::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitDismember@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitAttributes::InitParticleVelocity
==============
*/

void __fastcall ParticleModuleInitAttributes::InitParticleVelocity(const ParticleModuleInitAttributes *pModule, float4 *velocityArray, const int *randomSeedArray, const ParticleState *pParticleState, const unsigned int particleCountEmit)
{
  ?InitParticleVelocity@ParticleModuleInitAttributes@@SAXPEBU1@PEAUfloat4@@PEBHPEBVParticleState@@I@Z(pModule, velocityArray, randomSeedArray, pParticleState, particleCountEmit);
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetVolumeSize
==============
*/

double __fastcall ParticleModuleInitSpawnShapeBox::GetVolumeSize(ParticleModuleInitSpawnShapeBox *this, const float4 *dimensions)
{
  double result; 

  *(float *)&result = ?GetVolumeSize@ParticleModuleInitSpawnShapeBox@@QEBAMAEBUfloat4@@@Z(this, dimensions);
  return result;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetDimensions
==============
*/

void __fastcall ParticleModuleInitSpawnShapeEllipsoid::GetDimensions(ParticleModuleInitSpawnShapeEllipsoid *this, const ParticleState *pParticleState, float4 *radiusMin, float4 *radiusMax)
{
  ?GetDimensions@ParticleModuleInitSpawnShapeEllipsoid@@QEBAXPEBVParticleState@@AEAUfloat4@@1@Z(this, pParticleState, radiusMin, radiusMax);
}

/*
==============
ParticleModuleInitLightSpot::Init
==============
*/

void __fastcall ParticleModuleInitLightSpot::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitLightSpot@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitVectorField::InitParticles
==============
*/

void __fastcall ParticleModuleInitVectorField::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ?InitParticles@ParticleModuleInitVectorField@@SAXPEBUParticleModule@@PEBVParticleState@@PEAUParticleData@@PEBUFxCamera@@I@Z(pModuleBase, pParticleState, pParticleData, pCamera, particleCountEmit);
}

/*
==============
ParticleModuleInitAttributes::Init
==============
*/

void __fastcall ParticleModuleInitAttributes::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleInitAttributes@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleInitBeam::DebugDraw
==============
*/
void ParticleModuleInitBeam::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  const ParticleSystem *SystemOwner; 
  const ParticleSystem *v17; 
  vec3_t center; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 717, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 718, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 719, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 720, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    __asm
    {
      vmovaps [rsp+98h+var_38], xmm6
      vmovaps [rsp+98h+var_48], xmm7
    }
    _RSI = ParticleEmitter::GetEmitterPos((ParticleEmitter *)pEmitterOwner, pParticleState);
    SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
    __asm
    {
      vmovups xmm1, xmmword ptr [rsi]
      vmovss  xmm7, cs:__real@41200000
      vaddps  xmm2, xmm1, xmmword ptr [rax+0F0h]
      vaddps  xmm6, xmm1, xmmword ptr [rax+100h]
      vmovaps xmm1, xmm7; radius
    }
    v17 = SystemOwner;
    __asm
    {
      vmovss  dword ptr [rsp+98h+center], xmm2
      vextractps dword ptr [rsp+98h+center+4], xmm2, 1
      vextractps dword ptr [rsp+98h+center+8], xmm2, 2
    }
    Particle_DebugSphere(&center, *(float *)&_XMM1, &colorBlueHeat, 1, 0);
    __asm
    {
      vmovaps xmm1, xmm7; radius
      vmovss  dword ptr [rsp+98h+center], xmm6
      vextractps dword ptr [rsp+98h+center+4], xmm6, 1
      vextractps dword ptr [rsp+98h+center+8], xmm6, 2
    }
    Particle_DebugSphere(&center, *(float *)&_XMM1, &colorBlueHeat, 1, 0);
    if ( v17->m_beamData.m_useCurvePoints )
    {
      __asm
      {
        vmovups xmm1, xmmword ptr [rsi]
        vaddps  xmm2, xmm1, xmmword ptr [rbx+110h]
        vaddps  xmm6, xmm1, xmmword ptr [rbx+120h]
        vmovaps xmm1, xmm7; radius
        vmovss  dword ptr [rsp+98h+center], xmm2
        vextractps dword ptr [rsp+98h+center+4], xmm2, 1
        vextractps dword ptr [rsp+98h+center+8], xmm2, 2
      }
      Particle_DebugSphere(&center, *(float *)&_XMM1, &colorBlueHeat, 1, 0);
      __asm
      {
        vmovaps xmm1, xmm7; radius
        vmovss  dword ptr [rsp+98h+center], xmm6
        vextractps dword ptr [rsp+98h+center+4], xmm6, 1
        vextractps dword ptr [rsp+98h+center+8], xmm6, 2
      }
      Particle_DebugSphere(&center, *(float *)&_XMM1, &colorBlueHeat, 1, 0);
    }
    __asm
    {
      vmovaps xmm6, [rsp+98h+var_38]
      vmovaps xmm7, [rsp+98h+var_48]
    }
  }
}

/*
==============
ParticleModuleInitKillWrapBox::DebugDraw
==============
*/
void ParticleModuleInitKillWrapBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  float4 outShapeOrigin; 
  vec3_t origin; 
  Bounds bounds; 
  vec3_t outAngles; 

  _RBX = (ParticleModule *)pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 798, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 799, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 800, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 801, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw(_RBX) || particle_debug_draw_wrap_bounds->current.enabled )
  {
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, (const float4 *)&_RBX[4], &outShapeOrigin, &outAngles, (_RBX->m_flags & 0x80) != 0);
    __asm
    {
      vmovups xmm1, xmmword ptr [rsp+0A8h+outShapeOrigin.v]
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+0A8h+origin], xmm1
      vextractps dword ptr [rsp+0A8h+origin+4], xmm1, 1
      vextractps dword ptr [rsp+0A8h+origin+8], xmm1, 2
      vmovups xmm1, xmmword ptr [rbx+10h]
      vmovss  dword ptr [rsp+0A8h+bounds.halfSize], xmm1
      vextractps dword ptr [rsp+0A8h+bounds.halfSize+4], xmm1, 1
      vextractps dword ptr [rsp+0A8h+bounds.halfSize+8], xmm1, 2
      vmovss  dword ptr [rsp+0A8h+bounds.midPoint], xmm0
      vmovss  dword ptr [rsp+0A8h+bounds.midPoint+4], xmm0
      vmovss  dword ptr [rsp+0A8h+bounds.midPoint+8], xmm0
    }
    Particle_DebugBox(&origin, &bounds, &outAngles, &colorLtPurple, 1, 0);
  }
}

/*
==============
ParticleModuleInitLightOmni::DebugDraw
==============
*/
void ParticleModuleInitLightOmni::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  const vector4 *EmitterTransform; 
  ParticleState::ElementTypeModule v10; 
  bool v11; 
  __int64 m_particleCountRunning; 
  const float4 *PositionArray; 
  float4 *ColorArray; 
  float4 *SizeArray; 
  float4 posWorld; 
  vec3_t center; 
  vec4_t color; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 833, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 834, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 835, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 836, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_lights->current.enabled )
  {
    v10.pModule = (const ParticleModule *)pParticleState->m_elementTypeModule;
    v11 = v10.pModule && (v10.pModule->m_flags & 1) == 0;
    if ( pParticleState->m_pStateDef->elementType == 5 && v11 )
    {
      m_particleCountRunning = pParticleData->m_particleCountRunning;
      PositionArray = Particle_GetPositionArray(pParticleData);
      ColorArray = Particle_GetColorArray(pParticleData);
      SizeArray = Particle_GetSizeArray(pParticleData);
      _RDI = SizeArray;
      if ( (_DWORD)m_particleCountRunning )
      {
        _RSI = (char *)ColorArray - (char *)SizeArray;
        __asm
        {
          vmovaps [rsp+0C8h+var_58], xmm6
          vmovss  xmm6, cs:__real@40400000
        }
        do
        {
          ParticleEmitter::GetWorldPos((ParticleEmitter *)pEmitterOwner, PositionArray, &posWorld, pParticleState, EmitterTransform);
          __asm
          {
            vmovups xmm1, xmmword ptr [rsp+0C8h+posWorld.v]
            vmovss  dword ptr [rsp+0C8h+center], xmm1
            vextractps dword ptr [rsp+0C8h+center+4], xmm1, 1
            vextractps dword ptr [rsp+0C8h+center+8], xmm1, 2
            vmovups xmm0, xmmword ptr [rsi+rdi]
            vmovups xmmword ptr [rsp+0C8h+color], xmm0
            vmovups xmm1, xmmword ptr [rdi]; radius
          }
          Particle_DebugSphere(&center, *(float *)&_XMM1, &color, 1, 0);
          __asm { vmovaps xmm1, xmm6; radius }
          Particle_DebugSphere(&center, *(float *)&_XMM1, &colorOrange, 1, 0);
          ++PositionArray;
          ++_RDI;
          --m_particleCountRunning;
        }
        while ( m_particleCountRunning );
        __asm { vmovaps xmm6, [rsp+0C8h+var_58] }
      }
    }
  }
}

/*
==============
ParticleModuleInitLightSpot::DebugDraw
==============
*/
void ParticleModuleInitLightSpot::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  bool v20; 
  __int64 m_particleCountRunning; 
  const vector4 *EmitterTransform; 
  float4 *SizeArray; 
  float4 *ColorArray; 
  const ParticleStateDef *m_pStateDef; 
  int v29; 
  const float4 *v37; 
  float4 *v38; 
  const vector4 *v39; 
  const float4 *v43; 
  vector3 *v44; 
  const vector4 *v47; 
  const vector4 *v50; 
  float4 *PositionArray; 
  __int64 v93; 
  vector4 M1; 
  vector4 result; 
  vec3_t center; 
  vec3_t start; 
  vec4_t color; 
  tmat33_t<vec3_t> rotation; 

  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_lights->current.enabled )
  {
    _RSI.pModule = (const ParticleModule *)pParticleState->m_elementTypeModule;
    v20 = _RSI.pModule && (_RSI.pModule->m_flags & 1) == 0;
    if ( pParticleState->m_pStateDef->elementType == 6 && v20 )
    {
      m_particleCountRunning = pParticleData->m_particleCountRunning;
      EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
      PositionArray = Particle_GetPositionArray(pParticleData);
      SizeArray = Particle_GetSizeArray(pParticleData);
      _RBX = Particle_GetRotationAngleArray(pParticleData);
      ColorArray = Particle_GetColorArray(pParticleData);
      m_pStateDef = pParticleState->m_pStateDef;
      __asm
      {
        vmovups xmm0, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
        vmovss  xmm2, cs:__real@3fc90fdb
      }
      *(_QWORD *)center.v = ColorArray;
      v29 = m_pStateDef->flags & 0xF0;
      __asm { vmovdqa xmmword ptr [rsp+2F8h+var_118], xmm0 }
      Float4x4RotationAroundUnitAxis(&result, (const float4 *)&color, *(const float *)&_XMM2);
      if ( (_DWORD)m_particleCountRunning )
      {
        _R14 = (char *)SizeArray - (char *)_RBX;
        __asm { vmovaps [rsp+2F8h+var_48], xmm6 }
        _R13 = (char *)PositionArray - (char *)_RBX;
        *(_QWORD *)center.v -= _RBX;
        __asm
        {
          vmovaps [rsp+2F8h+var_58], xmm7
          vmovaps [rsp+2F8h+var_68], xmm8
          vmovaps [rsp+2F8h+var_78], xmm9
          vmovaps [rsp+2F8h+var_88], xmm10
          vmovaps [rsp+2F8h+var_98], xmm11
          vmovaps [rsp+2F8h+var_A8], xmm12
          vmovaps [rsp+2F8h+var_B8], xmm13
          vmovaps [rsp+2F8h+var_C8], xmm14
          vmovss  xmm14, cs:__real@3f800000
          vmovaps [rsp+2F8h+var_D8], xmm15
          vmovss  xmm15, cs:__real@40400000
        }
        v93 = m_particleCountRunning;
        _R12 = *(_QWORD *)center.v;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr cs:?g_unit@@3Ufloat4@@B.v; float4 const g_unit
            vmovups xmm12, xmmword ptr [r14+rbx]
            vmovdqa xmmword ptr [rsp+2F8h+M1.w.v], xmm0
            vmovss  xmm0, dword ptr [rsi+18h]; X
          }
          *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
          __asm { vmulss  xmm13, xmm0, xmm12 }
          if ( v29 )
          {
            __asm { vmovups xmm0, xmmword ptr [rbx] }
            Float4RadianToQuat(v38, v37);
            Float4UnitQuatToAxis(v44, v43);
            __asm
            {
              vmovups xmm3, xmm2
              vmovups xmmword ptr [rsp+2F8h+var_1A8+10h], xmm1
              vmovups xmmword ptr [rsp+2F8h+var_1A8], xmm0
              vmovups ymm2, [rsp+2F8h+var_1A8]
              vmovups ymmword ptr [rsp+2F8h+M1.baseclass_0.x.v], ymm2
              vmovups xmmword ptr [rsp+2F8h+M1.baseclass_0.z.v], xmm3
            }
            Float4x4Mul(&result, &M1, v47);
            __asm
            {
              vmovups xmmword ptr [rsp+2F8h+var_248], xmm2
              vmovups xmmword ptr [rsp+2F8h+var_268], xmm0
              vmovups xmmword ptr [rsp+2F8h+var_248+10h], xmm3
              vmovups ymm0, [rsp+2F8h+var_248]
              vmovups xmmword ptr [rsp+2F8h+var_268+10h], xmm1
              vmovups ymm2, [rsp+2F8h+var_268]
              vmovups ymmword ptr [rsp+2F8h+M1.baseclass_0.x.v], ymm2
              vmovups ymmword ptr [rsp+2F8h+M1.baseclass_0.z.v], ymm0
            }
            Float4x4Mul(&M1, EmitterTransform, v50);
            __asm
            {
              vmovups xmmword ptr [rsp+2F8h+var_208], xmm2
              vmovups xmmword ptr [rsp+2F8h+var_228], xmm0
              vmovups xmmword ptr [rsp+2F8h+var_208+10h], xmm3
              vmovups ymm0, [rsp+2F8h+var_208]
              vmovups xmmword ptr [rsp+2F8h+var_228+10h], xmm1
              vmovups ymm2, [rsp+2F8h+var_228]
            }
          }
          else
          {
            Float4x4Mul(&result, EmitterTransform, v39);
            __asm
            {
              vmovups xmmword ptr [rsp+2F8h+var_1C8], xmm2
              vmovups xmmword ptr [rsp+2F8h+var_1E8], xmm0
              vmovups xmmword ptr [rsp+2F8h+var_1C8+10h], xmm3
              vmovups ymm0, [rsp+2F8h+var_1C8]
              vmovups xmmword ptr [rsp+2F8h+var_1E8+10h], xmm1
              vmovups ymm2, [rsp+2F8h+var_1E8]
            }
          }
          __asm
          {
            vmovups xmm4, xmmword ptr [rbx+r13]
            vxorps  xmm6, xmm12, cs:__xmm@80000000800000008000000080000000
            vmovups ymmword ptr [rsp+2F8h+M1.baseclass_0.z.v], ymm0
            vmovups xmm9, xmmword ptr [rsp+2F8h+M1.baseclass_0.z.v]
            vmovups ymmword ptr [rsp+2F8h+M1.baseclass_0.x.v], ymm2
            vmovups xmm1, xmmword ptr [rsp+2F8h+M1.baseclass_0.x.v]
            vmovups xmm2, xmmword ptr [rsp+2F8h+M1.baseclass_0.y.v]
            vmovss  dword ptr [rsp+2F8h+rotation], xmm1
            vextractps dword ptr [rsp+2F8h+rotation+4], xmm1, 1
            vextractps dword ptr [rsp+2F8h+rotation+8], xmm1, 2
            vmovss  dword ptr [rsp+2F8h+rotation+0Ch], xmm2
            vextractps dword ptr [rsp+2F8h+rotation+10h], xmm2, 1
            vextractps dword ptr [rsp+2F8h+rotation+14h], xmm2, 2
            vmulss  xmm0, xmm9, xmm9
            vshufps xmm7, xmm4, xmm4, 55h ; 'U'
            vshufps xmm8, xmm4, xmm4, 0AAh ; 'ª'
            vshufps xmm10, xmm9, xmm9, 55h ; 'U'
            vmulss  xmm1, xmm10, xmm10
            vaddss  xmm2, xmm1, xmm0
            vshufps xmm11, xmm9, xmm9, 0AAh ; 'ª'
            vmulss  xmm1, xmm11, xmm11
            vaddss  xmm2, xmm2, xmm1
            vsqrtss xmm3, xmm2, xmm2
            vcmpless xmm0, xmm3, cs:__real@80000000
            vblendvps xmm0, xmm3, xmm14, xmm0
            vdivss  xmm5, xmm14, xmm0
            vmulss  xmm0, xmm9, xmm5
            vmulss  xmm1, xmm0, xmm6
            vaddss  xmm2, xmm1, xmm4
            vmulss  xmm0, xmm10, xmm5
            vmulss  xmm1, xmm0, xmm6
            vmulss  xmm0, xmm11, xmm5
            vmovss  dword ptr [rsp+2F8h+start], xmm4
            vaddss  xmm4, xmm1, xmm7
            vmulss  xmm1, xmm0, xmm6
            vmovups xmm0, xmmword ptr [r12+rbx]
            vmovss  dword ptr [rsp+2F8h+center+4], xmm4
            vaddss  xmm4, xmm1, xmm8
            vmovss  dword ptr [rsp+2F8h+center], xmm2
            vmovaps xmm3, xmm13; radius
            vmovaps xmm2, xmm12; height
            vmovss  dword ptr [rsp+2F8h+center+8], xmm4
            vmovss  dword ptr [rsp+2F8h+rotation+18h], xmm9
            vmovss  dword ptr [rsp+2F8h+rotation+1Ch], xmm10
            vmovss  dword ptr [rsp+2F8h+rotation+20h], xmm11
            vmovss  dword ptr [rsp+2F8h+start+4], xmm7
            vmovss  dword ptr [rsp+2F8h+start+8], xmm8
            vmovups xmmword ptr [rsp+2F8h+var_118], xmm0
          }
          Particle_DebugCone(&center, &rotation, *(float *)&_XMM2, *(float *)&_XMM3, &color, 1, 0);
          Particle_DebugLine(&start, &center, &colorOrange, 1, 0);
          __asm { vmovaps xmm1, xmm15; radius }
          Particle_DebugSphere(&start, *(float *)&_XMM1, &color, 1, 0);
          __asm { vmovaps xmm1, xmm15; radius }
          Particle_DebugSphere(&center, *(float *)&_XMM1, &colorOrange, 1, 0);
          ++_RBX;
          --v93;
        }
        while ( v93 );
        __asm
        {
          vmovaps xmm15, [rsp+2F8h+var_D8]
          vmovaps xmm14, [rsp+2F8h+var_C8]
          vmovaps xmm13, [rsp+2F8h+var_B8]
          vmovaps xmm12, [rsp+2F8h+var_A8]
          vmovaps xmm11, [rsp+2F8h+var_98]
          vmovaps xmm10, [rsp+2F8h+var_88]
          vmovaps xmm9, [rsp+2F8h+var_78]
          vmovaps xmm8, [rsp+2F8h+var_68]
          vmovaps xmm7, [rsp+2F8h+var_58]
          vmovaps xmm6, [rsp+2F8h+var_48]
        }
      }
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeBox::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeBox::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  bool useWorldSpace; 
  float4 dimensionsMax; 
  float4 dimensionsMin; 
  vec3_t origin; 
  Bounds bounds; 
  vec3_t outAngles; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1479, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1480, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1481, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1482, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    __asm { vmovaps [rsp+0C8h+var_38], xmm6 }
    ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)pModuleBase, pParticleState, &dimensionsMin, &dimensionsMax);
    __asm
    {
      vmovups xmm2, xmmword ptr [rsp+0C8h+dimensionsMax.v]
      vsubps  xmm1, xmm2, xmmword ptr [rsp+0C8h+dimensionsMin.v]
      vmulps  xmm6, xmm1, cs:__xmm@3f0000003f0000003f0000003f000000
    }
    useWorldSpace = (pModuleBase->m_flags & 0x80) != 0;
    __asm
    {
      vsubps  xmm1, xmm2, xmm6
      vmovups xmmword ptr [rsp+0C8h+dimensionsMin.v], xmm1
    }
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &dimensionsMin, &dimensionsMax, &outAngles, useWorldSpace);
    __asm
    {
      vmovups xmm1, xmmword ptr [rsp+0C8h+dimensionsMax.v]
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+0C8h+origin], xmm1
      vextractps dword ptr [rsp+0C8h+origin+4], xmm1, 1
      vextractps dword ptr [rsp+0C8h+origin+8], xmm1, 2
      vmovss  dword ptr [rsp+0C8h+bounds.midPoint], xmm0
      vmovss  dword ptr [rsp+0C8h+bounds.midPoint+4], xmm0
      vmovss  dword ptr [rsp+0C8h+bounds.midPoint+8], xmm0
      vmovss  dword ptr [rsp+0C8h+bounds.halfSize], xmm6
      vextractps dword ptr [rsp+0C8h+bounds.halfSize+4], xmm6, 1
      vextractps dword ptr [rsp+0C8h+bounds.halfSize+8], xmm6, 2
    }
    Particle_DebugBox(&origin, &bounds, &outAngles, &colorLtGreen, 1, 0);
    __asm { vmovaps xmm6, [rsp+0C8h+var_38] }
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeCylinder::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  unsigned int v15; 
  char v16; 
  ParticleRelativeVelocityType m_velocityType; 
  bool v19; 
  const vector4 *EmitterTransform; 
  const float4 *v22; 
  vector3 *v23; 
  const vector4 *v27; 
  ParticleEmitter *EmitterOwner; 
  float4 outOffset; 
  vector4 result; 

  _RBX = (ParticleModuleInitSpawnShapeCylinder *)pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1873, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1874, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1875, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1876, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw(_RBX) || particle_debug_draw_spawn_shape->current.enabled )
  {
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    v15 = _RBX->m_flags >> 7;
    __asm { vmovaps [rsp+128h+var_38], xmm6 }
    v16 = v15 & 1;
    __asm
    {
      vmovaps [rsp+128h+var_48], xmm7
      vxorps  xmm6, xmm6, xmm6
    }
    v19 = 0;
    if ( m_pModuleInitRelativeVelocity )
    {
      if ( (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 )
      {
        m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
        if ( m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
          v19 = 1;
      }
    }
    __asm
    {
      vmovups xmm0, xmmword ptr cs:?g_unit@@3Ufloat4@@B.v; float4 const g_unit
      vmovdqa xmmword ptr [rsp+128h+result.w.v], xmm0
    }
    EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    ParticleModuleInitSpawnShape::GetOffsetForShape(_RBX, pParticleState, &outOffset);
    if ( v19 )
    {
      __asm
      {
        vmovups xmm1, xmmword ptr [rbx+10h]
        vshufps xmm0, xmm1, xmm6, 0FAh ; 'ú'
        vshufps xmm1, xmm1, xmm0, 84h ; ''
        vaddps  xmm6, xmm1, xmmword ptr [rbx+20h]
      }
    }
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx+40h]
      vmovaps [rsp+128h+var_58], xmm8
    }
    Float4UnitQuatToAxis(v23, v22);
    __asm
    {
      vmovups xmmword ptr [rsp+128h+var_E8+10h], xmm1
      vmovups xmmword ptr [rsp+128h+var_E8], xmm0
      vmovups ymm3, [rsp+128h+var_E8]
      vmovups ymmword ptr [rsp+128h+result.baseclass_0.x.v], ymm3
      vmovups xmmword ptr [rsp+128h+result.baseclass_0.z.v], xmm2
    }
    if ( v16 )
    {
      __asm { vmovups xmm5, xmmword ptr [rsp+128h+outOffset.v] }
    }
    else
    {
      Float4x4Mul(&result, EmitterTransform, v27);
      __asm
      {
        vmovups xmm7, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
        vmovups xmm8, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
        vmovups xmmword ptr [rsp+128h+var_C8], xmm2
        vmovups xmmword ptr [rsp+128h+var_E8], xmm0
        vmovups xmmword ptr [rsp+128h+var_E8+10h], xmm1
        vmovups xmm1, xmmword ptr [rsp+128h+outOffset.v]
        vmovups ymm2, [rsp+128h+var_E8]
        vmovups ymmword ptr [rsp+128h+result.baseclass_0.x.v], ymm2
        vshufps xmm2, xmm1, xmm1, 0
        vshufps xmm4, xmm1, xmm1, 0AAh ; 'ª'
        vmovups xmmword ptr [rsp+128h+var_C8+10h], xmm3
        vmovups ymm0, [rsp+128h+var_C8]
        vmovups ymmword ptr [rsp+128h+result.baseclass_0.z.v], ymm0
        vmulps  xmm0, xmm2, xmmword ptr [r15]
        vshufps xmm3, xmm1, xmm1, 55h ; 'U'
        vaddps  xmm1, xmm0, xmm7
        vmulps  xmm0, xmm3, xmmword ptr [r15+10h]
        vaddps  xmm2, xmm0, xmm7
        vmulps  xmm0, xmm4, xmmword ptr [r15+20h]
        vaddps  xmm1, xmm0, xmm1
        vaddps  xmm2, xmm2, xmm1
        vandps  xmm5, xmm2, xmm8
      }
      if ( v19 )
      {
        __asm
        {
          vshufps xmm1, xmm6, xmm6, 0
          vmulps  xmm0, xmm1, xmmword ptr [r15]
          vshufps xmm2, xmm6, xmm6, 55h ; 'U'
          vaddps  xmm3, xmm0, xmm7
          vmulps  xmm0, xmm2, xmmword ptr [r15+10h]
          vshufps xmm4, xmm6, xmm6, 0AAh ; 'ª'
          vaddps  xmm2, xmm0, xmm7
          vmulps  xmm0, xmm4, xmmword ptr [r15+20h]
          vaddps  xmm1, xmm0, xmm3
          vaddps  xmm2, xmm2, xmm1
          vandps  xmm6, xmm2, xmm8
        }
      }
    }
    __asm
    {
      vmovaps xmm8, [rsp+128h+var_58]
      vaddps  xmm7, xmm5, xmmword ptr [r15+30h]
      vmovups xmmword ptr [rsp+128h+outOffset.v], xmm7
    }
    if ( v16 )
    {
      EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
      ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
      __asm
      {
        vshufps xmm2, xmm7, xmm7, 0
        vshufps xmm4, xmm7, xmm7, 55h ; 'U'
        vshufps xmm5, xmm7, xmm7, 0AAh ; 'ª'
        vmulps  xmm0, xmm2, xmmword ptr [rax]
        vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
        vmulps  xmm0, xmm4, xmmword ptr [rax+10h]
        vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
        vmulps  xmm0, xmm5, xmmword ptr [rax+20h]
        vaddps  xmm1, xmm0, xmm3
        vaddps  xmm2, xmm2, xmm1
        vandps  xmm0, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
        vmovups xmmword ptr [rsp+128h+outOffset.v], xmm0
      }
    }
    Particle_SpawnShapeDrawCylinder(&outOffset, &result, &colorLtGreen, pParticleState, _RBX);
    __asm { vmovaps xmm7, [rsp+128h+var_48] }
    if ( v19 )
    {
      __asm
      {
        vaddps  xmm0, xmm6, xmmword ptr [r15+30h]
        vmovups xmmword ptr [rsp+128h+outOffset.v], xmm0
      }
      Particle_SpawnShapeDrawCylinder(&outOffset, &result, &colorLtBlue, pParticleState, _RBX);
    }
    __asm { vmovaps xmm6, [rsp+128h+var_38] }
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  bool v8; 
  float4 *p_outShapeOrigin; 
  float4 outShapeOrigin; 
  vec3_t center; 
  float4 outOffset; 
  vec3_t outAngles; 
  float4 radiusMax; 
  float4 radiusMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2031, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2032, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2033, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2034, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
    ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &outOffset, &outShapeOrigin, &outAngles, (pModuleBase->m_flags & 0x80) != 0);
    v8 = (HIBYTE(pModuleBase[1].m_type) & 1) == 0;
    __asm
    {
      vmovups xmm1, xmmword ptr [rbp+57h+outShapeOrigin.v]
      vmovss  dword ptr [rbp+57h+center], xmm1
      vextractps dword ptr [rbp+57h+center+4], xmm1, 1
      vextractps dword ptr [rbp+57h+center+8], xmm1, 2
    }
    p_outShapeOrigin = &outShapeOrigin;
    if ( v8 )
    {
      __asm
      {
        vmovups xmm1, xmmword ptr [rbp+57h+radiusMin.v]
        vmovups xmm2, xmmword ptr [rbp+57h+radiusMax.v]
        vmovss  dword ptr [rbp+57h+outShapeOrigin.v], xmm1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+4], xmm1, 1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+8], xmm1, 2
        vmovss  dword ptr [rbp+57h+outOffset.v], xmm2
        vextractps dword ptr [rbp+57h+outOffset.v+4], xmm2, 1
        vextractps dword ptr [rbp+57h+outOffset.v+8], xmm2, 2
      }
      Particle_DebugEllipsoid(&center, &outAngles, (const vec3_t *)&outShapeOrigin, &colorLtGreen, 1, 0);
      p_outShapeOrigin = &outOffset;
    }
    else
    {
      __asm
      {
        vmovups xmm1, xmmword ptr [rbp+57h+radiusMax.v]
        vmovss  dword ptr [rbp+57h+outShapeOrigin.v], xmm1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+4], xmm1, 1
        vextractps dword ptr [rbp+57h+outShapeOrigin.v+8], xmm1, 2
      }
    }
    Particle_DebugEllipsoid(&center, &outAngles, (const vec3_t *)p_outShapeOrigin, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::DebugDraw
==============
*/
void ParticleModuleInitSpawnShapeSphere::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  float radiusMax; 
  float radiusMin[3]; 
  float4 outOffset; 
  float4 outShapeOrigin; 
  vec3_t center; 
  vec3_t outAngles; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2342, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2343, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2344, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2345, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) || particle_debug_draw_spawn_shape->current.enabled )
  {
    ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
    ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)pModuleBase, pParticleState, radiusMin, &radiusMax);
    Particle_GetShapeOffsetAndAngles(pEmitterOwner, pParticleState, &outOffset, &outShapeOrigin, &outAngles, (pModuleBase->m_flags & 0x80) != 0);
    __asm
    {
      vmovups xmm1, xmmword ptr [rsp+0B8h+outShapeOrigin.v]
      vmovss  dword ptr [rsp+0B8h+center], xmm1
      vextractps dword ptr [rsp+0B8h+center+4], xmm1, 1
      vextractps dword ptr [rsp+0B8h+center+8], xmm1, 2
    }
    if ( (HIBYTE(pModuleBase[1].m_type) & 1) == 0 )
    {
      __asm { vmovss  xmm1, [rsp+0B8h+radiusMin]; radius }
      Particle_DebugSphere(&center, *(float *)&_XMM1, &colorLtGreen, 1, 0);
    }
    __asm { vmovss  xmm1, [rsp+0B8h+radiusMax]; radius }
    Particle_DebugSphere(&center, *(float *)&_XMM1, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleInitVolumetric::DebugDraw
==============
*/
void ParticleModuleInitVolumetric::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  __int64 m_particleCountRunning; 
  unsigned __int8 *ParticleDataArray; 
  ParticleEmitter *v21; 
  const vector4 *EmitterTransform; 
  const ParticleSystem *SystemOwner; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  unsigned int m_velocityType; 
  const ParticleModuleInitRelativeVelocity *v30; 
  const ParticleStateDef *m_pStateDef; 
  float4 *v42; 
  bool v46; 
  const dvar_t *v97; 
  double v110; 
  double v111; 
  double v112; 
  double v113; 
  char v114; 
  float4 *RotationAngleArray; 
  const float4 *v116; 
  float4 *SizeArray; 
  signed __int64 v118; 
  __int64 v120; 
  vec4_t v121; 
  vec3_t center; 
  vec4_t quat; 
  vec3_t size; 
  vec3_t angles; 
  tmat33_t<vec3_t> axis; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2396, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2397, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2398, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2399, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    m_particleCountRunning = pParticleData->m_particleCountRunning;
    _RBX = Particle_GetPositionArray(pParticleData);
    SizeArray = Particle_GetSizeArray(pParticleData);
    RotationAngleArray = Particle_GetRotationAngleArray(pParticleData);
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    ParticleDataArray = ParticleData::GetParticleDataArray((ParticleData *)pParticleData, PARTICLE_DATA_SPAWN_QUAT);
    v21 = (ParticleEmitter *)pEmitterOwner;
    v120 = pParticleState->m_pStateDef->flags & 0xA0;
    EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    v114 = SystemOwner->m_flags & 1;
    if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
      m_velocityType = 0;
    else
      m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
    Particle_RotMatrixToQuatVec(EmitterTransform, &quat);
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+0E0h+quat]
      vmovdqa xmmword ptr [rbp+0E0h+var_160], xmm0
    }
    if ( (_DWORD)m_particleCountRunning )
    {
      v118 = (char *)SizeArray - (char *)_RBX;
      _RDX = (const float4 *)((char *)RotationAngleArray - (char *)_RBX);
      __asm { vmovaps [rsp+1E0h+var_50], xmm6 }
      _R12 = ParticleDataArray - (unsigned __int8 *)_RBX;
      __asm
      {
        vmovaps [rsp+1E0h+var_B0], xmm12
        vmovaps [rsp+1E0h+var_C0], xmm13
        vmovaps [rsp+1E0h+var_D0], xmm14
        vmovaps [rsp+1E0h+var_E0], xmm15
        vmovss  xmm15, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vmovaps [rsp+1E0h+var_60], xmm7
        vmovaps [rsp+1E0h+var_70], xmm8
        vmovaps [rsp+1E0h+var_80], xmm9
        vmovaps [rsp+1E0h+var_90], xmm10
        vmovaps [rsp+1E0h+var_A0], xmm11
      }
      v116 = (const float4 *)((char *)RotationAngleArray - (char *)_RBX);
      do
      {
        v30 = pParticleState->m_pModuleInitRelativeVelocity;
        if ( !v30 || (v30->m_flags & 1) != 0 || ((v30->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
        {
          __asm { vmovups xmm6, xmmword ptr [rbx] }
        }
        else
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rbx]
            vshufps xmm2, xmm0, xmm0, 0AAh ; 'ª'
            vshufps xmm3, xmm0, xmm0, 55h ; 'U'
            vshufps xmm4, xmm0, xmm0, 0
            vmulps  xmm0, xmm2, xmmword ptr [r13+20h]
            vaddps  xmm2, xmm0, xmmword ptr [r13+30h]
            vmulps  xmm0, xmm3, xmmword ptr [r13+10h]
            vaddps  xmm1, xmm0, xmm2
            vmulps  xmm0, xmm4, xmmword ptr [r13+0]
            vaddps  xmm6, xmm0, xmm1
          }
        }
        m_pStateDef = pParticleState->m_pStateDef;
        v42 = (float4 *)((unsigned __int64)LODWORD(m_pStateDef->flags) >> 28);
        if ( (m_pStateDef->flags & 0x10000000) != 0 )
        {
          ParticleEmitter::GetSystemOwner(v21);
          _RDX = v116;
          __asm { vaddps  xmm6, xmm6, xmmword ptr [rax+30h] }
        }
        _RAX = v118;
        __asm
        {
          vmovss  dword ptr [rbp+0E0h+center], xmm6
          vextractps dword ptr [rbp+0E0h+center+4], xmm6, 1
          vextractps dword ptr [rbp+0E0h+center+8], xmm6, 2
          vmovups xmm2, xmmword ptr [rax+rbx]
          vmovss  dword ptr [rbp+0E0h+size], xmm2
          vextractps dword ptr [rbp+0E0h+size+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+size+8], xmm2, 2
        }
        if ( v120 )
        {
          __asm { vmovups xmm0, xmmword ptr [rdx+rbx] }
          Float4RadianToQuat(v42, _RDX);
          __asm
          {
            vmovss  xmm10, dword ptr [rbp+0E0h+quat]
            vmovss  xmm8, dword ptr [rbp+0E0h+quat+0Ch]
            vmovss  xmm6, dword ptr [rbp+0E0h+quat+4]
            vmovss  xmm5, dword ptr [rbp+0E0h+quat+8]
            vmovups xmm11, xmm0
            vshufps xmm9, xmm0, xmm0, 0FFh
            vshufps xmm7, xmm0, xmm0, 0AAh ; 'ª'
            vshufps xmm4, xmm11, xmm11, 55h ; 'U'
            vmulss  xmm2, xmm10, xmm9
            vmulss  xmm1, xmm8, xmm11
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm6, xmm7
            vaddss  xmm1, xmm3, xmm0
            vmulss  xmm0, xmm5, xmm4
            vsubss  xmm12, xmm1, xmm0
            vmulss  xmm1, xmm4, xmm8
            vmulss  xmm0, xmm7, xmm10
            vsubss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm6, xmm9
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm1, xmm4, xmm10
            vmulss  xmm0, xmm5, xmm11
            vaddss  xmm13, xmm3, xmm0
            vmulss  xmm0, xmm7, xmm8
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm6, xmm11
            vsubss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm5, xmm9
            vaddss  xmm14, xmm3, xmm0
            vmulss  xmm0, xmm10, xmm11
            vmulss  xmm1, xmm9, xmm8
            vsubss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm4, xmm6
            vsubss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm5, xmm7
            vsubss  xmm4, xmm3, xmm0
            vmovss  dword ptr [rbp+0E0h+var_160+0Ch], xmm4
            vmovss  dword ptr [rbp+0E0h+var_160], xmm12
            vmovss  dword ptr [rbp+0E0h+var_160+4], xmm13
            vmovss  dword ptr [rbp+0E0h+var_160+8], xmm14
          }
        }
        else
        {
          v46 = m_velocityType < 2;
          if ( m_velocityType == 2 || (v46 = m_velocityType < 5, m_velocityType == 5) || (v46 = 0, v114) && (v46 = m_velocityType < 3, m_velocityType != 3) )
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [r12+rbx]
              vmovups xmmword ptr [rbp+0E0h+var_160], xmm0
              vshufps xmm4, xmm0, xmm0, 0FFh
            }
          }
          else
          {
            __asm { vmovss  xmm4, dword ptr [rbp+0E0h+var_160+0Ch] }
          }
          __asm
          {
            vmovss  xmm14, dword ptr [rbp+0E0h+var_160+8]
            vmovss  xmm13, dword ptr [rbp+0E0h+var_160+4]
            vmovss  xmm12, dword ptr [rbp+0E0h+var_160]
          }
        }
        __asm
        {
          vmulss  xmm1, xmm12, xmm12
          vmulss  xmm0, xmm13, xmm13
          vaddss  xmm2, xmm1, xmm0
          vmulss  xmm1, xmm14, xmm14
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm2, xmm3, xmm0
          vsubss  xmm1, xmm2, cs:__real@3f800000
          vandps  xmm1, xmm1, xmm15
          vcomiss xmm1, cs:__real@3b83126f
        }
        if ( !v46 )
        {
          __asm
          {
            vcvtss2sd xmm0, xmm4, xmm4
            vmovsd  [rsp+1E0h+var_198], xmm0
            vcvtss2sd xmm1, xmm14, xmm14
            vmovsd  [rsp+1E0h+var_1A0], xmm1
            vcvtss2sd xmm2, xmm13, xmm13
            vmovsd  [rsp+1E0h+var_1A8], xmm2
            vcvtss2sd xmm3, xmm12, xmm12
            vmovsd  [rsp+1E0h+var_1B0], xmm3
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 698, ASSERT_TYPE_ASSERT, "(Particle_Vec4IsNormalized( outQuat ))", "%s\n\t%g %g %g %g", "Particle_Vec4IsNormalized( outQuat )", v110, v111, v112, v113) )
            __debugbreak();
        }
        QuatToAxis(&v121, &axis);
        AxisToAngles(&axis, &angles);
        Particle_DebugEllipsoid(&center, &angles, &size, &colorRedHeat, 1, 0);
        v97 = particle_show_axes;
        if ( !particle_show_axes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 620, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v97);
        if ( v97->current.enabled )
        {
          _RAX = particle_axes_length;
          __asm { vmovss  xmm2, dword ptr [rax+28h]; length }
          Particle_DebugAxis(&axis, &center, *(float *)&_XMM2, 1, 0);
        }
        v21 = (ParticleEmitter *)pEmitterOwner;
        ++_RBX;
        _RDX = v116;
        --m_particleCountRunning;
      }
      while ( m_particleCountRunning );
      __asm
      {
        vmovaps xmm15, [rsp+1E0h+var_E0]
        vmovaps xmm14, [rsp+1E0h+var_D0]
        vmovaps xmm13, [rsp+1E0h+var_C0]
        vmovaps xmm12, [rsp+1E0h+var_B0]
        vmovaps xmm11, [rsp+1E0h+var_A0]
        vmovaps xmm10, [rsp+1E0h+var_90]
        vmovaps xmm9, [rsp+1E0h+var_80]
        vmovaps xmm8, [rsp+1E0h+var_70]
        vmovaps xmm7, [rsp+1E0h+var_60]
        vmovaps xmm6, [rsp+1E0h+var_50]
      }
    }
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetCalculationOffset
==============
*/
void ParticleModuleInitSpawnShape::GetCalculationOffset(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, const ParticleState *pParticleState, float4 *outCalculationOffset)
{
  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovups xmm2, xmmword ptr [rcx+10h]
  }
  _RBX = outCalculationOffset;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vshufps xmm1, xmm2, xmm0, 0FAh ; 'ú'
    vshufps xmm6, xmm2, xmm1, 84h ; ''
  }
  if ( (this->m_flags & 0x80) != 0 )
  {
    __asm
    {
      vmovaps [rsp+88h+var_28], xmm7
      vmovaps [rsp+88h+var_38], xmm8
      vmovaps [rsp+88h+var_48], xmm9
      vmovaps [rsp+88h+var_58], xmm10
    }
    _RAX = ParticleEmitter::GetEmitterTransformTranspose((ParticleEmitter *)pEmitter, pParticleState);
    __asm
    {
      vshufps xmm7, xmm6, xmm6, 0
      vshufps xmm8, xmm6, xmm6, 55h ; 'U'
      vshufps xmm9, xmm6, xmm6, 0AAh ; 'ª'
      vmovups xmm3, xmmword ptr [rax]
      vshufps xmm2, xmm3, xmmword ptr [rax+10h], 0EEh ; 'î'
      vmovups xmm1, xmmword ptr [rax+20h]
      vshufps xmm4, xmm1, xmmword ptr [rax+30h], 44h ; 'D'
      vshufps xmm5, xmm1, xmmword ptr [rax+30h], 0EEh ; 'î'
      vshufps xmm10, xmm6, xmm6, 0FFh
      vshufps xmm6, xmm3, xmmword ptr [rax+10h], 44h ; 'D'
      vshufps xmm3, xmm6, xmm4, 88h ; ''
      vmulps  xmm0, xmm7, xmm3
      vmovaps xmm7, [rsp+88h+var_28]
      vshufps xmm4, xmm6, xmm4, 0DDh ; 'Ý'
      vshufps xmm6, xmm2, xmm5, 88h ; ''
      vshufps xmm5, xmm2, xmm5, 0DDh ; 'Ý'
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm8, xmm4
      vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmovaps xmm8, [rsp+88h+var_38]
      vmulps  xmm1, xmm9, xmm6
      vmovaps xmm9, [rsp+88h+var_48]
      vmulps  xmm0, xmm10, xmm5
      vmovaps xmm10, [rsp+88h+var_58]
      vaddps  xmm2, xmm1, xmm2
      vaddps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rbx], xmm2
    }
  }
  else
  {
    __asm { vmovups xmmword ptr [rbx], xmm6 }
  }
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeBox::GetDimensions(ParticleModuleInitSpawnShapeBox *this, const ParticleState *pParticleState, float4 *dimensionsMin, float4 *dimensionsMax)
{
  const ParticleSystem *SystemOwner; 
  ParticleSpawnFlags m_spawnFlags; 
  ParticleSystem *v15; 
  bool v16; 
  char v22; 
  float4 result; 
  float4 v48; 
  float4 v49; 

  _R14 = dimensionsMax;
  _RDI = dimensionsMin;
  _RBX = this;
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1338, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  _R15 = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = ParticleEmitter::GetSystemOwner(_R15);
  m_spawnFlags = _RBX->m_spawnFlags;
  v15 = (ParticleSystem *)SystemOwner;
  v16 = (m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0;
  if ( _RBX->m_useBeamInfo && (SystemOwner->m_flags & 0x100) != 0 )
  {
    ParticleEmitter::GetBeamLength(_R15, pParticleState);
    __asm
    {
      vmovups xmm2, xmmword ptr [rbx+40h]
      vmovups xmm3, xmmword ptr [rbx+50h]
      vxorps  xmm1, xmm1, xmm1
      vinsertps xmm2, xmm2, xmm1, 10h
      vinsertps xmm3, xmm3, xmm0, 10h
      vmovups xmmword ptr [rdi], xmm2
      vmovups xmmword ptr [r14], xmm3
    }
  }
  else
  {
    v22 = m_spawnFlags & 2;
    if ( v22 || v16 )
    {
      __asm { vmovaps [rsp+0C8h+var_58], xmm7 }
      if ( v22 )
      {
        __asm
        {
          vmovaps [rsp+0C8h+var_48], xmm6
          vmovss  xmm6, dword ptr [r15+178h]
          vmovaps xmm2, xmm6; life
        }
        _RAX = Particle_GetCurveValueFloat4(&result, _RBX->m_curves, *(float *)&_XMM2);
        __asm
        {
          vmovaps xmm2, xmm6; life
          vmovups xmm7, xmmword ptr [rax]
        }
        _RAX = Particle_GetCurveValueFloat4(&result, &_RBX->m_curves[3], *(float *)&_XMM2);
        __asm
        {
          vmovaps xmm6, [rsp+0C8h+var_48]
          vmovups xmm2, xmmword ptr [rax]
        }
      }
      else
      {
        __asm
        {
          vmovups xmm7, xmmword ptr [rbx+20h]
          vmovups xmm0, xmmword ptr [rbx+50h]
          vsubps  xmm2, xmm0, xmm7
        }
      }
      __asm { vmovups [rsp+0C8h+var_88], xmm2 }
      if ( v16 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovups xmmword ptr [rsp+0C8h+result.v], xmm0
        }
        _RAX = ParticleSystem::ApplyScaleModifiers(v15, &v49, &v48, -1, &result, 0);
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovdqu xmmword ptr [rdi], xmm0
          vmovups xmm1, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
          vmovdqa xmmword ptr [rsp+0C8h+result.v], xmm1
        }
        _RAX = ParticleSystem::ApplyScaleModifiers(v15, &v49, &v48, -1, &result, 0);
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovdqu xmmword ptr [r14], xmm0
          vmovups xmm0, xmmword ptr [rax]
          vsubps  xmm0, xmm0, xmmword ptr [rdi]
          vmulps  xmm1, xmm0, xmmword ptr cs:?g_oneHalf@@3Ufloat4@@B.v; float4 const g_oneHalf
          vaddps  xmm2, xmm1, xmmword ptr [rdi]
        }
      }
      __asm
      {
        vaddps  xmm0, xmm2, xmm7
        vmovups xmmword ptr [r14], xmm0
        vxorps  xmm1, xmm1, xmm1
        vsubps  xmm2, xmm1, xmm2
        vaddps  xmm0, xmm2, xmm7
        vmovaps xmm7, [rsp+0C8h+var_58]
        vmovups xmmword ptr [rdi], xmm0
      }
    }
    else
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx+40h]
        vmovdqu xmmword ptr [rdi], xmm0
        vmovups xmm1, xmmword ptr [rbx+50h]
        vmovdqu xmmword ptr [r14], xmm1
      }
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeCylinder::GetDimensions(ParticleModuleInitSpawnShapeCylinder *this, const ParticleState *pParticleState, float *halfHeight, float *radiusMin, float *radiusMax)
{
  ParticleSystem *SystemOwner; 
  float4 v41; 
  float4 v42; 
  float4 v43; 
  float4 v44; 

  _RSI = radiusMin;
  _R14 = radiusMax;
  _RDI = halfHeight;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  _RBP = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(_RBP);
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    __asm
    {
      vmovaps [rsp+0C8h+var_48], xmm6
      vmovss  xmm6, dword ptr [rbp+178h]
      vmovaps xmm1, xmm6; time
    }
    *(double *)&_XMM0 = Particle_GetCurveValue(&this->m_curves[4], *(const float *)&_XMM1);
    __asm
    {
      vmovss  dword ptr [rsi], xmm0
      vmovaps xmm1, xmm6; time
      vmovss  dword ptr [r14], xmm0
    }
    *(double *)&_XMM0 = Particle_GetCurveValue(&this->m_curves[3], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm6, [rsp+0C8h+var_48]
      vmovss  dword ptr [rdi], xmm0
    }
  }
  else
  {
    *_RDI = this->m_halfHeight;
    *_RSI = this->m_radius.min;
    *radiusMax = this->m_radius.max;
  }
  if ( (this->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    __asm
    {
      vmovups xmm1, cs:__xmm@3f800000000000000000000000000000
      vinsertps xmm1, xmm1, dword ptr [rsi], 0
      vmovups xmm2, cs:__xmm@3f800000000000000000000000000000
      vinsertps xmm2, xmm2, dword ptr [r14], 0
      vinsertps xmm1, xmm1, dword ptr [rsi], 10h
      vinsertps xmm2, xmm2, dword ptr [r14], 10h
      vinsertps xmm1, xmm1, dword ptr [rdi], 20h ; ' '
      vinsertps xmm2, xmm2, dword ptr [rdi], 20h ; ' '
      vxorps  xmm0, xmm0, xmm0
      vmovups [rsp+0C8h+var_88], xmm1
      vmovups [rsp+0C8h+var_78], xmm2
      vmovups [rsp+0C8h+var_98], xmm0
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v44, &v42, -1, &v41, 0);
    __asm
    {
      vmovups xmm1, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+0C8h+var_88], xmm0
      vmovdqa [rsp+0C8h+var_98], xmm1
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v44, &v43, -1, &v41, 0);
    __asm
    {
      vmovups xmm3, [rsp+0C8h+var_88]
      vshufps xmm0, xmm3, xmm3, 55h ; 'U'
      vminss  xmm0, xmm0, xmm3
      vmovups xmm2, xmmword ptr [rax]
      vmovss  dword ptr [rsi], xmm0
      vshufps xmm1, xmm2, xmm2, 55h ; 'U'
      vmaxss  xmm0, xmm1, xmm2
      vmovss  dword ptr [r14], xmm0
      vshufps xmm0, xmm3, xmm3, 0AAh ; 'ª'
      vshufps xmm2, xmm2, xmm2, 0AAh ; 'ª'
      vaddss  xmm0, xmm2, xmm0
      vmulss  xmm1, xmm0, cs:__real@3f000000
      vmovss  dword ptr [rdi], xmm1
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::GetDimensions(ParticleModuleInitSpawnShapeEllipsoid *this, const ParticleState *pParticleState, float4 *radiusMin, float4 *radiusMax)
{
  ParticleSystem *SystemOwner; 
  float4 result; 
  float4 v21; 

  _RSI = radiusMax;
  _RDI = radiusMin;
  _RBX = this;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  _RBP = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(_RBP);
  if ( (_RBX->m_spawnFlags & 2) != 0 )
  {
    __asm { vmovss  xmm2, dword ptr [rbp+178h]; life }
    _RAX = Particle_GetCurveValueFloat4(&result, &_RBX->m_curves[3], *(float *)&_XMM2);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovdqu xmmword ptr [rdi], xmm0
      vmovdqu xmmword ptr [rsi], xmm0
    }
  }
  else
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx+30h]
      vmovdqu xmmword ptr [rdi], xmm0
      vmovups xmm1, xmmword ptr [rbx+40h]
      vmovdqu xmmword ptr [rsi], xmm1
    }
  }
  if ( (_RBX->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rsp+88h+result.v], xmm0
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v21, _RDI, -1, &result, 0);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovdqu xmmword ptr [rdi], xmm0
      vmovups xmm1, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      vmovdqa xmmword ptr [rsp+88h+result.v], xmm1
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v21, _RSI, -1, &result, 0);
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovdqu xmmword ptr [rsi], xmm0
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetDimensions
==============
*/
void ParticleModuleInitSpawnShapeSphere::GetDimensions(ParticleModuleInitSpawnShapeSphere *this, const ParticleState *pParticleState, float *radiusMin, float *radiusMax)
{
  ParticleSystem *SystemOwner; 
  float4 v37; 
  float4 v38; 
  float4 v39; 
  float4 v40; 
  float4 v41; 
  float4 v42; 

  _R14 = radiusMax;
  _RDI = radiusMin;
  _RBX = this;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  _RSI = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(_RSI);
  if ( (_RBX->m_spawnFlags & 2) != 0 )
  {
    __asm { vmovss  xmm1, dword ptr [rsi+178h]; time }
    *(double *)&_XMM0 = Particle_GetCurveValue(&_RBX->m_curves[3], *(const float *)&_XMM1);
    __asm { vmovss  dword ptr [rdi], xmm0 }
  }
  else
  {
    *_RDI = _RBX->m_radius.min;
    __asm { vmovss  xmm0, dword ptr [rbx+3Ch] }
  }
  __asm { vmovss  dword ptr [r14], xmm0 }
  if ( (_RBX->m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vmovups xmm1, cs:__xmm@3f800000000000000000000000000000
      vmovups xmm2, cs:__xmm@3f800000000000000000000000000000
      vinsertps xmm1, xmm1, xmm0, 0
      vinsertps xmm1, xmm1, xmm0, 10h
      vinsertps xmm1, xmm1, xmm0, 20h ; ' '
      vmovss  xmm0, dword ptr [r14]
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm0, 10h
      vinsertps xmm2, xmm2, xmm0, 20h ; ' '
      vxorps  xmm0, xmm0, xmm0
      vmovups [rsp+0C8h+var_98], xmm0
      vmovups [rsp+0C8h+var_78], xmm1
      vmovups [rsp+0C8h+var_68], xmm2
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v41, &v39, -1, &v37, 0);
    __asm
    {
      vmovups xmm1, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+0C8h+var_78], xmm0
      vmovdqa [rsp+0C8h+var_88], xmm1
    }
    _RAX = ParticleSystem::ApplyScaleModifiers(SystemOwner, &v42, &v40, -1, &v38, 0);
    __asm
    {
      vmovups xmm1, [rsp+0C8h+var_78]
      vshufps xmm0, xmm1, xmm1, 55h ; 'U'
      vminss  xmm0, xmm0, xmm1
      vmovups xmm4, xmmword ptr [rax]
      vshufps xmm2, xmm1, xmm1, 0AAh ; 'ª'
      vminss  xmm1, xmm0, xmm2
      vmovss  dword ptr [rdi], xmm1
      vshufps xmm0, xmm4, xmm4, 55h ; 'U'
      vmaxss  xmm0, xmm0, xmm4
      vshufps xmm3, xmm4, xmm4, 0AAh ; 'ª'
      vmaxss  xmm1, xmm0, xmm3
      vmovss  dword ptr [r14], xmm1
    }
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/
void ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleEmitter *pEmitter, float4 *outOffset)
{
  const ParticleCurveDef *ModuleCurveList; 
  float4 result; 

  _RBX = outOffset;
  if ( (this->m_spawnFlags & 2) != 0 )
  {
    __asm
    {
      vmovaps [rsp+48h+var_18], xmm6
      vmovss  xmm6, dword ptr [rdx+178h]
    }
    ModuleCurveList = ParticleModule::GetModuleCurveList(this);
    __asm { vmovaps xmm2, xmm6; life }
    _RAX = Particle_GetCurveValueFloat4(&result, ModuleCurveList, *(float *)&_XMM2);
    __asm
    {
      vmovaps xmm6, [rsp+48h+var_18]
      vmovups xmm0, xmmword ptr [rax]
      vmovdqa xmmword ptr [rbx], xmm0
    }
  }
  else
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rcx+20h]
      vmovdqa xmmword ptr [r8], xmm0
    }
  }
}

/*
==============
ParticleModuleInitSpawnShape::GetOffsetForShape
==============
*/
void ParticleModuleInitSpawnShape::GetOffsetForShape(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, float4 *outOffset)
{
  const ParticleCurveDef *ModuleCurveList; 
  float4 result; 

  _RDI = outOffset;
  _RBX = this;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  if ( (_RBX->m_spawnFlags & 2) != 0 )
  {
    _RAX = pParticleState->m_pEmitterOwner;
    __asm
    {
      vmovaps [rsp+58h+var_18], xmm6
      vmovss  xmm6, dword ptr [rax+178h]
    }
    ModuleCurveList = ParticleModule::GetModuleCurveList(_RBX);
    __asm { vmovaps xmm2, xmm6; life }
    _RAX = Particle_GetCurveValueFloat4(&result, ModuleCurveList, *(float *)&_XMM2);
    __asm
    {
      vmovaps xmm6, [rsp+58h+var_18]
      vmovups xmm0, xmmword ptr [rax]
    }
  }
  else
  {
    __asm { vmovups xmm0, xmmword ptr [rbx+20h] }
  }
  __asm { vmovdqa xmmword ptr [rdi], xmm0 }
}

/*
==============
ParticleModuleInitSpawnShape::GetRandomSeed
==============
*/
__int64 ParticleModuleInitSpawnShape::GetRandomSeed(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState, ParticleData *pParticleData, const int particleIndex)
{
  unsigned __int8 v4; 
  ParticleEmitter *EmitterOwner; 

  v4 = particleIndex;
  if ( (this->m_spawnFlags & 8) == 0 )
    return (unsigned int)Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[particleIndex];
  EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
  return (ParticleEmitter::GetEmitterDef(EmitterOwner)->randomSeed + EmitterOwner->m_lifetimeParticleCount + 10111 * v4) % 0x3FE9;
}

/*
==============
ParticleModuleInitSpawnShape::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShape::GetVolumeSize(ParticleModuleInitSpawnShape *this, const ParticleState *pParticleState)
{
  const ParticleSystem *SystemOwner; 
  ParticleSpawnFlags m_spawnFlags; 
  float radiusMax; 
  float radiusMin; 
  float v47; 
  float4 dimensionsMin; 
  float4 dimensionsMax; 

  _RBX = this;
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1237, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pParticleState->m_pEmitterOwner);
  m_spawnFlags = _RBX->m_spawnFlags;
  if ( (m_spawnFlags & 4) != 0 && (SystemOwner->m_flags & 0x40000000) != 0 || (m_spawnFlags & 2) != 0 )
  {
    if ( _RBX->m_spawnType )
    {
      switch ( _RBX->m_spawnType )
      {
        case PARTICLE_SPAWN_SHAPE_CYLINDER:
          ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)_RBX, pParticleState, &radiusMax, &v47, &radiusMin);
          __asm { vmovss  xmm2, [rsp+78h+radiusMin] }
          if ( (_RBX->m_spawnFlags & 1) != 0 )
          {
            __asm
            {
              vmulss  xmm1, xmm2, [rsp+78h+radiusMax]
              vmulss  xmm0, xmm1, cs:__real@41490fdb
            }
          }
          else
          {
            __asm
            {
              vmovss  xmm5, [rsp+78h+var_40]
              vsubss  xmm0, xmm2, xmm5
              vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
              vcomiss xmm0, cs:__real@3a83126f
              vmovss  xmm0, [rsp+78h+radiusMax]
              vmulss  xmm1, xmm0, cs:__real@40490fdb
              vmulss  xmm4, xmm1, cs:__real@40000000
              vmulss  xmm0, xmm5, xmm5
              vmulss  xmm1, xmm0, xmm4
              vmulss  xmm2, xmm2, xmm2
              vmulss  xmm3, xmm2, xmm4
              vsubss  xmm0, xmm3, xmm1
              vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
            }
          }
          break;
        case PARTICLE_SPAWN_SHAPE_ELLIPSOID:
          ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)_RBX, pParticleState, &dimensionsMax, &dimensionsMin);
          *(double *)&_XMM0 = ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize((ParticleModuleInitSpawnShapeEllipsoid *)_RBX, &dimensionsMax, &dimensionsMin);
          break;
        case PARTICLE_SPAWN_SHAPE_SPHERE:
          ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)_RBX, pParticleState, &radiusMin, &radiusMax);
          __asm { vmovss  xmm1, [rsp+78h+radiusMax] }
          if ( (_RBX->m_spawnFlags & 1) != 0 )
          {
            __asm
            {
              vmulss  xmm0, xmm1, cs:__real@41490fdb
              vmulss  xmm0, xmm0, xmm1
            }
          }
          else
          {
            __asm
            {
              vmovss  xmm4, [rsp+78h+radiusMin]
              vmovss  xmm5, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
              vsubss  xmm0, xmm1, xmm4
              vandps  xmm0, xmm0, xmm5
              vcomiss xmm0, cs:__real@3a83126f
              vmulss  xmm0, xmm1, xmm1
              vmulss  xmm1, xmm0, xmm1
              vmulss  xmm3, xmm1, cs:__real@40860a92
              vmulss  xmm0, xmm4, xmm4
              vmulss  xmm1, xmm0, xmm4
              vmulss  xmm2, xmm1, cs:__real@40860a92
              vsubss  xmm0, xmm3, xmm2
              vandps  xmm0, xmm0, xmm5
            }
          }
          break;
        default:
          __asm { vmovss  xmm0, cs:__real@3f800000 }
          return *(float *)&_XMM0;
      }
    }
    else
    {
      ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)_RBX, pParticleState, &dimensionsMin, &dimensionsMax);
      __asm
      {
        vmovups xmm0, xmmword ptr [rsp+78h+dimensionsMax.v]
        vsubps  xmm4, xmm0, xmmword ptr [rsp+78h+dimensionsMin.v]
      }
      if ( (_RBX->m_spawnFlags & 1) != 0 )
      {
        __asm
        {
          vshufps xmm3, xmm4, xmm4, 55h ; 'U'
          vaddss  xmm0, xmm3, xmm4
          vshufps xmm1, xmm4, xmm4, 0AAh ; 'ª'
          vmulss  xmm2, xmm0, xmm1
          vmulss  xmm1, xmm3, xmm4
          vaddss  xmm2, xmm2, xmm1
          vmulss  xmm0, xmm2, cs:__real@40000000
        }
      }
      else
      {
        __asm
        {
          vshufps xmm0, xmm4, xmm4, 55h ; 'U'
          vmulss  xmm1, xmm0, xmm4
          vshufps xmm0, xmm4, xmm4, 0AAh ; 'ª'
          vmulss  xmm0, xmm1, xmm0; X
        }
      }
    }
    *(float *)&_XMM0 = cbrtf(*(float *)&_XMM0);
    return *(float *)&_XMM0;
  }
  __asm { vmovss  xmm0, dword ptr [rbx+0Ch] }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleInitSpawnShapeBox::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeBox::GetVolumeSize(ParticleModuleInitSpawnShapeBox *this, const float4 *dimensions)
{
  if ( (this->m_spawnFlags & 1) != 0 )
  {
    __asm
    {
      vmovups xmm4, xmmword ptr [rdx]
      vaddss  xmm0, xmm4, dword ptr [rdx+4]
      vmulss  xmm2, xmm0, dword ptr [rdx+8]
      vmulss  xmm1, xmm4, dword ptr [rdx+4]
      vaddss  xmm2, xmm2, xmm1
      vmulss  xmm0, xmm2, cs:__real@40000000
    }
  }
  else
  {
    __asm
    {
      vmovups xmm1, xmmword ptr [rdx]
      vmulss  xmm1, xmm1, dword ptr [rdx+4]
      vmulss  xmm0, xmm1, dword ptr [rdx+8]
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::GetVolumeSize
==============
*/

float __fastcall ParticleModuleInitSpawnShapeCylinder::GetVolumeSize(ParticleModuleInitSpawnShapeCylinder *this, double halfHeight, double radiusMin, double radiusMax)
{
  __asm { vmovaps xmm4, xmm2 }
  if ( (this->m_spawnFlags & 1) != 0 )
  {
    __asm
    {
      vmulss  xmm0, xmm1, xmm3
      vmulss  xmm0, xmm0, cs:__real@41490fdb
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm5, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vsubss  xmm0, xmm3, xmm2
      vandps  xmm0, xmm0, xmm5
      vcomiss xmm0, cs:__real@3a83126f
      vmulss  xmm0, xmm1, cs:__real@40490fdb
      vmulss  xmm2, xmm0, cs:__real@40000000
      vmulss  xmm0, xmm4, xmm4
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm3, xmm1, xmm2
      vmulss  xmm2, xmm0, xmm2
      vsubss  xmm0, xmm3, xmm2
      vandps  xmm0, xmm0, xmm5
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize
==============
*/
float ParticleModuleInitSpawnShapeEllipsoid::GetVolumeSize(ParticleModuleInitSpawnShapeEllipsoid *this, const float4 *radiusMin, const float4 *radiusMax)
{
  __asm
  {
    vmovaps [rsp+28h+var_18], xmm7
    vmovups xmm1, xmmword ptr [r8]
    vmovss  xmm3, cs:__real@40860a92
    vmovups xmm2, xmm1
    vmulss  xmm1, xmm1, dword ptr [r8+4]
    vshufps xmm0, xmm2, xmm2, 0AAh ; 'ª'
    vmulss  xmm1, xmm1, xmm0
    vmulss  xmm7, xmm1, xmm3
    vsubps  xmm1, xmm2, xmmword ptr [rdx]
    vmulps  xmm2, xmm1, xmm1
    vhaddps xmm0, xmm2, xmm2
  }
  if ( (this->m_spawnFlags & 1) != 0 )
  {
    __asm
    {
      vmovss  xmm4, cs:__real@3f800000
      vmovss  xmm0, dword ptr [r8+4]
      vmovups xmm1, xmmword ptr [r8]
      vsubss  xmm2, xmm0, xmm4
      vsubss  xmm0, xmm1, xmm4
      vmulss  xmm1, xmm0, xmm3
      vmulss  xmm3, xmm2, xmm1
      vmovss  xmm2, dword ptr [r8+8]
      vsubss  xmm0, xmm2, xmm4
      vmulss  xmm2, xmm3, xmm0
    }
  }
  else
  {
    __asm
    {
      vhaddps xmm0, xmm0, xmm0
      vsqrtps xmm1, xmm0
      vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm1, cs:__real@3a83126f
      vmovups xmm1, xmmword ptr [rdx]
      vmulss  xmm1, xmm1, dword ptr [rdx+4]
      vmulss  xmm0, xmm1, dword ptr [rdx+8]
      vmulss  xmm2, xmm0, xmm3
    }
  }
  __asm
  {
    vsubss  xmm0, xmm7, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovaps xmm7, [rsp+28h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleInitSpawnShapeSphere::GetVolumeSize
==============
*/

float __fastcall ParticleModuleInitSpawnShapeSphere::GetVolumeSize(ParticleModuleInitSpawnShapeSphere *this, double radiusMin, double radiusMax)
{
  if ( (this->m_spawnFlags & 1) != 0 )
  {
    __asm
    {
      vmulss  xmm0, xmm2, cs:__real@41490fdb
      vmulss  xmm0, xmm0, xmm2
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm5, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vsubss  xmm0, xmm2, xmm1
      vandps  xmm0, xmm0, xmm5
      vcomiss xmm0, cs:__real@3a83126f
      vmulss  xmm0, xmm2, xmm2
      vmulss  xmm2, xmm0, xmm2
      vmulss  xmm4, xmm2, cs:__real@40860a92
      vmulss  xmm0, xmm1, xmm1
      vmulss  xmm1, xmm0, xmm1
      vmulss  xmm2, xmm1, cs:__real@40860a92
      vsubss  xmm0, xmm4, xmm2
      vandps  xmm0, xmm0, xmm5
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleInitAtlas::Init
==============
*/
void ParticleModuleInitAtlas::Init(ParticleModule *pModuleBase)
{
  pModuleBase[1].m_flags = -1;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitAttributes::Init
==============
*/
void ParticleModuleInitAttributes::Init(ParticleModule *pModuleBase)
{
  __asm
  {
    vmovaps ymm0, cs:__ymm@0000000041200000412000004120000000000000412000004120000041200000
    vmovaps ymm1, cs:__ymm@3f8000003f8000003f8000003f8000003f8000003f8000003f8000003f800000
    vmovups ymmword ptr [rcx+10h], ymm0
    vmovaps ymm0, cs:__ymm@000000004248000000000000000000000000000041c800000000000000000000
    vmovups ymmword ptr [rcx+50h], ymm0
    vmovups ymmword ptr [rcx+30h], ymm1
  }
}

/*
==============
ParticleModuleInitBeam::Init
==============
*/
void ParticleModuleInitBeam::Init(ParticleModule *pModuleBase)
{
  __asm
  {
    vmovups xmm1, cs:__xmm@00000000000000000000000042c80000
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rcx+10h], xmm0
    vmovups xmmword ptr [rcx+20h], xmm1
  }
  pModuleBase[1].m_flags = 1092616192;
}

/*
==============
ParticleModuleInitCloud::Init
==============
*/
void ParticleModuleInitCloud::Init(ParticleModule *pModuleBase)
{
  ;
}

/*
==============
ParticleModuleInitDecal::Init
==============
*/
void ParticleModuleInitDecal::Init(ParticleModule *pModuleBase)
{
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rcx+20h], xmm0
  }
  *((_BYTE *)&pModuleBase[6].m_type + 3) = 5;
}

/*
==============
ParticleModuleInitDismember::Init
==============
*/
void ParticleModuleInitDismember::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 50;
  LOBYTE(pModuleBase[1].m_flags) = 0;
}

/*
==============
ParticleModuleInitFlare::Init
==============
*/
void ParticleModuleInitFlare::Init(ParticleModule *pModuleBase)
{
  __asm { vmovups xmm0, cs:__xmm@0000000000000000000000003f800000 }
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
  pModuleBase[5] = 0i64;
  pModuleBase[6] = 0i64;
  *(_DWORD *)&pModuleBase[8].m_type = 1065353216;
  pModuleBase[8].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[9].m_type = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[7] = 0i64;
  pModuleBase[4] = 0i64;
  __asm { vmovups xmmword ptr [rcx+10h], xmm0 }
}

/*
==============
ParticleModuleInitGeoTrail::Init
==============
*/
void ParticleModuleInitGeoTrail::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 16;
  pModuleBase[2].m_flags = 0;
  *(_QWORD *)&pModuleBase[1].m_flags = 1112014848i64;
  *(_DWORD *)&pModuleBase[3].m_type = 1;
  *(_QWORD *)&pModuleBase[4].m_flags = 1112014848i64;
  pModuleBase[5].m_flags = 0;
}

/*
==============
ParticleModuleInitLightOmni::Init
==============
*/
void ParticleModuleInitLightOmni::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3] = (ParticleModule)1061752795i64;
  *(_QWORD *)&pModuleBase[6].m_flags = 0i64;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
  pModuleBase[4].m_flags = 998277249;
  *(_DWORD *)&pModuleBase[5].m_type = 1056964608;
  *(_QWORD *)&pModuleBase[5].m_flags = 1065353216i64;
  pModuleBase[7].m_flags = 1057803469;
  *(_DWORD *)&pModuleBase[8].m_type = 1053609165;
  pModuleBase[8].m_flags = 1016296636;
  *(_DWORD *)&pModuleBase[9].m_type = 1065353216;
  pModuleBase[9].m_flags = 16842752;
}

/*
==============
ParticleModuleInitLightSpot::Init
==============
*/
void ParticleModuleInitLightSpot::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3] = (ParticleModule)1061752795i64;
  pModuleBase[7] = 0i64;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
  pModuleBase[4].m_flags = 998277249;
  *(_DWORD *)&pModuleBase[5].m_type = 1045220557;
  pModuleBase[5].m_flags = 1070141403;
  pModuleBase[6] = (ParticleModule)1092616192i64;
  *(_DWORD *)&pModuleBase[8].m_type = 1057803469;
  pModuleBase[8].m_flags = 1053609165;
  *(_DWORD *)&pModuleBase[9].m_type = 1016296636;
  pModuleBase[9].m_flags = 1090519040;
  *(_DWORD *)&pModuleBase[10].m_type = 1065353216;
  pModuleBase[10].m_flags = 0x1000000;
}

/*
==============
ParticleModuleInitOcclusionQuery::Init
==============
*/
void ParticleModuleInitOcclusionQuery::Init(ParticleModule *pModuleBase)
{
  pModuleBase[2].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[3].m_type = 1065353216;
  pModuleBase[3].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[4].m_type = 1065353216;
}

/*
==============
ParticleModuleInitOrientedSprite::Init
==============
*/
void ParticleModuleInitOrientedSprite::Init(ParticleModule *pModuleBase)
{
  __asm
  {
    vmovups xmm0, xmmword ptr cs:?g_unit@@3Ufloat4@@B.v; float4 const g_unit
    vmovups xmmword ptr [rcx+10h], xmm0
  }
}

/*
==============
ParticleModuleInitParticleSim::Init
==============
*/
void ParticleModuleInitParticleSim::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[3].m_type = 1065353216;
  pModuleBase[3].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitRunner::Init
==============
*/
void ParticleModuleInitRunner::Init(ParticleModule *pModuleBase)
{
  __asm
  {
    vmovaps ymm0, cs:__ymm@000000003f8000003f8000003f800000000000003f8000003f8000003f800000
    vmovups ymmword ptr [rcx+10h], ymm0
    vmovups ymmword ptr [rcx+30h], ymm0
  }
}

/*
==============
ParticleModuleInitSpawn::Init
==============
*/
void ParticleModuleInitSpawn::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeBox::Init
==============
*/
void ParticleModuleInitSpawnShapeBox::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::Init
==============
*/
void ParticleModuleInitSpawnShapeCylinder::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::Init
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeMesh::Init
==============
*/
void ParticleModuleInitSpawnShapeMesh::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitSpawnShapeSphere::Init
==============
*/
void ParticleModuleInitSpawnShapeSphere::Init(ParticleModule *pModuleBase)
{
  LOBYTE(pModuleBase[1].m_type) = 63;
  *((_BYTE *)&pModuleBase[1].m_type + 2) = 2;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleInitVolumetric::Init
==============
*/
void ParticleModuleInitVolumetric::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1028443341;
  pModuleBase[1].m_flags = 1066192077;
  pModuleBase[2] = (ParticleModule)1065353216i64;
}

/*
==============
ParticleModuleInitAttributes::InitParticleColor
==============
*/
void ParticleModuleInitAttributes::InitParticleColor(const ParticleModuleInitAttributes *pModule, float4 *colorArray, const int *randomSeedArray, __int64 particleCountEmit)
{
  if ( (_DWORD)particleCountEmit )
  {
    particleCountEmit = (unsigned int)particleCountEmit;
    _R10 = fx_randomTable;
    do
    {
      _RAX = *randomSeedArray;
      __asm { vmovups xmm0, xmmword ptr [rcx+40h] }
      if ( pModule->m_useNonUniformInterpolationForColor )
      {
        __asm
        {
          vmovss  xmm1, dword ptr [r10+rax*4+64h]
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+70h], 30h ; '0'
          vsubps  xmm0, xmm0, xmmword ptr [rcx+30h]
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmmword ptr [rcx+30h]
          vmovups xmmword ptr [rdx], xmm2
        }
      }
      else
      {
        __asm
        {
          vsubps  xmm1, xmm0, xmmword ptr [rcx+30h]
          vbroadcastss xmm0, dword ptr [r10+rax*4+60h]
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm1, xmm0, xmmword ptr [rcx+30h]
          vmovups xmmword ptr [rdx], xmm1
        }
      }
      ++randomSeedArray;
      ++colorArray;
      --particleCountEmit;
    }
    while ( particleCountEmit );
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticleSize
==============
*/
void ParticleModuleInitAttributes::InitParticleSize(const ParticleModuleInitAttributes *pModule, float4 *sizeArray, const int *randomSeedArray, __int64 particleCountEmit)
{
  _R10 = sizeArray;
  if ( (_DWORD)particleCountEmit )
  {
    _RAX = 0i64;
    particleCountEmit = (unsigned int)particleCountEmit;
    _R11 = fx_randomTable;
    do
    {
      _RDX = *randomSeedArray;
      __asm { vmovups xmm0, xmmword ptr [rcx+20h] }
      if ( pModule->m_useNonUniformInterpolationForSize )
      {
        __asm
        {
          vsubps  xmm0, xmm0, xmmword ptr [rcx+10h]
          vxorps  xmm1, xmm1, xmm1
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A0h], 0
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A4h], 10h
          vinsertps xmm1, xmm1, dword ptr [r11+rdx*4+0A8h], 20h ; ' '
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmmword ptr [rcx+10h]
          vmovups xmmword ptr [rax+r10], xmm2
        }
      }
      else
      {
        __asm
        {
          vsubps  xmm1, xmm0, xmmword ptr [rcx+10h]
          vbroadcastss xmm0, dword ptr [r11+rdx*4+0A0h]
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm1, xmm0, xmmword ptr [rcx+10h]
          vmovups xmmword ptr [rax+r10], xmm1
        }
      }
      ++randomSeedArray;
      _RAX += 16i64;
      --particleCountEmit;
    }
    while ( particleCountEmit );
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticleVelocity
==============
*/
void ParticleModuleInitAttributes::InitParticleVelocity(const ParticleModuleInitAttributes *pModule, float4 *velocityArray, const int *randomSeedArray, const ParticleState *pParticleState, const unsigned int particleCountEmit)
{
  ParticleEmitter *m_pEmitterOwner; 
  char v14; 
  __int64 v28; 
  float4 lookAtInput; 
  vector3 outMatrix; 

  _RBX = velocityArray;
  _RSI = pModule;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  _RBP = ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
  if ( !_RBP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 572, ASSERT_TYPE_ASSERT, "(pParticleSystem)", (const char *)&queryFormat, "pParticleSystem") )
    __debugbreak();
  if ( (_RBP->m_flags & 0x4000) != 0 && (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->flags & 0x100) != 0 )
  {
    v14 = 1;
    ParticleEmitter::GetEmitterTransformTranspose(m_pEmitterOwner, pParticleState);
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+90h]
      vshufps xmm2, xmm0, xmm0, 0
      vshufps xmm4, xmm0, xmm0, 55h ; 'U'
      vshufps xmm5, xmm0, xmm0, 0AAh ; 'ª'
      vmulps  xmm0, xmm2, xmmword ptr [rax]
      vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm4, xmmword ptr [rax+10h]
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm5, xmmword ptr [rax+20h]
      vaddps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm2, xmm1
      vandps  xmm0, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
      vmovups xmmword ptr [rsp+0D8h+lookAtInput.v], xmm0
    }
    Particle_GenerateMatrixFromLookAt(&lookAtInput, &outMatrix);
  }
  else
  {
    v14 = 0;
  }
  if ( particleCountEmit )
  {
    __asm
    {
      vmovups xmm5, xmmword ptr [rsp+0D8h+outMatrix.z.v]
      vmovaps [rsp+0D8h+var_38], xmm6
      vmovups xmm6, xmmword ptr [rsp+0D8h+outMatrix.y.v]
      vmovaps [rsp+0D8h+var_48], xmm7
    }
    v28 = particleCountEmit;
    __asm { vmovups xmm7, xmmword ptr [rsp+0D8h+outMatrix.x.v] }
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rsi+60h]
        vsubps  xmm0, xmm0, xmmword ptr [rsi+50h]
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4], 0
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4+4], 10h
        vinsertps xmm1, xmm1, dword ptr [rdx+rax*4+8], 20h ; ' '
        vmulps  xmm1, xmm1, xmm0
        vaddps  xmm3, xmm1, xmmword ptr [rsi+50h]
        vmovups xmmword ptr [rbx], xmm3
      }
      if ( v14 )
      {
        __asm
        {
          vshufps xmm2, xmm3, xmm3, 55h ; 'U'
          vshufps xmm0, xmm3, xmm3, 0
          vmulps  xmm0, xmm7, xmm0
          vshufps xmm4, xmm3, xmm3, 0AAh ; 'ª'
          vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
          vmulps  xmm0, xmm6, xmm2
          vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
          vmulps  xmm1, xmm5, xmm4
          vaddps  xmm0, xmm1, xmm3
          vaddps  xmm0, xmm2, xmm0
          vmovups xmmword ptr [rbx], xmm0
          vandps  xmm0, xmm0, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
          vmovups xmmword ptr [rbx], xmm0
        }
      }
      ++randomSeedArray;
      ++_RBX;
      --v28;
    }
    while ( v28 );
    __asm
    {
      vmovaps xmm7, [rsp+0D8h+var_48]
      vmovaps xmm6, [rsp+0D8h+var_38]
    }
  }
}

/*
==============
ParticleModuleInitAtlas::InitParticles
==============
*/
void ParticleModuleInitAtlas::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  __int64 m_particleCountRunning; 
  __int64 v12; 
  unsigned int v14; 
  __int64 v15; 
  __int64 v24; 
  unsigned int v29; 
  unsigned int v34; 
  __int64 v35; 
  __int64 v43; 
  __int64 v45; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 543, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v45) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v45, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 365, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  _RDI = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_ATLAS_INDEX)[4 * m_particleCountRunning];
  if ( LOBYTE(pModuleBase[2].m_type) )
  {
    Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
    v12 = 0i64;
    if ( particleCountEmit >= 4 )
    {
      _R8 = _RDI + 4;
      v14 = ((particleCountEmit - 4) >> 2) + 1;
      v15 = v14;
      v12 = 4 * v14;
      do
      {
        _R8 += 16;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmovss  dword ptr [r8-14h], xmm0
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmovss  dword ptr [r8-10h], xmm0
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmovss  dword ptr [r8-0Ch], xmm0
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmovss  dword ptr [r8-8], xmm0
        }
        --v15;
      }
      while ( v15 );
    }
    if ( (unsigned int)v12 < particleCountEmit )
    {
      _R8 = &_RDI[4 * v12];
      v24 = particleCountEmit - (unsigned int)v12;
      do
      {
        _R8 += 4;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmovss  dword ptr [r8-4], xmm0
        }
        --v24;
      }
      while ( v24 );
    }
  }
  else
  {
    _RDX = 0i64;
    if ( particleCountEmit )
    {
      if ( particleCountEmit >= 0x10 )
      {
        _R8 = pModuleBase + 1;
        __asm
        {
          vmovd   xmm0, dword ptr [r8]
          vpshufd xmm0, xmm0, 0
        }
        if ( _RDI > (unsigned __int8 *)&pModuleBase[1] || &_RDI[4 * particleCountEmit - 4] < (unsigned __int8 *)_R8 )
        {
          __asm { vcvtdq2ps xmm0, xmm0 }
          v29 = 8;
          do
          {
            __asm { vmovups xmmword ptr [rdi+rdx*4], xmm0 }
            _RAX = v29 - 4;
            _RDX = (unsigned int)(_RDX + 16);
            __asm { vmovups xmmword ptr [rdi+rax*4], xmm0 }
            _RAX = v29;
            __asm { vmovups xmmword ptr [rdi+rax*4], xmm0 }
            _RAX = v29 + 4;
            v29 += 16;
            __asm { vmovups xmmword ptr [rdi+rax*4], xmm0 }
          }
          while ( (unsigned int)_RDX < (particleCountEmit & 0xFFFFFFF0) );
        }
      }
      if ( (unsigned int)_RDX < particleCountEmit )
      {
        if ( particleCountEmit - (unsigned int)_RDX >= 4 )
        {
          _RCX = (__int64)&_RDI[4 * _RDX + 8];
          v34 = ((particleCountEmit - (unsigned int)_RDX - 4) >> 2) + 1;
          v35 = v34;
          _RDX = (unsigned int)_RDX + 4 * v34;
          do
          {
            _RCX += 16i64;
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
              vmovss  dword ptr [rcx-18h], xmm0
              vxorps  xmm1, xmm1, xmm1
              vcvtsi2ss xmm1, xmm1, dword ptr [rbx+8]
              vmovss  dword ptr [rcx-14h], xmm1
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
              vmovss  dword ptr [rcx-10h], xmm0
              vxorps  xmm1, xmm1, xmm1
              vcvtsi2ss xmm1, xmm1, dword ptr [rbx+8]
              vmovss  dword ptr [rcx-0Ch], xmm1
            }
            --v35;
          }
          while ( v35 );
        }
        if ( (unsigned int)_RDX < particleCountEmit )
        {
          _RCX = &_RDI[4 * _RDX];
          v43 = particleCountEmit - (unsigned int)_RDX;
          do
          {
            _RCX += 4;
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
              vmovss  dword ptr [rcx-4], xmm0
            }
            --v43;
          }
          while ( v43 );
        }
      }
    }
  }
}

/*
==============
ParticleModuleInitAttributes::InitParticles
==============
*/
void ParticleModuleInitAttributes::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  const int *RandomSeedArrayNextFreeElem; 
  float4 *VelocityArrayAtIndex; 
  __int64 m_particleCountRunning; 
  const int *v16; 
  __int64 v17; 
  __int64 v18; 
  const int *v30; 
  ParticleSystem *v44; 
  const float4 *v45; 
  __int64 v47; 
  int v48; 
  __int64 v53; 
  float4 v54; 
  float4 result; 

  _RBX = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (_RBX->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 659, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  result.v.m128_u64[0] = (unsigned __int64)pParticleState->m_pEmitterOwner;
  v54.v.m128_u64[0] = (unsigned __int64)ParticleEmitter::GetSystemOwner((ParticleEmitter *)result.v.m128_u64[0]);
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 342, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 348, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  _RSI = Particle_GetSizeArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v53) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v53, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 343, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  _RDI = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_COLOR)[16 * m_particleCountRunning];
  ParticleModuleInitAttributes::InitParticleVelocity((const ParticleModuleInitAttributes *)_RBX, VelocityArrayAtIndex, RandomSeedArrayNextFreeElem, pParticleState, particleCountEmit);
  if ( particleCountEmit )
  {
    _RAX = _RSI;
    _R10 = fx_randomTable;
    v16 = RandomSeedArrayNextFreeElem;
    v17 = particleCountEmit;
    v18 = particleCountEmit;
    do
    {
      _RDX = *v16;
      __asm { vmovups xmm0, xmmword ptr [rbx+20h] }
      if ( HIBYTE(_RBX[1].m_type) )
      {
        __asm
        {
          vsubps  xmm0, xmm0, xmmword ptr [rbx+10h]
          vxorps  xmm1, xmm1, xmm1
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A0h], 0
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A4h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rdx*4+0A8h], 20h ; ' '
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmmword ptr [rbx+10h]
          vmovups xmmword ptr [rax], xmm2
        }
      }
      else
      {
        __asm
        {
          vsubps  xmm1, xmm0, xmmword ptr [rbx+10h]
          vbroadcastss xmm0, dword ptr [r10+rdx*4+0A0h]
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm1, xmm0, xmmword ptr [rbx+10h]
          vmovups xmmword ptr [rax], xmm1
        }
      }
      ++v16;
      ++_RAX;
      --v18;
    }
    while ( v18 );
    v30 = RandomSeedArrayNextFreeElem;
    do
    {
      _RAX = *v30;
      __asm { vmovups xmm0, xmmword ptr [rbx+40h] }
      if ( LOBYTE(_RBX[1].m_type) )
      {
        __asm
        {
          vmovss  xmm1, dword ptr [r10+rax*4+64h]
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, dword ptr [r10+rax*4+70h], 30h ; '0'
          vsubps  xmm0, xmm0, xmmword ptr [rbx+30h]
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmmword ptr [rbx+30h]
          vmovups xmmword ptr [rdi], xmm2
        }
      }
      else
      {
        __asm
        {
          vsubps  xmm1, xmm0, xmmword ptr [rbx+30h]
          vbroadcastss xmm0, dword ptr [r10+rax*4+60h]
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm1, xmm0, xmmword ptr [rbx+30h]
          vmovups xmmword ptr [rdi], xmm1
        }
      }
      ++v30;
      _RDI += 16;
      --v17;
    }
    while ( v17 );
  }
  v44 = (ParticleSystem *)v54.v.m128_u64[0];
  if ( (*(_DWORD *)(v54.v.m128_u64[0] + 416) & 0x40000000) != 0 && (ParticleEmitter::GetEmitterDef((ParticleEmitter *)result.v.m128_u64[0])->flags & 0x800000) == 0 && particleCountEmit )
  {
    v45 = _RSI;
    _R15 = (char *)VelocityArrayAtIndex - (char *)_RSI;
    v47 = particleCountEmit;
    do
    {
      v48 = *RandomSeedArrayNextFreeElem;
      _RAX = ParticleSystem::ApplyVelocityModifiers(v44, &result, (const float4 *)((char *)v45 + _R15), *RandomSeedArrayNextFreeElem);
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovdqu xmmword ptr [r15+rsi], xmm0
      }
      _RAX = ParticleSystem::ApplyScaleModifiers(v44, &v54, v45++, v48, 1);
      ++_RSI;
      ++RandomSeedArrayNextFreeElem;
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovdqu xmmword ptr [rsi-10h], xmm0
      }
      --v47;
    }
    while ( v47 );
  }
}

/*
==============
ParticleModuleInitBeam::InitParticles
==============
*/
void ParticleModuleInitBeam::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ParticleEmitter *m_pEmitterOwner; 
  __int64 v10; 
  float4 outStartPos; 
  float4 outEndPos; 

  _RDI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (_RDI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 693, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  if ( (ParticleEmitter::GetSystemOwner(m_pEmitterOwner)->m_flags & 0x100) == 0 )
  {
    _RBX = Particle_GetPositionArrayNextFreeElem(pParticleData);
    ParticleEmitter::GetBeamPos(m_pEmitterOwner, pParticleState, &outStartPos, &outEndPos);
    if ( particleCountEmit )
    {
      v10 = particleCountEmit;
      do
      {
        ++_RBX;
        __asm
        {
          vmovups xmm1, xmmword ptr [rdi+30h]
          vaddps  xmm1, xmm1, xmmword ptr [rsp+78h+outStartPos.v]
          vmovups xmmword ptr [rbx-10h], xmm1
        }
        --v10;
      }
      while ( v10 );
    }
  }
}

/*
==============
ParticleModuleInitCameraOffset::InitParticles
==============
*/
void ParticleModuleInitCameraOffset::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitCloud::InitParticles
==============
*/
void ParticleModuleInitCloud::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitDecal::InitParticles
==============
*/
void ParticleModuleInitDecal::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitDismember::InitParticles
==============
*/
void ParticleModuleInitDismember::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitFlare::InitParticles
==============
*/
void ParticleModuleInitFlare::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitGeoTrail::InitParticles
==============
*/
void ParticleModuleInitGeoTrail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitKillWrapBox::InitParticles
==============
*/
void ParticleModuleInitKillWrapBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitLightOmni::InitParticles
==============
*/
void ParticleModuleInitLightOmni::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitLightSpot::InitParticles
==============
*/
void ParticleModuleInitLightSpot::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitMaterial::InitParticles
==============
*/
void ParticleModuleInitMaterial::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitMirrorTexture::InitParticles
==============
*/
void ParticleModuleInitMirrorTexture::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitModel::InitParticles
==============
*/
void ParticleModuleInitModel::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitOcclusionQuery::InitParticles
==============
*/
void ParticleModuleInitOcclusionQuery::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitOrientedSprite::InitParticles
==============
*/
void ParticleModuleInitOrientedSprite::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitParticleSim::InitParticles
==============
*/
void ParticleModuleInitParticleSim::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitPlayerFacing::InitParticles
==============
*/
void ParticleModuleInitPlayerFacing::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitRelativeVelocity::InitParticles
==============
*/
void ParticleModuleInitRelativeVelocity::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitRotation3D::InitParticles
==============
*/
void ParticleModuleInitRotation3D::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  int *RandomSeedArrayNextFreeElem; 
  float4 *RotationAngleArrayNextFreeElem; 
  float4 *RotationRateArrayNextFreeElem; 
  __int64 v19; 

  _RSI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (_RSI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1140, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  RotationAngleArrayNextFreeElem = Particle_GetRotationAngleArrayNextFreeElem(pParticleData);
  RotationRateArrayNextFreeElem = Particle_GetRotationRateArrayNextFreeElem(pParticleData);
  _RCX = RotationRateArrayNextFreeElem;
  __asm
  {
    vmovups xmm2, xmmword ptr [rsi+10h]
    vmovups xmm0, xmmword ptr [rsi+20h]
    vmovups xmm3, xmmword ptr [rsi+30h]
    vmovups xmm1, xmmword ptr [rsi+40h]
  }
  if ( particleCountEmit )
  {
    __asm
    {
      vsubps  xmm4, xmm0, xmm2
      vsubps  xmm5, xmm1, xmm3
    }
    _RBP = (char *)RotationAngleArrayNextFreeElem - (char *)RotationRateArrayNextFreeElem;
    v19 = particleCountEmit;
    do
    {
      ++_RCX;
      ++RandomSeedArrayNextFreeElem;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+88h], 0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+8Ch], 10h
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+90h], 20h ; ' '
        vmulps  xmm0, xmm0, xmm4
        vaddps  xmm1, xmm0, xmm2
        vmovups xmmword ptr [rcx+rbp-10h], xmm1
        vxorps  xmm0, xmm0, xmm0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+94h], 0
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+98h], 10h
        vinsertps xmm0, xmm0, dword ptr [r8+rax*4+9Ch], 20h ; ' '
        vmulps  xmm0, xmm0, xmm5
        vaddps  xmm1, xmm0, xmm3
        vmovups xmmword ptr [rcx-10h], xmm1
      }
      --v19;
    }
    while ( v19 );
  }
}

/*
==============
ParticleModuleInitRotation::InitParticles
==============
*/
void ParticleModuleInitRotation::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  int *RandomSeedArrayNextFreeElem; 
  float4 *RotationAngleArrayNextFreeElem; 
  float4 *RotationRateArrayNextFreeElem; 
  __int64 v15; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1114, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  RandomSeedArrayNextFreeElem = Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
  RotationAngleArrayNextFreeElem = Particle_GetRotationAngleArrayNextFreeElem(pParticleData);
  RotationRateArrayNextFreeElem = Particle_GetRotationRateArrayNextFreeElem(pParticleData);
  _RCX = RotationRateArrayNextFreeElem;
  if ( particleCountEmit )
  {
    __asm { vmovss  xmm3, cs:__real@3f800000 }
    _RBP = (char *)RotationAngleArrayNextFreeElem - (char *)RotationRateArrayNextFreeElem;
    _R8 = fx_randomTable;
    v15 = particleCountEmit;
    do
    {
      _RAX = *RandomSeedArrayNextFreeElem;
      ++_RCX;
      ++RandomSeedArrayNextFreeElem;
      __asm
      {
        vmovss  xmm1, dword ptr [r8+rax*4+88h]
        vsubss  xmm0, xmm3, xmm1
        vmulss  xmm2, xmm0, dword ptr [rdi+10h]
        vmulss  xmm1, xmm1, dword ptr [rdi+14h]
        vaddss  xmm0, xmm2, xmm1
        vshufps xmm0, xmm0, xmm0, 0
        vmovups xmmword ptr [rcx+rbp-10h], xmm0
        vmovss  xmm1, dword ptr [r8+rax*4+94h]
        vsubss  xmm0, xmm3, xmm1
        vmulss  xmm2, xmm0, dword ptr [rdi+18h]
        vmulss  xmm1, xmm1, dword ptr [rdi+1Ch]
        vaddss  xmm0, xmm2, xmm1
        vshufps xmm0, xmm0, xmm0, 0
        vmovups xmmword ptr [rcx-10h], xmm0
      }
      --v15;
    }
    while ( v15 );
  }
}

/*
==============
ParticleModuleInitRunner::InitParticles
==============
*/
void ParticleModuleInitRunner::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSound::InitParticles
==============
*/
void ParticleModuleInitSound::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSpawn::InitParticles
==============
*/
void ParticleModuleInitSpawn::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitSpawnShapeBox::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeBox::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  float4 *PositionArrayNextFreeElem; 
  unsigned int v15; 
  ParticleEmitter *m_pEmitterOwner; 
  signed int v20; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  unsigned int v27; 
  __int64 v55; 
  __int64 v56; 
  signed __int64 v57; 
  signed __int64 v58; 
  float4 dimensionsMax; 
  float4 dimensionsMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1417, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+0E8h+var_48], xmm6
    vmovaps [rsp+0E8h+var_58], xmm7
  }
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
  _RSI = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShapeBox::GetDimensions((ParticleModuleInitSpawnShapeBox *)pModuleBase, pParticleState, &dimensionsMin, &dimensionsMax);
  v15 = 0;
  if ( (HIBYTE(pModuleBase[1].m_type) & 1) != 0 )
  {
    if ( particleCountEmit )
    {
      __asm
      {
        vmovaps [rsp+0E8h+var_68], xmm8
        vmovups xmm8, xmmword ptr [rsp+0E8h+dimensionsMin.v]
        vmovaps [rsp+0E8h+var_78], xmm9
        vmovups xmm9, xmmword ptr [rsp+0E8h+dimensionsMax.v]
      }
      v57 = (char *)PositionArrayNextFreeElem - (char *)_RSI;
      _R13 = fx_randomTable;
      while ( 1 )
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v20 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v15) % 0x3FE9;
        }
        else
        {
          v20 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v15];
        }
        _RAX = v20;
        __asm
        {
          vmovss  xmm6, dword ptr [r13+rax*4+18h]
          vmovss  xmm7, dword ptr [r13+rax*4+1Ch]
        }
        v24 = (6 * LOWORD(fx_randomTable[v20 + 8])) >> 16;
        if ( v24 >= 6 )
        {
          LODWORD(v56) = 6;
          LODWORD(v55) = (6 * LOWORD(fx_randomTable[v20 + 8])) >> 16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v55, v56) )
            __debugbreak();
        }
        if ( !v24 )
          break;
        v25 = v24 - 1;
        if ( !v25 )
        {
          __asm { vmovups xmm1, cs:__xmm@0000000000000000000000003f800000 }
LABEL_42:
          __asm { vinsertps xmm1, xmm1, xmm6, 10h }
          goto LABEL_43;
        }
        v26 = v25 - 1;
        if ( v26 )
        {
          v27 = v26 - 1;
          if ( v27 )
          {
            if ( v27 == 1 )
            {
              __asm
              {
                vxorps  xmm1, xmm1, xmm1
                vinsertps xmm1, xmm1, xmm6, 0
                vinsertps xmm1, xmm1, xmm7, 10h
              }
            }
            else
            {
              __asm
              {
                vmovups xmm1, cs:__xmm@000000003f8000000000000000000000
                vinsertps xmm1, xmm1, xmm6, 0
                vinsertps xmm1, xmm1, xmm7, 10h
              }
            }
            goto LABEL_44;
          }
          __asm
          {
            vmovups xmm1, cs:__xmm@00000000000000003f80000000000000
            vinsertps xmm1, xmm1, xmm6, 0
          }
        }
        else
        {
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vinsertps xmm1, xmm1, xmm6, 0
          }
        }
LABEL_43:
        __asm { vinsertps xmm1, xmm1, xmm7, 20h ; ' ' }
LABEL_44:
        _RAX = v57;
        ++v15;
        __asm
        {
          vsubps  xmm0, xmm9, xmm8
          vmulps  xmm1, xmm0, xmm1
          vaddps  xmm2, xmm1, xmm8
          vmovups xmmword ptr [rax+rsi], xmm2
          vmovups xmmword ptr [rsi], xmm2
        }
        ++_RSI;
        if ( v15 >= particleCountEmit )
        {
          __asm
          {
            vmovaps xmm9, [rsp+0E8h+var_78]
            vmovaps xmm8, [rsp+0E8h+var_68]
          }
          goto LABEL_55;
        }
      }
      __asm { vxorps  xmm1, xmm1, xmm1 }
      goto LABEL_42;
    }
  }
  else if ( particleCountEmit )
  {
    __asm
    {
      vmovups xmm7, xmmword ptr [rsp+0E8h+dimensionsMax.v]
      vmovups xmm6, xmmword ptr [rsp+0E8h+dimensionsMin.v]
    }
    _RBX = (char *)PositionArrayNextFreeElem - (char *)_RSI;
    v58 = _RBX;
    do
    {
      if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
      {
        if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        ParticleEmitter::GetEmitterDef((ParticleEmitter *)pParticleState->m_pEmitterOwner);
        _RBX = v58;
      }
      else
      {
        Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
      }
      ++v15;
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vsubps  xmm0, xmm7, xmm6
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+18h], 0
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+1Ch], 10h
        vinsertps xmm1, xmm1, dword ptr [r13+rax*4+20h], 20h ; ' '
        vmulps  xmm1, xmm1, xmm0
        vaddps  xmm2, xmm1, xmm6
        vmovups xmmword ptr [rsi+rbx], xmm2
        vmovups xmmword ptr [rsi], xmm2
      }
      ++_RSI;
    }
    while ( v15 < particleCountEmit );
  }
LABEL_55:
  __asm
  {
    vmovaps xmm7, [rsp+0E8h+var_58]
    vmovaps xmm6, [rsp+0E8h+var_48]
  }
}

/*
==============
ParticleModuleInitSpawnShapeCylinder::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeCylinder::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ParticleData *v18; 
  ParticleState *v19; 
  float4 *SpawnPosArrayNextFreeElem; 
  char m_type; 
  unsigned int v23; 
  const float4 *v25; 
  vector3 *v26; 
  char v27; 
  ParticleEmitter *EmitterOwner; 
  ParticleEmitter *v42; 
  const vector4 *EmitterTransformTranspose; 
  const vector4 *v44; 
  unsigned int v47; 
  ParticleEmitter *m_pEmitterOwner; 
  unsigned int v53; 
  bool v70; 
  bool v71; 
  bool v84; 
  unsigned int v150; 
  unsigned __int8 *ParticleDataArray; 
  unsigned int v152; 
  unsigned __int8 *v153; 
  unsigned int v155; 
  ParticleModuleAxesFlags v160; 
  bool v189; 
  __int64 v191; 
  ParticleModuleAxesFlags v201; 
  char m_type_high; 
  char v241; 
  char v242; 
  char v243; 
  float halfHeight[2]; 
  float radiusMax; 
  unsigned int v246; 
  float4 *PositionArrayNextFreeElem; 
  float radiusMin; 
  float c; 
  float s; 
  float v252; 
  float v253[3]; 
  float4 outOffset; 
  __int64 v255; 
  const FxCamera *v256; 
  ParticleData *v257; 
  const ParticleState *v258; 
  __int64 v259; 
  vector4 result; 
  vec3_t outPos; 
  vec3_t v264; 
  __int64 v265; 
  __int128 v266; 
  __int128 v267; 
  __int128 v268; 

  v256 = pCamera;
  v18 = pParticleData;
  v257 = pParticleData;
  v19 = (ParticleState *)pParticleState;
  v258 = pParticleState;
  _R13 = (ParticleModule *)pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + v18->m_particleCountRunning > v18->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (_R13->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1614, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_type_high = HIBYTE(_R13[1].m_type);
  v243 = m_type_high & 1;
  __asm { vmovaps [rsp+278h+var_D8], xmm15 }
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(v18);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(v18);
  m_type = _R13[6].m_type;
  v242 = m_type;
  v23 = _R13->m_flags >> 7;
  _R14 = (__int64)SpawnPosArrayNextFreeElem;
  v255 = (__int64)SpawnPosArrayNextFreeElem;
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)_R13, v19, &outOffset);
  ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)_R13, v19, halfHeight, &radiusMin, &radiusMax);
  v27 = v23 & 1;
  if ( v27 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner(v19);
    ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, v19);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsp+278h+outOffset.v]
      vshufps xmm2, xmm0, xmm0, 0
      vshufps xmm4, xmm0, xmm0, 55h ; 'U'
      vshufps xmm5, xmm0, xmm0, 0AAh ; 'ª'
      vmulps  xmm0, xmm2, xmmword ptr [rax]
      vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm4, xmmword ptr [rax+10h]
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm5, xmmword ptr [rax+20h]
      vaddps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm2, xmm1
      vandps  xmm15, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
    }
  }
  else
  {
    __asm { vmovups xmm15, xmmword ptr [rsp+278h+outOffset.v] }
  }
  __asm
  {
    vmovaps [rsp+278h+var_48], xmm6
    vmovups xmm0, xmmword ptr cs:?g_unit@@3Ufloat4@@B.v; float4 const g_unit
    vmovdqa xmmword ptr [rsp+278h+result.w.v], xmm0
  }
  if ( m_type )
  {
    __asm { vmovups xmm0, xmmword ptr [r13+40h] }
    Float4UnitQuatToAxis(v26, v25);
    __asm
    {
      vmovups xmmword ptr [rsp+278h+var_188+10h], xmm1
      vmovups xmmword ptr [rsp+278h+var_188], xmm0
      vmovups ymm3, [rsp+278h+var_188]
      vmovups ymmword ptr [rsp+278h+result.baseclass_0.x.v], ymm3
      vmovups xmm6, xmm2
      vmovups xmmword ptr [rsp+278h+outOffset.v], xmm2
      vmovups xmmword ptr [rsp+278h+result.baseclass_0.z.v], xmm2
    }
    if ( !v27 )
      goto LABEL_26;
    v42 = (ParticleEmitter *)ParticleState::GetEmitterOwner(v19);
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(v42, v19);
    Float4x4Mul(&result, EmitterTransformTranspose, v44);
    __asm
    {
      vmovups xmmword ptr [rsp+278h+var_168], xmm2
      vmovups xmmword ptr [rsp+278h+var_188], xmm0
      vmovups xmmword ptr [rsp+278h+var_168+10h], xmm3
      vmovups ymm0, [rsp+278h+var_168]
      vmovups xmmword ptr [rsp+278h+var_188+10h], xmm1
      vmovups ymm2, [rsp+278h+var_188]
      vmovups ymmword ptr [rsp+278h+result.baseclass_0.x.v], ymm2
      vmovups ymmword ptr [rsp+278h+result.baseclass_0.z.v], ymm0
    }
  }
  __asm
  {
    vmovups xmm6, xmmword ptr [rsp+278h+result.baseclass_0.z.v]
    vmovups xmmword ptr [rsp+278h+outOffset.v], xmm6
  }
LABEL_26:
  v47 = 0;
  v246 = 0;
  if ( particleCountEmit )
  {
    v241 = m_type_high & 0x10;
    PositionArrayNextFreeElem = (float4 *)((char *)PositionArrayNextFreeElem - _R14);
    __asm
    {
      vmovaps [rsp+278h+var_58], xmm7
      vmovss  xmm7, [rsp+278h+radiusMax]
      vmovaps [rsp+278h+var_68], xmm8
      vmovss  xmm8, cs:__real@40c90fdb
      vmovaps [rsp+278h+var_78], xmm9
      vmovss  xmm9, dword ptr cs:__xmm@80000000800000008000000080000000
      vmovaps [rsp+278h+var_88], xmm10
      vmovaps [rsp+278h+var_98], xmm11
      vmovss  xmm11, [rsp+278h+halfHeight]
      vmovaps [rsp+278h+var_A8], xmm12
      vmovaps [rsp+278h+var_B8], xmm13
      vmovaps [rsp+278h+var_C8], xmm14
    }
    do
    {
      if ( (HIBYTE(_R13[1].m_type) & 8) != 0 )
      {
        if ( !v19->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        m_pEmitterOwner = (ParticleEmitter *)v19->m_pEmitterOwner;
        v53 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v47) % 0x3FE9;
      }
      else
      {
        v53 = Particle_GetRandomSeedArrayNextFreeElem(v18)[v47];
      }
      LODWORD(halfHeight[1]) = v53;
      if ( v243 )
      {
        __asm { vmovaps xmm12, xmm7 }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, cs:__real@3f800000
          vsubss  xmm0, xmm0, dword ptr [rax+rbx*4+2Ch]
          vmulss  xmm2, xmm0, [rsp+278h+radiusMin]
          vmulss  xmm1, xmm7, dword ptr [rax+rbx*4+2Ch]
          vaddss  xmm12, xmm2, xmm1
        }
      }
      if ( v241 )
      {
        __asm
        {
          vmovaps xmm14, xmm8
          vmovss  xmm8, dword ptr [r13+1Ch]
          vxorps  xmm10, xmm10, xmm10
          vcomiss xmm8, xmm10
          vxorps  xmm13, xmm13, xmm13
        }
        _RAX = v256;
        __asm
        {
          vmovss  xmm0, dword ptr [rax]
          vmovss  xmm1, dword ptr [rax+4]
          vmovss  xmm2, dword ptr [rax+8]
        }
        HIDWORD(v266) = 0;
        __asm
        {
          vmovups xmm6, xmmword ptr [rsp+160h]
          vmovss  xmm6, xmm6, xmm0
          vinsertps xmm6, xmm6, xmm1, 10h
          vinsertps xmm6, xmm6, xmm2, 20h ; ' '
          vmovups xmmword ptr [rsp+160h], xmm6
        }
        if ( !v19->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        ParticleEmitter::GetEmitterTransform((ParticleEmitter *)v19->m_pEmitterOwner, v19);
        __asm
        {
          vsubps  xmm7, xmm6, xmmword ptr [rax+30h]
          vshufps xmm9, xmm7, xmm7, 55h ; 'U'
          vmulss  xmm0, xmm9, xmm9
          vmulss  xmm1, xmm7, xmm7
          vaddss  xmm11, xmm1, xmm0
          vmulss  xmm1, xmm9, xmm9
          vmulss  xmm2, xmm7, xmm7
          vaddss  xmm10, xmm2, xmm1
          vsqrtss xmm6, xmm10, xmm10
          vaddss  xmm0, xmm8, xmm12
          vcomiss xmm6, xmm0
        }
        if ( v70 || v71 )
        {
          __asm
          {
            vsubss  xmm0, xmm12, xmm8
            vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
            vcomiss xmm6, xmm0
          }
          if ( !v70 )
          {
            __asm
            {
              vmovss  xmm1, cs:__real@34000000
              vcomiss xmm6, xmm1
            }
            if ( v70 || v71 )
              __asm { vcomiss xmm0, xmm1 }
            __asm { vucomiss xmm6, cs:__real@00000000 }
            if ( v71 )
            {
              v84 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 652, ASSERT_TYPE_SANITY, "( val != 0.0f )", (const char *)&queryFormat, "val != 0.0f");
              v70 = 0;
              v71 = !v84;
              if ( v84 )
                __debugbreak();
            }
            __asm
            {
              vcomiss xmm11, cs:__real@34000000
              vmovss  xmm0, cs:__real@3f800000
              vdivss  xmm6, xmm0, xmm6
              vmulss  xmm4, xmm12, xmm12
              vmulss  xmm0, xmm8, xmm8
              vsubss  xmm1, xmm4, xmm0
              vaddss  xmm2, xmm1, xmm10
              vmulss  xmm3, xmm2, xmm6
              vmulss  xmm0, xmm3, cs:__real@3f000000
              vmulss  xmm5, xmm0, xmm6
              vmulss  xmm1, xmm3, xmm3
              vmulss  xmm2, xmm1, cs:__real@3e800000
              vsubss  xmm0, xmm4, xmm2
              vsqrtss xmm3, xmm0, xmm0
              vmulss  xmm4, xmm3, xmm6
              vmulss  xmm1, xmm9, xmm4
              vmulss  xmm0, xmm7, xmm5
              vaddss  xmm1, xmm1, xmm0
              vmulss  xmm0, xmm7, xmm4
              vmulss  xmm2, xmm9, xmm5
              vmovss  dword ptr [rsp+278h+var_1D8], xmm1
              vsubss  xmm1, xmm2, xmm0
              vmovss  dword ptr [rsp+278h+var_1D8+4], xmm1
            }
            if ( !v70 && !v71 )
            {
              __asm
              {
                vandps  xmm0, xmm9, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
                vaddss  xmm2, xmm0, cs:__real@2edbe6ff
                vaddss  xmm4, xmm7, xmm2
                vsubss  xmm1, xmm7, xmm2
                vxorps  xmm10, xmm10, xmm10
                vcomiss xmm11, xmm10
                vsubss  xmm2, xmm2, xmm7
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm3, xmm4, xmm1, xmm0
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm0, xmm2, xmm4, xmm0
                vdivss  xmm3, xmm3, xmm0
                vmulss  xmm1, xmm3, cs:__real@3e4902de
                vmulss  xmm2, xmm1, xmm3
                vsubss  xmm0, xmm2, cs:__real@3f7b50b1
                vmovss  xmm1, cs:__real@3f490fdb
                vmovss  xmm2, cs:__real@4016cbe4
                vmulss  xmm4, xmm0, xmm3
                vcmpless xmm0, xmm10, xmm7
                vblendvps xmm0, xmm2, xmm1, xmm0
                vaddss  xmm2, xmm4, xmm0
                vxorps  xmm1, xmm2, cs:__xmm@80000000800000008000000080000000
                vcmpless xmm0, xmm10, xmm9
                vblendvps xmm0, xmm1, xmm2, xmm0
                vmovss  [rsp+278h+var_224], xmm0
              }
              if ( (v70 || v71) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 639, ASSERT_TYPE_SANITY, "( val > 0 )", (const char *)&queryFormat, "val > 0") )
                __debugbreak();
              __asm
              {
                vmovss  xmm8, cs:__real@3f800000
                vxorps  xmm0, xmm0, xmm0
              }
              v265 = v259;
              __asm
              {
                vmovss  xmm3, dword ptr [rsp+278h+var_128]
                vmovss  xmm5, dword ptr [rsp+278h+var_128+4]
                vmovaps xmm1, xmm11
                vmovss  xmm6, xmm0, xmm1
                vmulss  xmm0, xmm3, xmm3
                vmulss  xmm1, xmm5, xmm5
                vaddss  xmm1, xmm1, xmm0
                vsqrtss xmm2, xmm1, xmm1
                vcmpless xmm0, xmm2, cs:__real@80000000
                vblendvps xmm0, xmm2, xmm8, xmm0
                vdivss  xmm1, xmm8, xmm0
                vmulss  xmm4, xmm3, xmm1
                vmulss  xmm2, xmm5, xmm1
                vrsqrtss xmm6, xmm6, xmm6
                vmulss  xmm1, xmm7, xmm6
                vmulss  xmm0, xmm9, xmm6
                vmulss  xmm3, xmm0, xmm2
                vmulss  xmm2, xmm1, xmm4
                vmovss  xmm1, cs:__real@bf800000; min
                vaddss  xmm0, xmm3, xmm2; val
                vmovaps xmm2, xmm8; max
              }
              *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
              *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
              __asm
              {
                vmovss  xmm1, [rsp+278h+var_224]
                vmulss  xmm14, xmm0, cs:__real@40000000
                vsubss  xmm13, xmm1, xmm0
              }
            }
          }
        }
        __asm { vmovss  xmm9, dword ptr cs:__xmm@80000000800000008000000080000000 }
        v150 = v47 + v18->m_particleCountRunning;
        if ( !v18->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 344, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
          __debugbreak();
        ParticleDataArray = ParticleData::GetParticleDataArray(v18, PARTICLE_DATA_SPAWN_POS);
        __asm { vmovss  xmm11, [rsp+278h+halfHeight] }
        v152 = v150 + 1;
        v153 = ParticleDataArray;
        __asm { vxorps  xmm6, xmm6, xmm6 }
        if ( v150 + 1 > 8 )
          v152 = 8;
        v155 = 0;
        __asm { vxorps  xmm7, xmm7, xmm7 }
        if ( v152 )
        {
          __asm
          {
            vmovups xmm10, xmmword ptr [rsp+278h+outOffset.v]
            vxorps  xmm8, xmm11, xmm9
            vsubss  xmm9, xmm11, xmm8
            vmovups xmm11, xmmword ptr [rsp+278h+result.baseclass_0.y.v]
          }
          do
          {
            v160 = _R13[1].m_type;
            __asm
            {
              vmulss  xmm0, xmm14, dword ptr [rax+rbx*4+24h]
              vaddss  xmm0, xmm0, xmm13; radians
            }
            FastSinCos(*(const float *)&_XMM0, &s, &c);
            __asm
            {
              vmovss  xmm0, [rsp+278h+c]
              vmovss  xmm1, [rsp+278h+s]
              vmulss  xmm2, xmm0, xmm12
              vmulss  xmm0, xmm9, dword ptr [rax+rbx*4+28h]
              vaddss  xmm4, xmm0, xmm8
              vmulss  xmm3, xmm1, xmm12
              vmovss  dword ptr [rsp+278h+outPos+8], xmm4
              vmovss  dword ptr [rsp+278h+outPos], xmm2
              vmovss  dword ptr [rsp+278h+outPos+4], xmm3
            }
            if ( v160 != PARTICLE_MODULE_AXES_FLAG_ALL )
            {
              Particle_SpawnShapeConvertPos(v160, &outPos);
              __asm
              {
                vmovss  xmm4, dword ptr [rsp+278h+outPos+8]
                vmovss  xmm3, dword ptr [rsp+278h+outPos+4]
                vmovss  xmm2, dword ptr [rsp+278h+outPos]
              }
            }
            HIDWORD(v267) = 0;
            __asm
            {
              vmovups xmm1, xmmword ptr [rsp+170h]
              vmovss  xmm1, xmm1, xmm2
              vinsertps xmm1, xmm1, xmm3, 10h
              vinsertps xmm1, xmm1, xmm4, 20h ; ' '
              vmovups xmmword ptr [rsp+170h], xmm1
            }
            if ( v242 )
            {
              __asm
              {
                vshufps xmm2, xmm1, xmm1, 55h ; 'U'
                vshufps xmm0, xmm1, xmm1, 0
                vmulps  xmm0, xmm0, xmmword ptr [rsp+278h+result.baseclass_0.x.v]
                vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
                vmulps  xmm0, xmm11, xmm2
                vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
                vshufps xmm4, xmm1, xmm1, 0AAh ; 'ª'
                vmulps  xmm1, xmm10, xmm4
                vaddps  xmm0, xmm1, xmm3
                vaddps  xmm2, xmm2, xmm0
                vandps  xmm1, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
              }
            }
            __asm
            {
              vmovss  xmm3, cs:__real@7f7fffff
              vaddps  xmm4, xmm15, xmm1
            }
            v189 = v150 == 0;
            if ( v150 )
            {
              _RAX = v153;
              v191 = v150;
              do
              {
                __asm { vmovups xmm0, xmmword ptr [rax] }
                _RAX += 16;
                __asm
                {
                  vsubps  xmm1, xmm0, xmm4
                  vmulps  xmm2, xmm1, xmm1
                  vinsertps xmm0, xmm2, xmm2, 8
                  vhaddps xmm1, xmm0, xmm0
                  vhaddps xmm2, xmm1, xmm1
                  vminss  xmm3, xmm2, xmm3
                }
                v70 = v191-- == 0;
                v189 = v70 || v191 == 0;
              }
              while ( v191 );
            }
            __asm { vcomiss xmm3, xmm6 }
            if ( !v189 )
              __asm { vmovdqa xmm7, xmm4 }
            ++v155;
            __asm { vmaxss  xmm6, xmm3, xmm6 }
          }
          while ( v155 < v152 );
          __asm { vmovss  xmm11, [rsp+278h+halfHeight] }
        }
        _R14 = v255;
        _RAX = PositionArrayNextFreeElem;
        __asm
        {
          vmovss  xmm9, dword ptr cs:__xmm@80000000800000008000000080000000
          vmovss  xmm8, cs:__real@40c90fdb
        }
        v47 = v246;
        v18 = v257;
        m_type = v242;
        __asm
        {
          vmovups xmmword ptr [rax+r14], xmm7
          vmovups xmmword ptr [r14], xmm7
          vmovss  xmm7, [rsp+278h+radiusMax]
        }
      }
      else
      {
        __asm { vmulss  xmm0, xmm8, dword ptr [rax+rbx*4+24h]; radians }
        v201 = _R13[1].m_type;
        FastSinCos(*(const float *)&_XMM0, v253, &v252);
        __asm
        {
          vmovss  xmm0, [rsp+278h+var_218]
          vmovss  xmm1, [rsp+278h+var_214]
          vmulss  xmm3, xmm0, xmm12
          vxorps  xmm2, xmm11, xmm9
          vsubss  xmm0, xmm11, xmm2
          vmulss  xmm0, xmm0, dword ptr [rax+rbx*4+28h]
          vaddss  xmm5, xmm0, xmm2
          vmulss  xmm4, xmm1, xmm12
          vmovss  dword ptr [rsp+278h+var_138+8], xmm5
          vmovss  dword ptr [rsp+278h+var_138], xmm3
          vmovss  dword ptr [rsp+278h+var_138+4], xmm4
        }
        if ( v201 != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(v201, &v264);
          __asm
          {
            vmovss  xmm5, dword ptr [rsp+278h+var_138+8]
            vmovss  xmm4, dword ptr [rsp+278h+var_138+4]
            vmovss  xmm3, dword ptr [rsp+278h+var_138]
          }
        }
        HIDWORD(v268) = 0;
        __asm
        {
          vmovups xmm1, xmmword ptr [rsp+180h]
          vmovss  xmm1, xmm1, xmm3
          vinsertps xmm1, xmm1, xmm4, 10h
          vinsertps xmm1, xmm1, xmm5, 20h ; ' '
          vmovups xmmword ptr [rsp+180h], xmm1
        }
        if ( m_type )
        {
          __asm
          {
            vshufps xmm2, xmm1, xmm1, 55h ; 'U'
            vshufps xmm0, xmm1, xmm1, 0
            vmulps  xmm0, xmm0, xmmword ptr [rsp+278h+result.baseclass_0.x.v]
            vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
            vmulps  xmm0, xmm2, xmmword ptr [rsp+278h+result.baseclass_0.y.v]
            vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
            vshufps xmm4, xmm1, xmm1, 0AAh ; 'ª'
            vmulps  xmm1, xmm6, xmm4
            vaddps  xmm0, xmm1, xmm3
            vaddps  xmm2, xmm2, xmm0
            vandps  xmm1, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
          }
        }
        _RAX = PositionArrayNextFreeElem;
        __asm
        {
          vaddps  xmm0, xmm15, xmm1
          vmovups xmmword ptr [rax+r14], xmm0
          vmovups xmmword ptr [r14], xmm0
        }
      }
      __asm { vmovups xmm6, xmmword ptr [rsp+278h+outOffset.v] }
      v19 = (ParticleState *)v258;
      ++v47;
      _R14 += 16i64;
      v246 = v47;
      v255 = _R14;
    }
    while ( v47 < particleCountEmit );
    __asm
    {
      vmovaps xmm14, [rsp+278h+var_C8]
      vmovaps xmm13, [rsp+278h+var_B8]
      vmovaps xmm12, [rsp+278h+var_A8]
      vmovaps xmm11, [rsp+278h+var_98]
      vmovaps xmm10, [rsp+278h+var_88]
      vmovaps xmm9, [rsp+278h+var_78]
      vmovaps xmm8, [rsp+278h+var_68]
      vmovaps xmm7, [rsp+278h+var_58]
    }
  }
  __asm
  {
    vmovaps xmm15, [rsp+278h+var_D8]
    vmovaps xmm6, [rsp+278h+var_48]
  }
}

/*
==============
ParticleModuleInitSpawnShapeEllipsoid::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeEllipsoid::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  char m_type_high; 
  unsigned int v20; 
  ParticleEmitter *m_pEmitterOwner; 
  unsigned int v28; 
  bool v29; 
  bool v30; 
  ParticleModuleAxesFlags m_type; 
  unsigned int v59; 
  ParticleEmitter *v66; 
  unsigned int v67; 
  bool v68; 
  bool v69; 
  ParticleModuleAxesFlags v70; 
  double v116; 
  double v117; 
  float c; 
  float s; 
  float4 *SpawnPosArrayNextFreeElem; 
  float4 outOffset; 
  vec3_t outPos; 
  __int128 v123; 
  float4 radiusMax; 
  float4 radiusMin; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1965, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_type_high = HIBYTE(pModuleBase[1].m_type);
  __asm
  {
    vmovaps [rsp+170h+var_40], xmm6
    vmovaps [rsp+170h+var_50], xmm7
    vmovaps [rsp+170h+var_60], xmm8
    vmovaps [rsp+170h+var_70], xmm9
    vmovaps [rsp+170h+var_80], xmm10
    vmovaps [rsp+170h+var_90], xmm11
    vmovaps [rsp+170h+var_A0], xmm12
    vmovaps [rsp+170h+var_B0], xmm13
    vmovaps [rsp+170h+var_C0], xmm14
    vmovaps [rsp+170h+var_D0], xmm15
  }
  _R12 = Particle_GetPositionArrayNextFreeElem(pParticleData);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
  ParticleModuleInitSpawnShapeEllipsoid::GetDimensions((ParticleModuleInitSpawnShapeEllipsoid *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
  if ( (m_type_high & 1) != 0 )
  {
    v20 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)_R12);
      __asm
      {
        vmovups xmm13, xmmword ptr [rsp+170h+outOffset.v]
        vmovss  xmm14, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vmovss  xmm11, cs:__real@40000000
        vmovss  xmm10, cs:__real@3f800000
        vmovss  xmm12, cs:__real@bf800000
        vmovss  xmm15, cs:__real@40c90fdb
      }
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v28 = ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v20;
          v29 = v28 < 16361 * (v28 / 0x3FE9);
          v30 = v28 % 0x3FE9 == 0;
        }
        else
        {
          Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
        }
        m_type = pModuleBase[1].m_type;
        __asm
        {
          vmulss  xmm1, xmm11, dword ptr [rax+r14*4+28h]
          vsubss  xmm8, xmm1, xmm10
          vcomiss xmm8, xmm12
        }
        if ( v29 )
          goto LABEL_60;
        __asm { vcomiss xmm8, xmm10 }
        if ( !v29 && !v30 )
        {
LABEL_60:
          __asm
          {
            vcvtss2sd xmm0, xmm8, xmm8
            vmovsd  [rsp+170h+var_148], xmm0
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v116) )
            __debugbreak();
        }
        __asm
        {
          vmulss  xmm7, xmm8, xmm8
          vsubss  xmm0, xmm10, xmm7
          vsqrtss xmm6, xmm0, xmm0
          vmulss  xmm0, xmm15, dword ptr [rax+r14*4+24h]; radians
        }
        FastSinCos(*(const float *)&_XMM0, &s, &c);
        __asm
        {
          vmovss  xmm0, [rsp+170h+c]
          vmulss  xmm9, xmm0, xmm6
          vmovss  xmm0, [rsp+170h+s]
          vmulss  xmm6, xmm0, xmm6
          vmulss  xmm1, xmm6, xmm6
          vmulss  xmm0, xmm9, xmm9
          vaddss  xmm1, xmm1, xmm0
          vaddss  xmm2, xmm1, xmm7
          vsubss  xmm3, xmm2, xmm10
          vandps  xmm3, xmm3, xmm14
          vcomiss xmm3, cs:__real@358637be
          vmovss  dword ptr [rsp+170h+outPos], xmm9
          vmovss  dword ptr [rsp+170h+outPos+4], xmm6
          vmovss  dword ptr [rsp+170h+outPos+8], xmm8
        }
        if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
          __debugbreak();
        if ( m_type != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(m_type, &outPos);
          __asm
          {
            vmovss  xmm8, dword ptr [rsp+170h+outPos+8]
            vmovss  xmm6, dword ptr [rsp+170h+outPos+4]
            vmovss  xmm9, dword ptr [rsp+170h+outPos]
          }
        }
        ++v20;
        HIDWORD(v123) = 0;
        __asm { vmovups xmm1, xmmword ptr [rsp+60h] }
        _RAX = SpawnPosArrayNextFreeElem;
        __asm
        {
          vmovss  xmm1, xmm1, xmm9
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm8, 20h ; ' '
          vmovups xmmword ptr [r12], xmm1
          vmovups xmmword ptr [rsp+60h], xmm1
          vmulps  xmm1, xmm1, xmmword ptr [rsp+170h+radiusMax.v]
          vaddps  xmm2, xmm13, xmm1
          vmovups xmmword ptr [r12], xmm2
          vmovups xmmword ptr [rax+r12], xmm2
        }
        ++_R12;
      }
      while ( v20 < particleCountEmit );
    }
  }
  else
  {
    v59 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)_R12);
      __asm
      {
        vmovss  xmm13, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vmovss  xmm11, cs:__real@40000000
        vmovss  xmm10, cs:__real@3f800000
        vmovss  xmm12, cs:__real@bf800000
        vmovss  xmm14, cs:__real@40c90fdb
        vmovss  xmm15, cs:__real@358637be
      }
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          v66 = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v67 = ParticleEmitter::GetEmitterDef(v66)->randomSeed + v66->m_lifetimeParticleCount + 10111 * (unsigned __int8)v59;
          v68 = v67 < 16361 * (v67 / 0x3FE9);
          v69 = v67 % 0x3FE9 == 0;
        }
        else
        {
          Particle_GetRandomSeedArrayNextFreeElem(pParticleData);
        }
        v70 = pModuleBase[1].m_type;
        __asm
        {
          vmulss  xmm1, xmm11, dword ptr [rax+r14*4+28h]
          vsubss  xmm8, xmm1, xmm10
          vcomiss xmm8, xmm12
        }
        if ( v68 )
          goto LABEL_61;
        __asm { vcomiss xmm8, xmm10 }
        if ( !v68 && !v69 )
        {
LABEL_61:
          __asm
          {
            vcvtss2sd xmm0, xmm8, xmm8
            vmovsd  [rsp+170h+var_148], xmm0
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v117) )
            __debugbreak();
        }
        __asm
        {
          vmulss  xmm7, xmm8, xmm8
          vsubss  xmm0, xmm10, xmm7
          vsqrtss xmm6, xmm0, xmm0
          vmulss  xmm0, xmm14, dword ptr [rax+r14*4+24h]; radians
        }
        FastSinCos(*(const float *)&_XMM0, &c, &s);
        __asm
        {
          vmovss  xmm0, [rsp+170h+s]
          vmulss  xmm9, xmm0, xmm6
          vmovss  xmm0, [rsp+170h+c]
          vmulss  xmm6, xmm0, xmm6
          vmulss  xmm1, xmm6, xmm6
          vmulss  xmm0, xmm9, xmm9
          vaddss  xmm1, xmm1, xmm0
          vaddss  xmm2, xmm1, xmm7
          vsubss  xmm3, xmm2, xmm10
          vandps  xmm3, xmm3, xmm13
          vcomiss xmm3, xmm15
          vmovss  dword ptr [rsp+170h+outPos], xmm9
          vmovss  dword ptr [rsp+170h+outPos+4], xmm6
          vmovss  dword ptr [rsp+170h+outPos+8], xmm8
        }
        if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
          __debugbreak();
        if ( v70 != PARTICLE_MODULE_AXES_FLAG_ALL )
        {
          Particle_SpawnShapeConvertPos(v70, &outPos);
          __asm
          {
            vmovss  xmm8, dword ptr [rsp+170h+outPos+8]
            vmovss  xmm6, dword ptr [rsp+170h+outPos+4]
            vmovss  xmm9, dword ptr [rsp+170h+outPos]
          }
        }
        ++v59;
        HIDWORD(v123) = 0;
        __asm
        {
          vmovups xmm4, xmmword ptr [rsp+60h]
          vxorps  xmm2, xmm2, xmm2
          vmovss  xmm4, xmm4, xmm9
          vinsertps xmm4, xmm4, xmm6, 10h
          vinsertps xmm4, xmm4, xmm8, 20h ; ' '
          vmovups xmmword ptr [r12], xmm4
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A0h], 0
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A4h], 10h
          vinsertps xmm2, xmm2, dword ptr [rax+r14*4+0A8h], 20h ; ' '
          vmovups xmm0, xmmword ptr [rsp+170h+radiusMax.v]
          vsubps  xmm1, xmm0, xmmword ptr [rbp+70h+radiusMin.v]
        }
        _RAX = SpawnPosArrayNextFreeElem;
        __asm
        {
          vmulps  xmm2, xmm2, xmm1
          vaddps  xmm3, xmm2, xmmword ptr [rbp+70h+radiusMin.v]
          vmulps  xmm0, xmm4, xmm3
          vaddps  xmm1, xmm0, xmmword ptr [rsp+170h+outOffset.v]
          vmovups xmmword ptr [r12], xmm1
          vmovups xmmword ptr [r12+rax], xmm1
        }
        ++_R12;
        __asm { vmovups xmmword ptr [rsp+60h], xmm4 }
      }
      while ( v59 < particleCountEmit );
    }
  }
  __asm
  {
    vmovaps xmm15, [rsp+170h+var_D0]
    vmovaps xmm14, [rsp+170h+var_C0]
    vmovaps xmm13, [rsp+170h+var_B0]
    vmovaps xmm12, [rsp+170h+var_A0]
    vmovaps xmm11, [rsp+170h+var_90]
    vmovaps xmm10, [rsp+170h+var_80]
    vmovaps xmm9, [rsp+170h+var_70]
    vmovaps xmm8, [rsp+170h+var_60]
    vmovaps xmm7, [rsp+170h+var_50]
    vmovaps xmm6, [rsp+170h+var_40]
  }
}

/*
==============
ParticleModuleInitSpawnShapeMesh::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeMesh::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  ParticleData *v9; 
  ParticleState *v10; 
  ParticleModule *v11; 
  __int64 v13; 
  XSurface *v14; 
  __int64 v15; 
  __int64 v16; 
  const XModel *v17; 
  ParticleModule v18; 
  bool v19; 
  _DWORD *v20; 
  unsigned int v21; 
  int v22; 
  int v23; 
  XSurface *v24; 
  __int64 v25; 
  __int64 v26; 
  XSurface *v27; 
  const char *VFXName; 
  unsigned int v29; 
  ParticleEmitter *m_pEmitterOwner; 
  int v33; 
  __int64 v34; 
  const XModel *v35; 
  int *v36; 
  int v37; 
  unsigned int v38; 
  int v39; 
  unsigned int v40; 
  unsigned int v41; 
  unsigned int v42; 
  XSurface *v43; 
  unsigned int v44; 
  const char *v46; 
  const char *XModelSurfsName; 
  unsigned int v48; 
  XSurfaceShared *shared; 
  unsigned __int8 *data; 
  int v61; 
  unsigned int v62; 
  unsigned int v63; 
  unsigned int v64; 
  XSurface *v65; 
  unsigned int v66; 
  const char *v68; 
  const char *v69; 
  unsigned int v70; 
  XSurfaceShared *v71; 
  unsigned __int8 *v72; 
  unsigned __int8 *v73; 
  XSurfaceShared *v74; 
  unsigned __int8 *v75; 
  unsigned __int8 *v76; 
  const Bounds *p_surfBounds; 
  __int64 v78; 
  __int64 v79; 
  __int64 v80; 
  ParticleModuleAxesFlags m_type; 
  const char *v111; 
  __int64 v113; 
  __int64 v114; 
  char m_flags; 
  float4 *PositionArrayNextFreeElem; 
  __int64 v119; 
  unsigned int v120; 
  XSurface *v121; 
  __int64 v122; 
  float4 *SpawnPosArrayNextFreeElem; 
  ParticleModule *v124; 
  ParticleData *v125; 
  vec3_t outPos; 
  vec3_t result; 
  XSurface *surfaces[2]; 
  float4 outOffset; 
  float4 v130; 
  float4 v131; 
  float4 v132; 

  v125 = pParticleData;
  v9 = pParticleData;
  v10 = (ParticleState *)pParticleState;
  v11 = (ParticleModule *)pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + v9->m_particleCountRunning > v9->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (v11->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2078, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = v11[6].m_flags;
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(v9);
  _R15 = PositionArrayNextFreeElem;
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(v9);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)v11, v10, &outOffset);
  if ( *(_DWORD *)&v11[8].m_type )
  {
    v13 = (__int64)&v11[7];
    v14 = (XSurface *)*(int *)&v11[8].m_type;
    v124 = v11 + 7;
    v121 = v14;
    if ( (__int64)v14 > 0 )
    {
      v15 = 0i64;
      v16 = 0i64;
      v119 = 0i64;
      v122 = 0i64;
      do
      {
        v17 = *(const XModel **)(v16 + *(_QWORD *)v13);
        *(_QWORD *)result.v = v17;
        if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2101, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
          __debugbreak();
        v18 = v11[9];
        v19 = v15 + *(_QWORD *)&v18 == 0;
        v20 = (_DWORD *)(v15 + *(_QWORD *)&v18);
        *(_QWORD *)outPos.v = v20;
        if ( v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2104, ASSERT_TYPE_ASSERT, "(pMeshData)", (const char *)&queryFormat, "pMeshData") )
          __debugbreak();
        if ( (v17->flags & 0x8000) == 0 )
        {
          v21 = XModelGetSurfaces(v17, surfaces, 0);
          v22 = 0;
          v23 = 0;
          if ( v21 )
          {
            v24 = surfaces[0];
            v25 = 0i64;
            v26 = v21;
            do
            {
              v27 = &v24[v25];
              if ( !&v24[v25] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2121, ASSERT_TYPE_ASSERT, "(pSurface)", (const char *)&queryFormat, "pSurface") )
                __debugbreak();
              ++v25;
              v22 += v27->vertCount;
              v23 += v27->triCount;
              --v26;
            }
            while ( v26 );
            v17 = *(const XModel **)result.v;
            v20 = *(_DWORD **)outPos.v;
            v16 = v122;
            v15 = v119;
            v14 = v121;
          }
          if ( *v20 == v22 && v20[1] == v23 )
          {
            v10 = (ParticleState *)pParticleState;
          }
          else
          {
            v10 = (ParticleState *)pParticleState;
            VFXName = ParticleState::GetVFXName((ParticleState *)pParticleState);
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2129, ASSERT_TYPE_ASSERT, "(pMeshData->m_numVertsTotal == numVertsTotal && pMeshData->m_numTrisTotal == numTrisTotal)", "%s\n\tERROR: There is a vertex/triangle count mismatch for the model %s, referenced by the effect %s. This may be due to an incorrectly patched model/vfx reference.\n", "pMeshData->m_numVertsTotal == numVertsTotal && pMeshData->m_numTrisTotal == numTrisTotal", v17->name, VFXName) )
              __debugbreak();
          }
          v13 = (__int64)v124;
        }
        v11 = (ParticleModule *)pModuleBase;
        v16 += 32i64;
        v15 += 16i64;
        v122 = v16;
        v14 = (XSurface *)((char *)v14 - 1);
        v119 = v15;
        v121 = v14;
      }
      while ( v14 );
      _R15 = PositionArrayNextFreeElem;
      v9 = v125;
    }
    v29 = 0;
    v120 = 0;
    if ( particleCountEmit )
    {
      SpawnPosArrayNextFreeElem = (float4 *)((char *)SpawnPosArrayNextFreeElem - (__int64)_R15);
      __asm
      {
        vmovaps [rsp+170h+var_50], xmm7
        vmovups xmm7, xmmword ptr [rbp+70h+outOffset.v]
        vmovaps [rsp+170h+var_60], xmm8
        vmovss  xmm8, cs:__real@3f800000
        vmovaps [rsp+170h+var_40], xmm6
      }
      while ( 1 )
      {
        if ( (HIBYTE(v11[1].m_type) & 8) != 0 )
        {
          if ( !v10->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)v10->m_pEmitterOwner;
          v33 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v29) % 0x3FE9;
        }
        else
        {
          v33 = Particle_GetRandomSeedArrayNextFreeElem(v9)[v29];
        }
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 215, ASSERT_TYPE_ASSERT, "(pLinkedAssetList)", (const char *)&queryFormat, "pLinkedAssetList") )
          __debugbreak();
        if ( !*(_QWORD *)v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 216, ASSERT_TYPE_ASSERT, "(pLinkedAssetList->assetList)", (const char *)&queryFormat, "pLinkedAssetList->assetList") )
          __debugbreak();
        if ( *(int *)(v13 + 8) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleutil.h", 217, ASSERT_TYPE_ASSERT, "(pLinkedAssetList->numAssets > 0)", (const char *)&queryFormat, "pLinkedAssetList->numAssets > 0") )
          __debugbreak();
        v34 = Particle_RandomIndex(v33, FXRAND_VISUAL, *(_DWORD *)(v13 + 8));
        v35 = *(const XModel **)(32 * v34 + *(_QWORD *)v13);
        if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2143, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
          __debugbreak();
        v36 = (int *)(*(_QWORD *)&pModuleBase[9] + 16 * v34);
        if ( !v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2146, ASSERT_TYPE_ASSERT, "(pMeshData)", (const char *)&queryFormat, "pMeshData") )
          __debugbreak();
        v37 = XModelGetSurfaces(v35, &v121, 0);
        v38 = v37;
        if ( m_flags )
          goto LABEL_94;
        v39 = *v36;
        if ( !*v36 || !v37 )
          break;
        v40 = 0;
        if ( v39 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 74, ASSERT_TYPE_ASSERT, "(count > 0)", (const char *)&queryFormat, "count > 0") )
          __debugbreak();
        v41 = abs32((v39 * LOWORD(fx_randomTable[v33 + 6])) >> 16);
        if ( v41 >= v39 )
        {
          LODWORD(v114) = v39;
          LODWORD(v113) = v41;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v113, v114) )
            __debugbreak();
        }
        v42 = 0;
        if ( v38 )
        {
          v43 = v121;
          while ( 1 )
          {
            v44 = v40 + v43->vertCount;
            if ( v44 > v41 )
              break;
            ++v42;
            ++v43;
            v40 = v44;
            if ( v42 >= v38 )
              goto LABEL_80;
          }
          v48 = v41 - v40;
          if ( v43->sharedVertDataOffset >= v43->shared->dataSize )
          {
            LODWORD(v114) = v43->shared->dataSize;
            LODWORD(v113) = v43->sharedVertDataOffset;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 33, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedVertDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedVertDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v113, v114) )
              __debugbreak();
          }
          shared = v43->shared;
          if ( (shared->flags & 1) != 0 )
            data = Stream_AddressSpace_ResolveHandle(&v43->shared->data.streamedDataHandle);
          else
            data = (unsigned __int8 *)shared->data.streamedDataHandle.data;
          XSurfaceUnpackPosition(*(const PackedPosition *)&data[20 * v48 + v43->sharedVertDataOffset], &v43->surfBounds, &result);
          __asm { vmovss  xmm0, dword ptr [rbp+70h+result] }
          _R15 = PositionArrayNextFreeElem;
          HIDWORD(surfaces[1]) = 0;
          __asm
          {
            vmovups xmm3, xmmword ptr [rbp+70h+surfaces]
            vmovss  xmm3, xmm3, xmm0
            vinsertps xmm3, xmm3, dword ptr [rbp+70h+result+4], 70h+var_60
            vinsertps xmm3, xmm3, dword ptr [rbp+70h+result+8], 70h+var_50
            vmovups xmmword ptr [rbp+70h+surfaces], xmm3
            vmovups xmmword ptr [r15], xmm3
          }
LABEL_88:
          v11 = (ParticleModule *)pModuleBase;
          goto LABEL_89;
        }
LABEL_80:
        _R15 = PositionArrayNextFreeElem;
        v10 = (ParticleState *)pParticleState;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovups xmmword ptr [r15], xmm0
        }
        v46 = ParticleState::GetVFXName((ParticleState *)pParticleState);
        XModelSurfsName = XModelGetXModelSurfsName(v35, 0);
        Com_PrintWarning(21, "Could not find vertex index %d on model %s (lod model info %s) in effect %s. This may be due to transients loading the default FX model.\n", v41, v35->name, XModelSurfsName, v46);
        v11 = (ParticleModule *)pModuleBase;
LABEL_90:
        __asm { vmovups xmm0, xmmword ptr [r15] }
        _RAX = SpawnPosArrayNextFreeElem;
        v13 = (__int64)v124;
        v29 = v120 + 1;
        v9 = v125;
        __asm
        {
          vaddps  xmm1, xmm7, xmm0
          vmovups xmmword ptr [r15], xmm1
          vmovups xmmword ptr [rax+r15], xmm1
        }
        ++_R15;
        v120 = v29;
        PositionArrayNextFreeElem = _R15;
        if ( v29 >= particleCountEmit )
        {
          __asm
          {
            vmovaps xmm8, [rsp+170h+var_60]
            vmovaps xmm7, [rsp+170h+var_50]
            vmovaps xmm6, [rsp+170h+var_40]
          }
          return;
        }
      }
      _R15 = PositionArrayNextFreeElem;
LABEL_94:
      v61 = v36[1];
      if ( !v61 || !v37 )
      {
        if ( !v35->name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2245, ASSERT_TYPE_ASSERT, "(pModel->name)", (const char *)&queryFormat, "pModel->name") )
          __debugbreak();
        if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2246, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
          __debugbreak();
        if ( !ParticleState::GetVFXName(v10) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2247, ASSERT_TYPE_ASSERT, "(pParticleState->GetVFXName())", (const char *)&queryFormat, "pParticleState->GetVFXName()") )
          __debugbreak();
        v111 = ParticleState::GetVFXName(v10);
        R_WarnOncePerFrame(R_WARN_FX_INVALID_SHAPE_MESH, v35->name, v111);
        v11 = (ParticleModule *)pModuleBase;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovups xmmword ptr [r15], xmm0
        }
        goto LABEL_90;
      }
      v62 = 0;
      if ( v61 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 74, ASSERT_TYPE_ASSERT, "(count > 0)", (const char *)&queryFormat, "count > 0") )
        __debugbreak();
      v63 = abs32((v61 * LOWORD(fx_randomTable[v33 + 22])) >> 16);
      if ( v63 >= v61 )
      {
        LODWORD(v114) = v61;
        LODWORD(v113) = v63;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlerandom.h", 78, ASSERT_TYPE_ASSERT, "(unsigned)( randomIndex ) < (unsigned)( count )", "randomIndex doesn't index count\n\t%i not in [0, %i)", v113, v114) )
          __debugbreak();
      }
      v64 = 0;
      v65 = v121;
      while ( 1 )
      {
        v66 = v62 + v65->triCount;
        if ( v66 > v63 )
          break;
        ++v64;
        ++v65;
        v62 = v66;
        if ( v64 >= v38 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vmovups xmmword ptr [r15], xmm0
          }
          v68 = ParticleState::GetVFXName((ParticleState *)pParticleState);
          v69 = XModelGetXModelSurfsName(v35, 0);
          Com_PrintWarning(21, "Could not find tri index %d on model %s (lod model info %s) in effect %s. This may be due to transients loading the default FX model", v63, v35->name, v69, v68);
          goto LABEL_88;
        }
      }
      v70 = v63 - v62;
      if ( v65->sharedVertDataOffset >= v65->shared->dataSize )
      {
        LODWORD(v114) = v65->shared->dataSize;
        LODWORD(v113) = v65->sharedVertDataOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 33, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedVertDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedVertDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v113, v114) )
          __debugbreak();
      }
      v71 = v65->shared;
      if ( (v71->flags & 1) != 0 )
      {
        v72 = Stream_AddressSpace_ResolveHandle(&v65->shared->data.streamedDataHandle);
        v71 = v65->shared;
      }
      else
      {
        v72 = (unsigned __int8 *)v71->data.streamedDataHandle.data;
      }
      v73 = &v72[v65->sharedVertDataOffset];
      if ( v65->sharedIndexDataOffset >= v71->dataSize )
      {
        LODWORD(v114) = v71->dataSize;
        LODWORD(v113) = v65->sharedIndexDataOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 46, ASSERT_TYPE_ASSERT, "(unsigned)( surface->sharedIndexDataOffset ) < (unsigned)( surface->shared->dataSize )", "surface->sharedIndexDataOffset doesn't index surface->shared->dataSize\n\t%i not in [0, %i)", v113, v114) )
          __debugbreak();
      }
      v74 = v65->shared;
      if ( (v74->flags & 1) != 0 )
        v75 = Stream_AddressSpace_ResolveHandle(&v65->shared->data.streamedDataHandle);
      else
        v75 = (unsigned __int8 *)v74->data.streamedDataHandle.data;
      v76 = &v75[v65->sharedIndexDataOffset];
      if ( ((unsigned __int8)v76 & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_xsurface.h", 48, ASSERT_TYPE_ASSERT, "(IsAligned( indices, 16 ))", (const char *)&queryFormat, "IsAligned( indices, 16 )") )
        __debugbreak();
      p_surfBounds = &v65->surfBounds;
      v78 = 3 * v70;
      v79 = 5i64 * *(unsigned __int16 *)&v76[2 * v78 + 2];
      v80 = 5i64 * *(unsigned __int16 *)&v76[2 * v78 + 4];
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v73[20 * *(unsigned __int16 *)&v76[2 * v78]], p_surfBounds, &v130);
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v73[4 * v79], p_surfBounds, &v131);
      XSurfaceUnpackPositionToFloat4(*(const PackedPosition *)&v73[4 * v80], p_surfBounds, &v132);
      v11 = (ParticleModule *)pModuleBase;
      _RDX = fx_randomTable;
      _R15 = PositionArrayNextFreeElem;
      _RAX = v33;
      m_type = pModuleBase[1].m_type;
      __asm
      {
        vmovss  xmm2, dword ptr [rdx+rax*4+1Ch]
        vmovss  xmm4, dword ptr [rdx+rax*4+18h]
        vaddss  xmm3, xmm2, xmm4
        vcmpltss xmm0, xmm8, xmm3
        vsubss  xmm1, xmm8, xmm2
        vblendvps xmm6, xmm2, xmm1, xmm0
        vsubss  xmm1, xmm8, xmm4
        vcmpltss xmm0, xmm8, xmm3
        vblendvps xmm5, xmm4, xmm1, xmm0
        vmovaps xmm0, xmm5
        vshufps xmm0, xmm0, xmm0, 0
        vmulps  xmm1, xmm0, xmmword ptr [rbp+70h+var_A0.v]
        vmovaps xmm0, xmm6
        vshufps xmm0, xmm0, xmm0, 0
        vmulps  xmm0, xmm0, xmmword ptr [rbp+70h+var_90.v]
        vaddps  xmm2, xmm0, xmm1
        vsubss  xmm0, xmm8, xmm5
        vsubss  xmm1, xmm0, xmm6
        vshufps xmm1, xmm1, xmm1, 0
        vmulps  xmm1, xmm1, xmmword ptr [rbp+70h+var_80.v]
        vaddps  xmm0, xmm1, xmm2
        vmovss  dword ptr [rsp+170h+var_100], xmm5
        vmovups xmmword ptr [r15], xmm0
        vmovss  dword ptr [rsp+170h+var_100], xmm6
      }
      if ( m_type != PARTICLE_MODULE_AXES_FLAG_ALL )
      {
        __asm
        {
          vmovss  dword ptr [rbp+70h+outPos], xmm0
          vextractps dword ptr [rbp+70h+outPos+4], xmm0, 1
          vextractps dword ptr [rbp+70h+outPos+8], xmm0, 2
        }
        Particle_SpawnShapeConvertPos(m_type, &outPos);
        __asm { vmovss  xmm0, dword ptr [rbp+70h+outPos] }
        outOffset.v.m128_i32[3] = 0;
        __asm
        {
          vmovups xmm3, xmmword ptr [rbp+70h+outOffset.v]
          vmovss  xmm3, xmm3, xmm0
          vinsertps xmm3, xmm3, dword ptr [rbp+70h+outPos+4], 70h+var_60
          vinsertps xmm3, xmm3, dword ptr [rbp+70h+outPos+8], 70h+var_50
          vmovups xmmword ptr [rbp+70h+outOffset.v], xmm3
          vmovups xmmword ptr [r15], xmm3
        }
      }
LABEL_89:
      v10 = (ParticleState *)pParticleState;
      goto LABEL_90;
    }
  }
}

/*
==============
ParticleModuleInitSpawnShapeSphere::InitParticles
==============
*/
void ParticleModuleInitSpawnShapeSphere::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera, const unsigned int particleCountEmit)
{
  char v12; 
  float4 *PositionArrayNextFreeElem; 
  ParticleEmitter *EmitterOwner; 
  unsigned int v27; 
  ParticleEmitter *m_pEmitterOwner; 
  int v31; 
  ParticleEmitter *v39; 
  int v40; 
  float4 *SpawnPosArrayNextFreeElem; 
  signed __int64 v52; 
  signed __int64 v53; 
  float radiusMax; 
  float radiusMin; 
  float4 outOffset; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 2295, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v12 = HIBYTE(pModuleBase[1].m_type) & 1;
  __asm { vmovaps [rsp+0D8h+var_58], xmm7 }
  PositionArrayNextFreeElem = Particle_GetPositionArrayNextFreeElem(pParticleData);
  SpawnPosArrayNextFreeElem = Particle_GetSpawnPosArrayNextFreeElem(pParticleData);
  ParticleModuleInitSpawnShape::GetOffsetForShape((ParticleModuleInitSpawnShape *)pModuleBase, pParticleState, &outOffset);
  ParticleModuleInitSpawnShapeSphere::GetDimensions((ParticleModuleInitSpawnShapeSphere *)pModuleBase, pParticleState, &radiusMin, &radiusMax);
  if ( (pModuleBase->m_flags & 0x80) != 0 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
    ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsp+0D8h+outOffset.v]
      vshufps xmm2, xmm0, xmm0, 0
      vshufps xmm4, xmm0, xmm0, 55h ; 'U'
      vshufps xmm5, xmm0, xmm0, 0AAh ; 'ª'
      vmulps  xmm0, xmm2, xmmword ptr [rax]
      vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm4, xmmword ptr [rax+10h]
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm5, xmmword ptr [rax+20h]
      vaddps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm2, xmm1
      vandps  xmm7, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
    }
  }
  else
  {
    __asm { vmovups xmm7, xmmword ptr [rsp+0D8h+outOffset.v] }
  }
  v27 = 0;
  __asm { vmovaps [rsp+0D8h+var_48], xmm6 }
  if ( v12 )
  {
    if ( particleCountEmit )
    {
      v52 = (char *)SpawnPosArrayNextFreeElem - (char *)PositionArrayNextFreeElem;
      __asm { vmovss  xmm6, [rsp+0D8h+radiusMax] }
      _R14 = PositionArrayNextFreeElem;
      do
      {
        if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
        {
          if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
            __debugbreak();
          m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
          v31 = (ParticleEmitter::GetEmitterDef(m_pEmitterOwner)->randomSeed + m_pEmitterOwner->m_lifetimeParticleCount + 10111 * (unsigned __int8)v27) % 0x3FE9;
        }
        else
        {
          v31 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v27];
        }
        __asm { vmovaps xmm2, xmm6; radius }
        Particle_RandomPointOnSphere(v31, &PositionArrayNextFreeElem[v27], *(const float *)&_XMM2, pModuleBase[1].m_type);
        __asm { vaddps  xmm1, xmm7, xmmword ptr [r14] }
        _RAX = v52;
        ++v27;
        __asm
        {
          vmovups xmmword ptr [r14], xmm1
          vmovups xmmword ptr [rax+r14], xmm1
        }
        ++_R14;
      }
      while ( v27 < particleCountEmit );
    }
  }
  else if ( particleCountEmit )
  {
    v53 = (char *)SpawnPosArrayNextFreeElem - (char *)PositionArrayNextFreeElem;
    __asm
    {
      vmovss  xmm6, [rsp+0D8h+radiusMax]
      vmovaps [rsp+0D8h+var_68], xmm8
    }
    _R14 = PositionArrayNextFreeElem;
    __asm
    {
      vmovss  xmm8, [rsp+0D8h+radiusMin]
      vmovaps [rsp+0D8h+var_78], xmm9
      vmovss  xmm9, cs:__real@3f800000
    }
    do
    {
      if ( (HIBYTE(pModuleBase[1].m_type) & 8) != 0 )
      {
        if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
          __debugbreak();
        v39 = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
        v40 = (ParticleEmitter::GetEmitterDef(v39)->randomSeed + v39->m_lifetimeParticleCount + 10111 * (unsigned __int8)v27) % 0x3FE9;
      }
      else
      {
        v40 = Particle_GetRandomSeedArrayNextFreeElem(pParticleData)[v27];
      }
      __asm
      {
        vsubss  xmm0, xmm9, dword ptr [rdx+rax*4]
        vmulss  xmm1, xmm6, dword ptr [rdx+rax*4]
        vmulss  xmm2, xmm0, xmm8
        vaddss  xmm2, xmm2, xmm1; radius
      }
      Particle_RandomPointOnSphere(v40, &PositionArrayNextFreeElem[v27], *(const float *)&_XMM2, pModuleBase[1].m_type);
      __asm { vaddps  xmm1, xmm7, xmmword ptr [r14] }
      _RAX = v53;
      ++v27;
      __asm
      {
        vmovups xmmword ptr [r14], xmm1
        vmovups xmmword ptr [r14+rax], xmm1
      }
      ++_R14;
    }
    while ( v27 < particleCountEmit );
    __asm
    {
      vmovaps xmm9, [rsp+0D8h+var_78]
      vmovaps xmm8, [rsp+0D8h+var_68]
    }
  }
  __asm
  {
    vmovaps xmm7, [rsp+0D8h+var_58]
    vmovaps xmm6, [rsp+0D8h+var_48]
  }
}

/*
==============
ParticleModuleInitTail::InitParticles
==============
*/
void ParticleModuleInitTail::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitVectorField::InitParticles
==============
*/
void ParticleModuleInitVectorField::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitVolumetric::InitParticles
==============
*/
void ParticleModuleInitVolumetric::InitParticles(const ParticleModule *pModuleBase, const ParticleState *pParticleState, ParticleData *pParticleData, const FxCamera *pCamera)
{
  ;
}

/*
==============
ParticleModuleInitModel::InitPhysicsParticles
==============
*/
void ParticleModuleInitModel::InitPhysicsParticles(ParticleModuleInitModel *this, ParticleData *pParticleData, const unsigned int particleCountEmit, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, FxPhysics *physicsInstanceIDList)
{
  __int64 m_particleCountRunning; 
  __int64 v22; 
  unsigned __int8 *ParticleDataArray; 
  __int64 v24; 
  ParticleEmitter *v25; 
  __int64 m_localClientNum; 
  unsigned __int64 flags; 
  void (__fastcall *v28)(Physics_SimpleCollisionCallback_Data *); 
  const ParticleSystem *SystemOwner; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  unsigned int m_velocityType; 
  unsigned int *p_createListIndex; 
  ParticleLinkedAssetListDef *p_m_linkedAssetList; 
  signed __int64 v35; 
  _DWORD *v37; 
  unsigned __int8 *v38; 
  int *v39; 
  Material *material; 
  ParticleSystem *v41; 
  const ParticleSystemDef *v42; 
  unsigned __int32 v43; 
  char v45; 
  ParticleSystem *v46; 
  const ParticleSystemDef *Def; 
  const ParticleState *v48; 
  const ParticleModuleInitRelativeVelocity *v49; 
  const ParticleStateDef *m_pStateDef; 
  float4 *v61; 
  bool v64; 
  const ParticleSystem *m_pSystemOwner; 
  int v120; 
  __int64 v121; 
  volatile signed __int32 *v122; 
  __int64 v124; 
  __int64 v136; 
  __int64 v137; 
  double v138; 
  double v139; 
  double v140; 
  double v141; 
  char v142; 
  unsigned int v143; 
  unsigned int v144; 
  Physics_WorldId worldId; 
  unsigned int v147; 
  float4 *RotationAngleArrayAtIndex; 
  signed __int64 v149; 
  float4 *VelocityArrayAtIndex; 
  signed __int64 v151; 
  float4 *RotationRateArrayAtIndex; 
  signed __int64 v153; 
  unsigned __int8 *v154; 
  signed __int64 v155; 
  unsigned __int8 *v156; 
  unsigned __int8 *v157; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v159; 
  int outAssetIndex; 
  vector3 *rotMatrix; 
  __int64 v162; 
  ParticleEmitter *v163; 
  __int128 v164; 
  __int64 v165; 
  __int64 v166; 
  void (__fastcall *v167)(Physics_SimpleCollisionCallback_Data *); 
  ParticleLinkedAssetListDef *v168; 
  vec4_t quat; 

  v163 = (ParticleEmitter *)pEmitterOwner;
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 974, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 975, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 976, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 977, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 978, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( !this->m_usePhysics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 979, ASSERT_TYPE_ASSERT, "(m_usePhysics)", (const char *)&queryFormat, "m_usePhysics") )
    __debugbreak();
  if ( !physicsInstanceIDList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 980, ASSERT_TYPE_ASSERT, "(physicsInstanceIDList)", (const char *)&queryFormat, "physicsInstanceIDList") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  _R13 = Particle_GetPositionArrayAtIndex(pParticleData, pParticleData->m_particleCountRunning);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, m_particleCountRunning);
  Particle_GetSizeArrayAtIndex(pParticleData, m_particleCountRunning);
  RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, m_particleCountRunning);
  RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, m_particleCountRunning);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, m_particleCountRunning);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v136) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v136, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v154 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_SPAWN_QUAT)[16 * m_particleCountRunning];
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v137) = pParticleData->m_particleCountMax;
    LODWORD(v136) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v136, v137) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 356, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v22 = 4 * m_particleCountRunning;
  v156 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_HANDLE)[4 * m_particleCountRunning];
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)m_particleCountRunning >= pParticleData->m_particleCountMax )
  {
    LODWORD(v137) = pParticleData->m_particleCountMax;
    LODWORD(v136) = m_particleCountRunning;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v136, v137) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 354, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  ParticleDataArray = ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_FLAGS);
  v24 = m_particleCountRunning;
  v25 = v163;
  v162 = (__int64)&ParticleDataArray[v22];
  m_localClientNum = v163->m_pSystemOwner->m_localClientNum;
  v147 = m_localClientNum;
  worldId = 3 * m_localClientNum + 3;
  flags = pParticleState->m_pStateDef->flags;
  v28 = NULL;
  if ( (flags & 0x10000) != 0 )
    v28 = ParticleState::OnImpactCB;
  v167 = v28;
  v165 = (unsigned __int8)flags & 0xA0;
  rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform(v163, pParticleState);
  SystemOwner = ParticleEmitter::GetSystemOwner(v163);
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  v142 = SystemOwner->m_flags & 1;
  if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
    m_velocityType = 0;
  else
    m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
  v144 = m_velocityType;
  Particle_RotMatrixToQuatVec(rotMatrix, &quat);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbp+100h+quat]
    vmovdqa [rbp+100h+var_110], xmm0
  }
  v143 = 0;
  if ( particleCountEmit )
  {
    p_createListIndex = &physicsInstanceIDList[v24].createListIndex;
    p_m_linkedAssetList = &this->m_linkedAssetList;
    v35 = (char *)RandomSeedArrayAtIndex - (char *)v156;
    _RBX = v154 - (unsigned __int8 *)_R13;
    v149 = (char *)RotationAngleArrayAtIndex - (char *)_R13;
    v37 = (_DWORD *)v162;
    v151 = (char *)VelocityArrayAtIndex - (char *)_R13;
    v153 = (char *)RotationRateArrayAtIndex - (char *)_R13;
    __asm { vmovaps [rsp+200h+var_40], xmm6 }
    v38 = &v156[-v162];
    __asm
    {
      vmovaps [rsp+200h+var_50], xmm7
      vmovaps [rsp+200h+var_60], xmm8
      vmovaps [rsp+200h+var_70], xmm9
      vmovaps [rsp+200h+var_80], xmm10
      vmovaps [rsp+200h+var_90], xmm11
      vmovaps [rsp+200h+var_A0], xmm12
      vmovaps [rsp+200h+var_B0], xmm13
      vmovaps [rsp+200h+var_C0], xmm14
      vmovaps [rsp+200h+var_D0], xmm15
    }
    v166 = m_localClientNum;
    v168 = &this->m_linkedAssetList;
    v159 = (char *)RandomSeedArrayAtIndex - (char *)v156;
    v155 = v154 - (unsigned __int8 *)_R13;
    v157 = &v156[-v162];
    while ( 1 )
    {
      v39 = (_DWORD *)((char *)v37 + (_QWORD)v38);
      material = Particle_GetRandomAssetWithIndex(p_m_linkedAssetList, *(_DWORD *)((char *)v37 + (_QWORD)v38 + v35), FXRAND_VISUAL, &outAssetIndex)->material;
      if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1038, ASSERT_TYPE_ASSERT, "(pModel)", (const char *)&queryFormat, "pModel") )
        __debugbreak();
      if ( *(_QWORD *)&material[5].cameraRegion )
      {
        *(double *)&_XMM0 = Physics_GetFixedMemoryPoolUsage(worldId);
        _RAX = particle_physics_memory_threshold;
        __asm { vcomiss xmm0, dword ptr [rax+28h] }
        if ( v64 | v45 )
        {
          v48 = pParticleState;
          v49 = pParticleState->m_pModuleInitRelativeVelocity;
          if ( !v49 || (v49->m_flags & 1) != 0 || ((v49->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
          {
            __asm { vmovups xmm15, xmmword ptr [r13+0] }
          }
          else
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [r13+0]
              vshufps xmm2, xmm0, xmm0, 0AAh ; 'ª'
              vshufps xmm3, xmm0, xmm0, 55h ; 'U'
              vshufps xmm4, xmm0, xmm0, 0
              vmulps  xmm0, xmm2, xmmword ptr [rax+20h]
              vaddps  xmm2, xmm0, xmmword ptr [rax+30h]
              vmulps  xmm0, xmm3, xmmword ptr [rax+10h]
              vaddps  xmm1, xmm0, xmm2
              vmulps  xmm0, xmm4, xmmword ptr [rax]
              vaddps  xmm15, xmm0, xmm1
            }
          }
          m_pStateDef = pParticleState->m_pStateDef;
          v61 = (float4 *)((unsigned __int64)LODWORD(m_pStateDef->flags) >> 28);
          if ( (m_pStateDef->flags & 0x10000000) != 0 )
          {
            ParticleEmitter::GetSystemOwner(v25);
            __asm { vaddps  xmm15, xmm15, xmmword ptr [rax+30h] }
          }
          if ( v165 )
          {
            _RAX = v149;
            __asm { vmovups xmm0, xmmword ptr [rax+r13] }
            Float4RadianToQuat(v61, &v48->m_moduleGraphLengthData.color);
            __asm
            {
              vmovss  xmm10, dword ptr [rbp+100h+quat]
              vmovss  xmm8, dword ptr [rbp+100h+quat+0Ch]
              vmovss  xmm6, dword ptr [rbp+100h+quat+4]
              vmovss  xmm5, dword ptr [rbp+100h+quat+8]
              vmovups xmm11, xmm0
              vshufps xmm9, xmm0, xmm0, 0FFh
              vshufps xmm7, xmm0, xmm0, 0AAh ; 'ª'
              vmovups [rbp+100h+var_F0], xmm0
              vshufps xmm4, xmm11, xmm11, 55h ; 'U'
              vmulss  xmm2, xmm10, xmm9
              vmulss  xmm1, xmm8, xmm11
              vaddss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm6, xmm7
              vaddss  xmm1, xmm3, xmm0
              vmulss  xmm0, xmm5, xmm4
              vsubss  xmm12, xmm1, xmm0
              vmulss  xmm1, xmm4, xmm8
              vmulss  xmm0, xmm7, xmm10
              vsubss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm6, xmm9
              vaddss  xmm3, xmm2, xmm1
              vmulss  xmm1, xmm4, xmm10
              vmulss  xmm0, xmm5, xmm11
              vaddss  xmm13, xmm3, xmm0
              vmulss  xmm0, xmm7, xmm8
              vaddss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm6, xmm11
              vsubss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm5, xmm9
              vaddss  xmm14, xmm3, xmm0
              vmulss  xmm0, xmm10, xmm11
              vmulss  xmm1, xmm9, xmm8
              vsubss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm4, xmm6
              vsubss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm5, xmm7
              vsubss  xmm4, xmm3, xmm0
              vmovss  dword ptr [rbp+100h+var_110+0Ch], xmm4
              vmovss  dword ptr [rbp+100h+var_110], xmm12
              vmovss  dword ptr [rbp+100h+var_110+4], xmm13
              vmovss  dword ptr [rbp+100h+var_110+8], xmm14
            }
          }
          else
          {
            v64 = v144 < 2;
            if ( v144 == 2 || (v64 = v144 < 5, v144 == 5) || (v64 = 0, v142) && (v64 = v144 < 3, v144 != 3) )
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rbx+r13]
                vmovups [rbp+100h+var_110], xmm0
                vshufps xmm4, xmm0, xmm0, 0FFh
              }
            }
            else
            {
              __asm { vmovss  xmm4, dword ptr [rbp+100h+var_110+0Ch] }
            }
            __asm
            {
              vmovss  xmm14, dword ptr [rbp+100h+var_110+8]
              vmovss  xmm13, dword ptr [rbp+100h+var_110+4]
              vmovss  xmm12, dword ptr [rbp+100h+var_110]
            }
          }
          __asm
          {
            vmulss  xmm1, xmm12, xmm12
            vmulss  xmm0, xmm13, xmm13
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm14, xmm14
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm4, xmm4
            vaddss  xmm2, xmm3, xmm0
            vsubss  xmm1, xmm2, cs:__real@3f800000
            vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
            vcomiss xmm1, cs:__real@3b83126f
          }
          if ( !v64 )
          {
            __asm
            {
              vcvtss2sd xmm0, xmm4, xmm4
              vmovsd  [rsp+200h+var_1B8], xmm0
              vcvtss2sd xmm1, xmm14, xmm14
              vmovsd  [rsp+200h+var_1C0], xmm1
              vcvtss2sd xmm2, xmm13, xmm13
              vmovsd  [rsp+200h+var_1C8], xmm2
              vcvtss2sd xmm3, xmm12, xmm12
              vmovsd  [rsp+200h+var_1D0], xmm3
            }
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 698, ASSERT_TYPE_ASSERT, "(Particle_Vec4IsNormalized( outQuat ))", "%s\n\t%g %g %g %g", "Particle_Vec4IsNormalized( outQuat )", v138, v139, v140, v141) )
              __debugbreak();
          }
          _RAX = v151;
          __asm { vmovups xmm6, xmmword ptr [rax+r13] }
          _RAX = v153;
          __asm { vmovups xmm7, xmmword ptr [rax+r13] }
          if ( !v25->m_pSystemOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particleemitter.h", 204, ASSERT_TYPE_ASSERT, "(m_pSystemOwner)", (const char *)&queryFormat, "m_pSystemOwner") )
            __debugbreak();
          m_pSystemOwner = v25->m_pSystemOwner;
          if ( m_pSystemOwner->m_systemHandle == PARTICLE_SYSTEM_INVALID_HANDLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlesystem.h", 196, ASSERT_TYPE_ASSERT, "(m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE)", (const char *)&queryFormat, "m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE") )
            __debugbreak();
          LODWORD(v164) = m_pSystemOwner->m_systemHandle;
          DWORD1(v164) = v25->m_emitterIndex;
          DWORD2(v164) = pParticleState->m_stateIndex;
          v120 = *v39;
          *v37 |= 2u;
          HIDWORD(v164) = v120;
          if ( v147 >= 2 )
          {
            LODWORD(v137) = 2;
            LODWORD(v136) = v147;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 419, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v136, v137) )
              __debugbreak();
          }
          v121 = v166;
          v122 = &g_particleDeferredPhysicsCreateListCount[v166];
          if ( ((unsigned __int8)v122 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&g_particleDeferredPhysicsCreateListCount[v166]) )
            __debugbreak();
          v43 = _InterlockedExchangeAdd(v122, 1u);
          if ( v43 >= 0x800 )
          {
            LODWORD(v137) = 2048;
            LODWORD(v136) = v43;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 422, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( PARTICLE_DEFERRED_PHYSICS_LIST_MAX )", "index doesn't index PARTICLE_DEFERRED_PHYSICS_LIST_MAX\n\t%i not in [0, %i)", v136, v137) )
              __debugbreak();
          }
          __asm { vmovaps xmm0, [rbp+100h+var_110] }
          v25 = v163;
          v124 = v162;
          _RDX = &g_particleDeferredPhysicsCreateList[v121][v43];
          _RDX->pModel = (const XModel *)material;
          _RDX->physicsRefId = 0;
          __asm
          {
            vmovss  dword ptr [rdx+10h], xmm15
            vextractps dword ptr [rdx+14h], xmm15, 1
            vextractps dword ptr [rdx+18h], xmm15, 2
            vmovss  dword ptr [rdx+1Ch], xmm6
            vextractps dword ptr [rdx+20h], xmm6, 1
            vextractps dword ptr [rdx+24h], xmm6, 2
            vmovss  dword ptr [rdx+28h], xmm7
            vextractps dword ptr [rdx+2Ch], xmm7, 1
            vextractps dword ptr [rdx+30h], xmm7, 2
            vmovups xmmword ptr [rdx], xmm0
            vmovups xmm0, [rbp+100h+var_140]
          }
          _RDX->physicsInstanceID = (FxPhysics *)(p_createListIndex - 2);
          *(p_createListIndex - 2) = -1;
          _RDX->physicsInstanceID->detailInstanceId = -1;
          __asm { vmovups xmmword ptr [rdx+50h], xmm0 }
          _RDX->state = PARTICLE_DEFERRED_PHYSICS_PENDING_CREATION;
          _RDX->onImpactCB = v167;
          _RDX->flags = (unsigned int *)(v124 + 4i64 * v143);
          goto LABEL_100;
        }
        v46 = (ParticleSystem *)ParticleEmitter::GetSystemOwner(v25);
        Def = ParticleSystem::GetDef(v46);
        Com_PrintWarning(21, "FX Model %s used by Particle FX %s won't create physics asset because we are close to memory limits\n", material->name, Def->name);
      }
      else
      {
        v41 = (ParticleSystem *)ParticleEmitter::GetSystemOwner(v25);
        v42 = ParticleSystem::GetDef(v41);
        Com_PrintWarning(21, "FX Model %s used by Particle FX %s has no physics asset\n", material->name, v42->name);
      }
      *((_QWORD *)p_createListIndex - 1) = -1i64;
      v43 = -1;
LABEL_100:
      ++_R13;
      v35 = v159;
      p_m_linkedAssetList = v168;
      ++v37;
      *p_createListIndex = v43;
      p_createListIndex += 3;
      v64 = v143 + 1 < particleCountEmit;
      _RBX = v155;
      ++v143;
      v38 = v157;
      if ( !v64 )
      {
        __asm
        {
          vmovaps xmm15, [rsp+200h+var_D0]
          vmovaps xmm14, [rsp+200h+var_C0]
          vmovaps xmm13, [rsp+200h+var_B0]
          vmovaps xmm12, [rsp+200h+var_A0]
          vmovaps xmm11, [rsp+200h+var_90]
          vmovaps xmm10, [rsp+200h+var_80]
          vmovaps xmm9, [rsp+200h+var_70]
          vmovaps xmm8, [rsp+200h+var_60]
          vmovaps xmm7, [rsp+200h+var_50]
          vmovaps xmm6, [rsp+200h+var_40]
        }
        return;
      }
    }
  }
}

/*
==============
Particle_GetShapeOffsetAndAngles
==============
*/
void Particle_GetShapeOffsetAndAngles(const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState, const float4 *offset, float4 *outShapeOrigin, vec3_t *outAngles, bool useWorldSpace)
{
  tmat33_t<vec3_t> axis; 

  _R14 = outShapeOrigin;
  _RBP = offset;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 188, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 189, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  _RAX = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( useWorldSpace )
  {
    __asm
    {
      vmovups xmm1, xmmword ptr [rax+30h]
      vaddps  xmm0, xmm1, xmmword ptr [rbp+0]
      vmovups xmmword ptr [r14], xmm0
    }
    *(_QWORD *)outAngles->v = 0i64;
    outAngles->v[2] = 0.0;
  }
  else
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+0]
      vshufps xmm2, xmm0, xmm0, 0AAh ; 'ª'
      vshufps xmm3, xmm0, xmm0, 55h ; 'U'
      vshufps xmm4, xmm0, xmm0, 0
      vmulps  xmm0, xmm2, xmmword ptr [rax+20h]
      vaddps  xmm2, xmm0, xmmword ptr [rax+30h]
      vmulps  xmm0, xmm3, xmmword ptr [rax+10h]
      vaddps  xmm1, xmm0, xmm2
      vmulps  xmm0, xmm4, xmmword ptr [rax]
      vaddps  xmm1, xmm0, xmm1
      vmovups xmmword ptr [r14], xmm1
      vmovups xmm2, xmmword ptr [rax]
      vmovss  dword ptr [rsp+88h+axis], xmm2
      vextractps dword ptr [rsp+88h+axis+4], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+8], xmm2, 2
      vmovups xmm2, xmmword ptr [rax+10h]
      vmovss  dword ptr [rsp+88h+axis+0Ch], xmm2
      vextractps dword ptr [rsp+88h+axis+10h], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+14h], xmm2, 2
      vmovups xmm2, xmmword ptr [rax+20h]
      vmovss  dword ptr [rsp+88h+axis+18h], xmm2
      vextractps dword ptr [rsp+88h+axis+1Ch], xmm2, 1
      vextractps dword ptr [rsp+88h+axis+20h], xmm2, 2
    }
    AxisToAngles(&axis, outAngles);
  }
}

/*
==============
Particle_RandomPointOnSphere
==============
*/

void __fastcall Particle_RandomPointOnSphere(int seed, float4 *outPos, double radius, ParticleModuleAxesFlags spawnAxes)
{
  char v26; 
  char v32; 
  __int64 v53; 
  double v54; 
  float c; 
  float s[3]; 
  __int128 v57; 
  char v58; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
  }
  _RDI = seed;
  _RBP = fx_randomTable;
  __asm { vmovaps xmm6, xmm2 }
  _RSI = outPos;
  __asm
  {
    vmulss  xmm0, xmm2, dword ptr [rbp+rdi*4+28h]
    vmulss  xmm1, xmm0, cs:__real@40000000
    vsubss  xmm7, xmm1, xmm2
    vxorps  xmm2, xmm2, cs:__xmm@80000000800000008000000080000000
    vcomiss xmm7, xmm2
    vcomiss xmm7, xmm6
  }
  if ( (unsigned __int64)&v53 != _security_cookie )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm7, xmm7
      vmovsd  [rsp+0C8h+var_A0], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 129, ASSERT_TYPE_ASSERT, "( ( height >= -radius && height <= radius ) )", "( height ) = %g", v54) )
      __debugbreak();
  }
  __asm
  {
    vmulss  xmm9, xmm6, xmm6
    vmulss  xmm10, xmm7, xmm7
    vsubss  xmm0, xmm9, xmm10
    vsqrtss xmm6, xmm0, xmm0
    vmovss  xmm0, dword ptr [rbp+rdi*4+24h]
    vmulss  xmm0, xmm0, cs:__real@40c90fdb; radians
  }
  FastSinCos(*(const float *)&_XMM0, s, &c);
  __asm
  {
    vmovss  xmm0, [rsp+0C8h+c]
    vmulss  xmm8, xmm0, xmm6
    vmovss  xmm0, [rsp+0C8h+s]
    vmulss  xmm6, xmm0, xmm6
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm9, xmm0
    vmovss  dword ptr [rsp+0C8h+var_88], xmm8
    vmovss  dword ptr [rsp+0C8h+var_88+4], xmm6
    vmovss  dword ptr [rsp+0C8h+var_88+8], xmm7
  }
  if ( !v32 )
  {
    __asm
    {
      vmulss  xmm0, xmm8, xmm8
      vmulss  xmm1, xmm6, xmm6
      vaddss  xmm1, xmm1, xmm0
      vaddss  xmm2, xmm1, xmm10
      vsubss  xmm3, xmm2, xmm9
      vandps  xmm3, xmm3, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vdivss  xmm0, xmm3, xmm9
      vcomiss xmm0, cs:__real@358637be
    }
    if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 140, ASSERT_TYPE_ASSERT, "(radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < 0.001f * 0.001f))", (const char *)&queryFormat, "radiusSquared == 0.0f || (I_fabs( lengthSquared - radiusSquared ) / radiusSquared < EQUAL_EPSILON * EQUAL_EPSILON)") )
      __debugbreak();
  }
  if ( spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL )
  {
    Particle_SpawnShapeConvertPos(spawnAxes, (vec3_t *)&v57);
    __asm
    {
      vmovss  xmm7, dword ptr [rsp+0C8h+var_88+8]
      vmovss  xmm6, dword ptr [rsp+0C8h+var_88+4]
      vmovss  xmm8, dword ptr [rsp+0C8h+var_88]
    }
  }
  HIDWORD(v57) = 0;
  __asm
  {
    vmovups xmm0, [rsp+0C8h+var_88]
    vmovss  xmm0, xmm0, xmm8
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm7, 20h ; ' '
    vmovups xmmword ptr [rsi], xmm0
  }
  _R11 = &v58;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
Particle_SpawnShapeConvertPos
==============
*/
void Particle_SpawnShapeConvertPos(ParticleModuleAxesFlags spawnAxes, vec3_t *outPos)
{
  _RBX = outPos;
  if ( spawnAxes == PARTICLE_MODULE_AXES_FLAG_ALL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 54, ASSERT_TYPE_ASSERT, "(spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL)", (const char *)&queryFormat, "spawnAxes != PARTICLE_MODULE_AXES_FLAG_ALL") )
    __debugbreak();
  __asm
  {
    vmovss  xmm2, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovss  xmm1, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
  }
  if ( (spawnAxes & 3) != 0 )
  {
    if ( (spawnAxes & 2) != 0 )
    {
      if ( (spawnAxes & 1) == 0 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbx]
          vandps  xmm0, xmm0, xmm1
          vxorps  xmm0, xmm0, xmm2
          vmovss  dword ptr [rbx], xmm0
        }
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx]
        vandps  xmm0, xmm0, xmm1
        vmovss  dword ptr [rbx], xmm0
      }
    }
  }
  else
  {
    _RBX->v[0] = 0.0;
  }
  if ( (spawnAxes & 0xC) != 0 )
  {
    if ( (spawnAxes & 8) != 0 )
    {
      if ( (spawnAxes & 4) == 0 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+4]
          vandps  xmm0, xmm0, xmm1
          vxorps  xmm0, xmm0, xmm2
          vmovss  dword ptr [rbx+4], xmm0
        }
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+4]
        vandps  xmm0, xmm0, xmm1
        vmovss  dword ptr [rbx+4], xmm0
      }
    }
  }
  else
  {
    _RBX->v[1] = 0.0;
  }
  if ( (spawnAxes & 0x30) != 0 )
  {
    if ( (spawnAxes & 0x20) != 0 )
    {
      if ( (spawnAxes & 0x10) == 0 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+8]
          vandps  xmm0, xmm0, xmm1
          vxorps  xmm0, xmm0, xmm2
          vmovss  dword ptr [rbx+8], xmm0
        }
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+8]
        vandps  xmm0, xmm0, xmm1
        vmovss  dword ptr [rbx+8], xmm0
      }
    }
  }
  else
  {
    _RBX->v[2] = 0.0;
  }
}

/*
==============
Particle_SpawnShapeDrawCylinder
==============
*/
void Particle_SpawnShapeDrawCylinder(const float4 *offset, const vector4 *axis, const vec4_t *color, const ParticleState *pParticleState, const ParticleModuleInitSpawnShapeCylinder *pModule)
{
  char v46; 
  char v47; 
  float radiusMax; 
  float radiusMin; 
  float halfHeight; 
  vec3_t angles; 
  vec3_t start; 
  vec3_t end; 
  tmat33_t<vec3_t> axisa; 
  char v68; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
  }
  _RBX = axis;
  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleinit.cpp", 1787, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  ParticleModuleInitSpawnShapeCylinder::GetDimensions((ParticleModuleInitSpawnShapeCylinder *)pModule, pParticleState, &halfHeight, &radiusMin, &radiusMax);
  __asm
  {
    vmovups xmm8, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
    vmovss  xmm9, [rbp+4Fh+halfHeight]
    vxorps  xmm0, xmm9, cs:__xmm@80000000800000008000000080000000
    vxorps  xmm2, xmm2, xmm2
    vinsertps xmm2, xmm2, xmm0, 20h ; ' '
    vshufps xmm1, xmm2, xmm2, 0
    vmulps  xmm0, xmm1, xmmword ptr [rbx]
    vshufps xmm4, xmm2, xmm2, 55h ; 'U'
    vaddps  xmm3, xmm0, xmm8
    vmulps  xmm0, xmm4, xmmword ptr [rbx+10h]
    vshufps xmm5, xmm2, xmm2, 0AAh ; 'ª'
    vaddps  xmm2, xmm0, xmm8
    vmulps  xmm0, xmm5, xmmword ptr [rbx+20h]
    vaddps  xmm1, xmm0, xmm3
    vaddps  xmm2, xmm2, xmm1
    vandps  xmm6, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
    vxorps  xmm7, xmm7, xmm7
    vinsertps xmm7, xmm7, xmm9, 20h ; ' '
    vshufps xmm1, xmm7, xmm7, 0
    vmulps  xmm0, xmm1, xmmword ptr [rbx]
    vaddps  xmm3, xmm0, xmm8
    vshufps xmm2, xmm7, xmm7, 55h ; 'U'
    vmulps  xmm0, xmm2, xmmword ptr [rbx+10h]
    vaddps  xmm2, xmm0, xmm8
    vshufps xmm4, xmm7, xmm7, 0AAh ; 'ª'
    vmulps  xmm0, xmm4, xmmword ptr [rbx+20h]
    vaddps  xmm1, xmm0, xmm3
    vaddps  xmm2, xmm2, xmm1
    vandps  xmm1, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
    vaddps  xmm2, xmm6, xmmword ptr [r14]
    vaddps  xmm3, xmm1, xmmword ptr [r14]
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm9, xmm6
    vmovss  dword ptr [rbp+4Fh+start], xmm2
    vextractps dword ptr [rbp+4Fh+start+4], xmm2, 1
    vextractps dword ptr [rbp+4Fh+start+8], xmm2, 2
    vmovss  dword ptr [rbp+4Fh+end], xmm3
    vextractps dword ptr [rbp+4Fh+end+4], xmm3, 1
    vextractps dword ptr [rbp+4Fh+end+8], xmm3, 2
  }
  if ( v46 | v47 )
  {
    __asm
    {
      vmovups xmm2, xmmword ptr [rbx+10h]
      vmovups xmm1, xmmword ptr [rbx]
      vmovss  dword ptr [rbp+4Fh+axis+0Ch], xmm2
      vextractps dword ptr [rbp+4Fh+axis+10h], xmm2, 1
      vextractps dword ptr [rbp+4Fh+axis+14h], xmm2, 2
      vmovups xmm2, xmmword ptr [rbx+20h]
      vmovss  dword ptr [rbp+4Fh+axis+18h], xmm2
      vextractps dword ptr [rbp+4Fh+axis+1Ch], xmm2, 1
      vextractps dword ptr [rbp+4Fh+axis+20h], xmm2, 2
      vmovss  dword ptr [rbp+4Fh+axis], xmm1
      vextractps dword ptr [rbp+4Fh+axis+4], xmm1, 1
      vextractps dword ptr [rbp+4Fh+axis+8], xmm1, 2
    }
    AxisToAngles(&axisa, &angles);
  }
  else
  {
    __asm
    {
      vmovss  dword ptr [rbp+4Fh+angles+8], xmm6
      vmovss  dword ptr [rbp+4Fh+angles+4], xmm6
      vmovss  dword ptr [rbp+4Fh+angles], xmm6
    }
  }
  if ( (pModule->m_spawnFlags & 1) == 0 )
  {
    __asm { vcomiss xmm9, xmm6 }
    if ( (pModule->m_spawnFlags & 1) != 0 )
    {
      __asm { vmovss  xmm2, [rbp+4Fh+radiusMin]; radius }
      Particle_DebugCylinder(&start, &end, *(float *)&_XMM2, &angles, color, 1, 0);
      __asm { vmovss  xmm2, [rsp+110h+radiusMax]; radius }
      Particle_DebugCylinder(&start, &end, *(float *)&_XMM2, &angles, color, 1, 0);
      goto LABEL_14;
    }
    __asm { vmovss  xmm1, [rbp+4Fh+radiusMin]; radius }
    Particle_DebugCircle(&start, *(float *)&_XMM1, &angles, color, 1, 0);
LABEL_13:
    __asm { vmovss  xmm1, [rsp+110h+radiusMax]; radius }
    Particle_DebugCircle(&start, *(float *)&_XMM1, &angles, color, 1, 0);
    goto LABEL_14;
  }
  __asm { vcomiss xmm9, xmm6 }
  if ( (pModule->m_spawnFlags & 1) == 0 )
    goto LABEL_13;
  __asm { vmovss  xmm2, [rsp+110h+radiusMax]; radius }
  Particle_DebugCylinder(&start, &end, *(float *)&_XMM2, &angles, color, 1, 0);
LABEL_14:
  _R11 = &v68;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

