/*
==============
ParticleModuleVectorFieldGraph::Init
==============
*/

void __fastcall ParticleModuleVectorFieldGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleVectorFieldGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph::Init
==============
*/

void __fastcall ParticleModuleRotationGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleRotationGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModulePositionGraph::Update
==============
*/

void __fastcall ParticleModulePositionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePositionGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissiveGraph::Init
==============
*/

void __fastcall ParticleModuleEmissiveGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleEmissiveGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVelocityGraph::Init
==============
*/

void __fastcall ParticleModuleVelocityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleVelocityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph::Update
==============
*/

void __fastcall ParticleModuleRotationGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleRotationGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleIntensityGraph::Update
==============
*/

void __fastcall ParticleModuleIntensityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleIntensityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeGraph::Init
==============
*/

void __fastcall ParticleModuleSizeGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleSizeGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleAttractor::Update
==============
*/

void __fastcall ParticleModuleAttractor::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleAttractor@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleTemperatureGraph::Update
==============
*/

void __fastcall ParticleModuleTemperatureGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleTemperatureGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeGraph::Update
==============
*/

void __fastcall ParticleModuleSizeGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleSizeGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleTemperatureGraph::Init
==============
*/

void __fastcall ParticleModuleTemperatureGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleTemperatureGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleIntensityGraph::Init
==============
*/

void __fastcall ParticleModuleIntensityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleIntensityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleEmissionGraph::GetSpawnRate
==============
*/

double __fastcall ParticleModuleEmissionGraph::GetSpawnRate(ParticleModuleEmissionGraph *this, float time, unsigned __int16 randomSeed)
{
  double result; 

  *(float *)&result = ?GetSpawnRate@ParticleModuleEmissionGraph@@QEBAMMG@Z(this, time, randomSeed);
  return result;
}

/*
==============
ParticleModuleColorGraph::Init
==============
*/

void __fastcall ParticleModuleColorGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleColorGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVelocityGraph::Update
==============
*/

void __fastcall ParticleModuleVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleVelocityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleForce::Update
==============
*/

void __fastcall ParticleModuleForce::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleForce@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleScaleByDistance::Update
==============
*/

void __fastcall ParticleModuleScaleByDistance::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleScaleByDistance@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeLerp::Update
==============
*/

void __fastcall ParticleModuleSizeLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleSizeLerp@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissionGraph::Init
==============
*/

void __fastcall ParticleModuleEmissionGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleEmissionGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleForceDragGraph::Update
==============
*/

void __fastcall ParticleModuleForceDragGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleForceDragGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsRayCast::Update
==============
*/

void __fastcall ParticleModulePhysicsRayCast::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePhysicsRayCast@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleParentVelocityGraph::Init
==============
*/

void __fastcall ParticleModuleParentVelocityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleParentVelocityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleShaderGraph::Init
==============
*/

void __fastcall ParticleModuleShaderGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleShaderGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleShaderGraph::Update
==============
*/

void __fastcall ParticleModuleShaderGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleShaderGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleParentVelocityGraph::Update
==============
*/

void __fastcall ParticleModuleParentVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleParentVelocityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePositionGraph::Init
==============
*/

void __fastcall ParticleModulePositionGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModulePositionGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleEmissiveGraph::Update
==============
*/

void __fastcall ParticleModuleEmissiveGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleEmissiveGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissionGraph::Update
==============
*/

void __fastcall ParticleModuleEmissionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleEmissionGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleForceDragGraph::Init
==============
*/

void __fastcall ParticleModuleForceDragGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleForceDragGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVectorFieldGraph::Update
==============
*/

void __fastcall ParticleModuleVectorFieldGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleVectorFieldGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleRotationGraph3D::Init
==============
*/

void __fastcall ParticleModuleRotationGraph3D::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleRotationGraph3D@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleGravity::Update
==============
*/

void __fastcall ParticleModuleGravity::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleGravity@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleScaleByDistance::Init
==============
*/

void __fastcall ParticleModuleScaleByDistance::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleScaleByDistance@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleGravity::Init
==============
*/

void __fastcall ParticleModuleGravity::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleGravity@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModulePhysicsLight::InitPhysicsParticles
==============
*/

void __fastcall ParticleModulePhysicsLight::InitPhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  ?InitPhysicsParticles@ParticleModulePhysicsLight@@QEBAXPEAUParticleData@@IPEAVParticleState@@@Z(this, pParticleData, particleCountEmit, pParticleState);
}

/*
==============
ParticleModuleColorGraph::Update
==============
*/

void __fastcall ParticleModuleColorGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleColorGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::CreatePhysicsParticles
==============
*/

void __fastcall ParticleModulePhysicsLight::CreatePhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleOffset, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  ?CreatePhysicsParticles@ParticleModulePhysicsLight@@QEBAXPEAUParticleData@@IIPEAVParticleState@@@Z(this, pParticleData, particleOffset, particleCountEmit, pParticleState);
}

/*
==============
ParticleModulePhysicsRayCast::Init
==============
*/

void __fastcall ParticleModulePhysicsRayCast::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModulePhysicsRayCast@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph3D::Update
==============
*/

void __fastcall ParticleModuleRotationGraph3D::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleRotationGraph3D@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleAttractor::DebugDraw
==============
*/

void __fastcall ParticleModuleAttractor::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleAttractor@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::Update
==============
*/

void __fastcall ParticleModulePhysicsLight::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePhysicsLight@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleColorLerp::Update
==============
*/

void __fastcall ParticleModuleColorLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleColorLerp@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::CreatePhysicsParticles
==============
*/
void ParticleModulePhysicsLight::CreatePhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleOffset, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  __int128 v5; 
  __int128 v6; 
  __int128 v7; 
  __int128 v8; 
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  __int128 v13; 
  __int128 v14; 
  __int64 v17; 
  HavokPhysicsFX_Pipeline *m_physicsFXPipelineInstance; 
  int m_physicsFXShapeIndex; 
  unsigned int *FlagsArrayAtIndex; 
  const vector4 *EmitterTransform; 
  __int64 v22; 
  int *v23; 
  int Particles; 
  unsigned int v25; 
  unsigned int v26; 
  signed __int64 v27; 
  signed __int64 v28; 
  float4 *v29; 
  signed __int64 v30; 
  signed __int64 v31; 
  signed __int64 v33; 
  int v34; 
  __int128 *v35; 
  __int128 v36; 
  double ScaleFactorByCameraDistance; 
  const float4 *v38; 
  float4 *v39; 
  vec4_t v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  const char *VFXName; 
  const char *v52; 
  const char *v53; 
  const char *v54; 
  Physics_WorldId v55; 
  ParticleSystem *SystemOwner; 
  const ParticleSystemDef *Def; 
  unsigned int v60; 
  unsigned int v61; 
  __int64 v62; 
  __int64 v63; 
  bool m_ignoreEmitterOrientation; 
  Physics_WorldId m_physicsWorldId; 
  float4 *RotationRateArrayAtIndex; 
  signed __int64 v69; 
  float4 *RotationAngleArrayAtIndex; 
  signed __int64 v71; 
  int *particleIds; 
  int *particleIdsa; 
  unsigned __int8 *v74; 
  signed __int64 v75; 
  float4 *VelocityArrayAtIndex; 
  signed __int64 v77; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v79; 
  float4 *PositionArrayAtIndex; 
  float4 *SizeArrayAtIndex; 
  signed __int64 v82; 
  ParticleEmitter *m_pEmitterOwner; 
  ParticleModuleScaleByDistance *pModuleScaleByDistance; 
  signed __int64 v85; 
  vec3_t position; 
  vec3_t velocity; 
  vec3_t v88; 
  vec4_t orientation; 
  vec4_t quat; 
  __int128 v91; 
  __int128 v92; 
  __int128 v93; 
  __int128 v94; 
  __int128 v95; 
  __int128 v96; 
  __int128 v97; 
  __int128 v98; 
  __int128 v99; 
  __int128 v100; 

  v17 = particleOffset;
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1280, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1281, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  m_physicsFXPipelineInstance = pParticleState->m_physicsFXPipelineInstance;
  if ( !m_physicsFXPipelineInstance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1284, ASSERT_TYPE_ASSERT, "(physicsFXPipeline)", (const char *)&queryFormat, "physicsFXPipeline") )
    __debugbreak();
  m_physicsFXShapeIndex = pParticleState->m_physicsFXShapeIndex;
  particleIds = ParticleState::GetPhysicsFXParticleIDList(pParticleState);
  if ( !particleIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1289, ASSERT_TYPE_ASSERT, "(physicsFXParticleIDList)", (const char *)&queryFormat, "physicsFXParticleIDList") )
    __debugbreak();
  m_physicsWorldId = pParticleState->m_physicsWorldId;
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v17);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v17);
  SizeArrayAtIndex = Particle_GetSizeArrayAtIndex(pParticleData, v17);
  RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, v17);
  RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, v17);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v17);
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  EmitterTransform = ParticleEmitter::GetEmitterTransform(m_pEmitterOwner, pParticleState);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v17);
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v17 >= pParticleData->m_particleCountMax )
  {
    LODWORD(v62) = v17;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v62, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v22 = v17;
  v74 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_CAMERA_DISTANCE)[v22 * 4];
  pModuleScaleByDistance = (ParticleModuleScaleByDistance *)pParticleState->m_pModuleScaleByDistance;
  if ( !pModuleScaleByDistance && (pParticleState->m_pStateDef->flags & 0x800000000i64) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1307, ASSERT_TYPE_ASSERT, "(pModuleScaleByDistance || !pParticleState->HasFlag( PARTICLE_STATE_DEF_FLAG_SCALE_BY_DISTANCE ))", (const char *)&queryFormat, "pModuleScaleByDistance || !pParticleState->HasFlag( PARTICLE_STATE_DEF_FLAG_SCALE_BY_DISTANCE )") )
    __debugbreak();
  v23 = &particleIds[v22];
  particleIdsa = v23;
  Particles = PhysicsFX_CreateParticles(m_physicsWorldId, m_physicsFXPipelineInstance, m_physicsFXShapeIndex, particleCountEmit, v23);
  v25 = particleCountEmit;
  if ( Particles != particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1312, ASSERT_TYPE_ASSERT, "(static_cast<uint>( numParticlesAllocated ) == particleCountEmit)", (const char *)&queryFormat, "static_cast<uint>( numParticlesAllocated ) == particleCountEmit") )
    __debugbreak();
  m_ignoreEmitterOrientation = this->m_ignoreEmitterOrientation;
  if ( !m_ignoreEmitterOrientation )
    Particle_RotMatrixToQuatVec(EmitterTransform, &quat);
  v26 = 0;
  if ( particleCountEmit )
  {
    v27 = (char *)v23 - (char *)RandomSeedArrayAtIndex;
    v28 = v74 - (unsigned __int8 *)RandomSeedArrayAtIndex;
    v29 = PositionArrayAtIndex;
    v30 = (char *)SizeArrayAtIndex - (char *)VelocityArrayAtIndex;
    v69 = (char *)RotationRateArrayAtIndex - (char *)VelocityArrayAtIndex;
    v31 = (char *)RandomSeedArrayAtIndex - (char *)FlagsArrayAtIndex;
    v71 = (char *)RotationAngleArrayAtIndex - (char *)VelocityArrayAtIndex;
    _RSI = PositionArrayAtIndex;
    v100 = v5;
    v33 = (char *)VelocityArrayAtIndex - (char *)PositionArrayAtIndex;
    v91 = v14;
    v99 = v6;
    v98 = v7;
    v97 = v8;
    v96 = v9;
    v95 = v10;
    v94 = v11;
    v93 = v12;
    v92 = v13;
    v85 = (char *)v23 - (char *)RandomSeedArrayAtIndex;
    v82 = (char *)SizeArrayAtIndex - (char *)VelocityArrayAtIndex;
    v75 = v74 - (unsigned __int8 *)RandomSeedArrayAtIndex;
    v79 = (char *)RandomSeedArrayAtIndex - (char *)FlagsArrayAtIndex;
    v77 = (char *)VelocityArrayAtIndex - (char *)PositionArrayAtIndex;
    do
    {
      v34 = *(unsigned int *)((char *)FlagsArrayAtIndex + v31 + v27);
      v35 = (__int128 *)((char *)_RSI + v33);
      v36 = *(__int128 *)((char *)_RSI + v33 + v30);
      if ( (pParticleState->m_pStateDef->flags & 0x800000000i64) != 0 )
      {
        ScaleFactorByCameraDistance = ParticleEmitter::GetScaleFactorByCameraDistance(m_pEmitterOwner, pModuleScaleByDistance, *(float *)((char *)FlagsArrayAtIndex + v31 + v28), *(unsigned int *)((char *)FlagsArrayAtIndex + v31));
        v29 = PositionArrayAtIndex;
        *(float *)&v36 = *(float *)&v36 * *(float *)&ScaleFactorByCameraDistance;
      }
      if ( *(float *)&v36 > 0.0 && PhysicsFX_IsValidParticlePosition(&v29[v26]) )
      {
        _XMM1 = _RSI->v;
        LODWORD(position.v[0]) = *(float4 *)_RSI->v.m128_f32;
        __asm
        {
          vextractps dword ptr [rbp+0E0h+position+4], xmm1, 1
          vextractps dword ptr [rbp+0E0h+position+8], xmm1, 2
        }
        _XMM2 = *v35;
        LODWORD(velocity.v[0]) = *v35;
        __asm
        {
          vextractps dword ptr [rbp+0E0h+velocity+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+velocity+8], xmm2, 2
        }
        _XMM2 = *(__int128 *)((char *)v35 + v69);
        LODWORD(v88.v[0]) = _XMM2;
        __asm
        {
          vextractps dword ptr [rbp+0E0h+var_110+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+var_110+8], xmm2, 2
        }
        v43 = *(vec4_t *)((char *)v35 + v71);
        Float4RadianToQuat(v39, v38);
        if ( m_ignoreEmitterOrientation )
        {
          orientation = v43;
          v49 = v43.v[2];
          v48 = v43.v[1];
          v47 = v43.v[0];
          LODWORD(v50) = _mm_shuffle_ps((__m128)v43, (__m128)v43, 255).m128_u32[0];
        }
        else
        {
          v44 = _mm_shuffle_ps((__m128)v43, (__m128)v43, 255).m128_f32[0];
          v45 = _mm_shuffle_ps((__m128)v43, (__m128)v43, 85).m128_f32[0];
          v46 = _mm_shuffle_ps((__m128)v43, (__m128)v43, 170).m128_f32[0];
          v47 = (float)((float)((float)(v43.v[0] * quat.v[3]) + (float)(v44 * quat.v[0])) + (float)(v45 * quat.v[2])) - (float)(v46 * quat.v[1]);
          v48 = (float)((float)((float)(quat.v[1] * v44) - (float)(quat.v[2] * v43.v[0])) + (float)(v45 * quat.v[3])) + (float)(v46 * quat.v[0]);
          v49 = (float)((float)((float)(quat.v[1] * v43.v[0]) + (float)(quat.v[2] * v44)) - (float)(v45 * quat.v[0])) + (float)(v46 * quat.v[3]);
          v50 = (float)((float)((float)(quat.v[3] * v44) - (float)(v43.v[0] * quat.v[0])) - (float)(quat.v[1] * v45)) - (float)(v46 * quat.v[2]);
          orientation.v[3] = v50;
          orientation.v[0] = v47;
          orientation.v[1] = v48;
          orientation.v[2] = v49;
        }
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)((float)(v47 * v47) + (float)(v48 * v48)) + (float)(v49 * v49)) + (float)(v50 * v50)) - 1.0) & _xmm) >= 0.0020000001 )
        {
          VFXName = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1362, ASSERT_TYPE_ASSERT, "(Vec4IsNormalized( orientation ))", "%s\n\tVFX ERROR: Unnormalized quat when initializing HavokFX particle: %s\n", "Vec4IsNormalized( orientation )", VFXName) )
            __debugbreak();
        }
        if ( (LODWORD(position.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(position.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(position.v[2]) & 0x7F800000) == 2139095040 )
        {
          v52 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1364, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( position )[0] ) && !IS_NAN( ( position )[1] ) && !IS_NAN( ( position )[2] ) ) )", "fx %s", v52) )
            __debugbreak();
        }
        if ( (LODWORD(velocity.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(velocity.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(velocity.v[2]) & 0x7F800000) == 2139095040 )
        {
          v53 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1365, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] ) ) )", "fx %s", v53) )
            __debugbreak();
        }
        if ( (LODWORD(v88.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(v88.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(v88.v[2]) & 0x7F800000) == 2139095040 )
        {
          v54 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1366, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( angularVelocity )[0] ) && !IS_NAN( ( angularVelocity )[1] ) && !IS_NAN( ( angularVelocity )[2] ) ) )", "fx %s", v54) )
            __debugbreak();
        }
        v55 = m_physicsWorldId;
        PhysicsFX_SetParticlePosition(m_physicsWorldId, m_physicsFXPipelineInstance, v34, &position);
        PhysicsFX_SetParticleLinearVelocity(m_physicsWorldId, m_physicsFXPipelineInstance, v34, &velocity);
        PhysicsFX_SetParticleAngularVelocity(m_physicsWorldId, m_physicsFXPipelineInstance, v34, &v88);
        PhysicsFX_SetParticleScale(m_physicsWorldId, m_physicsFXPipelineInstance, v34, *(float *)&v36);
        PhysicsFX_SetParticleOrientation(m_physicsWorldId, m_physicsFXPipelineInstance, v34, &orientation);
      }
      else
      {
        SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
        Def = ParticleSystem::GetDef(SystemOwner);
        __asm
        {
          vbroadcastss xmm1, dword ptr [rsi+4]
          vbroadcastss xmm0, dword ptr [rsi+8]
        }
        Com_PrintWarning(21, "WARNING: Particle position of (%f,%f,%f) outside PHYSICS_FX_MAX_POS, or zero scale for effect: %s\n", COERCE_FLOAT(*_RSI), *(float *)&_XMM1, *(float *)&_XMM0, Def->name);
        *FlagsArrayAtIndex |= 1u;
        v55 = m_physicsWorldId;
      }
      v25 = particleCountEmit;
      PhysicsFX_ParticlesUpdated(v55, m_physicsFXPipelineInstance, particleCountEmit, particleIdsa);
      ++v26;
      v28 = v75;
      v31 = v79;
      v27 = v85;
      ++_RSI;
      v29 = PositionArrayAtIndex;
      v30 = v82;
      *FlagsArrayAtIndex = *FlagsArrayAtIndex & 0xFFFFFFBD | 0x40;
      ++FlagsArrayAtIndex;
      v33 = v77;
    }
    while ( v26 < particleCountEmit );
  }
  v60 = v25 + pParticleState->m_numPhysicsFXParticles;
  v61 = pParticleState->m_particleCountMax + 1;
  pParticleState->m_numPhysicsFXParticles = v60;
  if ( v60 >= v61 )
  {
    LODWORD(v63) = v61;
    LODWORD(v62) = v60;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 565, ASSERT_TYPE_ASSERT, "(unsigned)( m_numPhysicsFXParticles ) < (unsigned)( m_particleCountMax + 1 )", "m_numPhysicsFXParticles doesn't index m_particleCountMax + 1\n\t%i not in [0, %i)", v62, v63) )
      __debugbreak();
  }
}

/*
==============
ParticleModuleAttractor::DebugDraw
==============
*/
void ParticleModuleAttractor::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  vec3_t center; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 474, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 475, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 476, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 477, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    _XMM2 = _mm128_add_ps(ParticleEmitter::GetEmitterPos((ParticleEmitter *)pEmitterOwner, pParticleState)->v, *(__m128 *)&pModuleBase[4].m_type);
    center.v[0] = _XMM2.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rsp+78h+center+4], xmm2, 1
      vextractps dword ptr [rsp+78h+center+8], xmm2, 2
    }
    Particle_DebugSphere(&center, 5.0, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleEmissionGraph::GetSpawnRate
==============
*/
float ParticleModuleEmissionGraph::GetSpawnRate(ParticleModuleEmissionGraph *this, float time, unsigned __int16 randomSeed)
{
  unsigned int v5; 
  double CurveValue; 
  float v7; 
  double v8; 

  v5 = this->m_flags >> 4;
  CurveValue = Particle_GetCurveValue(this->m_curves, time);
  v7 = *(float *)&CurveValue * this->m_curves[0].scale;
  if ( (v5 & 1) == 0 )
    return *(float *)&CurveValue * this->m_curves[0].scale;
  v8 = Particle_GetCurveValue(&this->m_curves[1], time);
  return (float)((float)(1.0 - fx_randomTable[randomSeed + 50]) * v7) + (float)((float)(*(float *)&v8 * this->m_curves[1].scale) * fx_randomTable[randomSeed + 50]);
}

/*
==============
ParticleModuleColorGraph::Init
==============
*/
void ParticleModuleColorGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
}

/*
==============
ParticleModuleEmissionGraph::Init
==============
*/
void ParticleModuleEmissionGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase->m_flags |= 0x200u;
}

/*
==============
ParticleModuleEmissiveGraph::Init
==============
*/
void ParticleModuleEmissiveGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[19].m_flags = 1065353216;
  pModuleBase[21].m_flags = 1065353216;
  pModuleBase[11].m_flags = 0;
  pModuleBase[21].m_flags = 0;
}

/*
==============
ParticleModuleForceDragGraph::Init
==============
*/
void ParticleModuleForceDragGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleGravity::Init
==============
*/
void ParticleModuleGravity::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleIntensityGraph::Init
==============
*/
void ParticleModuleIntensityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleParentVelocityGraph::Init
==============
*/
void ParticleModuleParentVelocityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModulePhysicsRayCast::Init
==============
*/
void ParticleModulePhysicsRayCast::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModulePositionGraph::Init
==============
*/
void ParticleModulePositionGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModuleRotationGraph3D::Init
==============
*/
void ParticleModuleRotationGraph3D::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 0;
  pModuleBase[5].m_flags = 0;
  pModuleBase[7].m_flags = 0;
  pModuleBase[9].m_flags = 0;
  pModuleBase[11].m_flags = 0;
  pModuleBase[13].m_flags = 0;
}

/*
==============
ParticleModuleRotationGraph::Init
==============
*/
void ParticleModuleRotationGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 0;
  pModuleBase[5].m_flags = 0;
}

/*
==============
ParticleModuleScaleByDistance::Init
==============
*/
void ParticleModuleScaleByDistance::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[6].m_type = 1148846080;
}

/*
==============
ParticleModuleShaderGraph::Init
==============
*/
void ParticleModuleShaderGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[19].m_flags = 1065353216;
  pModuleBase[21].m_flags = 1065353216;
  pModuleBase[23].m_flags = 1065353216;
  pModuleBase[25].m_flags = 1065353216;
}

/*
==============
ParticleModuleSizeGraph::Init
==============
*/
void ParticleModuleSizeGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModuleTemperatureGraph::Init
==============
*/
void ParticleModuleTemperatureGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleVectorFieldGraph::Init
==============
*/
void ParticleModuleVectorFieldGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleVelocityGraph::Init
==============
*/
void ParticleModuleVelocityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModulePhysicsLight::InitPhysicsParticles
==============
*/
void ParticleModulePhysicsLight::InitPhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  unsigned int m_particleCountRunning; 
  unsigned int *FlagsArrayAtIndex; 
  const ParticleEmitter *m_pEmitterOwner; 
  LocalClientNum_t m_localClientNum; 
  const ParticleSystem *SystemOwner; 
  ParticleSystemHandle particleSystemHandle; 
  __int64 v14; 
  unsigned int v16; 
  __int64 v20; 
  unsigned int *v22; 
  __int64 v23; 

  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1397, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1398, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1399, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1400, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, m_particleCountRunning);
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = pParticleState->m_pEmitterOwner;
  m_localClientNum = m_pEmitterOwner->m_pSystemOwner->m_localClientNum;
  if ( !m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pParticleState->m_pEmitterOwner);
  if ( SystemOwner->m_systemHandle == PARTICLE_SYSTEM_INVALID_HANDLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlesystem.h", 196, ASSERT_TYPE_ASSERT, "(m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE)", (const char *)&queryFormat, "m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE") )
    __debugbreak();
  particleSystemHandle = SystemOwner->m_systemHandle;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  Particle_AddDeferredPhysicsFXCreate(m_localClientNum, this, pParticleData, m_particleCountRunning, particleCountEmit, pParticleState, pParticleState->m_pEmitterOwner, particleSystemHandle);
  v14 = 0i64;
  if ( particleCountEmit )
  {
    if ( particleCountEmit >= 0x10 )
    {
      _XMM2 = _xmm;
      v16 = 8;
      do
      {
        __asm { vpor    xmm1, xmm2, xmmword ptr [r14+rdx*4] }
        *(_OWORD *)&FlagsArrayAtIndex[v14] = _XMM1;
        v14 = (unsigned int)(v14 + 16);
        __asm { vpor    xmm1, xmm2, xmmword ptr [r14+rax*4] }
        *(_OWORD *)&FlagsArrayAtIndex[v16 - 4] = _XMM1;
        __asm { vpor    xmm1, xmm2, xmmword ptr [r14+rax*4] }
        *(_OWORD *)&FlagsArrayAtIndex[v16] = _XMM1;
        v20 = v16 + 4;
        v16 += 16;
        __asm { vpor    xmm1, xmm2, xmmword ptr [r14+rax*4] }
        *(_OWORD *)&FlagsArrayAtIndex[v20] = _XMM1;
      }
      while ( (unsigned int)v14 < (particleCountEmit & 0xFFFFFFF0) );
    }
    if ( (unsigned int)v14 < particleCountEmit )
    {
      v22 = &FlagsArrayAtIndex[v14];
      v23 = particleCountEmit - (unsigned int)v14;
      do
      {
        *v22++ |= 2u;
        --v23;
      }
      while ( v23 );
    }
  }
}

/*
==============
Particle_TransformForceRelativeToEffectOrigin
==============
*/
void Particle_TransformForceRelativeToEffectOrigin(const float4 *spawnQuat, const vector4 *rEmitterTransformTranspose, bool worldForce, const float4 *force, float4 *outForceTransformed)
{
  __m128 v; 
  float4 v6; 
  __m128 v7; 
  __m128 v8; 
  __m128 v9; 
  __m128 v10; 
  __m128 v11; 
  __m128 v12; 

  if ( worldForce )
  {
    v = force->v;
    v6.v = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 85), rEmitterTransformTranspose->y.v), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 170), rEmitterTransformTranspose->z.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v, v, 0), rEmitterTransformTranspose->x.v), g_negativeZero.v)));
    *outForceTransformed = (float4)v6.v;
    *outForceTransformed = (float4)(*(_OWORD *)&v6.v & *(_OWORD *)&g_keepXYZ.v);
  }
  else
  {
    v7 = spawnQuat->v;
    v8 = _mm_shuffle_ps(v7, v7, 201);
    v9 = _mm_shuffle_ps(v7, v7, 210);
    v10 = _mm_shuffle_ps(v7, v7, 255);
    v11 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(force->v, force->v, 210), v8), _mm128_mul_ps(_mm_shuffle_ps(force->v, force->v, 201), v9));
    v12 = _mm128_add_ps(v11, v11);
    outForceTransformed->v = _mm128_add_ps(_mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v12, v12, 210), v8), _mm128_mul_ps(_mm_shuffle_ps(v12, v12, 201), v9)), _mm128_add_ps(_mm128_mul_ps(v10, v12), force->v));
  }
}

/*
==============
Particle_UpdateForceRayCast
==============
*/
void Particle_UpdateForceRayCast(const ParticleModuleForce *pModule, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, float dt, const vector4 *rEmitterTransform, bool noLerp, bool applyTransform, bool hasVelocityGraph, float emitterLife)
{
  __int64 v10; 
  unsigned int *FlagsArrayAtIndex; 
  float *SpawnTimeArrayAtIndex; 
  float4 *VelocityArrayAtIndex; 
  signed __int64 v17; 
  __int64 v18; 
  float4 v19; 
  float4 v20; 
  __m128 v21; 
  __m128 v22; 
  bool v23; 
  int *RandomSeedArrayAtIndex; 
  int *v25; 
  __m128 v27; 
  signed __int64 v29; 
  signed __int64 v30; 
  __int64 v31; 
  float4 v33; 
  __m128 v38; 
  __m128 v39; 
  __m128 v41; 
  __int64 v42; 

  v10 = particleCount;
  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 823, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 824, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( (unsigned int)v10 + particleOffset >= pParticleData->m_particleCountRunning + 1 )
  {
    LODWORD(v42) = v10 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 825, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountRunning() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountRunning() + 1\n\t%i not in [0, %i)", v42, pParticleData->m_particleCountRunning + 1) )
      __debugbreak();
  }
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  if ( noLerp )
  {
    if ( (_DWORD)v10 )
    {
      v17 = (char *)FlagsArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      v18 = v10;
      do
      {
        if ( (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v17) & 0x10) == 0 )
        {
          if ( !applyTransform || (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v17) & 8) != 0 )
          {
            v20.v = (__m128)pModule->m_forceMin;
          }
          else
          {
            v19.v = (__m128)pModule->m_forceMin;
            v20.v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v19.v, v19.v, 0), rEmitterTransform->x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v19.v, v19.v, 85), rEmitterTransform->y.v), _mm128_mul_ps(_mm_shuffle_ps(v19.v, v19.v, 170), rEmitterTransform->z.v)));
          }
          if ( !hasVelocityGraph || (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v17) & 8) != 0 )
          {
            v21 = (__m128)LODWORD(dt);
          }
          else
          {
            v22 = (__m128)LODWORD(emitterLife);
            v22.m128_f32[0] = emitterLife - *SpawnTimeArrayAtIndex;
            v21 = v22;
          }
          VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v21, v21, 0), v20.v), VelocityArrayAtIndex->v);
        }
        ++SpawnTimeArrayAtIndex;
        ++VelocityArrayAtIndex;
        --v18;
      }
      while ( v18 );
    }
  }
  else
  {
    v23 = (pModule->m_flags & 0x20) != 0;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
    v25 = RandomSeedArrayAtIndex;
    __asm { vbroadcastss xmm6, [rsp+0A8h+dt] }
    v27 = _XMM6;
    if ( (_DWORD)v10 )
    {
      _RBP = fx_randomTable;
      v29 = (char *)FlagsArrayAtIndex - (char *)RandomSeedArrayAtIndex;
      v30 = (char *)SpawnTimeArrayAtIndex - (char *)RandomSeedArrayAtIndex;
      v31 = v10;
      do
      {
        if ( (*(int *)((char *)v25 + v29) & 0x10) == 0 )
        {
          if ( hasVelocityGraph && (*(int *)((char *)v25 + v29) & 8) != 0 )
            v27 = _XMM6;
          _RDX = *v25;
          v33.v = (__m128)pModule->m_forceMax;
          if ( v23 )
          {
            _XMM1 = 0i64;
            __asm
            {
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B0h], 0
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B4h], 10h
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B8h], 20h ; ' '
            }
            v38 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v33.v, pModule->m_forceMin.v)), pModule->m_forceMin.v);
          }
          else
          {
            v39 = _mm128_sub_ps(v33.v, pModule->m_forceMin.v);
            __asm { vbroadcastss xmm0, dword ptr [rbp+rdx*4+0B0h] }
            v38 = _mm128_add_ps(_mm128_mul_ps(v39, _XMM0), pModule->m_forceMin.v);
          }
          if ( hasVelocityGraph && (*(int *)((char *)v25 + v29) & 8) == 0 )
          {
            v41 = (__m128)LODWORD(emitterLife);
            v41.m128_f32[0] = emitterLife - *(float *)((char *)v25 + v30);
            v27 = _mm_shuffle_ps(v41, v41, 0);
          }
          if ( !applyTransform || (*(int *)((char *)v25 + v29) & 8) != 0 )
            VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(v38, v27), VelocityArrayAtIndex->v);
          else
            VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v38, v38, 0), rEmitterTransform->x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v38, v38, 85), rEmitterTransform->y.v), _mm128_mul_ps(_mm_shuffle_ps(v38, v38, 170), rEmitterTransform->z.v))), v27), VelocityArrayAtIndex->v);
        }
        ++v25;
        ++VelocityArrayAtIndex;
        --v31;
      }
      while ( v31 );
    }
  }
}

/*
==============
Particle_UpdateForceRelativeToEffectOrigin
==============
*/
void Particle_UpdateForceRelativeToEffectOrigin(const ParticleModuleForce *pModule, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const ParticleState *pParticleState, float dt, const vector4 *rEmitterTransform, bool noLerp, bool applyTransform, bool useWorldForce, bool hasVelocityGraph, float emitterLife, ParticleRelativeVelocityType relativeVelocityType)
{
  __int64 v15; 
  bool v17; 
  bool v18; 
  float *SpawnTimeArrayAtIndex; 
  float4 *VelocityArrayAtIndex; 
  unsigned __int8 *ParticleDataArray; 
  unsigned int v22; 
  unsigned __int8 *v23; 
  ParticleEmitter *EmitterOwner; 
  const vector4 *EmitterTransformTranspose; 
  float4 *p_m_forceMin; 
  unsigned int v27; 
  __m128 v28; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v33; 
  signed __int64 v34; 
  __int64 v35; 
  float4 v37; 
  __m128 v42; 
  __m128 v43; 
  __m128 v45; 
  __m128 v46; 
  __m128 v47; 
  __m128 v48; 
  __m128 v49; 
  __m128 v50; 
  __m128 v51; 
  __int64 v52; 
  __int64 v53; 
  bool v55; 
  __m128 *p_v; 
  float4 outForceTransformed; 

  v15 = particleCount;
  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 920, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 921, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( (unsigned int)v15 + particleOffset >= pParticleData->m_particleCountRunning + 1 )
  {
    LODWORD(v52) = v15 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 922, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountRunning() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountRunning() + 1\n\t%i not in [0, %i)", v52, pParticleData->m_particleCountRunning + 1) )
      __debugbreak();
  }
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 923, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( applyTransform || relativeVelocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
  {
    v17 = useWorldForce;
    v18 = !hasVelocityGraph || useWorldForce;
  }
  else
  {
    v17 = useWorldForce;
    v18 = 0;
  }
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( particleOffset >= pParticleData->m_particleCountMax )
  {
    LODWORD(v53) = pParticleData->m_particleCountMax;
    LODWORD(v52) = particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v52, v53) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  ParticleDataArray = ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_SPAWN_QUAT);
  v22 = particleOffset;
  v23 = &ParticleDataArray[16 * particleOffset];
  if ( v18 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
    v22 = particleOffset;
  }
  else
  {
    EmitterTransformTranspose = rEmitterTransform;
  }
  p_v = &EmitterTransformTranspose->x.v;
  if ( noLerp )
  {
    p_m_forceMin = &pModule->m_forceMin;
    if ( !applyTransform )
      outForceTransformed.v = p_m_forceMin->v;
    v27 = 0;
    if ( hasVelocityGraph )
    {
      if ( (_DWORD)v15 )
      {
        do
        {
          if ( v18 )
            Particle_TransformForceRelativeToEffectOrigin((const float4 *)&v23[16 * v27], EmitterTransformTranspose, v17, p_m_forceMin, &outForceTransformed);
          v28 = (__m128)LODWORD(emitterLife);
          v28.m128_f32[0] = emitterLife - *SpawnTimeArrayAtIndex;
          EmitterTransformTranspose = (const vector4 *)p_v;
          ++v27;
          VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v28, v28, 0), outForceTransformed.v), VelocityArrayAtIndex->v);
          ++VelocityArrayAtIndex;
          ++SpawnTimeArrayAtIndex;
        }
        while ( v27 < (unsigned int)v15 );
      }
    }
    else if ( (_DWORD)v15 )
    {
      __asm { vbroadcastss xmm6, [rsp+108h+dt] }
      do
      {
        if ( v18 )
          Particle_TransformForceRelativeToEffectOrigin((const float4 *)&v23[16 * v27], EmitterTransformTranspose, v17, p_m_forceMin, &outForceTransformed);
        EmitterTransformTranspose = (const vector4 *)p_v;
        ++v27;
        VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_XMM6, outForceTransformed.v), VelocityArrayAtIndex->v);
        ++VelocityArrayAtIndex;
      }
      while ( v27 < (unsigned int)v15 );
    }
  }
  else
  {
    v55 = (pModule->m_flags & 0x20) != 0;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v22);
    __asm { vbroadcastss xmm8, [rsp+108h+dt] }
    if ( (_DWORD)v15 )
    {
      _R11 = fx_randomTable;
      v33 = (char *)RandomSeedArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      v34 = v23 - (unsigned __int8 *)VelocityArrayAtIndex;
      v35 = v15;
      do
      {
        _RAX = *(int *)((char *)SpawnTimeArrayAtIndex + v33);
        v37.v = (__m128)pModule->m_forceMax;
        if ( v55 )
        {
          _XMM1 = 0i64;
          __asm
          {
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B0h], 0
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B4h], 10h
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B8h], 20h ; ' '
          }
          v42 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v37.v, pModule->m_forceMin.v)), pModule->m_forceMin.v);
        }
        else
        {
          v43 = _mm128_sub_ps(v37.v, pModule->m_forceMin.v);
          __asm { vbroadcastss xmm0, dword ptr [r11+rax*4+0B0h] }
          v42 = _mm128_add_ps(_mm128_mul_ps(v43, _XMM0), pModule->m_forceMin.v);
        }
        if ( hasVelocityGraph )
        {
          v45 = (__m128)LODWORD(emitterLife);
          v45.m128_f32[0] = emitterLife - *SpawnTimeArrayAtIndex;
          _XMM8 = _mm_shuffle_ps(v45, v45, 0);
        }
        if ( v18 )
        {
          if ( v17 )
          {
            v42 = (__m128)(*(_OWORD *)&_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v42, v42, 85), p_v[1]), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v42, v42, 170), p_v[2]), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v42, v42, 0), *p_v), g_negativeZero.v))) & *(_OWORD *)&g_keepXYZ.v);
          }
          else
          {
            v46 = *(__m128 *)((char *)&VelocityArrayAtIndex->v + v34);
            v47 = _mm_shuffle_ps(v46, v46, 210);
            v48 = _mm_shuffle_ps(v46, v46, 201);
            v49 = _mm_shuffle_ps(v46, v46, 255);
            v50 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v42, v42, 210), v48), _mm128_mul_ps(_mm_shuffle_ps(v42, v42, 201), v47));
            v51 = _mm128_add_ps(v50, v50);
            v42 = _mm128_add_ps(_mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v51, v51, 210), v48), _mm128_mul_ps(_mm_shuffle_ps(v51, v51, 201), v47)), _mm128_add_ps(_mm128_mul_ps(v49, v51), v42));
          }
        }
        VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_XMM8, v42), VelocityArrayAtIndex->v);
        ++VelocityArrayAtIndex;
        ++SpawnTimeArrayAtIndex;
        --v35;
      }
      while ( v35 );
    }
  }
}

/*
==============
ParticleModuleAttractor::Update
==============
*/
void ParticleModuleAttractor::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v9; 
  float4 *VelocityArrayAtIndex; 
  unsigned int *FlagsArrayAtIndex; 
  __m128 m_emitterLife_low; 
  float *SpawnTimeArrayAtIndex; 
  const vector4 *EmitterTransform; 
  __m128 v16; 
  __int64 v17; 
  signed __int64 v18; 
  __int64 v19; 
  __m128 v20; 
  __m128 v28; 
  __m128 v29; 
  __int64 v30; 
  __int64 v31; 
  float4 *PositionArrayAtIndex; 

  v9 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v9 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v30) = v9 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v30, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  m_emitterLife_low = (__m128)LODWORD(pEmitterOwner->m_emitterLife);
  v31 = pParticleState->m_pStateDef->flags & 0x300;
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  v16 = _mm128_add_ps(_mm_shuffle_ps(EmitterTransform->w.v, _mm_shuffle_ps(EmitterTransform->w.v, (__m128)0i64, 250), 132), *(__m128 *)&pModuleBase[4].m_type);
  if ( (_DWORD)v9 )
  {
    v17 = 0i64;
    v18 = (char *)SpawnTimeArrayAtIndex - (char *)FlagsArrayAtIndex;
    v19 = v9;
    do
    {
      v20 = _mm128_sub_ps(v16, PositionArrayAtIndex[v17].v);
      _XMM1 = _mm128_mul_ps(v20, v20);
      __asm
      {
        vinsertps xmm0, xmm1, xmm1, 8
        vhaddps xmm3, xmm0, xmm0
      }
      if ( LOBYTE(pModuleBase[2].m_flags) )
      {
        __asm { vhaddps xmm0, xmm3, xmm3 }
        if ( *(float *)&_XMM0 <= *(float *)&pModuleBase[3].m_flags )
          *FlagsArrayAtIndex |= 1u;
      }
      __asm
      {
        vinsertps xmm0, xmm1, xmm1, 8
        vhaddps xmm1, xmm0, xmm0
        vhaddps xmm0, xmm1, xmm1
      }
      v28 = _mm128_div_ps(v20, _mm_sqrt_ps(_XMM0));
      if ( v31 )
      {
        v29 = m_emitterLife_low;
        v29.m128_f32[0] = (float)(m_emitterLife_low.m128_f32[0] - *(float *)((char *)FlagsArrayAtIndex + v18)) * *(float *)&pModuleBase[3].m_type;
      }
      else
      {
        v29 = (__m128)LODWORD(dt);
        v29.m128_f32[0] = dt * *(float *)&pModuleBase[3].m_type;
      }
      VelocityArrayAtIndex[v17].v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v29, v29, 0), v28), VelocityArrayAtIndex[v17].v);
      ++v17;
      ++FlagsArrayAtIndex;
      --v19;
    }
    while ( v19 );
  }
}

/*
==============
ParticleModuleColorGraph::Update
==============
*/
void ParticleModuleColorGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  unsigned int m_flags; 
  bool useLength; 
  bool v13; 
  ParticleState *ColorArrayAtIndex; 
  float *LifeArrayAtIndex; 
  char v16; 
  float lengthFraction; 
  unsigned int v18; 
  __m128 v; 
  signed __int64 v21; 
  __m128 v22; 
  __int64 i; 
  float v25; 
  __m128 v26; 
  __m128 v28; 
  __m128 v29; 
  __m128 v30; 
  __int64 v34; 
  bool v36; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v38; 
  float4 outCurve; 
  float4 v40; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v34) = particleCount + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v34, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = pModuleBase->m_flags;
  useLength = pParticleState->m_moduleGraphLengthData.useLength;
  v13 = (m_flags & 0x10) != 0;
  v36 = (m_flags & 0x20) != 0;
  if ( useLength && (m_flags & 0x300) != 768 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 509, ASSERT_TYPE_ASSERT, "(!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  ColorArrayAtIndex = (ParticleState *)Particle_GetColorArrayAtIndex(pParticleData, particleOffset);
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  if ( (pModuleBase->m_flags & 4) != 0 || useLength )
  {
    v16 = 0;
    if ( useLength )
    {
      lengthFraction = pParticleState->m_moduleGraphLengthData.lengthFraction;
      ColorArrayAtIndex = (ParticleState *)pParticleState;
    }
    else
    {
      lengthFraction = pEmitterOwner->m_emitterLifeNormalized;
    }
    Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], lengthFraction, &outCurve);
    if ( v13 )
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], lengthFraction, &v40);
  }
  else
  {
    v16 = 1;
  }
  v18 = 1;
  if ( !useLength )
    v18 = particleCount;
  if ( v18 )
  {
    _RDX = fx_randomTable;
    v = outCurve.v;
    v21 = (char *)RandomSeedArrayAtIndex - (char *)LifeArrayAtIndex;
    v22 = v40.v;
    v38 = (char *)RandomSeedArrayAtIndex - (char *)LifeArrayAtIndex;
    for ( i = v18; i; --i )
    {
      _RBP = *(int *)((char *)LifeArrayAtIndex + v21);
      if ( v16 )
      {
        v25 = *LifeArrayAtIndex;
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *LifeArrayAtIndex, &outCurve);
        if ( !v13 )
        {
          v = outCurve.v;
          goto LABEL_43;
        }
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], v25, &v40);
        v = outCurve.v;
        v22 = v40.v;
        _RDX = fx_randomTable;
      }
      if ( v13 )
      {
        v26 = _mm128_sub_ps(v22, v);
        if ( v36 )
        {
          _XMM1 = LODWORD(fx_randomTable[_RBP + 25]);
          __asm
          {
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+68h], 10h
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+6Ch], 20h ; ' '
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+70h], 30h ; '0'
          }
        }
        else
        {
          __asm { vbroadcastss xmm1, dword ptr [rdx+rbp*4+60h] }
        }
        v28 = _mm128_add_ps(_mm128_mul_ps(_XMM1, v26), v);
        goto LABEL_44;
      }
LABEL_43:
      v28 = v;
      _RDX = fx_randomTable;
LABEL_44:
      if ( LOBYTE(pModuleBase[1].m_flags) )
      {
        v29 = _mm_shuffle_ps(v28, v28, 255);
        v30 = _mm128_mul_ps(_mm_shuffle_ps(v29, v29, 0), v28);
        v28 = _mm_shuffle_ps(v30, _mm_shuffle_ps(v30, g_one.v, 250), 132);
      }
      if ( LOBYTE(pModuleBase[1].m_type) )
        ColorArrayAtIndex->m_moduleGraphLengthData.color.v = v28;
      else
        ColorArrayAtIndex->m_moduleGraphLengthData.color.v = _mm128_mul_ps(v28, ColorArrayAtIndex->m_moduleGraphLengthData.color.v);
      v21 = v38;
      ++LifeArrayAtIndex;
      ColorArrayAtIndex = (ParticleState *)((char *)ColorArrayAtIndex + 16);
    }
  }
}

/*
==============
ParticleModuleColorLerp::Update
==============
*/
void ParticleModuleColorLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  float4 *ColorArrayAtIndex; 
  float4 *v13; 
  __m128 v15; 
  __m128 v17; 
  __int64 v18; 
  __int64 v20; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R14 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v20) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v20, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  ColorArrayAtIndex = Particle_GetColorArrayAtIndex(pParticleData, particleOffset);
  v13 = ColorArrayAtIndex;
  if ( (pModuleBase->m_flags & 4) != 0 )
  {
    __asm { vbroadcastss xmm0, dword ptr [r14+178h] }
    v15 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)&pModuleBase[4].m_type, *(__m128 *)&pModuleBase[2].m_type), _XMM0), *(__m128 *)&pModuleBase[2].m_type);
    if ( (_DWORD)v7 )
    {
      *ColorArrayAtIndex = (float4)v15;
      qmemcpy(&ColorArrayAtIndex[1], ColorArrayAtIndex, 8 * ((unsigned __int64)(16 * v7 - 9) >> 3));
    }
  }
  else
  {
    _RAX = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    v17 = _mm128_sub_ps(*(__m128 *)&pModuleBase[4].m_type, *(__m128 *)&pModuleBase[2].m_type);
    if ( (_DWORD)v7 )
    {
      v18 = v7;
      do
      {
        ++v13;
        __asm { vbroadcastss xmm0, dword ptr [rax] }
        ++_RAX;
        v13[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, v17), *(__m128 *)&pModuleBase[2].m_type);
        --v18;
      }
      while ( v18 );
    }
  }
}

/*
==============
ParticleModuleEmissionGraph::Update
==============
*/
void ParticleModuleEmissionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleEmissiveGraph::Update
==============
*/
void ParticleModuleEmissiveGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int128 v7; 
  __int128 v8; 
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  const ParticleEmitter *v12; 
  ParticleData *v13; 
  __int64 v14; 
  __int64 v16; 
  __m128 *v17; 
  unsigned int m_flags; 
  float *LifeArrayAtIndex; 
  bool v22; 
  bool v23; 
  float m_emitterLifeNormalized; 
  __m128 v; 
  __m128 v28; 
  signed __int64 v29; 
  __int64 v30; 
  __int64 v31; 
  float v32; 
  __m128 v33; 
  __m128 v34; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 
  bool v44; 
  bool v45; 
  float4 v48; 
  float4 outCurve; 
  int *RandomSeedArrayAtIndex; 
  ParticleData *v51; 
  const ParticleEmitter *v52; 
  __int128 v53; 
  __int128 v54; 
  __int128 v55; 
  __int128 v56; 
  __int128 v57; 

  v12 = pEmitterOwner;
  v13 = pParticleData;
  v14 = particleCount;
  v16 = particleOffset;
  v52 = pEmitterOwner;
  v53 = v11;
  v51 = pParticleData;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (int)v14 + (int)v16 >= v13->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v14 + v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, v13->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v16 >= v13->m_particleCountMax )
  {
    LODWORD(rCurve2) = v13->m_particleCountMax;
    LODWORD(rCurve1) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v54 = v10;
  v17 = (__m128 *)&ParticleData::GetParticleDataArray(v13, PARTICLE_DATA_EMISSIVE)[16 * v16];
  m_flags = pModuleBase->m_flags;
  v45 = (m_flags & 0x20) != 0;
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(v13, v16);
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(v13, v16);
  _XMM10 = _xmm;
  __asm { vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 30h ; '0' }
  v22 = (pModuleBase->m_flags & 4) == 0;
  v44 = v22;
  v23 = (m_flags & 0x10) != 0;
  if ( v23 )
  {
    _XMM9 = _xmm;
    __asm { vinsertps xmm9, xmm9, dword ptr [rbx+9Ch], 30h ; '0' }
  }
  else
  {
    _XMM9 = outCurve.v;
  }
  v57 = v7;
  v56 = v8;
  v55 = v9;
  if ( v22 )
  {
    v = outCurve.v;
    goto LABEL_35;
  }
  m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
  Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized, &outCurve);
  v = _mm128_mul_ps(_XMM10, outCurve.v);
  outCurve.v = v;
  if ( !v23 )
  {
LABEL_35:
    v28 = v48.v;
    goto LABEL_36;
  }
  Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[12], m_emitterLifeNormalized, &v48);
  v28 = _mm128_mul_ps(_XMM9, v48.v);
  v48.v = v28;
LABEL_36:
  if ( !(_DWORD)v14 )
    goto LABEL_51;
  v29 = (char *)RandomSeedArrayAtIndex - (char *)LifeArrayAtIndex;
  v30 = v14;
  do
  {
    v31 = *(int *)((char *)LifeArrayAtIndex + v29);
    if ( v44 )
    {
      v32 = *LifeArrayAtIndex;
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *LifeArrayAtIndex, &outCurve);
      v = _mm128_mul_ps(_XMM10, outCurve.v);
      outCurve.v = v;
      if ( !v23 )
        goto LABEL_45;
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[12], v32, &v48);
      v28 = _mm128_mul_ps(_XMM9, v48.v);
      v48.v = v28;
    }
    if ( v23 )
    {
      if ( v45 )
      {
        _XMM1 = LODWORD(fx_randomTable[v31 + 25]);
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [rcx+r14*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [rcx+r14*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, xmm0, 30h ; '0'
        }
        v34 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v28, v)), v);
      }
      else
      {
        v33 = (__m128)LODWORD(fx_randomTable[v31 + 29]);
        v34 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(v28, v), _mm_shuffle_ps(v33, v33, 0)), v);
      }
      goto LABEL_46;
    }
LABEL_45:
    v34 = v;
LABEL_46:
    if ( LOBYTE(pModuleBase[1].m_type) )
      *v17 = v34;
    else
      *v17 = _mm128_mul_ps(v34, *v17);
    ++LifeArrayAtIndex;
    ++v17;
    --v30;
  }
  while ( v30 );
  v13 = v51;
  LODWORD(v16) = particleOffset;
  LODWORD(v14) = particleCount;
  v12 = v52;
LABEL_51:
  if ( (pParticleState->m_pStateDef->flags & 0x40000000000i64) != 0 )
  {
    if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v16 >= v13->m_particleCountMax )
    {
      LODWORD(rCurve2) = v13->m_particleCountMax;
      LODWORD(rCurve1) = v16;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    floatArray = (float *)&ParticleData::GetParticleDataArray(v13, PARTICLE_DATA_LIGHTING_FRAC)[4 * (unsigned int)v16];
    rCurve2a = (ParticleCurveDef *)&pModuleBase[20];
    rCurve1a = (ParticleCurveDef *)&pModuleBase[10];
    if ( LOBYTE(pModuleBase[1].m_type) )
      ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, v13, v16, v14, v12, rCurve1a, rCurve2a, FXRAND_LIGHTING_FRAC, floatArray);
    else
      ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, v13, v16, v14, v12, rCurve1a, rCurve2a, FXRAND_LIGHTING_FRAC, floatArray);
  }
}

/*
==============
ParticleModuleForce::Update
==============
*/
void ParticleModuleForce::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v10; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  ParticleRelativeVelocityType m_velocityType; 
  ParticleRelativeVelocityType v13; 
  bool v14; 
  bool v15; 
  unsigned __int64 flags; 
  bool applyTransform; 
  bool v18; 
  __m128 m_emitterLife_low; 
  float4 *VelocityArrayAtIndex; 
  float *SpawnTimeArrayAtIndex; 
  const vector4 *EmitterTransform; 
  const ParticleModuleInitRelativeVelocity *v23; 
  ParticleRelativeVelocityType v24; 
  bool v25; 
  unsigned int m_flags; 
  bool noLerp; 
  __m128 v; 
  __m128 v29; 
  __m128 v30; 
  __m128 v31; 
  char v32; 
  __m128 v33; 
  __m128 *p_v; 
  __m128 v35; 
  __m128 v36; 
  __int64 v37; 
  __m128 v38; 
  __m128 v40; 
  __int64 v41; 
  bool v42; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v46; 
  __int64 v47; 
  __m128 v49; 
  __m128 v54; 
  __m128 v55; 
  __m128 v57; 
  vector4 *rEmitterTransform; 
  bool hasVelocityGraph; 
  bool useWorldForce; 
  ParticleRelativeVelocityType relativeVelocityType; 
  __m128 *v63; 
  unsigned __int64 v65; 
  __m256i v66; 
  __m256i v67; 
  _BYTE v68[64]; 

  v10 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v10 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rEmitterTransform) = v10 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rEmitterTransform, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
    m_velocityType = PARTICLE_RELATIVE_VELOCITY_TYPE_LOCAL;
  else
    m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
  relativeVelocityType = m_velocityType;
  v14 = 0;
  if ( m_pModuleInitRelativeVelocity )
  {
    if ( (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 )
    {
      v13 = m_pModuleInitRelativeVelocity->m_velocityType;
      if ( v13 == PARTICLE_RELATIVE_VELOCITY_TYPE_WORLD || v13 == PARTICLE_RELATIVE_VELOCITY_TYPE_WORLD_WITH_BOLT_INFO )
        v14 = 1;
    }
  }
  v15 = (pModuleBase->m_flags & 0x80) != 0 || v14;
  useWorldForce = v15;
  flags = pParticleState->m_pStateDef->flags;
  v65 = flags & 0x300;
  hasVelocityGraph = (flags & 0x300) != 0;
  if ( (flags & 0x100) != 0 && !v14 || m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
    applyTransform = v15;
  else
    applyTransform = !v15;
  v18 = (flags & 0x200000) != 0;
  m_emitterLife_low = (__m128)LODWORD(pEmitterOwner->m_emitterLife);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  EmitterTransform = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  v23 = pParticleState->m_pModuleInitRelativeVelocity;
  v25 = 0;
  if ( v23 )
  {
    if ( (v23->m_flags & 1) == 0 )
    {
      v24 = v23->m_velocityType;
      if ( v24 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || v24 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
        v25 = 1;
    }
  }
  m_flags = pModuleBase->m_flags;
  noLerp = (m_flags & 0x40) != 0;
  if ( applyTransform && relativeVelocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
  {
    v = EmitterTransform->z.v;
    v29 = _mm_shuffle_ps(v, EmitterTransform->w.v, 68);
    v30 = _mm_shuffle_ps(v, EmitterTransform->w.v, 238);
    v31 = _mm_shuffle_ps(EmitterTransform->x.v, EmitterTransform->y.v, 238);
    v32 = 1;
    v33 = _mm_shuffle_ps(EmitterTransform->x.v, EmitterTransform->y.v, 68);
    *(__m128 *)&v66.m256i_u64[2] = _mm_shuffle_ps(v33, v29, 221);
    *(__m128 *)v66.m256i_i8 = _mm_shuffle_ps(v33, v29, 136);
    *(__m128 *)v67.m256i_i8 = _mm_shuffle_ps(v31, v30, 136);
    *(__m128 *)&v67.m256i_u64[2] = _mm_shuffle_ps(v31, v30, 221);
    *(__m256i *)v68 = v66;
    *(__m256i *)&v68[32] = v67;
  }
  else
  {
    v32 = 0;
  }
  p_v = (__m128 *)v68;
  if ( !v32 )
    p_v = &EmitterTransform->x.v;
  v63 = p_v;
  if ( v18 )
  {
    Particle_UpdateForceRayCast((const ParticleModuleForce *)pModuleBase, pParticleData, particleOffset, v10, dt, EmitterTransform, noLerp, applyTransform, hasVelocityGraph, m_emitterLife_low.m128_f32[0]);
  }
  else if ( v25 )
  {
    Particle_UpdateForceRelativeToEffectOrigin((const ParticleModuleForce *)pModuleBase, pParticleData, particleOffset, v10, pParticleState, dt, EmitterTransform, noLerp, applyTransform, useWorldForce, hasVelocityGraph, m_emitterLife_low.m128_f32[0], relativeVelocityType);
  }
  else if ( (m_flags & 0x40) != 0 )
  {
    if ( applyTransform )
    {
      v35 = *(__m128 *)&pModuleBase[2].m_type;
      v36 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v35, v35, 0), *p_v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v35, v35, 85), p_v[1]), _mm128_mul_ps(_mm_shuffle_ps(v35, v35, 170), p_v[2])));
    }
    else
    {
      v36 = *(__m128 *)&pModuleBase[2].m_type;
    }
    if ( v65 )
    {
      if ( (_DWORD)v10 )
      {
        v37 = v10;
        do
        {
          ++VelocityArrayAtIndex;
          v38 = m_emitterLife_low;
          v38.m128_f32[0] = m_emitterLife_low.m128_f32[0] - *SpawnTimeArrayAtIndex++;
          VelocityArrayAtIndex[-1].v = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v38, v38, 0), v36), VelocityArrayAtIndex[-1].v);
          --v37;
        }
        while ( v37 );
      }
    }
    else
    {
      __asm { vbroadcastss xmm0, [rsp+188h+dt] }
      v40 = _mm128_mul_ps(_XMM0, v36);
      if ( (_DWORD)v10 )
      {
        v41 = v10;
        do
        {
          VelocityArrayAtIndex->v = _mm128_add_ps(v40, VelocityArrayAtIndex->v);
          ++VelocityArrayAtIndex;
          --v41;
        }
        while ( v41 );
      }
    }
  }
  else
  {
    v42 = (m_flags & 0x20) != 0;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
    __asm { vbroadcastss xmm5, [rsp+188h+dt] }
    if ( (_DWORD)v10 )
    {
      _R9 = fx_randomTable;
      v46 = (char *)RandomSeedArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      v47 = v10;
      do
      {
        _RAX = *(int *)((char *)SpawnTimeArrayAtIndex + v46);
        v49 = *(__m128 *)&pModuleBase[4].m_type;
        if ( v42 )
        {
          _XMM1 = 0i64;
          __asm
          {
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B0h], 0
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B4h], 10h
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B8h], 20h ; ' '
          }
          v54 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v49, *(__m128 *)&pModuleBase[2].m_type)), *(__m128 *)&pModuleBase[2].m_type);
        }
        else
        {
          v55 = _mm128_sub_ps(v49, *(__m128 *)&pModuleBase[2].m_type);
          __asm { vbroadcastss xmm0, dword ptr [r9+rax*4+0B0h] }
          v54 = _mm128_add_ps(_mm128_mul_ps(v55, _XMM0), *(__m128 *)&pModuleBase[2].m_type);
        }
        if ( v65 )
        {
          v57 = m_emitterLife_low;
          v57.m128_f32[0] = m_emitterLife_low.m128_f32[0] - *SpawnTimeArrayAtIndex;
          _XMM5 = _mm_shuffle_ps(v57, v57, 0);
        }
        if ( applyTransform )
          VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v54, v54, 0), *v63), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v54, v54, 85), v63[1]), _mm128_mul_ps(_mm_shuffle_ps(v54, v54, 170), v63[2]))), _XMM5), VelocityArrayAtIndex->v);
        else
          VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(v54, _XMM5), VelocityArrayAtIndex->v);
        ++SpawnTimeArrayAtIndex;
        ++VelocityArrayAtIndex;
        --v47;
      }
      while ( v47 );
    }
  }
}

/*
==============
ParticleModuleForceDragGraph::Update
==============
*/
void ParticleModuleForceDragGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  int *RandomSeedArrayAtIndex; 
  const float *LifeArrayAtIndex; 
  float4 *VelocityArrayAtIndex; 
  float m_emitterLifeNormalized; 
  float4 *v15; 
  const ParticleCurveDef *v16; 
  const ParticleCurveDef *v17; 
  signed __int64 v18; 
  float v19; 
  __int64 v20; 
  double v21; 
  float v22; 
  double v23; 
  __m128 v24; 
  const ParticleCurveDef *v25; 
  const ParticleCurveDef *v26; 
  __int64 v27; 
  double CurveValue; 
  float v29; 
  double v30; 
  __m128 v31; 
  __int64 v32; 
  double v33; 
  __m128 v34; 
  __int64 v35; 
  double v36; 
  __m128 v37; 
  __int64 v38; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v38) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v38, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
  v15 = VelocityArrayAtIndex;
  if ( (_DWORD)v7 )
  {
    if ( (pModuleBase->m_flags & 0x10) != 0 )
    {
      if ( (pModuleBase->m_flags & 4) != 0 )
      {
        v25 = (const ParticleCurveDef *)&pModuleBase[4];
        v26 = (const ParticleCurveDef *)&pModuleBase[2];
        do
        {
          v27 = *RandomSeedArrayAtIndex;
          CurveValue = Particle_GetCurveValue(v26, m_emitterLifeNormalized);
          v29 = *(float *)&CurveValue * v26->scale;
          v30 = Particle_GetCurveValue(v25, m_emitterLifeNormalized);
          v31 = (__m128)LODWORD(FLOAT_1_0);
          v31.m128_f32[0] = 1.0 - (float)((float)((float)((float)(1.0 - fx_randomTable[v27 + 15]) * v29) + (float)((float)(*(float *)&v30 * v25->scale) * fx_randomTable[v27 + 15])) * dt);
          I_fclamp(v31.m128_f32[0], 0.0, 1.0);
          ++v15;
          ++RandomSeedArrayAtIndex;
          v15[-1].v = _mm128_mul_ps(_mm_shuffle_ps(v31, v31, 0), v15[-1].v);
          --v7;
        }
        while ( v7 );
      }
      else
      {
        v16 = (const ParticleCurveDef *)&pModuleBase[4];
        v17 = (const ParticleCurveDef *)&pModuleBase[2];
        v18 = (char *)LifeArrayAtIndex - (char *)RandomSeedArrayAtIndex;
        do
        {
          v19 = *(float *)((char *)RandomSeedArrayAtIndex + v18);
          v20 = *RandomSeedArrayAtIndex;
          v21 = Particle_GetCurveValue(v17, v19);
          v22 = *(float *)&v21 * v17->scale;
          v23 = Particle_GetCurveValue(v16, v19);
          v24 = (__m128)LODWORD(FLOAT_1_0);
          v24.m128_f32[0] = 1.0 - (float)((float)((float)((float)(1.0 - fx_randomTable[v20 + 15]) * v22) + (float)((float)(*(float *)&v23 * v16->scale) * fx_randomTable[v20 + 15])) * dt);
          I_fclamp(v24.m128_f32[0], 0.0, 1.0);
          ++v15;
          ++RandomSeedArrayAtIndex;
          v15[-1].v = _mm128_mul_ps(_mm_shuffle_ps(v24, v24, 0), v15[-1].v);
          --v7;
        }
        while ( v7 );
      }
    }
    else if ( (pModuleBase->m_flags & 4) != 0 )
    {
      v35 = v7;
      do
      {
        v36 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized);
        v37 = (__m128)LODWORD(FLOAT_1_0);
        v37.m128_f32[0] = 1.0 - (float)((float)(*(float *)&v36 * *(float *)&pModuleBase[3].m_flags) * dt);
        I_fclamp(v37.m128_f32[0], 0.0, 1.0);
        ++v15;
        v15[-1].v = _mm128_mul_ps(_mm_shuffle_ps(v37, v37, 0), v15[-1].v);
        --v35;
      }
      while ( v35 );
    }
    else
    {
      v32 = v7;
      do
      {
        v33 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *LifeArrayAtIndex);
        v34 = (__m128)LODWORD(FLOAT_1_0);
        v34.m128_f32[0] = 1.0 - (float)((float)(*(float *)&v33 * *(float *)&pModuleBase[3].m_flags) * dt);
        I_fclamp(v34.m128_f32[0], 0.0, 1.0);
        ++v15;
        ++LifeArrayAtIndex;
        v15[-1].v = _mm128_mul_ps(_mm_shuffle_ps(v34, v34, 0), v15[-1].v);
        --v32;
      }
      while ( v32 );
    }
  }
}

/*
==============
ParticleModuleGravity::Update
==============
*/
void ParticleModuleGravity::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleIntensityGraph::Update
==============
*/
void ParticleModuleIntensityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_INTENSITY)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_INTENSITY, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_INTENSITY, floatArray);
}

/*
==============
ParticleModuleParentVelocityGraph::Update
==============
*/
void ParticleModuleParentVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v9; 
  __int64 v10; 
  float4 *VelocityArrayAtIndex; 
  unsigned __int8 *v12; 
  float *floatArray; 
  signed __int64 v14; 
  __int64 v15; 
  const ParticleModuleInitAttributes *m_pModuleInitAttributes; 
  signed __int64 v18; 
  __int64 v19; 
  __m128 v24; 
  signed __int64 v26; 
  __int64 v27; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve2; 

  v9 = particleCount;
  v10 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (int)v9 + (int)v10 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v9 + v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1220, ASSERT_TYPE_ASSERT, "(pModuleBase->HasFlag( PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "pModuleBase->HasFlag( PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  if ( pParticleState->m_pStateDef->elementType != 10 )
  {
    VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v10);
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v10 >= pParticleData->m_particleCountMax )
    {
      LODWORD(rCurve2) = pParticleData->m_particleCountMax;
      LODWORD(rCurve1) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    v12 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_PARENT_VELOCITY)[16 * v10];
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v10 >= pParticleData->m_particleCountMax )
    {
      LODWORD(rCurve2) = pParticleData->m_particleCountMax;
      LODWORD(rCurve1) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_INHERIT_PERCENTAGE)[4 * v10];
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v10, v9, pEmitterOwner, (const ParticleCurveDef *)&pModuleBase[2], (const ParticleCurveDef *)&pModuleBase[4], FXRAND_EMISSIVE, floatArray);
    if ( (pParticleState->m_pStateDef->flags & 0x300) != 0 )
    {
      if ( (_DWORD)v9 )
      {
        v14 = v12 - (unsigned __int8 *)VelocityArrayAtIndex;
        v15 = v9;
        do
        {
          ++VelocityArrayAtIndex;
          __asm { vbroadcastss xmm0, dword ptr [rdi] }
          ++floatArray;
          VelocityArrayAtIndex[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, *(__m128 *)((char *)&VelocityArrayAtIndex[-1].v + v14)), VelocityArrayAtIndex[-1].v);
          --v15;
        }
        while ( v15 );
      }
    }
    else
    {
      Particle_GetRandomSeedArrayAtIndex(pParticleData, v10);
      m_pModuleInitAttributes = pParticleState->m_pModuleInitAttributes;
      if ( (_DWORD)v9 )
      {
        if ( m_pModuleInitAttributes )
        {
          v18 = v12 - (unsigned __int8 *)VelocityArrayAtIndex;
          v19 = v9;
          do
          {
            ++VelocityArrayAtIndex;
            ++floatArray;
            _XMM1 = 0i64;
            __asm
            {
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4], 0
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4+4], 10h
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4+8], 20h ; ' '
            }
            v24 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(m_pModuleInitAttributes->m_velocityMax.v, m_pModuleInitAttributes->m_velocityMin.v)), m_pModuleInitAttributes->m_velocityMin.v);
            VelocityArrayAtIndex[-1] = (float4)v24;
            __asm { vbroadcastss xmm0, dword ptr [rdi-4] }
            VelocityArrayAtIndex[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, *(__m128 *)((char *)&VelocityArrayAtIndex[-1].v + v18)), v24);
            --v19;
          }
          while ( v19 );
        }
        else
        {
          v26 = v12 - (unsigned __int8 *)VelocityArrayAtIndex;
          v27 = v9;
          do
          {
            ++VelocityArrayAtIndex;
            __asm { vbroadcastss xmm0, dword ptr [rdi] }
            ++floatArray;
            VelocityArrayAtIndex[-1].v = _mm128_mul_ps(_XMM0, *(__m128 *)((char *)&VelocityArrayAtIndex[-1].v + v26));
            --v27;
          }
          while ( v27 );
        }
      }
    }
  }
}

/*
==============
ParticleModulePhysicsLight::Update
==============
*/
void ParticleModulePhysicsLight::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v10; 
  unsigned int *FlagsArrayAtIndex; 
  char *v12; 
  int *PhysicsFXParticleIDList; 
  HavokPhysicsFX_Pipeline *m_physicsFXPipelineInstance; 
  Physics_WorldId m_physicsWorldId; 
  ParticleSystem *SystemOwner; 
  const ParticleSystemDef *Def; 
  unsigned int v18; 
  unsigned __int64 v19; 
  unsigned int v20; 
  float4 *v21; 
  __int64 v22; 
  ParticleSystem *v23; 
  const ParticleSystemDef *v24; 
  ParticleSystem *v25; 
  const ParticleSystemDef *v26; 
  ParticleSystem *v27; 
  const ParticleSystemDef *v28; 
  _OWORD *v29; 
  bool v30; 
  __m128 v; 
  __m128 v36; 
  const float4 *v37; 
  __int64 v38; 
  bool impact; 
  Physics_WorldId worldId; 
  int *v41; 
  unsigned int v42; 
  float4 *VelocityArrayAtIndex; 
  float4 *PositionArrayAtIndex; 
  float4 *RotationAngleArrayAtIndex; 
  Particle_OnImpactData *v46; 
  unsigned __int64 v47; 
  const ParticleModulePhysicsLight *m_pModulePhysicsLight; 
  vector3 *rotMatrix; 
  float4 v50; 
  float4 v51; 
  float4 v52; 
  float4 v53; 
  float4 v54; 
  float4 v55; 
  __int128 v56; 
  vec4_t orientation; 
  vec4_t quat; 
  Particle_OnImpactData data; 

  v42 = particleCount;
  v10 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + (unsigned int)v10 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v38) = particleCount + v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v38, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !particle_enable_physics_light->current.enabled )
    R_WarnOncePerFrame(R_WARN_VFX_PHYSICS_DISABLED, "(ParticleModulePhysicsLight::Update)");
  if ( (pParticleState->m_pStateDef->flags & 0x400) != 0 )
  {
    PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v10);
    VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v10);
    RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, v10);
    FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v10);
    m_pModulePhysicsLight = pParticleState->m_pModulePhysicsLight;
    v12 = (char *)FlagsArrayAtIndex;
    rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    if ( m_pModulePhysicsLight )
    {
      if ( !pParticleState->m_physicsFXParticleIDList )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 555, ASSERT_TYPE_ASSERT, "(m_physicsFXParticleIDList)", (const char *)&queryFormat, "m_physicsFXParticleIDList") )
          __debugbreak();
        if ( !pParticleState->m_physicsFXParticleIDList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1457, ASSERT_TYPE_ASSERT, "(pParticleState->GetPhysicsFXParticleIDList())", (const char *)&queryFormat, "pParticleState->GetPhysicsFXParticleIDList()") )
          __debugbreak();
      }
      PhysicsFXParticleIDList = ParticleState::GetPhysicsFXParticleIDList((ParticleState *)pParticleState);
      m_physicsFXPipelineInstance = pParticleState->m_physicsFXPipelineInstance;
      v41 = &PhysicsFXParticleIDList[v10];
      m_physicsWorldId = pParticleState->m_physicsWorldId;
      worldId = m_physicsWorldId;
      if ( !m_physicsFXPipelineInstance )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1461, ASSERT_TYPE_ASSERT, "(physicsFXPipeline)", (const char *)&queryFormat, "physicsFXPipeline") )
          __debugbreak();
        m_physicsWorldId = worldId;
      }
      v55.v = 0i64;
      v56 = 0i64;
      if ( particleCount )
      {
        if ( !PhysicsFX_HasPipeline(m_physicsWorldId, m_physicsFXPipelineInstance) )
        {
          SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
          Def = ParticleSystem::GetDef(SystemOwner);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1472, ASSERT_TYPE_ASSERT, "(particleCount == 0 || PhysicsFX_HasPipeline( physicsWorldID, physicsFXPipeline ))", "%s\n\tERROR: The effect %s somehow managed to get its pipeline deleted\n", "particleCount == 0 || PhysicsFX_HasPipeline( physicsWorldID, physicsFXPipeline )", Def->name) )
            __debugbreak();
        }
      }
      pEmitterOwner->m_numPhysicsFX += particleCount;
      v18 = 0;
      v19 = (unsigned __int64)LODWORD(pParticleState->m_pStateDef->flags) >> 16;
      LOBYTE(v19) = HIWORD(LODWORD(pParticleState->m_pStateDef->flags)) & 1;
      v47 = v19;
      if ( (_BYTE)v19 )
      {
        if ( !pParticleState->m_onImpactDataList )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 455, ASSERT_TYPE_ASSERT, "(m_onImpactDataList)", (const char *)&queryFormat, "m_onImpactDataList") )
            __debugbreak();
          if ( !pParticleState->m_onImpactDataList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1479, ASSERT_TYPE_ASSERT, "(!handleImpacts || pParticleState->GetOnImpactDataList())", (const char *)&queryFormat, "!handleImpacts || pParticleState->GetOnImpactDataList()") )
            __debugbreak();
        }
        v46 = &ParticleState::GetOnImpactDataList((ParticleState *)pParticleState)[v10];
        if ( !v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1481, ASSERT_TYPE_ASSERT, "(!handleImpacts || pImpactDataList)", (const char *)&queryFormat, "!handleImpacts || pImpactDataList") )
          __debugbreak();
      }
      else
      {
        v46 = NULL;
      }
      v20 = v42;
      if ( v42 )
      {
        PositionArrayAtIndex = (float4 *)((char *)PositionArrayAtIndex - (__int64)VelocityArrayAtIndex);
        v21 = RotationAngleArrayAtIndex;
        VelocityArrayAtIndex = (float4 *)((char *)VelocityArrayAtIndex - (__int64)RotationAngleArrayAtIndex);
        v22 = (char *)v41 - v12;
        v41 = (int *)((char *)v41 - v12);
        do
        {
          if ( (*v12 & 2) == 0 )
          {
            PhysicsFX_GetParticlePosition(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v12[v22], (vec3_t *)&v55);
            PhysicsFX_GetParticleLinearVelocity(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v12[(_QWORD)v41], (vec3_t *)&v56);
            PhysicsFX_GetParticleOrientation(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v12[(_QWORD)v41], &orientation);
            if ( (v55.v.m128_i32[0] & 0x7F800000) == 2139095040 || (v55.v.m128_i32[1] & 0x7F800000) == 2139095040 || (v55.v.m128_i32[2] & 0x7F800000) == 2139095040 )
            {
              v23 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v24 = ParticleSystem::GetDef(v23);
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1516, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( position )[0] ) && !IS_NAN( ( position )[1] ) && !IS_NAN( ( position )[2] ) ) )", "VFX ERROR: NAN in position coming from HavokFX: %s\n", v24->name) )
                __debugbreak();
            }
            if ( (v56 & 0x7F800000) == 2139095040 || (DWORD1(v56) & 0x7F800000) == 2139095040 || (DWORD2(v56) & 0x7F800000) == 2139095040 )
            {
              v25 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v26 = ParticleSystem::GetDef(v25);
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1517, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] ) ) )", "VFX ERROR: NAN in velocity coming from HavokFX: %s\n", v26->name) )
                __debugbreak();
            }
            if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)((float)(orientation.v[0] * orientation.v[0]) + (float)(orientation.v[1] * orientation.v[1])) + (float)(orientation.v[2] * orientation.v[2])) + (float)(orientation.v[3] * orientation.v[3])) - 1.0) & _xmm) >= 0.0020000001 )
            {
              v27 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v28 = ParticleSystem::GetDef(v27);
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1518, ASSERT_TYPE_ASSERT, "(Vec4IsNormalized( orientation ))", "%s\n\tVFX ERROR: Unnormalized quat coming from HavokFX: %s\n", "Vec4IsNormalized( orientation )", v28->name) )
                __debugbreak();
            }
            v29 = (_OWORD *)((char *)VelocityArrayAtIndex->v.m128_f32 + (_QWORD)v21);
            v30 = (_BYTE)v47 == 0;
            *(float4 *)((char *)PositionArrayAtIndex + (_QWORD)v29) = (float4)v55.v;
            *v29 = v56;
            *v21 = (float4)orientation;
            if ( !v30 )
            {
              PhysicsFX_GetParticleImpactAndClear(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v12[(_QWORD)v41], &impact, &data);
              if ( impact )
              {
                v = data.incomingVelocity.v;
                _XMM0 = _mm128_mul_ps(v, v);
                __asm
                {
                  vinsertps xmm1, xmm0, xmm0, 8
                  vhaddps xmm2, xmm1, xmm1
                  vhaddps xmm0, xmm2, xmm2
                }
                if ( *(float *)&_XMM0 > 0.00000011920929 )
                {
                  if ( m_pModulePhysicsLight->m_ignoreEmitterOrientation )
                  {
                    Particle_RotMatrixToQuatVec(rotMatrix, &quat);
                    Float4QuatMultiply(RotationAngleArrayAtIndex, v37, &v50);
                    v = data.incomingVelocity.v;
                    v36 = v50.v;
                  }
                  else
                  {
                    v36 = v21->v;
                    v50.v = v21->v;
                  }
                  v51.v = v36;
                  v52.v = v;
                  v53.v = (__m128)data.normal;
                  v54.v = (__m128)data.pos;
                  ParticleState::FillImpactData((ParticleState *)pParticleState, &v46[v18], &v54, &v53, &v52, data.surfaceFlags, data.entNum, data.hitType, data.partName, &v51, pEmitterOwner);
                  *(_DWORD *)v12 |= 4u;
                  v20 = v42;
                }
              }
            }
            *(_DWORD *)v12 &= ~0x40u;
            v22 = (__int64)v41;
          }
          ++v18;
          ++v21;
          v12 += 4;
        }
        while ( v18 < v20 );
      }
    }
  }
}

/*
==============
ParticleModulePhysicsRayCast::Update
==============
*/
void ParticleModulePhysicsRayCast::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ParticleEmitter *v7; 
  __int64 v10; 
  __int64 m_localClientNum; 
  unsigned int *FlagsArrayAtIndex; 
  int *RandomSeedArrayAtIndex; 
  bool v15; 
  int integer; 
  bool v17; 
  unsigned __int64 v18; 
  int v19; 
  int v20; 
  int v21; 
  int v22; 
  int v23; 
  int v24; 
  int v25; 
  int v26; 
  char m_type; 
  int v28; 
  int v29; 
  char v30; 
  int v32; 
  const ParticleStateDef *m_pStateDef; 
  unsigned __int64 v34; 
  char v35; 
  __m128 *p_v; 
  unsigned int v37; 
  signed __int64 v38; 
  const ParticleSystem *SystemOwner; 
  __int64 v40; 
  vector4 *p_m_cameraTransformPosOnly; 
  __int64 v42; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  __m128 v44; 
  __int64 v47; 
  char *v48; 
  float v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  int v53; 
  const ParticleModule *v54; 
  float v55; 
  __m128 v57; 
  float v64; 
  __m128 v66; 
  float4 *RotationAngleArrayAtIndex; 
  __m128 v70; 
  const float4 *v71; 
  const float4 *v72; 
  const float4 *v73; 
  float v74; 
  __m128 v75; 
  __m128 v80; 
  int v87; 
  __int64 v88; 
  __int64 v89; 
  int v90; 
  __int64 v91; 
  __int64 v92; 
  unsigned int v93; 
  TraceHitType v94; 
  scr_string_t v95; 
  bool v96; 
  unsigned __int8 *v98; 
  signed __int64 v99; 
  float4 *PositionArrayAtIndex; 
  signed __int64 v101; 
  float4 v102; 
  unsigned int particleIndex; 
  int brushMask; 
  int *v105; 
  const ParticleModule *v106; 
  float4 *VelocityArrayAtIndex; 
  Particle_OnImpactData *v108; 
  __int64 v109; 
  unsigned __int64 v110; 
  ParticleData *pParticleDataa; 
  vector3 *rotMatrix; 
  float4 v113; 
  float4 v114; 
  float4 v115; 
  vec3_t end; 
  vec3_t start; 
  __m128 v118; 
  __m128 v119; 
  vec4_t quat; 

  v7 = (ParticleEmitter *)pEmitterOwner;
  v10 = particleOffset;
  particleIndex = particleOffset;
  pParticleDataa = pParticleData;
  v106 = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + (unsigned int)v10 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v88) = particleCount + v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v88, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_localClientNum = pEmitterOwner->m_pSystemOwner->m_localClientNum;
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v10);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v10);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v10);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v10);
  v15 = pParticleData->m_pParticleData == NULL;
  v105 = RandomSeedArrayAtIndex;
  if ( v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v10 >= pParticleData->m_particleCountMax )
  {
    LODWORD(v91) = pParticleData->m_particleCountMax;
    LODWORD(v88) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v88, v91) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v98 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_RAY_CAST_HANDLE)[4 * v10];
  rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  pEmitterOwner->m_numRayCasts += particleCount;
  integer = particle_override_raycast_contents_mask_solid->current.integer;
  v17 = 1;
  if ( integer )
    v17 = integer == 1;
  LODWORD(v18) = 0;
  v19 = v17 ? 0x811 : 0;
  v102.v.m128_u64[0] = 0i64;
  v20 = particle_override_raycast_contents_vehicle->current.integer;
  v21 = 1;
  if ( v20 )
    v21 = v20 == 1;
  v22 = (v21 << 23) | v19;
  v23 = particle_override_raycast_contents_item->current.integer;
  v24 = *((_BYTE *)&pModuleBase[5].m_type + 3) == 0;
  if ( v23 )
    v24 = v23 == 1;
  v25 = (v24 << 8) | v22;
  v26 = particle_override_raycast_contents_item_clip->current.integer;
  m_type = pModuleBase[5].m_type;
  if ( v26 )
    m_type = v26 == 1;
  v28 = (m_type != 0 ? 0x400 : 0) | v25;
  v29 = particle_override_raycast_contents_water->current.integer;
  v30 = *((_BYTE *)&pModuleBase[5].m_type + 2);
  if ( v29 )
    v30 = v29 == 1;
  __asm { vbroadcastss xmm9, [rbp+120h+dt] }
  v32 = (v30 != 0 ? 0x20 : 0) | v28;
  m_pStateDef = pParticleState->m_pStateDef;
  brushMask = v32;
  v34 = (unsigned __int64)LODWORD(m_pStateDef->flags) >> 16;
  LOBYTE(v34) = v34 & 1;
  v110 = v34;
  if ( (_BYTE)v34 )
  {
    if ( !pParticleState->m_onImpactDataList )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 455, ASSERT_TYPE_ASSERT, "(m_onImpactDataList)", (const char *)&queryFormat, "m_onImpactDataList") )
        __debugbreak();
      if ( !pParticleState->m_onImpactDataList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1620, ASSERT_TYPE_ASSERT, "(!handleImpacts || pParticleState->GetOnImpactDataList())", (const char *)&queryFormat, "!handleImpacts || pParticleState->GetOnImpactDataList()") )
        __debugbreak();
    }
    v108 = &ParticleState::GetOnImpactDataList((ParticleState *)pParticleState)[v10];
    if ( !v108 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1622, ASSERT_TYPE_ASSERT, "(!handleImpacts || pImpactDataList)", (const char *)&queryFormat, "!handleImpacts || pImpactDataList") )
      __debugbreak();
  }
  else
  {
    v108 = NULL;
  }
  if ( (unsigned int)m_localClientNum >= 2 )
  {
    LODWORD(v91) = 2;
    LODWORD(v88) = m_localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 623, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v88, v91) )
      __debugbreak();
    LODWORD(v92) = 2;
    LODWORD(v89) = m_localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 609, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v89, v92) )
      __debugbreak();
  }
  v35 = g_particleDeferredPhysicsRayCastIndex[m_localClientNum] - 1;
  v109 = 2 * m_localClientNum;
  v96 = g_particleDeferredPhysicsRayCastResultValid[m_localClientNum][v35 & 1];
  if ( particleCount )
  {
    v101 = (char *)PositionArrayAtIndex - (char *)VelocityArrayAtIndex;
    p_v = &VelocityArrayAtIndex->v;
    v105 = (int *)((char *)v105 - (__int64)FlagsArrayAtIndex);
    v37 = particleCount;
    v38 = v98 - (unsigned __int8 *)FlagsArrayAtIndex;
    v99 = v98 - (unsigned __int8 *)FlagsArrayAtIndex;
    while ( (*(_BYTE *)FlagsArrayAtIndex & 0x10) != 0 )
    {
LABEL_111:
      v18 = (unsigned int)(v18 + 1);
      ++p_v;
      v102.v.m128_u64[0] = v18;
      ++FlagsArrayAtIndex;
      if ( (unsigned int)v18 >= v37 )
        return;
    }
    if ( (pParticleState->m_pStateDef->flags & 2) != 0 || (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
    {
      v40 = v7->m_pSystemOwner->m_localClientNum;
      if ( (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
      {
        if ( (unsigned int)v40 >= 2 )
        {
          LODWORD(v91) = 2;
          LODWORD(v88) = v7->m_pSystemOwner->m_localClientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v88, v91) )
            __debugbreak();
        }
        p_m_cameraTransformPosOnly = &g_particleManager[0].m_cameraTransformPosOnly;
      }
      else
      {
        if ( (unsigned int)v40 >= 2 )
        {
          LODWORD(v91) = 2;
          LODWORD(v88) = v7->m_pSystemOwner->m_localClientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v88, v91) )
            __debugbreak();
        }
        p_m_cameraTransformPosOnly = &g_particleManager[0].m_cameraTransform;
      }
      v42 = 4916 * v40;
      v38 = v99;
      SystemOwner = (const ParticleSystem *)&p_m_cameraTransformPosOnly[v42];
    }
    else
    {
      SystemOwner = ParticleEmitter::GetSystemOwner(v7);
    }
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 || ((m_pModuleInitRelativeVelocity->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
    {
      _XMM6 = *(__m128 *)((char *)p_v + v101);
    }
    else
    {
      v44 = *(__m128 *)((char *)p_v + v101);
      _XMM6 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v44, v44, 0), SystemOwner->m_systemTransform.x.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v44, v44, 85), SystemOwner->m_systemTransform.y.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v44, v44, 170), SystemOwner->m_systemTransform.z.v), SystemOwner->m_systemTransform.w.v)));
    }
    if ( (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
      _XMM6 = _mm128_add_ps(_XMM6, ParticleEmitter::GetSystemOwner(v7)->m_systemTransform.w.v);
    v15 = (*(_BYTE *)FlagsArrayAtIndex & 0x20) == 0;
    _XMM1 = _mm128_add_ps(_mm128_mul_ps(_XMM9, *p_v), _XMM6);
    end.v[0] = _XMM1.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbp+120h+end+4], xmm1, 1
      vextractps dword ptr [rbp+120h+end+8], xmm1, 2
    }
    start.v[0] = _XMM6.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbp+120h+start+4], xmm6, 1
      vextractps dword ptr [rbp+120h+start+8], xmm6, 2
    }
    if ( v15 )
      goto LABEL_109;
    v47 = *(unsigned int *)((char *)FlagsArrayAtIndex + v38);
    if ( (_DWORD)v47 != 2048 && v96 )
    {
      if ( (unsigned int)m_localClientNum >= 2 )
      {
        LODWORD(v91) = 2;
        LODWORD(v88) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 631, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v88, v91) )
          __debugbreak();
      }
      if ( (unsigned int)v47 >= 0x800 )
      {
        LODWORD(v91) = 2048;
        LODWORD(v88) = v47;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 632, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( PARTICLE_DEFERRED_PHYSICS_RAY_CAST_LIST_MAX )", "index doesn't index PARTICLE_DEFERRED_PHYSICS_RAY_CAST_LIST_MAX\n\t%i not in [0, %i)", v88, v91) )
          __debugbreak();
      }
      if ( (unsigned int)m_localClientNum >= 2 )
      {
        LODWORD(v91) = 2;
        LODWORD(v88) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 609, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v88, v91) )
          __debugbreak();
      }
      v48 = (char *)g_particleDeferredPhysicsRayCastCreateList + 294912 * (v109 + (((unsigned __int8)g_particleDeferredPhysicsRayCastIndex[m_localClientNum] - 1) & 1)) + 144 * v47;
      v49 = *(float *)v48;
      if ( *(float *)v48 < 1.0 )
      {
        if ( *((_DWORD *)v48 + 9) == 1 )
        {
          v50 = *((int *)v48 + 11);
          if ( (unsigned int)v50 >= 0x7FE || (v106->m_flags & 0x20000) != 0 || !particle_raycast_ignore_wztrain_killswitch->current.enabled )
          {
            v7 = (ParticleEmitter *)pEmitterOwner;
          }
          else
          {
            if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
            {
              LODWORD(v91) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", v91) )
                __debugbreak();
            }
            if ( (unsigned int)m_localClientNum >= CgEntitySystem::ms_allocatedCount )
            {
              LODWORD(v91) = CgEntitySystem::ms_allocatedCount;
              LODWORD(v88) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v88, v91) )
                __debugbreak();
            }
            if ( !CgEntitySystem::ms_entitySystemArray[m_localClientNum] )
            {
              LODWORD(v91) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v91) )
                __debugbreak();
            }
            v18 = (unsigned __int64)CgEntitySystem::ms_entitySystemArray[m_localClientNum];
            if ( (unsigned int)v50 >= 0x800 )
            {
              LODWORD(v91) = 2048;
              LODWORD(v88) = v50;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v88, v91) )
                __debugbreak();
            }
            v51 = 760 * v50;
            v7 = (ParticleEmitter *)pEmitterOwner;
            v52 = v51 + v18 + 16;
            LODWORD(v18) = v102.v.m128_i32[0];
            if ( v52 && (*(_BYTE *)(v52 + 524) & 0x20) != 0 )
              goto LABEL_108;
          }
        }
        v55 = *((float *)v48 + 4);
        v118.m128_i32[3] = 0;
        v57 = v118;
        v57.m128_f32[0] = v55;
        _XMM8 = v57;
        __asm
        {
          vinsertps xmm8, xmm8, dword ptr [rbx+14h], 10h
          vinsertps xmm8, xmm8, dword ptr [rbx+18h], 20h ; ' '
        }
        *FlagsArrayAtIndex |= 8u;
        _XMM1 = _mm128_mul_ps(*p_v, *p_v);
        __asm
        {
          vinsertps xmm2, xmm1, xmm1, 8
          vhaddps xmm0, xmm2, xmm2
          vhaddps xmm1, xmm0, xmm0
        }
        v118 = _XMM8;
        if ( (_BYTE)v110 && *(float *)&_XMM1 > 0.00000011920929 )
        {
          v64 = (float)((float)(*((float *)v48 + 25) - *((float *)v48 + 22)) * v49) + *((float *)v48 + 22);
          v119.m128_i32[3] = 0;
          v66 = v119;
          v66.m128_f32[0] = v64;
          _XMM7 = v66;
          __asm
          {
            vinsertps xmm7, xmm7, xmm5, 10h
            vinsertps xmm7, xmm7, xmm4, 20h ; ' '
          }
          v119 = _XMM7;
          RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleDataa, particleIndex);
          v70 = *(__m128 *)((char *)&RotationAngleArrayAtIndex->v + (char *)p_v - (char *)VelocityArrayAtIndex);
          Float4RadianToQuat((float4 *)((char *)p_v - (char *)VelocityArrayAtIndex), v71);
          v102.v = v70;
          Particle_RotMatrixToQuatVec(rotMatrix, &quat);
          Float4QuatMultiply(v73, v72, &v102);
          v113.v = *p_v;
          v95 = *((_DWORD *)v48 + 14);
          v94 = *((_DWORD *)v48 + 9);
          v93 = *((_DWORD *)v48 + 11);
          v90 = *((_DWORD *)v48 + 7);
          v114.v = _XMM8;
          v115.v = _XMM7;
          ParticleState::FillImpactData((ParticleState *)pParticleState, &v108[(unsigned int)v18], &v115, &v114, &v113, v90, v93, v94, v95, &v102, v7);
          *FlagsArrayAtIndex |= 4u;
        }
        v74 = fx_randomTable[*(int *)((char *)FlagsArrayAtIndex + (_QWORD)v105) + 17];
        v75 = (__m128)LODWORD(FLOAT_1_0);
        v75.m128_f32[0] = (float)((float)(1.0 - v74) * *(float *)&v106[1].m_type) + (float)(v74 * *(float *)&v106[1].m_flags);
        _XMM0 = _mm128_mul_ps(_XMM8, *p_v);
        __asm
        {
          vinsertps xmm2, xmm0, xmm0, 8
          vhaddps xmm1, xmm2, xmm2
          vhaddps xmm3, xmm1, xmm1
        }
        v80 = _mm128_add_ps(_mm128_mul_ps(_XMM8, _mm128_mul_ps(_XMM3, (__m128)_xmm_c0000000c0000000c0000000c0000000)), *p_v);
        _XMM1 = _mm128_mul_ps(v80, v80);
        __asm
        {
          vhaddps xmm0, xmm1, xmm1
          vhaddps xmm2, xmm0, xmm0
        }
        if ( v75.m128_f32[0] <= 0.0 )
          goto LABEL_120;
        _XMM0 = VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_1442.v;
        __asm
        {
          vcmpltps xmm1, xmm0, xmm2
          vmovmskps eax, xmm1
        }
        if ( (_EAX & 0xF) == 15 )
        {
          *p_v = _mm128_mul_ps(_mm_shuffle_ps(v75, v75, 0), v80);
          v87 = *FlagsArrayAtIndex;
        }
        else
        {
LABEL_120:
          *p_v = 0i64;
          v87 = *FlagsArrayAtIndex | 0x10;
        }
        v38 = v99;
        *FlagsArrayAtIndex = v87 & 0xFFFFFFDF;
        *(unsigned int *)((char *)FlagsArrayAtIndex + v99) = 2048;
        goto LABEL_110;
      }
    }
LABEL_108:
    v38 = v99;
LABEL_109:
    v53 = brushMask;
    v54 = v106;
    *FlagsArrayAtIndex |= 0x20u;
    *(unsigned int *)((char *)FlagsArrayAtIndex + v38) = Particle_AddDeferredPhysicsRayCastCreate((LocalClientNum_t)m_localClientNum, &start, &end, (const Bounds *)&v54[2], v53);
LABEL_110:
    v37 = particleCount;
    goto LABEL_111;
  }
}

/*
==============
ParticleModulePositionGraph::Update
==============
*/
void ParticleModulePositionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  unsigned int m_flags; 
  bool useLength; 
  bool v13; 
  float4 *PositionArrayAtIndex; 
  float *LifeArrayAtIndex; 
  bool v16; 
  __m128 v25; 
  __m128 v26; 
  float lengthFraction; 
  __m128 v32; 
  __m128 v37; 
  unsigned int v38; 
  unsigned __int64 v39; 
  __int64 v40; 
  float v41; 
  __m128 v; 
  __int64 v55; 
  __m128 v56; 
  unsigned __int64 v57; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v55) = particleCount + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v55, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = pModuleBase->m_flags;
  useLength = pParticleState->m_moduleGraphLengthData.useLength;
  v13 = (m_flags & 0x10) != 0;
  if ( useLength && (m_flags & 0x300) != 768 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1756, ASSERT_TYPE_ASSERT, "(!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, particleOffset);
  v56.m128_u64[0] = (unsigned __int64)Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  v16 = (pModuleBase->m_flags & 4) == 0 && !useLength;
  _XMM11 = 0i64;
  __asm
  {
    vinsertps xmm11, xmm11, dword ptr [rdi+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rdi+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rdi+3Ch], 20h ; ' '
  }
  if ( v13 )
  {
    _XMM10 = 0i64;
    __asm
    {
      vinsertps xmm10, xmm10, dword ptr [rdi+4Ch], 0
      vinsertps xmm10, xmm10, dword ptr [rdi+5Ch], 10h
      vinsertps xmm10, xmm10, dword ptr [rdi+6Ch], 20h ; ' '
    }
  }
  else
  {
    _XMM10 = v56;
  }
  v25 = (__m128)LODWORD(FLOAT_1_0);
  v25.m128_f32[0] = 1.0 / dt;
  v26 = _mm_shuffle_ps(v25, v25, 0);
  if ( v16 )
  {
    v32 = v56;
  }
  else
  {
    if ( useLength )
    {
      lengthFraction = pParticleState->m_moduleGraphLengthData.lengthFraction;
      PositionArrayAtIndex = &pParticleState->m_moduleGraphLengthData.position;
    }
    else
    {
      lengthFraction = pEmitterOwner->m_emitterLifeNormalized;
    }
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], lengthFraction);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], lengthFraction);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], lengthFraction);
    _XMM2 = 0i64;
    __asm
    {
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
    }
    v32 = _mm128_mul_ps(_XMM11, _XMM2);
    if ( v13 )
    {
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], lengthFraction);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], lengthFraction);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], lengthFraction);
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
      }
      v37 = _mm128_mul_ps(_XMM10, _XMM1);
      goto LABEL_38;
    }
  }
  v37 = v56;
LABEL_38:
  v38 = 1;
  if ( !useLength )
    v38 = particleCount;
  if ( v38 )
  {
    v39 = v56.m128_u64[0] - (_QWORD)PositionArrayAtIndex;
    v57 = v56.m128_u64[0] - (_QWORD)PositionArrayAtIndex;
    v40 = v38;
    do
    {
      if ( v16 )
      {
        v41 = *LifeArrayAtIndex;
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *LifeArrayAtIndex);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], v41);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], v41);
        _XMM2 = 0i64;
        __asm
        {
          vinsertps xmm2, xmm2, xmm0, 0
          vinsertps xmm2, xmm2, xmm6, 10h
          vinsertps xmm2, xmm2, xmm7, 20h ; ' '
        }
        v32 = _mm128_mul_ps(_XMM11, _XMM2);
        if ( v13 )
        {
          Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], v41);
          Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], v41);
          Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], v41);
          _XMM1 = 0i64;
          __asm
          {
            vinsertps xmm1, xmm1, xmm0, 0
            vinsertps xmm1, xmm1, xmm6, 10h
            vinsertps xmm1, xmm1, xmm7, 20h ; ' '
          }
          v37 = _mm128_mul_ps(_XMM10, _XMM1);
        }
        v39 = v57;
      }
      v = PositionArrayAtIndex->v;
      if ( v13 )
      {
        _XMM1 = 0i64;
        __asm
        {
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+18h], 0
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+1Ch], 10h
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+20h], 20h ; ' '
        }
        PositionArrayAtIndex->v = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v37, v32)), v32);
      }
      else
      {
        *PositionArrayAtIndex = (float4)v32;
      }
      *(__m128 *)((char *)&PositionArrayAtIndex->v + v39) = _mm128_mul_ps(_mm128_sub_ps(PositionArrayAtIndex->v, v), v26);
      ++PositionArrayAtIndex;
      ++LifeArrayAtIndex;
      --v40;
    }
    while ( v40 );
  }
}

/*
==============
ParticleModuleRotationGraph3D::Update
==============
*/
void ParticleModuleRotationGraph3D::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  bool v11; 
  float4 *RotationRateArrayAtIndex; 
  __m128 *p_v; 
  float *LifeArrayAtIndex; 
  float m_emitterLifeNormalized; 
  __m128 v28; 
  __m128 v33; 
  __int64 i; 
  float v35; 
  __m128 v48; 
  __int64 v49; 
  __m128 v50; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v49) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v49, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v11 = (pModuleBase->m_flags & 0x10) != 0;
  Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  if ( LOBYTE(pModuleBase[1].m_type) )
    RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, particleOffset);
  else
    RotationRateArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, particleOffset);
  p_v = &RotationRateArrayAtIndex->v;
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  _XMM11 = 0i64;
  __asm
  {
    vinsertps xmm11, xmm11, dword ptr [rbx+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rbx+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rbx+3Ch], 20h ; ' '
  }
  if ( v11 )
  {
    _XMM9 = 0i64;
    __asm
    {
      vinsertps xmm9, xmm9, dword ptr [rbx+4Ch], 0
      vinsertps xmm9, xmm9, dword ptr [rbx+5Ch], 10h
      vinsertps xmm9, xmm9, dword ptr [rbx+6Ch], 20h ; ' '
    }
  }
  else
  {
    _XMM9 = v50;
  }
  if ( (pModuleBase->m_flags & 4) != 0 )
  {
    m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], m_emitterLifeNormalized);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], m_emitterLifeNormalized);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized);
    _XMM2 = 0i64;
    __asm
    {
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
    }
    v28 = _mm128_mul_ps(_XMM11, _XMM2);
    if ( v11 )
    {
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], m_emitterLifeNormalized);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], m_emitterLifeNormalized);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], m_emitterLifeNormalized);
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
      }
      v33 = _mm128_mul_ps(_XMM9, _XMM1);
      goto LABEL_30;
    }
  }
  else
  {
    v28 = v50;
  }
  v33 = v50;
LABEL_30:
  if ( (_DWORD)v7 )
  {
    for ( i = v7; i; --i )
    {
      if ( (pModuleBase->m_flags & 4) == 0 )
      {
        v35 = *LifeArrayAtIndex;
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *LifeArrayAtIndex);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], v35);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], v35);
        _XMM2 = 0i64;
        __asm
        {
          vinsertps xmm2, xmm2, xmm0, 0
          vinsertps xmm2, xmm2, xmm6, 10h
          vinsertps xmm2, xmm2, xmm7, 20h ; ' '
        }
        v28 = _mm128_mul_ps(_XMM11, _XMM2);
        if ( !v11 )
          goto LABEL_37;
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], v35);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], v35);
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], v35);
        _XMM1 = 0i64;
        __asm
        {
          vinsertps xmm1, xmm1, xmm0, 0
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm7, 20h ; ' '
        }
        v33 = _mm128_mul_ps(_XMM9, _XMM1);
      }
      if ( !v11 )
      {
LABEL_37:
        v48 = v28;
        goto LABEL_38;
      }
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+88h], 0
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+8Ch], 10h
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+90h], 20h ; ' '
      }
      v48 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v33, v28)), v28);
LABEL_38:
      *p_v++ = _mm_shuffle_ps(v48, v48, 201);
      ++LifeArrayAtIndex;
    }
  }
}

/*
==============
ParticleModuleRotationGraph::Update
==============
*/
void ParticleModuleRotationGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __m128 v7; 
  __int64 v10; 
  float v13; 
  float v14; 
  bool v15; 
  float4 *RotationRateArrayAtIndex; 
  float4 *v17; 
  float *LifeArrayAtIndex; 
  bool v19; 
  float m_emitterLifeNormalized; 
  __m128 v21; 
  __m128 v22; 
  double CurveValue; 
  float v24; 
  __int64 v25; 
  const ParticleEmitter *v26; 
  __int64 v27; 
  float v28; 
  __m128 v29; 
  double v30; 
  __m128 v31; 
  __int64 v32; 
  float v33; 
  const ParticleEmitter *pEmitterOwnera; 
  const ParticleEmitter *pEmitterOwnerb; 

  v10 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleOffset + (unsigned int)v10 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v32) = particleOffset + v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v32, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v13 = *(float *)&pModuleBase[3].m_flags;
  v14 = *(float *)&pModuleBase[5].m_flags;
  v15 = (pModuleBase->m_flags & 0x10) != 0;
  pEmitterOwnera = (const ParticleEmitter *)Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  if ( LOBYTE(pModuleBase[1].m_type) )
    RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, particleOffset);
  else
    RotationRateArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, particleOffset);
  v17 = RotationRateArrayAtIndex;
  LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  v19 = (pModuleBase->m_flags & 4) == 0;
  if ( (pModuleBase->m_flags & 4) != 0 )
  {
    m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
    *(double *)v7.m128_u64 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized);
    v22 = v7;
    v22.m128_f32[0] = v7.m128_f32[0] * v13;
    v21 = v22;
    if ( v15 )
    {
      CurveValue = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], m_emitterLifeNormalized);
      v24 = *(float *)&CurveValue * v14;
      goto LABEL_27;
    }
  }
  else
  {
    v21 = (__m128)LODWORD(v33);
  }
  v24 = v33;
LABEL_27:
  if ( (_DWORD)v10 )
  {
    v25 = v10;
    v26 = (const ParticleEmitter *)((char *)pEmitterOwnera - (char *)LifeArrayAtIndex);
    pEmitterOwnerb = (const ParticleEmitter *)((char *)pEmitterOwnera - (char *)LifeArrayAtIndex);
    do
    {
      v27 = *(int *)((char *)LifeArrayAtIndex + (_QWORD)v26);
      if ( v19 )
      {
        v28 = *LifeArrayAtIndex;
        *(double *)v7.m128_u64 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *LifeArrayAtIndex);
        v29 = v7;
        v29.m128_f32[0] = v7.m128_f32[0] * v13;
        v21 = v29;
        if ( !v15 )
          goto LABEL_34;
        v30 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], v28);
        v24 = *(float *)&v30 * v14;
      }
      if ( !v15 )
      {
LABEL_34:
        v7 = _mm_shuffle_ps(v21, v21, 0);
        *v17 = (float4)v7;
        goto LABEL_35;
      }
      v31 = (__m128)LODWORD(FLOAT_1_0);
      v7.m128_u64[1] = 0i64;
      v31.m128_f32[0] = (float)((float)(1.0 - fx_randomTable[v27 + 34]) * v21.m128_f32[0]) + (float)(v24 * fx_randomTable[v27 + 34]);
      v17->v = _mm_shuffle_ps(v31, v31, 0);
LABEL_35:
      v26 = pEmitterOwnerb;
      ++LifeArrayAtIndex;
      ++v17;
      --v25;
    }
    while ( v25 );
  }
}

/*
==============
ParticleModuleScaleByDistance::Update
==============
*/
void ParticleModuleScaleByDistance::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleShaderGraph::Update
==============
*/
void ParticleModuleShaderGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  float *LifeArray; 
  ParticleShaderParams *ShaderParamsArray; 
  float4 *v13; 
  float *v14; 
  float m_emitterLifeNormalized; 
  double CurveValue; 
  float v17; 
  double v18; 
  float v19; 
  double v20; 
  float v21; 
  double v22; 
  __m128 v; 
  __int64 v24; 
  float4 outCurve; 
  float4 v26; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v24) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v24, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( pParticleState->m_pModuleInitMaterial )
  {
    LifeArray = Particle_GetLifeArray(pParticleData);
    ShaderParamsArray = Particle_GetShaderParamsArray(pParticleData);
    v13 = (float4 *)ShaderParamsArray;
    if ( (_DWORD)v7 )
    {
      v14 = &ShaderParamsArray->params0.v[2];
      do
      {
        if ( (pModuleBase->m_flags & 4) != 0 )
          m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
        else
          m_emitterLifeNormalized = *LifeArray;
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized, &outCurve);
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], m_emitterLifeNormalized, &v26);
        CurveValue = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[18], m_emitterLifeNormalized);
        v17 = *(float *)&CurveValue;
        v18 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[20], m_emitterLifeNormalized);
        v19 = *(float *)&v18;
        v20 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[22], m_emitterLifeNormalized);
        v21 = *(float *)&v20;
        v22 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[24], m_emitterLifeNormalized);
        v = v26.v;
        *v13 = (float4)outCurve.v;
        v13[1] = (float4)v;
        *(v14 - 2) = v17;
        *(v14 - 1) = v19;
        *v14 = v21;
        v14[1] = *(float *)&v22;
        v14 += 12;
        v13 += 3;
        ++LifeArray;
        --v7;
      }
      while ( v7 );
    }
  }
}

/*
==============
ParticleModuleSizeGraph::Update
==============
*/
void ParticleModuleSizeGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  float4 *float4Array; 
  float4 *v12; 
  const float *LifeArrayAtIndex; 
  __m128 m_emitterLifeNormalized_low; 
  bool v16; 
  __m128 v17; 
  __m128 v18; 
  __m128 v19; 
  __int64 v20; 
  __int64 useEmitterLife; 
  const ParticleCurveDef *useEmitterLifea; 
  const ParticleCurveDef *emitterLife; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(useEmitterLife) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", useEmitterLife, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  float4Array = Particle_GetSizeArrayAtIndex(pParticleData, particleOffset);
  v12 = float4Array;
  if ( (pModuleBase->m_flags & 0x1000) != 0 )
  {
    LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    _RDI = LifeArrayAtIndex;
    m_emitterLifeNormalized_low = (__m128)LODWORD(pEmitterOwner->m_emitterLifeNormalized);
    v16 = (pModuleBase->m_flags & 4) != 0;
    if ( LOBYTE(pModuleBase[1].m_type) )
    {
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 386, ASSERT_TYPE_ASSERT, "(outputArray)", (const char *)&queryFormat, "outputArray") )
        __debugbreak();
      if ( !(_DWORD)v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 387, ASSERT_TYPE_ASSERT, "(numParticles > 0)", (const char *)&queryFormat, "numParticles > 0") )
        __debugbreak();
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 388, ASSERT_TYPE_ASSERT, "(lifeArray)", (const char *)&queryFormat, "lifeArray") )
        __debugbreak();
      v17 = *(__m128 *)&pModuleBase[16].m_type;
      if ( v16 )
      {
        v18 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(v17, *(__m128 *)&pModuleBase[14].m_type), _mm_shuffle_ps(m_emitterLifeNormalized_low, m_emitterLifeNormalized_low, 0)), *(__m128 *)&pModuleBase[14].m_type);
        if ( (_DWORD)v7 )
        {
          *v12 = (float4)v18;
          qmemcpy(&v12[1], v12, 8 * ((unsigned __int64)(16 * v7 - 9) >> 3));
        }
      }
      else
      {
        v19 = _mm128_sub_ps(v17, *(__m128 *)&pModuleBase[14].m_type);
        if ( (_DWORD)v7 )
        {
          v20 = v7;
          do
          {
            ++v12;
            __asm { vbroadcastss xmm0, dword ptr [rdi] }
            ++_RDI;
            v12[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, v19), *(__m128 *)&pModuleBase[14].m_type);
            --v20;
          }
          while ( v20 );
        }
      }
    }
    else
    {
      ParticleModuleGraph_LerpFloat4Array_1_((const float4 *)&pModuleBase[14], (const float4 *)&pModuleBase[16], v12, v7, LifeArrayAtIndex, v16, pEmitterOwner->m_emitterLifeNormalized);
    }
  }
  else
  {
    emitterLife = (const ParticleCurveDef *)&pModuleBase[8];
    useEmitterLifea = (const ParticleCurveDef *)&pModuleBase[2];
    if ( LOBYTE(pModuleBase[1].m_type) )
      ParticleModuleGraph_UpdateFloat4Array_0_(pModuleBase, pParticleData, particleOffset, v7, pEmitterOwner, useEmitterLifea, emitterLife, FXRAND_SIZE_0, FXRAND_SIZE_1, FXRAND_SIZE_2, float4Array);
    else
      ParticleModuleGraph_UpdateFloat4Array_1_(pModuleBase, pParticleData, particleOffset, v7, pEmitterOwner, useEmitterLifea, emitterLife, FXRAND_SIZE_0, FXRAND_SIZE_1, FXRAND_SIZE_2, float4Array);
  }
}

/*
==============
ParticleModuleSizeLerp::Update
==============
*/
void ParticleModuleSizeLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  float4 *SizeArrayAtIndex; 
  float4 *v13; 
  __m128 v14; 
  __m128 v15; 
  __m128 v17; 
  __m128 v18; 
  __int64 v20; 
  __int64 v22; 

  v7 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R14 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v22) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v22, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  SizeArrayAtIndex = Particle_GetSizeArrayAtIndex(pParticleData, particleOffset);
  v13 = SizeArrayAtIndex;
  v14 = *(__m128 *)&pModuleBase[4].m_type;
  if ( (pModuleBase->m_flags & 4) != 0 )
  {
    v15 = _mm128_sub_ps(v14, *(__m128 *)&pModuleBase[2].m_type);
    __asm { vbroadcastss xmm0, dword ptr [r14+178h] }
    v17 = _mm128_add_ps(_mm128_mul_ps(v15, _XMM0), *(__m128 *)&pModuleBase[2].m_type);
    if ( (_DWORD)v7 )
    {
      *SizeArrayAtIndex = (float4)v17;
      qmemcpy(&SizeArrayAtIndex[1], SizeArrayAtIndex, 8 * ((unsigned __int64)(16 * v7 - 9) >> 3));
    }
  }
  else
  {
    v18 = _mm128_sub_ps(v14, *(__m128 *)&pModuleBase[2].m_type);
    _RAX = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    if ( (_DWORD)v7 )
    {
      v20 = v7;
      do
      {
        ++v13;
        __asm { vbroadcastss xmm0, dword ptr [rax] }
        ++_RAX;
        v13[-1].v = _mm128_add_ps(_mm128_mul_ps(_XMM0, v18), *(__m128 *)&pModuleBase[2].m_type);
        --v20;
      }
      while ( v20 );
    }
  }
}

/*
==============
ParticleModuleTemperatureGraph::Update
==============
*/
void ParticleModuleTemperatureGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_TEMPERATURE)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_TEMPERATURE, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_TEMPERATURE, floatArray);
}

/*
==============
ParticleModuleVectorFieldGraph::Update
==============
*/
void ParticleModuleVectorFieldGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_VECTOR_FIELD_SCALE)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_VECTOR_FIELD_SCALE, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_VECTOR_FIELD_SCALE, floatArray);
}

/*
==============
ParticleModuleVelocityGraph::Update
==============
*/
void ParticleModuleVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v10; 
  float4 *VelocityArrayAtIndex; 
  unsigned int *FlagsArrayAtIndex; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  bool v16; 
  bool v17; 
  unsigned int m_flags; 
  bool v19; 
  __m128 v20; 
  __m128 v21; 
  __m128 v23; 
  __m128 v24; 
  float m_emitterLifeNormalized; 
  __m128 v38; 
  __m128 v43; 
  signed __int64 v44; 
  signed __int64 v45; 
  bool v46; 
  __m128 v47; 
  float v49; 
  __m128 v62; 
  __int64 v63; 
  bool v64; 
  bool v65; 
  bool v66; 
  unsigned int *v67; 
  signed __int64 v68; 
  __m128 v69; 
  bool v70; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v72; 
  bool v73; 
  bool v74; 
  bool v75; 

  _R12 = pEmitterOwner;
  v10 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v10 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v63) = v10 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v63, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v73 = (pModuleBase->m_flags & 0x10) != 0;
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  _RDI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  v67 = FlagsArrayAtIndex;
  v70 = (pParticleState->m_pStateDef->flags & 0x200000) != 0;
  v16 = m_pModuleInitRelativeVelocity && (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 && ((m_pModuleInitRelativeVelocity->m_velocityType - 3) & 0xFFFFFFFD) == 0;
  v65 = v16;
  v75 = (pModuleBase->m_flags & 0x80) != 0;
  v74 = (pModuleBase->m_flags & 0x400) != 0;
  v17 = (pModuleBase->m_flags & 0x80) != 0 && ((pModuleBase->m_flags & 0x400) != 0 || v16);
  v64 = (pModuleBase->m_flags & 0x400) != 0 || v16 && (pModuleBase->m_flags & 0x80) != 0;
  v69.m128_u64[0] = (unsigned __int64)ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( v17 )
    v69.m128_u64[0] = (unsigned __int64)ParticleEmitter::GetEmitterTransformTranspose((ParticleEmitter *)pEmitterOwner, pParticleState);
  m_flags = pModuleBase->m_flags;
  v19 = (m_flags & 0x1000) != 0;
  v66 = v19;
  if ( (m_flags & 0x1000) != 0 )
  {
    v20 = *(__m128 *)&pModuleBase[16].m_type;
    if ( (m_flags & 4) == 0 )
    {
      v24 = _mm128_sub_ps(v20, *(__m128 *)&pModuleBase[14].m_type);
      v23 = v69;
      goto LABEL_42;
    }
    v21 = _mm128_sub_ps(v20, *(__m128 *)&pModuleBase[14].m_type);
    __asm { vbroadcastss xmm0, dword ptr [r12+178h] }
    v23 = _mm128_add_ps(_mm128_mul_ps(v21, _XMM0), *(__m128 *)&pModuleBase[14].m_type);
  }
  else
  {
    v23 = v69;
  }
  v24 = v69;
LABEL_42:
  _XMM11 = 0i64;
  __asm
  {
    vinsertps xmm11, xmm11, dword ptr [rbx+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rbx+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rbx+3Ch], 20h ; ' '
  }
  if ( v73 )
  {
    _XMM10 = 0i64;
    __asm
    {
      vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 0
      vinsertps xmm10, xmm10, dword ptr [rbx+5Ch], 10h
      vinsertps xmm10, xmm10, dword ptr [rbx+6Ch], 20h ; ' '
    }
  }
  else
  {
    _XMM10 = v69;
  }
  if ( (m_flags & 4) != 0 )
  {
    m_emitterLifeNormalized = pEmitterOwner->m_emitterLifeNormalized;
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], m_emitterLifeNormalized);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], m_emitterLifeNormalized);
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], m_emitterLifeNormalized);
    _XMM2 = 0i64;
    __asm
    {
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
    }
    v38 = _mm128_mul_ps(_XMM11, _XMM2);
    if ( v73 )
    {
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], m_emitterLifeNormalized);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], m_emitterLifeNormalized);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], m_emitterLifeNormalized);
      v19 = v66;
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
      }
      v43 = _mm128_mul_ps(_XMM10, _XMM1);
      goto LABEL_51;
    }
    v19 = v66;
  }
  else
  {
    v38 = v69;
  }
  v43 = v69;
LABEL_51:
  if ( (_DWORD)v10 )
  {
    v44 = (char *)v67 - (char *)RandomSeedArrayAtIndex;
    v45 = (char *)RandomSeedArrayAtIndex - (char *)_RDI;
    v46 = v70;
    v72 = (char *)RandomSeedArrayAtIndex - (char *)_RDI;
    v68 = v44;
    while ( v46 && (*((_BYTE *)_RDI + v44 + v45) & 8) != 0 )
    {
LABEL_75:
      v45 = v72;
      v19 = v66;
      ++_RDI;
      ++VelocityArrayAtIndex;
      if ( !--v10 )
        return;
    }
    if ( v19 )
    {
      if ( (pModuleBase->m_flags & 4) != 0 )
      {
        v47 = v23;
      }
      else
      {
        __asm { vbroadcastss xmm0, dword ptr [rdi] }
        v47 = _mm128_add_ps(_mm128_mul_ps(_XMM0, v24), *(__m128 *)&pModuleBase[14].m_type);
      }
      goto LABEL_65;
    }
    if ( (pModuleBase->m_flags & 4) == 0 )
    {
      v49 = *_RDI;
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *_RDI);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], v49);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], v49);
      _XMM2 = 0i64;
      __asm
      {
        vinsertps xmm2, xmm2, xmm0, 0
        vinsertps xmm2, xmm2, xmm6, 10h
        vinsertps xmm2, xmm2, xmm7, 20h ; ' '
      }
      v38 = _mm128_mul_ps(_XMM11, _XMM2);
      if ( !v73 )
        goto LABEL_64;
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], v49);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], v49);
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], v49);
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
      }
      v43 = _mm128_mul_ps(_XMM10, _XMM1);
    }
    if ( v73 )
    {
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4], 0
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4+4], 10h
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4+8], 20h ; ' '
      }
      v47 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _mm128_sub_ps(v43, v38)), v38);
LABEL_65:
      if ( v64 )
      {
        if ( v74 )
        {
          VelocityArrayAtIndex->v = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v47, v47, 0), *(__m128 *)v69.m128_u64[0]), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v47, v47, 85), *(__m128 *)(v69.m128_u64[0] + 16)), _mm128_mul_ps(_mm_shuffle_ps(v47, v47, 170), *(__m128 *)(v69.m128_u64[0] + 32)))), VelocityArrayAtIndex->v);
        }
        else
        {
          if ( (!v65 || !v75) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2280, ASSERT_TYPE_ASSERT, "(hasBoltInfo && useWorldSpace)", (const char *)&queryFormat, "hasBoltInfo && useWorldSpace") )
            __debugbreak();
          v62 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v47, v47, 85), *(__m128 *)(v69.m128_u64[0] + 16)), g_negativeZero.v), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v47, v47, 170), *(__m128 *)(v69.m128_u64[0] + 32)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v47, v47, 0), *(__m128 *)v69.m128_u64[0]), g_negativeZero.v)));
          *VelocityArrayAtIndex = (float4)v62;
          *VelocityArrayAtIndex = (float4)(*(_OWORD *)&v62 & *(_OWORD *)&g_keepXYZ.v);
        }
      }
      else
      {
        *VelocityArrayAtIndex = (float4)v47;
      }
      v46 = v70;
      v44 = v68;
      goto LABEL_75;
    }
LABEL_64:
    v47 = v38;
    goto LABEL_65;
  }
}

