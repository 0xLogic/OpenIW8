/*
==============
BG_AimAssistRange
==============
*/

void __fastcall BG_AimAssistRange(const Weapon *r_weapon, bool isAlternate, float *aimAssistRange, float *aimAssistRangeAds)
{
  ?BG_AimAssistRange@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, aimAssistRange, aimAssistRangeAds);
}

/*
==============
BG_PlayerWeaponGetEquippedSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetEquippedSlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_PlayerWeaponGetEquippedSlot@@YA?AW4WeaponSlot@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_SprintOutTime
==============
*/

int __fastcall BG_SprintOutTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintOutTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetCharacterModelRangeByType
==============
*/

bool __fastcall BG_GetCharacterModelRangeByType(DObj *obj, const CharacterModelType (*dobjModelTypes)[32], const CharacterModelType modelTypeSearched, const int startModelIndex, const int finishModelIndex, int *outFirst, int *outLast)
{
  return ?BG_GetCharacterModelRangeByType@@YA_NPEAUDObj@@AEAY0CA@$$CBW4CharacterModelType@@W42@HHPEAH3@Z(obj, dobjModelTypes, modelTypeSearched, startModelIndex, finishModelIndex, outFirst, outLast);
}

/*
==============
BG_ProjDudEffect
==============
*/

FxCombinedDef __fastcall BG_ProjDudEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDudEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlastLeftTime
==============
*/

int __fastcall BG_BlastLeftTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastLeftTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_PlayAltGesturesForOffhandWeapons
==============
*/

bool __fastcall BG_PlayAltGesturesForOffhandWeapons(const Weapon *r_weapon)
{
  return ?BG_PlayAltGesturesForOffhandWeapons@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SprintOutInterruptTime
==============
*/

int __fastcall BG_SprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintOutInterruptTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponLaserSettings
==============
*/

void __fastcall BG_GetWeaponLaserSettings(const Weapon *r_weapon, const bool isAlternate, LaserSettings *outLaserSettings)
{
  ?BG_GetWeaponLaserSettings@@YAXAEBUWeapon@@_NAEAULaserSettings@@@Z(r_weapon, isAlternate, outLaserSettings);
}

/*
==============
BG_SetWeaponDelay
==============
*/

void __fastcall BG_SetWeaponDelay(const BgWeaponMap *weaponMap, playerState_s *ps, const PlayerHandIndex hand, int weaponDelay, const char *const reason)
{
  ?BG_SetWeaponDelay@@YAXPEBVBgWeaponMap@@PEAUplayerState_s@@W4PlayerHandIndex@@HQEBD@Z(weaponMap, ps, hand, weaponDelay, reason);
}

/*
==============
BG_Weapon_GetCameraFireEffectDurationSec
==============
*/

double __fastcall BG_Weapon_GetCameraFireEffectDurationSec(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_Weapon_GetCameraFireEffectDurationSec@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSShouldShowCrosshair
==============
*/

bool __fastcall BG_ADSShouldShowCrosshair(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSShouldShowCrosshair@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ADSBobFactor
==============
*/

double __fastcall BG_ADSBobFactor(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSBobFactor@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetReticleType
==============
*/

ReticleType __fastcall BG_GetReticleType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetReticleType@@YA?AW4ReticleType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HideWarningIcons
==============
*/

bool __fastcall BG_HideWarningIcons(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HideWarningIcons@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_RandomizeWeapon
==============
*/

void __fastcall BG_WeaponsUtil_RandomizeWeapon(Weapon *inOutWeapon, unsigned int *randSeed)
{
  ?BG_WeaponsUtil_RandomizeWeapon@@YAXAEAUWeapon@@PEAI@Z(inOutWeapon, randSeed);
}

/*
==============
BG_UseSmoothViewKick
==============
*/

bool __fastcall BG_UseSmoothViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseSmoothViewKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_TakePlayerWeapon
==============
*/

int __fastcall BG_TakePlayerWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const BgHandler *const handler, const Weapon *r_weapon, int gameTime)
{
  return ?BG_TakePlayerWeapon@@YAHPEAVBgWeaponMap@@PEAUplayerState_s@@QEBVBgHandler@@AEBUWeapon@@H@Z(weaponMap, ps, handler, r_weapon, gameTime);
}

/*
==============
BG_DoubleRiotShieldCheck
==============
*/

bool __fastcall BG_DoubleRiotShieldCheck(const BgWeaponMap *weaponMap, const Weapon *weaponToPickUp, const playerState_s *ps)
{
  return ?BG_DoubleRiotShieldCheck@@YA_NPEBVBgWeaponMap@@AEBUWeapon@@PEBUplayerState_s@@@Z(weaponMap, weaponToPickUp, ps);
}

/*
==============
BG_GetMeleeComboSeqCount
==============
*/

int __fastcall BG_GetMeleeComboSeqCount(const Weapon *r_weapon)
{
  return ?BG_GetMeleeComboSeqCount@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_RechamberWhileADS
==============
*/

bool __fastcall BG_RechamberWhileADS(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RechamberWhileADS@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_MeleeImpactRumble
==============
*/

RumbleInfo *__fastcall BG_MeleeImpactRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_MeleeImpactRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponFieldTime
==============
*/

unsigned __int16 __fastcall BG_GetWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  return ?BG_GetWeaponFieldTime@@YAGPEBUplayerState_s@@AEBUWeapon@@_N2_J@Z(ps, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_LadderAimRaiseInterruptTime
==============
*/

int __fastcall BG_LadderAimRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimRaiseInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadAddTime
==============
*/

int __fastcall BG_ReloadAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  return ?BG_ReloadAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2H2AEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, isSecondRound, hasFastReloadOverride);
}

/*
==============
BG_EmptyRaiseTime
==============
*/

int __fastcall BG_EmptyRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_EmptyRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineOccludedOutlineColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedOutlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedOutlineColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndexForCharacter@TagPair@@QEBA_NPEBUDObj@@PEBUcharacterInfo_t@@QEBW4CharacterModelType@@HPEAW4scr_string_t@@PEAE@Z(this, obj, ci, modelTypesToSearch, modelTypeCount, outTagName, outBoneIndex);
}

/*
==============
BG_GetShelvedDamageForRange
==============
*/

int __fastcall BG_GetShelvedDamageForRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float range)
{
  return ?BG_GetShelvedDamageForRange@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMM@Z(damageCalcType, r_weapon, isAlternate, rangeScale, range);
}

/*
==============
BG_GetGameDefaultWeaponAnim
==============
*/

XAnimParts *__fastcall BG_GetGameDefaultWeaponAnim(int animIndex)
{
  return ?BG_GetGameDefaultWeaponAnim@@YAPEAUXAnimParts@@H@Z(animIndex);
}

/*
==============
BG_GetBallisticInfo
==============
*/

const BallisticInfo *__fastcall BG_GetBallisticInfo(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetBallisticInfo@@YAPEBUBallisticInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjExplosionReflectionClass
==============
*/

unsigned int __fastcall BG_ProjExplosionReflectionClass(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionReflectionClass@@YAIAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjTimeoutSound
==============
*/

const SndAliasList *__fastcall BG_ProjTimeoutSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTimeoutSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasUnderbarrelShotgun
==============
*/

int __fastcall BG_HasUnderbarrelShotgun(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelShotgun@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BGSpreadSetting::CalculateSpread
==============
*/

void __fastcall BGSpreadSetting::CalculateSpread(BGSpreadSetting *this, int shotIndex, float *spreadMinOut, float *spreadMaxOut, float *angleMinOut, float *angleMaxOut)
{
  ?CalculateSpread@BGSpreadSetting@@QEAAXHPEAM000@Z(this, shotIndex, spreadMinOut, spreadMaxOut, angleMinOut, angleMaxOut);
}

/*
==============
BG_FireRumble
==============
*/

RumbleInfo *__fastcall BG_FireRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_FireRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SetGlobalAmmoForAmmoType
==============
*/

void __fastcall BG_SetGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  ?BG_SetGlobalAmmoForAmmoType@@YAXPEAUplayerState_s@@AEBUAmmoStore@@H@Z(ps, r_ammoType, ammoCount);
}

/*
==============
BG_GetPenetrateType
==============
*/

PenetrateType __fastcall BG_GetPenetrateType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetPenetrateType@@YA?AW4PenetrateType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsPlayingVehicleOccupancyAnims
==============
*/

bool __fastcall BG_IsPlayingVehicleOccupancyAnims(const characterInfo_t *ci)
{
  return ?BG_IsPlayingVehicleOccupancyAnims@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BG_PreFireSound
==============
*/

const SndAliasList *__fastcall BG_PreFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_PreFireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_GetWeaponOffhandClass
==============
*/

OffhandClass __fastcall BG_GetWeaponOffhandClass(const Weapon *r_weapon)
{
  return ?BG_GetWeaponOffhandClass@@YA?AW4OffhandClass@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IdleCrouchFactor
==============
*/

double __fastcall BG_IdleCrouchFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_IdleCrouchFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ProjTimeoutEffect
==============
*/

FxCombinedDef __fastcall BG_ProjTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTimeoutEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsEnergyBullet
==============
*/

bool __fastcall BG_IsEnergyBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsEnergyBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ApplyWeaponAnglesToShootingDirection
==============
*/

void __fastcall BG_ApplyWeaponAnglesToShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t *angles, const vec3_t (*anglesCategorized)[30], const vec3_t *oldAngles, vec3_t *outNewAngles, vec3_t *outShootingAnglesLocal)
{
  ?BG_ApplyWeaponAnglesToShootingDirection@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEBTvec3_t@@AEAY0BO@$$CBT4@4AEAT4@6@Z(weaponMap, ps, r_weapon, isAlternate, angles, anglesCategorized, oldAngles, outNewAngles, outShootingAnglesLocal);
}

/*
==============
BG_WeaponCharge_GetChargeMaxSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeMaxSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeMaxSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_RaiseTime
==============
*/

int __fastcall BG_RaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ProjWhizByEnabled
==============
*/

bool __fastcall BG_ProjWhizByEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjWhizByEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TimedDetonation
==============
*/

bool __fastcall BG_TimedDetonation(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TimedDetonation@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_RechamberTimeOneHanded
==============
*/

int __fastcall BG_RechamberTimeOneHanded(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberTimeOneHanded@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddParachuteModelToCorpse
==============
*/

int __fastcall BG_AddParachuteModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddParachuteModelToCorpse@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetMountEnterExitDuration
==============
*/

void __fastcall BG_GetMountEnterExitDuration(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, int *outEnterDurationMs, int *outExitDurationMs)
{
  ?BG_GetMountEnterExitDuration@@YAXW4ContextMountType@@AEBUWeapon@@_NPEAH3@Z(mountType, r_weapon, isAlternate, outEnterDurationMs, outExitDurationMs);
}

/*
==============
BG_IsBallWeapon
==============
*/

bool __fastcall BG_IsBallWeapon(const Weapon *r_weapon)
{
  return ?BG_IsBallWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SuperSprintOutInterruptTime
==============
*/

int __fastcall BG_SuperSprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SuperSprintOutInterruptTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponSticksToPlayers
==============
*/

bool __fastcall BG_WeaponSticksToPlayers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToPlayers@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Interpolated
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Interpolated(const float innerDamage, const float outerDamage, const float damageRadius, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_BuildExplosionDamageRangeInfo_Interpolated@@YAXMMMAEAUBgExplosionDamageRangeInfo@@@Z(innerDamage, outerDamage, damageRadius, outDamageRangeInfo);
}

/*
==============
BG_GetMountGunIdleScale
==============
*/

double __fastcall BG_GetMountGunIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunIdleScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ReloadStartAddTime
==============
*/

int __fastcall BG_ReloadStartAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  return ?BG_ReloadStartAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2H2AEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, isSecondRound, hasFastReloadOverride);
}

/*
==============
BG_ExplosionUsesSteppedDamage
==============
*/

bool __fastcall BG_ExplosionUsesSteppedDamage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionUsesSteppedDamage@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WalkLoopTime
==============
*/

int __fastcall BG_WalkLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_WalkLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MoveCycleJogTime
==============
*/

int __fastcall BG_MoveCycleJogTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleJogTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponMeleeAnimProperties
==============
*/

int __fastcall BG_GetWeaponMeleeAnimProperties(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool isUsingAlternateMelee, bool *outIsRandomized, MeleeAnimType *outAnimType, unsigned __int8 *outAnimSets)
{
  return ?BG_GetWeaponMeleeAnimProperties@@YAHPEBUplayerState_s@@AEBUWeapon@@_N22PEA_NPEAW4MeleeAnimType@@PEAE@Z(ps, r_weapon, isAlternate, isDualWielding, isUsingAlternateMelee, outIsRandomized, outAnimType, outAnimSets);
}

/*
==============
BG_BlastFrontTime
==============
*/

int __fastcall BG_BlastFrontTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastFrontTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCharge_GetFireAtMaxDamageMultiplier
==============
*/

double __fastcall BG_WeaponCharge_GetFireAtMaxDamageMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetFireAtMaxDamageMultiplier@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponAttachmentsUsingHighStockPriority
==============
*/

unsigned int __fastcall BG_GetWeaponAttachmentsUsingHighStockPriority(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  return ?BG_GetWeaponAttachmentsUsingHighStockPriority@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@@Z(r_weapon, isAlternate, attachments);
}

/*
==============
BG_TurretWeaponUses3pIK
==============
*/

bool __fastcall BG_TurretWeaponUses3pIK(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretWeaponUses3pIK@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEmptyTime
==============
*/

int __fastcall BG_ReloadEmptyTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEmptyTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4AEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, hasFastReloadOverride);
}

/*
==============
BG_WeaponBulletFire_GetExplRadius
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplRadius(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplRadius@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_LeapOutTime
==============
*/

int __fastcall BG_LeapOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapOutTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCanAutoReload
==============
*/

bool __fastcall BG_WeaponCanAutoReload(const playerState_s *ps, const Weapon *currentWeapon, bool isAlternate)
{
  return ?BG_WeaponCanAutoReload@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, currentWeapon, isAlternate);
}

/*
==============
BG_ScaleKickValue
==============
*/

void __fastcall BG_ScaleKickValue(float *kickPitch, float *kickYaw, const float kickMagMin)
{
  ?BG_ScaleKickValue@@YAXPEAM0M@Z(kickPitch, kickYaw, kickMagMin);
}

/*
==============
BG_SkydiveSuperDiveOutTime
==============
*/

int __fastcall BG_SkydiveSuperDiveOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveSuperDiveOutTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetMinMaxDamage
==============
*/

void __fastcall BG_GetMinMaxDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMinDamage, int *outMaxDamage)
{
  ?BG_GetMinMaxDamage@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NAEAH3@Z(damageCalcType, r_weapon, isAlternate, outMinDamage, outMaxDamage);
}

/*
==============
BG_AltDropAkimboTime
==============
*/

int __fastcall BG_AltDropAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropAkimboTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/

weapClass_t __fastcall BG_GetWeaponClassForAnimCondition(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClassForAnimCondition@@YA?AW4weapClass_t@@PEBUentityState_t@@AEBUWeapon@@_N@Z(es, r_weapon, isAlternate);
}

/*
==============
BG_ExplosionForceRadius
==============
*/

int __fastcall BG_ExplosionForceRadius(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionForceRadius@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSAccel
==============
*/

void __fastcall BG_GetADSAccel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsOutToInAccelSec, float *outAdsInToOutAccelSec)
{
  ?BG_GetADSAccel@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, outAdsOutToInAccelSec, outAdsInToOutAccelSec);
}

/*
==============
BG_GetWeaponInspectTime
==============
*/

int __fastcall BG_GetWeaponInspectTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_GetWeaponInspectTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetMountFOVScale
==============
*/

double __fastcall BG_GetMountFOVScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountFOVScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetHeatSmokeProperties
==============
*/

void __fastcall BG_GetHeatSmokeProperties(const Weapon *weapon, const bool isAlternate, float *outSmokeStartThreshold, float *outSmokeStopThreshold)
{
  ?BG_GetHeatSmokeProperties@@YAXAEBUWeapon@@_NAEAM2@Z(weapon, isAlternate, outSmokeStartThreshold, outSmokeStopThreshold);
}

/*
==============
BG_PlayerOffhandGetSlotName
==============
*/

scr_string_t __fastcall BG_PlayerOffhandGetSlotName(const OffhandSlot slot)
{
  return ?BG_PlayerOffhandGetSlotName@@YA?AW4scr_string_t@@W4OffhandSlot@@@Z(slot);
}

/*
==============
BG_DPadIcon
==============
*/

Material *__fastcall BG_DPadIcon(const Weapon *r_weapon, bool isAlternate, bool isActive)
{
  return ?BG_DPadIcon@@YAPEAUMaterial@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isActive);
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObjByModelRange
==============
*/

void __fastcall BG_UpdateWeaponHidePartBitsForDObjByModelRange(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel, int lastModelInclusive)
{
  ?BG_UpdateWeaponHidePartBitsForDObjByModelRange@@YAXPEAUDObj@@AEBUWeapon@@_NHH@Z(obj, r_weapon, isViewModel, startModel, lastModelInclusive);
}

/*
==============
BGSpreadSetting::Init
==============
*/

void __fastcall BGSpreadSetting::Init(BGSpreadSetting *this, float angleStart, int shotCount, float initSpreadMin, float initSpreadMax)
{
  ?Init@BGSpreadSetting@@QEAAXMHMM@Z(this, angleStart, shotCount, initSpreadMin, initSpreadMax);
}

/*
==============
BG_IsSilenced
==============
*/

bool __fastcall BG_IsSilenced(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsSilenced@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSDamageRangeScale
==============
*/

double __fastcall BG_GetADSDamageRangeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSDamageRangeScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetAdvancedIdleSettings
==============
*/

void __fastcall BG_GetAdvancedIdleSettings(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, AdvancedIdleSettings *outAdvancedIdleSettings)
{
  ?BG_GetAdvancedIdleSettings@@YAXV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAUAdvancedIdleSettings@@@Z(perks, r_weapon, isAlternate, outAdvancedIdleSettings);
}

/*
==============
BG_ProjIgnitionSound
==============
*/

const SndAliasList *__fastcall BG_ProjIgnitionSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldSpread
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldSpread(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldSpread@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_MultipleReloadInterruptTime
==============
*/

int __fastcall BG_MultipleReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t animIndex)
{
  return ?BG_MultipleReloadInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4W4weapAnimFiles_t@@@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, animIndex);
}

/*
==============
BG_GetAdsFireAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsFireAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsFireAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_IsPredictedProjectileWeapon
==============
*/

bool __fastcall BG_IsPredictedProjectileWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsPredictedProjectileWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponFireRecoil
==============
*/

void __fastcall BG_WeaponFireRecoil(const BgWeaponMap *weaponMap, const playerState_s *ps, PlayerHandIndex hand, const float pitchMove, const float yawMove, const vec2_t *gunKickAngles, const vec2_t *viewKickAngles, vec2_t *outGunKickAVel, bool *outGunNeedsToCrossCenter, vec3_t *outViewKickAVel, bool *outViewNeedsToCrossCenter)
{
  ?BG_WeaponFireRecoil@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@W4PlayerHandIndex@@MMAEBTvec2_t@@3AEAT4@AEA_NAEATvec3_t@@5@Z(weaponMap, ps, hand, pitchMove, yawMove, gunKickAngles, viewKickAngles, outGunKickAVel, outGunNeedsToCrossCenter, outViewKickAVel, outViewNeedsToCrossCenter);
}

/*
==============
BG_CalculateEaseMotionFactor
==============
*/

double __fastcall BG_CalculateEaseMotionFactor(const float weaponPosFrac, AdsOffsetInterpolationType lerpType)
{
  double result; 

  *(float *)&result = ?BG_CalculateEaseMotionFactor@@YAMMW4AdsOffsetInterpolationType@@@Z(weaponPosFrac, lerpType);
  return result;
}

/*
==============
BG_SmoothFadeSniperScene
==============
*/

void __fastcall BG_SmoothFadeSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float adsFrac)
{
  ?BG_SmoothFadeSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@M@Z(r_weapon, isAlternate, obj, adsFrac);
}

/*
==============
BG_GetGrenadeDangerIconDistance
==============
*/

double __fastcall BG_GetGrenadeDangerIconDistance(const Weapon *r_weapon, bool isAlternate, const float defaultValue)
{
  double result; 

  *(float *)&result = ?BG_GetGrenadeDangerIconDistance@@YAMAEBUWeapon@@_NM@Z(r_weapon, isAlternate, defaultValue);
  return result;
}

/*
==============
BG_MoveCycleSuperSprintTime
==============
*/

int __fastcall BG_MoveCycleSuperSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleSuperSprintTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddIgnoreEntToBP
==============
*/

void __fastcall BG_AddIgnoreEntToBP(BulletFireParams *bp, int entityIndex)
{
  ?BG_AddIgnoreEntToBP@@YAXPEAUBulletFireParams@@H@Z(bp, entityIndex);
}

/*
==============
BG_IsUsingWorldIKTargets
==============
*/

bool __fastcall BG_IsUsingWorldIKTargets(const characterInfo_t *ci)
{
  return ?BG_IsUsingWorldIKTargets@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BgWeaponScalarAccumulator::ApplyAdditiveScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyAdditiveScale(BgWeaponScalarAccumulator *this, const float scale)
{
  ?ApplyAdditiveScale@BgWeaponScalarAccumulator@@QEAAXM@Z(this, scale);
}

/*
==============
BG_LadderAimRaiseTime
==============
*/

int __fastcall BG_LadderAimRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_DangerIcon
==============
*/

Material *__fastcall BG_DangerIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DangerIcon@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsHighPrecisionClientFireEventEnabled
==============
*/

bool __fastcall BG_IsHighPrecisionClientFireEventEnabled(const int eventId, const entityState_t *es)
{
  return ?BG_IsHighPrecisionClientFireEventEnabled@@YA_NHPEBUentityState_t@@@Z(eventId, es);
}

/*
==============
BG_HasDualFOV
==============
*/

bool __fastcall BG_HasDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSfxPackageSound
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSfxPackageSound(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSound@@YAPEBUSndAliasList@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_GetWeaponPrimaryAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetWeaponPrimaryAttachment(const Weapon *r_weapon, const AttachmentSlot attachment)
{
  return ?BG_GetWeaponPrimaryAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@W4AttachmentSlot@@@Z(r_weapon, attachment);
}

/*
==============
BG_ADSFireAnimFrac
==============
*/

double __fastcall BG_ADSFireAnimFrac(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSFireAnimFrac@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSMovementAnimBlendFrac
==============
*/

void __fastcall BG_ADSMovementAnimBlendFrac(const Weapon *r_weapon, bool isAlternate, float *outStartFrac, float *outEndFrac)
{
  ?BG_ADSMovementAnimBlendFrac@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, outStartFrac, outEndFrac);
}

/*
==============
BG_ShowBoneByModelRange
==============
*/

unsigned __int8 __fastcall BG_ShowBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  return ?BG_ShowBoneByModelRange@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@HH@Z(bone, obj, partBits, startModel, lastModelInclusive);
}

/*
==============
BG_GetOffhandOverCookIsNotLethal
==============
*/

bool __fastcall BG_GetOffhandOverCookIsNotLethal(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandOverCookIsNotLethal@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerWeaponIsSlotFull
==============
*/

bool __fastcall BG_PlayerWeaponIsSlotFull(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_PlayerWeaponIsSlotFull@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_WeaponResetADSReloadFraction
==============
*/

void __fastcall BG_WeaponResetADSReloadFraction(playerState_s *ps)
{
  ?BG_WeaponResetADSReloadFraction@@YAXPEAUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetBulletTerminationRange
==============
*/

double __fastcall BG_GetBulletTerminationRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBulletTerminationRange@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponCharge_GetChargeUpToDownSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeUpToDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeUpToDownSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_LadderAimADSRaiseInterruptTime
==============
*/

int __fastcall BG_LadderAimADSRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimADSRaiseInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetFirstEquippedOffhandByClass
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return ?BG_GetFirstEquippedOffhandByClass@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@H@Z(weaponMap, ps, offhandClass);
}

/*
==============
BG_IsMeleeComboWeapon
==============
*/

bool __fastcall BG_IsMeleeComboWeapon(const Weapon *r_weapon)
{
  return ?BG_IsMeleeComboWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ReloadDisabled
==============
*/

bool __fastcall BG_ReloadDisabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadDisabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetFootstepFromAnim
==============
*/

FootstepAnimType __fastcall BG_GetFootstepFromAnim(weapAnimFiles_t animIndex)
{
  return ?BG_GetFootstepFromAnim@@YA?AW4FootstepAnimType@@W4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ReloadMultipleTimePercentageBased
==============
*/

int __fastcall BG_ReloadMultipleTimePercentageBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  return ?BG_ReloadMultipleTimePercentageBased@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_NAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, hasFastReloadOverride);
}

/*
==============
BG_GetMeleeAutoAimMaxPitchMovement
==============
*/

double __fastcall BG_GetMeleeAutoAimMaxPitchMovement(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimMaxPitchMovement@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasVRLegendaryScope
==============
*/

bool __fastcall BG_HasVRLegendaryScope(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_HasVRLegendaryScope@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_InitPlayerWeapons
==============
*/

void __fastcall BG_InitPlayerWeapons(playerState_s *ps)
{
  ?BG_InitPlayerWeapons@@YAXPEAUplayerState_s@@@Z(ps);
}

/*
==============
TagPair::IsEmpty
==============
*/

bool __fastcall TagPair::IsEmpty(TagPair *this)
{
  return ?IsEmpty@TagPair@@QEBA_NXZ(this);
}

/*
==============
BG_WeaponCharge_GetMeterBoneCount
==============
*/

unsigned int __fastcall BG_WeaponCharge_GetMeterBoneCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetMeterBoneCount@@YAIAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponAnglesForShootingDirection
==============
*/

void __fastcall BG_GetWeaponAnglesForShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t (*anglesCategorized)[30], vec3_t *outAngles)
{
  ?BG_GetWeaponAnglesForShootingDirection@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEAY0BO@$$CBTvec3_t@@AEAT4@@Z(weaponMap, ps, r_weapon, isAlternate, anglesCategorized, outAngles);
}

/*
==============
BG_DisableProjectileCrumpleCheck
==============
*/

bool __fastcall BG_DisableProjectileCrumpleCheck(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DisableProjectileCrumpleCheck@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountViewmodelOffset
==============
*/

double __fastcall BG_GetMountViewmodelOffset(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewmodelOffset@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_EndingGunKickPercent
==============
*/

double __fastcall BG_EndingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_EndingGunKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_ExplosionReactiveEmitterDelay
==============
*/

double __fastcall BG_ExplosionReactiveEmitterDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ExplosionReactiveEmitterDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponCharge_GetEmptyCooldown
==============
*/

double __fastcall BG_WeaponCharge_GetEmptyCooldown(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetEmptyCooldown@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetFirstEquippedWeaponBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedWeaponBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_GetFirstEquippedWeaponBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_GetFireTime
==============
*/

void __fastcall BG_GetFireTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  ?BG_GetFireTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3HPEAH4@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_GetMeleeDamage
==============
*/

int __fastcall BG_GetMeleeDamage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMeleeDamage@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHudOutlineScriptControlled
==============
*/

bool __fastcall BG_GetHudOutlineScriptControlled(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineScriptControlled@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_PlayerUsesNVGHalfADS
==============
*/

bool __fastcall BG_PlayerUsesNVGHalfADS(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_PlayerUsesNVGHalfADS@@YA_NPEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_UsingSniperScope
==============
*/

int __fastcall BG_UsingSniperScope(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UsingSniperScope@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetOtherAdsUpAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsUpAnim(const weapAnimFiles_t adsAnim)
{
  return ?BG_GetOtherAdsUpAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsAnim);
}

/*
==============
BG_IsBallPassValid
==============
*/

bool __fastcall BG_IsBallPassValid(const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsBallPassValid@@YA_NPEBUplayerState_s@@AEBUWeapon@@@Z(ps, r_weapon);
}

/*
==============
BG_GetFireTimerLerpToADSScale
==============
*/

double __fastcall BG_GetFireTimerLerpToADSScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetFireTimerLerpToADSScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsLadderWeapon
==============
*/

bool __fastcall BG_IsLadderWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsLadderWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsAnimInWeaponPackages
==============
*/

bool __fastcall BG_IsAnimInWeaponPackages(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const int meleeComboSeqIdx, const weapAnimFiles_t animType)
{
  return ?BG_IsAnimInWeaponPackages@@YA_NAEBUWeapon@@_N1HW4weapAnimFiles_t@@@Z(r_weapon, isAlternate, isDualWielding, meleeComboSeqIdx, animType);
}

/*
==============
BG_ValidateWeaponNumber
==============
*/

bool __fastcall BG_ValidateWeaponNumber(const Weapon *r_weapon)
{
  return ?BG_ValidateWeaponNumber@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetSprintAdditiveAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetSprintAdditiveAnim(weapAnimFiles_t relativeAnim)
{
  return ?BG_GetSprintAdditiveAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(relativeAnim);
}

/*
==============
BG_GetMeleeHeight
==============
*/

double __fastcall BG_GetMeleeHeight(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeHeight@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsBeamStyleTracer
==============
*/

bool __fastcall BG_IsBeamStyleTracer(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsBeamStyleTracer@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseLeftTriggerAltFireMode
==============
*/

bool __fastcall BG_UseLeftTriggerAltFireMode(const Weapon *r_weapon)
{
  return ?BG_UseLeftTriggerAltFireMode@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ViewShellEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewShellEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateLastWeaponHand
==============
*/

void __fastcall BG_UpdateLastWeaponHand(const BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *weapon)
{
  ?BG_UpdateLastWeaponHand@@YAXPEBVBgWeaponMap@@PEAUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, weapon);
}

/*
==============
BG_GetADSGunBobSettings
==============
*/

void __fastcall BG_GetADSGunBobSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *adsGunBobPitchScale, float *adsGunBobYawScale, float *adsGunBobTiltPitchScale, float *adsGunBobTiltYawScale, float *adsGunBobTiltRollScale, float *adsGunBobTiltOffset)
{
  ?BG_GetADSGunBobSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM44444@Z(weaponMap, ps, r_weapon, isAlternate, adsGunBobPitchScale, adsGunBobYawScale, adsGunBobTiltPitchScale, adsGunBobTiltYawScale, adsGunBobTiltRollScale, adsGunBobTiltOffset);
}

/*
==============
BG_HasThermalScope
==============
*/

bool __fastcall BG_HasThermalScope(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasThermalScope@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponHasStreamedModelsErrorCheck
==============
*/

bool __fastcall BG_WeaponHasStreamedModelsErrorCheck(const Weapon *weapon)
{
  return ?BG_WeaponHasStreamedModelsErrorCheck@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_InitClientWeapons
==============
*/

void __fastcall BG_InitClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  ?BG_InitClientWeapons@@YAXPEAVBgWeaponMap@@PEAUclientState_t@@@Z(weaponMap, cs);
}

/*
==============
BG_EquipWeapon
==============
*/

bool __fastcall BG_EquipWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_EquipWeapon@@YA_NPEAVBgWeaponMap@@PEAUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_ADSReloadFovXOffset
==============
*/

double __fastcall BG_ADSReloadFovXOffset(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSReloadFovXOffset@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(handler, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::SetPrimaryTagName
==============
*/

void __fastcall TagPair::SetPrimaryTagName(TagPair *this, scr_string_t tagName)
{
  ?SetPrimaryTagName@TagPair@@QEAAXW4scr_string_t@@@Z(this, tagName);
}

/*
==============
BG_BoltActionReloadIncludesRechamber
==============
*/

bool __fastcall BG_BoltActionReloadIncludesRechamber(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BoltActionReloadIncludesRechamber@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjBodyEffect
==============
*/

FxCombinedDef __fastcall BG_ProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjBodyEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetChargeUpSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeUpSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_WeapHasDetonator
==============
*/

bool __fastcall BG_WeapHasDetonator(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapHasDetonator@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StunnedTimeEnd
==============
*/

int __fastcall BG_StunnedTimeEnd(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeEnd@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_UpdatedWeaponBonesByModelRange
==============
*/

void __fastcall BG_UpdatedWeaponBonesByModelRange(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  ?BG_UpdatedWeaponBonesByModelRange@@YAXAEBUWeapon@@PEAUDObj@@HH@Z(r_weapon, obj, startModel, lastModelInclusive);
}

/*
==============
BG_GetMidDamage
==============
*/

void __fastcall BG_GetMidDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMid1Damage, int *outMid2Damage, int *outMid3Damage)
{
  ?BG_GetMidDamage@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NAEAH33@Z(damageCalcType, r_weapon, isAlternate, outMid1Damage, outMid2Damage, outMid3Damage);
}

/*
==============
BG_AltOverride3POutTime
==============
*/

int __fastcall BG_AltOverride3POutTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3POutTime@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsLastShotWeaponEvent
==============
*/

bool __fastcall BG_IsLastShotWeaponEvent(int event)
{
  return ?BG_IsLastShotWeaponEvent@@YA_NH@Z(event);
}

/*
==============
BG_IsMeleeOnlyWeapon
==============
*/

bool __fastcall BG_IsMeleeOnlyWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsMeleeOnlyWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSfxPackageSoundLookup
==============
*/

SndAliasLookup __fastcall BG_GetWeaponSfxPackageSoundLookup(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSoundLookup@@YA?AUSndAliasLookup@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_GetMeleeAutoAimMaxYawMovement
==============
*/

double __fastcall BG_GetMeleeAutoAimMaxYawMovement(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimMaxYawMovement@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AltDropADSTime
==============
*/

int __fastcall BG_AltDropADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropADSTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetFirstAvailableOffhandByClass
==============
*/

const Weapon *__fastcall BG_GetFirstAvailableOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return ?BG_GetFirstAvailableOffhandByClass@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@H@Z(weaponMap, ps, offhandClass);
}

/*
==============
BG_GetMeleeRange
==============
*/

double __fastcall BG_GetMeleeRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const bool getChargeRange)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeRange@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@_N@Z(weaponMap, ps, getChargeRange);
  return result;
}

/*
==============
BG_ScopeOutlinesVehicles
==============
*/

bool __fastcall BG_ScopeOutlinesVehicles(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesVehicles@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_EndingViewKickPercent
==============
*/

double __fastcall BG_EndingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_EndingViewKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_ScopeToggleOnTime
==============
*/

int __fastcall BG_ScopeToggleOnTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOnTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasUnderbarrelWeapon
==============
*/

int __fastcall BG_HasUnderbarrelWeapon(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelWeapon@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetWeaponSoundWithFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSoundWithFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundWithFallback@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_AddParachuteModel
==============
*/

int __fastcall BG_AddParachuteModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddParachuteModel@@YAHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetMeleeAutoAimLerp
==============
*/

double __fastcall BG_GetMeleeAutoAimLerp(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimLerp@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetDamageRange
==============
*/

void __fastcall BG_GetDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *minDamageRange, float *maxDamageRange)
{
  ?BG_GetDamageRange@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NMPEAM3@Z(damageCalcType, r_weapon, isAlternate, rangeScale, minDamageRange, maxDamageRange);
}

/*
==============
BG_GetUnderbarrelAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetUnderbarrelAttachment(const Weapon *r_weapon)
{
  return ?BG_GetUnderbarrelAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetMountViewCenterScale
==============
*/

double __fastcall BG_GetMountViewCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewCenterScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_BreachRaiseTime
==============
*/

int __fastcall BG_BreachRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BreachRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObj
==============
*/

void __fastcall BG_UpdateWeaponHidePartBitsForDObj(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel)
{
  ?BG_UpdateWeaponHidePartBitsForDObj@@YAXPEAUDObj@@AEBUWeapon@@_NH@Z(obj, r_weapon, isViewModel, startModel);
}

/*
==============
BG_ReloadEndRechamberInterruptTime
==============
*/

int __fastcall BG_ReloadEndRechamberInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEndRechamberInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ScopeOutlinesTurrets
==============
*/

bool __fastcall BG_ScopeOutlinesTurrets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesTurrets@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasLadderHand
==============
*/

bool __fastcall BG_HasLadderHand(const playerState_s *ps)
{
  return ?BG_HasLadderHand@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_ReloadEmptyAddTime
==============
*/

int __fastcall BG_ReloadEmptyAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEmptyAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2HAEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetViewKickMaintainFraction
==============
*/

double __fastcall BG_GetViewKickMaintainFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetViewKickMaintainFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_PlayerWeaponCountWeaponsBySlot
==============
*/

unsigned int __fastcall BG_PlayerWeaponCountWeaponsBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_PlayerWeaponCountWeaponsBySlot@@YAIPEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_GetOverlayReticle
==============
*/

weapOverlayReticle_t __fastcall BG_GetOverlayReticle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOverlayReticle@@YA?AW4weapOverlayReticle_t@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_NoADSWhenMagIsEmpty
==============
*/

bool __fastcall BG_NoADSWhenMagIsEmpty(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_NoADSWhenMagIsEmpty@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponIsDualWield
==============
*/

bool __fastcall BG_WeaponIsDualWield(const Weapon *r_weapon)
{
  return ?BG_WeaponIsDualWield@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_AnyUnderbarrelWeaponEquipped
==============
*/

int __fastcall BG_AnyUnderbarrelWeaponEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_AnyUnderbarrelWeaponEquipped@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_SkydiveParachuteFastLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteFastLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteFastLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_SprintInTime
==============
*/

int __fastcall BG_SprintInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetViewKickSpeed
==============
*/

void __fastcall BG_GetViewKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickAccel, float *hipViewKickReturnAccelScale, float *hipViewKickReturnSpeedCurveScale, float *adsViewKickAccel, float *adsViewKickReturnAccelScale, float *adsViewKickReturnSpeedCurveScale)
{
  ?BG_GetViewKickSpeed@@YAXPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_NPEAM44444@Z(weaponMap, ps, r_weapon, isAlternate, hipViewKickAccel, hipViewKickReturnAccelScale, hipViewKickReturnSpeedCurveScale, adsViewKickAccel, adsViewKickReturnAccelScale, adsViewKickReturnSpeedCurveScale);
}

/*
==============
BG_ProjExplosionEffect
==============
*/

FxCombinedDef __fastcall BG_ProjExplosionEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetEnemyLaserType
==============
*/

const LaserDef *__fastcall BG_GetEnemyLaserType(const Weapon *r_weapon, bool isBeamDraw)
{
  return ?BG_GetEnemyLaserType@@YAPEBULaserDef@@AEBUWeapon@@_N@Z(r_weapon, isBeamDraw);
}

/*
==============
BG_GetMoveSpeedScale
==============
*/

void __fastcall BG_GetMoveSpeedScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *moveSpeedScaleOut, float *adsMoveSpeedScaleOut)
{
  ?BG_GetMoveSpeedScale@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, moveSpeedScaleOut, adsMoveSpeedScaleOut);
}

/*
==============
BG_ADSResetZoomLevelOnToggle
==============
*/

bool __fastcall BG_ADSResetZoomLevelOnToggle(BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSResetZoomLevelOnToggle@@YA_NPEAVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_QuickRaiseTime
==============
*/

int __fastcall BG_QuickRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_QuickRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_TurretMaxCorrectionAngle
==============
*/

double __fastcall BG_TurretMaxCorrectionAngle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_TurretMaxCorrectionAngle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponsUtil_ChooseNextWeaponIdx
==============
*/

unsigned __int16 __fastcall BG_WeaponsUtil_ChooseNextWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  return ?BG_WeaponsUtil_ChooseNextWeaponIdx@@YAGPEAIG@Z(randSeed, lastWeaponIdx);
}

/*
==============
BG_GetCenterReticle
==============
*/

void __fastcall BG_GetCenterReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleCenter, int *reticleCenterSize, bool *shouldPulse)
{
  ?BG_GetCenterReticle@@YAXAEBUWeapon@@_NPEAPEAUMaterial@@PEAHPEA_N@Z(r_weapon, isAlternate, reticleCenter, reticleCenterSize, shouldPulse);
}

/*
==============
BG_IsADSFireOnly
==============
*/

bool __fastcall BG_IsADSFireOnly(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsADSFireOnly@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveFreefallRaiseTime
==============
*/

int __fastcall BG_SkydiveFreefallRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveFreefallRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_ProceduralGunMotionDisabled
==============
*/

bool __fastcall BG_ProceduralGunMotionDisabled(const playerState_s *ps)
{
  return ?BG_ProceduralGunMotionDisabled@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_WeaponADSFractionAffectedByReload
==============
*/

double __fastcall BG_WeaponADSFractionAffectedByReload(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_WeaponADSFractionAffectedByReload@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_CurrentWeaponSupportsDualFOV
==============
*/

bool __fastcall BG_CurrentWeaponSupportsDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_CurrentWeaponSupportsDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_UseAngularGunKick
==============
*/

bool __fastcall BG_UseAngularGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseAngularGunKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ExplosionForceScalar
==============
*/

double __fastcall BG_ExplosionForceScalar(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ExplosionForceScalar@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_TurretSpinSound
==============
*/

SndAliasLookup __fastcall BG_TurretSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretSpinSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ScopeToggleOffTime
==============
*/

int __fastcall BG_ScopeToggleOffTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOffTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineFill
==============
*/

bool __fastcall BG_GetHudOutlineFill(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineFill@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_KickAngles
==============
*/

void __fastcall BG_KickAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, int updateFrameTime, int *inOutKickTimeRemaining, vec3_t *inOutKickAVel, vec3_t *inOutRawKickAngles, vec3_t *outKickAngles, bool *inOutKickNeedsToCrossCenter)
{
  ?BG_KickAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@HAEAHAEATvec3_t@@33AEA_N@Z(weaponMap, ps, updateFrameTime, inOutKickTimeRemaining, inOutKickAVel, inOutRawKickAngles, outKickAngles, inOutKickNeedsToCrossCenter);
}

/*
==============
BG_HasForegrip
==============
*/

int __fastcall BG_HasForegrip(const Weapon *r_weapon)
{
  return ?BG_HasForegrip@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_HasHoldBreathAbility
==============
*/

int __fastcall BG_HasHoldBreathAbility(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_HasHoldBreathAbility@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetAttachmentModel
==============
*/

const XModel *__fastcall BG_GetAttachmentModel(const WeaponAttachment *weaponAttachment, const int attachmentVariationIndex, bool isViewModel)
{
  return ?BG_GetAttachmentModel@@YAPEBUXModel@@PEBUWeaponAttachment@@H_N@Z(weaponAttachment, attachmentVariationIndex, isViewModel);
}

/*
==============
BG_UsesContinousAdsIdleTransiton
==============
*/

bool __fastcall BG_UsesContinousAdsIdleTransiton(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesContinousAdsIdleTransiton@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountRumble
==============
*/

RumbleInfo *__fastcall BG_GetMountRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMountRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAngularViewKickSettings
==============
*/

void __fastcall BG_GetAngularViewKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularViewKickDir, float *hipAngularViewKickDev, float *hipAngularViewKickStrengthMin, float *hipAngularViewKickStrengthMax, float *hipAngularViewKickPitchScale, float *adsAngularViewKickDir, float *adsAngularViewKickDev, float *adsAngularViewKickStrengthMin, float *adsAngularViewKickStrengthMax, float *adsAngularViewKickPitchScale)
{
  ?BG_GetAngularViewKickSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NHPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, bulletNum, hipAngularViewKickDir, hipAngularViewKickDev, hipAngularViewKickStrengthMin, hipAngularViewKickStrengthMax, hipAngularViewKickPitchScale, adsAngularViewKickDir, adsAngularViewKickDev, adsAngularViewKickStrengthMin, adsAngularViewKickStrengthMax, adsAngularViewKickPitchScale);
}

/*
==============
BG_ScopeOutlinesLockOn
==============
*/

bool __fastcall BG_ScopeOutlinesLockOn(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesLockOn@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasVariableZoom
==============
*/

bool __fastcall BG_HasVariableZoom(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasVariableZoom@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetLocationDamageMultipliers
==============
*/

const float *__fastcall BG_GetLocationDamageMultipliers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetLocationDamageMultipliers@@YAPEBMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HoldingBreath
==============
*/

int __fastcall BG_HoldingBreath(const playerState_s *ps)
{
  return ?BG_HoldingBreath@@YAHPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetMountTransitionEnabled
==============
*/

bool __fastcall BG_GetMountTransitionEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMountTransitionEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_RequireAmmoUsedPerShot
==============
*/

bool __fastcall BG_RequireAmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RequireAmmoUsedPerShot@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TurretSpawnsProjectileAtMuzzle
==============
*/

bool __fastcall BG_TurretSpawnsProjectileAtMuzzle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretSpawnsProjectileAtMuzzle@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadInterruptTime
==============
*/

int __fastcall BG_ReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ClearClientWeapons
==============
*/

void __fastcall BG_ClearClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  ?BG_ClearClientWeapons@@YAXPEAVBgWeaponMap@@PEAUclientState_t@@@Z(weaponMap, cs);
}

/*
==============
BG_GetFootstepFromGesture
==============
*/

FootstepAnimType __fastcall BG_GetFootstepFromGesture(gestureAnimType_t gestureIndex)
{
  return ?BG_GetFootstepFromGesture@@YA?AW4FootstepAnimType@@W4gestureAnimType_t@@@Z(gestureIndex);
}

/*
==============
BG_GetAdsLastShotAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsLastShotAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsLastShotAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_IsRifleBullet
==============
*/

bool __fastcall BG_IsRifleBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsRifleBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateWeaponGlass
==============
*/

void __fastcall BG_UpdateWeaponGlass(const float adsFrac, DObj *const obj, const bool adsSmoothFade)
{
  ?BG_UpdateWeaponGlass@@YAXMQEAUDObj@@_N@Z(adsFrac, obj, adsSmoothFade);
}

/*
==============
BG_CanHybridToggle
==============
*/

bool __fastcall BG_CanHybridToggle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanHybridToggle@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeAnimState
==============
*/

bool __fastcall BG_IsMeleeAnimState(int animState)
{
  return ?BG_IsMeleeAnimState@@YA_NH@Z(animState);
}

/*
==============
BG_LadderAimADSRaiseTime
==============
*/

int __fastcall BG_LadderAimADSRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimADSRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsWeaponValid
==============
*/

bool __fastcall BG_IsWeaponValid(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsWeaponValid@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_PlayerLastWeaponHandForViewWeapon
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHandForViewWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_PlayerLastWeaponHandForViewWeapon@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_CalculateKickPolar
==============
*/

void __fastcall BG_CalculateKickPolar(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel)
{
  ?BG_CalculateKickPolar@@YAXPEBVBgWeaponMap@@_NPEBUplayerState_s@@AEBUWeapon@@_NPEAIPEAM6@Z(weaponMap, isViewKick, ps, r_weapon, isAlternate, holdrand, outPitchAVel, outYawAVel);
}

/*
==============
BG_HideBone
==============
*/

unsigned __int8 __fastcall BG_HideBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return ?BG_HideBone@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@H@Z(bone, obj, partBits, startModel);
}

/*
==============
BG_GetHeatProperties
==============
*/

void __fastcall BG_GetHeatProperties(const Weapon *weapon, const bool isAlternate, float *outAccumulationPerShot, float *outDissipationPerSecond)
{
  ?BG_GetHeatProperties@@YAXAEBUWeapon@@_NAEAM2@Z(weapon, isAlternate, outAccumulationPerShot, outDissipationPerSecond);
}

/*
==============
BG_GetLUICrosshairWidget
==============
*/

const char *__fastcall BG_GetLUICrosshairWidget(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetLUICrosshairWidget@@YAPEBDAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ClearAgentWeapons
==============
*/

void __fastcall BG_ClearAgentWeapons(BgWeaponMap *weaponMap, agentState_s *as)
{
  ?BG_ClearAgentWeapons@@YAXPEAVBgWeaponMap@@PEAUagentState_s@@@Z(weaponMap, as);
}

/*
==============
BG_ConvertWeaponToHexString
==============
*/

void __fastcall BG_ConvertWeaponToHexString(const Weapon *r_weapon, char *outHexString, int outStringLength)
{
  ?BG_ConvertWeaponToHexString@@YAXAEBUWeapon@@PEADH@Z(r_weapon, outHexString, outStringLength);
}

/*
==============
BG_ProjDudSound
==============
*/

const SndAliasList *__fastcall BG_ProjDudSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDudSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ADSReloadTransTime
==============
*/

int __fastcall BG_ADSReloadTransTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSReloadTransTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelEntityState
==============
*/

int __fastcall BG_WeaponDoesNotFullyAnimateViewmodelEntityState(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponDoesNotFullyAnimateViewmodelEntityState@@YAHPEBUentityState_t@@AEBUWeapon@@_N@Z(es, r_weapon, isAlternate);
}

/*
==============
BG_IsPlayingLadderAnims
==============
*/

bool __fastcall BG_IsPlayingLadderAnims(const characterInfo_t *ci)
{
  return ?BG_IsPlayingLadderAnims@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BG_HipSpreadFireAdd
==============
*/

double __fastcall BG_HipSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_HipSpreadFireAdd@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetTargetAssistType
==============
*/

targetAssistType_t __fastcall BG_GetTargetAssistType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTargetAssistType@@YA?AW4targetAssistType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_Weapons_GetScriptedAnimEvent
==============
*/

scriptedAnimEvent_t __fastcall BG_Weapons_GetScriptedAnimEvent(const Weapon *offHandWeapon)
{
  return ?BG_Weapons_GetScriptedAnimEvent@@YA?AW4scriptedAnimEvent_t@@AEBUWeapon@@@Z(offHandWeapon);
}

/*
==============
BG_GetSprintOutTimeScale
==============
*/

double __fastcall BG_GetSprintOutTimeScale(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetSprintOutTimeScale@@YAMPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSwayScalar
==============
*/

double __fastcall BG_GetSwayScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const int gameTime)
{
  double result; 

  *(float *)&result = ?BG_GetSwayScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH@Z(weaponMap, ps, r_weapon, isAlternate, gameTime);
  return result;
}

/*
==============
BG_IsWeaponRecoilDelayed
==============
*/

bool __fastcall BG_IsWeaponRecoilDelayed(const pmove_t *pm, const playerState_s *ps)
{
  return ?BG_IsWeaponRecoilDelayed@@YA_NPEBVpmove_t@@PEBUplayerState_s@@@Z(pm, ps);
}

/*
==============
BG_GetScopeDriftLerpInTime
==============
*/

double __fastcall BG_GetScopeDriftLerpInTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftLerpInTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSprintAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetSprintAnim(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t relativeAnim)
{
  return ?BG_GetSprintAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@AEBUWeapon@@_N2W41@@Z(ps, r_weapon, isAlternate, isDualWielding, relativeAnim);
}

/*
==============
BG_WeaponCharge_GetLossWhenIdle
==============
*/

double __fastcall BG_WeaponCharge_GetLossWhenIdle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetLossWhenIdle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AutoAimRange
==============
*/

double __fastcall BG_AutoAimRange(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_AutoAimRange@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSZoomFov
==============
*/

double __fastcall BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSZoomFov@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(handler, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetADSGunBobBulletDirScale
==============
*/

double __fastcall BG_GetADSGunBobBulletDirScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSGunBobBulletDirScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetAllWeaponAttachments
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachments(const Weapon *r_weapon, const WeaponAttachment **attachments)
{
  return ?BG_GetAllWeaponAttachments@@YAIAEBUWeapon@@QEAPEBUWeaponAttachment@@@Z(r_weapon, attachments);
}

/*
==============
BG_AmmoUsedPerShot
==============
*/

int __fastcall BG_AmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AmmoUsedPerShot@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMeleeRangeByWeapon
==============
*/

double __fastcall BG_GetMeleeRangeByWeapon(const Weapon *r_weapon, const bool isAlternate, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance, const bool isSliding)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeRangeByWeapon@@YAMAEBUWeapon@@_N11W4EffectiveStance@@1@Z(r_weapon, isAlternate, getChargeRange, hasExtendedMelee, stance, isSliding);
  return result;
}

/*
==============
BG_GetMeleeCountToFinisher
==============
*/

bool __fastcall BG_GetMeleeCountToFinisher(const Weapon *r_weapon, bool isAlternate, int *outCountToFinisher)
{
  return ?BG_GetMeleeCountToFinisher@@YA_NAEBUWeapon@@_NPEAH@Z(r_weapon, isAlternate, outCountToFinisher);
}

/*
==============
BG_WeaponAIFuseTime
==============
*/

int __fastcall BG_WeaponAIFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponAIFuseTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetBallisticMuzzleVelocityScale
==============
*/

double __fastcall BG_GetBallisticMuzzleVelocityScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBallisticMuzzleVelocityScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_SkydiveParachuteSlowHardLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteSlowHardLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteSlowHardLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetTurretFireType
==============
*/

turretFireType_t __fastcall BG_GetTurretFireType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTurretFireType@@YA?AW4turretFireType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_InheritsPerks
==============
*/

bool __fastcall BG_InheritsPerks(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_InheritsPerks@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseFastReload
==============
*/

bool __fastcall BG_UseFastReload(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseFastReload@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetScopeLensSettings
==============
*/

void __fastcall BG_GetScopeLensSettings(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  ?BG_GetScopeLensSettings@@YAXPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NMAEBUBgHybridScopeFraction@@PEAUGfxScopeInfo@@@Z(handler, ps, r_weapon, isAlternate, adsFrac, hybridScopeFraction, settingOut);
}

/*
==============
BG_AltOverride3PInTime
==============
*/

int __fastcall BG_AltOverride3PInTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3PInTime@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineDepthTest
==============
*/

bool __fastcall BG_GetHudOutlineDepthTest(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineDepthTest@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_AddWeaponAttachmentModels
==============
*/

void __fastcall BG_AddWeaponAttachmentModels(const Weapon *r_weapon, const PlayerHandIndex hand, bool isDualWield, bool useViewModel, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels, const DObjCamoParams *camoParams)
{
  ?BG_AddWeaponAttachmentModels@@YAXAEBUWeapon@@W4PlayerHandIndex@@_N222PEAUDObjModel@@GPEAGPEAVXAnimWeaponIKModelsContainer@@PEBUDObjCamoParams@@@Z(r_weapon, hand, isDualWield, useViewModel, ignoreCollision, stowedWeapon, dobjModels, maxModels, numModels, outWeaponIKModels, camoParams);
}

/*
==============
BG_GetTargetAssistBehavior
==============
*/

targetAssistBehavior_t __fastcall BG_GetTargetAssistBehavior(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTargetAssistBehavior@@YA?AW4targetAssistBehavior_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeOnlyAxe
==============
*/

bool __fastcall BG_IsMeleeOnlyAxe(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsMeleeOnlyAxe@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ExplodeOnImpact
==============
*/

bool __fastcall BG_WeaponBulletFire_ExplodeOnImpact(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ExplodeOnImpact@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_GetADSSwayScalars
==============
*/

void __fastcall BG_GetADSSwayScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsSwayMaxAngleScale, float *outAdsSwayLerpSpeedScale, float *outAdsSwayScaleScale)
{
  ?BG_GetADSSwayScalars@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM44@Z(weaponMap, ps, r_weapon, isAlternate, outAdsSwayMaxAngleScale, outAdsSwayLerpSpeedScale, outAdsSwayScaleScale);
}

/*
==============
BG_GetHudOutlineWidth
==============
*/

double __fastcall BG_GetHudOutlineWidth(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_GetHudOutlineWidth@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_GetWeaponThermalPlayerFadeDistStartAndEnd
==============
*/

bool __fastcall BG_GetWeaponThermalPlayerFadeDistStartAndEnd(const Weapon *r_weapon, const bool isAlternate, vec2_t *outStartAndEnd)
{
  return ?BG_GetWeaponThermalPlayerFadeDistStartAndEnd@@YA_NAEBUWeapon@@_NAEATvec2_t@@@Z(r_weapon, isAlternate, outStartAndEnd);
}

/*
==============
BG_ProjectileActivateDist
==============
*/

int __fastcall BG_ProjectileActivateDist(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjectileActivateDist@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponType
==============
*/

weapType_t __fastcall BG_GetWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponType@@YA?AW4weapType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ValidateWeapon
==============
*/

bool __fastcall BG_ValidateWeapon(const Weapon *r_weapon)
{
  return ?BG_ValidateWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteSlowSoftLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteSlowSoftLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetADSReloadNVGFOV
==============
*/

double __fastcall BG_GetADSReloadNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  double result; 

  *(float *)&result = ?BG_GetADSReloadNVGFOV@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, getWeaponValues);
  return result;
}

/*
==============
BG_CanAttachmentHybridToggle
==============
*/

bool __fastcall BG_CanAttachmentHybridToggle(const WeaponAttachment *attachment)
{
  return ?BG_CanAttachmentHybridToggle@@YA_NPEBUWeaponAttachment@@@Z(attachment);
}

/*
==============
BG_WeaponBulletFire_GetHitEvent
==============
*/

unsigned int __fastcall BG_WeaponBulletFire_GetHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  return ?BG_WeaponBulletFire_GetHitEvent@@YAII_N@Z(meansOfDeath, serverPlayerHitEvent);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteSlowSoftLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteSlowSoftLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BG_SlideSpreadFireAdd
==============
*/

double __fastcall BG_SlideSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_SlideSpreadFireAdd@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_Weapons_AttachWorldIKTargets
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachWorldIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModel, bool isServer, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachWorldIKTargets@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAUXModel@@_NAEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, ikTargetModel, isServer, outModelTypes);
}

/*
==============
BG_GetHudOutlineAltInScopeColor
==============
*/

void __fastcall BG_GetHudOutlineAltInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineAltInScopeColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetOtherAdsDownAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsDownAnim(const weapAnimFiles_t adsAnim)
{
  return ?BG_GetOtherAdsDownAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsAnim);
}

/*
==============
BG_HasDefaultViewModel
==============
*/

bool __fastcall BG_HasDefaultViewModel(const Weapon *r_weapon)
{
  return ?BG_HasDefaultViewModel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_CanPlayerHaveWeapon
==============
*/

bool __fastcall BG_CanPlayerHaveWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanPlayerHaveWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSCrosshairBlendFracs
==============
*/

void __fastcall BG_GetADSCrosshairBlendFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool adsIn, float *outBlendStart, float *outBlendEnd)
{
  ?BG_GetADSCrosshairBlendFracs@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3PEAM4@Z(weaponMap, ps, r_weapon, isAlternate, adsIn, outBlendStart, outBlendEnd);
}

/*
==============
BG_IsRiotShield
==============
*/

bool __fastcall BG_IsRiotShield(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsRiotShield@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveParachuteDetachTime
==============
*/

int __fastcall BG_SkydiveParachuteDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteDetachTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsTopMountYawClamped
==============
*/

bool __fastcall BG_IsTopMountYawClamped(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsTopMountYawClamped@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerLastWeaponHandForWeapon
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHandForWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_PlayerLastWeaponHandForWeapon@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_IsWeaponLaserEndViewCenterInAds
==============
*/

bool __fastcall BG_IsWeaponLaserEndViewCenterInAds(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsWeaponLaserEndViewCenterInAds@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_AdvanceWeapon
==============
*/

bool __fastcall BG_WeaponsUtil_AdvanceWeapon(Weapon *inOutWeapon)
{
  return ?BG_WeaponsUtil_AdvanceWeapon@@YA_NAEAUWeapon@@@Z(inOutWeapon);
}

/*
==============
BG_IsBoltAction
==============
*/

bool __fastcall BG_IsBoltAction(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsBoltAction@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ViewFlashADSEffect
==============
*/

FxCombinedDef __fastcall BG_ViewFlashADSEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_ViewFlashADSEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_UniqueAmmoUnderbarrelAttachment
==============
*/

const WeaponAttachment *__fastcall BG_UniqueAmmoUnderbarrelAttachment(const Weapon *weapon, const bool isAlternate)
{
  return ?BG_UniqueAmmoUnderbarrelAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@_N@Z(weapon, isAlternate);
}

/*
==============
BG_CalculateKickBox
==============
*/

void __fastcall BG_CalculateKickBox(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel, float *outMinMagnitude)
{
  ?BG_CalculateKickBox@@YAXPEBVBgWeaponMap@@_NPEBUplayerState_s@@AEBUWeapon@@_NPEAIPEAM66@Z(weaponMap, isViewKick, ps, r_weapon, isAlternate, holdrand, outPitchAVel, outYawAVel, outMinMagnitude);
}

/*
==============
BG_ProjExplosionSound
==============
*/

const SndAliasList *__fastcall BG_ProjExplosionSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsUsingDualFOV
==============
*/

bool __fastcall BG_IsUsingDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_IsUsingDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
TagPair::GetPrimaryTagName
==============
*/

scr_string_t __fastcall TagPair::GetPrimaryTagName(TagPair *this)
{
  return ?GetPrimaryTagName@TagPair@@QEBA?AW4scr_string_t@@XZ(this);
}

/*
==============
BG_HideSniperScene
==============
*/

void __fastcall BG_HideSniperScene(const Weapon *r_weapon, DObj *obj)
{
  ?BG_HideSniperScene@@YAXAEBUWeapon@@PEAUDObj@@@Z(r_weapon, obj);
}

/*
==============
BG_Weapon_FiresOnWeaponSwitch
==============
*/

int __fastcall BG_Weapon_FiresOnWeaponSwitch(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_FiresOnWeaponSwitch@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeapDetonateType
==============
*/

WeapDetonateType __fastcall BG_WeapDetonateType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapDetonateType@@YA?AW4WeapDetonateType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasVRScope
==============
*/

bool __fastcall BG_HasVRScope(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_HasVRScope@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponExplicitHideTags
==============
*/

void __fastcall BG_GetWeaponExplicitHideTags(const Weapon *r_weapon, const bool isAlternate, const bool isViewModel, const unsigned __int64 hideTagBufferSize, scr_string_t *outHideTagBuffer, unsigned __int64 *outHideTagCount)
{
  ?BG_GetWeaponExplicitHideTags@@YAXAEBUWeapon@@_N1_KQEAW4scr_string_t@@PEA_K@Z(r_weapon, isAlternate, isViewModel, hideTagBufferSize, outHideTagBuffer, outHideTagCount);
}

/*
==============
BG_ProjTrailEffect
==============
*/

FxCombinedDef __fastcall BG_ProjTrailEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTrailEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHybridScopeEnablerAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetHybridScopeEnablerAttachment(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **outDataAttachment)
{
  return ?BG_GetHybridScopeEnablerAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@_NPEAPEBU1@@Z(r_weapon, isAlternate, outDataAttachment);
}

/*
==============
BG_ShowHideTagsBasedOnAltMode
==============
*/

void __fastcall BG_ShowHideTagsBasedOnAltMode(const Weapon *r_weapon, DObj *obj, bool isAlternate, bool raisingToAlt, bool hideReticle, bool overrideHamr, bool hamrOn)
{
  ?BG_ShowHideTagsBasedOnAltMode@@YAXAEBUWeapon@@PEAUDObj@@_N2222@Z(r_weapon, obj, isAlternate, raisingToAlt, hideReticle, overrideHamr, hamrOn);
}

/*
==============
TagPair::TagPair
==============
*/

void __fastcall TagPair::TagPair(TagPair *this, scr_string_t primaryTagName, scr_string_t fallbackTagName)
{
  ??0TagPair@@QEAA@W4scr_string_t@@0@Z(this, primaryTagName, fallbackTagName);
}

/*
==============
BG_IsFistsWeapon
==============
*/

bool __fastcall BG_IsFistsWeapon(const Weapon *r_weapon)
{
  return ?BG_IsFistsWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_WeaponGetNotetrackMilliseconds
==============
*/

int __fastcall BG_WeaponGetNotetrackMilliseconds(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler, const scr_string_t notetrackName, int *outDuration)
{
  return ?BG_WeaponGetNotetrackMilliseconds@@YAHPEBUplayerState_s@@W4PlayerHandIndex@@_NW4weapAnimFiles_t@@PEBVBgHandler@@W4scr_string_t@@PEAH@Z(ps, hand, bIsAlternate, eWeaponAnim, pmoveHandler, notetrackName, outDuration);
}

/*
==============
BG_WeaponCharge_GetHudReveal
==============
*/

bool __fastcall BG_WeaponCharge_GetHudReveal(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetHudReveal@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsBeamWeapon
==============
*/

bool __fastcall BG_IsBeamWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsBeamWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_FireSound
==============
*/

const SndAliasList *__fastcall BG_FireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_FireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_ADSZoomFov
==============
*/

double __fastcall BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, const bool getWeaponValues, bool *outIsNVGForcedFov)
{
  double result; 

  *(float *)&result = ?BG_ADSZoomFov@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@_NAEA_N@Z(handler, ps, r_weapon, isAlternate, hybridScopeFractionInfo, getWeaponValues, outIsNVGForcedFov);
  return result;
}

/*
==============
BG_GetAllWeaponAttachmentsWithIds
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachmentsWithIds(const Weapon *r_weapon, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return ?BG_GetAllWeaponAttachmentsWithIds@@YAIAEBUWeapon@@QEAPEBUWeaponAttachment@@QEAE@Z(r_weapon, attachments, attachmentIds);
}

/*
==============
BG_IsWeaponUsableInState
==============
*/

bool __fastcall BG_IsWeaponUsableInState(const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsWeaponUsableInState@@YA_NPEBUplayerState_s@@AEBUWeapon@@@Z(ps, r_weapon);
}

/*
==============
BG_OffhandUnderbarrelInitAllowed
==============
*/

int __fastcall BG_OffhandUnderbarrelInitAllowed(const playerState_s *ps)
{
  return ?BG_OffhandUnderbarrelInitAllowed@@YAHPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetProjectileSpeed
==============
*/

void __fastcall BG_GetProjectileSpeed(const Weapon *r_weapon, bool isAlternate, int *projectileSpeed, int *projectileSpeedUp)
{
  ?BG_GetProjectileSpeed@@YAXAEBUWeapon@@_NPEAH2@Z(r_weapon, isAlternate, projectileSpeed, projectileSpeedUp);
}

/*
==============
BG_ViewModelBlendSpaceExists
==============
*/

int __fastcall BG_ViewModelBlendSpaceExists(const playerState_s *ps, WeaponBlendSpaceType blendSpaceType, const BgHandler *pmoveHandler)
{
  return ?BG_ViewModelBlendSpaceExists@@YAHPEBUplayerState_s@@W4WeaponBlendSpaceType@@PEBVBgHandler@@@Z(ps, blendSpaceType, pmoveHandler);
}

/*
==============
BG_UseAngularViewKick
==============
*/

bool __fastcall BG_UseAngularViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseAngularViewKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetScopeAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetScopeAttachment(const Weapon *r_weapon)
{
  return ?BG_GetScopeAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetKickOpposedInputScalar
==============
*/

double __fastcall BG_GetKickOpposedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetKickOpposedInputScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsAdsVisionSetActive
==============
*/

bool __fastcall BG_IsAdsVisionSetActive(const BgHandler *handler, const playerState_s *ps, const Weapon *weapon, bool isAlternate, BgAdsVisionSetInfo *outVisionSetInfo)
{
  return ?BG_IsAdsVisionSetActive@@YA_NPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NAEAUBgAdsVisionSetInfo@@@Z(handler, ps, weapon, isAlternate, outVisionSetInfo);
}

/*
==============
BG_Weapon_GetPrimaryAttachmentIndex
==============
*/

unsigned __int16 __fastcall BG_Weapon_GetPrimaryAttachmentIndex(const Weapon *weapon, const AttachmentSlot *slot)
{
  return ?BG_Weapon_GetPrimaryAttachmentIndex@@YAGAEBUWeapon@@AEBW4AttachmentSlot@@@Z(weapon, slot);
}

/*
==============
BG_HeatSmokeEffect
==============
*/

void __fastcall BG_HeatSmokeEffect(const Weapon *r_weapon, bool isAlternate, bool isViewmodel, FxCombinedDef *muzzleSmoke, FxCombinedDef *barrelSmoke, FxCombinedDef *ejectionPortSmoke)
{
  ?BG_HeatSmokeEffect@@YAXAEBUWeapon@@_N1PEAUFxCombinedDef@@22@Z(r_weapon, isAlternate, isViewmodel, muzzleSmoke, barrelSmoke, ejectionPortSmoke);
}

/*
==============
BG_ProjectileModel
==============
*/

XModel *__fastcall BG_ProjectileModel(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjectileModel@@YAPEAUXModel@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSViewBobSettingsScale
==============
*/

double __fastcall BG_GetADSViewBobSettingsScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSViewBobSettingsScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_MapWeaponAnimIndexToMeleeIndex
==============
*/

weapMeleeAnimFiles_t __fastcall BG_MapWeaponAnimIndexToMeleeIndex(weapAnimFiles_t animIndex)
{
  return ?BG_MapWeaponAnimIndexToMeleeIndex@@YA?AW4weapMeleeAnimFiles_t@@W4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_WeaponSticksToTurrets
==============
*/

bool __fastcall BG_WeaponSticksToTurrets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToTurrets@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsOffhandWeaponType
==============
*/

int __fastcall BG_IsOffhandWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsOffhandWeaponType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasUnderbarrelAmmo
==============
*/

bool __fastcall BG_HasUnderbarrelAmmo(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelAmmo@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetADSZoomLevelFraction
==============
*/

double __fastcall BG_GetADSZoomLevelFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const int gameTime)
{
  double result; 

  *(float *)&result = ?BG_GetADSZoomLevelFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH@Z(weaponMap, ps, weapon, isAlternate, gameTime);
  return result;
}

/*
==============
BG_StunnedTimeBegin
==============
*/

int __fastcall BG_StunnedTimeBegin(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeBegin@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadTime
==============
*/

int __fastcall BG_ReloadTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetScopeDriftSteadyFactor
==============
*/

double __fastcall BG_GetScopeDriftSteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftSteadyFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_StartAmmo
==============
*/

int __fastcall BG_StartAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  return ?BG_StartAmmo@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, hasIncreasedOffhandAmmoPerk);
}

/*
==============
BG_UseFastOffhand
==============
*/

bool __fastcall BG_UseFastOffhand(const playerState_s *ps, const BgWeaponMap *weaponMap)
{
  return ?BG_UseFastOffhand@@YA_NPEBUplayerState_s@@PEBVBgWeaponMap@@@Z(ps, weaponMap);
}

/*
==============
BG_ShowBone
==============
*/

unsigned __int8 __fastcall BG_ShowBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return ?BG_ShowBone@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@H@Z(bone, obj, partBits, startModel);
}

/*
==============
BG_SyncedFOVInDualFOV
==============
*/

bool __fastcall BG_SyncedFOVInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SyncedFOVInDualFOV@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsFauxFists
==============
*/

bool __fastcall BG_IsFauxFists(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsFauxFists@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_AltRaiseAkimboTime
==============
*/

int __fastcall BG_AltRaiseAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseAkimboTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_BlurSceneAdsInFraction
==============
*/

double __fastcall BG_BlurSceneAdsInFraction(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_BlurSceneAdsInFraction@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsValidWeapon
==============
*/

bool __fastcall BG_IsValidWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsValidWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetShelvedDamageRanges
==============
*/

int __fastcall BG_GetShelvedDamageRanges(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *rangeArray, int size)
{
  return ?BG_GetShelvedDamageRanges@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMPEAMH@Z(damageCalcType, r_weapon, isAlternate, rangeScale, rangeArray, size);
}

/*
==============
BG_GetViewKickYawAndPitch
==============
*/

void __fastcall BG_GetViewKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickPitchMin, float *hipViewKickPitchMax, float *hipViewKickYawMin, float *hipViewKickYawMax, float *hipViewKickMagMin, float *adsViewKickPitchMin, float *adsViewKickPitchMax, float *adsViewKickYawMin, float *adsViewKickYawMax, float *adsViewKickMagMin)
{
  ?BG_GetViewKickYawAndPitch@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipViewKickPitchMin, hipViewKickPitchMax, hipViewKickYawMin, hipViewKickYawMax, hipViewKickMagMin, adsViewKickPitchMin, adsViewKickPitchMax, adsViewKickYawMin, adsViewKickYawMax, adsViewKickMagMin);
}

/*
==============
BG_IsForceForegripIK
==============
*/

bool __fastcall BG_IsForceForegripIK(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsForceForegripIK@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ChargeWeaponLoopTime
==============
*/

int __fastcall BG_ChargeWeaponLoopTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponLoopTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHipOffsetLerpType
==============
*/

void __fastcall BG_GetHipOffsetLerpType(const Weapon *r_weapon, bool isAlternate, AdsOffsetInterpolationType *outHipOffsetLerpType)
{
  ?BG_GetHipOffsetLerpType@@YAXAEBUWeapon@@_NPEAW4AdsOffsetInterpolationType@@@Z(r_weapon, isAlternate, outHipOffsetLerpType);
}

/*
==============
BG_GetHitmarkerType
==============
*/

int __fastcall BG_GetHitmarkerType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetHitmarkerType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetViewKickMaxAngles
==============
*/

void __fastcall BG_GetViewKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  ?BG_GetViewKickMaxAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEATvec2_t@@@Z(weaponMap, ps, r_weapon, isAlternate, outMaxAngles);
}

/*
==============
BG_AltSharesAmmo
==============
*/

bool __fastcall BG_AltSharesAmmo(const Weapon *r_weapon)
{
  return ?BG_AltSharesAmmo@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BgWeaponScalarAccumulator::Reset
==============
*/

void __fastcall BgWeaponScalarAccumulator::Reset(BgWeaponScalarAccumulator *this)
{
  ?Reset@BgWeaponScalarAccumulator@@QEAAXXZ(this);
}

/*
==============
BG_AltRaiseADSTime
==============
*/

int __fastcall BG_AltRaiseADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseADSTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MaxAmmo
==============
*/

int __fastcall BG_MaxAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  return ?BG_MaxAmmo@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, hasIncreasedOffhandAmmoPerk);
}

/*
==============
BG_NoPartialReload
==============
*/

bool __fastcall BG_NoPartialReload(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_NoPartialReload@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ViewFlashEffect
==============
*/

FxCombinedDef __fastcall BG_ViewFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_ViewFlashEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_RechamberTime
==============
*/

int __fastcall BG_RechamberTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ADSReloadEnabled
==============
*/

bool __fastcall BG_ADSReloadEnabled(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_ADSReloadEnabled@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ThrowingBackGrenade
==============
*/

bool __fastcall BG_ThrowingBackGrenade(const playerState_s *ps)
{
  return ?BG_ThrowingBackGrenade@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetPlayerDamageRange
==============
*/

void __fastcall BG_GetPlayerDamageRange(const WeaponDamageCalcType damageCalcType, const BgWeaponMap *weaponMap, const playerState_s *ps, const bitarray<64> *r_perks, const Weapon *r_weapon, bool isAlternate, float *minDamageRange, float *maxDamageRange)
{
  ?BG_GetPlayerDamageRange@@YAXW4WeaponDamageCalcType@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAM6@Z(damageCalcType, weaponMap, ps, r_perks, r_weapon, isAlternate, minDamageRange, maxDamageRange);
}

/*
==============
BG_GetHudOutlineFillColor1
==============
*/

void __fastcall BG_GetHudOutlineFillColor1(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineFillColor1@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_DestabilizeDistance
==============
*/

int __fastcall BG_DestabilizeDistance(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DestabilizeDistance@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_DropTime
==============
*/

int __fastcall BG_DropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_DropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetOffhandAllowsSprint
==============
*/

bool __fastcall BG_GetOffhandAllowsSprint(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandAllowsSprint@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderClimbDropTime
==============
*/

int __fastcall BG_LadderClimbDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderClimbDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCharge_GetMeterBoneMaxCount
==============
*/

unsigned int __fastcall BG_WeaponCharge_GetMeterBoneMaxCount()
{
  return ?BG_WeaponCharge_GetMeterBoneMaxCount@@YAIXZ();
}

/*
==============
BG_AltRaiseTime
==============
*/

int __fastcall BG_AltRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_Weapon_SetPrimaryAttachmentIndex
==============
*/

void __fastcall BG_Weapon_SetPrimaryAttachmentIndex(const AttachmentSlot *slot, const unsigned __int16 attachmentIndex, Weapon *outWeapon)
{
  ?BG_Weapon_SetPrimaryAttachmentIndex@@YAXAEBW4AttachmentSlot@@GAEAUWeapon@@@Z(slot, attachmentIndex, outWeapon);
}

/*
==============
BG_UseQuickSwitchAnims
==============
*/

bool __fastcall BG_UseQuickSwitchAnims(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const BgHandler *pmoveHandler, const bool checkRaise)
{
  return ?BG_UseQuickSwitchAnims@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N2PEBVBgHandler@@2@Z(ps, r_weapon, isAlternate, isDualWielding, pmoveHandler, checkRaise);
}

/*
==============
BG_WorldShellEjectEffect
==============
*/

FxCombinedDef __fastcall BG_WorldShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WorldShellEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_ChooseRandomWeaponIdx
==============
*/

unsigned __int16 __fastcall BG_WeaponsUtil_ChooseRandomWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  return ?BG_WeaponsUtil_ChooseRandomWeaponIdx@@YAGPEAIG@Z(randSeed, lastWeaponIdx);
}

/*
==============
BG_UseADSFireAnim
==============
*/

bool __fastcall BG_UseADSFireAnim(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UseADSFireAnim@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetMountViewKickScale
==============
*/

double __fastcall BG_GetMountViewKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewKickScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HybridToggleIsAllowed
==============
*/

bool __fastcall BG_HybridToggleIsAllowed(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *handler)
{
  return ?BG_HybridToggleIsAllowed@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@PEBVBgHandler@@@Z(weaponMap, ps, handler);
}

/*
==============
BG_CreateWeaponFireParam
==============
*/

unsigned int __fastcall BG_CreateWeaponFireParam(int boneIndex, const Weapon *r_weaponID)
{
  return ?BG_CreateWeaponFireParam@@YAIHAEBUWeapon@@@Z(boneIndex, r_weaponID);
}

/*
==============
BG_WeaponCharge_GetMeterBoneName
==============
*/

scr_string_t __fastcall BG_WeaponCharge_GetMeterBoneName(unsigned int chargeIndex)
{
  return ?BG_WeaponCharge_GetMeterBoneName@@YA?AW4scr_string_t@@I@Z(chargeIndex);
}

/*
==============
BG_ConvertWeaponFromHexString
==============
*/

Weapon *__fastcall BG_ConvertWeaponFromHexString(Weapon *result, const char *hexString)
{
  return ?BG_ConvertWeaponFromHexString@@YA?AUWeapon@@PEBD@Z(result, hexString);
}

/*
==============
BG_OffhandIsUnderbarrelWeapon
==============
*/

int __fastcall BG_OffhandIsUnderbarrelWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, unsigned __int64 whichOffhandButton)
{
  return ?BG_OffhandIsUnderbarrelWeapon@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@_K@Z(weaponMap, ps, whichOffhandButton);
}

/*
==============
BG_ShotCount
==============
*/

int __fastcall BG_ShotCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShotCount@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetType
==============
*/

WeaponChargeType __fastcall BG_WeaponCharge_GetType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetType@@YA?AW4WeaponChargeType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_DestabilizationRateTime
==============
*/

double __fastcall BG_DestabilizationRateTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DestabilizationRateTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSlideSpread
==============
*/

void __fastcall BG_GetSlideSpread(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMax)
{
  ?BG_GetSlideSpread@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, outSlideSpreadMin, outSlideSpreadMax);
}

/*
==============
BG_GetWeaponAttachments
==============
*/

unsigned int __fastcall BG_GetWeaponAttachments(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  return ?BG_GetWeaponAttachments@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@@Z(r_weapon, isAlternate, attachments);
}

/*
==============
BG_GetWeaponDismembermentEnabled
==============
*/

bool __fastcall BG_GetWeaponDismembermentEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetWeaponDismembermentEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlocksNVGADS
==============
*/

bool __fastcall BG_BlocksNVGADS(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BlocksNVGADS@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponGetPlayerAnimType
==============
*/

int __fastcall BG_WeaponGetPlayerAnimType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponGetPlayerAnimType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsMountTopStrafeEnabled
==============
*/

bool __fastcall BG_IsMountTopStrafeEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsMountTopStrafeEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveParachuteStillLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteStillLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteStillLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetStandWeaponOffset
==============
*/

void __fastcall BG_GetStandWeaponOffset(const Weapon *r_weapon, bool isAlternate, vec3_t *outStandOffset, vec3_t *outStandOffsetAngles, vec3_t *outStandOffsetPivot)
{
  ?BG_GetStandWeaponOffset@@YAXAEBUWeapon@@_NAEATvec3_t@@22@Z(r_weapon, isAlternate, outStandOffset, outStandOffsetAngles, outStandOffsetPivot);
}

/*
==============
BG_GetNextSpectateViewWeapons
==============
*/

bool __fastcall BG_GetNextSpectateViewWeapons(const BgWeaponMap *const weaponMap, const characterInfo_t *const ci, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  return ?BG_GetNextSpectateViewWeapons@@YA_NQEBVBgWeaponMap@@QEBUcharacterInfo_t@@AEAY0BI@UWeapon@@AEAI@Z(weaponMap, ci, outViewWeapons, inOutWeaponCount);
}

/*
==============
BG_WorldLastShotEjectEffect
==============
*/

FxCombinedDef __fastcall BG_WorldLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WorldLastShotEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TracerType
==============
*/

TracerDef *__fastcall BG_TracerType(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TracerType@@YAPEAUTracerDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_ValidateWeaponAttachment
==============
*/

bool __fastcall BG_ValidateWeaponAttachment(const WeaponCompleteDef *const weapCompleteDef, const AttachmentSlot slot, const unsigned __int16 weaponAttachmentIndex)
{
  return ?BG_ValidateWeaponAttachment@@YA_NQEBUWeaponCompleteDef@@W4AttachmentSlot@@G@Z(weapCompleteDef, slot, weaponAttachmentIndex);
}

/*
==============
BG_IsMeleeAnimHit
==============
*/

bool __fastcall BG_IsMeleeAnimHit(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimHit@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_GetMeleeWidth
==============
*/

double __fastcall BG_GetMeleeWidth(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeWidth@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes
==============
*/

unsigned __int8 __fastcall TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, const scr_string_t tagName)
{
  return ?GetBoneIndexForTagNameMatchingCharacterModelTypes@TagPair@@SAEPEBUDObj@@PEBUcharacterInfo_t@@QEBW4CharacterModelType@@HW4scr_string_t@@@Z(obj, ci, modelTypesToSearch, modelTypeCount, tagName);
}

/*
==============
BG_WeaponCharge_GetMeterEffect
==============
*/

FxCombinedDef __fastcall BG_WeaponCharge_GetMeterEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetMeterEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ScopeOutlinesAgents
==============
*/

bool __fastcall BG_ScopeOutlinesAgents(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesAgents@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetSfxPackage
==============
*/

WeaponSFXPackage *__fastcall BG_GetSfxPackage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetSfxPackage@@YAPEAUWeaponSFXPackage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BurstFireIsAuto
==============
*/

bool __fastcall BG_BurstFireIsAuto(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BurstFireIsAuto@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateWeaponGlassDebug
==============
*/

void __fastcall BG_UpdateWeaponGlassDebug(const float adsFrac, DObj *const obj)
{
  ?BG_UpdateWeaponGlassDebug@@YAXMQEAUDObj@@@Z(adsFrac, obj);
}

/*
==============
BG_OneHandedViewModelAnimsValid
==============
*/

int __fastcall BG_OneHandedViewModelAnimsValid(const WeaponDef *weapDef)
{
  return ?BG_OneHandedViewModelAnimsValid@@YAHPEBUWeaponDef@@@Z(weapDef);
}

/*
==============
BG_ADSBobRate
==============
*/

double __fastcall BG_ADSBobRate(const Weapon *r_weapon, const bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSBobRate@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsThermalEnabled
==============
*/

bool __fastcall BG_IsThermalEnabled(const BgWeaponMap *weaponMap, const Weapon *r_weapon, const playerState_s *ps)
{
  return ?BG_IsThermalEnabled@@YA_NPEBVBgWeaponMap@@AEBUWeapon@@PEBUplayerState_s@@@Z(weaponMap, r_weapon, ps);
}

/*
==============
BG_TurretUsesBulletCorrection
==============
*/

bool __fastcall BG_TurretUsesBulletCorrection(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretUsesBulletCorrection@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountViewIdleScale
==============
*/

double __fastcall BG_GetMountViewIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewIdleScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetTagNameAndBoneIndex
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndex(TagPair *this, const DObj *obj, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndex@TagPair@@QEBA_NPEBUDObj@@PEAW4scr_string_t@@PEAE@Z(this, obj, outTagName, outBoneIndex);
}

/*
==============
BG_GetExplosionDamageFromRangeInfo
==============
*/

double __fastcall BG_GetExplosionDamageFromRangeInfo(const BgExplosionDamageRangeInfo *damageRangeInfo, const float distance)
{
  double result; 

  *(float *)&result = ?BG_GetExplosionDamageFromRangeInfo@@YAMAEBUBgExplosionDamageRangeInfo@@M@Z(damageRangeInfo, distance);
  return result;
}

/*
==============
BG_GetAllWeaponAttachmentsCount
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachmentsCount(const Weapon *r_weapon)
{
  return ?BG_GetAllWeaponAttachmentsCount@@YAIAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IsAimDownSight
==============
*/

bool __fastcall BG_IsAimDownSight(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsAimDownSight@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IdleProneFactor
==============
*/

double __fastcall BG_IdleProneFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_IdleProneFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetFallbackTagName
==============
*/

scr_string_t __fastcall TagPair::GetFallbackTagName(TagPair *this)
{
  return ?GetFallbackTagName@TagPair@@QEBA?AW4scr_string_t@@XZ(this);
}

/*
==============
BG_LeapInTime
==============
*/

int __fastcall BG_LeapInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetADSZoomLevelWeights
==============
*/

void __fastcall BG_GetADSZoomLevelWeights(const float adsZoomLevelFraction, float *outZoomLevelWeights)
{
  ?BG_GetADSZoomLevelWeights@@YAXMQEAM@Z(adsZoomLevelFraction, outZoomLevelWeights);
}

/*
==============
BG_PlayerHasCompatibleWeapon
==============
*/

bool __fastcall BG_PlayerHasCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PlayerHasCompatibleWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetMountGunCenterScale
==============
*/

double __fastcall BG_GetMountGunCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunCenterScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_RechamberBoltTime
==============
*/

int __fastcall BG_RechamberBoltTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberBoltTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsLadderAiming
==============
*/

bool __fastcall BG_IsLadderAiming(const Weapon *currentWeapon, const playerState_s *ps, bool isAlternate)
{
  return ?BG_IsLadderAiming@@YA_NAEBUWeapon@@PEBUplayerState_s@@_N@Z(currentWeapon, ps, isAlternate);
}

/*
==============
BG_GetScopeDriftDelay
==============
*/

double __fastcall BG_GetScopeDriftDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ValidateWeaponNumberOffhand
==============
*/

bool __fastcall BG_ValidateWeaponNumberOffhand(const Weapon *r_weapon)
{
  return ?BG_ValidateWeaponNumberOffhand@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetScopeDriftUnsteadyFactor
==============
*/

double __fastcall BG_GetScopeDriftUnsteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftUnsteadyFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AimAssistSlowdown
==============
*/

void __fastcall BG_AimAssistSlowdown(const Weapon *r_weapon, bool isAlternate, float *aimAssistPitchSlowdown, float *aimAssistPitchSlowdownAds, float *aimAssistYawSlowdown, float *aimAssistYawSlowdownAds)
{
  ?BG_AimAssistSlowdown@@YAXAEBUWeapon@@_NPEAM222@Z(r_weapon, isAlternate, aimAssistPitchSlowdown, aimAssistPitchSlowdownAds, aimAssistYawSlowdown, aimAssistYawSlowdownAds);
}

/*
==============
BG_UpdateVisibilitySlingBones
==============
*/

void __fastcall BG_UpdateVisibilitySlingBones(const entityState_t *es, DObj *obj, bool isClientCorpse, const Weapon *r_heldWeapon, const Weapon *r_stowedWeapon, int heldWeaponIndex, int stowedWeaponIndex, bool clientOnly, bool forceShowBones)
{
  ?BG_UpdateVisibilitySlingBones@@YAXPEBUentityState_t@@PEAUDObj@@_NAEBUWeapon@@3HH22@Z(es, obj, isClientCorpse, r_heldWeapon, r_stowedWeapon, heldWeaponIndex, stowedWeaponIndex, clientOnly, forceShowBones);
}

/*
==============
BG_GetNotetrackOverrides
==============
*/

bool __fastcall BG_GetNotetrackOverrides(const Weapon *r_weapon, bool isAlternate, unsigned int *numMappings, const scr_string_t **keys, const scr_string_t **values)
{
  return ?BG_GetNotetrackOverrides@@YA_NAEBUWeapon@@_NPEAIPEAPEBW4scr_string_t@@3@Z(r_weapon, isAlternate, numMappings, keys, values);
}

/*
==============
BG_Weapons_AttachHeldWeapon
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachHeldWeapon(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, int *outWeaponModelIndex1, int *outWeaponModelIndex2, bool isServer, XAnimWeaponIKModelsContainer *outWeaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachHeldWeapon@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAH2_NPEAVXAnimWeaponIKModelsContainer@@AEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, outWeaponModelIndex1, outWeaponModelIndex2, isServer, outWeaponIKModels, outModelTypes);
}

/*
==============
BG_GetMeleeAutoAimHeight
==============
*/

double __fastcall BG_GetMeleeAutoAimHeight(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimHeight@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponFlashTagname
==============
*/

TagPair *__fastcall BG_GetWeaponFlashTagname(TagPair *result, const Weapon *r_weapon, bool isAlternate, int chamberIndex)
{
  return ?BG_GetWeaponFlashTagname@@YA?AVTagPair@@AEBUWeapon@@_NH@Z(result, r_weapon, isAlternate, chamberIndex);
}

/*
==============
BG_WeaponBulletFire_GetClientHitEvent
==============
*/

unsigned int __fastcall BG_WeaponBulletFire_GetClientHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  return ?BG_WeaponBulletFire_GetClientHitEvent@@YAII_N@Z(meansOfDeath, serverPlayerHitEvent);
}

/*
==============
BG_GetHudOutlineInScopeColor
==============
*/

void __fastcall BG_GetHudOutlineInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineInScopeColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetWeaponSoundLookup
==============
*/

SndAliasLookup __fastcall BG_GetWeaponSoundLookup(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundLookup@@YA?AUSndAliasLookup@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_GetHudOutlineWeapon
==============
*/

bool __fastcall BG_GetHudOutlineWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_WeaponCharge_GetChargeDownToUpSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeDownToUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeDownToUpSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_GetHandFromWeaponEvent
==============
*/

PlayerHandIndex __fastcall BG_GetHandFromWeaponEvent(int event)
{
  return ?BG_GetHandFromWeaponEvent@@YA?AW4PlayerHandIndex@@H@Z(event);
}

/*
==============
BG_Weapon_CheckFriendlyFire
==============
*/

bool __fastcall BG_Weapon_CheckFriendlyFire(const playerState_s *ps)
{
  return ?BG_Weapon_CheckFriendlyFire@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetOverrideAttachmentWhenApplicable
==============
*/

const WeaponAttachment *__fastcall BG_GetOverrideAttachmentWhenApplicable(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  return ?BG_GetOverrideAttachmentWhenApplicable@@YAPEBUWeaponAttachment@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEBU1@3@Z(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
}

/*
==============
BG_WeaponBulletFire_ShouldPenetrate
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldPenetrate(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldPenetrate@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_ADSSpreadFractions
==============
*/

void __fastcall BG_ADSSpreadFractions(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, float *startFrac, float *endFrac)
{
  ?BG_ADSSpreadFractions@@YAXAEBUWeapon@@_N1AEAM2@Z(r_weapon, isAlternate, isUsingHybridScope, startFrac, endFrac);
}

/*
==============
BG_BuildWeaponAnimArrays
==============
*/

bool __fastcall BG_BuildWeaponAnimArrays(const playerState_s *ps, const Weapon *r_weapon, bool bIsDualWielding, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  return ?BG_BuildWeaponAnimArrays@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N2QEBURawWeaponAnimArrays@@PEAPEAUXAnimParts@@QEAPEBUBlendSpace2DDef@@45PEAUFootstepAnim@@W4weapAnimFiles_t@@H@Z(ps, r_weapon, bIsDualWielding, bIsAlternate, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
}

/*
==============
BG_AddStreamedViewWeaponsToList
==============
*/

bool __fastcall BG_AddStreamedViewWeaponsToList(const BgWeaponMap *const weaponMap, const playerState_s *const ps, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  return ?BG_AddStreamedViewWeaponsToList@@YA_NQEBVBgWeaponMap@@QEBUplayerState_s@@AEAY0BI@UWeapon@@AEAI@Z(weaponMap, ps, outViewWeapons, inOutWeaponCount);
}

/*
==============
BG_GetDynamicAttachmentSlot
==============
*/

AttachmentSlot __fastcall BG_GetDynamicAttachmentSlot(const DynamicAttachmentType dynamicAttachmentType)
{
  return ?BG_GetDynamicAttachmentSlot@@YA?AW4AttachmentSlot@@W4DynamicAttachmentType@@@Z(dynamicAttachmentType);
}

/*
==============
BG_CalculateRecoilInputScalar
==============
*/

double __fastcall BG_CalculateRecoilInputScalar(float kick, float move, float fkickAlignedInputScalar, float fkickOpposedInputScalar)
{
  double result; 

  *(float *)&result = ?BG_CalculateRecoilInputScalar@@YAMMMMM@Z(kick, move, fkickAlignedInputScalar, fkickOpposedInputScalar);
  return result;
}

/*
==============
BG_CanThermalToggle
==============
*/

bool __fastcall BG_CanThermalToggle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanThermalToggle@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetClipLowAmmo
==============
*/

int __fastcall BG_GetClipLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetClipLowAmmo@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_DestabilizationCurvatureMax
==============
*/

double __fastcall BG_DestabilizationCurvatureMax(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DestabilizationCurvatureMax@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_turretGetTagForFiringMuzzle
==============
*/

scr_string_t __fastcall BG_turretGetTagForFiringMuzzle(const entityState_t *es, const Weapon *r_weapon)
{
  return ?BG_turretGetTagForFiringMuzzle@@YA?AW4scr_string_t@@PEBUentityState_t@@AEBUWeapon@@@Z(es, r_weapon);
}

/*
==============
BG_GetReloadTimeScale
==============
*/

double __fastcall BG_GetReloadTimeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip, bool isUsingFastReloadStateTimer)
{
  double result; 

  *(float *)&result = ?BG_GetReloadTimeScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH3@Z(weaponMap, ps, r_weapon, isAlternate, ammoInClip, isUsingFastReloadStateTimer);
  return result;
}

/*
==============
BG_GetWeaponAttachmentsWithIds
==============
*/

unsigned int __fastcall BG_GetWeaponAttachmentsWithIds(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return ?BG_GetWeaponAttachmentsWithIds@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@QEAE@Z(r_weapon, isAlternate, attachments, attachmentIds);
}

/*
==============
BG_PlayerWeaponGetSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetSlot(const Weapon *r_weapon)
{
  return ?BG_PlayerWeaponGetSlot@@YA?AW4WeaponSlot@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IsMeleeAnimMiss
==============
*/

bool __fastcall BG_IsMeleeAnimMiss(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimMiss@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_GetAnimOverrideIdxForMeleeComboSeq
==============
*/

int __fastcall BG_GetAnimOverrideIdxForMeleeComboSeq(const Weapon *r_weapon, const int meleeComboSeqIdx)
{
  return ?BG_GetAnimOverrideIdxForMeleeComboSeq@@YAHAEBUWeapon@@H@Z(r_weapon, meleeComboSeqIdx);
}

/*
==============
BG_ReloadAmmoAdd
==============
*/

int __fastcall BG_ReloadAmmoAdd(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadAmmoAdd@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Stepped
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Stepped(const float innerRange, const float innerDamage, const float midRange, const float midDamage, const float outerRange, const float outerDamage, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_BuildExplosionDamageRangeInfo_Stepped@@YAXMMMMMMAEAUBgExplosionDamageRangeInfo@@@Z(innerRange, innerDamage, midRange, midDamage, outerRange, outerDamage, outDamageRangeInfo);
}

/*
==============
BG_ReloadStartTime
==============
*/

int __fastcall BG_ReloadStartTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadStartTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetSlideSpreadWithDecay
==============
*/

void __fastcall BG_GetSlideSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMoveMax, float *outSlideSpreadMax, float *outSlideSpreadDecayRate, float *outSlideSpreadTurnAdd)
{
  ?BG_GetSlideSpreadWithDecay@@YAXAEBUWeapon@@_NPEAM2222@Z(r_weapon, isAlternate, outSlideSpreadMin, outSlideSpreadMoveMax, outSlideSpreadMax, outSlideSpreadDecayRate, outSlideSpreadTurnAdd);
}

/*
==============
BG_IsMeleeAnimFatal
==============
*/

bool __fastcall BG_IsMeleeAnimFatal(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimFatal@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ChargeWeaponOutTime
==============
*/

int __fastcall BG_ChargeWeaponOutTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponOutTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_CrawlLoopTime
==============
*/

int __fastcall BG_CrawlLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_CrawlLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MoveCycleSprintTime
==============
*/

int __fastcall BG_MoveCycleSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleSprintTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetADSZoomLevel
==============
*/

int __fastcall BG_GetADSZoomLevel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const int zoomCount)
{
  return ?BG_GetADSZoomLevel@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@H@Z(weaponMap, ps, r_weapon, zoomCount);
}

/*
==============
BG_GetADSZoomInfo
==============
*/

void __fastcall BG_GetADSZoomInfo(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  ?BG_GetADSZoomInfo@@YAXPEBVBgWeaponMap@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@AEAUBgAdsZoomInfo@@@Z(weaponMap, r_weapon, isAlternate, hybridScopeFractionInfo, outZoomInfo);
}

/*
==============
BG_GetDamage
==============
*/

int __fastcall BG_GetDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetDamage@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_IsBoneVisibleOnEitherHand
==============
*/

bool __fastcall BG_IsBoneVisibleOnEitherHand(const LocalClientNum_t localClientNum, const char *bone)
{
  return ?BG_IsBoneVisibleOnEitherHand@@YA_NW4LocalClientNum_t@@PEBD@Z(localClientNum, bone);
}

/*
==============
BG_ChargeWeaponInTime
==============
*/

int __fastcall BG_ChargeWeaponInTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponInTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetGrenadePrimeTime
==============
*/

void __fastcall BG_GetGrenadePrimeTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  ?BG_GetGrenadePrimeTime@@YAXPEBUplayerState_s@@AEBUWeapon@@_NPEAH@Z(ps, r_weapon, isAlternate, time);
}

/*
==============
BG_GetAdsDownAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsDownAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsDownAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_StartingKickBullets
==============
*/

int __fastcall BG_StartingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_StartingKickBullets@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetScopeDriftSteadyTime
==============
*/

double __fastcall BG_GetScopeDriftSteadyTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftSteadyTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsAttachmentHybridThermal
==============
*/

bool __fastcall BG_IsAttachmentHybridThermal(const WeaponAttachment *attachment)
{
  return ?BG_IsAttachmentHybridThermal@@YA_NPEBUWeaponAttachment@@@Z(attachment);
}

/*
==============
BG_CalculateKickMovement
==============
*/

bool __fastcall BG_CalculateKickMovement(float fTimeStep, const vec2_t *maxAngles, float kickPitchScale, float kickYawScale, float recenterAngAcceleration, float fReturnAccelScale, float fReturnSpeedCurveScale, vec2_t *inOutAngles, vec2_t *inOutAngularVel, bool *inOutKickNeedsToCrossCenter)
{
  return ?BG_CalculateKickMovement@@YA_NMAEBTvec2_t@@MMMMMAEAT1@1AEA_N@Z(fTimeStep, maxAngles, kickPitchScale, kickYawScale, recenterAngAcceleration, fReturnAccelScale, fReturnSpeedCurveScale, inOutAngles, inOutAngularVel, inOutKickNeedsToCrossCenter);
}

/*
==============
BG_ViewLastShotEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewLastShotEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
RawWeaponAnimArrays::RawWeaponAnimArrays
==============
*/

void __fastcall RawWeaponAnimArrays::RawWeaponAnimArrays(RawWeaponAnimArrays *this)
{
  ??0RawWeaponAnimArrays@@QEAA@XZ(this);
}

/*
==============
BG_ScopeOutlinesEnemies
==============
*/

bool __fastcall BG_ScopeOutlinesEnemies(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesEnemies@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HideSlingBonesForDObj
==============
*/

void __fastcall BG_HideSlingBonesForDObj(DObj *obj, bool hideBones)
{
  ?BG_HideSlingBonesForDObj@@YAXPEAUDObj@@_N@Z(obj, hideBones);
}

/*
==============
BG_WeaponCharge_GetCostPerShot
==============
*/

double __fastcall BG_WeaponCharge_GetCostPerShot(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetCostPerShot@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponFieldTimeWithDependentAnimation
==============
*/

unsigned __int16 __fastcall BG_GetWeaponFieldTimeWithDependentAnimation(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset, const weapAnimFiles_t dependentAnimType)
{
  return ?BG_GetWeaponFieldTimeWithDependentAnimation@@YAGPEBUplayerState_s@@AEBUWeapon@@_N2_JW4weapAnimFiles_t@@@Z(ps, r_weapon, isAlternate, isDualWielding, offset, dependentAnimType);
}

/*
==============
BG_GetWeaponFireType
==============
*/

weapFireType_t __fastcall BG_GetWeaponFireType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponFireType@@YA?AW4weapFireType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsExecutionDog
==============
*/

bool __fastcall BG_IsExecutionDog(const Weapon *weapon)
{
  return ?BG_IsExecutionDog@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_UsesShelvedDamageFalloff
==============
*/

bool __fastcall BG_UsesShelvedDamageFalloff(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesShelvedDamageFalloff@@YA_NW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponBurstCount
==============
*/

int __fastcall BG_GetWeaponBurstCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponBurstCount@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LeapCancelTime
==============
*/

int __fastcall BG_LeapCancelTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapCancelTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_PlayerWeaponGetCycleSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetCycleSlot(WeaponSlot currentSlot, int cycleSlot)
{
  return ?BG_PlayerWeaponGetCycleSlot@@YA?AW4WeaponSlot@@W41@H@Z(currentSlot, cycleSlot);
}

/*
==============
BG_Weapons_IsRiotShieldModel
==============
*/

int __fastcall BG_Weapons_IsRiotShieldModel(const XModel *weapModel)
{
  return ?BG_Weapons_IsRiotShieldModel@@YAHPEBUXModel@@@Z(weapModel);
}

/*
==============
BG_GetWeaponSfxPackageSoundWithFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSfxPackageSoundWithFallback(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSoundWithFallback@@YAPEBUSndAliasList@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_WeapHasGestureDetonation
==============
*/

bool __fastcall BG_WeapHasGestureDetonation(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapHasGestureDetonation@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AltDropTime
==============
*/

int __fastcall BG_AltDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_DebugSniperScene
==============
*/

void __fastcall BG_DebugSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float frac)
{
  ?BG_DebugSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@M@Z(r_weapon, isAlternate, obj, frac);
}

/*
==============
BG_UnpackClientWeaponFireEventParm
==============
*/

void __fastcall BG_UnpackClientWeaponFireEventParm(const unsigned int eventParm, tmat33_t<vec3_t> *outFireAxis)
{
  ?BG_UnpackClientWeaponFireEventParm@@YAXIAEAT?$tmat33_t@Tvec3_t@@@@@Z(eventParm, outFireAxis);
}

/*
==============
BG_GetMeleeTime
==============
*/

void __fastcall BG_GetMeleeTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outMeleeTime, int *outMeleeDamageTime, int *outMeleeViewLockTime)
{
  ?BG_GetMeleeTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@_N22PEAH33@Z(weaponMap, ps, isAlternate, isDualWielding, isFatal, outMeleeTime, outMeleeDamageTime, outMeleeViewLockTime);
}

/*
==============
BG_GetImpactDamageAndModForProjectile
==============
*/

int __fastcall BG_GetImpactDamageAndModForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, const vec3_t *origStart, vec3_t *hitPos, meansOfDeath_t *outMOD)
{
  return ?BG_GetImpactDamageAndModForProjectile@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMAEBTvec3_t@@AEAT3@PEAW4meansOfDeath_t@@@Z(damageCalcType, r_weapon, isAlternate, rangeScale, origStart, hitPos, outMOD);
}

/*
==============
BG_GetMinDamage
==============
*/

int __fastcall BG_GetMinDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMinDamage@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetChargeDownSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeDownSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_GetWeaponSoundWithWeaponSfxPackageFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSoundWithWeaponSfxPackageFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundWithWeaponSfxPackageFallback@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_UseScopeDrift
==============
*/

int __fastcall BG_UseScopeDrift(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UseScopeDrift@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_ProjBeaconEffect
==============
*/

FxCombinedDef __fastcall BG_ProjBeaconEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjBeaconEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel_Internal<characterInfo_t>
==============
*/

int __fastcall BG_AddCarryObjectModel_Internal<characterInfo_t>(const int entityNum, const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ??$BG_AddCarryObjectModel_Internal@UcharacterInfo_t@@@@YAHHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entityNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetSideReticle
==============
*/

void __fastcall BG_GetSideReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleSide, int *reticleSideSize, bool *spin45)
{
  ?BG_GetSideReticle@@YAXAEBUWeapon@@_NPEAPEAUMaterial@@PEAHPEA_N@Z(r_weapon, isAlternate, reticleSide, reticleSideSize, spin45);
}

/*
==============
BG_ScopeToggleOnInterruptTime
==============
*/

int __fastcall BG_ScopeToggleOnInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOnInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetReloadType
==============
*/

ReloadType __fastcall BG_GetReloadType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetReloadType@@YA?AW4ReloadType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PickUpIcon
==============
*/

GfxImage *__fastcall BG_PickUpIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PickUpIcon@@YAPEAUGfxImage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponAltReloadAnimsEnabled
==============
*/

bool __fastcall BG_GetWeaponAltReloadAnimsEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetWeaponAltReloadAnimsEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseFastADSAnims
==============
*/

bool __fastcall BG_UseFastADSAnims(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseFastADSAnims@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetRumble
==============
*/

RumbleInfo *__fastcall BG_WeaponCharge_GetRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEndRechamberTime
==============
*/

int __fastcall BG_ReloadEndRechamberTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, int *outShellEjectTime, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEndRechamberTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEAHAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, outShellEjectTime, hasFastReloadOverride);
}

/*
==============
BG_GetMountGunKickScale
==============
*/

double __fastcall BG_GetMountGunKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunKickScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetGrenadePrimeReadyToThrowTime
==============
*/

void __fastcall BG_GetGrenadePrimeReadyToThrowTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  ?BG_GetGrenadePrimeReadyToThrowTime@@YAXPEBUplayerState_s@@AEBUWeapon@@_NPEAH@Z(ps, r_weapon, isAlternate, time);
}

/*
==============
BG_GetAdsSettleAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsSettleAnim(const playerState_s *ps, const PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsSettleAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@W4PlayerHandIndex@@PEBVBgHandler@@@Z(ps, hand, pmoveHandler);
}

/*
==============
BG_GetADSZoomInFracs
==============
*/

void __fastcall BG_GetADSZoomInFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const bool getWeaponValues, float *adsZoomInFrac, float *adsZoomOutFrac)
{
  ?BG_GetADSZoomInFracs@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N_NPEAM5@Z(weaponMap, ps, r_weapon, isAlternate, getWeaponValues, adsZoomInFrac, adsZoomOutFrac);
}

/*
==============
BG_PreFireTime
==============
*/

int __fastcall BG_PreFireTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_PreFireTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasDefaultWorldModel
==============
*/

bool __fastcall BG_HasDefaultWorldModel(const Weapon *r_weapon)
{
  return ?BG_HasDefaultWorldModel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetMultipleReloadClipPercentage
==============
*/

double __fastcall BG_GetMultipleReloadClipPercentage(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMultipleReloadClipPercentage@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetFireAnimTime
==============
*/

int __fastcall BG_GetFireAnimTime(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const playerState_s *const ps, const BgHandler *pmoveHandler, const weapAnimFiles_t anim)
{
  return ?BG_GetFireAnimTime@@YAHAEBUWeapon@@_N1QEBUplayerState_s@@PEBVBgHandler@@W4weapAnimFiles_t@@@Z(r_weapon, isAlternate, isDualWielding, ps, pmoveHandler, anim);
}

/*
==============
BG_GetKickAlignedInputScalar
==============
*/

double __fastcall BG_GetKickAlignedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetKickAlignedInputScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetExplosionDamageRangeInfo
==============
*/

void __fastcall BG_GetExplosionDamageRangeInfo(const Weapon *r_weapon, bool isAlternate, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_GetExplosionDamageRangeInfo@@YAXAEBUWeapon@@_NAEAUBgExplosionDamageRangeInfo@@@Z(r_weapon, isAlternate, outDamageRangeInfo);
}

/*
==============
BG_IsIncendiaryBullet
==============
*/

bool __fastcall BG_IsIncendiaryBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsIncendiaryBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponAttachmentAdsSmoothFade
==============
*/

bool __fastcall BG_WeaponAttachmentAdsSmoothFade(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_WeaponAttachmentAdsSmoothFade@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOnePieceReticle
==============
*/

Material *__fastcall BG_GetOnePieceReticle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOnePieceReticle@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderClimbRaiseTime
==============
*/

int __fastcall BG_LadderClimbRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderClimbRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetTargetAssistAngleRange
==============
*/

void __fastcall BG_GetTargetAssistAngleRange(const Weapon *r_weapon, bool isAlternate, const float fallbackAngle, const float fallbackRange, float *outAngle, float *outRange)
{
  ?BG_GetTargetAssistAngleRange@@YAXAEBUWeapon@@_NMMPEAM2@Z(r_weapon, isAlternate, fallbackAngle, fallbackRange, outAngle, outRange);
}

/*
==============
BG_AllowWeaponSwitchWhileHoldingGrenade
==============
*/

bool __fastcall BG_AllowWeaponSwitchWhileHoldingGrenade(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AllowWeaponSwitchWhileHoldingGrenade@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSHandheldCamScale
==============
*/

void __fastcall BG_GetADSHandheldCamScale(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, bool isAlternate, float *outAdsRotationScale, float *outAdsTranslationScale)
{
  ?BG_GetADSHandheldCamScale@@YAXPEBUplayerState_s@@AEBUBgHybridScopeFraction@@AEBUWeapon@@_NPEAM4@Z(ps, hybridScopeFraction, weapon, isAlternate, outAdsRotationScale, outAdsTranslationScale);
}

/*
==============
BG_GetOffhandClass
==============
*/

OffhandClass __fastcall BG_GetOffhandClass(const playerState_s *ps, const OffhandSlot slot, const BgWeaponMap *weaponMap)
{
  return ?BG_GetOffhandClass@@YA?AW4OffhandClass@@PEBUplayerState_s@@W4OffhandSlot@@PEBVBgWeaponMap@@@Z(ps, slot, weaponMap);
}

/*
==============
BG_SkydiveSuperDiveInTime
==============
*/

int __fastcall BG_SkydiveSuperDiveInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveSuperDiveInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetViewAndGunKickScalars
==============
*/

void __fastcall BG_GetViewAndGunKickScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outViewKickPitchScale, float *outViewKickYawScale, float *outGunKickPitchScale, float *outGunKickYawScale)
{
  ?BG_GetViewAndGunKickScalars@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEAM444@Z(weaponMap, ps, r_weapon, isAlternate, outViewKickPitchScale, outViewKickYawScale, outGunKickPitchScale, outGunKickYawScale);
}

/*
==============
BG_IsSwimWeapon
==============
*/

bool __fastcall BG_IsSwimWeapon(const Weapon *r_weapon)
{
  return ?BG_IsSwimWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ViewModelAnimExists
==============
*/

int __fastcall BG_ViewModelAnimExists(const playerState_s *ps, weapAnimFiles_t anim, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_ViewModelAnimExists@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@W4PlayerHandIndex@@PEBVBgHandler@@@Z(ps, anim, hand, pmoveHandler);
}

/*
==============
BG_AssertOffhandIndexOrNone
==============
*/

void __fastcall BG_AssertOffhandIndexOrNone(const Weapon *r_weapon)
{
  ?BG_AssertOffhandIndexOrNone@@YAXAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_MoveCycleWalkTime
==============
*/

int __fastcall BG_MoveCycleWalkTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleWalkTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetMotionBlurProperties
==============
*/

void __fastcall BG_GetMotionBlurProperties(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, const bool isAlternate, const float adsLerp, float *outBlur, int *outBlurDurationMs, float *outBlurDecayExponent)
{
  ?BG_GetMotionBlurProperties@@YAXPEBUplayerState_s@@AEBUBgHybridScopeFraction@@AEBUWeapon@@_NMAEAMAEAH4@Z(ps, hybridScopeFraction, weapon, isAlternate, adsLerp, outBlur, outBlurDurationMs, outBlurDecayExponent);
}

/*
==============
BG_WeaponRadiusDamageDetailTrace
==============
*/

bool __fastcall BG_WeaponRadiusDamageDetailTrace(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponRadiusDamageDetailTrace@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetSwaySettings
==============
*/

void __fastcall BG_GetSwaySettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, SwaySettings *outSwaySettings)
{
  ?BG_GetSwaySettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAUSwaySettings@@@Z(weaponMap, ps, r_weapon, isAlternate, outSwaySettings);
}

/*
==============
BG_WeaponStickinessType
==============
*/

WeapStickinessType __fastcall BG_WeaponStickinessType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponStickinessType@@YA?AW4WeapStickinessType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_GetExplDmgMin
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplDmgMin(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplDmgMin@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasUnderbarrelAttachment
==============
*/

bool __fastcall BG_HasUnderbarrelAttachment(const Weapon *r_weapon, bool isAlternate, const scr_string_t attachmentName)
{
  return ?BG_HasUnderbarrelAttachment@@YA_NAEBUWeapon@@_NW4scr_string_t@@@Z(r_weapon, isAlternate, attachmentName);
}

/*
==============
BG_WorldFlashEffect
==============
*/

FxCombinedDef __fastcall BG_WorldFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_WorldFlashEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_Weapon_OffhandDisabled
==============
*/

OffhandDisableResult __fastcall BG_Weapon_OffhandDisabled(const playerState_s *ps)
{
  return ?BG_Weapon_OffhandDisabled@@YA?AW4OffhandDisableResult@@PEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_UpdatedWeaponBones
==============
*/

void __fastcall BG_UpdatedWeaponBones(const Weapon *r_weapon, DObj *obj, int startModel)
{
  ?BG_UpdatedWeaponBones@@YAXAEBUWeapon@@PEAUDObj@@H@Z(r_weapon, obj, startModel);
}

/*
==============
BG_Weapons_GetAttachBone
==============
*/

scr_string_t __fastcall BG_Weapons_GetAttachBone(const characterInfo_t *ci, weapType_t weapType, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand)
{
  return ?BG_Weapons_GetAttachBone@@YA?AW4scr_string_t@@PEBUcharacterInfo_t@@W4weapType_t@@AEBUWeapon@@_NW4PlayerHandIndex@@@Z(ci, weapType, r_weapon, isAlternate, hand);
}

/*
==============
BG_DamageConeAngle
==============
*/

double __fastcall BG_DamageConeAngle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DamageConeAngle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasDualFOVEquipped
==============
*/

bool __fastcall BG_HasDualFOVEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_HasDualFOVEquipped@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_ProjImpactExplode
==============
*/

bool __fastcall BG_ProjImpactExplode(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjImpactExplode@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClass
==============
*/

weapClass_t __fastcall BG_GetWeaponClass(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClass@@YA?AW4weapClass_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetDamageViewKickScaleValues
==============
*/

void __fastcall BG_GetDamageViewKickScaleValues(const playerState_s *ps, const usercmd_s *cmd, float *viewKickScale, float *viewKickMin, float *viewKickMax)
{
  ?BG_GetDamageViewKickScaleValues@@YAXPEBUplayerState_s@@PEBUusercmd_s@@PEAM22@Z(ps, cmd, viewKickScale, viewKickMin, viewKickMax);
}

/*
==============
BG_GetWeaponInspectEnabled
==============
*/

bool __fastcall BG_GetWeaponInspectEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponInspectEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsArmorPiercing
==============
*/

bool __fastcall BG_IsArmorPiercing(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsArmorPiercing@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjIgnitionEffect
==============
*/

FxCombinedDef __fastcall BG_ProjIgnitionEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetTopMountYawMax
==============
*/

double __fastcall BG_GetTopMountYawMax(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetTopMountYawMax@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_RemoveIgnoreEntFromBP
==============
*/

void __fastcall BG_RemoveIgnoreEntFromBP(BulletFireParams *bp, int entityIndex)
{
  ?BG_RemoveIgnoreEntFromBP@@YAXPEAUBulletFireParams@@H@Z(bp, entityIndex);
}

/*
==============
BG_GetHudOutlineFillColor0
==============
*/

void __fastcall BG_GetHudOutlineFillColor0(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineFillColor0@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetADSTransTimes
==============
*/

void __fastcall BG_GetADSTransTimes(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsTransInSpeedMs, float *outAdsTransOutSpeedMs)
{
  ?BG_GetADSTransTimes@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, outAdsTransInSpeedMs, outAdsTransOutSpeedMs);
}

/*
==============
BG_GetGunKickMaxAngles
==============
*/

void __fastcall BG_GetGunKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  ?BG_GetGunKickMaxAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEATvec2_t@@@Z(weaponMap, ps, r_weapon, isAlternate, outMaxAngles);
}

/*
==============
BG_ClearPlayerWeapons
==============
*/

void __fastcall BG_ClearPlayerWeapons(BgWeaponMap *weaponMap, playerState_s *ps)
{
  ?BG_ClearPlayerWeapons@@YAXPEAVBgWeaponMap@@PEAUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_HoldBreathMaxTime
==============
*/

int __fastcall BG_HoldBreathMaxTime(const playerState_s *const ps)
{
  return ?BG_HoldBreathMaxTime@@YAHQEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_ExplosionRadius
==============
*/

int __fastcall BG_ExplosionRadius(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionRadius@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelPlayerState
==============
*/

int __fastcall BG_WeaponDoesNotFullyAnimateViewmodelPlayerState(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponDoesNotFullyAnimateViewmodelPlayerState@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_MapWeaponAnimStateToMeleeAnimIndex
==============
*/

weapAnimFiles_t __fastcall BG_MapWeaponAnimStateToMeleeAnimIndex(const playerState_s *ps, bool previous, int animState)
{
  return ?BG_MapWeaponAnimStateToMeleeAnimIndex@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@_NH@Z(ps, previous, animState);
}

/*
==============
BG_ClearMLGSpectatorClientWeapons
==============
*/

void __fastcall BG_ClearMLGSpectatorClientWeapons(BgWeaponMap *weaponMap, MLGSpectatorClientInfo *mlgSpectatorClientInfo)
{
  ?BG_ClearMLGSpectatorClientWeapons@@YAXPEAVBgWeaponMap@@PEAUMLGSpectatorClientInfo@@@Z(weaponMap, mlgSpectatorClientInfo);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteSlowHardLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteSlowHardLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BG_WeaponCharge_GetGain
==============
*/

double __fastcall BG_WeaponCharge_GetGain(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetGain@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsTargetAssistActive
==============
*/

bool __fastcall BG_IsTargetAssistActive(const playerState_s *ps, const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsTargetAssistActive@@YA_NPEBUplayerState_s@@PEBUentityState_t@@AEBUWeapon@@_N@Z(ps, es, r_weapon, isAlternate);
}

/*
==============
BG_ScopeToggleOffInterruptTime
==============
*/

int __fastcall BG_ScopeToggleOffInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOffInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponGetAltModePlayerAnimType
==============
*/

int __fastcall BG_WeaponGetAltModePlayerAnimType(const Weapon *r_weapon)
{
  return ?BG_WeaponGetAltModePlayerAnimType@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_LadderVaultTime
==============
*/

int __fastcall BG_LadderVaultTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderVaultTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SkydiveParachuteMidAirDetachTime
==============
*/

int __fastcall BG_SkydiveParachuteMidAirDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteMidAirDetachTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
TagPair::SetFallbackTagName
==============
*/

void __fastcall TagPair::SetFallbackTagName(TagPair *this, scr_string_t tagName)
{
  ?SetFallbackTagName@TagPair@@QEAAXW4scr_string_t@@@Z(this, tagName);
}

/*
==============
BG_IsImpalingBullet
==============
*/

bool __fastcall BG_IsImpalingBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsImpalingBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOffhandMaxHoldTime
==============
*/

int __fastcall BG_GetOffhandMaxHoldTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandMaxHoldTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseSmoothGunKick
==============
*/

bool __fastcall BG_UseSmoothGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseSmoothGunKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_UsesReverseWeaponSpread
==============
*/

bool __fastcall BG_UsesReverseWeaponSpread(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesReverseWeaponSpread@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PackClientWeaponFireEventParm
==============
*/

unsigned int __fastcall BG_PackClientWeaponFireEventParm(const tmat33_t<vec3_t> *fireAxis)
{
  return ?BG_PackClientWeaponFireEventParm@@YAIAEBT?$tmat33_t@Tvec3_t@@@@@Z(fireAxis);
}

/*
==============
BG_ThrowBackIcon
==============
*/

Material *__fastcall BG_ThrowBackIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ThrowBackIcon@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjTrajectoryEvents
==============
*/

bool __fastcall BG_ProjTrajectoryEvents(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTrajectoryEvents@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldRicochet
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldRicochet(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldRicochet@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_Weapon_GetCameraFireEffect
==============
*/

FxCombinedDef __fastcall BG_Weapon_GetCameraFireEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_GetCameraFireEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsThrowingAxe
==============
*/

bool __fastcall BG_IsThrowingAxe(const Weapon *r_weapon)
{
  return ?BG_IsThrowingAxe@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BgWeaponScalarAccumulator::GetFinalValue
==============
*/

double __fastcall BgWeaponScalarAccumulator::GetFinalValue(BgWeaponScalarAccumulator *this, const float baseValue)
{
  double result; 

  *(float *)&result = ?GetFinalValue@BgWeaponScalarAccumulator@@QEBAMM@Z(this, baseValue);
  return result;
}

/*
==============
BG_WeaponAnimNumberExists
==============
*/

int __fastcall BG_WeaponAnimNumberExists(const BgWeaponMap *weaponMap, const playerState_s *ps, int weaponAnimNumber, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_WeaponAnimNumberExists@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@HW4PlayerHandIndex@@PEBVBgHandler@@@Z(weaponMap, ps, weaponAnimNumber, hand, pmoveHandler);
}

/*
==============
BG_InADS
==============
*/

bool __fastcall BG_InADS(const playerState_s *ps)
{
  return ?BG_InADS@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetWeaponFireEventBoneIndex
==============
*/

int __fastcall BG_GetWeaponFireEventBoneIndex(unsigned int param)
{
  return ?BG_GetWeaponFireEventBoneIndex@@YAHI@Z(param);
}

/*
==============
BG_WeaponSticksToFloors
==============
*/

bool __fastcall BG_WeaponSticksToFloors(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToFloors@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsUsingHybridScope
==============
*/

bool __fastcall BG_IsUsingHybridScope(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsUsingHybridScope@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_GetWeaponEffect
==============
*/

FxCombinedDef __fastcall BG_GetWeaponEffect(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_GetADSNVGFOVXOffset
==============
*/

double __fastcall BG_GetADSNVGFOVXOffset(const Weapon *r_weapon, const bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSNVGFOVXOffset@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_Weapons_AttachHeldWeaponIKTargets
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachHeldWeaponIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModelLeft, XModel *ikTargetModelRight, bool isServer, unsigned int *inOutFirstWeaponModelIdx, unsigned int *inOutFirstWeaponBoneIdx, int *heldWeaponModelIdx1, int *heldWeaponModelIdx2, int *stowedWeaponModelIdx, const XAnimWeaponIKModelsContainer *weaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachHeldWeaponIKTargets@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAUXModel@@2_NPEAI4PEAH55PEBVXAnimWeaponIKModelsContainer@@AEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, ikTargetModelLeft, ikTargetModelRight, isServer, inOutFirstWeaponModelIdx, inOutFirstWeaponBoneIdx, heldWeaponModelIdx1, heldWeaponModelIdx2, stowedWeaponModelIdx, weaponIKModels, outModelTypes);
}

/*
==============
BG_CopyPlayerWeapons
==============
*/

void __fastcall BG_CopyPlayerWeapons(BgWeaponMap *dstWeaponMap, playerState_s *dstPs, const BgWeaponMap *srcWeaponMap, const playerState_s *srcPs)
{
  ?BG_CopyPlayerWeapons@@YAXPEAVBgWeaponMap@@PEAUplayerState_s@@PEBV1@PEBU2@@Z(dstWeaponMap, dstPs, srcWeaponMap, srcPs);
}

/*
==============
BG_RequiredAmmoPerShot
==============
*/

int __fastcall BG_RequiredAmmoPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RequiredAmmoPerShot@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSound
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSound(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType modelTypeToSearch, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndexForCharacter@TagPair@@QEBA_NPEBUDObj@@PEBUcharacterInfo_t@@W4CharacterModelType@@PEAW4scr_string_t@@PEAE@Z(this, obj, ci, modelTypeToSearch, outTagName, outBoneIndex);
}

/*
==============
BG_AlwaysFireAtMaxRangeInAds
==============
*/

bool __fastcall BG_AlwaysFireAtMaxRangeInAds(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AlwaysFireAtMaxRangeInAds@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ViewMagEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewMagEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewMagEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponStreamedModels
==============
*/

unsigned int __fastcall BG_GetWeaponStreamedModels(const Weapon *weapon, const XModel *(*outList)[32], const bool viewModel)
{
  return ?BG_GetWeaponStreamedModels@@YAIAEBUWeapon@@AEAY0CA@PEBUXModel@@_N@Z(weapon, outList, viewModel);
}

/*
==============
BG_EmptyDropTime
==============
*/

int __fastcall BG_EmptyDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_EmptyDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_BlurSceneAdsOutFraction
==============
*/

double __fastcall BG_BlurSceneAdsOutFraction(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_BlurSceneAdsOutFraction@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetMountSideRoll
==============
*/

void __fastcall BG_GetMountSideRoll(const Weapon *r_weapon, bool isAlternate, float *outRollDeg, float *outStartFrac, float *outEndFrac)
{
  ?BG_GetMountSideRoll@@YAXAEBUWeapon@@_NAEAM22@Z(r_weapon, isAlternate, outRollDeg, outStartFrac, outEndFrac);
}

/*
==============
BG_QuickDropTime
==============
*/

int __fastcall BG_QuickDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_QuickDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponBulletFire_GetExplDmg
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplDmg(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplDmg@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetMeleeAutoAimWidth
==============
*/

double __fastcall BG_GetMeleeAutoAimWidth(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimWidth@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AdvanceTrace
==============
*/

bool __fastcall BG_AdvanceTrace(BulletFireParams *bp, const trace_t *trace, const vec3_t *hitPos, float dist)
{
  return ?BG_AdvanceTrace@@YA_NPEAUBulletFireParams@@PEBUtrace_t@@AEBTvec3_t@@M@Z(bp, trace, hitPos, dist);
}

/*
==============
BG_IsHighPrecisionClientFireEvent
==============
*/

bool __fastcall BG_IsHighPrecisionClientFireEvent(const int eventId)
{
  return ?BG_IsHighPrecisionClientFireEvent@@YA_NH@Z(eventId);
}

/*
==============
BG_ADSZoomCount
==============
*/

int __fastcall BG_ADSZoomCount(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSZoomCount@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_AddGlobalAmmoForAmmoType
==============
*/

void __fastcall BG_AddGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  ?BG_AddGlobalAmmoForAmmoType@@YAXPEAUplayerState_s@@AEBUAmmoStore@@H@Z(ps, r_ammoType, ammoCount);
}

/*
==============
BG_AimAssistLockonStrength
==============
*/

double __fastcall BG_AimAssistLockonStrength(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_AimAssistLockonStrength@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponSticksToWalls
==============
*/

bool __fastcall BG_WeaponSticksToWalls(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToWalls@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderAimDropInterruptTime
==============
*/

int __fastcall BG_LadderAimDropInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimDropInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ProjIgnitionDelay
==============
*/

int __fastcall BG_ProjIgnitionDelay(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionDelay@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetClipSize
==============
*/

int __fastcall BG_GetClipSize(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetClipSize@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetExplosionReactiveMotionParams
==============
*/

void __fastcall BG_GetExplosionReactiveMotionParams(const Weapon *r_weapon, bool isAlternate, float *radiusScale, float *frequencyScale, float *amplitudeScale, float *falloff, float *lifetime)
{
  ?BG_GetExplosionReactiveMotionParams@@YAXAEBUWeapon@@_NPEAM2222@Z(r_weapon, isAlternate, radiusScale, frequencyScale, amplitudeScale, falloff, lifetime);
}

/*
==============
BG_WeaponFuseTime
==============
*/

int __fastcall BG_WeaponFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponFuseTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHybridScopeInfo
==============
*/

void __fastcall BG_GetHybridScopeInfo(const Weapon *r_weapon, bool isAlternate, BgHybridScopeInfo *outHybridScopeInfo)
{
  ?BG_GetHybridScopeInfo@@YAXAEBUWeapon@@_NAEAUBgHybridScopeInfo@@@Z(r_weapon, isAlternate, outHybridScopeInfo);
}

/*
==============
BG_HasPredictedProjectileAttachment
==============
*/

bool __fastcall BG_HasPredictedProjectileAttachment(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasPredictedProjectileAttachment@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEndTime
==============
*/

int __fastcall BG_ReloadEndTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEndTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetWeaponOtherAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetWeaponOtherAttachment(const Weapon *r_weapon, const unsigned int otherIndex)
{
  return ?BG_GetWeaponOtherAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@I@Z(r_weapon, otherIndex);
}

/*
==============
BG_GetHipSpread
==============
*/

void __fastcall BG_GetHipSpread(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMax)
{
  ?BG_GetHipSpread@@YAXAEBUWeapon@@_NPEAM222222222@Z(r_weapon, isAlternate, hipSpreadStandMin, hipSpreadStandMax, hipSpreadDuckedMin, hipSpreadDuckedMax, hipSpreadProneMin, hipSpreadProneMax, hipSpreadSprintMin, hipSpreadSprintMax, hipSpreadInAirMin, hipSpreadInAirMax);
}

/*
==============
BG_HasUnderbarrelGL
==============
*/

int __fastcall BG_HasUnderbarrelGL(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelGL@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
TagPair::TagPair
==============
*/

void __fastcall TagPair::TagPair(TagPair *this)
{
  ??0TagPair@@QEAA@XZ(this);
}

/*
==============
BG_AltOverride3PIsADS
==============
*/

bool __fastcall BG_AltOverride3PIsADS(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3PIsADS@@YA_NAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_StowedOcclusionTestEnabled
==============
*/

bool __fastcall BG_StowedOcclusionTestEnabled(const Weapon *r_weapon)
{
  return ?BG_StowedOcclusionTestEnabled@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SkydiveQuickOpenParachuteTime
==============
*/

int __fastcall BG_SkydiveQuickOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveQuickOpenParachuteTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_PredictionGetClientTrajectoryBlendOutTime
==============
*/

int __fastcall BG_PredictionGetClientTrajectoryBlendOutTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PredictionGetClientTrajectoryBlendOutTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetFirstAvailableOffhandBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstAvailableOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  return ?BG_GetFirstAvailableOffhandBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4OffhandSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_IsWeaponHybridThermal
==============
*/

bool __fastcall BG_IsWeaponHybridThermal(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsWeaponHybridThermal@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetOverlay
==============
*/

const ADSOverlay *__fastcall BG_GetOverlay(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOverlay@@YAPEBUADSOverlay@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TurretStopSpinSound
==============
*/

SndAliasLookup __fastcall BG_TurretStopSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretStopSpinSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAdsUpAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsUpAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsUpAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_GetHipSpreadWithDecay
==============
*/

void __fastcall BG_GetHipSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMoveMax, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMoveMax, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMoveMax, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMoveMax, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMoveMax, float *hipSpreadInAirMax, float *hipSpreadDecayRate, float *hipSpreadProneDecay, float *hipSpreadDuckedDecay, float *hipSpreadSprintDecay, float *hipSpreadInAirDecay, float *hipSpreadTurnAdd, float *hipSpreadMoveAdd)
{
  ?BG_GetHipSpreadWithDecay@@YAXAEBUWeapon@@_NPEAM222222222222222222222@Z(r_weapon, isAlternate, hipSpreadStandMin, hipSpreadStandMoveMax, hipSpreadStandMax, hipSpreadDuckedMin, hipSpreadDuckedMoveMax, hipSpreadDuckedMax, hipSpreadProneMin, hipSpreadProneMoveMax, hipSpreadProneMax, hipSpreadSprintMin, hipSpreadSprintMoveMax, hipSpreadSprintMax, hipSpreadInAirMin, hipSpreadInAirMoveMax, hipSpreadInAirMax, hipSpreadDecayRate, hipSpreadProneDecay, hipSpreadDuckedDecay, hipSpreadSprintDecay, hipSpreadInAirDecay, hipSpreadTurnAdd, hipSpreadMoveAdd);
}

/*
==============
BG_GetHipIdleValues
==============
*/

void __fastcall BG_GetHipIdleValues(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, float *hipIdleAmount, float *adsIdleAmount, float *hipIdleSpeed, float *adsIdleSpeed)
{
  ?BG_GetHipIdleValues@@YAXV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAM333@Z(perks, r_weapon, isAlternate, hipIdleAmount, adsIdleAmount, hipIdleSpeed, adsIdleSpeed);
}

/*
==============
BG_WarningIconsDelay
==============
*/

double __fastcall BG_WarningIconsDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WarningIconsDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetScopeDriftLerpOutTime
==============
*/

double __fastcall BG_GetScopeDriftLerpOutTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftLerpOutTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_CanEquipWeapon
==============
*/

bool __fastcall BG_CanEquipWeapon(const BgWeaponMap *const weaponMap, const playerState_s *const ps, const Weapon *r_weapon)
{
  return ?BG_CanEquipWeapon@@YA_NQEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_GungHoSprintLoopTime
==============
*/

int __fastcall BG_GungHoSprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_GungHoSprintLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHyperBurstInfo
==============
*/

const HyperBurstInfo *__fastcall BG_GetHyperBurstInfo(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetHyperBurstInfo@@YAPEBUHyperBurstInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/

weapClass_t __fastcall BG_GetWeaponClassForAnimCondition(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClassForAnimCondition@@YA?AW4weapClass_t@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeAnim
==============
*/

bool __fastcall BG_IsMeleeAnim(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnim@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ReloadStartAdd
==============
*/

int __fastcall BG_ReloadStartAdd(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadStartAdd@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetIgnoreHitEntityCount
==============
*/

int __fastcall BG_GetIgnoreHitEntityCount(const BulletFireParams *bp)
{
  return ?BG_GetIgnoreHitEntityCount@@YAHPEBUBulletFireParams@@@Z(bp);
}

/*
==============
BG_ProjExplosionEffectInheritParentDirection
==============
*/

bool __fastcall BG_ProjExplosionEffectInheritParentDirection(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffectInheritParentDirection@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>
==============
*/

int __fastcall BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>(const int entityNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ??$BG_AddCarryObjectModel_Internal@UcorpseReferenceCharacterInfo_t@@@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entityNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_ADSSpread
==============
*/

double __fastcall BG_ADSSpread(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, const bool isUsingNVGHalfADS)
{
  double result; 

  *(float *)&result = ?BG_ADSSpread@@YAMAEBUWeapon@@_N11@Z(r_weapon, isAlternate, isUsingHybridScope, isUsingNVGHalfADS);
  return result;
}

/*
==============
BG_UseFastReloadAnims
==============
*/

bool __fastcall BG_UseFastReloadAnims(const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex hand, int ammoInClip, weapAnimFiles_t reloadAnimFile)
{
  return ?BG_UseFastReloadAnims@@YA_NPEBUplayerState_s@@PEBVBgHandler@@AEBUWeapon@@_NW4PlayerHandIndex@@HW4weapAnimFiles_t@@@Z(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, reloadAnimFile);
}

/*
==============
BG_GetAdsVisionSetInfo
==============
*/

BgAdsVisionSetInfo *__fastcall BG_GetAdsVisionSetInfo(BgAdsVisionSetInfo *result, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, bool isAlternate)
{
  return ?BG_GetAdsVisionSetInfo@@YA?AUBgAdsVisionSetInfo@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(result, weaponMap, ps, weapon, isAlternate);
}

/*
==============
BG_PlayerDualWieldingCompatibleWeapon
==============
*/

bool __fastcall BG_PlayerDualWieldingCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PlayerDualWieldingCompatibleWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponGetAnimParts
==============
*/

const XAnimParts *__fastcall BG_WeaponGetAnimParts(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler)
{
  return ?BG_WeaponGetAnimParts@@YAPEBUXAnimParts@@PEBUplayerState_s@@W4PlayerHandIndex@@_NW4weapAnimFiles_t@@PEBVBgHandler@@@Z(ps, hand, bIsAlternate, eWeaponAnim, pmoveHandler);
}

/*
==============
BG_ShowViewModelInDualFOV
==============
*/

bool __fastcall BG_ShowViewModelInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShowViewModelInDualFOV@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateSecondaryWeaponVisibilities
==============
*/

void __fastcall BG_UpdateSecondaryWeaponVisibilities(const BgAnimStatic *bgameAnim, const BgWeaponMap *weaponMap, const entityState_t *es, characterInfo_t *ci)
{
  ?BG_UpdateSecondaryWeaponVisibilities@@YAXPEBUBgAnimStatic@@PEBVBgWeaponMap@@PEBUentityState_t@@PEAUcharacterInfo_t@@@Z(bgameAnim, weaponMap, es, ci);
}

/*
==============
BG_WeaponHasStreamedModels
==============
*/

bool __fastcall BG_WeaponHasStreamedModels(const Weapon *weapon)
{
  return ?BG_WeaponHasStreamedModels@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_LadderAimDropTime
==============
*/

int __fastcall BG_LadderAimDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_StartingGunKickPercent
==============
*/

double __fastcall BG_StartingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_StartingGunKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_GetFirstEquippedOffhandBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  return ?BG_GetFirstEquippedOffhandBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4OffhandSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_ProjDisabledTimeoutEffect
==============
*/

bool __fastcall BG_ProjDisabledTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDisabledTimeoutEffect@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ShowSniperScene
==============
*/

void __fastcall BG_ShowSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj)
{
  ?BG_ShowSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@@Z(r_weapon, isAlternate, obj);
}

/*
==============
BG_HideBoneByModelRange
==============
*/

unsigned __int8 __fastcall BG_HideBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  return ?BG_HideBoneByModelRange@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@HH@Z(bone, obj, partBits, startModel, lastModelInclusive);
}

/*
==============
BG_GetAltWeapon
==============
*/

const Weapon *__fastcall BG_GetAltWeapon(const Weapon *r_weapon)
{
  return ?BG_GetAltWeapon@@YAAEBUWeapon@@AEBU1@@Z(r_weapon);
}

/*
==============
BG_GetHudOutlineOccludedInteriorColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedInteriorColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedInteriorColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_SkydiveOpenParachuteTime
==============
*/

int __fastcall BG_SkydiveOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveOpenParachuteTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_ScopeOutlinesCharacters
==============
*/

bool __fastcall BG_ScopeOutlinesCharacters(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesCharacters@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountEdgeToEyeDistance
==============
*/

void __fastcall BG_GetMountEdgeToEyeDistance(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, float *outForward, float *outAbove)
{
  ?BG_GetMountEdgeToEyeDistance@@YAXW4ContextMountType@@AEBUWeapon@@_NPEAM3@Z(mountType, r_weapon, isAlternate, outForward, outAbove);
}

/*
==============
BG_GetAngularGunKickSettings
==============
*/

void __fastcall BG_GetAngularGunKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularGunKickDir, float *hipAngularGunKickDev, float *hipAngularGunKickStrengthMin, float *hipAngularGunKickStrengthMax, float *hipAngularGunKickPitchScale, float *adsAngularGunKickDir, float *adsAngularGunKickDev, float *adsAngularGunKickStrengthMin, float *adsAngularGunKickStrengthMax, float *adsAngularGunKickPitchScale)
{
  ?BG_GetAngularGunKickSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NHPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, bulletNum, hipAngularGunKickDir, hipAngularGunKickDev, hipAngularGunKickStrengthMin, hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, adsAngularGunKickDir, adsAngularGunKickDev, adsAngularGunKickStrengthMin, adsAngularGunKickStrengthMax, adsAngularGunKickPitchScale);
}

/*
==============
BG_SetGlobalAmmo
==============
*/

void __fastcall BG_SetGlobalAmmo(playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoCount)
{
  ?BG_SetGlobalAmmo@@YAXPEAUplayerState_s@@AEBUWeapon@@_NH@Z(ps, r_weapon, isAlternate, ammoCount);
}

/*
==============
BG_WeaponsDifferOnlyInVariantForInstantSwitch
==============
*/

int __fastcall BG_WeaponsDifferOnlyInVariantForInstantSwitch(const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeapFlags, const Weapon *r_weaponA, const Weapon *r_weaponB)
{
  return ?BG_WeaponsDifferOnlyInVariantForInstantSwitch@@YAHPEBUplayerState_s@@V?$GameModeFlagContainer@W4PWeaponFlagsCommon@@W4PWeaponFlagsSP@@W4PWeaponFlagsMP@@$0EA@@@AEBUWeapon@@2@Z(ps, prevWeapFlags, r_weaponA, r_weaponB);
}

/*
==============
BG_ReloadEmptyInterruptTime
==============
*/

int __fastcall BG_ReloadEmptyInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEmptyInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AmmoCounterClip
==============
*/

ammoCounterClipType_t __fastcall BG_AmmoCounterClip(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AmmoCounterClip@@YA?AW4ammoCounterClipType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAnimForFootsteps
==============
*/

int __fastcall BG_GetAnimForFootsteps(FootstepAnimType footstepAnim)
{
  return ?BG_GetAnimForFootsteps@@YAHW4FootstepAnimType@@@Z(footstepAnim);
}

/*
==============
BG_ActiveUnderbarrel
==============
*/

bool __fastcall BG_ActiveUnderbarrel(const Weapon *r_weapon)
{
  return ?BG_ActiveUnderbarrel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetAmmoIndex
==============
*/

int __fastcall BG_GetAmmoIndex(const Weapon *r_weapon, bool isAlternate, const BgHandler *const handler, const char **outAmmoName)
{
  return ?BG_GetAmmoIndex@@YAHAEBUWeapon@@_NQEBVBgHandler@@PEAPEBD@Z(r_weapon, isAlternate, handler, outAmmoName);
}

/*
==============
BG_MoveTransitionTime
==============
*/

int __fastcall BG_MoveTransitionTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, movementTransition_t transitionType)
{
  return ?BG_MoveTransitionTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2W4movementTransition_t@@@Z(ps, r_weapon, isAlternate, isDualWielding, transitionType);
}

/*
==============
BG_ADSViewBobMult
==============
*/

double __fastcall BG_ADSViewBobMult(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSViewBobMult@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSAimPitch
==============
*/

double __fastcall BG_ADSAimPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSAimPitch@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetReloadAnimFileType
==============
*/

ReloadAnimFileType __fastcall BG_GetReloadAnimFileType(weapAnimFiles_t animFile)
{
  return ?BG_GetReloadAnimFileType@@YA?AW4ReloadAnimFileType@@W4weapAnimFiles_t@@@Z(animFile);
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

double __fastcall BG_CalculateFinalSpreadForWeapon(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, float aimSpreadScale)
{
  double result; 

  *(float *)&result = ?BG_CalculateFinalSpreadForWeapon@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@M@Z(handler, ps, r_weapon, aimSpreadScale);
  return result;
}

/*
==============
BG_WeaponBulletFire_GetMethodOfDeath
==============
*/

meansOfDeath_t __fastcall BG_WeaponBulletFire_GetMethodOfDeath(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_GetMethodOfDeath@@YA?AW4meansOfDeath_t@@V?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_EndingKickBullets
==============
*/

int __fastcall BG_EndingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_EndingKickBullets@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsChargeShotWeapon
==============
*/

bool __fastcall BG_IsChargeShotWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsChargeShotWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetPenetrateMultiplier
==============
*/

double __fastcall BG_GetPenetrateMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetPenetrateMultiplier@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ScopeOutlinesScriptMovers
==============
*/

bool __fastcall BG_ScopeOutlinesScriptMovers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesScriptMovers@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel
==============
*/

int __fastcall BG_AddCarryObjectModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddCarryObjectModel@@YAHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetHudOutlineOccludedInlineColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedInlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedInlineColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_FirstRaiseTime
==============
*/

int __fastcall BG_FirstRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_FirstRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_VMProjBodyEffect
==============
*/

FxCombinedDef __fastcall BG_VMProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_VMProjBodyEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponFireWeaponID
==============
*/

Weapon *__fastcall BG_GetWeaponFireWeaponID(Weapon *result, unsigned int param)
{
  return ?BG_GetWeaponFireWeaponID@@YA?AUWeapon@@I@Z(result, param);
}

/*
==============
BG_AddCarryObjectModelToCorpse
==============
*/

int __fastcall BG_AddCarryObjectModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddCarryObjectModelToCorpse@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_DeathAnimDamageType
==============
*/

AnimDamageType __fastcall BG_DeathAnimDamageType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DeathAnimDamageType@@YA?AW4AnimDamageType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlastBackTime
==============
*/

int __fastcall BG_BlastBackTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastBackTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadMultipleTimeBulletBased
==============
*/

int __fastcall BG_ReloadMultipleTimeBulletBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  return ?BG_ReloadMultipleTimeBulletBased@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_NAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, hasFastReloadOverride);
}

/*
==============
BG_GetSpreadForWeapon
==============
*/

void __fastcall BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon *r_weapon, float *minSpread, float *maxSpread)
{
  ?BG_GetSpreadForWeapon@@YAXPEBUplayerState_s@@AEBUWeapon@@PEAM2@Z(ps, r_weapon, minSpread, maxSpread);
}

/*
==============
BG_ShouldApplyWeaponAnglesToShootingDirection
==============
*/

bool __fastcall BG_ShouldApplyWeaponAnglesToShootingDirection(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShouldApplyWeaponAnglesToShootingDirection@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_Weapon_UsingAutoFireOnSwitchWeapon
==============
*/

bool __fastcall BG_Weapon_UsingAutoFireOnSwitchWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_Weapon_UsingAutoFireOnSwitchWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_PlayerLastWeaponHand
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHand(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_PlayerLastWeaponHand@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_Weapons_IsRiotShieldModelName
==============
*/

int __fastcall BG_Weapons_IsRiotShieldModelName(const char *const modelName)
{
  return ?BG_Weapons_IsRiotShieldModelName@@YAHQEBD@Z(modelName);
}

/*
==============
BG_ProjExplosionType
==============
*/

weapProjExposion_t __fastcall BG_ProjExplosionType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionType@@YA?AW4weapProjExposion_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponReloadingFraction
==============
*/

double __fastcall BG_WeaponReloadingFraction(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_WeaponReloadingFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_WeaponSticksToNonStick
==============
*/

bool __fastcall BG_WeaponSticksToNonStick(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToNonStick@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAdsAlign
==============
*/

bool __fastcall BG_GetAdsAlign(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, vec3_t *outAdsAlignOffset, AdsOffsetInterpolationType *outOffsetLerpType, AdsOffsetInterpolationType *outAlignmentLerpType, bool *outDisableTagAlignX)
{
  return ?BG_GetAdsAlign@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@AEATvec3_t@@PEAW4AdsOffsetInterpolationType@@6AEA_N@Z(weaponMap, ps, r_weapon, isAlternate, hybridScopeFractionInfo, outAdsAlignOffset, outOffsetLerpType, outAlignmentLerpType, outDisableTagAlignX);
}

/*
==============
BG_GetGunTiltYawPitchAndRoll
==============
*/

void __fastcall BG_GetGunTiltYawPitchAndRoll(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunTiltPitchFactor, float *hipGunTiltYawFactor, float *hipGunTiltRollFactor, float *hipGunTiltOffset, float *adsGunTiltPitchFactor, float *adsGunTiltYawFactor, float *adsGunTiltRollFactor, float *adsGunTiltOffset)
{
  ?BG_GetGunTiltYawPitchAndRoll@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunTiltPitchFactor, hipGunTiltYawFactor, hipGunTiltRollFactor, hipGunTiltOffset, adsGunTiltPitchFactor, adsGunTiltYawFactor, adsGunTiltRollFactor, adsGunTiltOffset);
}

/*
==============
BG_IsMountTypeEnabled
==============
*/

bool __fastcall BG_IsMountTypeEnabled(const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, const ContextMountType mountType)
{
  return ?BG_IsMountTypeEnabled@@YA_NQEBUplayerState_s@@AEBUWeapon@@_NW4ContextMountType@@@Z(ps, r_weapon, isAlternate, mountType);
}

/*
==============
BG_GetEnemyCrossHairRange
==============
*/

double __fastcall BG_GetEnemyCrossHairRange(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetEnemyCrossHairRange@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetADSIdleLerpTime
==============
*/

void __fastcall BG_GetADSIdleLerpTime(const Weapon *r_weapon, bool isAlternate, float *adsIdleLerpStartTime, float *adsIdleLerpTime)
{
  ?BG_GetADSIdleLerpTime@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, adsIdleLerpStartTime, adsIdleLerpTime);
}

/*
==============
BG_EmptyFireSound
==============
*/

const SndAliasList *__fastcall BG_EmptyFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_EmptyFireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_GetFriendlyLaserType
==============
*/

const LaserDef *__fastcall BG_GetFriendlyLaserType(const Weapon *r_weapon, const bool isPlayerView, const bool isBeamDraw)
{
  return ?BG_GetFriendlyLaserType@@YAPEBULaserDef@@AEBUWeapon@@_N1@Z(r_weapon, isPlayerView, isBeamDraw);
}

/*
==============
BG_GetADSFireRateScale
==============
*/

double __fastcall BG_GetADSFireRateScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSFireRateScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ReloadEndInterruptTime
==============
*/

int __fastcall BG_ReloadEndInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEndInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SkydiveParachuteFastLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteFastLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteFastLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BgWeaponScalarAccumulator::ApplyMultiplicativeScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyMultiplicativeScale(BgWeaponScalarAccumulator *this, const float scale)
{
  ?ApplyMultiplicativeScale@BgWeaponScalarAccumulator@@QEAAXM@Z(this, scale);
}

/*
==============
BG_WeaponBlocksProne
==============
*/

bool __fastcall BG_WeaponBlocksProne(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBlocksProne@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PredictionGetServerTrajectoryBlendInTime
==============
*/

int __fastcall BG_PredictionGetServerTrajectoryBlendInTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PredictionGetServerTrajectoryBlendInTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_Weapon_OffhandDisablesHold
==============
*/

int __fastcall BG_Weapon_OffhandDisablesHold(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_OffhandDisablesHold@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsHitSurfaceTransparent
==============
*/

bool __fastcall BG_IsHitSurfaceTransparent(const trace_t *trace)
{
  return ?BG_IsHitSurfaceTransparent@@YA_NPEBUtrace_t@@@Z(trace);
}

/*
==============
BG_GetADSNVGFOV
==============
*/

double __fastcall BG_GetADSNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  double result; 

  *(float *)&result = ?BG_GetADSNVGFOV@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, getWeaponValues);
  return result;
}

/*
==============
BG_GetGunKickSpeed
==============
*/

void __fastcall BG_GetGunKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickAccel, float *hipGunKickSpeedMax, float *hipGunKickSpeedDecay, float *hipGunKickStaticDecay, float *hipGunKickReturnAccelScale, float *hipGunKickReturnSpeedCurveScale, float *adsGunKickAccel, float *adsGunKickSpeedMax, float *adsGunKickSpeedDecay, float *adsGunKickStaticDecay, float *adsGunKickReturnAccelScale, float *adsGunKickReturnSpeedCurveScale)
{
  ?BG_GetGunKickSpeed@@YAXPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_NPEAM44444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunKickAccel, hipGunKickSpeedMax, hipGunKickSpeedDecay, hipGunKickStaticDecay, hipGunKickReturnAccelScale, hipGunKickReturnSpeedCurveScale, adsGunKickAccel, adsGunKickSpeedMax, adsGunKickSpeedDecay, adsGunKickStaticDecay, adsGunKickReturnAccelScale, adsGunKickReturnSpeedCurveScale);
}

/*
==============
BG_BlastRightTime
==============
*/

int __fastcall BG_BlastRightTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastRightTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponOffhandSlot
==============
*/

OffhandSlot __fastcall BG_GetWeaponOffhandSlot(const playerState_s *ps, const BgWeaponMap *weaponMap, const Weapon *r_weapon)
{
  return ?BG_GetWeaponOffhandSlot@@YA?AW4OffhandSlot@@PEBUplayerState_s@@PEBVBgWeaponMap@@AEBUWeapon@@@Z(ps, weaponMap, r_weapon);
}

/*
==============
BG_GetMeleeInterruptTime
==============
*/

void __fastcall BG_GetMeleeInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outToMeleeInterruptTime, int *outInterruptTime, int *outToFireInterruptTime)
{
  ?BG_GetMeleeInterruptTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@_N22PEAH33@Z(weaponMap, ps, isAlternate, isDualWielding, isFatal, outToMeleeInterruptTime, outInterruptTime, outToFireInterruptTime);
}

/*
==============
BG_ShouldBlendFireAnims
==============
*/

bool __fastcall BG_ShouldBlendFireAnims(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShouldBlendFireAnims@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StunnedTimeLoop
==============
*/

int __fastcall BG_StunnedTimeLoop(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeLoop@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasADSAltSwitchAnims
==============
*/

bool __fastcall BG_HasADSAltSwitchAnims(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_HasADSAltSwitchAnims@@YA_NPEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_ReloadStartInterruptTime
==============
*/

int __fastcall BG_ReloadStartInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadStartInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SprintLoopTime
==============
*/

int __fastcall BG_SprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MapWeaponAnimStateToAnimIndex
==============
*/

weapAnimFiles_t __fastcall BG_MapWeaponAnimStateToAnimIndex(const BgWeaponMap *weaponMap, const playerState_s *ps, int animState, bool previousMelee, const Weapon *r_weapon, bool bIsAlternate, PlayerHandIndex handIndex, const BgHandler *pmoveHandler)
{
  return ?BG_MapWeaponAnimStateToAnimIndex@@YA?AW4weapAnimFiles_t@@PEBVBgWeaponMap@@PEBUplayerState_s@@H_NAEBUWeapon@@2W4PlayerHandIndex@@PEBVBgHandler@@@Z(weaponMap, ps, animState, previousMelee, r_weapon, bIsAlternate, handIndex, pmoveHandler);
}

/*
==============
BG_TargetAssistLosOffsets
==============
*/

void __fastcall BG_TargetAssistLosOffsets(const Weapon *r_weapon, bool isAlternate, float *outForwardOffset, float *outRightOffset, float *outUpOffset)
{
  ?BG_TargetAssistLosOffsets@@YAXAEBUWeapon@@_NPEAM22@Z(r_weapon, isAlternate, outForwardOffset, outRightOffset, outUpOffset);
}

/*
==============
BG_HudIcon
==============
*/

GfxImage *__fastcall BG_HudIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HudIcon@@YAPEAUGfxImage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StartingViewKickPercent
==============
*/

double __fastcall BG_StartingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_StartingViewKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_GetFireTimeWithHand
==============
*/

void __fastcall BG_GetFireTimeWithHand(const BgWeaponMap *weaponMap, const playerState_s *ps, const PlayerHandIndex hand, const bool adjustForHyperBurst, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  ?BG_GetFireTimeWithHand@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@W4PlayerHandIndex@@_NAEBUWeapon@@_N5HPEAH6@Z(weaponMap, ps, hand, adjustForHyperBurst, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_ProjExplosionEffectForceNormalUp
==============
*/

bool __fastcall BG_ProjExplosionEffectForceNormalUp(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffectForceNormalUp@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

double __fastcall BG_CalculateFinalSpreadForWeapon(float weaponPosFrac, float minSpread, float maxSpread, float adsSpread, float aimSpreadScale)
{
  double result; 

  *(float *)&result = ?BG_CalculateFinalSpreadForWeapon@@YAMMMMMM@Z(weaponPosFrac, minSpread, maxSpread, adsSpread, aimSpreadScale);
  return result;
}

/*
==============
BG_WeaponSticksToVehicles
==============
*/

bool __fastcall BG_WeaponSticksToVehicles(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToVehicles@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerWeaponGetSlotName
==============
*/

const char *__fastcall BG_PlayerWeaponGetSlotName(const WeaponSlot slot)
{
  return ?BG_PlayerWeaponGetSlotName@@YAPEBDW4WeaponSlot@@@Z(slot);
}

/*
==============
BG_IsForceUseWeapon
==============
*/

int __fastcall BG_IsForceUseWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsForceUseWeapon@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOtherAdsSettleAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsSettleAnim(const weapAnimFiles_t adsSettleAnim)
{
  return ?BG_GetOtherAdsSettleAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsSettleAnim);
}

/*
==============
BG_UseFastReloadLowAmmo
==============
*/

bool __fastcall BG_UseFastReloadLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip)
{
  return ?BG_UseFastReloadLowAmmo@@YA_NPEBUplayerState_s@@AEBUWeapon@@_NH@Z(ps, r_weapon, isAlternate, ammoInClip);
}

/*
==============
BG_GetBurstFireCooldown
==============
*/

double __fastcall BG_GetBurstFireCooldown(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBurstFireCooldown@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetGunKickYawAndPitch
==============
*/

void __fastcall BG_GetGunKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickPitchMin, float *hipGunKickPitchMax, float *hipGunKickYawMin, float *hipGunKickYawMax, float *hipGunKickMagMin, float *adsGunKickPitchMin, float *adsGunKickPitchMax, float *adsGunKickYawMin, float *adsGunKickYawMax, float *adsGunKickMagMin)
{
  ?BG_GetGunKickYawAndPitch@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunKickPitchMin, hipGunKickPitchMax, hipGunKickYawMin, hipGunKickYawMax, hipGunKickMagMin, adsGunKickPitchMin, adsGunKickPitchMax, adsGunKickYawMin, adsGunKickYawMax, adsGunKickMagMin);
}

/*
==============
BG_DisableInputDrivenViewReturnDampening
==============
*/

bool __fastcall BG_DisableInputDrivenViewReturnDampening(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DisableInputDrivenViewReturnDampening@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_IsUsingFastReloadStateTimer
==============
*/

bool __fastcall BG_IsUsingFastReloadStateTimer(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_IsUsingFastReloadStateTimer@@YA_NPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddCarryObjectModel_Internal<characterInfo_t>
==============
*/
__int64 BG_AddCarryObjectModel_Internal<characterInfo_t>(const int entityNum, const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v12; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)v8;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v12 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v12;
  if ( v12 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v12;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>
==============
*/
__int64 BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>(const int entityNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v12; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)v8;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v12 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v12;
  if ( v12 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v12;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
RawWeaponAnimArrays::RawWeaponAnimArrays
==============
*/
void RawWeaponAnimArrays::RawWeaponAnimArrays(RawWeaponAnimArrays *this)
{
  memset_0(this, 0, 0x1330ui64);
  memset_0(this->xAnimsAlt, 0, sizeof(this->xAnimsAlt));
  memset_0(this->xAnimsRightHanded, 0, sizeof(this->xAnimsRightHanded));
  memset_0(this->xAnimsLeftHanded, 0, sizeof(this->xAnimsLeftHanded));
  this->blendSpaces[0] = NULL;
  this->blendSpaces[1] = NULL;
  this->blendSpaces[2] = NULL;
  this->blendSpaces[3] = NULL;
  this->blendSpaces[4] = NULL;
  this->blendSpaces[5] = NULL;
  this->blendSpaces[6] = NULL;
  this->blendSpaces[7] = NULL;
  this->blendSpacesAlt[0] = NULL;
  this->blendSpacesAlt[1] = NULL;
  this->blendSpacesAlt[2] = NULL;
  this->blendSpacesAlt[3] = NULL;
  this->blendSpacesAlt[4] = NULL;
  this->blendSpacesAlt[5] = NULL;
  this->blendSpacesAlt[6] = NULL;
  this->blendSpacesAlt[7] = NULL;
  this->blendSpacesRightHanded[0] = NULL;
  this->blendSpacesRightHanded[1] = NULL;
  this->blendSpacesRightHanded[2] = NULL;
  this->blendSpacesRightHanded[3] = NULL;
  this->blendSpacesRightHanded[4] = NULL;
  this->blendSpacesRightHanded[5] = NULL;
  this->blendSpacesRightHanded[6] = NULL;
  this->blendSpacesRightHanded[7] = NULL;
  this->blendSpacesLeftHanded[0] = NULL;
  this->blendSpacesLeftHanded[1] = NULL;
  this->blendSpacesLeftHanded[2] = NULL;
  this->blendSpacesLeftHanded[3] = NULL;
  this->blendSpacesLeftHanded[4] = NULL;
  this->blendSpacesLeftHanded[5] = NULL;
  this->blendSpacesLeftHanded[6] = NULL;
  this->blendSpacesLeftHanded[7] = NULL;
  memset_0(this->footsteps, 0, 0x68D0ui64);
}

/*
==============
TagPair::TagPair
==============
*/
void TagPair::TagPair(TagPair *this, scr_string_t primaryTagName, scr_string_t fallbackTagName)
{
  this->m_primaryTagName = primaryTagName;
  this->m_fallbackTagName = fallbackTagName;
}

/*
==============
TagPair::TagPair
==============
*/
void TagPair::TagPair(TagPair *this)
{
  *this = 0i64;
}

/*
==============
BgWeaponScalarAccumulator::ApplyAdditiveScale
==============
*/
void BgWeaponScalarAccumulator::ApplyAdditiveScale(BgWeaponScalarAccumulator *this, const float scale)
{
  this->m_additiveScale = (float)(scale + this->m_additiveScale) - 1.0;
}

/*
==============
BgWeaponScalarAccumulator::ApplyMultiplicativeScale
==============
*/
void BgWeaponScalarAccumulator::ApplyMultiplicativeScale(BgWeaponScalarAccumulator *this, const float scale)
{
  this->m_multiplicativeScale = scale * this->m_multiplicativeScale;
}

/*
==============
BG_ADSAimPitch
==============
*/
float BG_ADSAimPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  float fAdsAimPitch; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12610, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  fAdsAimPitch = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fAdsAimPitch;
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->adsAimPitch;
  else
    return fAdsAimPitch;
}

/*
==============
BG_ADSBobFactor
==============
*/
float BG_ADSBobFactor(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13381, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(v8->fAdsBobFactor);
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0) )
  {
    _XMM0 = 0i64;
    __asm
    {
      vcmpless xmm1, xmm0, xmm2
      vblendvps xmm0, xmm6, xmm2, xmm1
    }
  }
  else
  {
    LODWORD(_XMM0) = _XMM6;
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSBobRate
==============
*/
float BG_ADSBobRate(const Weapon *r_weapon, const bool isAlternate)
{
  __int128 v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v4; 
  __int64 v5; 
  WeaponAttachment *v6; 
  float adsBobRateScale; 
  __int128 v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v11[32]; 

  v2 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v11, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v4 = attachments;
    v5 = WeaponAttachments_Internal;
    do
    {
      v6 = *v4;
      if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13360, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsBobRateScale = v6->adsBobRateScale;
      if ( adsBobRateScale > 0.0 )
      {
        v8 = v2;
        *(float *)&v8 = *(float *)&v2 * adsBobRateScale;
        v2 = v8;
      }
      ++v4;
      --v5;
    }
    while ( v5 );
  }
  return *(float *)&v2;
}

/*
==============
BG_ADSFireAnimFrac
==============
*/
float BG_ADSFireAnimFrac(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  float adsFireAnimFrac; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13726, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  adsFireAnimFrac = v8->adsFireAnimFrac;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->adsFireAnimFrac;
  else
    return adsFireAnimFrac;
}

/*
==============
BG_ADSMovementAnimBlendFrac
==============
*/
void BG_ADSMovementAnimBlendFrac(const Weapon *r_weapon, bool isAlternate, float *outStartFrac, float *outEndFrac)
{
  const WeaponDef *v7; 

  if ( !outStartFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13743, ASSERT_TYPE_ASSERT, "(outStartFrac)", (const char *)&queryFormat, "outStartFrac") )
    __debugbreak();
  if ( !outEndFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13744, ASSERT_TYPE_ASSERT, "(outEndFrac)", (const char *)&queryFormat, "outEndFrac") )
    __debugbreak();
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outStartFrac = v7->adsMovementAnimLerpStart;
  *outEndFrac = v7->adsMovementAnimLerpEnd;
}

/*
==============
BG_ADSReloadEnabled
==============
*/
bool BG_ADSReloadEnabled(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  const dvar_t *v4; 
  bool v5; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  WeaponAttachment **i; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttADSReloadSettings *adsReloadSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = DCONST_DVARMODEBOOL_adsReloadEnabled;
  v5 = isAlternate;
  if ( !DCONST_DVARMODEBOOL_adsReloadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsReloadEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
    return 0;
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v13 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadWhileAds;
  for ( i = attachments; ; ++i )
  {
    OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v5, *i, v13);
    if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22219, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    adsReloadSettings = OverrideAttachmentWhenApplicable->adsReloadSettings;
    if ( adsReloadSettings )
      break;
    v5 = isAlternate;
    if ( ++v10 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadWhileAds;
  }
  return adsReloadSettings->reloadWhileADS;
}

/*
==============
BG_ADSReloadFovXOffset
==============
*/
float BG_ADSReloadFovXOffset(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v8; 
  float adsReloadZoomFovXOffset; 
  const BgWeaponMap *v11; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13271, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v8 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( ps && BG_PlayerUsesNVGHalfADS(ps, handler) )
    return v8->zoomSettings.weapon.adsNVGReloadZoomFovXOffset;
  adsReloadZoomFovXOffset = v8->zoomSettings.weapon.adsReloadZoomFovXOffset;
  v11 = handler->GetWeaponMap(handler);
  v13 = ps && v11 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v11, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v13, 0);
  if ( WeaponAdsSettings )
  {
    if ( WeaponAdsSettings->zoomSettings.weapon.adsReloadFovXOffsetOverride )
      return WeaponAdsSettings->zoomSettings.weapon.adsReloadZoomFovXOffset;
  }
  return adsReloadZoomFovXOffset;
}

/*
==============
BG_ADSReloadTransTime
==============
*/
__int64 BG_ADSReloadTransTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int iPositionReloadTransTime; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12727, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  iPositionReloadTransTime = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iPositionReloadTransTime;
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings && WeaponAdsSettings->adsReloadTransTime >= 0 )
    return (unsigned int)WeaponAdsSettings->adsReloadTransTime;
  return iPositionReloadTransTime;
}

/*
==============
BG_ADSResetZoomLevelOnToggle
==============
*/
_BOOL8 BG_ADSResetZoomLevelOnToggle(BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12832, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12833, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12836, ASSERT_TYPE_ASSERT, "(weapComplDef)", (const char *)&queryFormat, "weapComplDef") )
    __debugbreak();
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->zoomSettings.scene.adsZoomLevelIndexResetOnToggle;
  else
    return v8->zoomSettings.scene.adsZoomLevelIndexResetOnToggle;
}

/*
==============
BG_ADSShouldShowCrosshair
==============
*/
_BOOL8 BG_ADSShouldShowCrosshair(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsShouldShowCrosshair;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20714, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsShouldShowCrosshair;
  }
  return general->adsShouldShowCrosshair;
}

/*
==============
BG_ADSSpread
==============
*/
float BG_ADSSpread(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, const bool isUsingNVGHalfADS)
{
  const WeaponDef *v8; 
  bool doNotAllowAttachmentsToOverrideSpread; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v15; 
  __int64 v16; 
  const WeaponAttachment *v17; 
  float adsSpreadScale; 
  __int128 v19; 
  __int128 v21; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( isUsingNVGHalfADS )
    _XMM9 = LODWORD(v8->fAdsSpreadNVG);
  else
    _XMM9 = LODWORD(v8->fAdsSpread);
  doNotAllowAttachmentsToOverrideSpread = v8->doNotAllowAttachmentsToOverrideSpread;
  _XMM7 = 0i64;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, isUsingHybridScope, doNotAllowAttachmentsToOverrideSpread) )
  {
    __asm
    {
      vcmpless xmm0, xmm7, xmm1
      vblendvps xmm9, xmm9, xmm1, xmm0
    }
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)3, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v15 = (const WeaponAttachment **)attachments;
    v16 = WeaponAttachments_Internal;
    while ( 1 )
    {
      v17 = *v15;
      if ( !*v15 || doNotAllowAttachmentsToOverrideSpread && v17->type == ATTACHMENT_SCOPE )
        goto LABEL_17;
      if ( BG_AttachmentUseMainSettings(*v15, isAlternate, isUsingHybridScope) )
        break;
      adsSpreadScale = v17->adsSpreadScale;
      if ( adsSpreadScale <= 0.0 )
        goto LABEL_15;
LABEL_16:
      v19 = _XMM8;
      *(float *)&v19 = (float)(*(float *)&_XMM8 + adsSpreadScale) - 1.0;
      _XMM8 = v19;
LABEL_17:
      ++v15;
      if ( !--v16 )
        goto LABEL_18;
    }
    adsSpreadScale = v17->adsSpreadScaleMain;
    if ( adsSpreadScale > 0.0 )
      goto LABEL_16;
LABEL_15:
    adsSpreadScale = FLOAT_1_0;
    goto LABEL_16;
  }
LABEL_18:
  __asm { vmaxss  xmm3, xmm8, xmm7 }
  v21 = LODWORD(FLOAT_1_0);
  *(float *)&v21 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v21 + 1) = (v21 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v21 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v21;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
  }
  return *(float *)&_XMM0 * *(float *)&_XMM9;
}

/*
==============
BG_ADSSpreadFractions
==============
*/
void BG_ADSSpreadFractions(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, float *startFrac, float *endFrac)
{
  const WeaponDef *v9; 
  bool doNotAllowAttachmentsToOverrideSpread; 
  const AttADSSettings *WeaponAdsSettings; 
  float adsSpreadStartFrac; 
  float adsSpreadEndFrac; 

  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  doNotAllowAttachmentsToOverrideSpread = v9->doNotAllowAttachmentsToOverrideSpread;
  *startFrac = v9->adsSpreadStartFrac;
  *endFrac = v9->adsSpreadEndFrac;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, isUsingHybridScope, doNotAllowAttachmentsToOverrideSpread);
  if ( WeaponAdsSettings )
  {
    adsSpreadStartFrac = WeaponAdsSettings->adsSpreadStartFrac;
    if ( adsSpreadStartFrac >= 0.0 )
      *startFrac = adsSpreadStartFrac;
    adsSpreadEndFrac = WeaponAdsSettings->adsSpreadEndFrac;
    if ( adsSpreadEndFrac >= 0.0 )
      *endFrac = adsSpreadEndFrac;
  }
}

/*
==============
BG_ADSViewBobMult
==============
*/
float BG_ADSViewBobMult(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  __int128 v14; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v16; 
  __int64 v17; 
  WeaponAttachment *v18; 
  float adsViewBobScaleScale; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13427, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM7 = LODWORD(v8->fAdsViewBobMult);
  _XMM8 = 0i64;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0) )
  {
    __asm
    {
      vcmpless xmm0, xmm8, xmm1
      vblendvps xmm7, xmm7, xmm1, xmm0
    }
  }
  v14 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    v17 = WeaponAttachments_Internal;
    do
    {
      v18 = *v16;
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsViewBobScaleScale = v18->adsViewBobScaleScale;
      if ( adsViewBobScaleScale > 0.0 )
      {
        v20 = v14;
        *(float *)&v20 = *(float *)&v14 * adsViewBobScaleScale;
        v14 = v20;
      }
      ++v16;
      --v17;
    }
    while ( v17 );
  }
  return *(float *)&v14 * *(float *)&_XMM7;
}

/*
==============
BG_ADSZoomCount
==============
*/
__int64 BG_ADSZoomCount(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int adsZoomCount; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12800, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  if ( BG_CanHybridToggle(ps, r_weapon, isAlternate) )
    return 1i64;
  adsZoomCount = BG_WeaponCompleteDef(r_weapon, isAlternate)->zoomSettings.scene.adsZoomCount;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( WeaponAdsSettings )
    return (unsigned int)WeaponAdsSettings->zoomSettings.scene.adsZoomCount;
  return adsZoomCount;
}

/*
==============
BG_ADSZoomFov
==============
*/
float BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const BgWeaponMap *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  const BgWeaponMap *v10; 
  const WeaponCompleteDef *v11; 
  float result; 
  unsigned int zoomCount; 
  const BgWeaponMap *v14; 
  int ADSZoomLevel; 
  __int64 v16; 
  __int64 v17; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13259, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v8 = handler->GetWeaponMap(handler);
  if ( ps && v8 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v8, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope )
  {
    hybridScopeFractionInfo.fraction = FLOAT_1_0;
    hybridScopeFractionInfo.increasing = 1;
  }
  else
  {
    hybridScopeFractionInfo = 0i64;
  }
  v10 = handler->GetWeaponMap(handler);
  if ( !ps || !BG_PlayerUsesNVGHalfADS(ps, handler) || (v11 = BG_WeaponCompleteDef(r_weapon, isAlternate), result = v11->zoomSettings.weapon.adsNVGZoomFov, result <= 0.0) && (result = v11->zoomSettings.scene.adsFOVNVG, result <= 0.0) )
  {
    memset(&outZoomInfo, 0, sizeof(outZoomInfo));
    BG_GetADSZoomInfo(v10, r_weapon, isAlternate, &hybridScopeFractionInfo, &outZoomInfo);
    zoomCount = outZoomInfo.zoomCount;
    if ( outZoomInfo.zoomCount )
    {
      v14 = handler->GetWeaponMap(handler);
      ADSZoomLevel = BG_GetADSZoomLevel(v14, ps, r_weapon, zoomCount);
      v16 = ADSZoomLevel;
      if ( ADSZoomLevel >= zoomCount )
      {
        LODWORD(v17) = ADSZoomLevel;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13251, ASSERT_TYPE_ASSERT, "(unsigned)( adsZoomLevel ) < (unsigned)( adsZoomInfo.zoomCount )", "adsZoomLevel doesn't index adsZoomInfo.zoomCount\n\t%i not in [0, %i)", v17, zoomCount) )
          __debugbreak();
      }
      return outZoomInfo.zoomFov[v16];
    }
    else
    {
      return FLOAT_65_0;
    }
  }
  return result;
}

/*
==============
BG_ADSZoomFov
==============
*/
float BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, const bool getWeaponValues, bool *outIsNVGForcedFov)
{
  const BgWeaponMap *v11; 
  const WeaponCompleteDef *v12; 
  float result; 
  unsigned int zoomCount; 
  const BgWeaponMap *v15; 
  int ADSZoomLevel; 
  __int64 v17; 
  __int64 v18; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13224, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v11 = handler->GetWeaponMap(handler);
  if ( ps && BG_PlayerUsesNVGHalfADS(ps, handler) && ((v12 = BG_WeaponCompleteDef(r_weapon, isAlternate), getWeaponValues) && (result = v12->zoomSettings.weapon.adsNVGZoomFov, result > 0.0) || (result = v12->zoomSettings.scene.adsFOVNVG, result > 0.0)) )
  {
    *outIsNVGForcedFov = 1;
  }
  else
  {
    *outIsNVGForcedFov = 0;
    memset(&outZoomInfo, 0, sizeof(outZoomInfo));
    BG_GetADSZoomInfo(v11, r_weapon, isAlternate, hybridScopeFractionInfo, &outZoomInfo);
    zoomCount = outZoomInfo.zoomCount;
    if ( outZoomInfo.zoomCount )
    {
      v15 = handler->GetWeaponMap(handler);
      ADSZoomLevel = BG_GetADSZoomLevel(v15, ps, r_weapon, zoomCount);
      v17 = ADSZoomLevel;
      if ( ADSZoomLevel >= zoomCount )
      {
        LODWORD(v18) = ADSZoomLevel;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13251, ASSERT_TYPE_ASSERT, "(unsigned)( adsZoomLevel ) < (unsigned)( adsZoomInfo.zoomCount )", "adsZoomLevel doesn't index adsZoomInfo.zoomCount\n\t%i not in [0, %i)", v18, zoomCount) )
          __debugbreak();
      }
      return outZoomInfo.zoomFov[v17];
    }
    else
    {
      return FLOAT_65_0;
    }
  }
  return result;
}

/*
==============
BG_ActiveUnderbarrel
==============
*/
bool BG_ActiveUnderbarrel(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE;
}

/*
==============
BG_AddAttachmentModelToDObjHierarchy
==============
*/
void BG_AddAttachmentModelToDObjHierarchy(const Weapon *r_weapon, DObjModel *dobjModels, const unsigned __int8 attId, const WeaponAttachment *const weaponAttachment, const PlayerHandIndex hand, const bool useViewModel, const bool isDualWield, const DObjCamoParams *camoParams, const bool ignoreCollision, const bool stowedWeapon, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  const XModel *AttachmentModel; 
  bool attachRightWeaponAkimbo; 
  __int64 v19; 
  __int64 v20; 

  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1728, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1729, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( attId >= 0x1Du )
  {
    LODWORD(v19) = attId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1730, ASSERT_TYPE_ASSERT, "(unsigned)( attId ) < (unsigned)( WEAPON_ATTACHMENT_ID_COUNT )", "attId doesn't index WEAPON_ATTACHMENT_ID_COUNT\n\t%i not in [0, %i)", v19, 29) )
      __debugbreak();
  }
  AttachmentModel = BG_GetAttachmentModel(weaponAttachment, r_weapon->attachmentVariationIndices[attId], useViewModel);
  if ( AttachmentModel )
  {
    if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
    {
      LODWORD(v20) = 2;
      LODWORD(v19) = hand;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1648, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v19, v20) )
        __debugbreak();
    }
    if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1649, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
      __debugbreak();
    if ( isDualWield )
    {
      if ( hand == WEAPON_HAND_DEFAULT )
      {
        attachRightWeaponAkimbo = weaponAttachment->attachRightWeaponAkimbo;
        goto LABEL_22;
      }
      if ( hand == WEAPON_HAND_LEFT )
      {
        attachRightWeaponAkimbo = weaponAttachment->attachLeftWeaponAkimbo;
LABEL_22:
        if ( !attachRightWeaponAkimbo )
          return;
      }
    }
    BG_AddAttachmentModelToTag(hand, r_weapon, weaponAttachment, AttachmentModel, camoParams, ignoreCollision, stowedWeapon, dobjModels, maxModels, numModels, outWeaponIKModels);
  }
}

/*
==============
BG_AddAttachmentModelToTag
==============
*/
void BG_AddAttachmentModelToTag(const PlayerHandIndex hand, const Weapon *r_weapon, const WeaponAttachment *weaponAttachment, const XModel *attachmentModel, const DObjCamoParams *camoParams, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  scr_string_t attachPoint; 
  scr_string_t v15; 
  const char *WeaponName; 
  char output[1024]; 

  if ( !attachmentModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1607, ASSERT_TYPE_ASSERT, "(attachmentModel)", (const char *)&queryFormat, "attachmentModel") )
    __debugbreak();
  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1608, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1609, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !numModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1610, ASSERT_TYPE_ASSERT, "(numModels)", (const char *)&queryFormat, "numModels") )
    __debugbreak();
  if ( *numModels >= maxModels )
  {
    if ( !attachmentModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 121, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
      __debugbreak();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F572B0, 546i64, maxModels, attachmentModel->name);
  }
  attachPoint = weaponAttachment->attachPoint;
  if ( attachPoint && DObjModelsHasBone(dobjModels, *numModels, attachPoint) )
    v15 = weaponAttachment->attachPoint;
  else
    v15 = 0;
  DObjInitModel(attachmentModel, v15, ignoreCollision, stowedWeapon, camoParams, &dobjModels[*numModels]);
  ++*numModels;
  if ( outWeaponIKModels && weaponAttachment->containsIKTag && !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, attachmentModel) )
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1640, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", 12, WeaponName) )
      __debugbreak();
  }
}

/*
==============
BG_AddCarryObjectModel
==============
*/
__int64 BG_AddCarryObjectModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  unsigned int entityNum; 
  __int64 v9; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v13; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  entityNum = ci->entityNum;
  v9 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)numModels;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v9;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v9]);
  (*outModelTypes)[v9] = CHAR_MODEL_CARRY_OBJECT;
  v13 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v13;
  if ( v13 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v13;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v9 + 1);
}

/*
==============
BG_AddCarryObjectModelToCorpse
==============
*/
__int64 BG_AddCarryObjectModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v13; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)numModels;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v13 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v13;
  if ( v13 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v13;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
BG_AddGlobalAmmoForAmmoType
==============
*/
void BG_AddGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  __m256i *GlobalAmmoSlot; 
  int v7; 
  bool v8; 
  int v9; 
  int v10; 
  WeaponAmmoType ammoType; 
  int v12; 

  GlobalAmmoSlot = (__m256i *)BG_GlobalAmmoForAmmoType(ps, r_ammoType);
  if ( !GlobalAmmoSlot )
  {
    GlobalAmmoSlot = (__m256i *)BG_FindGlobalAmmoSlot(ps);
    *GlobalAmmoSlot = *(__m256i *)&r_ammoType->weapon.weaponIdx;
    GlobalAmmoSlot[1] = *(__m256i *)&r_ammoType->weapon.attachmentVariationIndices[5];
    GlobalAmmoSlot[2].m256i_i32[0] = 0;
  }
  v7 = GlobalAmmoSlot[2].m256i_i32[0];
  v8 = ammoCount + v7 < 0;
  v9 = ammoCount + v7;
  GlobalAmmoSlot[2].m256i_i32[0] = v9;
  if ( v8 )
  {
    v12 = v9;
    ammoType = r_ammoType->ammoType;
    v10 = ammoCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6838, ASSERT_TYPE_ASSERT, "(globalAmmo->ammoCount >= 0)", "%s\n\tAfter adding %i rounds to the ammoCount for ammoType %i, we have %i rounds not in the clip", "globalAmmo->ammoCount >= 0", v10, ammoType, v12) )
      __debugbreak();
  }
}

/*
==============
BG_AddIgnoreEntToBP
==============
*/
void BG_AddIgnoreEntToBP(BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 550, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !BG_IsIgnoreEntInBP(bp, entityIndex) )
  {
    ignoreHitEntCount = bp->ignoreHitEntCount;
    if ( ignoreHitEntCount >= 16 )
    {
      Com_PrintWarning(14, "BG_AddIgnoreEntToBP: %d is too many ignore hit entities.  May want to increase limit (BULLET_MAX_IGNORE_HIT_ENTRIES) of %d. \n", (unsigned int)ignoreHitEntCount, 16i64);
      ignoreHitEntCount = bp->ignoreHitEntCount;
    }
    bp->ignoreHitEntityQueue[ignoreHitEntCount % 16] = entityIndex;
    ++bp->ignoreHitEntCount;
  }
}

/*
==============
BG_AddParachuteModel
==============
*/
__int64 BG_AddParachuteModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const SuitDef *SuitDef; 
  int v11; 
  _QWORD *v12; 
  __int64 v13; 
  __int64 v14; 
  scr_string_t tag_ik_loc_le; 
  const XModel *v16; 
  const XModel *v17; 
  scr_string_t tag_ik_loc_ri; 
  const XModel *v19; 
  const XModel *v20; 
  unsigned int v21; 
  const SuitDef *v22; 
  unsigned int v23; 
  unsigned int entityNum; 
  const char *Name; 
  char *fmt; 
  __int64 ignoreCollision; 
  vec3_t offsets; 
  vec4_t quat; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
    return (unsigned int)v8;
  SuitDef = BG_GetSuitDef(ci->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22944, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  if ( !SuitDef->skydive_parachuteWorldModel )
    return (unsigned int)v8;
  offsets.v[0] = 0.0;
  offsets.v[1] = 0.0;
  offsets.v[2] = 0.0;
  quat = quat_identity;
  DObjInitSubmodel(SuitDef->skydive_parachuteWorldModel, (const scr_string_t)scr_const.j_spine4, 0, &offsets, &quat, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_PARACHUTE;
  v11 = XModelNumBones(SuitDef->skydive_parachuteWorldModel);
  v12 = NtCurrentTeb()->Reserved1[11];
  v13 = tls_index;
  *outBonesAdded += v11;
  if ( !*(_QWORD *)(v12[v13] + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v14 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v13) + 272i64);
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22974, ASSERT_TYPE_ASSERT, "(bgameStatic)", (const char *)&queryFormat, "bgameStatic") )
    __debugbreak();
  tag_ik_loc_le = scr_const.tag_ik_loc_le;
  v16 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 136i64))(v14);
  DObjInitModel(v16, tag_ik_loc_le, 1, 0, NULL, &dobjModels[v8 + 1]);
  (*outModelTypes)[v8 + 1] = CHAR_MODEL_IK_TARGET;
  v17 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 136i64))(v14);
  *outBonesAdded += XModelNumBones(v17);
  tag_ik_loc_ri = scr_const.tag_ik_loc_ri;
  v19 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 144i64))(v14);
  DObjInitModel(v19, tag_ik_loc_ri, 1, 0, NULL, &dobjModels[v8 + 2]);
  (*outModelTypes)[v8 + 2] = CHAR_MODEL_IK_TARGET;
  v20 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 144i64))(v14);
  *outBonesAdded += XModelNumBones(v20);
  v21 = v8 + 3;
  if ( totalBoneCountSoFar + *outBonesAdded > 0xFE )
  {
    v22 = BG_GetSuitDef(ci->suitIndex);
    if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22991, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v23 = *outBonesAdded;
    entityNum = ci->entityNum;
    Name = XModelGetName(v22->skydive_parachuteWorldModel);
    LODWORD(ignoreCollision) = v23;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for parachute model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, entityNum, fmt, ignoreCollision);
  }
  return v21;
}

/*
==============
BG_AddParachuteModelToCorpse
==============
*/
__int64 BG_AddParachuteModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v9; 
  const SuitDef *SuitDef; 
  const SuitDef *v12; 
  unsigned int v13; 
  const char *Name; 
  char *fmt; 
  __int64 ignoreCollision; 
  vec3_t offsets; 
  vec4_t quat; 

  v9 = numModels;
  *outBonesAdded = 0;
  if ( !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
    return (unsigned int)v9;
  SuitDef = BG_GetSuitDef(ci->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22944, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  if ( !SuitDef->skydive_parachuteWorldModel )
    return (unsigned int)v9;
  offsets.v[0] = 0.0;
  offsets.v[1] = 0.0;
  offsets.v[2] = 0.0;
  quat = quat_identity;
  DObjInitSubmodel(SuitDef->skydive_parachuteWorldModel, (const scr_string_t)scr_const.j_spine4, 0, &offsets, &quat, 1, 0, NULL, &dobjModels[v9]);
  (*outModelTypes)[v9] = CHAR_MODEL_PARACHUTE;
  *outBonesAdded += XModelNumBones(SuitDef->skydive_parachuteWorldModel);
  if ( totalBoneCountSoFar + *outBonesAdded > 0xFE )
  {
    v12 = BG_GetSuitDef(ci->suitIndex);
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23011, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v13 = *outBonesAdded;
    Name = XModelGetName(v12->skydive_parachuteWorldModel);
    LODWORD(ignoreCollision) = v13;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for parachute model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entNum, fmt, ignoreCollision);
  }
  return (unsigned int)(v9 + 1);
}

/*
==============
BG_AddStreamedViewWeaponsToList
==============
*/
char BG_AddStreamedViewWeaponsToList(const BgWeaponMap *const weaponMap, const playerState_s *const ps, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  int v4; 
  WeaponSlot *i; 
  const Weapon *Weapon; 
  __int64 v11; 
  Weapon *v12; 

  v4 = 0;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22664, ASSERT_TYPE_ASSERT, "( ( weaponMap != nullptr ) )", "( weaponMap ) = %p", NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22665, ASSERT_TYPE_ASSERT, "( ( ps != nullptr ) )", "( ps ) = %p", NULL) )
    __debugbreak();
  for ( i = &ps->weapEquippedData[0].slot; ; i += 4 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4]);
    if ( !BG_WeaponHasStreamedModels(Weapon) || *i == WEAPON_SLOT_EXECUTION )
      goto LABEL_18;
    v11 = *inOutWeaponCount;
    if ( (unsigned int)v11 >= 0x18 )
      break;
    v12 = &(*outViewWeapons)[v11];
    *(__m256i *)&v12->weaponIdx = *(__m256i *)&Weapon->weaponIdx;
    *(_OWORD *)&v12->attachmentVariationIndices[5] = *(_OWORD *)&Weapon->attachmentVariationIndices[5];
    *(double *)&v12->attachmentVariationIndices[21] = *(double *)&Weapon->attachmentVariationIndices[21];
    *(_DWORD *)&v12->weaponCamo = *(_DWORD *)&Weapon->weaponCamo;
    ++*inOutWeaponCount;
LABEL_18:
    if ( (unsigned int)++v4 >= 0xF )
      return 1;
  }
  return 0;
}

/*
==============
BG_AddStreamedWeaponModelToList
==============
*/
void BG_AddStreamedWeaponModelToList(const XModel *const addModel, const XModel *(*outList)[32], unsigned int *outCurListPos)
{
  unsigned int v6; 
  __int64 v7; 
  __int64 v8; 

  if ( !outList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22457, ASSERT_TYPE_ASSERT, "(outList)", (const char *)&queryFormat, "outList") )
    __debugbreak();
  if ( addModel )
  {
    v6 = *outCurListPos;
    v7 = 0i64;
    if ( *outCurListPos )
    {
      while ( (*outList)[v7] != addModel )
      {
        v7 = (unsigned int)(v7 + 1);
        if ( (unsigned int)v7 >= v6 )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      if ( v6 >= 0x20 )
      {
        LODWORD(v8) = *outCurListPos;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22472, ASSERT_TYPE_ASSERT, "(unsigned)( outCurListPos ) < (unsigned)( ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) + 3 ) )", "outCurListPos doesn't index MAX_NUM_WEAPON_STREAMED_XMODELS\n\t%i not in [0, %i)", v8, 32) )
          __debugbreak();
      }
      (*outList)[(*outCurListPos)++] = addModel;
    }
  }
}

/*
==============
BG_AddWeaponAttachmentModels
==============
*/
void BG_AddWeaponAttachmentModels(const Weapon *r_weapon, const PlayerHandIndex hand, bool isDualWield, bool useViewModel, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels, const DObjCamoParams *camoParams)
{
  AttachmentSlot v13; 
  __int64 v14; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  unsigned int v16; 
  int v17; 
  const WeaponAttachment *v18; 
  unsigned __int8 v19; 
  __int64 useViewModela; 
  __int64 isDualWielda; 
  DObjModel *dobjModelsa; 

  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1745, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !numModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1746, ASSERT_TYPE_ASSERT, "(numModels)", (const char *)&queryFormat, "numModels") )
    __debugbreak();
  dobjModelsa = (DObjModel *)BG_WeaponCompleteDef(r_weapon, 0);
  v13 = ATT_SLOT_RECEIVER;
  v14 = 0i64;
  do
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, v13);
    if ( WeaponPrimaryAttachment )
      BG_AddAttachmentModelToDObjHierarchy(r_weapon, dobjModels, v13, WeaponPrimaryAttachment, hand, useViewModel, isDualWield, camoParams, ignoreCollision, stowedWeapon, maxModels, numModels, outWeaponIKModels);
    ++v13;
    ++v14;
  }
  while ( (unsigned int)v13 < ATT_SLOT_OTHER );
  v16 = 0;
  if ( r_weapon->weaponOthers )
  {
    if ( dobjModelsa[3].boneName > 0x10u )
    {
      LODWORD(isDualWielda) = 16;
      LODWORD(useViewModela) = dobjModelsa[3].boneName;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1763, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", useViewModela, isDualWielda) )
        __debugbreak();
    }
    if ( dobjModelsa[3].boneName )
    {
      do
      {
        v17 = 1 << v16;
        if ( (1 << v16 < 0 || (unsigned int)v17 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,int>(int)", "unsigned", (unsigned __int16)v17, "signed", v17) )
          __debugbreak();
        if ( ((unsigned __int16)v17 & r_weapon->weaponOthers) != 0 )
        {
          v18 = *(const WeaponAttachment **)(*(_QWORD *)dobjModelsa[3].offsets.v + 8i64 * v16);
          if ( v16 >= 0x10 )
          {
            LODWORD(isDualWielda) = 16;
            LODWORD(useViewModela) = v16;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", useViewModela, isDualWielda) )
              __debugbreak();
          }
          v19 = truncate_cast<unsigned char,unsigned int>(v16 + 13);
          BG_AddAttachmentModelToDObjHierarchy(r_weapon, dobjModels, v19, v18, hand, useViewModel, isDualWield, camoParams, ignoreCollision, stowedWeapon, maxModels, numModels, outWeaponIKModels);
        }
        ++v16;
      }
      while ( v16 < dobjModelsa[3].boneName );
    }
  }
}

/*
==============
BG_AdvanceTrace
==============
*/
bool BG_AdvanceTrace(BulletFireParams *bp, const trace_t *trace, const vec3_t *hitPos, float dist)
{
  int EntityHitId; 
  int ignoreHitEntCount; 
  float v9; 
  float travelDistance; 
  float v11; 
  bool result; 
  float v13; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 617, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !trace && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 618, ASSERT_TYPE_ASSERT, "(trace)", (const char *)&queryFormat, "trace") )
    __debugbreak();
  if ( trace->hitType == TRACE_HITTYPE_BEGIN && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 619, ASSERT_TYPE_ASSERT, "(trace->hitType != TRACE_HITTYPE_NONE)", (const char *)&queryFormat, "trace->hitType != TRACE_HITTYPE_NONE") )
    __debugbreak();
  EntityHitId = Trace_GetEntityHitId(trace);
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 550, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !BG_IsIgnoreEntInBP(bp, EntityHitId) )
  {
    ignoreHitEntCount = bp->ignoreHitEntCount;
    if ( ignoreHitEntCount >= 16 )
    {
      Com_PrintWarning(14, "BG_AddIgnoreEntToBP: %d is too many ignore hit entities.  May want to increase limit (BULLET_MAX_IGNORE_HIT_ENTRIES) of %d. \n", (unsigned int)ignoreHitEntCount, 16i64);
      ignoreHitEntCount = bp->ignoreHitEntCount;
    }
    bp->ignoreHitEntityQueue[ignoreHitEntCount % 16] = EntityHitId;
    ++bp->ignoreHitEntCount;
  }
  if ( !BG_IsIgnoreEntInBP(bp, 2046) || dist <= 0.0 )
  {
    bp->start.v[0] = hitPos->v[0];
    bp->start.v[1] = hitPos->v[1];
    v11 = hitPos->v[2];
    goto LABEL_23;
  }
  v9 = (float)((float)(trace->normal.v[1] * bp->dir.v[1]) + (float)(trace->normal.v[0] * bp->dir.v[0])) + (float)(trace->normal.v[2] * bp->dir.v[2]);
  travelDistance = bp->travelDistance;
  if ( v9 <= -0.125 )
  {
    v13 = (float)(-1.0 / v9) * dist;
    bp->travelDistance = travelDistance + v13;
    bp->start.v[0] = (float)(v13 * bp->dir.v[0]) + hitPos->v[0];
    bp->start.v[1] = (float)(v13 * bp->dir.v[1]) + hitPos->v[1];
    v11 = (float)(v13 * bp->dir.v[2]) + hitPos->v[2];
LABEL_23:
    result = 1;
    goto LABEL_24;
  }
  bp->travelDistance = travelDistance + (float)(dist * 8.0);
  bp->start.v[0] = (float)((float)(dist * 8.0) * bp->dir.v[0]) + hitPos->v[0];
  bp->start.v[1] = (float)((float)(dist * 8.0) * bp->dir.v[1]) + hitPos->v[1];
  v11 = (float)((float)(dist * 8.0) * bp->dir.v[2]) + hitPos->v[2];
  result = 0;
LABEL_24:
  bp->start.v[2] = v11;
  return result;
}

/*
==============
BG_AimAssistLockonStrength
==============
*/
float BG_AimAssistLockonStrength(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->aimAssistLockonStrength;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8361, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    aimAssist = (*i)->aimAssist;
    if ( aimAssist )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->aimAssistLockonStrength;
  }
  return aimAssist->aimAssistLockonStrength;
}

/*
==============
BG_AimAssistRange
==============
*/
void BG_AimAssistRange(const Weapon *r_weapon, bool isAlternate, float *aimAssistRange, float *aimAssistRangeAds)
{
  const WeaponDef *v8; 
  int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v12; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !aimAssistRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8301, ASSERT_TYPE_ASSERT, "(aimAssistRange)", (const char *)&queryFormat, "aimAssistRange") )
    __debugbreak();
  if ( !aimAssistRangeAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8302, ASSERT_TYPE_ASSERT, "(aimAssistRangeAds)", (const char *)&queryFormat, "aimAssistRangeAds") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *aimAssistRange = v8->aimAssistRange;
  *aimAssistRangeAds = v8->aimAssistRangeAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8310, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *i;
      aimAssist = (*i)->aimAssist;
      if ( aimAssist )
        break;
      if ( ++v9 >= WeaponAttachments_Internal )
        return;
    }
    *aimAssistRange = aimAssist->aimAssistRange;
    *aimAssistRangeAds = v12->aimAssist->aimAssistRangeAds;
  }
}

/*
==============
BG_AimAssistSlowdown
==============
*/
void BG_AimAssistSlowdown(const Weapon *r_weapon, bool isAlternate, float *aimAssistPitchSlowdown, float *aimAssistPitchSlowdownAds, float *aimAssistYawSlowdown, float *aimAssistYawSlowdownAds)
{
  const WeaponDef *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v14; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !aimAssistPitchSlowdown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8327, ASSERT_TYPE_ASSERT, "(aimAssistPitchSlowdown)", (const char *)&queryFormat, "aimAssistPitchSlowdown") )
    __debugbreak();
  if ( !aimAssistPitchSlowdownAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8328, ASSERT_TYPE_ASSERT, "(aimAssistPitchSlowdownAds)", (const char *)&queryFormat, "aimAssistPitchSlowdownAds") )
    __debugbreak();
  if ( !aimAssistYawSlowdown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8329, ASSERT_TYPE_ASSERT, "(aimAssistYawSlowdown)", (const char *)&queryFormat, "aimAssistYawSlowdown") )
    __debugbreak();
  if ( !aimAssistYawSlowdownAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8330, ASSERT_TYPE_ASSERT, "(aimAssistYawSlowdownAds)", (const char *)&queryFormat, "aimAssistYawSlowdownAds") )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v11 = 0;
  *aimAssistPitchSlowdown = v10->aimAssistPitchSlowdown;
  *aimAssistPitchSlowdownAds = v10->aimAssistPitchSlowdownAds;
  *aimAssistYawSlowdown = v10->aimAssistYawSlowdown;
  *aimAssistYawSlowdownAds = v10->aimAssistYawSlowdownAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8340, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v14 = *i;
      aimAssist = (*i)->aimAssist;
      if ( aimAssist )
        break;
      if ( ++v11 >= WeaponAttachments_Internal )
        return;
    }
    *aimAssistPitchSlowdown = aimAssist->aimAssistPitchSlowdown;
    *aimAssistPitchSlowdownAds = v14->aimAssist->aimAssistPitchSlowdownAds;
    *aimAssistYawSlowdown = v14->aimAssist->aimAssistYawSlowdown;
    *aimAssistYawSlowdownAds = v14->aimAssist->aimAssistYawSlowdownAds;
  }
}

/*
==============
BG_AllowWeaponSwitchWhileHoldingGrenade
==============
*/
bool BG_AllowWeaponSwitchWhileHoldingGrenade(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9972, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->allowGrenadeSwitching;
}

/*
==============
BG_AltDropADSTime
==============
*/
__int64 BG_AltDropADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 138i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltDropAkimboTime
==============
*/
__int64 BG_AltDropAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 140i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltDropTime
==============
*/
__int64 BG_AltDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 136i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltOverride3PInTime
==============
*/
__int64 BG_AltOverride3PInTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 92i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltOverride3PIsADS
==============
*/
bool BG_AltOverride3PIsADS(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return (unsigned __int16)(unsigned __int8)BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 191i64, WEAP_ANIM_3P_ADDITIVE_ALT_OVERRIDE) != 0;
}

/*
==============
BG_AltOverride3POutTime
==============
*/
__int64 BG_AltOverride3POutTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 94i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseADSTime
==============
*/
__int64 BG_AltRaiseADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 6i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseAkimboTime
==============
*/
__int64 BG_AltRaiseAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 8i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseTime
==============
*/
__int64 BG_AltRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltSharesAmmo
==============
*/
bool BG_AltSharesAmmo(const Weapon *r_weapon)
{
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned int v2; 
  bool result; 
  WeaponAttachment **v4; 
  WeaponAttachment *v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  v2 = 0;
  result = 0;
  if ( AllWeaponAttachmentsWithIds )
  {
    v4 = attachments;
    do
    {
      if ( result )
        break;
      if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5026, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v5 = *v4;
      ++v2;
      ++v4;
      result = v5->shareAmmoWithAlt;
    }
    while ( v2 < AllWeaponAttachmentsWithIds );
  }
  return result;
}

/*
==============
BG_AlwaysFireAtMaxRangeInAds
==============
*/
_BOOL8 BG_AlwaysFireAtMaxRangeInAds(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v7; 
  const AttADSSettings *WeaponAdsSettings; 

  v7 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v7, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->alwaysFireAtMaxRangeInAds;
  else
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->alwaysFireAtMaxRangeInAds;
}

/*
==============
BG_AmmoCounterClip
==============
*/
__int64 BG_AmmoCounterClip(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ammoCounterClipType_t ammoCounterClip; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttUI *ui; 
  unsigned int v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  ammoCounterClip = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ammoCounterClip;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16348, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ui = (*i)->ui;
      if ( ui )
        break;
      if ( ++v4 >= WeaponAttachments_Internal )
        return (unsigned int)ammoCounterClip;
    }
    v9 = ui->ammoCounterClip;
    if ( v9 )
      return v9;
  }
  return (unsigned int)ammoCounterClip;
}

/*
==============
BG_AmmoUsedPerShot
==============
*/
__int64 BG_AmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  __int64 result; 
  int iAmmoUsedPerShot; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8567, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      result = (unsigned int)(*v5)->ammoUsedPerShotOverride;
      if ( (int)result > 0 )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    iAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iAmmoUsedPerShot;
    result = 1i64;
    if ( iAmmoUsedPerShot > 0 )
      return (unsigned int)iAmmoUsedPerShot;
  }
  return result;
}

/*
==============
BG_AnyUnderbarrelWeaponEquipped
==============
*/
__int64 BG_AnyUnderbarrelWeaponEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  unsigned int v4; 
  const Weapon *Weapon; 
  unsigned __int8 v6; 
  const WeaponCompleteDef *v7; 
  const WeaponCompleteDef *v8; 
  WeaponAttachment *v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1092, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1093, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v4 >= 0xF )
    {
      LODWORD(v12) = 15;
      LODWORD(v11) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v11, v12) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4]);
    if ( !Weapon->weaponIdx )
      goto LABEL_29;
    v6 = Weapon->weaponAttachments[10];
    if ( !v6 )
      goto LABEL_29;
    v7 = BG_WeaponCompleteDef(Weapon, 0);
    v8 = v7;
    if ( v6 > v7->attachments[10].attachmentCount )
    {
      LODWORD(v13) = v7->attachments[10].attachmentCount;
      LODWORD(v12) = 1;
      LODWORD(v11) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", v11, v12, v13) )
        __debugbreak();
    }
    v9 = v8->attachments[10].attachments[v6 - 1];
    if ( v9 )
      break;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v8->szInternalName) )
      __debugbreak();
LABEL_29:
    if ( (int)++v4 >= 15 )
      return 0i64;
  }
  if ( (v9->weapClass != WEAPCLASS_GRENADE || v9->weaponType != WEAPTYPE_PROJECTILE) && !BG_IsUnderbarrelShotgun(v9) )
    goto LABEL_29;
  return 1i64;
}

/*
==============
BG_ApplyWeaponAnglesToShootingDirection
==============
*/
void BG_ApplyWeaponAnglesToShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t *angles, const vec3_t (*anglesCategorized)[30], const vec3_t *oldAngles, vec3_t *outNewAngles, vec3_t *outShootingAnglesLocal)
{
  float v13; 
  vec3_t outAngles; 
  tmat33_t<vec3_t> in2; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> out; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20088, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anglesCategorized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20089, ASSERT_TYPE_ASSERT, "(anglesCategorized)", (const char *)&queryFormat, "anglesCategorized") )
    __debugbreak();
  *outNewAngles = *oldAngles;
  BG_GetWeaponAnglesForShootingDirection(weaponMap, ps, r_weapon, isAlternate, anglesCategorized, &outAngles);
  v13 = outAngles.v[1];
  outShootingAnglesLocal->v[0] = outAngles.v[0];
  outShootingAnglesLocal->v[2] = outAngles.v[2];
  outShootingAnglesLocal->v[1] = v13;
  AnglesToAxis(&outAngles, &axis);
  AnglesToAxis(outNewAngles, &in2);
  MatrixMultiply(&axis, &in2, &out);
  AxisToAngles(&out, outNewAngles);
}

/*
==============
BG_AssertOffhandIndexOrNone
==============
*/
void BG_AssertOffhandIndexOrNone(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 
  const char *WeaponName; 
  char output[1024]; 

  weaponIdx = r_weapon->weaponIdx;
  if ( weaponIdx && BG_WeaponDefAtIndex(weaponIdx)->offhandClass == OFFHAND_CLASS_NONE )
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5008, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Weapon (%s) expected to be offhand weapon or no weapon at all, but is not.", WeaponName) )
      __debugbreak();
  }
}

/*
==============
BG_AttachmentUseMainSettings
==============
*/
bool BG_AttachmentUseMainSettings(const WeaponAttachment *attachment, const bool isAlternate, const bool isUsingHybridScope)
{
  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8182, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  return attachment->type == ATTACHMENT_UNDERBARREL && !isAlternate || BG_CanAttachmentHybridToggle(attachment) && !isUsingHybridScope;
}

/*
==============
BG_AutoAimRange
==============
*/
float BG_AutoAimRange(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float autoAimRange; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  autoAimRange = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->autoAimRange;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return autoAimRange;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8283, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    aimAssist = (*i)->aimAssist;
    if ( aimAssist )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return autoAimRange;
  }
  return aimAssist->autoAimRange;
}

/*
==============
BG_BlastBackTime
==============
*/
__int64 BG_BlastBackTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 196i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastFrontTime
==============
*/
__int64 BG_BlastFrontTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 192i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastLeftTime
==============
*/
__int64 BG_BlastLeftTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 198i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastRightTime
==============
*/
__int64 BG_BlastRightTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 194i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlocksNVGADS
==============
*/
bool BG_BlocksNVGADS(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v5; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    v5 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1230, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    sight = v5->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return sight->blockNVGADS;
}

/*
==============
BG_BlurSceneAdsInFraction
==============
*/
float BG_BlurSceneAdsInFraction(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v6; 
  float *p_blurSceneAdsInFraction; 
  float result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v10[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v10, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blurSceneAdsInFraction;
  for ( i = attachments; ; ++i )
  {
    v6 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1186, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    p_blurSceneAdsInFraction = &v6->sight->blurSceneAdsInFraction;
    if ( p_blurSceneAdsInFraction )
    {
      result = *p_blurSceneAdsInFraction;
      if ( *p_blurSceneAdsInFraction > 0.0 )
        break;
    }
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blurSceneAdsInFraction;
  }
  return result;
}

/*
==============
BG_BlurSceneAdsOutFraction
==============
*/
float BG_BlurSceneAdsOutFraction(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v6; 
  AttSight *sight; 
  float result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v10[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v10, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blurSceneAdsOutFraction;
  for ( i = attachments; ; ++i )
  {
    v6 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1209, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    sight = v6->sight;
    if ( sight )
    {
      result = sight->blurSceneAdsOutFraction;
      if ( result > 0.0 )
        break;
    }
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blurSceneAdsOutFraction;
  }
  return result;
}

/*
==============
BG_BoltActionReloadIncludesRechamber
==============
*/
__int64 BG_BoltActionReloadIncludesRechamber(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->boltActionReloadIncludesRechamber;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8046, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0x14D7];
}

/*
==============
BG_BreachRaiseTime
==============
*/
__int64 BG_BreachRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 146i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Interpolated
==============
*/
void BG_BuildExplosionDamageRangeInfo_Interpolated(const float innerDamage, const float outerDamage, const float damageRadius, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  outDamageRangeInfo->midRadius = damageRadius;
  outDamageRangeInfo->outerRadius = damageRadius;
  outDamageRangeInfo->innerDamage = innerDamage;
  outDamageRangeInfo->midDamage = outerDamage;
  outDamageRangeInfo->outerDamage = outerDamage;
  outDamageRangeInfo->useSteppedDamage = 0;
  outDamageRangeInfo->innerRadius = 0.0;
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Stepped
==============
*/
void BG_BuildExplosionDamageRangeInfo_Stepped(const float innerRange, const float innerDamage, const float midRange, const float midDamage, const float outerRange, const float outerDamage, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  outDamageRangeInfo->innerRadius = innerRange;
  outDamageRangeInfo->innerDamage = innerDamage;
  outDamageRangeInfo->outerRadius = outerRange;
  outDamageRangeInfo->outerDamage = outerDamage;
  outDamageRangeInfo->midRadius = midRange;
  outDamageRangeInfo->midDamage = midDamage;
  outDamageRangeInfo->useSteppedDamage = 1;
}

/*
==============
BG_BuildWeaponAnimArrays
==============
*/
_BOOL8 BG_BuildWeaponAnimArrays(const playerState_s *ps, const Weapon *r_weapon, bool bIsDualWielding, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const WeaponDef *v14; 
  const WeaponDef *v15; 
  WeaponAnimPackage *szXAnimsRightHanded; 
  bool v17; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  __int64 v20; 
  unsigned int v21; 
  AnimOverride *v22; 
  int HasUnderbarrelAmmo; 
  bool v26; 
  int v28; 
  AnimOverride *animOverrides[23]; 

  Sys_ProfBeginNamedEvent(0xFF808080, "BG_BuildWeaponAnimArrays");
  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18853, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18854, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18855, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18857, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( outFootsteps && numAnims < 608 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18863, ASSERT_TYPE_ASSERT, "(numAnims >= NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "numAnims >= NUM_WEAP_VIEWMODEL_ANIMS") )
    __debugbreak();
  memset_0(animOverrides, 0, 0xA8ui64);
  v14 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v15 = v14;
  if ( !bIsDualWielding )
    goto LABEL_24;
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2738, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnimsRightHanded = v15->szXAnimsRightHanded;
  if ( szXAnimsRightHanded && *((_QWORD *)szXAnimsRightHanded->anims + 236) )
  {
    v17 = BG_BuildWeaponAnimArrays_DualWield(ps, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
  }
  else
  {
LABEL_24:
    IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
    v26 = IsMeleeComboOverride;
    AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
    v28 = AllWeaponAttachmentsCount;
    if ( IsMeleeComboOverride || AllWeaponAttachmentsCount )
    {
      v20 = 0i64;
      v21 = 0;
      if ( v15->numAnimOverrides )
      {
        do
        {
          v22 = &v15->animOverrides[v21];
          if ( BG_WeaponHasOverride(r_weapon, v22->bindings, v22->numBindings) )
          {
            animOverrides[v20] = v22;
            v20 = (unsigned int)(v20 + 1);
          }
          ++v21;
        }
        while ( v21 < v15->numAnimOverrides );
        IsMeleeComboOverride = v26;
      }
      BG_BuildWeaponAnimArrays_BaseAnimations(bIsAlternate, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      if ( IsMeleeComboOverride )
      {
        BG_BuildWeaponAnimArrays_MeleeComboWeapon(ps, r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      }
      else
      {
        BG_BuildWeaponAnimArrays_AttachmentOverrides(ps, r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
        BG_BuildWeaponAnimArrays_MeleeOverrides(r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      }
      if ( startAnim == WEAP_ANIM_ROOT && numAnims == 608 )
        BG_BuildWeaponAnimArrays_BlendSpaceOverrides(r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, WEAP_ANIM_ROOT, 608);
      BG_BuildWeaponAnimArrays_CarryOverrides(ps, v15, normalAnimArray, altAnimArray, startAnim, numAnims);
      if ( numAnims == 608 )
      {
        HasUnderbarrelAmmo = BG_HasUnderbarrelAmmo(r_weapon);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_ADS_DOWN);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_ADS_UP);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_SCOPE_TOGGLE_ON);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_SCOPE_TOGGLE_OFF);
      }
      v17 = v28 > 0 || IsMeleeComboOverride;
    }
    else
    {
      v17 = BG_BuildWeaponAnimArrays_NoAttachments(ps, v15, bIsAlternate, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
    }
  }
  Sys_ProfEndNamedEvent();
  return v17;
}

/*
==============
BG_BuildWeaponAnimArrays_AttachmentOverrides
==============
*/
void BG_BuildWeaponAnimArrays_AttachmentOverrides(const playerState_s *ps, const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v15; 
  unsigned int v16; 
  weapAnimFiles_t v17; 
  unsigned __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  const AnimOverride **v21; 
  __int64 v22; 
  __int64 v23; 
  const AnimOverride *v24; 
  unsigned int numBindings; 
  unsigned int v26; 
  unsigned int v27; 
  WeaponAnimPackage *overrides; 
  XAnimParts *v29; 
  __int64 v30; 
  FootstepAnim *v31; 
  FootstepAnim *v32; 
  __int128 v33; 
  WeaponAnimPackage *overridesAlt; 
  XAnimParts *v35; 
  FootstepAnim *v36; 
  FootstepAnim *v37; 
  __int64 v38; 
  __int128 v39; 
  __int64 v40; 
  __int64 v41; 
  __int64 v43; 
  XAnimParts **v44; 
  XAnimParts **v45; 
  int v46[616]; 
  int v47[616]; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18625, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18626, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18627, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v15 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18628, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18629, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18631, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  memset_0(v47, 0, 0x998ui64);
  memset_0(v46, 0, 0x998ui64);
  if ( numAnims > 0 )
  {
    v16 = numAnimOverrides;
    v17 = startAnim;
    v43 = (unsigned int)numAnims;
    v18 = 8i64 * (int)startAnim;
    v44 = &normalAnimArray[v18 / 0xFFFFFFFFFFFFFFF8ui64];
    v19 = 0i64;
    v45 = &altAnimArray[v18 / 0xFFFFFFFFFFFFFFF8ui64];
    do
    {
      if ( (unsigned int)v17 >= NUM_WEAP_ANIMS )
      {
        LODWORD(v41) = 614;
        LODWORD(v40) = v17;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v40, v41) )
          __debugbreak();
        v16 = numAnimOverrides;
      }
      v20 = 0i64;
      while ( FootstepToAnimMap[v20] != v17 )
      {
        if ( (unsigned __int64)++v20 >= 9 )
        {
          LODWORD(v20) = -1;
          break;
        }
      }
      if ( (unsigned int)(v17 - 262) > 0x17 && (unsigned int)(v17 - 448) > 0x9F && v16 )
      {
        v21 = v15;
        v22 = v16;
        v23 = (int)v20;
        do
        {
          v24 = *v21;
          if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18657, ASSERT_TYPE_ASSERT, "(animOverride != nullptr)", (const char *)&queryFormat, "animOverride != nullptr") )
            __debugbreak();
          numBindings = v24->numBindings;
          v26 = v47[v19];
          if ( v24->numBindings > v26 || numBindings > v46[v19] )
          {
            v27 = v24->numBindings;
            if ( numBindings > v26 )
            {
              overrides = v24->overrides;
              if ( overrides )
              {
                v29 = overrides->anims[v18 / 8];
                v27 = v24->numBindings;
                if ( v29 )
                {
                  v44[v18 / 8] = v29;
                  v27 = v24->numBindings;
                  v47[v19] = v24->numBindings;
                  if ( !bIsAlternate && outFootsteps && v23 != -1 )
                  {
                    v30 = 4i64;
                    v31 = &overrides->footstep[v23];
                    v32 = &outFootsteps[v23];
                    do
                    {
                      v32 = (FootstepAnim *)((char *)v32 + 128);
                      v33 = *(_OWORD *)&v31->leftCount;
                      v31 = (FootstepAnim *)((char *)v31 + 128);
                      *(_OWORD *)&v32[-1].movement[16].time = v33;
                      *(_OWORD *)&v32[-1].movement[18].time = *(_OWORD *)&v31[-1].movement[18].time;
                      *(_OWORD *)&v32[-1].movement[20].time = *(_OWORD *)&v31[-1].movement[20].time;
                      *(_OWORD *)&v32[-1].movement[22].time = *(_OWORD *)&v31[-1].movement[22].time;
                      *(_OWORD *)&v32[-1].movement[24].time = *(_OWORD *)&v31[-1].movement[24].time;
                      *(_OWORD *)&v32[-1].movement[26].time = *(_OWORD *)&v31[-1].movement[26].time;
                      *(_OWORD *)&v32[-1].movement[28].time = *(_OWORD *)&v31[-1].movement[28].time;
                      *(_OWORD *)&v32[-1].movement[30].time = *(_OWORD *)&v31[-1].movement[30].time;
                      --v30;
                    }
                    while ( v30 );
                    v32->leftCount = v31->leftCount;
                    v27 = v24->numBindings;
                  }
                }
              }
            }
            if ( v27 > v46[v19] )
            {
              overridesAlt = v24->overridesAlt;
              if ( overridesAlt )
              {
                v35 = overridesAlt->anims[v18 / 8];
                if ( v35 )
                {
                  v45[v18 / 8] = v35;
                  v46[v19] = v24->numBindings;
                  if ( bIsAlternate && outFootsteps && v23 != -1 )
                  {
                    v36 = &overridesAlt->footstep[v23];
                    v37 = &outFootsteps[v23];
                    v38 = 4i64;
                    do
                    {
                      v37 = (FootstepAnim *)((char *)v37 + 128);
                      v39 = *(_OWORD *)&v36->leftCount;
                      v36 = (FootstepAnim *)((char *)v36 + 128);
                      *(_OWORD *)&v37[-1].movement[16].time = v39;
                      *(_OWORD *)&v37[-1].movement[18].time = *(_OWORD *)&v36[-1].movement[18].time;
                      *(_OWORD *)&v37[-1].movement[20].time = *(_OWORD *)&v36[-1].movement[20].time;
                      *(_OWORD *)&v37[-1].movement[22].time = *(_OWORD *)&v36[-1].movement[22].time;
                      *(_OWORD *)&v37[-1].movement[24].time = *(_OWORD *)&v36[-1].movement[24].time;
                      *(_OWORD *)&v37[-1].movement[26].time = *(_OWORD *)&v36[-1].movement[26].time;
                      *(_OWORD *)&v37[-1].movement[28].time = *(_OWORD *)&v36[-1].movement[28].time;
                      *(_OWORD *)&v37[-1].movement[30].time = *(_OWORD *)&v36[-1].movement[30].time;
                      --v38;
                    }
                    while ( v38 );
                    v37->leftCount = v36->leftCount;
                  }
                }
              }
            }
          }
          ++v21;
          --v22;
        }
        while ( v22 );
        v17 = startAnim;
        v15 = animOverrides;
      }
      v16 = numAnimOverrides;
      ++v17;
      ++v19;
      startAnim = v17;
      v18 += 8i64;
      --v43;
    }
    while ( v43 );
  }
}

/*
==============
BG_BuildWeaponAnimArrays_BaseAnimations
==============
*/
void BG_BuildWeaponAnimArrays_BaseAnimations(bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v13; 
  weapAnimFiles_t v14; 
  unsigned __int64 v15; 
  XAnimParts **v16; 
  XAnimParts **anims; 
  XAnimParts *v18; 
  char v19; 
  FootstepAnimType FootstepFromAnim; 
  __int64 v21; 
  __int64 v22; 
  FootstepAnim *v23; 
  __int128 *v24; 
  __int64 v25; 
  __int128 v26; 
  XAnimParts **v29; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18560, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18561, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18562, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18563, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18565, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( outFootsteps )
    memcpy_0(outFootsteps, rawAnimArrays->footsteps, 0x1A34ui64);
  if ( outBlendSpaces )
  {
    *(__m256i *)outBlendSpaces = *(__m256i *)rawAnimArrays->blendSpaces;
    *((__m256i *)outBlendSpaces + 1) = *(__m256i *)&rawAnimArrays->blendSpaces[4];
  }
  if ( outBlendSpacesAlt )
  {
    *(__m256i *)outBlendSpacesAlt = *(__m256i *)rawAnimArrays->blendSpacesAlt;
    *((__m256i *)outBlendSpacesAlt + 1) = *(__m256i *)&rawAnimArrays->blendSpacesAlt[4];
  }
  v13 = numAnims;
  if ( numAnims > 0 )
  {
    v14 = startAnim;
    v15 = 8i64 * (int)startAnim;
    v16 = &normalAnimArray[v15 / 0xFFFFFFFFFFFFFFF8ui64];
    v29 = v16;
    do
    {
      v16[v15 / 8] = rawAnimArrays->xAnims[v15 / 8];
      anims = pDef->szXAnims->anims;
      if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2550, ASSERT_TYPE_ASSERT, "(originalAnims)", (const char *)&queryFormat, "originalAnims") )
        __debugbreak();
      if ( rawAnimArrays == (const RawWeaponAnimArrays *const)-4976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2551, ASSERT_TYPE_ASSERT, "(modifiedAnims)", (const char *)&queryFormat, "modifiedAnims") )
        __debugbreak();
      if ( !rawAnimArrays->xAnimsAlt[v15 / 8] || anims[v15 / 8] )
      {
        v19 = 0;
        v18 = v29[v15 / 8];
      }
      else
      {
        v18 = rawAnimArrays->xAnimsAlt[v15 / 8];
        v19 = 1;
      }
      *(&altAnimArray[v15 / 8] - (int)startAnim) = v18;
      if ( outFootsteps )
      {
        if ( bIsAlternate )
        {
          FootstepFromAnim = BG_GetFootstepFromAnim(v14);
          if ( FootstepFromAnim != FOOTSTEP_ANIM_INVALID )
          {
            v21 = FootstepFromAnim;
            v22 = 26612i64;
            if ( !v19 )
              v22 = 19904i64;
            v23 = &outFootsteps[v21];
            v24 = (__int128 *)((char *)rawAnimArrays + v21 * 516 + v22);
            v25 = 4i64;
            do
            {
              v23 = (FootstepAnim *)((char *)v23 + 128);
              v26 = *v24;
              v24 += 8;
              *(_OWORD *)&v23[-1].movement[16].time = v26;
              *(_OWORD *)&v23[-1].movement[18].time = *(v24 - 7);
              *(_OWORD *)&v23[-1].movement[20].time = *(v24 - 6);
              *(_OWORD *)&v23[-1].movement[22].time = *(v24 - 5);
              *(_OWORD *)&v23[-1].movement[24].time = *(v24 - 4);
              *(_OWORD *)&v23[-1].movement[26].time = *(v24 - 3);
              *(_OWORD *)&v23[-1].movement[28].time = *(v24 - 2);
              *(_OWORD *)&v23[-1].movement[30].time = *(v24 - 1);
              --v25;
            }
            while ( v25 );
            v23->leftCount = *(_DWORD *)v24;
          }
        }
      }
      v16 = v29;
      ++v14;
      v15 += 8i64;
      --v13;
    }
    while ( v13 );
  }
}

/*
==============
BG_BuildWeaponAnimArrays_BlendSpaceOverrides
==============
*/
void BG_BuildWeaponAnimArrays_BlendSpaceOverrides(const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v14; 
  unsigned int v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  unsigned int v21; 
  __int64 v22; 
  const AnimOverride **v23; 
  const AnimOverride *v24; 
  unsigned int numBindings; 
  WeaponAnimPackage *overrides; 
  __int64 v27; 
  WeaponAnimPackage *overridesAlt; 
  __int64 v29; 
  __int64 v30; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18773, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18774, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18775, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v14 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18776, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18777, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18779, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = numAnimOverrides;
  v16 = 448i64;
  v17 = 0i64;
  v18 = 8i64;
  v30 = 0i64;
  v33 = 448i64;
  v31 = 8i64;
  v19 = 467i64;
  do
  {
    v20 = 0;
    v21 = 0;
    if ( !v15 )
      goto LABEL_55;
    v22 = v15;
    v23 = v14;
    v32 = v15;
    do
    {
      if ( !*v23 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18792, ASSERT_TYPE_ASSERT, "(animOverrides[overrideIndex] != nullptr)", (const char *)&queryFormat, "animOverrides[overrideIndex] != nullptr") )
          __debugbreak();
        v22 = v32;
      }
      v24 = *v23;
      numBindings = (*v23)->numBindings;
      if ( numBindings > v20 )
      {
        overrides = v24->overrides;
        if ( overrides && *(BlendSpace2DDef **)((char *)overrides->blendSpaces + v17) )
        {
          v27 = v16;
          if ( v16 <= v19 )
          {
            do
            {
              if ( (unsigned __int64)(v27 - 448) > 0x9F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18804, ASSERT_TYPE_ASSERT, "(( (WEAP_ANIM_BLEND_SPACE_FIRST <= index) && (index <= WEAP_ANIM_BLEND_SPACE_LAST) ))", (const char *)&queryFormat, "WEAPONANIM_ISBLENDSPACEANIM( index )") )
                __debugbreak();
              normalAnimArray[v27] = v24->overrides->anims[v27];
              ++v27;
            }
            while ( v27 <= v19 );
            v16 = v33;
          }
          if ( outBlendSpaces )
            *(const BlendSpace2DDef **)((char *)outBlendSpaces + v17) = *(BlendSpace2DDef **)((char *)v24->overrides->blendSpaces + v17);
          v20 = v24->numBindings;
          numBindings = v24->numBindings;
        }
      }
      else if ( numBindings <= v21 )
      {
        goto LABEL_53;
      }
      if ( numBindings > v21 )
      {
        overridesAlt = v24->overridesAlt;
        if ( overridesAlt )
        {
          if ( *(BlendSpace2DDef **)((char *)overridesAlt->blendSpaces + v17) )
          {
            v29 = v16;
            if ( v16 <= v19 )
            {
              do
              {
                if ( (unsigned __int64)(v29 - 448) > 0x9F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18825, ASSERT_TYPE_ASSERT, "(( (WEAP_ANIM_BLEND_SPACE_FIRST <= index) && (index <= WEAP_ANIM_BLEND_SPACE_LAST) ))", (const char *)&queryFormat, "WEAPONANIM_ISBLENDSPACEANIM( index )") )
                  __debugbreak();
                altAnimArray[v29] = v24->overridesAlt->anims[v29];
                ++v29;
              }
              while ( v29 <= v19 );
              v17 = v30;
              v16 = v33;
            }
            if ( outBlendSpacesAlt )
              *(const BlendSpace2DDef **)((char *)outBlendSpacesAlt + v17) = *(BlendSpace2DDef **)((char *)v24->overridesAlt->blendSpaces + v17);
            v21 = v24->numBindings;
          }
        }
      }
      v22 = v32;
LABEL_53:
      ++v23;
      v32 = --v22;
    }
    while ( v22 );
    v18 = v31;
    v15 = numAnimOverrides;
    v14 = animOverrides;
LABEL_55:
    v16 += 20i64;
    v17 += 8i64;
    v33 = v16;
    v19 += 20i64;
    v30 = v17;
    v31 = --v18;
  }
  while ( v18 );
}

/*
==============
BG_BuildWeaponAnimArrays_CarryOverrides
==============
*/
void BG_BuildWeaponAnimArrays_CarryOverrides(const playerState_s *ps, const WeaponDef *pDef, XAnimParts **normalAnimArray, XAnimParts **altAnimArray, weapAnimFiles_t startAnim, int numAnims)
{
  const CarryObjectDef *PlayerCarryObjectDef; 
  CarryAnimOverride *carryAnimOverrides; 
  __int64 v12; 
  WeaponAnimPackage *animPackage; 
  WeaponAnimPackage *animPackageAlt; 
  __int64 v15; 
  unsigned __int64 v16; 
  unsigned __int64 v17; 
  unsigned __int64 v18; 
  XAnimParts **v19; 
  XAnimParts **v20; 
  XAnimParts **anims; 
  XAnimParts **v22; 
  XAnimParts *v23; 

  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18328, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18329, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18330, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18332, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( ps && BG_CarryObject_IsActive(ps) )
  {
    PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(ps);
    if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18347, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
      __debugbreak();
    carryAnimOverrides = pDef->carryAnimOverrides;
    v12 = 0i64;
    while ( carryAnimOverrides->carryObjectType != PlayerCarryObjectDef->type )
    {
      ++v12;
      ++carryAnimOverrides;
      if ( v12 >= 5 )
        return;
    }
    animPackage = carryAnimOverrides->animPackage;
    animPackageAlt = carryAnimOverrides->animPackageAlt;
    if ( animPackage || animPackageAlt )
    {
      v15 = numAnims;
      if ( numAnims > 0 )
      {
        v16 = 8i64 * (int)startAnim;
        v17 = (int)startAnim - 262i64;
        v18 = v16 - (_QWORD)normalAnimArray;
        v19 = &normalAnimArray[v16 / 0xFFFFFFFFFFFFFFF8ui64];
        v20 = &altAnimArray[v16 / 0xFFFFFFFFFFFFFFF8ui64];
        while ( 1 )
        {
          if ( animPackage )
          {
            anims = carryAnimOverrides->animPackage->anims;
            if ( v17 > 0x17 )
            {
              if ( anims[v16 / 8] )
                v19[v16 / 8] = *(XAnimParts **)((char *)anims + (_QWORD)&v19[v16 / 8] + v18);
            }
            else
            {
              v19[v16 / 8] = anims[v16 / 8];
            }
          }
          if ( !animPackageAlt )
            goto LABEL_37;
          v22 = carryAnimOverrides->animPackageAlt->anims;
          if ( v17 <= 0x17 )
            break;
          if ( v22[v16 / 8] )
          {
            v23 = *(XAnimParts **)((char *)v22 + (_QWORD)v19 + v18 + v16);
            goto LABEL_36;
          }
LABEL_37:
          ++v17;
          v16 += 8i64;
          if ( !--v15 )
            return;
        }
        v23 = v22[v16 / 8];
LABEL_36:
        v20[v16 / 8] = v23;
        goto LABEL_37;
      }
    }
  }
}

/*
==============
BG_BuildWeaponAnimArrays_DualWield
==============
*/
bool BG_BuildWeaponAnimArrays_DualWield(const playerState_s *ps, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v14; 
  XAnimParts **v15; 
  char *v16; 
  XAnimParts *v17; 
  XAnimParts *v18; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18408, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18409, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18410, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18412, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v14 = numAnims;
  if ( numAnims > 0 )
  {
    v15 = normalAnimArray;
    v16 = (char *)rawAnimArrays + 8i64 * (int)startAnim + 14928 - (_QWORD)normalAnimArray;
    do
    {
      v17 = *(XAnimParts **)((char *)v15++ + (_QWORD)v16 - 4976);
      v18 = NULL;
      if ( v17 )
        v18 = v17;
      *(v15 - 1) = v18;
      *(XAnimParts **)((char *)v15 + (char *)altAnimArray - (char *)normalAnimArray - 8) = *(XAnimParts **)((char *)v15 + (_QWORD)v16 - 8);
      --v14;
    }
    while ( v14 );
  }
  if ( outFootsteps )
    memcpy_0(outFootsteps, rawAnimArrays->footstepsLeftHanded, 0x1A34ui64);
  if ( outBlendSpaces )
  {
    *(__m256i *)outBlendSpaces = *(__m256i *)rawAnimArrays->blendSpacesRightHanded;
    *((__m256i *)outBlendSpaces + 1) = *(__m256i *)&rawAnimArrays->blendSpacesRightHanded[4];
  }
  if ( outBlendSpacesAlt )
  {
    *(__m256i *)outBlendSpacesAlt = *(__m256i *)rawAnimArrays->blendSpacesLeftHanded;
    *((__m256i *)outBlendSpacesAlt + 1) = *(__m256i *)&rawAnimArrays->blendSpacesLeftHanded[4];
  }
  BG_BuildWeaponAnimArrays_CarryOverrides(ps, pDef, normalAnimArray, altAnimArray, startAnim, numAnims);
  return 0;
}

/*
==============
BG_BuildWeaponAnimArrays_MeleeComboWeapon
==============
*/
void BG_BuildWeaponAnimArrays_MeleeComboWeapon(const playerState_s *ps, const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  int meleeComboSeqIdx; 
  signed int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v17; 
  __int64 v18; 
  AnimOverride *v19; 
  WeaponAnimPackage *overrides; 
  WeaponAnimPackage *overridesAlt; 
  weapAnimFiles_t v22; 
  unsigned __int64 v23; 
  XAnimParts **v24; 
  XAnimParts **v25; 
  __int64 v26; 
  XAnimParts *v27; 
  bool v28; 
  XAnimParts *v29; 
  __int64 v30; 
  __int64 v31; 
  FootstepAnim *v32; 
  FootstepAnim *v33; 
  __int128 v34; 
  XAnimParts *v35; 
  __int64 v36; 
  __int64 v37; 
  FootstepAnim *v38; 
  FootstepAnim *v39; 
  __int128 v40; 
  __int64 v41; 
  __int64 v42; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18496, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18497, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18498, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18499, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18501, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  meleeComboSeqIdx = 0;
  if ( ps )
    meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
  AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
  v17 = AnimOverrideIdxForMeleeComboSeq;
  if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
  {
    if ( AnimOverrideIdxForMeleeComboSeq >= pDef->numAnimOverrides )
    {
      LODWORD(v41) = AnimOverrideIdxForMeleeComboSeq;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18513, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( pDef->numAnimOverrides )", "animOverrideIdx doesn't index pDef->numAnimOverrides\n\t%i not in [0, %i)", v41, pDef->numAnimOverrides) )
        __debugbreak();
    }
    v18 = numAnims;
    v19 = &pDef->animOverrides[v17];
    overrides = v19->overrides;
    overridesAlt = v19->overridesAlt;
    if ( numAnims > 0 )
    {
      v22 = startAnim;
      v23 = 8i64 * (int)startAnim;
      v24 = &normalAnimArray[v23 / 0xFFFFFFFFFFFFFFF8ui64];
      v25 = &altAnimArray[v23 / 0xFFFFFFFFFFFFFFF8ui64];
      while ( 1 )
      {
        if ( (unsigned int)v22 >= NUM_WEAP_ANIMS )
        {
          LODWORD(v42) = 614;
          LODWORD(v41) = v22;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v41, v42) )
            __debugbreak();
        }
        v26 = 0i64;
        while ( FootstepToAnimMap[v26] != v22 )
        {
          if ( (unsigned __int64)++v26 >= 9 )
          {
            LODWORD(v26) = -1;
            break;
          }
        }
        if ( (unsigned int)(v22 - 262) > 0x17 )
          break;
        if ( overrides )
          v27 = overrides->anims[v23 / 8];
        else
          v27 = NULL;
        v24[v23 / 8] = v27;
        if ( overridesAlt )
          v25[v23 / 8] = overridesAlt->anims[v23 / 8];
        else
          v25[v23 / 8] = NULL;
LABEL_55:
        ++v22;
        v23 += 8i64;
        if ( !--v18 )
          return;
      }
      if ( overrides )
      {
        v28 = bIsAlternate;
        v29 = overrides->anims[v23 / 8];
        if ( !v29 || (v24[v23 / 8] = v29, bIsAlternate) || !outFootsteps || (_DWORD)v26 == -1 )
        {
LABEL_47:
          if ( overridesAlt )
          {
            v35 = overridesAlt->anims[v23 / 8];
            if ( v35 )
            {
              v25[v23 / 8] = v35;
              if ( v28 && outFootsteps && (_DWORD)v26 != -1 )
              {
                v36 = (int)v26;
                v37 = 4i64;
                v38 = &overridesAlt->footstep[v36];
                v39 = &outFootsteps[v36];
                do
                {
                  *(_OWORD *)&v39->leftCount = *(_OWORD *)&v38->leftCount;
                  *(_OWORD *)&v39->step[1].isLeft = *(_OWORD *)&v38->step[1].isLeft;
                  *(_OWORD *)&v39->step[3].isLeft = *(_OWORD *)&v38->step[3].isLeft;
                  *(_OWORD *)&v39->step[5].isLeft = *(_OWORD *)&v38->step[5].isLeft;
                  *(_OWORD *)&v39->step[7].isLeft = *(_OWORD *)&v38->step[7].isLeft;
                  *(_OWORD *)&v39->step[9].isLeft = *(_OWORD *)&v38->step[9].isLeft;
                  *(_OWORD *)&v39->step[11].isLeft = *(_OWORD *)&v38->step[11].isLeft;
                  v40 = *(_OWORD *)&v38->step[13].isLeft;
                  v38 = (FootstepAnim *)((char *)v38 + 128);
                  v39 = (FootstepAnim *)((char *)v39 + 128);
                  *(_OWORD *)&v39[-1].movement[30].time = v40;
                  --v37;
                }
                while ( v37 );
                v39->leftCount = v38->leftCount;
              }
            }
          }
          goto LABEL_55;
        }
        v30 = (int)v26;
        v31 = 4i64;
        v32 = &overrides->footstep[v30];
        v33 = &outFootsteps[v30];
        do
        {
          *(_OWORD *)&v33->leftCount = *(_OWORD *)&v32->leftCount;
          *(_OWORD *)&v33->step[1].isLeft = *(_OWORD *)&v32->step[1].isLeft;
          *(_OWORD *)&v33->step[3].isLeft = *(_OWORD *)&v32->step[3].isLeft;
          *(_OWORD *)&v33->step[5].isLeft = *(_OWORD *)&v32->step[5].isLeft;
          *(_OWORD *)&v33->step[7].isLeft = *(_OWORD *)&v32->step[7].isLeft;
          *(_OWORD *)&v33->step[9].isLeft = *(_OWORD *)&v32->step[9].isLeft;
          *(_OWORD *)&v33->step[11].isLeft = *(_OWORD *)&v32->step[11].isLeft;
          v34 = *(_OWORD *)&v32->step[13].isLeft;
          v33 = (FootstepAnim *)((char *)v33 + 128);
          v32 = (FootstepAnim *)((char *)v32 + 128);
          *(_OWORD *)&v33[-1].movement[30].time = v34;
          --v31;
        }
        while ( v31 );
        v33->leftCount = v32->leftCount;
      }
      v28 = bIsAlternate;
      goto LABEL_47;
    }
  }
}

/*
==============
BG_BuildWeaponAnimArrays_MeleeOverrides
==============
*/
void BG_BuildWeaponAnimArrays_MeleeOverrides(const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v14; 
  unsigned int v15; 
  unsigned int v16; 
  __int64 v17; 
  const AnimOverride *v18; 
  unsigned int numBindings; 
  __int64 v20; 
  XAnimParts **v21; 
  __int64 v22; 
  XAnimParts **v23; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18711, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18712, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18713, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v14 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18714, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18715, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18717, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = 0;
  v16 = 0;
  if ( numAnimOverrides )
  {
    v17 = numAnimOverrides;
    while ( 1 )
    {
      v18 = *v14;
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18724, ASSERT_TYPE_ASSERT, "(animOverride != nullptr)", (const char *)&queryFormat, "animOverride != nullptr") )
        __debugbreak();
      numBindings = v18->numBindings;
      if ( v18->numBindings > v15 )
        break;
      if ( numBindings > v16 )
        goto LABEL_33;
LABEL_40:
      ++v14;
      if ( !--v17 )
        return;
    }
    if ( v18->overrides )
    {
      v20 = 0i64;
      if ( numAnims > 0i64 )
      {
        v21 = normalAnimArray;
        do
        {
          if ( (unsigned __int64)((int)startAnim + v20 - 262) <= 0x17 )
          {
            *v21 = *(XAnimParts **)((char *)v18->overrides->anims + 8i64 * (int)startAnim - (_QWORD)normalAnimArray + (unsigned __int64)v21);
            v15 = v18->numBindings;
            numBindings = v18->numBindings;
          }
          ++v20;
          ++v21;
        }
        while ( v20 < numAnims );
      }
    }
LABEL_33:
    if ( numBindings > v16 )
    {
      if ( v18->overridesAlt )
      {
        v22 = 0i64;
        if ( numAnims > 0i64 )
        {
          v23 = altAnimArray;
          do
          {
            if ( (unsigned __int64)((int)startAnim + v22 - 262) <= 0x17 )
            {
              *v23 = *(XAnimParts **)((char *)v18->overridesAlt->anims + 8i64 * (int)startAnim - (_QWORD)altAnimArray + (unsigned __int64)v23);
              v16 = v18->numBindings;
            }
            ++v22;
            ++v23;
          }
          while ( v22 < numAnims );
        }
      }
    }
    goto LABEL_40;
  }
}

/*
==============
BG_BuildWeaponAnimArrays_NoAttachments
==============
*/
bool BG_BuildWeaponAnimArrays_NoAttachments(const playerState_s *ps, const WeaponDef *pDef, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v15; 
  XAnimParts **v16; 
  char *v17; 
  XAnimParts *v18; 
  XAnimParts *v19; 
  __int64 v20; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18452, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18453, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18454, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18456, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = numAnims;
  if ( numAnims > 0 )
  {
    v16 = normalAnimArray;
    v17 = (char *)rawAnimArrays + 8i64 * (int)startAnim - (_QWORD)normalAnimArray;
    do
    {
      v18 = *(XAnimParts **)((char *)v16++ + (_QWORD)v17);
      v19 = NULL;
      if ( v18 )
        v19 = v18;
      *(v16 - 1) = v19;
      *(XAnimParts **)((char *)v16 + (char *)altAnimArray - (char *)normalAnimArray - 8) = *(XAnimParts **)((char *)v16 + (_QWORD)v17 + 4968);
      --v15;
    }
    while ( v15 );
  }
  if ( outFootsteps )
  {
    v20 = 26612i64;
    if ( !bIsAlternate )
      v20 = 19904i64;
    memcpy_0(outFootsteps, (char *)rawAnimArrays + v20, 0x1A34ui64);
  }
  if ( outBlendSpaces )
  {
    *(__m256i *)outBlendSpaces = *(__m256i *)rawAnimArrays->blendSpaces;
    *((__m256i *)outBlendSpaces + 1) = *(__m256i *)&rawAnimArrays->blendSpaces[4];
  }
  if ( outBlendSpacesAlt )
  {
    *(__m256i *)outBlendSpacesAlt = *(__m256i *)rawAnimArrays->blendSpacesAlt;
    *((__m256i *)outBlendSpacesAlt + 1) = *(__m256i *)&rawAnimArrays->blendSpacesAlt[4];
  }
  BG_BuildWeaponAnimArrays_CarryOverrides(ps, pDef, normalAnimArray, altAnimArray, startAnim, numAnims);
  return 0;
}

/*
==============
BG_BurstFireIsAuto
==============
*/
bool BG_BurstFireIsAuto(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  WeaponAttachment *v7; 
  AttBurst *burst; 
  const WeaponDef *v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( BG_GetWeaponFireType(r_weapon, isAlternate) != WEAPON_FIRETYPE_BURST || !r_weapon->weaponIdx )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      v7 = *v6;
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7050, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      burst = v7->burst;
      if ( burst )
        return burst->burstFireAuto;
      ++v4;
      ++v6;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7059, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v9->burstFireAuto;
  }
}

/*
==============
BG_CalculateEaseMotionFactor
==============
*/
float BG_CalculateEaseMotionFactor(const float weaponPosFrac, AdsOffsetInterpolationType lerpType)
{
  float v3; 
  float result; 
  int v6; 

  v3 = weaponPosFrac;
  if ( (unsigned int)lerpType >= ADS_OFFSET_INTERP_TYPE_COUNT )
  {
    v6 = 9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22417, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>(lerpType) ) < (unsigned)( ADS_OFFSET_INTERP_TYPE_COUNT )", "static_cast<int>(lerpType) doesn't index ADS_OFFSET_INTERP_TYPE_COUNT\n\t%i not in [0, %i)", lerpType, v6) )
      __debugbreak();
  }
  switch ( lerpType )
  {
    case ADS_OFFSET_INTERP_TYPE_EASEINOUTSINE:
      result = (float)(sinf_0((float)(weaponPosFrac - 0.5) * 3.1415927) + 1.0) * 0.5;
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINOUTSMOOTHERSTEP:
      result = (float)((float)((float)((float)(weaponPosFrac * 6.0) - 15.0) * weaponPosFrac) + 10.0) * (float)((float)(weaponPosFrac * weaponPosFrac) * weaponPosFrac);
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINCUBIC:
      result = (float)(weaponPosFrac * weaponPosFrac) * weaponPosFrac;
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTCUBIC:
      result = (float)((float)((float)(weaponPosFrac - 1.0) * (float)(weaponPosFrac - 1.0)) * (float)(weaponPosFrac - 1.0)) + 1.0;
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINQUARTIC:
      result = (float)((float)(weaponPosFrac * weaponPosFrac) * weaponPosFrac) * weaponPosFrac;
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTQUARTIC:
      result = 1.0 - (float)((float)((float)((float)(weaponPosFrac - 1.0) * (float)(weaponPosFrac - 1.0)) * (float)(weaponPosFrac - 1.0)) * (float)(weaponPosFrac - 1.0));
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINEXPO:
      result = powf_0(2.0, (float)(weaponPosFrac - 1.0) * 10.0);
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTEXPO:
      v3 = 1.0 - powf_0(2.0, weaponPosFrac * -10.0);
      goto LABEL_13;
    default:
LABEL_13:
      result = v3;
      break;
  }
  return result;
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/
float BG_CalculateFinalSpreadForWeapon(float weaponPosFrac, float minSpread, float maxSpread, float adsSpread, float aimSpreadScale)
{
  float v5; 

  v5 = (float)((float)(maxSpread - minSpread) * aimSpreadScale) + minSpread;
  if ( weaponPosFrac != 0.0 )
    return (float)((float)(1.0 - weaponPosFrac) * (float)((float)((float)(maxSpread - minSpread) * aimSpreadScale) + minSpread)) + (float)(weaponPosFrac * adsSpread);
  return v5;
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/
float BG_CalculateFinalSpreadForWeapon(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, float aimSpreadScale)
{
  bool v8; 
  const BgWeaponMap *v9; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  bool v12; 
  const WeaponDef *v13; 
  bool doNotAllowAttachmentsToOverrideSpread; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v19; 
  __int64 v20; 
  const WeaponAttachment *v21; 
  float adsSpreadScale; 
  __int128 v23; 
  __int128 v25; 
  float v29; 
  const WeaponDef *v30; 
  double v36; 
  float v39; 
  float minSpread; 
  float maxSpread; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4686, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4687, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _XMM6 = 0i64;
  maxSpread = 0.0;
  minSpread = 0.0;
  BG_GetSpreadForWeapon(ps, r_weapon, &minSpread, &maxSpread);
  v8 = BG_UsingAlternate(ps);
  v9 = handler->GetWeaponMap(handler);
  v11 = ps && v9 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v9, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  v12 = BG_PlayerUsesNVGHalfADS(ps, handler);
  v13 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v12 )
    _XMM9 = LODWORD(v13->fAdsSpreadNVG);
  else
    _XMM9 = LODWORD(v13->fAdsSpread);
  doNotAllowAttachmentsToOverrideSpread = v13->doNotAllowAttachmentsToOverrideSpread;
  if ( BG_GetWeaponAdsSettings(r_weapon, v8, v11, doNotAllowAttachmentsToOverrideSpread) )
  {
    __asm
    {
      vcmpless xmm0, xmm6, xmm1
      vblendvps xmm9, xmm9, xmm1, xmm0
    }
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v8, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)3, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v19 = (const WeaponAttachment **)attachments;
    v20 = WeaponAttachments_Internal;
    while ( 1 )
    {
      v21 = *v19;
      if ( !*v19 || doNotAllowAttachmentsToOverrideSpread && v21->type == ATTACHMENT_SCOPE )
        goto LABEL_28;
      if ( BG_AttachmentUseMainSettings(*v19, v8, v11) )
        break;
      adsSpreadScale = v21->adsSpreadScale;
      if ( adsSpreadScale <= 0.0 )
        goto LABEL_26;
LABEL_27:
      v23 = _XMM8;
      *(float *)&v23 = (float)(*(float *)&_XMM8 + adsSpreadScale) - 1.0;
      _XMM8 = v23;
LABEL_28:
      ++v19;
      if ( !--v20 )
        goto LABEL_29;
    }
    adsSpreadScale = v21->adsSpreadScaleMain;
    if ( adsSpreadScale > 0.0 )
      goto LABEL_27;
LABEL_26:
    adsSpreadScale = FLOAT_1_0;
    goto LABEL_27;
  }
LABEL_29:
  __asm { vmaxss  xmm2, xmm8, xmm6 }
  v25 = LODWORD(FLOAT_1_0);
  *(float *)&v25 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v25 + 1) = (v25 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v25 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v25;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm7, xmm0
  }
  v29 = *(float *)&_XMM1 * *(float *)&_XMM9;
  v30 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _XMM8 = LODWORD(v30->adsSpreadStartFrac);
  _XMM9 = LODWORD(v30->adsSpreadEndFrac);
  if ( BG_GetWeaponAdsSettings(r_weapon, v8, v11, v30->doNotAllowAttachmentsToOverrideSpread) )
  {
    __asm
    {
      vcmpless xmm0, xmm6, xmm1
      vblendvps xmm8, xmm8, xmm1, xmm0
      vcmpless xmm0, xmm6, xmm2
      vblendvps xmm9, xmm9, xmm2, xmm0
    }
  }
  __asm { vmaxss  xmm0, xmm9, xmm8 }
  if ( (float)(*(float *)&_XMM0 - *(float *)&_XMM8) <= 0.000001 )
  {
    __asm
    {
      vcmpltss xmm0, xmm6, xmm3
      vblendvps xmm4, xmm6, xmm7, xmm0
    }
  }
  else
  {
    v36 = I_fclamp((float)(ps->weapCommon.fWeaponPosFrac - *(float *)&_XMM8) / (float)(*(float *)&_XMM0 - *(float *)&_XMM8), 0.0, 1.0);
    LODWORD(_XMM4) = LODWORD(v36);
  }
  v39 = (float)((float)(maxSpread - minSpread) * aimSpreadScale) + minSpread;
  if ( *(float *)&_XMM4 != 0.0 )
    return (float)((float)(1.0 - *(float *)&_XMM4) * (float)((float)((float)(maxSpread - minSpread) * aimSpreadScale) + minSpread)) + (float)(*(float *)&_XMM4 * v29);
  return v39;
}

/*
==============
BG_CalculateKickBox
==============
*/
void BG_CalculateKickBox(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel, float *outMinMagnitude)
{
  float fWeaponPosFrac; 
  unsigned int *v11; 
  double v12; 
  float v13; 
  double v14; 
  float v15; 
  int v16; 
  double v17; 
  float v18; 
  float v19; 
  int v20; 
  float hipGunKickPitchMin; 
  float hipGunKickPitchMax; 
  float hipGunKickYawMin; 
  float v24; 
  int v25[9]; 
  float v26; 
  float v27; 

  if ( isViewKick )
    BG_GetViewKickYawAndPitch(weaponMap, ps, r_weapon, isAlternate, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, &v24, (float *)v25, &v26, &v27, &v18, &v19, (float *)&v20);
  else
    BG_GetGunKickYawAndPitch(weaponMap, ps, r_weapon, isAlternate, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, &v24, (float *)v25, &v26, &v27, &v18, &v19, (float *)&v20);
  fWeaponPosFrac = ps->weapCommon.fWeaponPosFrac;
  v11 = holdrand;
  v12 = BG_random(holdrand);
  v13 = 1.0 - *(float *)&v12;
  if ( fWeaponPosFrac <= 0.0 )
  {
    *outPitchAVel = (float)(v13 * hipGunKickPitchMin) + (float)(*(float *)&v12 * hipGunKickPitchMax);
    v17 = BG_random(v11);
    v15 = (float)((float)(1.0 - *(float *)&v17) * hipGunKickYawMin) + (float)(*(float *)&v17 * v24);
    v16 = v25[0];
  }
  else
  {
    *outPitchAVel = (float)(v13 * v26) + (float)(*(float *)&v12 * v27);
    v14 = BG_random(v11);
    v15 = (float)((float)(1.0 - *(float *)&v14) * v18) + (float)(*(float *)&v14 * v19);
    v16 = v20;
  }
  *outYawAVel = v15;
  *outMinMagnitude = *(float *)&v16;
}

/*
==============
BG_CalculateKickMovement
==============
*/
bool BG_CalculateKickMovement(float fTimeStep, const vec2_t *maxAngles, float kickPitchScale, float kickYawScale, float recenterAngAcceleration, float fReturnAccelScale, float fReturnSpeedCurveScale, vec2_t *inOutAngles, vec2_t *inOutAngularVel, bool *inOutKickNeedsToCrossCenter)
{
  unsigned int v10; 
  vec2_t *v12; 
  bool v13; 
  float v15; 
  __int128 v16; 
  __int128 v17; 
  float v19; 
  float v20; 
  float v21; 
  float v24; 
  float v25; 
  __int128 v26; 
  __int128 v27; 
  float v31; 
  float v32; 
  const dvar_t *v33; 
  float v34; 
  float v35; 
  float v36; 
  __int128 v37; 
  float v42; 
  bool v43; 
  bool v44; 
  double v45; 
  float v46; 
  float v47; 
  __int128 v48; 
  __int128 v49; 
  float v50; 
  const dvar_t *v51; 
  float v52; 
  float v53; 
  float v54; 
  __int128 v56; 
  float v59; 
  float v60; 
  unsigned int v61; 
  float v62; 
  signed __int64 v63; 
  signed __int64 v64; 
  vec2_t *v65; 
  bool v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  bool result; 
  __int64 v73; 
  __int64 v74; 
  __int64 v75; 
  __int64 v76; 
  __int64 v77; 
  __int64 v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 

  v10 = 0;
  v12 = inOutAngles;
  v13 = 1;
  do
  {
    if ( !v13 )
    {
      LODWORD(v76) = 2;
      LODWORD(v73) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
        __debugbreak();
    }
    if ( v12->v[0] < -180.0 )
      goto LABEL_105;
    if ( v10 >= 2 )
    {
      LODWORD(v76) = 2;
      LODWORD(v73) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
        __debugbreak();
    }
    if ( v12->v[0] > 180.0 )
    {
LABEL_105:
      if ( v10 >= 2 )
      {
        LODWORD(v76) = 2;
        LODWORD(v73) = v10;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4077, ASSERT_TYPE_ASSERT, "( (-180.0f + 1.192092896e-07F) ) <= ( inOutAngles[i] ) && ( inOutAngles[i] ) <= ( 180.0f )", "inOutAngles[i] not in [(-180.0f + FLT_EPSILON), 180.0f]\n\t%g not in [%g, %g]", v12->v[0], DOUBLE_N180_0, DOUBLE_180_0) )
        __debugbreak();
    }
    ++v10;
    v12 = (vec2_t *)((char *)v12 + 4);
    v13 = v10 < 2;
  }
  while ( (int)v10 < 2 );
  v15 = inOutAngles->v[1];
  v16 = LODWORD(inOutAngles->v[0]);
  v17 = v16;
  *(float *)&v17 = fsqrt((float)(*(float *)&v16 * *(float *)&v16) + (float)(v15 * v15));
  _XMM5 = v17;
  v13 = *(float *)&v17 < STOP_THRESHOLD_OFFSET;
  v20 = fsqrt((float)(inOutAngularVel->v[0] * inOutAngularVel->v[0]) + (float)(inOutAngularVel->v[1] * inOutAngularVel->v[1]));
  v19 = v20;
  v82 = *(float *)&_XMM5;
  if ( v13 && v20 < STOP_THRESHOLD_SPEED )
    goto LABEL_102;
  v21 = FLOAT_1_0;
  if ( *(float *)&_XMM5 <= 0.000001 )
  {
    v79 = 0.0;
    v80 = FLOAT_1_0;
    v24 = FLOAT_1_0;
  }
  else
  {
    __asm
    {
      vcmpless xmm0, xmm5, xmm14
      vblendvps xmm0, xmm5, xmm6, xmm0
    }
    LODWORD(v24) = COERCE_UNSIGNED_INT(*(float *)&v16 * (float)(1.0 / *(float *)&_XMM0)) ^ _xmm;
    LODWORD(v79) = COERCE_UNSIGNED_INT(v15 * (float)(1.0 / *(float *)&_XMM0)) ^ _xmm;
    v80 = v24;
  }
  if ( v20 <= 0.000001 )
  {
    v31 = FLOAT_1_0;
    v32 = 0.0;
  }
  else
  {
    v25 = inOutAngularVel->v[1];
    v26 = LODWORD(inOutAngularVel->v[0]);
    v27 = v26;
    *(float *)&v27 = fsqrt((float)(*(float *)&v26 * *(float *)&v26) + (float)(v25 * v25));
    _XMM2 = v27;
    __asm
    {
      vcmpless xmm0, xmm2, xmm14
      vblendvps xmm0, xmm2, xmm6, xmm0
    }
    v31 = *(float *)&v26 * (float)(1.0 / *(float *)&_XMM0);
    v32 = v25 * (float)(1.0 / *(float *)&_XMM0);
  }
  v33 = DCONST_DVARFLT_bg_kickIntegrationFudgeFactor;
  if ( !DCONST_DVARFLT_bg_kickIntegrationFudgeFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_kickIntegrationFudgeFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v33);
  v34 = (float)(fTimeStep * recenterAngAcceleration) * v33->current.value;
  LODWORD(v35) = LODWORD(v24) ^ _xmm;
  v36 = (float)(v79 * v79) + (float)(v35 * v35);
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(v36 - 1.0) & _xmm) >= 0.0020000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4140, ASSERT_TYPE_ASSERT, "( Vec2IsNormalized( rightAngDirection ) )", "(%g, %g) len %g", v79, v35, fsqrt(v36)) )
    __debugbreak();
  v37 = LODWORD(FLOAT_1000_0);
  _XMM0 = LODWORD(v82);
  __asm { vcmpless xmm0, xmm0, cs:STOP_SIDE_MOVEMENT_OFFSET }
  *(float *)&v37 = (float)((float)(1000.0 / _mm_cvtepi32_ps((__m128i)(unsigned int)KICK_ANGLES_TIME_STEP).m128_f32[0]) * fTimeStep) * COUNTER_SIDE_MOVEMENT_SPEED_MULT;
  _XMM3 = v37;
  __asm { vblendvps xmm4, xmm3, xmm6, xmm0 }
  *(double *)&_XMM0 = I_fclamp((float)((float)((float)(v31 * v79) + (float)(v32 * v35)) * v19) * *(float *)&_XMM4, COERCE_FLOAT(LODWORD(v34) ^ _xmm), v34);
  v81 = (float)(*(float *)&_XMM0 * -1.0) * v35;
  v42 = (float)(*(float *)&_XMM0 * -1.0) * v79;
  v43 = v82 > 0.0 && v19 > 0.0;
  v44 = (float)((float)(v31 * v80) + (float)(v32 * v79)) > 0.0;
  if ( v43 && (float)((float)(v31 * v80) + (float)(v32 * v79)) > 0.0 )
  {
    if ( (float)(RECENTER_CURVE_FAR_DIST * fReturnSpeedCurveScale) > 0.0 )
      v45 = I_fclamp((float)((float)(RECENTER_CURVE_FAR_DIST * fReturnSpeedCurveScale) - v82) / (float)(RECENTER_CURVE_FAR_DIST * fReturnSpeedCurveScale), 0.0, 1.0);
    else
      LODWORD(v45) = 0;
    v46 = v80;
    v47 = (float)((float)((float)((float)(1.0 - (float)(*(float *)&v45 * *(float *)&v45)) * EDGE_MULT) + (float)((float)(*(float *)&v45 * *(float *)&v45) * CENTER_MULT)) * v34) - (float)((float)(v80 * inOutAngularVel->v[0]) + (float)(v79 * inOutAngularVel->v[1]));
    I_fclamp(v47, COERCE_FLOAT(LODWORD(v34) ^ _xmm), v34);
    v34 = v47;
  }
  else
  {
    v46 = v80;
  }
  v49 = LODWORD(v79);
  *(float *)&v49 = v79 * v34;
  v48 = v49;
  v50 = v46 * v34;
  if ( v44 )
  {
    v52 = v81;
  }
  else
  {
    v51 = DVARBOOL_bg_kickScalesReturn;
    if ( !DVARBOOL_bg_kickScalesReturn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_kickScalesReturn") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v51);
    v52 = v81;
    if ( v51->current.enabled )
    {
      v50 = (float)(v46 * v34) * kickPitchScale;
      *(float *)&v49 = *(float *)&v49 * kickYawScale;
      v48 = v49;
      v42 = v42 * kickPitchScale;
      v52 = v81 * kickYawScale;
      v34 = fsqrt((float)(v50 * v50) + (float)(*(float *)&v48 * *(float *)&v48));
    }
  }
  v53 = v50 + inOutAngularVel->v[0];
  v56 = v48;
  v54 = *(float *)&v48 + inOutAngularVel->v[1];
  *(float *)&v56 = fsqrt((float)(v54 * v54) + (float)(v53 * v53));
  _XMM2 = v56;
  if ( *(float *)&v56 <= 0.000001 )
  {
    v59 = 0.0;
  }
  else
  {
    __asm
    {
      vcmpless xmm0, xmm2, xmm14
      vblendvps xmm0, xmm2, xmm6, xmm0
    }
    v21 = (float)(1.0 / *(float *)&_XMM0) * v53;
    v59 = v54 * (float)(1.0 / *(float *)&_XMM0);
  }
  if ( v82 > 0.0 && *(float *)&v56 > 0.0 && (float)((float)(v79 * v59) + (float)(v21 * v46)) > 0.0 && (float)((float)((float)(v46 * v53) + (float)(v54 * v79)) * v34) > 0.0 )
  {
    v50 = v46 * (float)(v34 * fReturnAccelScale);
    *(float *)&v48 = v79 * (float)(v34 * fReturnAccelScale);
  }
  v60 = v52 + inOutAngularVel->v[1];
  v61 = 0;
  v62 = (float)(v42 + inOutAngularVel->v[0]) + v50;
  inOutAngularVel->v[0] = v62;
  inOutAngularVel->v[1] = v60 + *(float *)&v48;
  inOutAngles->v[0] = (float)(v62 * fTimeStep) + inOutAngles->v[0];
  v63 = (char *)maxAngles - (char *)inOutAngles;
  v64 = (char *)inOutAngularVel - (char *)inOutAngles;
  inOutAngles->v[1] = (float)(fTimeStep * inOutAngularVel->v[1]) + inOutAngles->v[1];
  v65 = inOutAngles;
  v66 = 1;
  do
  {
    if ( !v66 )
    {
      LODWORD(v76) = 2;
      LODWORD(v73) = v61;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
        __debugbreak();
      LODWORD(v77) = 2;
      LODWORD(v74) = v61;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v74, v77) )
        __debugbreak();
    }
    if ( *(float *)((char *)v65->v + v63) >= v65->v[0] )
    {
      if ( v61 >= 2 )
      {
        LODWORD(v76) = 2;
        LODWORD(v73) = v61;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
          __debugbreak();
        LODWORD(v78) = 2;
        LODWORD(v75) = v61;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v75, v78) )
          __debugbreak();
      }
      if ( COERCE_FLOAT(*(_DWORD *)((char *)v65->v + v63) ^ _xmm) > v65->v[0] )
      {
        if ( v61 >= 2 )
        {
          LODWORD(v76) = 2;
          LODWORD(v73) = v61;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
            __debugbreak();
        }
        LODWORD(v68) = *(_DWORD *)((char *)v65->v + v63) ^ _xmm;
        if ( v61 >= 2 )
        {
          LODWORD(v76) = 2;
          LODWORD(v73) = v61;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
            __debugbreak();
        }
        v65->v[0] = v68;
        if ( v61 >= 2 )
        {
          LODWORD(v76) = 2;
          LODWORD(v73) = v61;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
            __debugbreak();
        }
        if ( *(float *)((char *)v65->v + v64) < 0.0 )
        {
LABEL_90:
          if ( v61 >= 2 )
          {
            LODWORD(v76) = 2;
            LODWORD(v73) = v61;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
              __debugbreak();
          }
          *(float *)((char *)v65->v + v64) = 0.0;
        }
      }
    }
    else
    {
      if ( v61 >= 2 )
      {
        LODWORD(v76) = 2;
        LODWORD(v73) = v61;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
          __debugbreak();
      }
      v67 = *(float *)((char *)v65->v + v63);
      if ( v61 >= 2 )
      {
        LODWORD(v76) = 2;
        LODWORD(v73) = v61;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
          __debugbreak();
      }
      v65->v[0] = v67;
      if ( v61 >= 2 )
      {
        LODWORD(v76) = 2;
        LODWORD(v73) = v61;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v73, v76) )
          __debugbreak();
      }
      if ( *(float *)((char *)v65->v + v64) > 0.0 )
        goto LABEL_90;
    }
    ++v61;
    v65 = (vec2_t *)((char *)v65 + 4);
    v66 = v61 < 2;
  }
  while ( (int)v61 < 2 );
  v69 = inOutAngles->v[1];
  v70 = inOutAngles->v[0];
  v71 = fsqrt((float)(v69 * v69) + (float)(v70 * v70));
  if ( v82 <= 0.000001 || v71 <= 0.000001 || (float)((float)((float)(v69 * (float)(-1.0 / v71)) * v79) + (float)((float)(v70 * (float)(-1.0 / v71)) * v46)) >= 0.0 )
    return 0;
  if ( *inOutKickNeedsToCrossCenter )
  {
    *inOutKickNeedsToCrossCenter = 0;
    return 0;
  }
LABEL_102:
  result = 1;
  *inOutAngles = 0i64;
  *inOutAngularVel = 0i64;
  return result;
}

/*
==============
BG_CalculateKickMovement_Legacy
==============
*/

void __fastcall BG_CalculateKickMovement_Legacy(const float ft, const vec3_t *maxAngles, double recenterAccel, const Weapon *r_weapon, const bool fastSnipe, vec3_t *inOutKickAVel, vec3_t *inOutKickAngles)
{
  vec3_t *v7; 
  unsigned int v8; 
  signed __int64 v9; 
  signed __int64 v10; 
  bool v13; 
  float v23; 
  const dvar_t *v24; 
  float v25; 
  float v26; 
  float v27; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 
  __int64 v34; 

  v7 = inOutKickAngles;
  v8 = 0;
  v9 = (char *)maxAngles - (char *)inOutKickAngles;
  v10 = (char *)inOutKickAVel - (char *)inOutKickAngles;
  v13 = 1;
  _XMM12 = LODWORD(FLOAT_1_0);
  _XMM13 = *(_OWORD *)&recenterAccel;
  _XMM7 = 0i64;
  do
  {
    if ( !v13 )
    {
      LODWORD(v33) = 3;
      LODWORD(v31) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
        __debugbreak();
    }
    if ( *(float *)((char *)v7->v + v10) != 0.0 )
      goto LABEL_74;
    if ( v8 >= 3 )
    {
      LODWORD(v33) = 3;
      LODWORD(v31) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
        __debugbreak();
    }
    if ( v7->v[0] != 0.0 )
    {
LABEL_74:
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      if ( v7->v[0] != 0.0 )
      {
        if ( v8 >= 3 )
        {
          LODWORD(v33) = 3;
          LODWORD(v31) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
            __debugbreak();
        }
        __asm
        {
          vcmpltss xmm0, xmm7, dword ptr [rdi]
          vblendvps xmm3, xmm12, xmm11, xmm0
        }
        if ( *(float *)&_XMM3 != 0.0 )
        {
          _XMM0 = r_weapon->weaponIdx;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm0, xmm13, xmm15, xmm2
          }
          v23 = *(float *)&_XMM0 * *(float *)&_XMM3;
          if ( fastSnipe )
          {
            v24 = DVARFLT_perk_fastSnipeScale;
            if ( !DVARFLT_perk_fastSnipeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fastSnipeScale") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v24);
            v23 = (float)(*(float *)&_XMM0 * *(float *)&_XMM3) * v24->current.value;
          }
          if ( v8 >= 3 )
          {
            LODWORD(v33) = 3;
            LODWORD(v31) = v8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
              __debugbreak();
          }
          *(float *)((char *)v7->v + v10) = (float)(v23 * ft) + *(float *)((char *)v7->v + v10);
        }
      }
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      v26 = ft * *(float *)((char *)v7->v + v10);
      v25 = v26;
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      if ( (float)(v26 * v7->v[0]) < 0.0 )
        v25 = v26 * 0.059999999;
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
        LODWORD(v34) = 3;
        LODWORD(v32) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v32, v34) )
          __debugbreak();
      }
      if ( (float)((float)(v25 + v7->v[0]) * v7->v[0]) < 0.0 )
      {
        if ( v8 >= 3 )
        {
          LODWORD(v33) = 3;
          LODWORD(v31) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
            __debugbreak();
        }
        v7->v[0] = 0.0;
        if ( v8 >= 3 )
          goto LABEL_68;
        goto LABEL_70;
      }
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      v7->v[0] = v25 + v7->v[0];
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      if ( v7->v[0] == 0.0 )
        goto LABEL_62;
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      LODWORD(v27) = LODWORD(v7->v[0]) & _xmm;
      if ( v8 >= 3 )
      {
        LODWORD(v33) = 3;
        LODWORD(v31) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 48, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
          __debugbreak();
      }
      if ( v27 > *(float *)((char *)v7->v + v9) )
      {
        if ( v8 >= 3 )
        {
          LODWORD(v33) = 3;
          LODWORD(v31) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
            __debugbreak();
        }
        __asm { vcmpltss xmm0, xmm7, xmm6 }
        _XMM1 = *(unsigned int *)vec3_t::operator[]((vec3_t *)maxAngles, v8) ^ (unsigned __int128)(unsigned int)_xmm;
        __asm { vblendvps xmm0, xmm1, xmm2, xmm0 }
        if ( v8 >= 3 )
        {
          LODWORD(v33) = 3;
          LODWORD(v31) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
            __debugbreak();
        }
        v7->v[0] = *(float *)&_XMM0;
LABEL_62:
        if ( v8 >= 3 )
        {
LABEL_68:
          LODWORD(v33) = 3;
          LODWORD(v31) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v31, v33) )
            __debugbreak();
        }
LABEL_70:
        *(float *)((char *)v7->v + v10) = 0.0;
      }
    }
    ++v8;
    v7 = (vec3_t *)((char *)v7 + 4);
    v13 = v8 < 3;
  }
  while ( (int)v8 < 3 );
}

/*
==============
BG_CalculateKickPolar
==============
*/
void BG_CalculateKickPolar(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel)
{
  int bulletNum; 
  const dvar_t *v13; 
  float fWeaponPosFrac; 
  __int128 v15; 
  float v16; 
  float v17; 
  double v18; 
  float v19; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  float adsAngularGunKickStrengthMin; 
  float adsAngularGunKickStrengthMax; 
  float hipAngularGunKickDir; 
  float hipAngularGunKickDev; 
  float hipAngularGunKickStrengthMin; 
  float hipAngularGunKickStrengthMax; 
  float adsAngularGunKickPitchScale; 
  float hipAngularGunKickPitchScale[17]; 
  float adsAngularGunKickDir; 
  float adsAngularGunKickDev; 

  bulletNum = BG_GetShotCountForRecoil(ps);
  if ( isViewKick )
    BG_GetAngularViewKickSettings(weaponMap, ps, r_weapon, isAlternate, bulletNum, &hipAngularGunKickDir, &hipAngularGunKickDev, &hipAngularGunKickStrengthMin, &hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, &adsAngularGunKickDir, &adsAngularGunKickDev, &adsAngularGunKickStrengthMin, &adsAngularGunKickStrengthMax, &adsAngularGunKickPitchScale);
  else
    BG_GetAngularGunKickSettings(weaponMap, ps, r_weapon, isAlternate, bulletNum, &hipAngularGunKickDir, &hipAngularGunKickDev, &hipAngularGunKickStrengthMin, &hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, &adsAngularGunKickDir, &adsAngularGunKickDev, &adsAngularGunKickStrengthMin, &adsAngularGunKickStrengthMax, &adsAngularGunKickPitchScale);
  v13 = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
  fWeaponPosFrac = ps->weapCommon.fWeaponPosFrac;
  if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v13);
  if ( fWeaponPosFrac < v13->current.value )
  {
    v15 = LODWORD(hipAngularGunKickDir);
    v16 = hipAngularGunKickStrengthMin;
    v17 = hipAngularGunKickStrengthMax;
  }
  else
  {
    v15 = LODWORD(adsAngularGunKickDir);
    v16 = adsAngularGunKickStrengthMin;
    v17 = adsAngularGunKickStrengthMax;
  }
  BG_random(holdrand);
  v18 = BG_random(holdrand);
  v19 = (float)((float)(1.0 - *(float *)&v18) * v16) + (float)(*(float *)&v18 * v17);
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 1 }
  _XMM0.m128_u64[1] = *((_QWORD *)&v15 + 1);
  *(double *)_XMM0.m128_u64 = j___libm_sse2_sincosf_(v23, v22, v24, v25);
  *outPitchAVel = COERCE_FLOAT(COERCE_UNSIGNED_INT(_mm_shuffle_ps(_XMM0, _XMM0, 1).m128_f32[0] * v19) ^ _xmm);
  *outYawAVel = COERCE_FLOAT(COERCE_UNSIGNED_INT(_XMM0.m128_f32[0] * v19) ^ _xmm);
}

/*
==============
BG_CalculateRecoilInputScalar
==============
*/
float BG_CalculateRecoilInputScalar(float kick, float move, float fkickAlignedInputScalar, float fkickOpposedInputScalar)
{
  bool v4; 

  if ( kick == 0.0 || move == 0.0 )
    return FLOAT_1_0;
  v4 = kick < 0.0;
  if ( kick > 0.0 )
  {
    if ( move < 0.0 )
      return fkickOpposedInputScalar;
    v4 = kick < 0.0;
  }
  if ( v4 && move > 0.0 )
    return fkickOpposedInputScalar;
  return fkickAlignedInputScalar;
}

/*
==============
BG_CalculateRecoilInputScalars
==============
*/
void BG_CalculateRecoilInputScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, float pitchKick, float yawKick, float pitchMove, float yawMove, float *outPitchInputScalar, float *outYawInputScalar)
{
  unsigned int v14; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v17; 
  unsigned int v18; 
  const WeaponAttachment **v19; 
  AttViewKick *AttachmentViewKick; 
  float kickAlignedInputScalar; 
  unsigned int v22; 
  const PlayerEquippedWeaponState *v23; 
  bool v24; 
  const WeaponAttachment **v25; 
  AttViewKick *v26; 
  float kickOpposedInputScalar; 
  float v28; 
  bool v29; 
  float v30; 
  bool v31; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outPitchInputScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3770, ASSERT_TYPE_ASSERT, "(outPitchInputScalar)", (const char *)&queryFormat, "outPitchInputScalar") )
    __debugbreak();
  if ( !outYawInputScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3771, ASSERT_TYPE_ASSERT, "(outYawInputScalar)", (const char *)&queryFormat, "outYawInputScalar") )
    __debugbreak();
  v14 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v17 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  v18 = 0;
  if ( WeaponAttachments_Internal )
  {
    v19 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20735, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, weapon, isAlternate, *v19, v17);
      if ( AttachmentViewKick )
        break;
      ++v18;
      ++v19;
      if ( v18 >= WeaponAttachments_Internal )
        goto LABEL_19;
    }
    kickAlignedInputScalar = AttachmentViewKick->kickAlignedInputScalar;
  }
  else
  {
LABEL_19:
    kickAlignedInputScalar = BG_WeaponDefAtIndex(weapon->weaponIdx)->kickAlignedInputScalar;
  }
  v22 = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v24 = ps && weaponMap && (v23 = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL && v23->hybridScope;
  if ( v22 )
  {
    v25 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20757, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v26 = BG_GetAttachmentViewKick(weaponMap, ps, weapon, isAlternate, *v25, v24);
      if ( v26 )
        break;
      ++v14;
      ++v25;
      if ( v14 >= v22 )
        goto LABEL_33;
    }
    kickOpposedInputScalar = v26->kickOpposedInputScalar;
  }
  else
  {
LABEL_33:
    kickOpposedInputScalar = BG_WeaponDefAtIndex(weapon->weaponIdx)->kickOpposedInputScalar;
  }
  LODWORD(v28) = LODWORD(pitchMove) ^ _xmm;
  if ( pitchKick == 0.0 || v28 == 0.0 )
  {
    v30 = FLOAT_1_0;
    goto LABEL_46;
  }
  v29 = pitchKick < 0.0;
  if ( pitchKick > 0.0 )
  {
    if ( v28 < 0.0 )
    {
      v30 = kickOpposedInputScalar;
      goto LABEL_46;
    }
    v29 = pitchKick < 0.0;
  }
  if ( v29 && v28 > 0.0 )
    v30 = kickOpposedInputScalar;
  else
    v30 = kickAlignedInputScalar;
LABEL_46:
  *outPitchInputScalar = v30;
  if ( yawKick == 0.0 || yawMove == 0.0 )
  {
    *outYawInputScalar = FLOAT_1_0;
  }
  else
  {
    v31 = yawKick < 0.0;
    if ( yawKick > 0.0 )
    {
      if ( yawMove < 0.0 )
      {
LABEL_50:
        *outYawInputScalar = kickOpposedInputScalar;
        return;
      }
      v31 = yawKick < 0.0;
    }
    if ( v31 && yawMove > 0.0 )
      goto LABEL_50;
    *outYawInputScalar = kickAlignedInputScalar;
  }
}

/*
==============
BG_CalculateScopeFadeFraction
==============
*/
void BG_CalculateScopeFadeFraction(AttSight *sight, const float fractionFadeIn, const float fractionFadeOut, GfxScopeFadeInfo *outScopeFadeInfo)
{
  __int128 v10; 
  const dvar_t *v14; 
  __int128 v16; 
  double v18; 
  const dvar_t *v19; 
  double v20; 

  if ( !sight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15683, ASSERT_TYPE_ASSERT, "(sight)", (const char *)&queryFormat, "sight") )
    __debugbreak();
  _XMM0 = LODWORD(sight->adsSmoothFadeInBegin);
  __asm { vminss  xmm7, xmm0, cs:__real@3f7d70a4 }
  v10 = _XMM7;
  *(float *)&v10 = *(float *)&_XMM7 + 0.0099999998;
  _XMM0 = v10;
  _XMM1 = LODWORD(sight->adsSmoothFadeOutBegin);
  __asm
  {
    vminss  xmm11, xmm1, cs:__real@3f7d70a4
    vmaxss  xmm9, xmm0, dword ptr [rbx+10h]
  }
  v14 = DCONST_DVARBOOL_bg_scopeFadeIn;
  v16 = _XMM11;
  *(float *)&v16 = *(float *)&_XMM11 + 0.0099999998;
  _XMM0 = v16;
  __asm { vmaxss  xmm12, xmm0, dword ptr [rbx+18h] }
  if ( !DCONST_DVARBOOL_bg_scopeFadeIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeIn") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  if ( v14->current.enabled && sight->adsSmoothFade )
    v18 = I_fclamp((float)(fractionFadeIn - *(float *)&_XMM7) / (float)(*(float *)&_XMM9 - *(float *)&_XMM7), 0.0, 1.0);
  else
    LODWORD(v18) = 0;
  outScopeFadeInfo->fadeInFrac = *(float *)&v18;
  v19 = DCONST_DVARBOOL_bg_scopeFadeOut;
  if ( !DCONST_DVARBOOL_bg_scopeFadeOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeOut") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  if ( v19->current.enabled && sight->adsSmoothFade )
  {
    v20 = I_fclamp((float)(*(float *)&_XMM9 - fractionFadeOut) / (float)(*(float *)&_XMM12 - *(float *)&_XMM11), 0.0, 1.0);
    outScopeFadeInfo->fadeOutFrac = *(float *)&v20;
  }
  else
  {
    outScopeFadeInfo->fadeOutFrac = FLOAT_1_0;
  }
}

/*
==============
BG_CalculateScopeFadeFractions
==============
*/
void BG_CalculateScopeFadeFractions(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const bool playerUsesNVGHalfADS, const WeaponAttachment *scopeAttachment, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  GfxScopeInfo *v9; 
  AttSight *sight; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  GfxScopeInfo *v15; 
  AttSight *v16; 
  float fraction; 
  double v18; 
  __int128 v19; 
  __int128 v20; 
  __int128 v21; 
  __int128 v22; 
  double v23; 
  __int128 v24; 
  __int128 v25; 
  __int128 v31; 
  BgHybridScopeInfo outHybridScopeInfo; 

  v9 = settingOut;
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15714, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15715, ASSERT_TYPE_ASSERT, "(settingOut)", (const char *)&queryFormat, "settingOut") )
    __debugbreak();
  if ( !scopeAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15716, ASSERT_TYPE_ASSERT, "(scopeAttachment)", (const char *)&queryFormat, "scopeAttachment") )
    __debugbreak();
  if ( !scopeAttachment->sight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15717, ASSERT_TYPE_ASSERT, "(scopeAttachment->sight)", (const char *)&queryFormat, "scopeAttachment->sight") )
    __debugbreak();
  sight = scopeAttachment->sight;
  memset(&outHybridScopeInfo, 0, sizeof(outHybridScopeInfo));
  v9->adsSmoothFade = sight->adsSmoothFade;
  if ( playerUsesNVGHalfADS )
  {
    v9->scopeFadeInfo[0] = (GfxScopeFadeInfo)1065353216i64;
    v9->scopeFadeInfo[1] = (GfxScopeFadeInfo)1065353216i64;
  }
  else
  {
    if ( !BG_CanHybridToggle(ps, r_weapon, isAlternate) )
      goto LABEL_33;
    if ( BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_ROCKETLAUNCHER )
      goto LABEL_33;
    settingOut = NULL;
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(r_weapon, isAlternate, (const WeaponAttachment **)&settingOut);
    if ( HybridScopeEnablerAttachment != scopeAttachment )
      goto LABEL_33;
    v15 = settingOut;
    if ( !settingOut )
      goto LABEL_33;
    BG_GetHybridScopeInfo(r_weapon, isAlternate, &outHybridScopeInfo);
    v16 = *(AttSight **)&v15[1].scopeLensAxis.row1.z;
    if ( !outHybridScopeInfo.hasHybridScope && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15764, ASSERT_TYPE_ASSERT, "(hybridScopeInfo.hasHybridScope)", (const char *)&queryFormat, "hybridScopeInfo.hasHybridScope", outHybridScopeInfo.hybridScopeAttachment, *(_QWORD *)&outHybridScopeInfo.hybridScope1To2FovTransBegin, *(_QWORD *)&outHybridScopeInfo.hybridScope2To1FovTransBegin) )
      __debugbreak();
    if ( v16 )
    {
      if ( !HybridScopeEnablerAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15770, ASSERT_TYPE_ASSERT, "(hybridEnablerAttachment)", (const char *)&queryFormat, "hybridEnablerAttachment") )
        __debugbreak();
      if ( !HybridScopeEnablerAttachment->adsOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15771, ASSERT_TYPE_ASSERT, "(hybridEnablerAttachment->adsOverlay)", (const char *)&queryFormat, "hybridEnablerAttachment->adsOverlay") )
        __debugbreak();
      fraction = hybridScopeFraction->fraction;
      if ( hybridScopeFraction->increasing )
      {
        v18 = I_fclamp((float)(fraction - outHybridScopeInfo.hybridScope1To2ScopeFadeTransBegin) / (float)(outHybridScopeInfo.hybridScope1To2ScopeFadeTransEnd - outHybridScopeInfo.hybridScope1To2ScopeFadeTransBegin), 0.0, 1.0);
        v19 = *(unsigned __int64 *)&v18;
        *(float *)&v19 = (float)(*(float *)&v18 - 0.5) * 3.1415927;
        v20 = v19;
        *(float *)&v20 = sinf_0(*(float *)&v19);
        v21 = v20;
        *(float *)&v21 = (float)(*(float *)&v20 + 1.0) * 0.5;
        v22 = v21;
      }
      else
      {
        v23 = I_fclamp((float)((float)(1.0 - fraction) - outHybridScopeInfo.hybridScope2To1ScopeFadeTransBegin) / (float)(outHybridScopeInfo.hybridScope2To1ScopeFadeTransEnd - outHybridScopeInfo.hybridScope2To1ScopeFadeTransBegin), 0.0, 1.0);
        v24 = LODWORD(FLOAT_0_5);
        *(float *)&v24 = 0.5 - (float)(sinf_0((float)(*(float *)&v23 - 0.5) * 3.1415927) * 0.5);
        v22 = v24;
      }
      v25 = LODWORD(FLOAT_1_0);
      *(float *)&v25 = (float)(1.0 - *(float *)&v22) * adsFrac;
      _XMM1 = v25;
      _XMM0 = HybridScopeEnablerAttachment->adsOverlay->hybridScope1ShowHipGlassWhenInactive;
      __asm
      {
        vpcmpeqd xmm3, xmm0, xmm2
        vblendvps xmm2, xmm1, xmm6, xmm3; fractionFadeOut
      }
      BG_CalculateScopeFadeFraction(sight, *(const float *)&v25, *(const float *)&_XMM2, v9->scopeFadeInfo);
      v31 = v22;
      *(float *)&v31 = *(float *)&v22 * adsFrac;
      _XMM1 = v31;
      _XMM0 = HybridScopeEnablerAttachment->adsOverlay->hybridScope2ShowHipGlassWhenInactive;
      __asm
      {
        vpcmpeqd xmm3, xmm0, xmm2
        vblendvps xmm2, xmm1, xmm6, xmm3; fractionFadeOut
      }
      BG_CalculateScopeFadeFraction(v16, *(float *)&v22 * adsFrac, *(const float *)&_XMM2, &v9->scopeFadeInfo[1]);
    }
    else
    {
LABEL_33:
      BG_CalculateScopeFadeFraction(sight, adsFrac, adsFrac, v9->scopeFadeInfo);
      BG_CalculateScopeFadeFraction(sight, adsFrac, adsFrac, &v9->scopeFadeInfo[1]);
    }
  }
}

/*
==============
BG_CanAttachmentHybridToggle
==============
*/
AttADSOverlay *BG_CanAttachmentHybridToggle(const WeaponAttachment *attachment)
{
  AttADSOverlay *result; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  result = attachment->adsOverlay;
  if ( result )
    return (AttADSOverlay *)result->hybridToggle;
  return result;
}

/*
==============
BG_CanEquipWeapon
==============
*/
bool BG_CanEquipWeapon(const BgWeaponMap *const weaponMap, const playerState_s *const ps, const Weapon *r_weapon)
{
  return BG_GetFreeEquipSlot(weaponMap, ps) >= 0;
}

/*
==============
BG_CanHybridToggle
==============
*/
bool BG_CanHybridToggle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7556, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v8 = *i;
    if ( (*i)->type == ATTACHMENT_SCOPE )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0;
  }
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  adsOverlay = v8->adsOverlay;
  if ( !adsOverlay )
    return 0;
  return adsOverlay->hybridToggle;
}

/*
==============
BG_CanPlayerHaveWeapon
==============
*/
bool BG_CanPlayerHaveWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->gunXModel != NULL;
}

/*
==============
BG_CanThermalToggle
==============
*/
bool BG_CanThermalToggle(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = v4->thermalToggle && v4->thermalScope;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v5;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7599, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    if ( (*i)->type == ATTACHMENT_SCOPE )
    {
      adsOverlay = (*i)->adsOverlay;
      if ( adsOverlay )
        break;
    }
    if ( ++v6 >= WeaponAttachments_Internal )
      return v5;
  }
  return adsOverlay->thermalToggle && adsOverlay->thermalScope;
}

/*
==============
BG_ChargeWeaponInTime
==============
*/
__int64 BG_ChargeWeaponInTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 220i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_ChargeWeaponLoopTime
==============
*/
__int64 BG_ChargeWeaponLoopTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 222i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_ChargeWeaponOutTime
==============
*/
__int64 BG_ChargeWeaponOutTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 224i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_CheckTorsoAnimForModelVisibility
==============
*/
_BOOL8 BG_CheckTorsoAnimForModelVisibility(const BgAnimStatic *const bgameAnim, const entityState_t *es, characterInfo_t *ci, scr_string_t notetrack_on, scr_string_t notetrack_off, float rangeExpand)
{
  unsigned int Animset; 
  PlayerASM_AnimSlot v11; 
  unsigned int v12; 
  unsigned int Anim; 
  unsigned int XAnimIndex; 
  XAnimTree *pXAnimTree; 
  int XAnimIndexForCharacter; 
  float v17; 
  float v18; 
  double Length; 
  double NotetrackTime; 
  float v21; 
  double v22; 
  double v23; 
  float v24; 
  double Time; 
  _BOOL8 result; 
  unsigned int outAnimPartsIndex; 

  if ( PlayerASM_IsEnabled() )
  {
    Animset = BG_PlayerASM_GetAnimset(ci);
    LOBYTE(v11) = 1;
    v12 = Animset;
    Anim = BG_PlayerASM_GetAnim(es, v11);
    XAnimIndex = BG_PlayerASM_GetXAnimIndex(v12, Anim);
    pXAnimTree = ci->pXAnimTree;
    outAnimPartsIndex = 0;
    BG_PlayerASM_GetXAnimParts(pXAnimTree->anims, XAnimIndex, &outAnimPartsIndex);
    XAnimIndexForCharacter = outAnimPartsIndex;
  }
  else
  {
    XAnimIndexForCharacter = BG_AnimationMP_GetXAnimIndexForCharacter(bgameAnim, ci, ci->torso.animationNumber & 0xFFFFEFFF);
  }
  v17 = rangeExpand;
  v18 = 0.0;
  if ( rangeExpand != 0.0 )
  {
    Length = XAnimGetLength(ci->pXAnimTree->anims, XAnimIndexForCharacter);
    if ( *(float *)&Length > 0.0 )
      v18 = v17 / *(float *)&Length;
  }
  NotetrackTime = XAnimGetNotetrackTime(ci->pXAnimTree->anims, XAnimIndexForCharacter, notetrack_on);
  v21 = *(float *)&NotetrackTime;
  result = 0;
  if ( *(float *)&NotetrackTime < 0.0 || (v22 = XAnimGetTime(ci->pXAnimTree, 0, XANIM_SUBTREE_DEFAULT, XAnimIndexForCharacter), *(float *)&v22 >= (float)(v21 - v18)) )
  {
    v23 = XAnimGetNotetrackTime(ci->pXAnimTree->anims, XAnimIndexForCharacter, notetrack_off);
    v24 = *(float *)&v23;
    if ( *(float *)&v23 < 0.0 )
      return 1;
    Time = XAnimGetTime(ci->pXAnimTree, 0, XANIM_SUBTREE_DEFAULT, XAnimIndexForCharacter);
    if ( *(float *)&Time < (float)(v24 + v18) )
      return 1;
  }
  return result;
}

/*
==============
BG_ClearAgentWeapons
==============
*/
void BG_ClearAgentWeapons(BgWeaponMap *weaponMap, agentState_s *as)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20448, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !as && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20449, ASSERT_TYPE_ASSERT, "(as)", (const char *)&queryFormat, "as") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &as->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &as->serverDobjTurretWeapon);
}

/*
==============
BG_ClearClientWeapons
==============
*/
void BG_ClearClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !cs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20439, ASSERT_TYPE_ASSERT, "(cs)", (const char *)&queryFormat, "cs") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &cs->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &cs->serverDobjTurretWeapon);
}

/*
==============
BG_ClearMLGSpectatorClientWeapons
==============
*/
void BG_ClearMLGSpectatorClientWeapons(BgWeaponMap *weaponMap, MLGSpectatorClientInfo *mlgSpectatorClientInfo)
{
  BgWeaponHandle *weaponHandles; 
  __int64 v5; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20459, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !mlgSpectatorClientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20460, ASSERT_TYPE_ASSERT, "( mlgSpectatorClientInfo )", (const char *)&queryFormat, "mlgSpectatorClientInfo") )
    __debugbreak();
  weaponHandles = mlgSpectatorClientInfo->weaponHandles;
  v5 = 2i64;
  do
  {
    weaponMap->ClearWeapon(weaponMap, weaponHandles++);
    --v5;
  }
  while ( v5 );
}

/*
==============
BG_ClearPlayerWeapons
==============
*/
void BG_ClearPlayerWeapons(BgWeaponMap *weaponMap, playerState_s *ps)
{
  BgWeaponHandle *weaponsEquipped; 
  __int64 v5; 
  int i; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20395, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20396, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponHandle);
  weaponMap->ClearWeapon(weaponMap, (BgWeaponHandle *)&ps->weapCommon);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.lastWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.lastStowedWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponSpawnHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponAnimArrayHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.forcedViewAnimWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.forcedViewAnimOriginalWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->throwbackWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &ps->serverDobjTurretWeapon);
  weaponMap->ClearWeapon(weaponMap, &ps->executionWeapon);
  weaponMap->ClearWeapon(weaponMap, (BgWeaponHandle *)&ps->highPriorityWeapInfo);
  weaponsEquipped = ps->weaponsEquipped;
  v5 = 15i64;
  do
  {
    weaponMap->ClearWeapon(weaponMap, weaponsEquipped++);
    --v5;
  }
  while ( v5 );
  for ( i = 0; i < 7; ++i )
    BG_ClearActionSlotParameter(weaponMap, ps, i);
  BG_ClearPlayerEvents(weaponMap, ps);
}

/*
==============
BG_ConvertWeaponFromHexString
==============
*/
Weapon *BG_ConvertWeaponFromHexString(Weapon *result, const char *hexString)
{
  *result = NULL_WEAPON;
  Com_ConvertHexToBytes(hexString, 0x3Cui64, (unsigned __int8 *)result);
  return result;
}

/*
==============
BG_ConvertWeaponToHexString
==============
*/
void BG_ConvertWeaponToHexString(const Weapon *r_weapon, char *outHexString, int outStringLength)
{
  if ( !outHexString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20622, ASSERT_TYPE_ASSERT, "(outHexString)", (const char *)&queryFormat, "outHexString") )
    __debugbreak();
  Com_ConvertBytesToHex((const unsigned __int8 *)r_weapon, 60, outStringLength, outHexString);
}

/*
==============
BG_CopyPlayerWeapons
==============
*/
void BG_CopyPlayerWeapons(BgWeaponMap *dstWeaponMap, playerState_s *dstPs, const BgWeaponMap *srcWeaponMap, const playerState_s *srcPs)
{
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *Weapon; 
  const Weapon *OffHandWeaponForPlayer; 
  const Weapon *v11; 
  const Weapon *v12; 
  const Weapon *v13; 
  const Weapon *v14; 
  const Weapon *v15; 
  const Weapon *ThrowbackWeaponForPlayer; 
  const Weapon *v17; 
  const Weapon *v18; 
  const Weapon *v19; 
  const Weapon *v20; 
  BgWeaponHandle *weaponsEquipped; 
  int v22; 
  const Weapon *v23; 
  int v24; 
  ActionSlotType *actionSlotType; 
  ActionSlotParam *actionSlotParam; 
  const Weapon *v27; 
  __int64 v28; 
  __int64 v29; 
  signed __int64 v31; 
  __m256i v32; 
  __int128 v33; 
  __int64 v34; 
  int v35; 

  if ( !dstWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20474, ASSERT_TYPE_ASSERT, "( dstWeaponMap )", (const char *)&queryFormat, "dstWeaponMap") )
    __debugbreak();
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20475, ASSERT_TYPE_ASSERT, "( dstPs )", (const char *)&queryFormat, "dstPs") )
    __debugbreak();
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20476, ASSERT_TYPE_ASSERT, "( srcWeaponMap )", (const char *)&queryFormat, "srcWeaponMap") )
    __debugbreak();
  if ( !srcPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20477, ASSERT_TYPE_ASSERT, "( srcPs )", (const char *)&queryFormat, "srcPs") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(srcWeaponMap, srcPs);
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponHandle, CurrentWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 863, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !srcPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 864, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.lastWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 875, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.lastWeaponHandle, Weapon);
  OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(srcWeaponMap, srcPs);
  BG_SetOffHandWeaponForPlayer(dstWeaponMap, dstPs, OffHandWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 972, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.lastStowedWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 982, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.lastStowedWeaponHandle, v11);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 936, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v12 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.weaponSpawnHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 946, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponSpawnHandle, v12);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 954, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v13 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.weaponAnimArrayHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 964, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponAnimArrayHandle, v13);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 990, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v14 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.forcedViewAnimWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1000, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.forcedViewAnimWeaponHandle, v14);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1008, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v15 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.forcedViewAnimOriginalWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1018, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.forcedViewAnimOriginalWeaponHandle, v15);
  ThrowbackWeaponForPlayer = BG_GetThrowbackWeaponForPlayer(srcWeaponMap, srcPs);
  BG_SetThrowbackWeaponForPlayer(dstWeaponMap, dstPs, ThrowbackWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 785, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v17 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->serverDobjHeldWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 795, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->serverDobjHeldWeapon, v17);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 803, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v18 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->serverDobjTurretWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 813, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->serverDobjTurretWeapon, v18);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 821, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v19 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->executionWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 831, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->executionWeapon, v19);
  v20 = BG_HighPriorityWeapon_Get(srcWeaponMap, srcPs);
  BG_HighPriorityWeapon_SetDirectly(dstWeaponMap, dstPs, v20);
  weaponsEquipped = dstPs->weaponsEquipped;
  v22 = 0;
  v31 = (char *)srcPs - (char *)dstPs;
  do
  {
    if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( (unsigned int)v22 >= 0xF )
    {
      LODWORD(v29) = 15;
      LODWORD(v28) = v22;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v28, v29) )
        __debugbreak();
    }
    v23 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, *(BgWeaponHandle *)((char *)weaponsEquipped + (char *)srcPs - (char *)dstPs));
    if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 852, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( (unsigned int)v22 >= 0xF )
    {
      LODWORD(v29) = 15;
      LODWORD(v28) = v22;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 853, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v28, v29) )
        __debugbreak();
    }
    dstWeaponMap->SetWeapon(dstWeaponMap, weaponsEquipped, v23);
    ++v22;
    ++weaponsEquipped;
  }
  while ( v22 < 15 );
  v24 = 0;
  actionSlotType = dstPs->actionSlotType;
  actionSlotParam = dstPs->actionSlotParam;
  do
  {
    if ( dstPs != srcPs )
      BG_ClearActionSlotParameter(dstWeaponMap, dstPs, v24);
    *actionSlotType = *(ActionSlotType *)((char *)actionSlotType + v31);
    if ( BG_ActionSlotIsWeaponType(srcPs, v24) )
    {
      if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1026, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( (unsigned int)v24 >= 7 )
      {
        LODWORD(v29) = 7;
        LODWORD(v28) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1028, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", v28, v29) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(srcPs, v24) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1029, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      v27 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, *(BgWeaponHandle *)((char *)&actionSlotParam->specifyWeapon.weaponHandle + v31));
      v32 = *(__m256i *)&v27->weaponIdx;
      v33 = *(_OWORD *)&v27->attachmentVariationIndices[5];
      v34 = *(_QWORD *)&v27->attachmentVariationIndices[21];
      v35 = *(_DWORD *)&v27->weaponCamo;
      if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1038, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v24 >= 7 )
      {
        LODWORD(v29) = 7;
        LODWORD(v28) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1039, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", v28, v29) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(dstPs, v24) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1040, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      dstWeaponMap->SetWeapon(dstWeaponMap, (BgWeaponHandle *)actionSlotParam, (const Weapon *)&v32);
    }
    else
    {
      actionSlotType[7] = *(ActionSlotType *)((char *)actionSlotType + v31 + 28);
    }
    ++v24;
    ++actionSlotParam;
    ++actionSlotType;
  }
  while ( v24 < 7 );
  BG_CopyPlayerEvents(dstWeaponMap, dstPs, srcWeaponMap, srcPs);
}

/*
==============
BG_CrawlLoopTime
==============
*/
__int64 BG_CrawlLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 180i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_CRAWL_LOOP, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_CreateWeaponFireParam
==============
*/
__int64 BG_CreateWeaponFireParam(int boneIndex, const Weapon *r_weaponID)
{
  __int64 v5; 

  if ( r_weaponID->weaponIdx == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4719, ASSERT_TYPE_ASSERT, "(r_weaponID.weaponIdx < 0xffff)", (const char *)&queryFormat, "r_weaponID.weaponIdx < USHRT_MAX") )
    __debugbreak();
  if ( boneIndex + 1 >= 0xFFFF )
  {
    LODWORD(v5) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4720, ASSERT_TYPE_ASSERT, "( ( boneIndex + 1 < 0xffff ) )", "( boneIndex ) = %i", v5) )
      __debugbreak();
  }
  if ( boneIndex < 0 )
  {
    LODWORD(v5) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4721, ASSERT_TYPE_ASSERT, "( ( boneIndex >= 0 ) )", "( boneIndex ) = %i", v5) )
      __debugbreak();
  }
  return (boneIndex + 1) | (r_weaponID->weaponIdx << 16);
}

/*
==============
BG_CurrentWeaponSupportsDualFOV
==============
*/
bool BG_CurrentWeaponSupportsDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3036, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3037, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  return BG_HasDualFOV(weaponMap, ps, ViewmodelWeapon, 0) || BG_HasUnderbarrelAmmo(ViewmodelWeapon) && BG_HasDualFOV(weaponMap, ps, ViewmodelWeapon, 1);
}

/*
==============
BG_DPadIcon
==============
*/
Material *BG_DPadIcon(const Weapon *r_weapon, bool isAlternate, bool isActive)
{
  const WeaponCompleteDef *v5; 
  Material *dpadIconMat; 
  int v7; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v5 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( isActive || (dpadIconMat = v5->dpadIconInactiveMat) == NULL )
    dpadIconMat = v5->dpadIconMat;
  v7 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return dpadIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16315, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v7 >= AllWeaponAttachmentsWithIds )
      return dpadIconMat;
  }
  if ( isActive || !ui->dpadIconInactiveMat )
    return ui->dpadIconMat;
  else
    return ui->dpadIconInactiveMat;
}

/*
==============
BG_DamageConeAngle
==============
*/
float BG_DamageConeAngle(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float damageConeAngle; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  damageConeAngle = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageConeAngle;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return damageConeAngle;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17020, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return damageConeAngle;
  }
  return projectile->damageConeAngle;
}

/*
==============
BG_DangerIcon
==============
*/
Material *BG_DangerIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->dangerIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16218, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->dangerIconMat;
  }
  return ui->dangerIconMat;
}

/*
==============
BG_DeathAnimDamageType
==============
*/
__int64 BG_DeathAnimDamageType(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttDamage *damage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.deathAnimDamageType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8381, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    damage = (*i)->damage;
    if ( damage )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.deathAnimDamageType;
  }
  return (unsigned int)damage->deathAnimDamageType;
}

/*
==============
BG_DebugSniperScene
==============
*/
void BG_DebugSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float frac)
{
  bool v7; 
  const dvar_t *v8; 
  bool v9; 
  bool enabled; 
  const dvar_t *v11; 
  bool v12; 
  DObjPartBits *p_hidePartBits; 
  DObjPartBits *v14; 
  DObjPartBits *v15; 
  unsigned __int8 v16; 
  unsigned int v17; 
  const scr_string_t **v18; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5408, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v7 = BG_ShowViewModelInDualFOV(r_weapon, isAlternate);
  v8 = DCONST_DVARBOOL_bg_showSniperScene;
  v9 = v7;
  if ( !DCONST_DVARBOOL_bg_showSniperScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showSniperScene") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  enabled = v8->current.enabled;
  v11 = DCONST_DVARBOOL_bg_showHipScene;
  if ( !DCONST_DVARBOOL_bg_showHipScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showHipScene") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  v12 = v11->current.enabled;
  p_hidePartBits = &obj->hidePartBits;
  if ( enabled )
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  else
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  v14 = &obj->hidePartBits;
  if ( v12 )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v14, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v14, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  if ( !v9 )
  {
    v15 = &obj->hidePartBits;
    if ( enabled )
      v16 = BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v15, 0, -1);
    else
      v16 = BG_HideBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v15, 0, -1);
    if ( v16 <= 0xFDu )
    {
      v17 = 0;
      v18 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
      do
      {
        BG_ToggleBoneVisibilityInAllModels(**v18, obj, &obj->hidePartBits, v12);
        ++v17;
        ++v18;
      }
      while ( v17 < 0xD );
    }
  }
}

/*
==============
BG_DestabilizationCurvatureMax
==============
*/
float BG_DestabilizationCurvatureMax(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float destabilizationCurvatureMax; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  destabilizationCurvatureMax = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->destabilizationCurvatureMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return destabilizationCurvatureMax;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17498, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return destabilizationCurvatureMax;
  }
  return projectile->destabilizationCurvatureMax;
}

/*
==============
BG_DestabilizationRateTime
==============
*/
float BG_DestabilizationRateTime(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float destabilizationRateTime; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  destabilizationRateTime = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->destabilizationRateTime;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return destabilizationRateTime;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17473, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return destabilizationRateTime;
  }
  return projectile->destabilizationRateTime;
}

/*
==============
BG_DestabilizeDistance
==============
*/
__int64 BG_DestabilizeDistance(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int destabilizeDistance; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  destabilizeDistance = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->destabilizeDistance;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return destabilizeDistance;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17523, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return destabilizeDistance;
  }
  return (unsigned int)projectile->destabilizeDistance;
}

/*
==============
BG_DisableInputDrivenViewReturnDampening
==============
*/
bool BG_DisableInputDrivenViewReturnDampening(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  bool v4; 
  __int64 v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  WeaponAttachment **i; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = isAlternate;
  v8 = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableInputDrivenViewReturnDampening;
  for ( i = attachments; ; ++i )
  {
    OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v4, *i, v11);
    if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20780, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( OverrideAttachmentWhenApplicable->disableInputDrivenViewReturnDampening )
      break;
    v4 = isAlternate;
    v8 = (unsigned int)(v8 + 1);
    if ( (unsigned int)v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableInputDrivenViewReturnDampening;
  }
  return attachments[v8]->disableInputDrivenViewReturnDampening == WEAPON_FLAG_OVERRIDE_TRUE;
}

/*
==============
BG_DisableProjectileCrumpleCheck
==============
*/
_BOOL8 BG_DisableProjectileCrumpleCheck(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->disableProjectileCrumpleCheck;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17421, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->disableProjectileCrumpleCheck;
  }
  return projectile->disableProjectileCrumpleCheck;
}

/*
==============
BG_DoubleRiotShieldCheck
==============
*/
char BG_DoubleRiotShieldCheck(const BgWeaponMap *weaponMap, const Weapon *weaponToPickUp, const playerState_s *ps)
{
  __int16 v3; 
  unsigned int v7; 
  const Weapon *Weapon; 
  __m256i v9; 
  __int128 v10; 
  double v11; 
  __int64 v13; 
  __int64 v14; 
  Weapon r_weapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8104, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8105, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponToPickUp->weaponIdx || !BG_IsRiotShield(weaponToPickUp, 0) )
    return 0;
  v7 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v7 >= 0xF )
    {
      LODWORD(v14) = 15;
      LODWORD(v13) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v7]);
    v9 = *(__m256i *)&Weapon->weaponIdx;
    v10 = *(_OWORD *)&Weapon->attachmentVariationIndices[5];
    v11 = *(double *)&Weapon->attachmentVariationIndices[21];
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&Weapon->weaponCamo;
    *(__m256i *)&r_weapon.weaponIdx = v9;
    *(_OWORD *)&r_weapon.attachmentVariationIndices[5] = v10;
    *(double *)&r_weapon.attachmentVariationIndices[21] = v11;
    if ( v3 )
    {
      if ( BG_IsRiotShield(&r_weapon, 0) )
        break;
    }
    if ( (int)++v7 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_DropTime
==============
*/
__int64 BG_DropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 132i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EmptyDropTime
==============
*/
__int64 BG_EmptyDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 150i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EmptyFireSound
==============
*/
const SndAliasList *BG_EmptyFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 336);
}

/*
==============
BG_EmptyRaiseTime
==============
*/
__int64 BG_EmptyRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 148i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EndingGunKickPercent
==============
*/
float BG_EndingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  const WeaponDef *v6; 
  float adsEndingGunKickPercent; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    adsEndingGunKickPercent = v6->adsEndingGunKickPercent;
  else
    adsEndingGunKickPercent = v6->hipEndingGunKickPercent;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsEndingGunKickPercent;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14299, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return adsEndingGunKickPercent;
  }
  if ( ads )
    return kickScaling->adsEndingGunKickPercent;
  else
    return kickScaling->hipEndingGunKickPercent;
}

/*
==============
BG_EndingKickBullets
==============
*/
__int64 BG_EndingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int adsEndingKickBullets; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsEndingKickBullets = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsEndingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsEndingKickBullets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14266, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsEndingKickBullets;
  }
  return (unsigned int)kickScaling->adsEndingKickBullets;
}

/*
==============
BG_EndingViewKickPercent
==============
*/
float BG_EndingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  const WeaponDef *v6; 
  float adsEndingViewKickPercent; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    adsEndingViewKickPercent = v6->adsEndingViewKickPercent;
  else
    adsEndingViewKickPercent = v6->hipEndingViewKickPercent;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsEndingViewKickPercent;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14338, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return adsEndingViewKickPercent;
  }
  if ( ads )
    return kickScaling->adsEndingViewKickPercent;
  else
    return kickScaling->hipEndingViewKickPercent;
}

/*
==============
BG_EquipWeapon
==============
*/
char BG_EquipWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon)
{
  int FreeEquipSlot; 
  __int64 v7; 
  const char *WeaponName; 
  int v9; 
  __int64 v10; 
  const Weapon *Weapon; 
  const char *v12; 
  __int64 v14; 
  int AmmoNotInClip; 
  int v16; 
  ComGameModeApplication *ActiveApplication; 
  __int64 v18; 
  __int64 v19; 
  char output[1024]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6905, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6906, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  FreeEquipSlot = BG_GetFreeEquipSlot(weaponMap, ps);
  v7 = FreeEquipSlot;
  if ( FreeEquipSlot >= 0 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6872, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6873, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( (unsigned int)v7 >= 0xF )
    {
      LODWORD(v18) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6846, ASSERT_TYPE_ASSERT, "(unsigned)( equipIndex ) < (unsigned)( 15 )", "equipIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, 15) )
        __debugbreak();
    }
    v14 = v7;
    *(_QWORD *)&ps->weapEquippedData[v14].usedBefore = 0i64;
    *(_QWORD *)&ps->weapEquippedData[v14].thermalEnabled = 0i64;
    BG_SetEquippedWeaponForPlayer(weaponMap, ps, v7, r_weapon);
    AmmoNotInClip = BG_GetAmmoNotInClip(ps, r_weapon, 0);
    BG_SetGlobalAmmo(ps, r_weapon, 0, AmmoNotInClip);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
    {
      v16 = BG_GetAmmoNotInClip(ps, r_weapon, 1);
      BG_SetGlobalAmmo(ps, r_weapon, 1, v16);
    }
    if ( BG_IsRiotShield(r_weapon, 0) )
    {
      ActiveApplication = ComGameModeApplication::GetActiveApplication();
      ActiveApplication->EquipWeaponRiotShield(ActiveApplication, r_weapon, ps->clientNum);
    }
    return 1;
  }
  else
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    Com_PrintError(16, "No free weapon slots to add weapon (%s)\n", WeaponName);
    v9 = 0;
    v10 = 0i64;
    do
    {
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0xF )
      {
        LODWORD(v19) = 15;
        LODWORD(v18) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, v19) )
          __debugbreak();
      }
      Weapon = BgWeaponMap::GetWeapon(weaponMap, ps->weaponsEquipped[v10]);
      ++v9;
      v12 = BG_GetWeaponName(Weapon, output, 0x400u);
      Com_PrintError(16, "Weapon %i: %s\n", (unsigned int)v9, v12);
      ++v10;
    }
    while ( v9 < 15 );
    return 0;
  }
}

/*
==============
BG_ExplosionForceRadius
==============
*/
__int64 BG_ExplosionForceRadius(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iExplosionForceRadius; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iExplosionForceRadius = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iExplosionForceRadius;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iExplosionForceRadius;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16774, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iExplosionForceRadius;
  }
  return (unsigned int)projectile->explosionForceRadius;
}

/*
==============
BG_ExplosionForceScalar
==============
*/
float BG_ExplosionForceScalar(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->explosionForceScalar;
}

/*
==============
BG_ExplosionRadius
==============
*/
__int64 BG_ExplosionRadius(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int v5; 
  unsigned int WeaponAttachments_Internal; 
  bool v7; 
  WeaponAttachment *v8; 
  unsigned int iExplosionSteppedRadiusOuter; 
  AttProjectile *projectile; 
  AttProjectile *v12; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v7 = BG_ExplosionUsesSteppedDamage(r_weapon, isAlternate);
  v8 = attachments;
  if ( v7 )
  {
    iExplosionSteppedRadiusOuter = v4->iExplosionSteppedRadiusOuter;
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16732, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        projectile = v8->projectile;
        if ( projectile )
          break;
        ++v5;
        ++v8;
        if ( v5 >= WeaponAttachments_Internal )
          return iExplosionSteppedRadiusOuter;
      }
      return (unsigned int)projectile->iExplosionSteppedRadiusOuter;
    }
    return iExplosionSteppedRadiusOuter;
  }
  iExplosionSteppedRadiusOuter = v4->iExplosionRadius;
  if ( !WeaponAttachments_Internal )
    return iExplosionSteppedRadiusOuter;
  while ( 1 )
  {
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16748, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v12 = v8->projectile;
    if ( v12 )
      break;
    ++v5;
    ++v8;
    if ( v5 >= WeaponAttachments_Internal )
      return iExplosionSteppedRadiusOuter;
  }
  return (unsigned int)v12->explosionRadius;
}

/*
==============
BG_ExplosionReactiveEmitterDelay
==============
*/
float BG_ExplosionReactiveEmitterDelay(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reactiveEmitterDelay;
}

/*
==============
BG_ExplosionUsesSteppedDamage
==============
*/
_BOOL8 BG_ExplosionUsesSteppedDamage(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int v5; 
  unsigned int WeaponAttachments_Internal; 
  bool useSteppedExplosionDamage; 
  unsigned int v8; 
  WeaponAttachment *v9; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  useSteppedExplosionDamage = v4->useSteppedExplosionDamage;
  v8 = WeaponAttachments_Internal;
  v9 = attachments;
  if ( !WeaponAttachments_Internal )
    return useSteppedExplosionDamage;
  while ( 1 )
  {
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16818, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    projectile = v9->projectile;
    if ( projectile )
      break;
    ++v5;
    ++v9;
    if ( v5 >= v8 )
      return useSteppedExplosionDamage;
  }
  return projectile->useSteppedExplosionDamage;
}

/*
==============
BG_FindGlobalAmmoSlot
==============
*/
GlobalAmmo *BG_FindGlobalAmmoSlot(playerState_s *ps)
{
  int i; 

  for ( i = 0; i < 15; ++i )
  {
    if ( !BG_IsValidAmmo(&ps->weapCommon.ammoNotInClip[i].ammoType) )
      return &ps->weapCommon.ammoNotInClip[i];
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6790, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "All global ammo slots filled!\n") )
    __debugbreak();
  return ps->weapCommon.ammoNotInClip;
}

/*
==============
BG_FireRumble
==============
*/
RumbleInfo *BG_FireRumble(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  RumbleInfo *fireRumble; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttRumbles *rumbles; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fireRumble = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fireRumble;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return fireRumble;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16375, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    rumbles = (*i)->rumbles;
    if ( rumbles )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return fireRumble;
  }
  return rumbles->fireRumble;
}

/*
==============
BG_FireSound
==============
*/
const SndAliasList *BG_FireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 96);
}

/*
==============
BG_FirstRaiseTime
==============
*/
__int64 BG_FirstRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetADSAccel
==============
*/
void BG_GetADSAccel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsOutToInAccelSec, float *outAdsInToOutAccelSec)
{
  float *v6; 
  float *v11; 
  const WeaponDef *v12; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v14; 
  const AttADSSettings *WeaponAdsSettings; 
  float adsTransOutToInTime; 
  float v17; 
  float adsTransInToOutTime; 
  float AdsSettingsScale; 

  v6 = outAdsOutToInAccelSec;
  if ( !outAdsOutToInAccelSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12672, ASSERT_TYPE_ASSERT, "(outAdsOutToInAccelSec)", (const char *)&queryFormat, "outAdsOutToInAccelSec") )
    __debugbreak();
  v11 = outAdsInToOutAccelSec;
  if ( !outAdsInToOutAccelSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12673, ASSERT_TYPE_ASSERT, "(outAdsInToOutAccelSec)", (const char *)&queryFormat, "outAdsInToOutAccelSec") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12677, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *v6 = v12->adsAccelSec[0];
  *v11 = v12->adsAccelSec[1];
  v14 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v14, 0);
  if ( WeaponAdsSettings )
  {
    BG_GetADSTransTimes(weaponMap, ps, r_weapon, isAlternate, (float *)&outAdsOutToInAccelSec, (float *)&outAdsInToOutAccelSec);
    adsTransOutToInTime = WeaponAdsSettings->adsTransOutToInTime;
    v17 = (float)(*(float *)&outAdsOutToInAccelSec + *(float *)&outAdsInToOutAccelSec) * 1000.0;
    if ( adsTransOutToInTime > 0.0 )
      *v6 = v17 / adsTransOutToInTime;
    adsTransInToOutTime = WeaponAdsSettings->adsTransInToOutTime;
    if ( adsTransInToOutTime > 0.0 )
      *v11 = v17 / adsTransInToOutTime;
  }
  AdsSettingsScale = BG_GetAdsSettingsScale(r_weapon, isAlternate, v14, 0);
  *v11 = (float)(AdsSettingsScale * AdsSettingsScale) * *v11;
  *v6 = (float)(AdsSettingsScale * AdsSettingsScale) * *v6;
}

/*
==============
BG_GetADSCrosshairBlendFracs
==============
*/
void BG_GetADSCrosshairBlendFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool adsIn, float *outBlendStart, float *outBlendEnd)
{
  const WeaponDef *v11; 
  float adsInCrosshairAlphaEnd; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v14; 
  const AttADSSettings *WeaponAdsSettings; 
  float adsInCrosshairAlphaStart; 
  float adsOutCrosshairAlphaEnd; 
  float adsOutCrosshairAlphaStart; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12748, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12750, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( r_weapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( r_weapon )") )
    __debugbreak();
  if ( !outBlendStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12751, ASSERT_TYPE_ASSERT, "(outBlendStart)", (const char *)&queryFormat, "outBlendStart") )
    __debugbreak();
  if ( !outBlendEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12752, ASSERT_TYPE_ASSERT, "(outBlendEnd)", (const char *)&queryFormat, "outBlendEnd") )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( adsIn )
  {
    *outBlendStart = v11->adsInCrosshairAlphaStart;
    adsInCrosshairAlphaEnd = v11->adsInCrosshairAlphaEnd;
  }
  else
  {
    *outBlendStart = v11->adsOutCrosshairAlphaStart;
    adsInCrosshairAlphaEnd = v11->adsOutCrosshairAlphaEnd;
  }
  *outBlendEnd = adsInCrosshairAlphaEnd;
  v14 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v14, 0);
  if ( WeaponAdsSettings )
  {
    if ( adsIn )
    {
      adsInCrosshairAlphaStart = WeaponAdsSettings->adsInCrosshairAlphaStart;
      if ( adsInCrosshairAlphaStart >= 0.0 )
        *outBlendStart = adsInCrosshairAlphaStart;
      adsOutCrosshairAlphaEnd = WeaponAdsSettings->adsInCrosshairAlphaEnd;
    }
    else
    {
      adsOutCrosshairAlphaStart = WeaponAdsSettings->adsOutCrosshairAlphaStart;
      if ( adsOutCrosshairAlphaStart >= 0.0 )
        *outBlendStart = adsOutCrosshairAlphaStart;
      adsOutCrosshairAlphaEnd = WeaponAdsSettings->adsOutCrosshairAlphaEnd;
    }
    if ( adsOutCrosshairAlphaEnd >= 0.0 )
      *outBlendEnd = adsOutCrosshairAlphaEnd;
  }
}

/*
==============
BG_GetADSDamageRangeScale
==============
*/
float BG_GetADSDamageRangeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13660, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(v8->adsDamageRangeScale);
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    _XMM6 = LODWORD(WeaponAdsSettings->adsDamageRangeScale);
  __asm
  {
    vcmpeqss xmm2, xmm6, xmm0
    vblendvps xmm0, xmm6, xmm1, xmm2
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSFireRateScale
==============
*/
float BG_GetADSFireRateScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13633, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(v8->adsFireRateScale);
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    _XMM6 = LODWORD(WeaponAdsSettings->adsFireRateScale);
  __asm
  {
    vcmpeqss xmm2, xmm6, xmm0
    vblendvps xmm0, xmm6, xmm1, xmm2
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSGunBobBulletDirScale
==============
*/
float BG_GetADSGunBobBulletDirScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  float fAdsGunBobTiltBulletDirScale; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSGunBobSettings *WeaponAdsGunBobSettings; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v14; 
  __int64 i; 
  const WeaponAttachment *v16; 
  float adsGunBobTiltBulletDirScaleScaleMain; 
  __int128 v18; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13582, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  fAdsGunBobTiltBulletDirScale = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fAdsGunBobTiltBulletDirScale;
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsGunBobSettings = BG_GetWeaponAdsGunBobSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsGunBobSettings )
    fAdsGunBobTiltBulletDirScale = WeaponAdsGunBobSettings->fAdsGunBobTiltBulletDirScale;
  _XMM6 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)6, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v14 = attachments;
    for ( i = WeaponAttachments_Internal; i; --i )
    {
      v16 = *v14;
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13601, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( BG_AttachmentUseMainSettings(v16, isAlternate, v10) )
      {
        if ( !v16->adsGunBobSettingsMain )
        {
          adsGunBobTiltBulletDirScaleScaleMain = v16->adsGunBobTiltBulletDirScaleScaleMain;
          goto LABEL_22;
        }
      }
      else if ( !v16->adsGunBobSettings )
      {
        adsGunBobTiltBulletDirScaleScaleMain = v16->adsGunBobTiltBulletDirScaleScale;
LABEL_22:
        if ( adsGunBobTiltBulletDirScaleScaleMain != 0.0 )
        {
          v18 = _XMM6;
          *(float *)&v18 = (float)(*(float *)&_XMM6 + adsGunBobTiltBulletDirScaleScaleMain) - 1.0;
          _XMM6 = v18;
        }
      }
      ++v14;
    }
  }
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v20 = LODWORD(FLOAT_1_0);
  *(float *)&v20 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v20;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  return fAdsGunBobTiltBulletDirScale * *(float *)&_XMM0;
}

/*
==============
BG_GetADSGunBobSettings
==============
*/
void BG_GetADSGunBobSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *adsGunBobPitchScale, float *adsGunBobYawScale, float *adsGunBobTiltPitchScale, float *adsGunBobTiltYawScale, float *adsGunBobTiltRollScale, float *adsGunBobTiltOffset)
{
  bool v11; 
  const WeaponDef *v14; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v16; 
  const AttADSGunBobSettings *WeaponAdsGunBobSettings; 
  float fAdsGunBobCrouchFactor; 
  EffectiveStance EffectiveStance; 
  bool v20; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v25; 
  __int64 v26; 
  WeaponAttachment *v27; 
  AttADSStanceScales *adsStanceScales; 
  __int128 v29; 
  unsigned int v30; 
  WeaponAttachment **v32; 
  __int64 v33; 
  const WeaponAttachment *v34; 
  __int128 v44; 
  __int128 v45; 
  __int128 v47; 
  float v51; 
  __int128 v53; 
  __int128 v58; 
  float adsGunBobTiltScaleScaleMain; 
  float v64; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v11 = isAlternate;
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13498, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v14 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v16 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *adsGunBobPitchScale = v14->fAdsGunBobPitchScale;
  *adsGunBobYawScale = v14->fAdsGunBobYawScale;
  *adsGunBobTiltPitchScale = v14->fAdsGunBobTiltPitchScale;
  *adsGunBobTiltYawScale = v14->fAdsGunBobTiltYawScale;
  *adsGunBobTiltRollScale = v14->fAdsGunBobTiltRollScale;
  *adsGunBobTiltOffset = v14->fAdsGunBobTiltOffset;
  WeaponAdsGunBobSettings = BG_GetWeaponAdsGunBobSettings(r_weapon, v11, v16, 0);
  if ( WeaponAdsGunBobSettings )
  {
    *adsGunBobPitchScale = WeaponAdsGunBobSettings->fAdsGunBobPitchScale;
    *adsGunBobYawScale = WeaponAdsGunBobSettings->fAdsGunBobYawScale;
    *adsGunBobTiltPitchScale = WeaponAdsGunBobSettings->fAdsGunBobTiltPitchScale;
    *adsGunBobTiltYawScale = WeaponAdsGunBobSettings->fAdsGunBobTiltYawScale;
    *adsGunBobTiltRollScale = WeaponAdsGunBobSettings->fAdsGunBobTiltRollScale;
    *adsGunBobTiltOffset = WeaponAdsGunBobSettings->fAdsGunBobTiltOffset;
  }
  fAdsGunBobCrouchFactor = FLOAT_1_0;
  EffectiveStance = PM_GetEffectiveStance(ps);
  v20 = EffectiveStance == PM_EFF_STANCE_DUCKED;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
    fAdsGunBobCrouchFactor = v14->fAdsGunBobCrouchFactor;
  _XMM10 = LODWORD(FLOAT_1_0);
  _XMM11 = LODWORD(FLOAT_1_0);
  _XMM6 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v11, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v25 = attachments;
    v26 = WeaponAttachments_Internal;
    do
    {
      v27 = *v25;
      if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13545, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v20 )
      {
        adsStanceScales = v27->adsStanceScales;
        if ( adsStanceScales )
        {
          v29 = _XMM6;
          *(float *)&v29 = (float)(*(float *)&_XMM6 + adsStanceScales->adsCrouchGunBobFactorScale) - 1.0;
          _XMM6 = v29;
        }
      }
      ++v25;
      --v26;
    }
    while ( v26 );
    v11 = isAlternate;
  }
  v30 = BG_GetWeaponAttachments_Internal(r_weapon, v11, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)5, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM9 = 0i64;
  if ( v30 )
  {
    v32 = attachments;
    v33 = v30;
    do
    {
      v34 = *v32;
      if ( !*v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13556, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13447, ASSERT_TYPE_ASSERT, "( attachment ) != ( nullptr )", "%s != %s\n\t%p, %p", "attachment", "nullptr", NULL, NULL) )
        __debugbreak();
      v64 = FLOAT_1_0;
      adsGunBobTiltScaleScaleMain = FLOAT_1_0;
      if ( BG_AttachmentUseMainSettings(v34, v11, v16) )
      {
        if ( !v34->adsGunBobSettingsMain )
        {
          _XMM0 = LODWORD(FLOAT_1_0);
          __asm
          {
            vcmpltss xmm1, xmm9, xmm2
            vblendvps xmm1, xmm0, xmm2, xmm1
          }
          v64 = *(float *)&_XMM1;
          if ( v34->adsGunBobTiltScaleScaleMain > 0.0 )
            adsGunBobTiltScaleScaleMain = v34->adsGunBobTiltScaleScaleMain;
        }
      }
      else if ( !v34->adsGunBobSettings )
      {
        _XMM0 = LODWORD(FLOAT_1_0);
        __asm
        {
          vcmpltss xmm1, xmm9, xmm2
          vblendvps xmm1, xmm0, xmm2, xmm1
        }
        _XMM0 = LODWORD(FLOAT_1_0);
        v64 = *(float *)&_XMM1;
        __asm
        {
          vcmpltss xmm1, xmm9, xmm3
          vblendvps xmm1, xmm0, xmm3, xmm1
        }
        adsGunBobTiltScaleScaleMain = *(float *)&_XMM1;
      }
      ++v32;
      v44 = _XMM11;
      *(float *)&v44 = *(float *)&_XMM11 + (float)(adsGunBobTiltScaleScaleMain - 1.0);
      _XMM11 = v44;
      v45 = _XMM10;
      *(float *)&v45 = *(float *)&_XMM10 + (float)(v64 - 1.0);
      _XMM10 = v45;
      --v33;
    }
    while ( v33 );
  }
  __asm { vmaxss  xmm2, xmm6, xmm9 }
  v47 = LODWORD(FLOAT_1_0);
  *(float *)&v47 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v47 + 1) = (v47 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v47 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v47;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm1, xmm2, xmm8, xmm0
  }
  v51 = fAdsGunBobCrouchFactor * *(float *)&_XMM1;
  __asm { vmaxss  xmm3, xmm10, xmm9 }
  v53 = LODWORD(FLOAT_1_0);
  *(float *)&v53 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v53 + 1) = (v53 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v53 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v53;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm5, xmm3, xmm8, xmm2
    vmaxss  xmm3, xmm11, xmm9
  }
  v58 = LODWORD(FLOAT_1_0);
  *(float *)&v58 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v58 + 1) = (v58 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v58 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v58;
  __asm { vcmplesd xmm2, xmm1, xmm6 }
  *adsGunBobPitchScale = (float)(*(float *)&_XMM5 * v51) * *adsGunBobPitchScale;
  __asm { vblendvps xmm4, xmm3, xmm8, xmm2 }
  *adsGunBobYawScale = (float)(*(float *)&_XMM5 * v51) * *adsGunBobYawScale;
  *adsGunBobTiltPitchScale = (float)(*(float *)&_XMM4 * v51) * *adsGunBobTiltPitchScale;
  *adsGunBobTiltYawScale = (float)(*(float *)&_XMM4 * v51) * *adsGunBobTiltYawScale;
  *adsGunBobTiltRollScale = (float)(*(float *)&_XMM4 * v51) * *adsGunBobTiltRollScale;
}

/*
==============
BG_GetADSHandheldCamScale
==============
*/
void BG_GetADSHandheldCamScale(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, bool isAlternate, float *outAdsRotationScale, float *outAdsTranslationScale)
{
  WeaponAttachment *v6; 
  const WeaponDef *v10; 
  __int64 WeaponAttachments_Internal; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  __int64 v13; 
  WeaponAttachment **v14; 
  AttPost *post; 
  float *v16; 
  AttPost *v17; 
  const BgHybridScopeFraction *v18; 
  float *v19; 
  float v20; 
  __int128 v21; 
  __int128 v22; 
  WeaponAttachment **v23; 
  __int64 v24; 
  WeaponAttachment *v25; 
  float v28; 
  float v30; 
  float v31; 
  __int128 v37; 
  __int128 v38; 
  WeaponAttachment *v40; 
  WeaponAttachment *outDataAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = NULL;
  if ( !outAdsRotationScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19951, ASSERT_TYPE_ASSERT, "( outAdsRotationScale ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAdsRotationScale", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAdsTranslationScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19952, ASSERT_TYPE_ASSERT, "( outAdsTranslationScale ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAdsTranslationScale", "nullptr", NULL, NULL) )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19955, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *outAdsRotationScale = v10->adsCameraShakeRotationScale;
  *outAdsTranslationScale = v10->adsCameraShakeTranslationScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  outDataAttachment = NULL;
  v40 = NULL;
  if ( hybridScopeFraction->fraction > 0.0 && BG_CanHybridToggle(ps, weapon, isAlternate) )
  {
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
    v6 = outDataAttachment;
    v40 = (WeaponAttachment *)HybridScopeEnablerAttachment;
  }
  v13 = 0i64;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v14 = attachments;
    while ( 1 )
    {
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19972, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      post = (*v14)->post;
      if ( post )
        break;
      v13 = (unsigned int)(v13 + 1);
      ++v14;
      if ( (unsigned int)v13 >= (unsigned int)WeaponAttachments_Internal )
      {
        v16 = outAdsRotationScale;
        goto LABEL_30;
      }
    }
    if ( hybridScopeFraction->fraction > 0.0 && BG_CanHybridToggle(ps, weapon, isAlternate) )
    {
      if ( v40 )
      {
        if ( v40 == attachments[v13] )
        {
          if ( v6 )
          {
            v17 = v6->post;
            if ( v17 )
            {
              v18 = hybridScopeFraction;
              v16 = outAdsRotationScale;
              v19 = outAdsTranslationScale;
              v20 = sinf_0((float)(hybridScopeFraction->fraction - 0.5) * 3.1415927) * 0.5;
              *outAdsRotationScale = (float)((float)(0.5 - v20) * post->adsCameraShakeRotationScale) + (float)((float)(v20 + 0.5) * v17->adsCameraShakeRotationScale);
              *outAdsTranslationScale = (float)((float)(0.5 - v20) * post->adsCameraShakeTranslationScale) + (float)((float)(v20 + 0.5) * v17->adsCameraShakeTranslationScale);
              goto LABEL_32;
            }
          }
        }
      }
    }
    v16 = outAdsRotationScale;
    v19 = outAdsTranslationScale;
    *outAdsRotationScale = post->adsCameraShakeRotationScale;
    *outAdsTranslationScale = post->adsCameraShakeTranslationScale;
  }
  else
  {
    v16 = outAdsRotationScale;
LABEL_30:
    v19 = outAdsTranslationScale;
  }
  v18 = hybridScopeFraction;
LABEL_32:
  v21 = LODWORD(FLOAT_1_0);
  v22 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v23 = attachments;
    v24 = WeaponAttachments_Internal;
    do
    {
      v25 = *v23;
      if ( !*v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20006, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      *(float *)&_XMM7 = v25->adsCameraShakeRotationScaleScale;
      *(float *)&_XMM6 = v25->adsCameraShakeTranslationScaleScale;
      if ( v40 && v40 == v25 && v6 )
      {
        v28 = sinf_0((float)(v18->fraction - 0.5) * 3.1415927);
        _XMM3 = LODWORD(v6->adsCameraShakeRotationScaleScale);
        v30 = v28 * 0.5;
        v31 = (float)(v28 * 0.5) + 0.5;
        if ( *(float *)&_XMM7 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM3 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm7, xmm3, xmm8, xmm2
          }
        }
        else if ( *(float *)&_XMM3 > 0.0 )
        {
          *(float *)&_XMM7 = (float)((float)(0.5 - v30) * *(float *)&_XMM7) + (float)(*(float *)&_XMM3 * v31);
        }
        _XMM3 = LODWORD(v6->adsCameraShakeTranslationScaleScale);
        if ( *(float *)&_XMM6 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM3 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm6, xmm3, xmm8, xmm2
          }
        }
        else if ( *(float *)&_XMM3 > 0.0 )
        {
          *(float *)&_XMM6 = (float)((float)(0.5 - v30) * *(float *)&_XMM6) + (float)(*(float *)&_XMM3 * v31);
        }
      }
      if ( *(float *)&_XMM7 > 0.0 )
      {
        v37 = v21;
        *(float *)&v37 = *(float *)&v21 * *(float *)&_XMM7;
        v21 = v37;
      }
      if ( *(float *)&_XMM6 > 0.0 )
      {
        v38 = v22;
        *(float *)&v38 = *(float *)&v22 * *(float *)&_XMM6;
        v22 = v38;
      }
      ++v23;
      --v24;
    }
    while ( v24 );
    v19 = outAdsTranslationScale;
    v16 = outAdsRotationScale;
  }
  *v16 = *(float *)&v21 * *v16;
  *v19 = *(float *)&v22 * *v19;
}

/*
==============
BG_GetADSIdleLerpTime
==============
*/
void BG_GetADSIdleLerpTime(const Weapon *r_weapon, bool isAlternate, float *adsIdleLerpStartTime, float *adsIdleLerpTime)
{
  const WeaponDef *v8; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  __int64 v13; 
  float idleADSMotionTimeScale; 
  __int128 v15; 
  __int128 v17; 
  WeaponAttachment **v21; 
  WeaponAttachment *v22; 
  AttIdleSettings *idleSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !adsIdleLerpStartTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12247, ASSERT_TYPE_ASSERT, "(adsIdleLerpStartTime)", (const char *)&queryFormat, "adsIdleLerpStartTime") )
    __debugbreak();
  if ( !adsIdleLerpTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12248, ASSERT_TYPE_ASSERT, "(adsIdleLerpTime)", (const char *)&queryFormat, "adsIdleLerpTime") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *adsIdleLerpStartTime = v8->adsIdleLerpStartTime;
  *adsIdleLerpTime = v8->adsIdleLerpTime;
  _XMM6 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    v13 = WeaponAttachments_Internal;
    do
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12258, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      idleADSMotionTimeScale = (*v12)->idleADSMotionTimeScale;
      if ( idleADSMotionTimeScale >= 0.0 )
      {
        v15 = _XMM6;
        *(float *)&v15 = (float)(*(float *)&_XMM6 + idleADSMotionTimeScale) - 1.0;
        _XMM6 = v15;
      }
      ++v12;
      --v13;
    }
    while ( v13 );
  }
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v17 = LODWORD(FLOAT_1_0);
  *(float *)&v17 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v17 + 1) = (v17 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v17 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v17;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm7, xmm2
  }
  if ( WeaponAttachments_Internal )
  {
    v21 = attachments;
    while ( 1 )
    {
      if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12268, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v22 = *v21;
      idleSettings = (*v21)->idleSettings;
      if ( idleSettings )
        break;
      ++v9;
      ++v21;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    *adsIdleLerpStartTime = idleSettings->adsIdleLerpStartTime;
    *adsIdleLerpTime = v22->idleSettings->adsIdleLerpTime;
  }
LABEL_24:
  *adsIdleLerpStartTime = *(float *)&_XMM6 * *adsIdleLerpStartTime;
  *adsIdleLerpTime = *(float *)&_XMM6 * *adsIdleLerpTime;
}

/*
==============
BG_GetADSNVGFOV
==============
*/
float BG_GetADSNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  const WeaponCompleteDef *v4; 
  float result; 

  v4 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !getWeaponValues )
    return v4->zoomSettings.scene.adsFOVNVG;
  result = v4->zoomSettings.weapon.adsNVGZoomFov;
  if ( result <= 0.0 )
    return v4->zoomSettings.scene.adsFOVNVG;
  return result;
}

/*
==============
BG_GetADSNVGFOVXOffset
==============
*/
float BG_GetADSNVGFOVXOffset(const Weapon *r_weapon, const bool isAlternate)
{
  return BG_WeaponCompleteDef(r_weapon, isAlternate)->zoomSettings.weapon.adsNVGZoomFovXOffset;
}

/*
==============
BG_GetADSReloadNVGFOV
==============
*/
float BG_GetADSReloadNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  const WeaponCompleteDef *v4; 
  float result; 

  v4 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !getWeaponValues )
    return v4->zoomSettings.scene.adsReloadFovNVG;
  result = v4->zoomSettings.weapon.adsNVGReloadZoomFov;
  if ( result <= 0.0 )
    return v4->zoomSettings.scene.adsReloadFovNVG;
  return result;
}

/*
==============
BG_GetADSSwayScalars
==============
*/
void BG_GetADSSwayScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsSwayMaxAngleScale, float *outAdsSwayLerpSpeedScale, float *outAdsSwayScaleScale)
{
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v16; 
  __int64 v17; 
  WeaponAttachment **v18; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  float adsSwayMaxAngleScale; 
  __int128 v21; 
  float adsSwayLerpSpeedScale; 
  __int128 v23; 
  float adsSwayScaleScale; 
  __int128 v25; 
  __int128 v26; 
  __int128 v30; 
  __int128 v34; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _XMM8 = LODWORD(FLOAT_1_0);
  _XMM9 = LODWORD(FLOAT_1_0);
  _XMM7 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v16 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v17 = WeaponAttachments_Internal;
    v18 = attachments;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v18, v16);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19925, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsSwayMaxAngleScale = OverrideAttachmentWhenApplicable->adsSwayMaxAngleScale;
      if ( adsSwayMaxAngleScale > 0.0 )
      {
        v21 = _XMM8;
        *(float *)&v21 = *(float *)&_XMM8 * adsSwayMaxAngleScale;
        _XMM8 = v21;
      }
      adsSwayLerpSpeedScale = OverrideAttachmentWhenApplicable->adsSwayLerpSpeedScale;
      if ( adsSwayLerpSpeedScale > 0.0 )
      {
        v23 = _XMM9;
        *(float *)&v23 = *(float *)&_XMM9 * adsSwayLerpSpeedScale;
        _XMM9 = v23;
      }
      adsSwayScaleScale = OverrideAttachmentWhenApplicable->adsSwayScaleScale;
      if ( adsSwayScaleScale > 0.0 )
      {
        v25 = _XMM7;
        *(float *)&v25 = *(float *)&_XMM7 * adsSwayScaleScale;
        _XMM7 = v25;
      }
      ++v18;
      --v17;
    }
    while ( v17 );
  }
  v26 = LODWORD(FLOAT_1_0);
  *(float *)&v26 = 1.0 - *(float *)&_XMM8;
  *((_QWORD *)&v26 + 1) = (v26 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v26 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM8) & _xmm);
  _XMM1 = v26;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm4
    vblendvps xmm1, xmm8, xmm10, xmm0
  }
  *outAdsSwayMaxAngleScale = *(float *)&_XMM1;
  v30 = LODWORD(FLOAT_1_0);
  *(float *)&v30 = 1.0 - *(float *)&_XMM9;
  *((_QWORD *)&v30 + 1) = (v30 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v30 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM9) & _xmm);
  _XMM1 = v30;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm4
    vblendvps xmm0, xmm9, xmm10, xmm2
  }
  *outAdsSwayLerpSpeedScale = *(float *)&_XMM0;
  v34 = LODWORD(FLOAT_1_0);
  *(float *)&v34 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v34 + 1) = (v34 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v34 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v34;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm4
    vblendvps xmm0, xmm7, xmm10, xmm2
  }
  *outAdsSwayScaleScale = *(float *)&_XMM0;
}

/*
==============
BG_GetADSTransTimes
==============
*/
void BG_GetADSTransTimes(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsTransInSpeedMs, float *outAdsTransOutSpeedMs)
{
  const WeaponDef *v10; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  float AdsSettingsScale; 
  const AttADSSettings *WeaponAdsSettings; 
  float adsTransInTime; 
  float adsTransOutTime; 
  const dvar_t *v17; 

  if ( !outAdsTransInSpeedMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12632, ASSERT_TYPE_ASSERT, "(outAdsTransInSpeedMs)", (const char *)&queryFormat, "outAdsTransInSpeedMs") )
    __debugbreak();
  if ( !outAdsTransOutSpeedMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12633, ASSERT_TYPE_ASSERT, "(outAdsTransOutSpeedMs)", (const char *)&queryFormat, "outAdsTransOutSpeedMs") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12637, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outAdsTransInSpeedMs = v10->adsSpeedMs[0];
  *outAdsTransOutSpeedMs = v10->adsSpeedMs[1];
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  AdsSettingsScale = BG_GetAdsSettingsScale(r_weapon, isAlternate, v12, 0);
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0);
  if ( WeaponAdsSettings )
  {
    adsTransInTime = WeaponAdsSettings->adsTransInTime;
    if ( adsTransInTime > 0.0 )
      *outAdsTransInSpeedMs = 0.001 / adsTransInTime;
    adsTransOutTime = WeaponAdsSettings->adsTransOutTime;
    if ( adsTransOutTime > 0.0 )
      *outAdsTransOutSpeedMs = 0.001 / adsTransOutTime;
  }
  *outAdsTransInSpeedMs = AdsSettingsScale * *outAdsTransInSpeedMs;
  *outAdsTransOutSpeedMs = AdsSettingsScale * *outAdsTransOutSpeedMs;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x2Du) )
  {
    v17 = DCONST_DVARFLT_sprintAdsSpeedScale;
    if ( !DCONST_DVARFLT_sprintAdsSpeedScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sprintAdsSpeedScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    *outAdsTransInSpeedMs = v17->current.value * *outAdsTransInSpeedMs;
  }
}

/*
==============
BG_GetADSViewBobSettingsScale
==============
*/
float BG_GetADSViewBobSettingsScale(const Weapon *r_weapon, bool isAlternate)
{
  __int128 v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v4; 
  __int64 v5; 
  WeaponAttachment *v6; 
  float adsViewBobScaleScale; 
  __int128 v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v11[32]; 

  v2 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v11, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v4 = attachments;
    v5 = WeaponAttachments_Internal;
    do
    {
      v6 = *v4;
      if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsViewBobScaleScale = v6->adsViewBobScaleScale;
      if ( adsViewBobScaleScale > 0.0 )
      {
        v8 = v2;
        *(float *)&v8 = *(float *)&v2 * adsViewBobScaleScale;
        v2 = v8;
      }
      ++v4;
      --v5;
    }
    while ( v5 );
  }
  return *(float *)&v2;
}

/*
==============
BG_GetADSZoomInFracs
==============
*/
void BG_GetADSZoomInFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const bool getWeaponValues, float *adsZoomInFrac, float *adsZoomOutFrac)
{
  const WeaponCompleteDef *v11; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  const AttADSSettings *WeaponAdsSettings; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 

  if ( !adsZoomInFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13298, ASSERT_TYPE_ASSERT, "(adsZoomInFrac)", (const char *)&queryFormat, "adsZoomInFrac") )
    __debugbreak();
  if ( !adsZoomOutFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13299, ASSERT_TYPE_ASSERT, "(adsZoomOutFrac)", (const char *)&queryFormat, "adsZoomOutFrac") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13303, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v11 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  v13 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *adsZoomInFrac = v11->zoomSettings.scene.adsZoomInFrac;
  *adsZoomOutFrac = v11->zoomSettings.scene.adsZoomOutFrac;
  _XMM6 = 0i64;
  if ( getWeaponValues )
  {
    _XMM0 = *(unsigned int *)adsZoomInFrac;
    __asm
    {
      vcmpless xmm1, xmm6, xmm2
      vblendvps xmm1, xmm0, xmm2, xmm1
    }
    *adsZoomInFrac = *(float *)&_XMM1;
    _XMM0 = *(unsigned int *)adsZoomInFrac;
    __asm
    {
      vcmpless xmm1, xmm6, xmm3
      vblendvps xmm1, xmm0, xmm3, xmm1
    }
    *adsZoomInFrac = *(float *)&_XMM1;
  }
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v13, 0);
  if ( WeaponAdsSettings )
  {
    v22 = WeaponAdsSettings->zoomSettings.scene.adsZoomInFrac;
    if ( v22 >= 0.0 )
      *adsZoomInFrac = v22;
    v23 = WeaponAdsSettings->zoomSettings.scene.adsZoomOutFrac;
    if ( v23 >= 0.0 )
      *adsZoomOutFrac = v23;
    if ( getWeaponValues )
    {
      v24 = WeaponAdsSettings->zoomSettings.weapon.adsZoomInFrac;
      if ( v24 >= 0.0 )
        *adsZoomInFrac = v24;
      v25 = WeaponAdsSettings->zoomSettings.weapon.adsZoomOutFrac;
      if ( v25 >= 0.0 )
        *adsZoomOutFrac = v25;
    }
  }
}

/*
==============
BG_GetADSZoomInfo
==============
*/
void BG_GetADSZoomInfo(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  const WeaponCompleteDef *v9; 

  v9 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  outZoomInfo->zoomCount = v9->zoomSettings.scene.adsZoomCount;
  *(double *)outZoomInfo->zoomFov = *(double *)v9->zoomSettings.scene.adsZoomFov;
  outZoomInfo->zoomFov[2] = v9->zoomSettings.scene.adsZoomFov[2];
  *(double *)outZoomInfo->zoomFovTransitionTime = *(double *)v9->zoomSettings.scene.adsZoomFovTransitionTime;
  outZoomInfo->zoomFovTransitionTime[2] = v9->zoomSettings.scene.adsZoomFovTransitionTime[2];
  outZoomInfo->zoomFovXOffset = v9->zoomSettings.weapon.adsZoomFovXOffset;
  *(double *)outZoomInfo->zoomReloadFov = *(double *)v9->zoomSettings.scene.adsReloadFov;
  outZoomInfo->zoomReloadFov[2] = v9->zoomSettings.scene.adsReloadFov[2];
  outZoomInfo->depthHackZoomFov = v9->zoomSettings.weapon.adsZoomFov;
  outZoomInfo->depthHackReloadFov = v9->zoomSettings.weapon.adsReloadZoomFov;
  outZoomInfo->zoomLerpType = v9->zoomSettings.scene.adsZoomFovLerpType;
  outZoomInfo->depthHackZoomLerpType = v9->zoomSettings.weapon.adsZoomFovLerpType;
  BG_GetADSZoomInfo_ApplyAttachmentOverrides(weaponMap, r_weapon, isAlternate, hybridScopeFractionInfo, outZoomInfo);
  if ( outZoomInfo->zoomCount <= 1 )
  {
LABEL_4:
    if ( outZoomInfo->depthHackZoomFov <= 0.0 )
      return;
    goto LABEL_5;
  }
  if ( outZoomInfo->depthHackZoomFov <= 0.0 )
  {
    outZoomInfo->depthHackZoomFov = outZoomInfo->zoomFov[0];
    goto LABEL_4;
  }
LABEL_5:
  if ( outZoomInfo->depthHackReloadFov <= 0.0 )
    outZoomInfo->depthHackReloadFov = outZoomInfo->zoomReloadFov[0];
}

/*
==============
BG_GetADSZoomInfo_ApplyAttachmentOverrides
==============
*/
void BG_GetADSZoomInfo_ApplyAttachmentOverrides(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  const AttADSSettings *WeaponAdsSettings; 
  const AttADSSettings *v9; 
  const AttADSSettings *v10; 
  float fraction; 
  double v13; 
  float v14; 
  double v15; 
  float v16; 
  float zoomFovXOffset; 
  float adsZoomFovXOffset; 
  float v31; 
  float v32; 
  float v33; 
  float adsZoomFov; 
  float adsReloadZoomFov; 
  int adsZoomCount; 
  int v37; 
  float *zoomFov; 
  signed __int64 v39; 
  float v40; 
  int v41; 
  float v42; 
  BgHybridScopeInfo outHybridScopeInfo; 

  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( WeaponAdsSettings )
  {
    v9 = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 1, 0);
    v10 = v9;
    if ( !v9 || v9 == WeaponAdsSettings )
    {
      adsZoomFov = WeaponAdsSettings->zoomSettings.weapon.adsZoomFov;
      if ( adsZoomFov > 0.0 )
        outZoomInfo->depthHackZoomFov = adsZoomFov;
      adsReloadZoomFov = WeaponAdsSettings->zoomSettings.weapon.adsReloadZoomFov;
      if ( adsReloadZoomFov > 0.0 )
        outZoomInfo->depthHackReloadFov = adsReloadZoomFov;
      adsZoomCount = WeaponAdsSettings->zoomSettings.scene.adsZoomCount;
      v37 = 0;
      if ( adsZoomCount > 0 )
      {
        zoomFov = outZoomInfo->zoomFov;
        v39 = (char *)WeaponAdsSettings - (char *)outZoomInfo;
        do
        {
          v40 = *(float *)((char *)zoomFov + v39 + 40);
          if ( v40 >= 0.0 )
            *zoomFov = v40;
          v41 = *(_DWORD *)((char *)zoomFov + v39 + 64);
          if ( (float)v41 >= 0.0 )
            *((_DWORD *)zoomFov + 3) = v41;
          if ( WeaponAdsSettings->zoomSettings.weapon.adsZoomFovXOffsetOverride )
            outZoomInfo->zoomFovXOffset = WeaponAdsSettings->zoomSettings.weapon.adsZoomFovXOffset;
          v42 = *(float *)((char *)zoomFov + v39 + 52);
          if ( v42 >= 0.0 )
            zoomFov[7] = v42;
          adsZoomCount = WeaponAdsSettings->zoomSettings.scene.adsZoomCount;
          ++v37;
          ++zoomFov;
        }
        while ( v37 < adsZoomCount );
      }
      outZoomInfo->zoomCount = adsZoomCount;
      outZoomInfo->zoomLerpType = WeaponAdsSettings->zoomSettings.scene.adsZoomFovLerpType;
      outZoomInfo->depthHackZoomLerpType = WeaponAdsSettings->zoomSettings.weapon.adsZoomFovLerpType;
    }
    else
    {
      BG_GetHybridScopeInfo(r_weapon, isAlternate, &outHybridScopeInfo);
      if ( !outHybridScopeInfo.hasHybridScope && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13108, ASSERT_TYPE_ASSERT, "(hybridScopeInfo.hasHybridScope)", (const char *)&queryFormat, "hybridScopeInfo.hasHybridScope") )
        __debugbreak();
      fraction = hybridScopeFractionInfo->fraction;
      _XMM7 = 0i64;
      if ( hybridScopeFractionInfo->increasing )
      {
        v13 = I_fclamp((float)(fraction - outHybridScopeInfo.hybridScope1To2FovTransBegin) / (float)(outHybridScopeInfo.hybridScope1To2FovTransEnd - outHybridScopeInfo.hybridScope1To2FovTransBegin), 0.0, 1.0);
        v14 = (float)(sinf_0((float)(*(float *)&v13 - 0.5) * 3.1415927) + 1.0) * 0.5;
      }
      else
      {
        v15 = I_fclamp((float)((float)(1.0 - fraction) - outHybridScopeInfo.hybridScope2To1FovTransBegin) / (float)(outHybridScopeInfo.hybridScope2To1FovTransEnd - outHybridScopeInfo.hybridScope2To1FovTransBegin), 0.0, 1.0);
        v14 = 0.5 - (float)(sinf_0((float)(*(float *)&v15 - 0.5) * 3.1415927) * 0.5);
      }
      v16 = 1.0 - v14;
      outZoomInfo->zoomCount = 1;
      _XMM6 = LODWORD(outZoomInfo->zoomFov[0]);
      outZoomInfo->zoomFovTransitionTime[0] = 0;
      _XMM9 = LODWORD(outZoomInfo->depthHackZoomFov);
      zoomFovXOffset = outZoomInfo->zoomFovXOffset;
      __asm
      {
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm3, xmm6, xmm1, xmm0
        vcmpltss xmm0, xmm7, xmm2
        vblendvps xmm1, xmm6, xmm2, xmm0
      }
      outZoomInfo->zoomFov[0] = (float)((float)(1.0 - v14) * *(float *)&_XMM1) + (float)(*(float *)&_XMM3 * v14);
      __asm
      {
        vcmpltss xmm0, xmm7, xmm2
        vblendvps xmm3, xmm9, xmm2, xmm0
      }
      if ( *(float *)&_XMM3 <= 0.0 )
      {
        __asm
        {
          vcmpltss xmm0, xmm7, xmm1
          vblendvps xmm3, xmm6, xmm1, xmm0
        }
      }
      __asm
      {
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm2, xmm9, xmm1, xmm0
      }
      if ( *(float *)&_XMM2 <= 0.0 )
      {
        __asm
        {
          vcmpltss xmm0, xmm7, xmm1
          vblendvps xmm2, xmm6, xmm1, xmm0
        }
      }
      outZoomInfo->depthHackZoomFov = (float)(v16 * *(float *)&_XMM3) + (float)(*(float *)&_XMM2 * v14);
      if ( WeaponAdsSettings->zoomSettings.weapon.adsZoomFovXOffsetOverride )
        adsZoomFovXOffset = WeaponAdsSettings->zoomSettings.weapon.adsZoomFovXOffset;
      else
        adsZoomFovXOffset = zoomFovXOffset;
      if ( v10->zoomSettings.weapon.adsZoomFovXOffsetOverride )
        zoomFovXOffset = v10->zoomSettings.weapon.adsZoomFovXOffset;
      outZoomInfo->zoomFovXOffset = (float)(v16 * adsZoomFovXOffset) + (float)(zoomFovXOffset * v14);
      if ( hybridScopeFractionInfo->increasing )
      {
        outZoomInfo->zoomLerpType = v10->zoomSettings.scene.adsZoomFovLerpType;
        outZoomInfo->depthHackZoomLerpType = v10->zoomSettings.weapon.adsZoomFovLerpType;
        v31 = v10->zoomSettings.weapon.adsReloadZoomFov;
        if ( v31 > 0.0 )
          outZoomInfo->depthHackReloadFov = v31;
        v32 = v10->zoomSettings.scene.adsReloadFov[0];
      }
      else
      {
        outZoomInfo->zoomLerpType = WeaponAdsSettings->zoomSettings.scene.adsZoomFovLerpType;
        outZoomInfo->depthHackZoomLerpType = WeaponAdsSettings->zoomSettings.weapon.adsZoomFovLerpType;
        v33 = WeaponAdsSettings->zoomSettings.weapon.adsReloadZoomFov;
        if ( v33 > 0.0 )
          outZoomInfo->depthHackReloadFov = v33;
        v32 = WeaponAdsSettings->zoomSettings.scene.adsReloadFov[0];
      }
      if ( v32 > 0.0 )
        outZoomInfo->zoomReloadFov[0] = v32;
    }
  }
}

/*
==============
BG_GetADSZoomLevel
==============
*/
__int64 BG_GetADSZoomLevel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const int zoomCount)
{
  bool v8; 
  bool CanHybridToggle; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  __int64 result; 
  int zoomLevelIndex; 

  v8 = BG_UsingAlternate(ps);
  CanHybridToggle = BG_CanHybridToggle(ps, r_weapon, v8);
  if ( !ps || CanHybridToggle || zoomCount <= 0 )
    return 0i64;
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
  if ( !EquippedWeaponStateConst )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12856, ASSERT_TYPE_ASSERT, "(equippedData != nullptr)", (const char *)&queryFormat, "equippedData != nullptr") )
      __debugbreak();
    return 0i64;
  }
  zoomLevelIndex = EquippedWeaponStateConst->zoomLevelIndex;
  result = 0i64;
  if ( zoomLevelIndex < zoomCount )
    return (unsigned int)zoomLevelIndex;
  return result;
}

/*
==============
BG_GetADSZoomLevelFraction
==============
*/
float BG_GetADSZoomLevelFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const int gameTime)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  __int64 zoomLevelIndex; 
  float v12; 
  int v13; 
  double v14; 
  __int128 v15; 
  float v16; 
  float v17; 
  __int128 v19; 
  float v21; 
  __int64 v23; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12880, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_ADSZoomCount(weaponMap, ps, weapon, isAlternate) > 1 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL )
  {
    memset(&outZoomInfo, 0, sizeof(outZoomInfo));
    hybridScopeFractionInfo = 0i64;
    BG_GetADSZoomInfo(weaponMap, weapon, isAlternate, &hybridScopeFractionInfo, &outZoomInfo);
    if ( EquippedWeaponStateConst->zoomLevelIndex >= 3u )
    {
      LODWORD(v23) = EquippedWeaponStateConst->zoomLevelIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12900, ASSERT_TYPE_ASSERT, "(unsigned)( equippedWeaponState->zoomLevelIndex ) < (unsigned)( 3 )", "equippedWeaponState->zoomLevelIndex doesn't index WEAPON_VZSCOPE_MAXFOVS\n\t%i not in [0, %i)", v23, 3) )
        __debugbreak();
    }
    zoomLevelIndex = EquippedWeaponStateConst->zoomLevelIndex;
    v12 = (float)(int)zoomLevelIndex;
    v13 = outZoomInfo.zoomFovTransitionTime[zoomLevelIndex];
    if ( v13 > 0 )
    {
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1184, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(ps->weapCommon.adsZoomLevelFractionOnStateChange, 3.0, 8u);
      v15 = _XMM0;
      *(double *)&_XMM0 = I_fclamp((float)(gameTime - ps->weapCommon.adsZoomLevelChangeTime) / (float)v13, 0.0, 1.0);
      if ( v12 <= *(float *)&v15 )
      {
        v17 = *(float *)&v15 - v12;
        v16 = 3.0 - (float)(*(float *)&v15 - v12);
      }
      else
      {
        v16 = v12 - *(float *)&v15;
        v17 = 3.0 - (float)(v12 - *(float *)&v15);
      }
      if ( v17 >= v16 )
      {
        v21 = (float)(v16 * *(float *)&_XMM0) + *(float *)&v15;
        *(float *)&_XMM0 = v21;
        if ( v21 > 3.0 )
          *(float *)&_XMM0 = v21 + -3.0;
      }
      else
      {
        v19 = v15;
        *(float *)&v19 = *(float *)&v15 - (float)(v17 * *(float *)&_XMM0);
        _XMM2 = v19;
        __asm
        {
          vcmpltss xmm0, xmm2, xmm9
          vblendvps xmm0, xmm2, xmm1, xmm0
        }
      }
      v14 = I_fclamp(*(float *)&_XMM0, 0.0, 3.0);
    }
    else
    {
      *(float *)&v14 = (float)(int)zoomLevelIndex;
    }
  }
  else
  {
    LODWORD(v14) = 0;
  }
  return *(float *)&v14;
}

/*
==============
BG_GetADSZoomLevelWeights
==============
*/
void BG_GetADSZoomLevelWeights(const float adsZoomLevelFraction, float *outZoomLevelWeights)
{
  int v3; 
  int v4; 
  float v5; 
  float v6; 
  float v7; 

  if ( !outZoomLevelWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12964, ASSERT_TYPE_ASSERT, "(outZoomLevelWeights)", (const char *)&queryFormat, "outZoomLevelWeights") )
    __debugbreak();
  v3 = 0;
  *(_QWORD *)outZoomLevelWeights = 0i64;
  outZoomLevelWeights[2] = 0.0;
  while ( 1 )
  {
    v4 = v3 + 1;
    v5 = (float)(v3 + 1);
    if ( adsZoomLevelFraction <= v5 )
      break;
    ++v3;
    if ( v4 >= 3 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13000, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_GetADSZoomLevelWeights should have never reached here. adsZoomLevelFraction: %f", adsZoomLevelFraction) )
        __debugbreak();
      return;
    }
  }
  if ( v3 == 2 )
  {
    v6 = v5 - adsZoomLevelFraction;
    v7 = 1.0 - (float)(v5 - adsZoomLevelFraction);
    v4 = 0;
  }
  else
  {
    v7 = adsZoomLevelFraction - (float)v3;
    v6 = 1.0 - v7;
  }
  outZoomLevelWeights[v3] = v6;
  outZoomLevelWeights[v4] = v7;
}

/*
==============
BG_GetAdsAlign
==============
*/
_BOOL8 BG_GetAdsAlign(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, vec3_t *outAdsAlignOffset, AdsOffsetInterpolationType *outOffsetLerpType, AdsOffsetInterpolationType *outAlignmentLerpType, bool *outDisableTagAlignX)
{
  const AttADSSettings *v12; 
  const AttADSSettings *WeaponAdsSettings; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  bool adsAlignEnabled; 
  AdsOffsetInterpolationType adsAlignLerpType; 
  const WeaponDef *v21; 
  _BOOL8 result; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19500, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19501, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v12 = NULL;
  if ( !outOffsetLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19502, ASSERT_TYPE_ASSERT, "( outOffsetLerpType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outOffsetLerpType", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAlignmentLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19503, ASSERT_TYPE_ASSERT, "( outAlignmentLerpType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAlignmentLerpType", "nullptr", NULL, NULL) )
    __debugbreak();
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( WeaponAdsSettings )
  {
    if ( hybridScopeFractionInfo->fraction > 0.0 )
      v12 = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 1, 0);
    if ( v12 )
    {
      v14 = sinf_0((float)(hybridScopeFractionInfo->fraction - 0.5) * 3.1415927);
      v15 = WeaponAdsSettings->adsAlignOffset.v[2];
      v16 = (float)(v14 + 1.0) * 0.5;
      v17 = (float)((float)(v12->adsAlignOffset.v[0] - WeaponAdsSettings->adsAlignOffset.v[0]) * v16) + WeaponAdsSettings->adsAlignOffset.v[0];
      v18 = (float)(v12->adsAlignOffset.v[2] - v15) * v16;
      outAdsAlignOffset->v[1] = (float)((float)(v12->adsAlignOffset.v[1] - WeaponAdsSettings->adsAlignOffset.v[1]) * v16) + WeaponAdsSettings->adsAlignOffset.v[1];
      outAdsAlignOffset->v[2] = v18 + v15;
      outAdsAlignOffset->v[0] = v17;
      if ( !hybridScopeFractionInfo->increasing )
      {
        adsAlignEnabled = v12->adsAlignEnabled;
        *outDisableTagAlignX = v12->disableTagAlignX;
        *outOffsetLerpType = v12->adsAlignOffsetLerpType;
        adsAlignLerpType = v12->adsAlignLerpType;
        goto LABEL_25;
      }
    }
    else
    {
      *outAdsAlignOffset = WeaponAdsSettings->adsAlignOffset;
    }
    adsAlignEnabled = WeaponAdsSettings->adsAlignEnabled;
    *outDisableTagAlignX = WeaponAdsSettings->disableTagAlignX;
    *outOffsetLerpType = WeaponAdsSettings->adsAlignOffsetLerpType;
    adsAlignLerpType = WeaponAdsSettings->adsAlignLerpType;
    goto LABEL_25;
  }
  v21 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19555, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  *outAdsAlignOffset = v21->adsAlignOffset;
  adsAlignEnabled = v21->adsAlignEnabled;
  *outDisableTagAlignX = v21->disableTagAlignX;
  *outOffsetLerpType = v21->adsAlignOffsetLerpType;
  adsAlignLerpType = v21->adsAlignLerpType;
LABEL_25:
  *outAlignmentLerpType = adsAlignLerpType;
  result = adsAlignEnabled;
  outAdsAlignOffset->v[1] = COERCE_FLOAT(LODWORD(outAdsAlignOffset->v[1]) ^ _xmm);
  return result;
}

/*
==============
BG_GetAdsDownAnim
==============
*/
__int64 BG_GetAdsDownAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17839, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17840, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_DOWN_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 407i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 408i64;
  if ( v4 )
    return 407i64;
  return result;
}

/*
==============
BG_GetAdsFireAnim
==============
*/
__int64 BG_GetAdsFireAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17908, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17909, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_FIRE_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 346i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 347i64;
  if ( v4 )
    return 346i64;
  return result;
}

/*
==============
BG_GetAdsLastShotAnim
==============
*/
__int64 BG_GetAdsLastShotAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17926, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17927, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_LASTSHOT_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 348i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 349i64;
  if ( v4 )
    return 348i64;
  return result;
}

/*
==============
BG_GetAdsSettingsScale
==============
*/
float BG_GetAdsSettingsScale(const Weapon *r_weapon, bool isAlternate, const bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v9; 
  __int64 v10; 
  const WeaponAttachment *v11; 
  float adsSettingsScale; 
  __int128 v13; 
  __int128 v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v21[32]; 

  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v21, (const UnderbarrelMainModeFieldType)2, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v9 = (const WeaponAttachment **)attachments;
    v10 = WeaponAttachments_Internal;
    while ( 1 )
    {
      v11 = *v9;
      if ( !*v9 || ignoreSpreadFromScopes && v11->type == ATTACHMENT_SCOPE )
        goto LABEL_12;
      if ( BG_AttachmentUseMainSettings(*v9, isAlternate, isUsingHybridScope) )
        break;
      adsSettingsScale = v11->adsSettingsScale;
      if ( adsSettingsScale <= 0.0 )
        goto LABEL_10;
LABEL_11:
      v13 = _XMM8;
      *(float *)&v13 = (float)(*(float *)&_XMM8 + adsSettingsScale) - 1.0;
      _XMM8 = v13;
LABEL_12:
      ++v9;
      if ( !--v10 )
        goto LABEL_13;
    }
    adsSettingsScale = v11->adsSettingsScaleMain;
    if ( adsSettingsScale > 0.0 )
      goto LABEL_11;
LABEL_10:
    adsSettingsScale = FLOAT_1_0;
    goto LABEL_11;
  }
LABEL_13:
  __asm { vmaxss  xmm3, xmm8, xmm7 }
  v15 = LODWORD(FLOAT_1_0);
  *(float *)&v15 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v15 + 1) = (v15 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v15 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v15;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetAdsSettleAnim
==============
*/
__int64 BG_GetAdsSettleAnim(const playerState_s *ps, const PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  bool v6; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17871, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17872, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  v6 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SETTLE_ADS, hand, pmoveHandler) != 0;
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG, hand, pmoveHandler) && BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
    return 165i64;
  else
    return v6 ? 0xA4 : 0;
}

/*
==============
BG_GetAdsUpAnim
==============
*/
__int64 BG_GetAdsUpAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17807, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17808, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_UP_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 405i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 406i64;
  if ( v4 )
    return 405i64;
  return result;
}

/*
==============
BG_GetAdsVisionSetInfo
==============
*/
BgAdsVisionSetInfo *BG_GetAdsVisionSetInfo(BgAdsVisionSetInfo *result, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, bool isAlternate)
{
  bool v9; 
  const WeaponDef *v10; 
  const char *visionSetName; 
  int visionSetBlendInTimeMs; 
  bool v13; 
  int v14; 
  unsigned int WeaponAttachments_Internal; 
  const playerState_s *v16; 
  unsigned int v17; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v19; 
  unsigned int v20; 
  WeaponAttachment **v21; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttADSOverlay *adsOverlay; 
  const char *v24; 
  bool v25; 
  bool v26; 
  const dvar_t *v27; 
  const dvar_t *v28; 
  const dvar_t *v29; 
  const dvar_t *v30; 
  WeaponAttachment **i; 
  const WeaponAttachment *v32; 
  AttADSOverlay *v33; 
  bool v34; 
  bool v35; 
  const char *v36; 
  bool v37; 
  const dvar_t *v38; 
  const dvar_t *v39; 
  const dvar_t *v40; 
  bool v42; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  result->visionSetName = NULL;
  *(_QWORD *)&result->visionSetADSFraction = 0i64;
  *(_QWORD *)&result->visionSetBlendOutTimeMs = 0i64;
  v9 = isAlternate && BG_HasUnderbarrelAmmo(weapon);
  v42 = v9;
  v10 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( v10->overlay.applyVisionSet )
  {
    visionSetName = v10->overlay.visionSetName;
    result->visionSetADSFraction = v10->overlay.visionSetADSFraction;
    visionSetBlendInTimeMs = v10->overlay.visionSetBlendInTimeMs;
    result->visionSetBlendOutTimeMs = v10->overlay.visionSetBlendOutTimeMs;
    result->visionSetName = visionSetName;
    result->visionSetBlendInTimeMs = visionSetBlendInTimeMs;
    v13 = visionSetName && *visionSetName;
    result->applyVisionSet = v13;
  }
  v14 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, v9, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v16 = ps;
  v17 = WeaponAttachments_Internal;
  v19 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon), v16 = ps, EquippedWeaponStateConst) && EquippedWeaponStateConst->hybridScope;
  v20 = 0;
  if ( v17 )
  {
    v21 = attachments;
    while ( 1 )
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v16, weapon, v9, *v21, v19);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15411, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsOverlay = OverrideAttachmentWhenApplicable->adsOverlay;
      if ( adsOverlay )
        break;
      v9 = v42;
      ++v20;
      v16 = ps;
      ++v21;
      if ( v20 >= v17 )
        goto LABEL_47;
    }
    v24 = adsOverlay->overlay.visionSetName;
    result->visionSetADSFraction = adsOverlay->overlay.visionSetADSFraction;
    result->visionSetBlendInTimeMs = adsOverlay->overlay.visionSetBlendInTimeMs;
    result->visionSetBlendOutTimeMs = adsOverlay->overlay.visionSetBlendOutTimeMs;
    result->visionSetName = v24;
    v25 = adsOverlay->overlay.applyVisionSet && v24 && *v24;
    result->applyVisionSet = v25;
    v26 = adsOverlay->thermalScope && OverrideAttachmentWhenApplicable->sight;
    v27 = DVARBOOL_bg_scopedNVGSyncAdsFraction;
    if ( !DVARBOOL_bg_scopedNVGSyncAdsFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopedNVGSyncAdsFraction") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v27);
    if ( v27->current.enabled && v26 )
      result->visionSetADSFraction = OverrideAttachmentWhenApplicable->sight->adsSmoothFadeInBegin;
    v28 = DCONST_DVARFLT_bg_visionsetADSFraction;
    if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v28);
    if ( v28->current.value > 0.0 )
    {
      v29 = DCONST_DVARFLT_bg_visionsetADSFraction;
      if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v29);
      LODWORD(result->visionSetADSFraction) = v29->current.integer;
    }
LABEL_47:
    v9 = v42;
  }
  if ( v19 )
  {
    v30 = DVARBOOL_bg_hybridScopeCheckAllAttachmentsForVisionSet;
    if ( !DVARBOOL_bg_hybridScopeCheckAllAttachmentsForVisionSet && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_hybridScopeCheckAllAttachmentsForVisionSet") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v30);
    if ( v30->current.enabled && !result->visionSetName && v17 )
    {
      for ( i = attachments; ; ++i )
      {
        v32 = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, v9, *i, 0);
        if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15449, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        v33 = v32->adsOverlay;
        v34 = v33 && v33->thermalScope && v32->sight;
        if ( v33 && v34 )
          break;
        if ( ++v14 >= v17 )
          return result;
      }
      v35 = !v33->overlay.applyVisionSet;
      v36 = v33->overlay.visionSetName;
      result->visionSetADSFraction = v33->overlay.visionSetADSFraction;
      result->visionSetBlendInTimeMs = v33->overlay.visionSetBlendInTimeMs;
      result->visionSetBlendOutTimeMs = v33->overlay.visionSetBlendOutTimeMs;
      result->visionSetName = v36;
      v37 = !v35 && v36 && *v36;
      v38 = DVARBOOL_bg_scopedNVGSyncAdsFraction;
      result->applyVisionSet = v37;
      if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopedNVGSyncAdsFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v38);
      if ( v38->current.enabled )
        result->visionSetADSFraction = v32->sight->adsSmoothFadeInBegin;
      v39 = DCONST_DVARFLT_bg_visionsetADSFraction;
      if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v39);
      if ( v39->current.value > 0.0 )
      {
        v40 = DCONST_DVARFLT_bg_visionsetADSFraction;
        if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v40);
        LODWORD(result->visionSetADSFraction) = v40->current.integer;
      }
    }
  }
  return result;
}

/*
==============
BG_GetAdvancedIdleSettings
==============
*/
void BG_GetAdvancedIdleSettings(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, AdvancedIdleSettings *outAdvancedIdleSettings)
{
  const WeaponDef *v7; 
  unsigned int WeaponAttachments_Internal; 
  char v9; 
  WeaponAttachment **v14; 
  __int64 v15; 
  WeaponAttachment *v16; 
  float idleHipMotionScale; 
  __int128 v18; 
  float idleADSMotionScale; 
  __int128 idleADSMotionScale_low; 
  float idleADSMotionTimeScale; 
  __int128 v22; 
  AttIdleSettings *idleSettings; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v25; 
  const dvar_t *v26; 
  __int128 v28; 
  __int128 v33; 
  __int128 v37; 
  __int128 v42; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  bitarray<64> v50; 

  v50 = perks;
  if ( !outAdvancedIdleSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12022, ASSERT_TYPE_ASSERT, "(outAdvancedIdleSettings)", (const char *)&queryFormat, "outAdvancedIdleSettings") )
    __debugbreak();
  memset_0(outAdvancedIdleSettings, 0, sizeof(AdvancedIdleSettings));
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12029, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *(__m256i *)&outAdvancedIdleSettings->useAdvancedIdleSettings = *(__m256i *)&v7->advancedIdleSettings.useAdvancedIdleSettings;
  *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting1_HipWeaponRotationOffset = *(__m256i *)&v7->advancedIdleSettings.idleSwaySetting1_HipWeaponRotationOffset;
  *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeF = *(__m256i *)&v7->advancedIdleSettings.idleSwaySetting1_AdsWeaponMagnitudeF;
  *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeZ = *(__m256i *)&v7->advancedIdleSettings.idleSwaySetting2_HipWeaponMagnitudeZ;
  *(_OWORD *)&outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeY = *(_OWORD *)&v7->advancedIdleSettings.idleSwaySetting2_AdsWeaponMagnitudeY;
  *(double *)&outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeX = *(double *)&v7->advancedIdleSettings.idleSwaySetting2_AdsViewMagnitudeX;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_ORDER_STOCK_PRIORITIZED);
  v9 = 0;
  _XMM6 = LODWORD(FLOAT_1_0);
  _XMM11 = LODWORD(FLOAT_1_0);
  _XMM12 = LODWORD(FLOAT_1_0);
  _XMM10 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v14 = attachments;
    v15 = WeaponAttachments_Internal;
    do
    {
      v16 = *v14;
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12046, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      idleHipMotionScale = v16->idleHipMotionScale;
      if ( idleHipMotionScale >= 0.0 )
      {
        v18 = _XMM6;
        *(float *)&v18 = (float)(*(float *)&_XMM6 + idleHipMotionScale) - 1.0;
        _XMM6 = v18;
      }
      idleADSMotionScale = v16->idleADSMotionScale;
      if ( idleADSMotionScale >= 0.0 )
      {
        idleADSMotionScale_low = LODWORD(v16->idleADSMotionScale);
        *(float *)&idleADSMotionScale_low = (float)(idleADSMotionScale + *(float *)&_XMM11) - 1.0;
        _XMM11 = idleADSMotionScale_low;
      }
      idleADSMotionTimeScale = v16->idleADSMotionTimeScale;
      if ( idleADSMotionTimeScale >= 0.0 )
      {
        v22 = _XMM10;
        *(float *)&v22 = (float)(*(float *)&_XMM10 + idleADSMotionTimeScale) - 1.0;
        _XMM10 = v22;
      }
      if ( !v9 )
      {
        idleSettings = v16->idleSettings;
        if ( idleSettings )
        {
          *(__m256i *)&outAdvancedIdleSettings->useAdvancedIdleSettings = *(__m256i *)&idleSettings->advancedIdleSettings.useAdvancedIdleSettings;
          *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting1_HipWeaponRotationOffset = *(__m256i *)&idleSettings->advancedIdleSettings.idleSwaySetting1_HipWeaponRotationOffset;
          *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeF = *(__m256i *)&idleSettings->advancedIdleSettings.idleSwaySetting1_AdsWeaponMagnitudeF;
          *(__m256i *)&outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeZ = *(__m256i *)&idleSettings->advancedIdleSettings.idleSwaySetting2_HipWeaponMagnitudeZ;
          *(_OWORD *)&outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeY = *(_OWORD *)&idleSettings->advancedIdleSettings.idleSwaySetting2_AdsWeaponMagnitudeY;
          *(double *)&outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeX = *(double *)&idleSettings->advancedIdleSettings.idleSwaySetting2_AdsViewMagnitudeX;
          v9 = 1;
        }
      }
      ++v14;
      --v15;
    }
    while ( v15 );
  }
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x1Au);
  v25 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(attachmentSlots) = 64;
      LODWORD(numAttachmentSlots) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v25 & 0x1F)) & v50.array[v25 >> 5]) != 0 )
    {
      v26 = DCONST_DVARFLT_perk_reducedSwayScale;
      if ( !DCONST_DVARFLT_perk_reducedSwayScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_reducedSwayScale") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v26);
      _XMM12 = v26->current.unsignedInt;
    }
  }
  __asm { vmaxss  xmm2, xmm6, xmm9 }
  v28 = LODWORD(FLOAT_1_0);
  *(float *)&v28 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v28 + 1) = (v28 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v28 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v28;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm7, xmm2, xmm8, xmm0
    vmaxss  xmm3, xmm11, xmm9
  }
  v33 = LODWORD(FLOAT_1_0);
  *(float *)&v33 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v33 + 1) = (v33 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v33 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v33;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm4, xmm3, xmm8, xmm2
  }
  v37 = LODWORD(FLOAT_1_0);
  *(float *)&v37 = 1.0 - *(float *)&_XMM12;
  *((_QWORD *)&v37 + 1) = (v37 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v37 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM12) & _xmm);
  _XMM1 = v37;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm12, xmm8, xmm2
  }
  *(float *)&_XMM4 = *(float *)&_XMM0 * *(float *)&_XMM4;
  __asm { vmaxss  xmm3, xmm10, xmm9 }
  v42 = LODWORD(FLOAT_1_0);
  *(float *)&v42 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v42 + 1) = (v42 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v42 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v42;
  outAdvancedIdleSettings->idleSwaySetting1_HipIdleSpeed = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipIdleSpeed;
  outAdvancedIdleSettings->idleSwaySetting1_HipViewMagnitudeX = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipViewMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting1_HipViewMagnitudeY = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipViewMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeX = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeY = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeZ = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting1_HipWeaponMagnitudeZ;
  outAdvancedIdleSettings->idleSwaySetting2_HipIdleSpeed = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipIdleSpeed;
  outAdvancedIdleSettings->idleSwaySetting2_HipViewMagnitudeX = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipViewMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting2_HipViewMagnitudeY = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipViewMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeX = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeY = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeZ = *(float *)&_XMM7 * outAdvancedIdleSettings->idleSwaySetting2_HipWeaponMagnitudeZ;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm1, xmm3, xmm8, xmm2
  }
  outAdvancedIdleSettings->idleSwaySetting1_AdsIdleSpeed = *(float *)&_XMM1 * outAdvancedIdleSettings->idleSwaySetting1_AdsIdleSpeed;
  outAdvancedIdleSettings->idleSwaySetting1_AdsViewMagnitudeX = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting1_AdsViewMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting1_AdsViewMagnitudeY = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting1_AdsViewMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeX = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeY = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeZ = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting1_AdsWeaponMagnitudeZ;
  outAdvancedIdleSettings->idleSwaySetting2_AdsIdleSpeed = *(float *)&_XMM1 * outAdvancedIdleSettings->idleSwaySetting2_AdsIdleSpeed;
  outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeX = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeY = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting2_AdsViewMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeX = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeX;
  outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeY = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeY;
  outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeZ = *(float *)&_XMM4 * outAdvancedIdleSettings->idleSwaySetting2_AdsWeaponMagnitudeZ;
}

/*
==============
BG_GetAllWeaponAttachments
==============
*/
unsigned int BG_GetAllWeaponAttachments(const Weapon *r_weapon, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetAllWeaponAttachmentsWithIds(r_weapon, attachments, attachmentIds);
}

/*
==============
BG_GetAllWeaponAttachmentsCount
==============
*/
__int64 BG_GetAllWeaponAttachmentsCount(const Weapon *r_weapon)
{
  int v1; 
  int v4; 
  bool v5; 
  __int16 v6; 
  int v7; 

  v1 = 0;
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v4 = 0;
  v5 = 1;
  do
  {
    if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
      __debugbreak();
    if ( v4 == 12 )
      v6 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
    else
      v6 = r_weapon->weaponAttachments[v4];
    v7 = v1 + 1;
    if ( !v6 )
      v7 = v1;
    ++v4;
    v1 = v7;
    v5 = v4 < 13;
  }
  while ( (unsigned int)v4 < 0xD );
  return v7 + __popcnt(r_weapon->weaponOthers);
}

/*
==============
BG_GetAllWeaponAttachmentsWithIds
==============
*/
__int64 BG_GetAllWeaponAttachmentsWithIds(const Weapon *r_weapon, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  const Weapon *v5; 
  __int64 v6; 
  const WeaponCompleteDef *v8; 
  const AttachmentSlot *v9; 
  __int64 v10; 
  AttachmentSlot v11; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  int v14; 
  __int64 v16; 
  __int64 v17; 
  __int64 v19; 
  const AttachmentSlot *v20; 

  v5 = r_weapon;
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1519, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  if ( !attachmentIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1520, ASSERT_TYPE_ASSERT, "(attachmentIds)", (const char *)&queryFormat, "attachmentIds") )
    __debugbreak();
  v6 = 0i64;
  DebugWipe(attachments, 0xE8ui64);
  if ( !v5->weaponIdx )
    return 0i64;
  v8 = BG_WeaponCompleteDef(v5, 0);
  v9 = ATTACHMENT_DEFAULT_ORDER;
  v10 = 14i64;
  v20 = ATTACHMENT_DEFAULT_ORDER;
  v19 = 14i64;
  do
  {
    v11 = *v9;
    if ( *(int *)v9 < 13 )
    {
      WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(v5, v11);
      if ( WeaponPrimaryAttachment )
      {
        if ( (unsigned int)v6 >= 0x1D )
        {
          LODWORD(v17) = 29;
          LODWORD(v16) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1541, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachments[v6] = WeaponPrimaryAttachment;
        v5 = r_weapon;
        attachmentIds[v6] = truncate_cast<unsigned char,enum AttachmentSlot>(v11);
        v6 = (unsigned int)(v6 + 1);
      }
LABEL_35:
      v10 = v19;
      goto LABEL_36;
    }
    if ( v11 != ATT_SLOT_OTHER )
    {
      SLODWORD(v16) = *v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1569, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid attachment slot %d specified by the attachment ordering\n", v16) )
        __debugbreak();
      goto LABEL_35;
    }
    if ( v8->attachments[13].attachmentCount > 0x10 )
    {
      LODWORD(v17) = 16;
      LODWORD(v16) = v8->attachments[13].attachmentCount;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1551, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", v16, v17) )
        __debugbreak();
      v10 = v19;
    }
    _EBP = v5->weaponOthers;
    if ( v5->weaponOthers )
    {
      do
      {
        v14 = _EBP;
        __asm { tzcnt   ebx, ebp }
        if ( _EBX >= v8->attachments[13].attachmentCount )
        {
          LODWORD(v17) = v8->attachments[13].attachmentCount;
          LODWORD(v16) = _EBX;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1556, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        if ( (unsigned int)v6 >= 0x1D )
        {
          LODWORD(v17) = 29;
          LODWORD(v16) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1557, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachments[v6] = v8->attachments[13].attachments[_EBX];
        if ( _EBX >= 0x10 )
        {
          LODWORD(v17) = 16;
          LODWORD(v16) = _EBX;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachmentIds[v6] = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
        v6 = (unsigned int)(v6 + 1);
        _EBP ^= 1 << _EBX;
      }
      while ( 1 << _EBX != v14 );
      v5 = r_weapon;
      goto LABEL_35;
    }
LABEL_36:
    v9 = v20 + 1;
    --v10;
    ++v20;
    v19 = v10;
  }
  while ( v10 );
  return (unsigned int)v6;
}

/*
==============
BG_GetAltWeapon
==============
*/
const Weapon *BG_GetAltWeapon(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  bool v3; 
  const Weapon *result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return &NULL_WEAPON;
  v3 = WeaponPrimaryAttachment->weapClass == WEAPCLASS_NONE;
  result = r_weapon;
  if ( v3 )
    return &NULL_WEAPON;
  return result;
}

/*
==============
BG_GetAmmoIndex
==============
*/
__int64 BG_GetAmmoIndex(const Weapon *r_weapon, bool isAlternate, const BgHandler *const handler, const char **outAmmoName)
{
  const WeaponDef *v8; 
  unsigned int iAmmoIndex; 
  int v10; 
  int WeaponAttachments_Internal; 
  __int64 v12; 
  __int64 v13; 
  WeaponAttachment *v14; 
  AttAmmoType *ammotype; 
  __int64 result; 
  WeaponAttachment *v17; 
  __int64 v18; 
  int v19; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( outAmmoName )
    *outAmmoName = NULL;
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8->iAmmoIndex )
  {
    v19 = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6075, ASSERT_TYPE_ASSERT, "( 0 ) != ( weapDef->iAmmoIndex )", "%s != %s\n\t%i, %i", "0", "weapDef->iAmmoIndex", 0i64, v19) )
      __debugbreak();
  }
  iAmmoIndex = v8->iAmmoIndex;
  if ( outAmmoName )
  {
    if ( handler )
      LOBYTE(handler) = BG_IsGameTypeQuick_BR(handler);
    if ( BG_WeaponOverrides_GetSharedAmmo(r_weapon) || (_BYTE)handler )
      *outAmmoName = v8->szAmmoName;
  }
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal <= 0 )
    return iAmmoIndex;
  v13 = 0i64;
  while ( 1 )
  {
    if ( !attachments[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6096, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v14 = attachments[v13];
    ammotype = v14->ammotype;
    if ( ammotype )
    {
      if ( ammotype->szAmmoName )
        break;
    }
    ++v10;
    if ( ++v13 >= v12 )
      return iAmmoIndex;
  }
  if ( !v14->iAmmoIndex )
  {
    LODWORD(v18) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6099, ASSERT_TYPE_ASSERT, "( 0 ) != ( attachments[attachmentIndex]->iAmmoIndex )", "%s != %s\n\t%i, %i", "0", "attachments[attachmentIndex]->iAmmoIndex", 0i64, v18) )
      __debugbreak();
  }
  v17 = attachments[v10];
  result = (unsigned int)v17->iAmmoIndex;
  if ( outAmmoName )
    *outAmmoName = v17->ammotype->szAmmoName;
  return result;
}

/*
==============
BG_GetAngularGunKickSettings
==============
*/
void BG_GetAngularGunKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularGunKickDir, float *hipAngularGunKickDev, float *hipAngularGunKickStrengthMin, float *hipAngularGunKickStrengthMax, float *hipAngularGunKickPitchScale, float *adsAngularGunKickDir, float *adsAngularGunKickDev, float *adsAngularGunKickStrengthMin, float *adsAngularGunKickStrengthMax, float *adsAngularGunKickPitchScale)
{
  const BgWeaponMap *v15; 
  const playerState_s *v16; 
  const Weapon *v18; 
  const WeaponDef *v19; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool *v21; 
  int v22; 
  int *v23; 
  int v24; 
  int v25; 
  EffectiveStance EffectiveStance; 
  __int64 v27; 
  float adsCrouchGunKickFactor; 
  ContextMountType type; 
  const WeaponDef *v30; 
  float mountTopGunKickScale; 
  unsigned int v32; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v36; 
  WeaponAttachment **v37; 
  __int64 v38; 
  WeaponAttachment *v39; 
  AttADSStanceScales *adsStanceScales; 
  const dvar_t *v41; 
  float adsCrouchGunKickFactorScale; 
  __int128 v43; 
  __int128 v44; 
  const WeaponAttachment **v45; 
  AttGunKick *AttachmentGunKick; 
  float *p_hipGunKickPitchMin; 
  float *v48; 
  float *v49; 
  __int128 v51; 
  __int128 v55; 
  bool *v59; 
  int *v60; 
  int v61; 
  bool v62; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v15 = weaponMap;
  v16 = ps;
  v18 = r_weapon;
  if ( !hipAngularGunKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14958, ASSERT_TYPE_ASSERT, "(hipAngularGunKickDir)", (const char *)&queryFormat, "hipAngularGunKickDir") )
    __debugbreak();
  if ( !hipAngularGunKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14959, ASSERT_TYPE_ASSERT, "(hipAngularGunKickDev)", (const char *)&queryFormat, "hipAngularGunKickDev") )
    __debugbreak();
  if ( !hipAngularGunKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14960, ASSERT_TYPE_ASSERT, "(hipAngularGunKickStrengthMin)", (const char *)&queryFormat, "hipAngularGunKickStrengthMin") )
    __debugbreak();
  if ( !hipAngularGunKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14961, ASSERT_TYPE_ASSERT, "(hipAngularGunKickStrengthMax)", (const char *)&queryFormat, "hipAngularGunKickStrengthMax") )
    __debugbreak();
  if ( !hipAngularGunKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14962, ASSERT_TYPE_ASSERT, "(hipAngularGunKickPitchScale)", (const char *)&queryFormat, "hipAngularGunKickPitchScale") )
    __debugbreak();
  if ( !adsAngularGunKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14963, ASSERT_TYPE_ASSERT, "(adsAngularGunKickDir)", (const char *)&queryFormat, "adsAngularGunKickDir") )
    __debugbreak();
  if ( !adsAngularGunKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14964, ASSERT_TYPE_ASSERT, "(adsAngularGunKickDev)", (const char *)&queryFormat, "adsAngularGunKickDev") )
    __debugbreak();
  if ( !adsAngularGunKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14965, ASSERT_TYPE_ASSERT, "(adsAngularGunKickStrengthMin)", (const char *)&queryFormat, "adsAngularGunKickStrengthMin") )
    __debugbreak();
  if ( !adsAngularGunKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14966, ASSERT_TYPE_ASSERT, "(adsAngularGunKickStrengthMax)", (const char *)&queryFormat, "adsAngularGunKickStrengthMax") )
    __debugbreak();
  if ( !adsAngularGunKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14967, ASSERT_TYPE_ASSERT, "(adsAngularGunKickPitchScale)", (const char *)&queryFormat, "adsAngularGunKickPitchScale") )
    __debugbreak();
  v19 = BG_WeaponDefAtIndex(v18->weaponIdx);
  v62 = v16 && v15 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v15, v16, v18)) != NULL && EquippedWeaponStateConst->hybridScope;
  v21 = &v19->adsAngularGunKickUseSet[1];
  v22 = 1;
  v23 = &v19->adsAngularGunKickBullet[1];
  v24 = 1;
  while ( *v21 && *v23 <= bulletNum )
  {
    v25 = v24;
    ++v23;
    ++v24;
    ++v21;
    if ( v24 >= 6 )
      goto LABEL_42;
  }
  v25 = v24 - 1;
LABEL_42:
  *hipAngularGunKickDir = v19->hipAngularGunKickDir[0];
  *hipAngularGunKickDev = v19->hipAngularGunKickDev[0];
  *hipAngularGunKickStrengthMin = v19->hipAngularGunKickStrengthMin[0];
  *hipAngularGunKickStrengthMax = v19->hipAngularGunKickStrengthMax[0];
  *hipAngularGunKickPitchScale = v19->hipAngularGunKickPitchScale[0];
  *adsAngularGunKickDir = v19->adsAngularGunKickDir[v25];
  *adsAngularGunKickDev = v19->adsAngularGunKickDev[v25];
  *adsAngularGunKickStrengthMin = v19->adsAngularGunKickStrengthMin[v25];
  *adsAngularGunKickStrengthMax = v19->adsAngularGunKickStrengthMax[v25];
  *adsAngularGunKickPitchScale = v19->adsAngularGunKickPitchScale[v25];
  EffectiveStance = PM_GetEffectiveStance(v16);
  v27 = EffectiveStance;
  adsCrouchGunKickFactor = FLOAT_1_0;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    adsCrouchGunKickFactor = v19->adsCrouchGunKickFactor;
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    adsCrouchGunKickFactor = v19->adsProneGunKickFactor;
  }
  if ( v16->mountState.mountFraction <= 0.0 )
    goto LABEL_54;
  type = v16->mountState.surface.type;
  v30 = BG_WeaponDefAtIndex(v18->weaponIdx);
  if ( !v30 )
    goto LABEL_48;
  if ( type == MOUNT_TYPE_TOP )
  {
    mountTopGunKickScale = v30->mountTopGunKickScale;
    goto LABEL_53;
  }
  if ( (unsigned int)(type - 2) <= 1 )
    mountTopGunKickScale = v30->mountSideGunKickScale;
  else
LABEL_48:
    mountTopGunKickScale = FLOAT_1_0;
LABEL_53:
  adsCrouchGunKickFactor = (float)((float)(1.0 - v16->mountState.mountFraction) * adsCrouchGunKickFactor) + (float)(v16->mountState.mountFraction * mountTopGunKickScale);
LABEL_54:
  v32 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v18, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM8 = LODWORD(FLOAT_1_0);
  _XMM7 = LODWORD(FLOAT_1_0);
  if ( !WeaponAttachments_Internal )
    goto LABEL_75;
  v36 = WeaponAttachments_Internal;
  v37 = attachments;
  v38 = v27;
  do
  {
    v39 = *v37;
    if ( !*v37 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15036, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    adsStanceScales = v39->adsStanceScales;
    if ( adsStanceScales )
    {
      if ( v38 == 2 )
      {
        v41 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v41);
        adsCrouchGunKickFactorScale = adsStanceScales->adsCrouchGunKickFactorScale;
      }
      else
      {
        if ( v38 != 1 )
          goto LABEL_73;
        v41 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v41);
        adsCrouchGunKickFactorScale = adsStanceScales->adsProneGunKickFactorScale;
      }
      if ( v41->current.enabled )
      {
        v43 = _XMM7;
        *(float *)&v43 = *(float *)&_XMM7 * adsCrouchGunKickFactorScale;
        _XMM7 = v43;
      }
      else
      {
        v44 = _XMM8;
        *(float *)&v44 = (float)(*(float *)&_XMM8 + adsCrouchGunKickFactorScale) - 1.0;
        _XMM8 = v44;
      }
    }
LABEL_73:
    ++v37;
    --v36;
  }
  while ( v36 );
  v22 = 1;
  v16 = ps;
  v32 = 0;
  v18 = r_weapon;
  v15 = weaponMap;
LABEL_75:
  if ( WeaponAttachments_Internal )
  {
    v45 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15069, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(v15, v16, v18, isAlternate, *v45, v62);
      p_hipGunKickPitchMin = &AttachmentGunKick->hipGunKickPitchMin;
      if ( AttachmentGunKick )
        break;
      ++v32;
      ++v45;
      if ( v32 >= WeaponAttachments_Internal )
        goto LABEL_82;
    }
    v59 = &AttachmentGunKick->adsAngularGunKickUseSet[1];
    v60 = (int *)(p_hipGunKickPitchMin + 72);
    while ( *v59 && *v60 <= bulletNum )
    {
      v61 = v22;
      ++v60;
      ++v22;
      ++v59;
      if ( v22 >= 6 )
        goto LABEL_90;
    }
    v61 = v22 - 1;
LABEL_90:
    v49 = hipAngularGunKickStrengthMin;
    v48 = hipAngularGunKickStrengthMax;
    *hipAngularGunKickDir = p_hipGunKickPitchMin[11];
    *hipAngularGunKickDev = p_hipGunKickPitchMin[17];
    *hipAngularGunKickStrengthMin = p_hipGunKickPitchMin[23];
    *hipAngularGunKickStrengthMax = p_hipGunKickPitchMin[29];
    *hipAngularGunKickPitchScale = p_hipGunKickPitchMin[35];
    *adsAngularGunKickDir = p_hipGunKickPitchMin[v61 + 41];
    *adsAngularGunKickDev = p_hipGunKickPitchMin[v61 + 47];
    *adsAngularGunKickStrengthMin = p_hipGunKickPitchMin[v61 + 53];
    *adsAngularGunKickStrengthMax = p_hipGunKickPitchMin[v61 + 59];
    *adsAngularGunKickPitchScale = p_hipGunKickPitchMin[v61 + 65];
  }
  else
  {
LABEL_82:
    v48 = hipAngularGunKickStrengthMax;
    v49 = hipAngularGunKickStrengthMin;
  }
  __asm { vmaxss  xmm2, xmm8, xmm10 }
  v51 = LODWORD(FLOAT_1_0);
  *(float *)&v51 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v51 + 1) = (v51 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v51 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v51;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm6, xmm0
  }
  v55 = LODWORD(FLOAT_1_0);
  *(float *)&v55 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v55 + 1) = (v55 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v55 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v55;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm6, xmm2
  }
  *v49 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v49;
  *v48 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v48;
  *(float *)&_XMM2 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * adsCrouchGunKickFactor;
  *adsAngularGunKickStrengthMin = *(float *)&_XMM2 * *adsAngularGunKickStrengthMin;
  *adsAngularGunKickStrengthMax = *(float *)&_XMM2 * *adsAngularGunKickStrengthMax;
}

/*
==============
BG_GetAngularViewKickSettings
==============
*/
void BG_GetAngularViewKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularViewKickDir, float *hipAngularViewKickDev, float *hipAngularViewKickStrengthMin, float *hipAngularViewKickStrengthMax, float *hipAngularViewKickPitchScale, float *adsAngularViewKickDir, float *adsAngularViewKickDev, float *adsAngularViewKickStrengthMin, float *adsAngularViewKickStrengthMax, float *adsAngularViewKickPitchScale)
{
  const WeaponDef *v19; 
  int v20; 
  bool *v21; 
  int *v22; 
  int v23; 
  EffectiveStance EffectiveStance; 
  __int64 v25; 
  float adsCrouchViewKickFactor; 
  ContextMountType type; 
  const WeaponDef *v28; 
  float mountTopViewKickScale; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v31; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  __int64 v35; 
  WeaponAttachment **v36; 
  __int64 v37; 
  WeaponAttachment *v38; 
  float *p_adsCrouchViewKickFactorScale; 
  const dvar_t *v40; 
  float v41; 
  __int128 v42; 
  __int128 v43; 
  unsigned int v44; 
  int v45; 
  const WeaponAttachment **v46; 
  AttViewKick *AttachmentViewKick; 
  float *p_hipViewKickPitchMin; 
  float *v49; 
  float *v50; 
  __int128 v52; 
  __int128 v56; 
  int *v60; 
  bool *v61; 
  int v62; 
  bool v63; 
  unsigned int v65; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !hipAngularViewKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14784, ASSERT_TYPE_ASSERT, "(hipAngularViewKickDir)", (const char *)&queryFormat, "hipAngularViewKickDir") )
    __debugbreak();
  if ( !hipAngularViewKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14785, ASSERT_TYPE_ASSERT, "(hipAngularViewKickDev)", (const char *)&queryFormat, "hipAngularViewKickDev") )
    __debugbreak();
  if ( !hipAngularViewKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14786, ASSERT_TYPE_ASSERT, "(hipAngularViewKickStrengthMin)", (const char *)&queryFormat, "hipAngularViewKickStrengthMin") )
    __debugbreak();
  if ( !hipAngularViewKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14787, ASSERT_TYPE_ASSERT, "(hipAngularViewKickStrengthMax)", (const char *)&queryFormat, "hipAngularViewKickStrengthMax") )
    __debugbreak();
  if ( !hipAngularViewKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14788, ASSERT_TYPE_ASSERT, "(hipAngularViewKickPitchScale)", (const char *)&queryFormat, "hipAngularViewKickPitchScale") )
    __debugbreak();
  if ( !adsAngularViewKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14789, ASSERT_TYPE_ASSERT, "(adsAngularViewKickDir)", (const char *)&queryFormat, "adsAngularViewKickDir") )
    __debugbreak();
  if ( !adsAngularViewKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14790, ASSERT_TYPE_ASSERT, "(adsAngularViewKickDev)", (const char *)&queryFormat, "adsAngularViewKickDev") )
    __debugbreak();
  if ( !adsAngularViewKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14791, ASSERT_TYPE_ASSERT, "(adsAngularViewKickStrengthMin)", (const char *)&queryFormat, "adsAngularViewKickStrengthMin") )
    __debugbreak();
  if ( !adsAngularViewKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14792, ASSERT_TYPE_ASSERT, "(adsAngularViewKickStrengthMax)", (const char *)&queryFormat, "adsAngularViewKickStrengthMax") )
    __debugbreak();
  if ( !adsAngularViewKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14793, ASSERT_TYPE_ASSERT, "(adsAngularViewKickPitchScale)", (const char *)&queryFormat, "adsAngularViewKickPitchScale") )
    __debugbreak();
  v19 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v20 = 1;
  v21 = &v19->adsAngularViewKickUseSet[1];
  v22 = &v19->adsAngularViewKickBullet[1];
  while ( *v21 && *v22 <= bulletNum )
  {
    v23 = v20;
    ++v22;
    ++v20;
    ++v21;
    if ( v20 >= 6 )
      goto LABEL_37;
  }
  v23 = v20 - 1;
LABEL_37:
  *hipAngularViewKickDir = v19->hipAngularViewKickDir[0];
  *hipAngularViewKickDev = v19->hipAngularViewKickDev[0];
  *hipAngularViewKickStrengthMin = v19->hipAngularViewKickStrengthMin[0];
  *hipAngularViewKickStrengthMax = v19->hipAngularViewKickStrengthMax[0];
  *hipAngularViewKickPitchScale = v19->hipAngularViewKickPitchScale[0];
  *adsAngularViewKickDir = v19->adsAngularViewKickDir[v23];
  *adsAngularViewKickDev = v19->adsAngularViewKickDev[v23];
  *adsAngularViewKickStrengthMin = v19->adsAngularViewKickStrengthMin[v23];
  *adsAngularViewKickStrengthMax = v19->adsAngularViewKickStrengthMax[v23];
  *adsAngularViewKickPitchScale = v19->adsAngularViewKickPitchScale[v23];
  EffectiveStance = PM_GetEffectiveStance(ps);
  v25 = EffectiveStance;
  adsCrouchViewKickFactor = FLOAT_1_0;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    adsCrouchViewKickFactor = v19->adsCrouchViewKickFactor;
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    adsCrouchViewKickFactor = v19->adsProneViewKickFactor;
  }
  if ( ps->mountState.mountFraction <= 0.0 )
    goto LABEL_49;
  type = ps->mountState.surface.type;
  v28 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v28 )
    goto LABEL_43;
  if ( type == MOUNT_TYPE_TOP )
  {
    mountTopViewKickScale = v28->mountTopViewKickScale;
    goto LABEL_48;
  }
  if ( (unsigned int)(type - 2) <= 1 )
    mountTopViewKickScale = v28->mountSideViewKickScale;
  else
LABEL_43:
    mountTopViewKickScale = FLOAT_1_0;
LABEL_48:
  adsCrouchViewKickFactor = (float)((float)(1.0 - ps->mountState.mountFraction) * adsCrouchViewKickFactor) + (float)(ps->mountState.mountFraction * mountTopViewKickScale);
LABEL_49:
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v31 = WeaponAttachments_Internal;
  v65 = WeaponAttachments_Internal;
  _XMM8 = LODWORD(FLOAT_1_0);
  _XMM7 = LODWORD(FLOAT_1_0);
  v63 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !(_DWORD)v31 )
    goto LABEL_80;
  v35 = v31;
  v36 = attachments;
  v37 = v25;
  do
  {
    v38 = *v36;
    if ( !*v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14863, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    p_adsCrouchViewKickFactorScale = &v38->adsStanceScales->adsCrouchViewKickFactorScale;
    if ( p_adsCrouchViewKickFactorScale )
    {
      if ( v37 == 2 )
      {
        v40 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v40);
        v41 = *p_adsCrouchViewKickFactorScale;
      }
      else
      {
        if ( v37 != 1 )
          goto LABEL_72;
        v40 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v40);
        v41 = p_adsCrouchViewKickFactorScale[2];
      }
      if ( v40->current.enabled )
      {
        v42 = _XMM7;
        *(float *)&v42 = *(float *)&_XMM7 * v41;
        _XMM7 = v42;
      }
      else
      {
        v43 = _XMM8;
        *(float *)&v43 = (float)(*(float *)&_XMM8 + v41) - 1.0;
        _XMM8 = v43;
      }
    }
LABEL_72:
    ++v36;
    --v35;
  }
  while ( v35 );
  v44 = 0;
  v45 = 1;
  if ( !v65 )
  {
LABEL_80:
    v49 = hipAngularViewKickStrengthMax;
    v50 = hipAngularViewKickStrengthMin;
    goto LABEL_81;
  }
  v46 = (const WeaponAttachment **)attachments;
  while ( 1 )
  {
    if ( !*v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14896, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *v46, v63);
    p_hipViewKickPitchMin = &AttachmentViewKick->hipViewKickPitchMin;
    if ( AttachmentViewKick )
      break;
    ++v44;
    ++v46;
    if ( v44 >= v65 )
      goto LABEL_80;
  }
  v60 = &AttachmentViewKick->adsAngularViewKickBullet[1];
  v61 = &AttachmentViewKick->adsAngularViewKickUseSet[1];
  while ( *v61 && *v60 <= bulletNum )
  {
    v62 = v45;
    ++v60;
    ++v45;
    ++v61;
    if ( v45 >= 6 )
      goto LABEL_88;
  }
  v62 = v45 - 1;
LABEL_88:
  v50 = hipAngularViewKickStrengthMin;
  v49 = hipAngularViewKickStrengthMax;
  *hipAngularViewKickDir = p_hipViewKickPitchMin[11];
  *hipAngularViewKickDev = p_hipViewKickPitchMin[17];
  *hipAngularViewKickStrengthMin = p_hipViewKickPitchMin[23];
  *hipAngularViewKickStrengthMax = p_hipViewKickPitchMin[29];
  *hipAngularViewKickPitchScale = p_hipViewKickPitchMin[35];
  *adsAngularViewKickDir = p_hipViewKickPitchMin[v62 + 41];
  *adsAngularViewKickDev = p_hipViewKickPitchMin[v62 + 47];
  *adsAngularViewKickStrengthMin = p_hipViewKickPitchMin[v62 + 53];
  *adsAngularViewKickStrengthMax = p_hipViewKickPitchMin[v62 + 59];
  *adsAngularViewKickPitchScale = p_hipViewKickPitchMin[v62 + 65];
LABEL_81:
  __asm { vmaxss  xmm2, xmm8, xmm10 }
  v52 = LODWORD(FLOAT_1_0);
  *(float *)&v52 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v52 + 1) = (v52 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v52 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v52;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm6, xmm0
  }
  v56 = LODWORD(FLOAT_1_0);
  *(float *)&v56 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v56 + 1) = (v56 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v56 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v56;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm6, xmm2
  }
  *v50 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v50;
  *v49 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v49;
  *(float *)&_XMM2 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * adsCrouchViewKickFactor;
  *adsAngularViewKickStrengthMin = *(float *)&_XMM2 * *adsAngularViewKickStrengthMin;
  *adsAngularViewKickStrengthMax = *(float *)&_XMM2 * *adsAngularViewKickStrengthMax;
}

/*
==============
BG_GetAnimForFootsteps
==============
*/
__int64 BG_GetAnimForFootsteps(FootstepAnimType footstepAnim)
{
  __int64 v1; 
  int v4; 

  v1 = footstepAnim;
  if ( (unsigned int)footstepAnim >= FOOTSTEP_ANIM_COUNT )
  {
    v4 = 13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21739, ASSERT_TYPE_ASSERT, "(unsigned)( footstepAnim ) < (unsigned)( ( sizeof( *array_counter( FootstepToAnimMap ) ) + 0 ) )", "footstepAnim doesn't index ARRAY_COUNT( FootstepToAnimMap )\n\t%i not in [0, %i)", footstepAnim, v4) )
      __debugbreak();
  }
  return (unsigned int)FootstepToAnimMap[v1];
}

/*
==============
BG_GetAnimOverrideIdxForMeleeComboSeq
==============
*/
__int64 BG_GetAnimOverrideIdxForMeleeComboSeq(const Weapon *r_weapon, const int meleeComboSeqIdx)
{
  int v4; 
  unsigned int v5; 
  const WeaponDef *v6; 
  __int64 result; 

  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19810, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  if ( meleeComboSeqIdx < 0 )
    goto LABEL_21;
  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19780, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  v4 = 1;
  v5 = 0;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6->numAnimOverrides )
    goto LABEL_22;
  do
  {
    if ( !BG_IsMeleeComboOverride(r_weapon, v5) )
      break;
    ++v4;
    ++v5;
  }
  while ( v5 < v6->numAnimOverrides );
  if ( v4 <= 1 )
  {
LABEL_22:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19802, ASSERT_TYPE_ASSERT, "(comboCount > 1)", (const char *)&queryFormat, "comboCount > 1") )
      __debugbreak();
  }
  if ( meleeComboSeqIdx >= v4 )
  {
LABEL_21:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19811, ASSERT_TYPE_ASSERT, "((meleeComboSeqIdx >= 0) && (meleeComboSeqIdx < BG_GetMeleeComboSeqCount( r_weapon )))", (const char *)&queryFormat, "(meleeComboSeqIdx >= 0) && (meleeComboSeqIdx < BG_GetMeleeComboSeqCount( r_weapon ))") )
      __debugbreak();
  }
  result = 0xFFFFFFFFi64;
  if ( meleeComboSeqIdx )
    return (unsigned int)(meleeComboSeqIdx - 1);
  return result;
}

/*
==============
BG_GetAttachmentGunKick
==============
*/
AttGunKick *BG_GetAttachmentGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 516, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment )
    return 0i64;
  OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
  if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 524, ASSERT_TYPE_ASSERT, "(overrideAttachment)", (const char *)&queryFormat, "overrideAttachment") )
    __debugbreak();
  return OverrideAttachmentWhenApplicable->gunKick;
}

/*
==============
BG_GetAttachmentModel
==============
*/
XModel *BG_GetAttachmentModel(const WeaponAttachment *weaponAttachment, const int attachmentVariationIndex, bool isViewModel)
{
  __int64 v3; 
  XModel **viewModelVariations; 

  v3 = attachmentVariationIndex;
  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1670, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( (int)v3 >= (signed int)weaponAttachment->numModelVariations )
    return 0i64;
  if ( isViewModel )
    viewModelVariations = weaponAttachment->viewModelVariations;
  else
    viewModelVariations = weaponAttachment->worldModelVariations;
  return viewModelVariations[v3];
}

/*
==============
BG_GetAttachmentViewKick
==============
*/
AttViewKick *BG_GetAttachmentViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 500, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment )
    return 0i64;
  OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
  if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 508, ASSERT_TYPE_ASSERT, "(overrideAttachment)", (const char *)&queryFormat, "overrideAttachment") )
    __debugbreak();
  return OverrideAttachmentWhenApplicable->viewKick;
}

/*
==============
BG_GetBallisticInfo
==============
*/
const BallisticInfo *BG_GetBallisticInfo(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const BallisticInfo *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ballisticInfo;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22302, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->ballisticInfo;
    if ( result )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ballisticInfo;
  }
  return result;
}

/*
==============
BG_GetBallisticMuzzleVelocityScale
==============
*/
float BG_GetBallisticMuzzleVelocityScale(const Weapon *r_weapon, bool isAlternate)
{
  __int64 v2; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v4; 
  char *v6; 
  unsigned int v7; 
  __int64 v8; 
  __int64 v9; 
  float v10; 
  __int128 v11; 
  float v12; 
  __int128 v13; 
  __int64 v14; 
  float v15; 
  __int128 v16; 
  __int64 v17; 
  float v18; 
  __int128 v19; 
  WeaponAttachment **v20; 
  __int64 v21; 
  float ballisticMuzzleVelocityScale; 
  __int128 v23; 
  __int128 v24; 
  const dvar_t *v26; 
  WeaponAttachment *attachments; 
  char v31; 
  unsigned __int8 v32[32]; 

  v2 = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, v32, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v4 = WeaponAttachments_Internal;
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal >= 4 )
  {
    v6 = &v31;
    v7 = ((WeaponAttachments_Internal - 4) >> 2) + 1;
    v8 = v7;
    v2 = 4 * v7;
    do
    {
      v9 = *((_QWORD *)v6 - 1);
      if ( v9 )
      {
        v10 = *(float *)(v9 + 612);
        if ( v10 > 0.0 )
        {
          v11 = _XMM6;
          *(float *)&v11 = *(float *)&_XMM6 * v10;
          _XMM6 = v11;
        }
      }
      if ( *(_QWORD *)v6 )
      {
        v12 = *(float *)(*(_QWORD *)v6 + 612i64);
        if ( v12 > 0.0 )
        {
          v13 = _XMM6;
          *(float *)&v13 = *(float *)&_XMM6 * v12;
          _XMM6 = v13;
        }
      }
      v14 = *((_QWORD *)v6 + 1);
      if ( v14 )
      {
        v15 = *(float *)(v14 + 612);
        if ( v15 > 0.0 )
        {
          v16 = _XMM6;
          *(float *)&v16 = *(float *)&_XMM6 * v15;
          _XMM6 = v16;
        }
      }
      v17 = *((_QWORD *)v6 + 2);
      if ( v17 )
      {
        v18 = *(float *)(v17 + 612);
        if ( v18 > 0.0 )
        {
          v19 = _XMM6;
          *(float *)&v19 = *(float *)&_XMM6 * v18;
          _XMM6 = v19;
        }
      }
      v6 += 32;
      --v8;
    }
    while ( v8 );
  }
  if ( (unsigned int)v2 < v4 )
  {
    v20 = &attachments + v2;
    v21 = v4 - (unsigned int)v2;
    do
    {
      if ( *v20 )
      {
        ballisticMuzzleVelocityScale = (*v20)->ballisticMuzzleVelocityScale;
        if ( ballisticMuzzleVelocityScale > 0.0 )
        {
          v23 = _XMM6;
          *(float *)&v23 = *(float *)&_XMM6 * ballisticMuzzleVelocityScale;
          _XMM6 = v23;
        }
      }
      ++v20;
      --v21;
    }
    while ( v21 );
  }
  v24 = LODWORD(FLOAT_1_0);
  *(float *)&v24 = 1.0 - *(float *)&_XMM6;
  *((_QWORD *)&v24 + 1) = (v24 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v24 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM6) & _xmm);
  _XMM8 = v24;
  if ( *(double *)&v24 > 0.000001 && *(float *)&_XMM6 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22355, ASSERT_TYPE_ASSERT, "(weapScaleAccum.GetFinalValue( 1.0f ))", (const char *)&queryFormat, "weapScaleAccum.GetFinalValue( 1.0f )") )
    __debugbreak();
  v26 = DCONST_DVARFLT_bg_ballisticsVelocityScalar;
  __asm
  {
    vcmplesd xmm0, xmm8, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm6, xmm9, xmm0
  }
  if ( !DCONST_DVARFLT_bg_ballisticsVelocityScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsVelocityScalar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  return *(float *)&_XMM6 * v26->current.value;
}

/*
==============
BG_GetBulletDamageForProjectile
==============
*/
__int64 BG_GetBulletDamageForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, const float rangeScale, const vec3_t *startPos, vec3_t *hitPos)
{
  __int128 v6; 
  int v10; 
  float v11; 
  float v12; 
  float v13; 
  float v15; 
  float v16; 
  int v18; 
  int outMaxDamage; 
  int outMinDamage; 
  float minDamageRange; 
  __int128 v22; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v18 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16627, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v18) )
      __debugbreak();
  }
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  v10 = outMaxDamage;
  if ( outMaxDamage == outMinDamage )
    return (unsigned int)outMaxDamage;
  BG_GetDamageRange(damageCalcType, r_weapon, isAlternate, rangeScale, &minDamageRange, (float *)&outMaxDamage);
  v11 = hitPos->v[1] - startPos->v[1];
  v12 = hitPos->v[2] - startPos->v[2];
  v13 = fsqrt((float)((float)(v11 * v11) + (float)((float)(hitPos->v[0] - startPos->v[0]) * (float)(hitPos->v[0] - startPos->v[0]))) + (float)(v12 * v12));
  if ( v13 < *(float *)&outMaxDamage )
    return (unsigned int)v10;
  if ( v13 >= minDamageRange )
    return (unsigned int)outMinDamage;
  v15 = minDamageRange - *(float *)&outMaxDamage;
  v22 = v6;
  if ( (float)(minDamageRange - *(float *)&outMaxDamage) == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16657, ASSERT_TYPE_ASSERT, "(range != 0.0f)", (const char *)&queryFormat, "range != 0.0f") )
    __debugbreak();
  v16 = (float)(v13 - *(float *)&outMaxDamage) / v15;
  if ( (v16 < 0.0 || v16 > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16659, ASSERT_TYPE_ASSERT, "( ( (lerpAmount >= 0.0) && (lerpAmount <= 1.0) ) )", "( lerpAmount ) = %g", v16) )
    __debugbreak();
  return (unsigned int)(int)(float)((float)((float)(1.0 - v16) * (float)v10) + (float)((float)outMinDamage * v16));
}

/*
==============
BG_GetBulletTerminationRange
==============
*/
float BG_GetBulletTerminationRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  __int128 v4; 
  __int128 v7; 
  float terminateAtRange; 
  char v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  __int64 v12; 
  float damageScale; 
  __int128 v14; 
  AttDamage *damage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  *(double *)&v4 = BG_GetADSDamageRangeScale(weaponMap, ps, r_weapon, isAlternate);
  v7 = v4;
  terminateAtRange = 0.0;
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return *(float *)&v7 * BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.terminateAtRange;
  v11 = attachments;
  v12 = WeaponAttachments_Internal;
  do
  {
    if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8405, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    damageScale = (*v11)->damageScale;
    if ( damageScale != 0.0 )
    {
      v14 = v7;
      *(float *)&v14 = *(float *)&v7 * damageScale;
      v7 = v14;
    }
    if ( !v9 )
    {
      damage = (*v11)->damage;
      if ( damage )
      {
        terminateAtRange = damage->terminateAtRange;
        v9 = 1;
      }
    }
    ++v11;
    --v12;
  }
  while ( v12 );
  if ( v9 )
    return terminateAtRange * *(float *)&v7;
  else
    return *(float *)&v7 * BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.terminateAtRange;
}

/*
==============
BG_GetBurstFireCooldown
==============
*/
float BG_GetBurstFireCooldown(const Weapon *r_weapon, bool isAlternate)
{
  char v4; 
  float burstFireCooldown; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment **v9; 
  __int64 v10; 
  WeaponAttachment *v11; 
  int *burst; 
  __int128 v13; 
  __int128 v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  burstFireCooldown = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->burstFireCooldown;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    v10 = WeaponAttachments_Internal;
    do
    {
      v11 = *v9;
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7010, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
        __debugbreak();
      if ( v4 || (burst = (int *)v11->burst) == NULL || v11->type == ATTACHMENT_UNDERBARREL && WeaponPrimaryAttachment != v11 )
      {
        v13 = _XMM6;
        *(float *)&v13 = (float)(*(float *)&_XMM6 + v11->burstFireCooldownScale) - 1.0;
        _XMM6 = v13;
      }
      else
      {
        burstFireCooldown = (float)*burst;
        v4 = 1;
      }
      ++v9;
      --v10;
    }
    while ( v10 );
  }
  __asm { vmaxss  xmm3, xmm6, xmm0 }
  v15 = LODWORD(FLOAT_1_0);
  *(float *)&v15 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v15 + 1) = (v15 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v15 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM0 = v15;
  __asm
  {
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  return burstFireCooldown * *(float *)&_XMM0;
}

/*
==============
BG_GetCenterReticle
==============
*/
void BG_GetCenterReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleCenter, int *reticleCenterSize, bool *shouldPulse)
{
  const WeaponDef *v9; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v13; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !reticleCenter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16541, ASSERT_TYPE_ASSERT, "(reticleCenter)", (const char *)&queryFormat, "reticleCenter") )
    __debugbreak();
  if ( !reticleCenterSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16542, ASSERT_TYPE_ASSERT, "(reticleCenterSize)", (const char *)&queryFormat, "reticleCenterSize") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *reticleCenter = v9->reticleCenter;
  *reticleCenterSize = v9->iReticleCenterSize;
  if ( shouldPulse )
    *shouldPulse = v9->reticleCenterPulse;
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16557, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v13 = *i;
      general = (*i)->general;
      if ( general )
        break;
      if ( ++v10 >= WeaponAttachments_Internal )
        return;
    }
    *reticleCenter = general->reticleCenter;
    *reticleCenterSize = v13->general->reticleCenterSize;
  }
}

/*
==============
BG_GetCharacterModelRangeByType
==============
*/
char BG_GetCharacterModelRangeByType(DObj *obj, const CharacterModelType (*dobjModelTypes)[32], const CharacterModelType modelTypeSearched, const int startModelIndex, const int finishModelIndex, int *outFirst, int *outLast)
{
  __int64 v7; 
  const CharacterModelType *v11; 
  CharacterModelType v12; 
  int v13; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  int v18; 

  v7 = startModelIndex;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5895, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !dobjModelTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5896, ASSERT_TYPE_ASSERT, "(dobjModelTypes)", (const char *)&queryFormat, "dobjModelTypes") )
    __debugbreak();
  if ( !outFirst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5897, ASSERT_TYPE_ASSERT, "(outFirst)", (const char *)&queryFormat, "outFirst") )
    __debugbreak();
  if ( !outLast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5898, ASSERT_TYPE_ASSERT, "(outLast)", (const char *)&queryFormat, "outLast") )
    __debugbreak();
  if ( (int)v7 < 0 || (int)v7 > DObjGetNumModels(obj) - 1 )
  {
    v18 = DObjGetNumModels(obj) - 1;
    LODWORD(v15) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5899, ASSERT_TYPE_ASSERT, "( 0 ) <= ( startModelIndex ) && ( startModelIndex ) <= ( (DObjGetNumModels( obj ) - 1) )", "startModelIndex not in [0, (DObjGetNumModels( obj ) - 1)]\n\t%i not in [%i, %i]", v15, 0i64, v18) )
      __debugbreak();
  }
  if ( finishModelIndex < 0 || finishModelIndex > DObjGetNumModels(obj) - 1 )
  {
    LODWORD(v17) = DObjGetNumModels(obj) - 1;
    LODWORD(v15) = finishModelIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5900, ASSERT_TYPE_ASSERT, "( 0 ) <= ( finishModelIndex ) && ( finishModelIndex ) <= ( (DObjGetNumModels( obj ) - 1) )", "finishModelIndex not in [0, (DObjGetNumModels( obj ) - 1)]\n\t%i not in [%i, %i]", v15, 0i64, v17) )
      __debugbreak();
  }
  *outFirst = -1;
  *outLast = -1;
  if ( (int)v7 <= finishModelIndex )
  {
    v11 = &(*dobjModelTypes)[v7];
    do
    {
      if ( (unsigned int)v7 >= 0x20 )
      {
        LODWORD(v16) = 32;
        LODWORD(v15) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5909, ASSERT_TYPE_ASSERT, "(unsigned)( modelIndex ) < (unsigned)( ( 32 ) )", "modelIndex doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      v12 = *v11;
      if ( *outFirst >= 0 )
      {
        if ( v12 != modelTypeSearched )
        {
          v13 = v7 - 1;
          *outLast = v13;
          if ( v13 < *outFirst )
          {
            LODWORD(v17) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5925, ASSERT_TYPE_ASSERT, "( *outLast ) >= ( *outFirst )", "%s >= %s\n\t%i, %i", "*outLast", "*outFirst", v17, *outFirst) )
              __debugbreak();
          }
          break;
        }
      }
      else if ( v12 == modelTypeSearched )
      {
        *outFirst = v7;
      }
      LODWORD(v7) = v7 + 1;
      ++v11;
    }
    while ( (int)v7 <= finishModelIndex );
  }
  if ( *outFirst < 0 )
    return 0;
  if ( *outLast < 0 )
    *outLast = finishModelIndex;
  return 1;
}

/*
==============
BG_GetClipLowAmmo
==============
*/
__int64 BG_GetClipLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v6; 
  const dvar_t *v7; 
  int lowAmmoWarningCount; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6027, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6030, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT|0x100) )
    return (unsigned int)(int)(float)((float)BG_GetClipSize(ps, r_weapon, isAlternate) * v6->lowAmmoWarningThreshold);
  v7 = DVARBOOL_killswitch_weapon_low_ammo_count_enabled;
  if ( !DVARBOOL_killswitch_weapon_low_ammo_count_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_low_ammo_count_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return (unsigned int)(int)(float)((float)BG_GetClipSize(ps, r_weapon, isAlternate) * v6->lowAmmoWarningThreshold);
  lowAmmoWarningCount = v6->lowAmmoWarningCount;
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6044, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunition = (*v11)->ammunition;
      if ( ammunition )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_21;
    }
    lowAmmoWarningCount = ammunition->lowAmmoWarningCount;
  }
LABEL_21:
  if ( lowAmmoWarningCount > 0 )
    return (unsigned int)lowAmmoWarningCount;
  else
    return (unsigned int)(int)(float)((float)BG_GetClipSize(ps, r_weapon, isAlternate) * v6->lowAmmoWarningThreshold);
}

/*
==============
BG_GetClipSize
==============
*/
__int64 BG_GetClipSize(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  __int128 v3; 
  __int128 v4; 
  __int128 v5; 
  const playerState_s *v7; 
  int integer; 
  unsigned int iClipSize; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v13; 
  __int64 v14; 
  float ammunitionScale; 
  __int128 ammunitionScale_low; 
  unsigned int v17; 
  WeaponAttachment **v18; 
  AttAmmunition *ammunition; 
  __int128 v21; 
  int v25; 
  const dvar_t *v26; 
  const char *v27; 
  __int64 numAttachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v33; 
  __int128 v34; 
  __int128 v35; 

  v7 = ps;
  v35 = v3;
  v34 = v4;
  _XMM6 = LODWORD(FLOAT_1_0);
  v33 = v5;
  integer = 0;
  iClipSize = BG_WeaponCompleteDef(r_weapon, isAlternate)->iClipSize;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v13 = attachments;
    v14 = WeaponAttachments_Internal;
    do
    {
      if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5996, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunitionScale = (*v13)->ammunitionScale;
      if ( ammunitionScale != 0.0 )
      {
        ammunitionScale_low = LODWORD((*v13)->ammunitionScale);
        *(float *)&ammunitionScale_low = (float)(ammunitionScale + *(float *)&_XMM6) - 1.0;
        _XMM6 = ammunitionScale_low;
      }
      ++v13;
      --v14;
    }
    while ( v14 );
    v7 = ps;
  }
  v17 = 0;
  if ( WeaponAttachments_Internal )
  {
    v18 = attachments;
    while ( 1 )
    {
      ammunition = (*v18)->ammunition;
      if ( ammunition )
        break;
      ++v17;
      ++v18;
      if ( v17 >= WeaponAttachments_Internal )
        goto LABEL_16;
    }
    iClipSize = ammunition->clipSize;
  }
LABEL_16:
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v21 = LODWORD(FLOAT_1_0);
  *(float *)&v21 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v21 + 1) = (v21 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v21 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v21;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm3, xmm7, xmm2
  }
  v25 = (int)(float)(_mm_cvtepi32_ps((__m128i)iClipSize).m128_f32[0] * *(float *)&_XMM1);
  if ( v25 > 1 )
  {
    if ( v7 && BG_HasPerk(&v7->perks, 0xEu) )
    {
      switch ( BG_GetWeaponClass(r_weapon, 0) )
      {
        case WEAPCLASS_RIFLE:
          v26 = DVARINT_perk_extendedMagsRifleAmmo;
          if ( DVARINT_perk_extendedMagsRifleAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsRifleAmmo";
          break;
        case WEAPCLASS_SNIPER:
          v26 = DVARINT_perk_extendedMagsSniperAmmo;
          if ( DVARINT_perk_extendedMagsSniperAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsSniperAmmo";
          break;
        case WEAPCLASS_MG:
          v26 = DVARINT_perk_extendedMagsMGAmmo;
          if ( DVARINT_perk_extendedMagsMGAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsMGAmmo";
          break;
        case WEAPCLASS_SMG:
          v26 = DVARINT_perk_extendedMagsSMGAmmo;
          if ( DVARINT_perk_extendedMagsSMGAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsSMGAmmo";
          break;
        case WEAPCLASS_SPREAD:
          v26 = DVARINT_perk_extendedMagsSpreadAmmo;
          if ( DVARINT_perk_extendedMagsSpreadAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsSpreadAmmo";
          break;
        case WEAPCLASS_PISTOL:
          v26 = DVARINT_perk_extendedMagsPistolAmmo;
          if ( DVARINT_perk_extendedMagsPistolAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsPistolAmmo";
          break;
        case WEAPCLASS_BEAM:
          v26 = DVARINT_perk_extendedMagsBeamAmmo;
          if ( DVARINT_perk_extendedMagsBeamAmmo )
            goto LABEL_36;
          v27 = "perk_extendedMagsBeamAmmo";
          break;
        default:
          goto LABEL_37;
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v27) )
        __debugbreak();
LABEL_36:
      Dvar_CheckFrontendServerThread(v26);
      integer = v26->current.integer;
LABEL_37:
      v25 += integer;
    }
    if ( v25 <= 1 )
    {
      LODWORD(numAttachmentSlots) = v25;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6018, ASSERT_TYPE_SANITY, "( ( clipSize > 1 ) )", "( clipSize ) = %i", numAttachmentSlots) )
        __debugbreak();
    }
  }
  return (unsigned int)v25;
}

/*
==============
BG_GetDamage
==============
*/
__int64 BG_GetDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  int outMaxDamage; 
  int outMinDamage; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v8 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8665, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v8) )
      __debugbreak();
  }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (unsigned int)outMaxDamage;
}

/*
==============
BG_GetDamageRange
==============
*/
void BG_GetDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *minDamageRange, float *maxDamageRange)
{
  int ShelvedDamageRanges; 
  __int64 size; 
  __int64 v12; 
  int v13; 
  float rangeArray[4]; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v13 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9478, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v13) )
      __debugbreak();
  }
  if ( BG_UsesShelvedDamageFalloff(damageCalcType, r_weapon, isAlternate) )
  {
    if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
    {
      LODWORD(v12) = 3;
      LODWORD(size) = damageCalcType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9408, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", size, v12) )
        __debugbreak();
    }
    ShelvedDamageRanges = BG_GetShelvedDamageRanges(damageCalcType, r_weapon, isAlternate, rangeScale, rangeArray, 4);
    if ( (unsigned int)(ShelvedDamageRanges - 1) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9414, ASSERT_TYPE_ASSERT, "(( rangeCount > 0 ) && ( rangeCount <= 4 ))", (const char *)&queryFormat, "( rangeCount > 0 ) && ( rangeCount <= MAX_WEAPON_SHELF_RANGES )") )
      __debugbreak();
    *maxDamageRange = rangeArray[0];
    *minDamageRange = rangeArray[ShelvedDamageRanges - 1];
  }
  else
  {
    BG_GetLinearDamageRange(damageCalcType, r_weapon, isAlternate, rangeScale, minDamageRange, maxDamageRange);
  }
}

/*
==============
BG_GetDamageViewKickScaleValues
==============
*/
void BG_GetDamageViewKickScaleValues(const playerState_s *ps, const usercmd_s *cmd, float *viewKickScale, float *viewKickMin, float *viewKickMax)
{
  const dvar_t *v9; 
  const dvar_t *v10; 
  const dvar_t *v11; 
  const char *v12; 
  const dvar_t *v13; 
  const dvar_t *v14; 
  const dvar_t *v16; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21797, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !viewKickScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21798, ASSERT_TYPE_ASSERT, "(viewKickScale)", (const char *)&queryFormat, "viewKickScale") )
    __debugbreak();
  if ( !viewKickMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21799, ASSERT_TYPE_ASSERT, "(viewKickMin)", (const char *)&queryFormat, "viewKickMin") )
    __debugbreak();
  if ( !viewKickMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21800, ASSERT_TYPE_ASSERT, "(viewKickMax)", (const char *)&queryFormat, "viewKickMax") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM|0x80) || BG_InADS(ps) || (cmd->buttons & 0x200) != 0 )
  {
    v13 = DCONST_DVARMPFLT_bg_viewKickScale;
    if ( !DCONST_DVARMPFLT_bg_viewKickScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    *viewKickScale = v13->current.value;
    v14 = DCONST_DVARMPFLT_bg_viewKickMin;
    if ( !DCONST_DVARMPFLT_bg_viewKickMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickMin") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    *viewKickMin = v14->current.value;
    v11 = DCONST_DVARMPFLT_bg_viewKickMax;
    if ( !DCONST_DVARMPFLT_bg_viewKickMax )
    {
      v12 = "bg_viewKickMax";
LABEL_35:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v12) )
        __debugbreak();
    }
  }
  else
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21811, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::NON_ADS_VIEW_KICK_VALUES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::NON_ADS_VIEW_KICK_VALUES )") )
      __debugbreak();
    v9 = DCONST_DVARMPFLT_bg_viewKickScaleNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickScaleNonADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickScaleNonADS") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    *viewKickScale = v9->current.value;
    v10 = DCONST_DVARMPFLT_bg_viewKickMinNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickMinNonADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickMinNonADS") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    *viewKickMin = v10->current.value;
    v11 = DCONST_DVARMPFLT_bg_viewKickMaxNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickMaxNonADS )
    {
      v12 = "bg_viewKickMaxNonADS";
      goto LABEL_35;
    }
  }
  Dvar_CheckFrontendServerThread(v11);
  _XMM0 = v11->current.unsignedInt;
  *viewKickMax = *(float *)&_XMM0;
  if ( ps->damageModFlags == 0x80000 )
  {
    v16 = DCONST_DVARFLT_bg_viewkickModFireScale;
    if ( !DCONST_DVARFLT_bg_viewkickModFireScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewkickModFireScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    *viewKickScale = v16->current.value * *viewKickScale;
    _XMM1 = *(unsigned int *)viewKickMin;
    __asm { vminss  xmm2, xmm1, xmm2 }
    *viewKickMin = *(float *)&_XMM2;
    _XMM0 = *(unsigned int *)viewKickMax;
    __asm { vmaxss  xmm1, xmm0, xmm2 }
  }
  else
  {
    __asm { vmaxss  xmm1, xmm0, dword ptr [r14] }
  }
  *viewKickMax = *(float *)&_XMM1;
}

/*
==============
BG_GetDynamicAttachmentSlot
==============
*/
__int64 BG_GetDynamicAttachmentSlot(const DynamicAttachmentType dynamicAttachmentType)
{
  __int64 result; 

  switch ( dynamicAttachmentType )
  {
    case DYNAMIC_ATTACHMENT_TYPE_MUZZLE:
      result = 5i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_UNDERBARREL:
      result = 10i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_LASER:
      result = 8i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_MAGAZINE:
      result = 3i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_RECEIVER:
      result = 0i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_SCOPE:
      result = 9i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_STOCK:
      result = 2i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_BARREL:
      result = 1i64;
      break;
    default:
      result = 13i64;
      break;
  }
  return result;
}

/*
==============
BG_GetEnemyCrossHairRange
==============
*/
float BG_GetEnemyCrossHairRange(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float enemyCrosshairRange; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  enemyCrosshairRange = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->enemyCrosshairRange;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return enemyCrosshairRange;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8168, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return enemyCrosshairRange;
  }
  return general->enemyCrosshairRange;
}

/*
==============
BG_GetEnemyLaserType
==============
*/
const LaserDef *BG_GetEnemyLaserType(const Weapon *r_weapon, bool isBeamDraw)
{
  const WeaponDef *v4; 
  const LaserDef *result; 
  LaserDef *viewModelLaser; 
  LaserDef *friendlyLaser; 
  LaserDef *enemyLaser; 
  LaserDef *viewModelLaserAlt; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !isBeamDraw && v4->tracerStyle == TRACERSTYLE_BEAM )
    return 0i64;
  viewModelLaser = NULL;
  viewModelLaserAlt = NULL;
  friendlyLaser = NULL;
  enemyLaser = NULL;
  BG_GetLasers(r_weapon, (const LaserDef **)&viewModelLaser, (const LaserDef **)&viewModelLaserAlt, (const LaserDef **)&friendlyLaser, (const LaserDef **)&enemyLaser);
  result = friendlyLaser;
  if ( enemyLaser )
    return enemyLaser;
  return result;
}

/*
==============
BG_GetExplosionDamageFromRangeInfo
==============
*/
float BG_GetExplosionDamageFromRangeInfo(const BgExplosionDamageRangeInfo *damageRangeInfo, const float distance)
{
  if ( damageRangeInfo->useSteppedDamage )
  {
    if ( distance > damageRangeInfo->innerRadius )
    {
      if ( distance > damageRangeInfo->midRadius )
      {
        if ( distance > damageRangeInfo->outerRadius )
          return 0.0;
        else
          return damageRangeInfo->outerDamage;
      }
      else
      {
        return damageRangeInfo->midDamage;
      }
    }
    else
    {
      return damageRangeInfo->innerDamage;
    }
  }
  else
  {
    _XMM0 = LODWORD(damageRangeInfo->outerRadius);
    __asm { vmaxss  xmm0, xmm0, xmm2 }
    return (float)((float)(1.0 - (float)(distance / *(float *)&_XMM0)) * (float)(damageRangeInfo->innerDamage - damageRangeInfo->outerDamage)) + damageRangeInfo->outerDamage;
  }
}

/*
==============
BG_GetExplosionDamageRangeInfo
==============
*/
void BG_GetExplosionDamageRangeInfo(const Weapon *r_weapon, bool isAlternate, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  BgExplosionDamageRangeInfo *v4; 
  const WeaponDef *v6; 
  unsigned int v7; 
  unsigned int WeaponAttachments_Internal; 
  bool v9; 
  WeaponAttachment *v10; 
  int iExplosionSteppedRadiusInner; 
  int iExplosionSteppedDamageInner; 
  int iExplosionSteppedRadiusMid; 
  int iExplosionSteppedRadiusOuter; 
  int iExplosionSteppedDamageMid; 
  int iExplosionSteppedDamageOuter; 
  int *p_explosionRadius; 
  float v18; 
  AttProjectile *projectile; 
  int v20; 
  int iExplosionInnerDamage; 
  int v23; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  v4 = outDamageRangeInfo;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v7 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = BG_ExplosionUsesSteppedDamage(r_weapon, isAlternate);
  v10 = attachments;
  v4->useSteppedDamage = v9;
  if ( v9 )
  {
    iExplosionSteppedRadiusInner = v6->iExplosionSteppedRadiusInner;
    iExplosionSteppedDamageInner = v6->iExplosionSteppedDamageInner;
    iExplosionSteppedRadiusMid = v6->iExplosionSteppedRadiusMid;
    iExplosionSteppedRadiusOuter = v6->iExplosionSteppedRadiusOuter;
    iExplosionSteppedDamageMid = v6->iExplosionSteppedDamageMid;
    iExplosionSteppedDamageOuter = v6->iExplosionSteppedDamageOuter;
    v23 = iExplosionSteppedRadiusInner;
    v20 = iExplosionSteppedDamageInner;
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16854, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        p_explosionRadius = &v10->projectile->explosionRadius;
        if ( p_explosionRadius )
          break;
        ++v7;
        ++v10;
        if ( v7 >= WeaponAttachments_Internal )
        {
          iExplosionSteppedDamageInner = v20;
          v4 = outDamageRangeInfo;
          v18 = (float)v23;
          goto LABEL_21;
        }
      }
      iExplosionSteppedRadiusMid = p_explosionRadius[6];
      iExplosionSteppedRadiusOuter = p_explosionRadius[7];
      iExplosionSteppedDamageInner = p_explosionRadius[8];
      iExplosionSteppedDamageMid = p_explosionRadius[9];
      iExplosionSteppedDamageOuter = p_explosionRadius[10];
      v4 = outDamageRangeInfo;
      v18 = (float)p_explosionRadius[5];
    }
    else
    {
      v18 = (float)iExplosionSteppedRadiusInner;
    }
  }
  else
  {
    iExplosionSteppedRadiusMid = v6->iExplosionRadius;
    iExplosionSteppedDamageMid = v6->iExplosionOuterDamage;
    iExplosionInnerDamage = v6->iExplosionInnerDamage;
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16885, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        projectile = v10->projectile;
        if ( projectile )
          break;
        ++v7;
        ++v10;
        if ( v7 >= WeaponAttachments_Internal )
        {
          iExplosionSteppedDamageInner = iExplosionInnerDamage;
          v4 = outDamageRangeInfo;
          goto LABEL_20;
        }
      }
      iExplosionSteppedRadiusMid = projectile->explosionRadius;
      iExplosionSteppedDamageInner = projectile->explosionInnerDamage;
      iExplosionSteppedDamageMid = projectile->explosionOuterDamage;
      v4 = outDamageRangeInfo;
    }
    else
    {
      iExplosionSteppedDamageInner = v6->iExplosionInnerDamage;
    }
LABEL_20:
    v18 = 0.0;
    iExplosionSteppedRadiusOuter = iExplosionSteppedRadiusMid;
    iExplosionSteppedDamageOuter = iExplosionSteppedDamageMid;
  }
LABEL_21:
  v4->innerRadius = v18;
  v4->midRadius = (float)iExplosionSteppedRadiusMid;
  v4->outerRadius = (float)iExplosionSteppedRadiusOuter;
  v4->innerDamage = (float)iExplosionSteppedDamageInner;
  v4->midDamage = (float)iExplosionSteppedDamageMid;
  v4->outerDamage = (float)iExplosionSteppedDamageOuter;
}

/*
==============
BG_GetExplosionReactiveMotionParams
==============
*/
void BG_GetExplosionReactiveMotionParams(const Weapon *r_weapon, bool isAlternate, float *radiusScale, float *frequencyScale, float *amplitudeScale, float *falloff, float *lifetime)
{
  const WeaponDef *v11; 
  int v12; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v15; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !radiusScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16974, ASSERT_TYPE_ASSERT, "(radiusScale)", (const char *)&queryFormat, "radiusScale") )
    __debugbreak();
  if ( !frequencyScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16975, ASSERT_TYPE_ASSERT, "(frequencyScale)", (const char *)&queryFormat, "frequencyScale") )
    __debugbreak();
  if ( !amplitudeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16976, ASSERT_TYPE_ASSERT, "(amplitudeScale)", (const char *)&queryFormat, "amplitudeScale") )
    __debugbreak();
  if ( !falloff && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16977, ASSERT_TYPE_ASSERT, "(falloff)", (const char *)&queryFormat, "falloff") )
    __debugbreak();
  if ( !lifetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16978, ASSERT_TYPE_ASSERT, "(lifetime)", (const char *)&queryFormat, "lifetime") )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = 0;
  *radiusScale = v11->reactiveMotionRadiusScale;
  *frequencyScale = v11->reactiveMotionFrequencyScale;
  *amplitudeScale = v11->reactiveMotionAmplitudeScale;
  *falloff = v11->reactiveMotionFalloff;
  *lifetime = v11->reactiveMotionLifetime;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16991, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v15 = *i;
      projectile = (*i)->projectile;
      if ( projectile )
        break;
      if ( ++v12 >= WeaponAttachments_Internal )
        return;
    }
    *radiusScale = projectile->reactiveMotionRadiusScale;
    *frequencyScale = v15->projectile->reactiveMotionFrequencyScale;
    *amplitudeScale = v15->projectile->reactiveMotionAmplitudeScale;
    *falloff = v15->projectile->reactiveMotionFalloff;
    *lifetime = v15->projectile->reactiveMotionLifetime;
  }
}

/*
==============
BG_GetFireAnimTime
==============
*/
__int64 BG_GetFireAnimTime(const Weapon *r_weapon, const bool isAlternate, __int64 isDualWielding, const playerState_s *const ps, const BgHandler *pmoveHandler, const weapAnimFiles_t anim)
{
  weapAnimFiles_t v6; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  const char *v14; 
  char v15[512]; 
  char output[512]; 

  v6 = anim;
  if ( anim != WEAP_ANIM_LASTSHOT && anim != WEAP_ANIM_FIRE && (unsigned int)(anim - 346) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9711, ASSERT_TYPE_ASSERT, "((anim == WEAP_ANIM_LASTSHOT) || (anim == WEAP_ANIM_FIRE) || (anim == WEAP_ANIM_ADS_FIRE) || (anim == WEAP_ANIM_ADS_LASTSHOT) || (anim == WEAP_ANIM_ADS_FIRE_NVG) || (anim == WEAP_ANIM_ADS_LASTSHOT_NVG))", (const char *)&queryFormat, "(anim == WEAP_ANIM_LASTSHOT) || (anim == WEAP_ANIM_FIRE) || (anim == WEAP_ANIM_ADS_FIRE) || (anim == WEAP_ANIM_ADS_LASTSHOT) || (anim == WEAP_ANIM_ADS_FIRE_NVG) || (anim == WEAP_ANIM_ADS_LASTSHOT_NVG)") )
    __debugbreak();
  v10 = ((__int64 (__fastcall *)(const BgHandler *, const playerState_s *const, __int64))pmoveHandler->PlayerWeaponAnimsConst)(pmoveHandler, ps, isDualWielding);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9714, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( memcmp_0((const void *)(v10 + 16660), r_weapon, 0x3Cui64) )
  {
    BG_GetWeaponName((const Weapon *)(v10 + 16660), output, 0x200u);
    BG_GetWeaponName(r_weapon, v15, 0x200u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9724, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetFireAnimTime(): Unexpected weapon anim array.  Have '%s', expected '%s'.", output, v15) )
      __debugbreak();
  }
  if ( isAlternate )
  {
    if ( (unsigned int)anim >= NUM_WEAP_ANIMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9730, ASSERT_TYPE_ASSERT, "(anim < ( sizeof( *array_counter( weaponAnimArrays->altAnimArray ) ) + 0 ))", (const char *)&queryFormat, "anim < ARRAY_COUNT( weaponAnimArrays->altAnimArray )") )
      __debugbreak();
    v10 += 4976i64;
  }
  else if ( (unsigned int)anim >= NUM_WEAP_ANIMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9735, ASSERT_TYPE_ASSERT, "(anim < ( sizeof( *array_counter( weaponAnimArrays->normalAnimArray ) ) + 0 ))", (const char *)&queryFormat, "anim < ARRAY_COUNT( weaponAnimArrays->normalAnimArray )") )
  {
    __debugbreak();
  }
  v11 = *(_QWORD *)(v10 + 8i64 * (int)anim);
  v12 = v11;
  if ( !v11 )
    v12 = *(_QWORD *)(v10 + 1912);
  if ( v12 )
  {
    if ( *(float *)(v12 + 100) <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9749, ASSERT_TYPE_ASSERT, "(animParts->framerate > 0.0f)", (const char *)&queryFormat, "animParts->framerate > 0.0f") )
      __debugbreak();
    return (unsigned int)(int)(float)((float)((float)*(unsigned __int16 *)(v12 + 118) * 1000.0) / *(float *)(v12 + 100));
  }
  else
  {
    BG_GetWeaponName(r_weapon, v15, 0x200u);
    v14 = "normal";
    if ( isAlternate )
      v14 = "alt";
    if ( !v11 )
      v6 = WEAP_ANIM_FIRE;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F5A1D0, 547i64, (unsigned int)v6, v14, v15);
    return 0i64;
  }
}

/*
==============
BG_GetFireTime
==============
*/
void BG_GetFireTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  BG_GetFireTimeWithHand(weaponMap, ps, WEAPON_HAND_DEFAULT, 0, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_GetFireTimeWithHand
==============
*/
void BG_GetFireTimeWithHand(const BgWeaponMap *weaponMap, const playerState_s *ps, const PlayerHandIndex hand, const bool adjustForHyperBurst, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  const WeaponDef *v13; 
  const WeaponDef *v14; 
  float changedFireTimeAkimbo; 
  unsigned int changedFireTimeNumBullets; 
  __m128 v19; 
  int v21; 
  int iFireDelayAkimbo; 
  float changedFireTime; 
  unsigned int v24; 
  __m128 v26; 
  int v28; 
  int fireTimeOverride; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v32; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  char *v34; 
  unsigned int v35; 
  __int64 v36; 
  __int64 v37; 
  int v38; 
  int v39; 
  __int128 v40; 
  __int64 v41; 
  int v42; 
  int v43; 
  __int128 v44; 
  __int64 v45; 
  int v46; 
  int v47; 
  __int128 v48; 
  __int64 v49; 
  int v50; 
  int v51; 
  __int128 v52; 
  WeaponAttachment **v53; 
  __int64 i; 
  WeaponAttachment *v55; 
  AttachmentType type; 
  int fireTimeAkimboOverride; 
  __int128 v58; 
  const WeaponDef *v59; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v61; 
  const AttADSSettings *WeaponAdsSettings; 
  const WeaponDef *v69; 
  const PlayerEquippedWeaponState *v70; 
  bool v71; 
  const AttADSSettings *v73; 
  float v76; 
  __int128 v78; 
  const Weapon *CurrentWeaponForPlayer; 
  __int128 v80; 
  int *v81; 
  __int128 v83; 
  __int128 v87; 
  unsigned int v91; 
  unsigned int v92; 
  WeaponAttachment **v93; 
  HyperBurstInfo *hyperBurstInfo; 
  const WeaponDef *v95; 
  int v96; 
  int v99; 
  int v100; 
  __int64 numAttachmentSlots; 
  float v103; 
  float rateofFire; 
  PlayerHandIndex handa; 
  int *v106; 
  WeaponAttachment *attachments; 
  char v108; 
  WeaponAttachment *v109[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v111[32]; 

  handa = hand;
  v106 = fireTime;
  if ( !fireTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9544, ASSERT_TYPE_ASSERT, "(fireTime)", (const char *)&queryFormat, "fireTime") )
    __debugbreak();
  if ( !fireDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9545, ASSERT_TYPE_ASSERT, "(fireDelay)", (const char *)&queryFormat, "fireDelay") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(numAttachmentSlots) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9546, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", numAttachmentSlots, 2) )
      __debugbreak();
  }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9551, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v13 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v14 = v13;
  if ( isDualWielding )
  {
    *fireTime = v13->iFireTimeAkimbo;
    if ( (v13->changedFireTimeAkimbo == 0.0) != (v13->changedFireTimeNumBullets == 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9560, ASSERT_TYPE_ASSERT, "((weapDef->changedFireTimeAkimbo == 0) == (weapDef->changedFireTimeNumBullets == 0))", (const char *)&queryFormat, "(weapDef->changedFireTimeAkimbo == 0) == (weapDef->changedFireTimeNumBullets == 0)") )
      __debugbreak();
    changedFireTimeAkimbo = v14->changedFireTimeAkimbo;
    _XMM9 = LODWORD(FLOAT_1_0);
    if ( changedFireTimeAkimbo != 0.0 )
    {
      changedFireTimeNumBullets = v14->changedFireTimeNumBullets;
      if ( changedFireTimeNumBullets )
      {
        v19 = _mm_cvtepi32_ps((__m128i)(unsigned int)shotCount);
        v19.m128_f32[0] = v19.m128_f32[0] / _mm_cvtepi32_ps((__m128i)changedFireTimeNumBullets).m128_f32[0];
        _XMM1 = v19;
        __asm { vminss  xmm3, xmm1, xmm9 }
        v21 = v14->iFireTimeAkimbo + (int)(float)((float)(*(float *)&_XMM3 * (float)((float)(changedFireTimeAkimbo * 1000.0) - _mm_cvtepi32_ps((__m128i)(unsigned int)v14->iFireTimeAkimbo).m128_f32[0])) + 0.5);
        if ( v21 < 50 )
          v21 = 50;
        *fireTime = v21;
      }
    }
    iFireDelayAkimbo = v14->iFireDelayAkimbo;
  }
  else
  {
    *fireTime = v13->iFireTime;
    if ( (v13->changedFireTime == 0.0) != (v13->changedFireTimeNumBullets == 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9574, ASSERT_TYPE_ASSERT, "((weapDef->changedFireTime == 0) == (weapDef->changedFireTimeNumBullets == 0))", (const char *)&queryFormat, "(weapDef->changedFireTime == 0) == (weapDef->changedFireTimeNumBullets == 0)") )
      __debugbreak();
    changedFireTime = v14->changedFireTime;
    _XMM9 = LODWORD(FLOAT_1_0);
    if ( changedFireTime != 0.0 )
    {
      v24 = v14->changedFireTimeNumBullets;
      if ( v24 )
      {
        v26 = _mm_cvtepi32_ps((__m128i)(unsigned int)shotCount);
        v26.m128_f32[0] = v26.m128_f32[0] / _mm_cvtepi32_ps((__m128i)v24).m128_f32[0];
        _XMM1 = v26;
        __asm { vminss  xmm3, xmm1, xmm9 }
        v28 = v14->iFireTime + (int)(float)((float)(*(float *)&_XMM3 * (float)((float)(changedFireTime * 1000.0) - _mm_cvtepi32_ps((__m128i)(unsigned int)v14->iFireTime).m128_f32[0])) + 0.5);
        if ( v28 < 50 )
          v28 = 50;
        *fireTime = v28;
      }
    }
    iFireDelayAkimbo = v14->iFireDelay;
  }
  *fireDelay = iFireDelayAkimbo;
  fireTimeOverride = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM8 = _XMM9;
  v32 = 0i64;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponAttachments_Internal >= 4 )
  {
    v34 = &v108;
    v35 = ((WeaponAttachments_Internal - 4) >> 2) + 1;
    v36 = v35;
    v32 = 4 * v35;
    do
    {
      v37 = *((_QWORD *)v34 - 1);
      if ( !v37 )
        goto LABEL_47;
      if ( !fireTimeOverride )
      {
        v38 = *(_DWORD *)(v37 + 28);
        if ( isDualWielding )
        {
          v39 = *(_DWORD *)(v37 + 704);
          if ( v39 && (v38 != 1 || WeaponPrimaryAttachment == (const WeaponAttachment *)v37) )
          {
LABEL_41:
            fireTimeOverride = v39;
            goto LABEL_47;
          }
        }
        else
        {
          v39 = *(_DWORD *)(v37 + 700);
          if ( v39 )
          {
            if ( v38 != 1 )
              goto LABEL_41;
            if ( WeaponPrimaryAttachment == (const WeaponAttachment *)v37 )
            {
              fireTimeOverride = *(_DWORD *)(v37 + 700);
              goto LABEL_47;
            }
          }
        }
      }
      v40 = _XMM8;
      *(float *)&v40 = (float)(*(float *)&_XMM8 + *(float *)(v37 + 708)) - *(float *)&_XMM9;
      _XMM8 = v40;
LABEL_47:
      v41 = *(_QWORD *)v34;
      if ( !*(_QWORD *)v34 )
        goto LABEL_59;
      if ( !fireTimeOverride )
      {
        v42 = *(_DWORD *)(v41 + 28);
        if ( isDualWielding )
        {
          v43 = *(_DWORD *)(v41 + 704);
          if ( v43 && (v42 != 1 || WeaponPrimaryAttachment == (const WeaponAttachment *)v41) )
          {
LABEL_53:
            fireTimeOverride = v43;
            goto LABEL_59;
          }
        }
        else
        {
          v43 = *(_DWORD *)(v41 + 700);
          if ( v43 )
          {
            if ( v42 != 1 )
              goto LABEL_53;
            if ( WeaponPrimaryAttachment == (const WeaponAttachment *)v41 )
            {
              fireTimeOverride = *(_DWORD *)(v41 + 700);
              goto LABEL_59;
            }
          }
        }
      }
      v44 = _XMM8;
      *(float *)&v44 = (float)(*(float *)&_XMM8 + *(float *)(v41 + 708)) - *(float *)&_XMM9;
      _XMM8 = v44;
LABEL_59:
      v45 = *((_QWORD *)v34 + 1);
      if ( !v45 )
        goto LABEL_71;
      if ( !fireTimeOverride )
      {
        v46 = *(_DWORD *)(v45 + 28);
        if ( isDualWielding )
        {
          v47 = *(_DWORD *)(v45 + 704);
          if ( v47 && (v46 != 1 || WeaponPrimaryAttachment == (const WeaponAttachment *)v45) )
          {
LABEL_65:
            fireTimeOverride = v47;
            goto LABEL_71;
          }
        }
        else
        {
          v47 = *(_DWORD *)(v45 + 700);
          if ( v47 )
          {
            if ( v46 != 1 )
              goto LABEL_65;
            if ( WeaponPrimaryAttachment == (const WeaponAttachment *)v45 )
            {
              fireTimeOverride = *(_DWORD *)(v45 + 700);
              goto LABEL_71;
            }
          }
        }
      }
      v48 = _XMM8;
      *(float *)&v48 = (float)(*(float *)&_XMM8 + *(float *)(v45 + 708)) - *(float *)&_XMM9;
      _XMM8 = v48;
LABEL_71:
      v49 = *((_QWORD *)v34 + 2);
      if ( v49 )
      {
        if ( fireTimeOverride )
          goto LABEL_82;
        v50 = *(_DWORD *)(v49 + 28);
        if ( isDualWielding )
        {
          v51 = *(_DWORD *)(v49 + 704);
          if ( !v51 || v50 == 1 && WeaponPrimaryAttachment != (const WeaponAttachment *)v49 )
          {
LABEL_82:
            v52 = _XMM8;
            *(float *)&v52 = (float)(*(float *)&_XMM8 + *(float *)(v49 + 708)) - *(float *)&_XMM9;
            _XMM8 = v52;
            goto LABEL_83;
          }
LABEL_77:
          fireTimeOverride = v51;
          goto LABEL_83;
        }
        v51 = *(_DWORD *)(v49 + 700);
        if ( !v51 )
          goto LABEL_82;
        if ( v50 != 1 )
          goto LABEL_77;
        if ( WeaponPrimaryAttachment != (const WeaponAttachment *)v49 )
          goto LABEL_82;
        fireTimeOverride = *(_DWORD *)(v49 + 700);
      }
LABEL_83:
      v34 += 32;
      --v36;
    }
    while ( v36 );
  }
  if ( (unsigned int)v32 < WeaponAttachments_Internal )
  {
    v53 = &attachments + v32;
    for ( i = WeaponAttachments_Internal - (unsigned int)v32; i; --i )
    {
      v55 = *v53;
      if ( *v53 )
      {
        if ( fireTimeOverride )
          goto LABEL_97;
        type = v55->type;
        if ( isDualWielding )
        {
          fireTimeAkimboOverride = v55->fireTimeAkimboOverride;
          if ( !fireTimeAkimboOverride || type == ATTACHMENT_UNDERBARREL && WeaponPrimaryAttachment != v55 )
          {
LABEL_97:
            v58 = _XMM8;
            *(float *)&v58 = (float)(*(float *)&_XMM8 + v55->fireTimersScale) - *(float *)&_XMM9;
            _XMM8 = v58;
            goto LABEL_98;
          }
LABEL_92:
          fireTimeOverride = fireTimeAkimboOverride;
          goto LABEL_98;
        }
        fireTimeAkimboOverride = v55->fireTimeOverride;
        if ( !fireTimeAkimboOverride )
          goto LABEL_97;
        if ( type != ATTACHMENT_UNDERBARREL )
          goto LABEL_92;
        if ( WeaponPrimaryAttachment != v55 )
          goto LABEL_97;
        fireTimeOverride = v55->fireTimeOverride;
      }
LABEL_98:
      ++v53;
    }
  }
  if ( fireTimeOverride )
    *v106 = fireTimeOverride;
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13633, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v59 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v61 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(v59->adsFireRateScale);
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v61, 0);
  if ( WeaponAdsSettings )
    _XMM6 = LODWORD(WeaponAdsSettings->adsFireRateScale);
  __asm
  {
    vcmpeqss xmm0, xmm6, xmm10
    vblendvps xmm1, xmm6, xmm9, xmm0
  }
  rateofFire = *(float *)&_XMM1;
  BG_GameInterface_ModifyRateOfFireForWeapon(ps, r_weapon, &rateofFire);
  _XMM1 = LODWORD(rateofFire);
  __asm
  {
    vcmpneqss xmm0, xmm1, xmm10
    vblendvps xmm0, xmm9, xmm1, xmm0
  }
  v103 = *(float *)&_XMM0;
  if ( !ps )
  {
    v76 = *(float *)&_XMM9;
LABEL_126:
    v78 = LODWORD(v103);
    *(float *)&v78 = v103 * v76;
    _XMM7 = v78;
    goto LABEL_127;
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13687, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v69 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v71 = weaponMap && (v70 = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && v70->hybridScope;
  _XMM6 = LODWORD(v69->fireTimerLerpToAdsScale);
  v73 = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v71, 0);
  if ( v73 )
  {
    _XMM1 = LODWORD(v73->fireTimerLerpToAdsScale);
    __asm
    {
      vcmpneqss xmm0, xmm1, xmm10
      vblendvps xmm6, xmm6, xmm1, xmm0
    }
  }
  if ( *(float *)&_XMM6 != 0.0 )
  {
    v76 = (float)(ps->weapCommon.fWeaponPosFrac * *(float *)&_XMM6) + (float)(*(float *)&_XMM9 - ps->weapCommon.fWeaponPosFrac);
    if ( v76 != 0.0 )
      goto LABEL_126;
  }
  _XMM7 = LODWORD(v103);
LABEL_127:
  if ( ps )
  {
    if ( ps->fireTimeScale )
    {
      CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
      if ( !memcmp_0(CurrentWeaponForPlayer, r_weapon, 0x3Cui64) )
      {
        v80 = _XMM7;
        *(float *)&v80 = *(float *)&_XMM7 * (float)((float)ps->fireTimeScale * 0.0099999998);
        _XMM7 = v80;
      }
    }
  }
  v81 = v106;
  __asm { vmaxss  xmm2, xmm8, xmm10 }
  v83 = _XMM9;
  *(float *)&v83 = *(float *)&_XMM9 - *(float *)&_XMM2;
  *((_QWORD *)&v83 + 1) = (v83 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v83 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&_XMM9 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v83;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm9, xmm0
  }
  v87 = _XMM9;
  *(float *)&v87 = *(float *)&_XMM9 - *(float *)&_XMM7;
  *((_QWORD *)&v87 + 1) = (v87 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v87 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&_XMM9 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v87;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm9, xmm2
  }
  *v106 = (int)(float)((float)(*(float *)&_XMM0 * _mm_cvtepi32_ps((__m128i)(unsigned int)*v106).m128_f32[0]) * *(float *)&_XMM5);
  if ( ps && adjustForHyperBurst )
  {
    v91 = 0;
    v92 = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)v109, v111, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( v92 )
    {
      v93 = v109;
      while ( 1 )
      {
        if ( !*v93 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22322, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        hyperBurstInfo = (*v93)->hyperBurstInfo;
        if ( hyperBurstInfo )
          break;
        ++v91;
        ++v93;
        if ( v91 >= v92 )
          goto LABEL_140;
      }
    }
    else
    {
LABEL_140:
      v95 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
      hyperBurstInfo = &v95->hyperBurstInfo;
      if ( v95 == (const WeaponDef *)-5272i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9660, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
        __debugbreak();
    }
    if ( hyperBurstInfo->enabled && (shotCount == 1 || !shotCount && BG_GetAmmoInClipForWeapon(ps, r_weapon, isAlternate, handa) >= 2) )
    {
      v96 = *v81;
      _XMM0 = 0i64;
      __asm { vroundss xmm4, xmm0, xmm2, 1 }
      v99 = (int)*(float *)&_XMM4;
      if ( (int)*(float *)&_XMM4 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9684, ASSERT_TYPE_ASSERT, "( firstHyperRoundFireTime ) > ( 0 )", "%s > %s\n\t%i, %i", "firstHyperRoundFireTime", "0", (int)*(float *)&_XMM4, 0i64) )
        __debugbreak();
      v100 = v96 - v99;
      if ( shotCount )
        *v81 = v100;
      else
        *v81 = v99;
    }
  }
}

/*
==============
BG_GetFireTimerLerpToADSScale
==============
*/
float BG_GetFireTimerLerpToADSScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 
  float result; 

  if ( !ps )
    return FLOAT_1_0;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13687, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(v8->fireTimerLerpToAdsScale);
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  result = 0.0;
  if ( WeaponAdsSettings )
  {
    _XMM2 = LODWORD(WeaponAdsSettings->fireTimerLerpToAdsScale);
    __asm
    {
      vcmpneqss xmm1, xmm2, xmm0
      vblendvps xmm6, xmm6, xmm2, xmm1
    }
  }
  if ( *(float *)&_XMM6 != 0.0 )
    return (float)(ps->weapCommon.fWeaponPosFrac * *(float *)&_XMM6) + (float)(1.0 - ps->weapCommon.fWeaponPosFrac);
  return result;
}

/*
==============
BG_GetFirstAvailableOffhandByClass
==============
*/
const Weapon *BG_GetFirstAvailableOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return BG_GetFirstEquippedOffhand(weaponMap, ps, OFFHAND_SLOT_NONE, offhandClass, 1);
}

/*
==============
BG_GetFirstAvailableOffhandBySlot
==============
*/
Weapon *BG_GetFirstAvailableOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  int OffhandClass; 

  OffhandClass = BG_GetOffhandClass(ps, slot, weaponMap);
  if ( slot == OFFHAND_SLOT_TAUNT || OffhandClass )
    return (Weapon *)BG_GetFirstEquippedOffhand(weaponMap, ps, slot, OffhandClass, 1);
  else
    return &NULL_WEAPON;
}

/*
==============
BG_GetFirstEquippedOffhand
==============
*/
Weapon *BG_GetFirstEquippedOffhand(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot, const int offhandClass, const int requiringAmmo)
{
  char v9; 
  unsigned int v11; 
  const Weapon *Weapon; 
  const WeaponDef *v13; 
  int EquippedWeaponIndex; 
  OffhandSlot *v15; 
  const char *WeaponName; 
  __int64 v17; 
  __int64 v18; 
  char output[1024]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2597, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2598, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned __int8)(slot - 4) <= 1u )
  {
    v9 = 1;
  }
  else
  {
    v9 = 0;
    if ( !offhandClass )
      return &NULL_WEAPON;
  }
  v11 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v11 >= 0xF )
    {
      LODWORD(v18) = 15;
      LODWORD(v17) = v11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v17, v18) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v11]);
    if ( Weapon->weaponIdx )
    {
      v13 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( v9 || v13->offhandClass == offhandClass )
      {
        if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1063, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1064, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon);
        v15 = EquippedWeaponIndex < 0 ? (OffhandSlot *)10 : &ps->weapEquippedData[EquippedWeaponIndex].offhandSlot;
        if ( (slot == OFFHAND_SLOT_NONE || *v15 == slot) && (!requiringAmmo || slot == OFFHAND_SLOT_TAUNT || BG_GetAmmoInClipForWeapon(ps, Weapon, 0, WEAPON_HAND_DEFAULT) > 0 || offhandClass == 1 && ps->throwbackGrenadeTimeLeft > 0) )
          break;
      }
    }
    if ( (int)++v11 >= 15 )
      return &NULL_WEAPON;
  }
  if ( Weapon->weaponIdx && BG_WeaponDefAtIndex(Weapon->weaponIdx)->offhandClass == OFFHAND_CLASS_NONE )
  {
    WeaponName = BG_GetWeaponName(Weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5008, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Weapon (%s) expected to be offhand weapon or no weapon at all, but is not.", WeaponName) )
      __debugbreak();
  }
  return (Weapon *)Weapon;
}

/*
==============
BG_GetFirstEquippedOffhandByClass
==============
*/
Weapon *BG_GetFirstEquippedOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return BG_GetFirstEquippedOffhand(weaponMap, ps, OFFHAND_SLOT_NONE, offhandClass, 0);
}

/*
==============
BG_GetFirstEquippedOffhandBySlot
==============
*/
Weapon *BG_GetFirstEquippedOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  int OffhandClass; 

  OffhandClass = BG_GetOffhandClass(ps, slot, weaponMap);
  if ( slot == OFFHAND_SLOT_TAUNT || OffhandClass )
    return BG_GetFirstEquippedOffhand(weaponMap, ps, slot, OffhandClass, 0);
  else
    return &NULL_WEAPON;
}

/*
==============
BG_GetFirstEquippedWeaponBySlot
==============
*/
Weapon *BG_GetFirstEquippedWeaponBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  unsigned int i; 
  const Weapon *Weapon; 
  const WeaponDef *v8; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  weapInventoryType_t inventoryType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4824, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4825, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
    {
      v8 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( Weapon->weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      inventoryType = v8->inventoryType;
      if ( (inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY) && *(_DWORD *)p_slot == slot )
        return (Weapon *)Weapon;
    }
  }
  return &NULL_WEAPON;
}

/*
==============
BG_GetFootstepFromAnim
==============
*/
__int64 BG_GetFootstepFromAnim(weapAnimFiles_t animIndex)
{
  __int64 result; 
  int v4; 

  if ( (unsigned int)animIndex >= NUM_WEAP_ANIMS )
  {
    v4 = 614;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", animIndex, v4) )
      __debugbreak();
  }
  result = 0i64;
  while ( FootstepToAnimMap[result] != animIndex )
  {
    if ( (unsigned __int64)++result >= 9 )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
BG_GetFootstepFromGesture
==============
*/
__int64 BG_GetFootstepFromGesture(gestureAnimType_t gestureIndex)
{
  __int64 result; 
  int v4; 

  if ( (unsigned int)gestureIndex >= GESTUREANIMTYPE_NUM )
  {
    v4 = 54;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21762, ASSERT_TYPE_ASSERT, "(unsigned)( gestureIndex ) < (unsigned)( GESTUREANIMTYPE_NUM )", "gestureIndex doesn't index GESTUREANIMTYPE_NUM\n\t%i not in [0, %i)", gestureIndex, v4) )
      __debugbreak();
  }
  result = 9i64;
  while ( FootstepToAnimMap[result] != gestureIndex )
  {
    if ( (unsigned __int64)++result >= 0xD )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
BG_GetFreeEquipSlot
==============
*/
__int64 BG_GetFreeEquipSlot(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  unsigned int v4; 
  __int64 v6; 
  __int64 v7; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6857, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6858, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v4 >= 0xF )
    {
      LODWORD(v7) = 15;
      LODWORD(v6) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( !BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4])->weaponIdx )
      break;
    if ( (int)++v4 >= 15 )
      return 0xFFFFFFFFi64;
  }
  return v4;
}

/*
==============
BG_GetFriendlyLaserType
==============
*/
const LaserDef *BG_GetFriendlyLaserType(const Weapon *r_weapon, const bool isPlayerView, const bool isBeamDraw)
{
  const WeaponDef *v6; 
  const LaserDef *result; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  LaserDef *enemyLaser; 
  LaserDef *friendlyLaser; 
  LaserDef *viewModelLaserAlt; 
  LaserDef *viewModelLaser; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !isBeamDraw && v6->tracerStyle == TRACERSTYLE_BEAM )
    return 0i64;
  viewModelLaser = NULL;
  viewModelLaserAlt = NULL;
  friendlyLaser = NULL;
  enemyLaser = NULL;
  BG_GetLasers(r_weapon, (const LaserDef **)&viewModelLaser, (const LaserDef **)&viewModelLaserAlt, (const LaserDef **)&friendlyLaser, (const LaserDef **)&enemyLaser);
  if ( !isPlayerView )
    goto LABEL_9;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( WeaponPrimaryAttachment && WeaponPrimaryAttachment->useAlternateViewModelLaser )
    return viewModelLaserAlt;
  result = viewModelLaser;
  if ( !viewModelLaser )
  {
LABEL_9:
    result = enemyLaser;
    if ( friendlyLaser )
      return friendlyLaser;
  }
  return result;
}

/*
==============
BG_GetGameDefaultWeaponAnim
==============
*/
XAnimParts *BG_GetGameDefaultWeaponAnim(int animIndex)
{
  return 0i64;
}

/*
==============
BG_GetGrenadeDangerIconDistance
==============
*/
float BG_GetGrenadeDangerIconDistance(const Weapon *r_weapon, bool isAlternate, const float defaultValue)
{
  __int128 v3; 
  unsigned __int16 weaponIdx; 
  unsigned int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v10; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v17; 

  weaponIdx = r_weapon->weaponIdx;
  v17 = v3;
  v7 = 0;
  _XMM6 = LODWORD(BG_WeaponDefAtIndex(weaponIdx)->grenadeDangerIconDistance);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20048, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ui = (*v10)->ui;
      if ( ui )
        break;
      ++v7;
      ++v10;
      if ( v7 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    _XMM6 = LODWORD(ui->grenadeDangerIconDistance);
  }
LABEL_10:
  __asm
  {
    vcmpltss xmm0, xmm6, xmm1
    vblendvps xmm6, xmm6, xmm7, xmm0
  }
  if ( *(float *)&_XMM6 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20062, ASSERT_TYPE_ASSERT, "(distance >= 0.f)", (const char *)&queryFormat, "distance >= 0.f") )
    __debugbreak();
  return *(float *)&_XMM6;
}

/*
==============
BG_GetGrenadePrimeReadyToThrowTime
==============
*/
void BG_GetGrenadePrimeReadyToThrowTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  int v8; 

  v8 = BG_PlayerDualWielding(ps);
  *time = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, v8 != 0, 18i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetGrenadePrimeTime
==============
*/
void BG_GetGrenadePrimeTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  int v8; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10154, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10155, ASSERT_TYPE_ASSERT, "(time)", (const char *)&queryFormat, "time") )
    __debugbreak();
  v8 = BG_PlayerDualWielding(ps);
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, v8 != 0, 188i64, NUM_WEAP_ANIMS);
  BG_GetCookingGrenadeScaleTime(ps);
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm3, 1 }
  *time = (int)*(float *)&_XMM1;
}

/*
==============
BG_GetGunKickMaxAngles
==============
*/
void BG_GetGunKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *outMaxAngles = *(vec2_t *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fGunMaxPitch;
  if ( WeaponAttachments_Internal )
  {
    for ( i = (const WeaponAttachment **)attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20835, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
      if ( AttachmentGunKick )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return;
    }
    *outMaxAngles = *(vec2_t *)&AttachmentGunKick->gunMaxPitch;
  }
}

/*
==============
BG_GetGunKickSpeed
==============
*/
void BG_GetGunKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickAccel, float *hipGunKickSpeedMax, float *hipGunKickSpeedDecay, float *hipGunKickStaticDecay, float *hipGunKickReturnAccelScale, float *hipGunKickReturnSpeedCurveScale, float *adsGunKickAccel, float *adsGunKickSpeedMax, float *adsGunKickSpeedDecay, float *adsGunKickStaticDecay, float *adsGunKickReturnAccelScale, float *adsGunKickReturnSpeedCurveScale)
{
  const BgWeaponMap *v16; 
  bool v18; 
  const Weapon *v19; 
  const WeaponDef *v20; 
  unsigned int v21; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v23; 
  __int128 v25; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v27; 
  __int64 v28; 
  WeaponAttachment **v29; 
  const Weapon *v30; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  const dvar_t *v32; 
  bool v33; 
  float gunCenterScale; 
  __int128 v35; 
  __int128 v36; 
  ContextMountType type; 
  const WeaponDef *v38; 
  float mountTopGunCenterScale; 
  __int128 v41; 
  const WeaponAttachment **v42; 
  AttGunKick *AttachmentGunKick; 
  float *v44; 
  float *v45; 
  float *v46; 
  float *v47; 
  __int128 v49; 
  __int128 v53; 
  unsigned int v58; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v16 = weaponMap;
  v18 = isAlternate;
  v19 = r_weapon;
  if ( !hipGunKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14685, ASSERT_TYPE_ASSERT, "(hipGunKickAccel)", (const char *)&queryFormat, "hipGunKickAccel") )
    __debugbreak();
  if ( !hipGunKickSpeedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14686, ASSERT_TYPE_ASSERT, "(hipGunKickSpeedMax)", (const char *)&queryFormat, "hipGunKickSpeedMax") )
    __debugbreak();
  if ( !hipGunKickSpeedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14687, ASSERT_TYPE_ASSERT, "(hipGunKickSpeedDecay)", (const char *)&queryFormat, "hipGunKickSpeedDecay") )
    __debugbreak();
  if ( !hipGunKickStaticDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14688, ASSERT_TYPE_ASSERT, "(hipGunKickStaticDecay)", (const char *)&queryFormat, "hipGunKickStaticDecay") )
    __debugbreak();
  if ( !adsGunKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14689, ASSERT_TYPE_ASSERT, "(adsGunKickAccel)", (const char *)&queryFormat, "adsGunKickAccel") )
    __debugbreak();
  if ( !adsGunKickSpeedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14690, ASSERT_TYPE_ASSERT, "(adsGunKickSpeedMax)", (const char *)&queryFormat, "adsGunKickSpeedMax") )
    __debugbreak();
  if ( !adsGunKickSpeedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14691, ASSERT_TYPE_ASSERT, "(adsGunKickSpeedDecay)", (const char *)&queryFormat, "adsGunKickSpeedDecay") )
    __debugbreak();
  if ( !adsGunKickStaticDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14692, ASSERT_TYPE_ASSERT, "(adsGunKickStaticDecay)", (const char *)&queryFormat, "adsGunKickStaticDecay") )
    __debugbreak();
  if ( !hipGunKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14693, ASSERT_TYPE_ASSERT, "(hipGunKickReturnAccelScale)", (const char *)&queryFormat, "hipGunKickReturnAccelScale") )
    __debugbreak();
  if ( !hipGunKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14694, ASSERT_TYPE_ASSERT, "(hipGunKickReturnSpeedCurveScale)", (const char *)&queryFormat, "hipGunKickReturnSpeedCurveScale") )
    __debugbreak();
  if ( !adsGunKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14695, ASSERT_TYPE_ASSERT, "(adsGunKickReturnAccelScale)", (const char *)&queryFormat, "adsGunKickReturnAccelScale") )
    __debugbreak();
  if ( !adsGunKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14696, ASSERT_TYPE_ASSERT, "(adsGunKickReturnSpeedCurveScale)", (const char *)&queryFormat, "adsGunKickReturnSpeedCurveScale") )
    __debugbreak();
  v20 = BG_WeaponDefAtIndex(v19->weaponIdx);
  *hipGunKickAccel = v20->fHipGunKickAccel;
  *hipGunKickSpeedMax = v20->fHipGunKickSpeedMax;
  *hipGunKickSpeedDecay = v20->fHipGunKickSpeedDecay;
  *hipGunKickStaticDecay = v20->fHipGunKickStaticDecay;
  v21 = 0;
  *adsGunKickAccel = v20->fAdsGunKickAccel;
  *adsGunKickSpeedMax = v20->fAdsGunKickSpeedMax;
  *adsGunKickSpeedDecay = v20->fAdsGunKickSpeedDecay;
  *adsGunKickStaticDecay = v20->fAdsGunKickStaticDecay;
  *hipGunKickReturnAccelScale = v20->hipGunKickReturnAccelScale;
  *hipGunKickReturnSpeedCurveScale = v20->hipGunKickReturnSpeedCurveScale;
  *adsGunKickReturnAccelScale = v20->adsGunKickReturnAccelScale;
  *adsGunKickReturnSpeedCurveScale = v20->adsGunKickReturnSpeedCurveScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v19, v18, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v23 = WeaponAttachments_Internal;
  v58 = WeaponAttachments_Internal;
  _XMM8 = LODWORD(FLOAT_1_0);
  v25 = LODWORD(FLOAT_1_0);
  v27 = ps && v16 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v16, ps, v19)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)v23 )
  {
    v28 = v23;
    v29 = attachments;
    v30 = v19;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(v16, ps, v30, isAlternate, *v29, v27);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14720, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( OverrideAttachmentWhenApplicable->gunCenterScale != 0.0 )
      {
        v32 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v32);
        v33 = !v32->current.enabled;
        v16 = weaponMap;
        gunCenterScale = OverrideAttachmentWhenApplicable->gunCenterScale;
        if ( v33 )
        {
          v36 = _XMM8;
          *(float *)&v36 = (float)(*(float *)&_XMM8 + gunCenterScale) - 1.0;
          _XMM8 = v36;
        }
        else
        {
          v35 = v25;
          *(float *)&v35 = *(float *)&v25 * gunCenterScale;
          v25 = v35;
        }
      }
      ++v29;
      --v28;
    }
    while ( v28 );
    LODWORD(v23) = v58;
    v21 = 0;
    v19 = r_weapon;
    v18 = isAlternate;
  }
  type = ps->mountState.surface.type;
  v38 = BG_WeaponDefAtIndex(v19->weaponIdx);
  if ( !v38 )
    goto LABEL_57;
  if ( type == MOUNT_TYPE_TOP )
  {
    mountTopGunCenterScale = v38->mountTopGunCenterScale;
  }
  else
  {
    if ( (unsigned int)(type - 2) > 1 )
    {
LABEL_57:
      mountTopGunCenterScale = FLOAT_1_0;
      goto LABEL_62;
    }
    mountTopGunCenterScale = v38->mountSideGunCenterScale;
  }
LABEL_62:
  v41 = v25;
  *(float *)&v41 = *(float *)&v25 * (float)((float)(ps->mountState.mountFraction * mountTopGunCenterScale) + (float)(1.0 - ps->mountState.mountFraction));
  _XMM6 = v41;
  if ( (_DWORD)v23 )
  {
    v42 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14740, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, v19, v18, *v42, v27);
      if ( AttachmentGunKick )
        break;
      ++v21;
      ++v42;
      if ( v21 >= (unsigned int)v23 )
        goto LABEL_69;
    }
    v46 = hipGunKickSpeedDecay;
    v45 = hipGunKickStaticDecay;
    v44 = adsGunKickAccel;
    *hipGunKickAccel = AttachmentGunKick->hipGunKickAccel;
    v47 = hipGunKickSpeedMax;
    *hipGunKickSpeedMax = AttachmentGunKick->hipGunKickSpeedMax;
    *hipGunKickSpeedDecay = AttachmentGunKick->hipGunKickSpeedDecay;
    *hipGunKickStaticDecay = AttachmentGunKick->hipGunKickStaticDecay;
    *adsGunKickAccel = AttachmentGunKick->adsGunKickAccel;
    *adsGunKickSpeedMax = AttachmentGunKick->adsGunKickSpeedMax;
    *adsGunKickSpeedDecay = AttachmentGunKick->adsGunKickSpeedDecay;
    *adsGunKickStaticDecay = AttachmentGunKick->adsGunKickStaticDecay;
    *hipGunKickReturnAccelScale = AttachmentGunKick->hipGunKickReturnAccelScale;
    *hipGunKickReturnSpeedCurveScale = AttachmentGunKick->hipGunKickReturnSpeedCurveScale;
    *adsGunKickReturnAccelScale = AttachmentGunKick->adsGunKickReturnAccelScale;
    *adsGunKickReturnSpeedCurveScale = AttachmentGunKick->adsGunKickReturnSpeedCurveScale;
  }
  else
  {
LABEL_69:
    v44 = adsGunKickAccel;
    v45 = hipGunKickStaticDecay;
    v46 = hipGunKickSpeedDecay;
    v47 = hipGunKickSpeedMax;
  }
  __asm { vmaxss  xmm2, xmm8, xmm9 }
  v49 = LODWORD(FLOAT_1_0);
  *(float *)&v49 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v49 + 1) = (v49 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v49 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v49;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm7, xmm0
  }
  v53 = LODWORD(FLOAT_1_0);
  *(float *)&v53 = 1.0 - *(float *)&_XMM6;
  *((_QWORD *)&v53 + 1) = (v53 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v53 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM6) & _xmm);
  _XMM1 = v53;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm6, xmm7, xmm2
  }
  *hipGunKickAccel = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *hipGunKickAccel;
  *v47 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v47;
  *v46 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v46;
  *v45 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v45;
  *v44 = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *v44;
  *adsGunKickSpeedMax = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *adsGunKickSpeedMax;
  *adsGunKickSpeedDecay = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *adsGunKickSpeedDecay;
  *adsGunKickStaticDecay = (float)(*(float *)&_XMM0 * *(float *)&_XMM5) * *adsGunKickStaticDecay;
}

/*
==============
BG_GetGunKickYawAndPitch
==============
*/
void BG_GetGunKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickPitchMin, float *hipGunKickPitchMax, float *hipGunKickYawMin, float *hipGunKickYawMax, float *hipGunKickMagMin, float *adsGunKickPitchMin, float *adsGunKickPitchMax, float *adsGunKickYawMin, float *adsGunKickYawMax, float *adsGunKickMagMin)
{
  float *v15; 
  float *v17; 
  const WeaponDef *v18; 
  EffectiveStance EffectiveStance; 
  __int64 v20; 
  float adsCrouchGunKickFactor; 
  unsigned int v22; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v25; 
  __int64 v26; 
  WeaponAttachment **v27; 
  WeaponAttachment *v28; 
  AttADSStanceScales *adsStanceScales; 
  __int128 v30; 
  __int128 v31; 
  __int128 v32; 
  __int128 v33; 
  __int128 v35; 
  float v39; 
  ContextMountType type; 
  const WeaponDef *v41; 
  float mountTopGunKickScale; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v44; 
  const WeaponAttachment **v45; 
  AttGunKick *AttachmentGunKick; 
  float *v47; 
  float *v48; 
  float *v49; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v15 = adsGunKickPitchMin;
  v17 = adsGunKickPitchMax;
  if ( !hipGunKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14575, ASSERT_TYPE_ASSERT, "(hipGunKickPitchMin)", (const char *)&queryFormat, "hipGunKickPitchMin") )
    __debugbreak();
  if ( !hipGunKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14576, ASSERT_TYPE_ASSERT, "(hipGunKickPitchMax)", (const char *)&queryFormat, "hipGunKickPitchMax") )
    __debugbreak();
  if ( !hipGunKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14577, ASSERT_TYPE_ASSERT, "(hipGunKickYawMin)", (const char *)&queryFormat, "hipGunKickYawMin") )
    __debugbreak();
  if ( !hipGunKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14578, ASSERT_TYPE_ASSERT, "(hipGunKickYawMax)", (const char *)&queryFormat, "hipGunKickYawMax") )
    __debugbreak();
  if ( !hipGunKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14579, ASSERT_TYPE_ASSERT, "(hipGunKickMagMin)", (const char *)&queryFormat, "hipGunKickMagMin") )
    __debugbreak();
  if ( !adsGunKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14580, ASSERT_TYPE_ASSERT, "(adsGunKickPitchMin)", (const char *)&queryFormat, "adsGunKickPitchMin") )
    __debugbreak();
  if ( !adsGunKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14581, ASSERT_TYPE_ASSERT, "(adsGunKickPitchMax)", (const char *)&queryFormat, "adsGunKickPitchMax") )
    __debugbreak();
  if ( !adsGunKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14582, ASSERT_TYPE_ASSERT, "(adsGunKickYawMin)", (const char *)&queryFormat, "adsGunKickYawMin") )
    __debugbreak();
  if ( !adsGunKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14583, ASSERT_TYPE_ASSERT, "(adsGunKickYawMax)", (const char *)&queryFormat, "adsGunKickYawMax") )
    __debugbreak();
  if ( !adsGunKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14584, ASSERT_TYPE_ASSERT, "(adsGunKickMagMin)", (const char *)&queryFormat, "adsGunKickMagMin") )
    __debugbreak();
  v18 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipGunKickPitchMin = v18->fHipGunKickPitchMin;
  *hipGunKickPitchMax = v18->fHipGunKickPitchMax;
  *hipGunKickYawMin = v18->fHipGunKickYawMin;
  *hipGunKickYawMax = v18->fHipGunKickYawMax;
  *hipGunKickMagMin = v18->fHipGunKickMagMin;
  *adsGunKickPitchMin = v18->fAdsGunKickPitchMin;
  *adsGunKickPitchMax = v18->fAdsGunKickPitchMax;
  *adsGunKickYawMin = v18->fAdsGunKickYawMin;
  *adsGunKickYawMax = v18->fAdsGunKickYawMax;
  *adsGunKickMagMin = v18->fAdsGunKickMagMin;
  EffectiveStance = PM_GetEffectiveStance(ps);
  v20 = EffectiveStance;
  adsCrouchGunKickFactor = FLOAT_1_0;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    adsCrouchGunKickFactor = v18->adsCrouchGunKickFactor;
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    adsCrouchGunKickFactor = v18->adsProneGunKickFactor;
  }
  v22 = 0;
  _XMM6 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v25 = v20;
    v26 = WeaponAttachments_Internal;
    v27 = attachments;
    while ( 1 )
    {
      v28 = *v27;
      if ( !*v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14617, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsStanceScales = v28->adsStanceScales;
      if ( !adsStanceScales )
        goto LABEL_46;
      if ( v25 == 2 )
        break;
      if ( v25 == 1 )
      {
        v32 = _XMM6;
        *(float *)&v32 = *(float *)&_XMM6 + adsStanceScales->adsProneGunKickFactorScale;
        v30 = v32;
        goto LABEL_45;
      }
LABEL_46:
      ++v27;
      if ( !--v26 )
      {
        v22 = 0;
        v15 = adsGunKickPitchMin;
        v17 = adsGunKickPitchMax;
        goto LABEL_48;
      }
    }
    v31 = _XMM6;
    *(float *)&v31 = *(float *)&_XMM6 + adsStanceScales->adsCrouchGunKickFactorScale;
    v30 = v31;
LABEL_45:
    v33 = v30;
    *(float *)&v33 = *(float *)&v30 - 1.0;
    _XMM6 = v33;
    goto LABEL_46;
  }
LABEL_48:
  __asm { vmaxss  xmm3, xmm6, xmm4 }
  v35 = LODWORD(FLOAT_1_0);
  *(float *)&v35 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v35 + 1) = (v35 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v35 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v35;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  v39 = *(float *)&_XMM0 * adsCrouchGunKickFactor;
  if ( ps->mountState.mountFraction > 0.0 )
  {
    type = ps->mountState.surface.type;
    v41 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v41 )
      goto LABEL_50;
    if ( type == MOUNT_TYPE_TOP )
    {
      mountTopGunKickScale = v41->mountTopGunKickScale;
      goto LABEL_55;
    }
    if ( (unsigned int)(type - 2) <= 1 )
      mountTopGunKickScale = v41->mountSideGunKickScale;
    else
LABEL_50:
      mountTopGunKickScale = FLOAT_1_0;
LABEL_55:
    v39 = (float)((float)(1.0 - ps->mountState.mountFraction) * v39) + (float)(ps->mountState.mountFraction * mountTopGunKickScale);
  }
  v44 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v45 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14648, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *v45, v44);
      if ( AttachmentGunKick )
        break;
      ++v22;
      ++v45;
      if ( v22 >= WeaponAttachments_Internal )
        goto LABEL_67;
    }
    v48 = adsGunKickYawMax;
    *hipGunKickPitchMin = AttachmentGunKick->hipGunKickPitchMin;
    *hipGunKickPitchMax = AttachmentGunKick->hipGunKickPitchMax;
    *hipGunKickYawMin = AttachmentGunKick->hipGunKickYawMin;
    *hipGunKickYawMax = AttachmentGunKick->hipGunKickYawMax;
    *hipGunKickMagMin = AttachmentGunKick->hipGunKickMagMin;
    v49 = adsGunKickYawMin;
    *v15 = AttachmentGunKick->adsGunKickPitchMin;
    *v17 = AttachmentGunKick->adsGunKickPitchMax;
    *adsGunKickYawMin = AttachmentGunKick->adsGunKickYawMin;
    *adsGunKickYawMax = AttachmentGunKick->adsGunKickYawMax;
    v47 = adsGunKickMagMin;
    *adsGunKickMagMin = AttachmentGunKick->adsGunKickMagMin;
  }
  else
  {
LABEL_67:
    v47 = adsGunKickMagMin;
    v48 = adsGunKickYawMax;
    v49 = adsGunKickYawMin;
  }
  *v15 = v39 * *v15;
  *v17 = v39 * *v17;
  *v49 = v39 * *v49;
  *v48 = v39 * *v48;
  *v47 = v39 * *v47;
}

/*
==============
BG_GetGunTiltYawPitchAndRoll
==============
*/
void BG_GetGunTiltYawPitchAndRoll(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunTiltPitchFactor, float *hipGunTiltYawFactor, float *hipGunTiltRollFactor, float *hipGunTiltOffset, float *adsGunTiltPitchFactor, float *adsGunTiltYawFactor, float *adsGunTiltRollFactor, float *adsGunTiltOffset)
{
  const WeaponDef *v16; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v18; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v21; 
  WeaponAttachment **v22; 
  __int64 v23; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  float gunTiltScale; 
  __int128 gunTiltScale_low; 
  unsigned int v27; 
  const playerState_s *v28; 
  WeaponAttachment **v29; 
  const WeaponAttachment *v30; 
  AttGunTilt *gunTilt; 
  float *v32; 
  float *v33; 
  float *v34; 
  float *v35; 
  __int128 v37; 
  unsigned int v42; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14364, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !hipGunTiltPitchFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14365, ASSERT_TYPE_ASSERT, "(hipGunTiltPitchFactor)", (const char *)&queryFormat, "hipGunTiltPitchFactor") )
    __debugbreak();
  if ( !hipGunTiltYawFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14366, ASSERT_TYPE_ASSERT, "(hipGunTiltYawFactor)", (const char *)&queryFormat, "hipGunTiltYawFactor") )
    __debugbreak();
  if ( !hipGunTiltRollFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14367, ASSERT_TYPE_ASSERT, "(hipGunTiltRollFactor)", (const char *)&queryFormat, "hipGunTiltRollFactor") )
    __debugbreak();
  if ( !hipGunTiltOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14368, ASSERT_TYPE_ASSERT, "(hipGunTiltOffset)", (const char *)&queryFormat, "hipGunTiltOffset") )
    __debugbreak();
  if ( !adsGunTiltPitchFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14369, ASSERT_TYPE_ASSERT, "(adsGunTiltPitchFactor)", (const char *)&queryFormat, "adsGunTiltPitchFactor") )
    __debugbreak();
  if ( !adsGunTiltYawFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14370, ASSERT_TYPE_ASSERT, "(adsGunTiltYawFactor)", (const char *)&queryFormat, "adsGunTiltYawFactor") )
    __debugbreak();
  if ( !adsGunTiltRollFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14371, ASSERT_TYPE_ASSERT, "(adsGunTiltRollFactor)", (const char *)&queryFormat, "adsGunTiltRollFactor") )
    __debugbreak();
  if ( !adsGunTiltOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14372, ASSERT_TYPE_ASSERT, "(adsGunTiltOffset)", (const char *)&queryFormat, "adsGunTiltOffset") )
    __debugbreak();
  v16 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipGunTiltPitchFactor = v16->hipGunTiltPitchFactor;
  *hipGunTiltYawFactor = v16->hipGunTiltYawFactor;
  *hipGunTiltRollFactor = v16->hipGunTiltRollFactor;
  *hipGunTiltOffset = v16->hipGunTiltOffset;
  *adsGunTiltPitchFactor = v16->adsGunTiltPitchFactor;
  *adsGunTiltYawFactor = v16->adsGunTiltYawFactor;
  *adsGunTiltRollFactor = v16->adsGunTiltRollFactor;
  *adsGunTiltOffset = v16->adsGunTiltOffset;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v18 = WeaponAttachments_Internal;
  v42 = WeaponAttachments_Internal;
  _XMM6 = LODWORD(FLOAT_1_0);
  v21 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !(_DWORD)v18 )
    goto LABEL_48;
  v22 = attachments;
  v23 = v18;
  do
  {
    OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v22, v21);
    if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14392, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    gunTiltScale = OverrideAttachmentWhenApplicable->gunTiltScale;
    if ( gunTiltScale != 0.0 )
    {
      gunTiltScale_low = LODWORD(OverrideAttachmentWhenApplicable->gunTiltScale);
      *(float *)&gunTiltScale_low = (float)(gunTiltScale + *(float *)&_XMM6) - 1.0;
      _XMM6 = gunTiltScale_low;
    }
    ++v22;
    --v23;
  }
  while ( v23 );
  v27 = 0;
  v28 = ps;
  if ( v42 )
  {
    v29 = attachments;
    while ( 1 )
    {
      v30 = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v28, r_weapon, isAlternate, *v29, v21);
      if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14403, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      gunTilt = v30->gunTilt;
      if ( gunTilt )
        break;
      v28 = ps;
      ++v27;
      ++v29;
      if ( v27 >= v42 )
        goto LABEL_48;
    }
    v35 = hipGunTiltPitchFactor;
    v34 = hipGunTiltYawFactor;
    v33 = hipGunTiltRollFactor;
    v32 = adsGunTiltPitchFactor;
    *hipGunTiltPitchFactor = gunTilt->hipGunTiltPitchFactor;
    *hipGunTiltYawFactor = v30->gunTilt->hipGunTiltYawFactor;
    *hipGunTiltRollFactor = v30->gunTilt->hipGunTiltRollFactor;
    *hipGunTiltOffset = v30->gunTilt->hipGunTiltOffset;
    *adsGunTiltPitchFactor = v30->gunTilt->adsGunTiltPitchFactor;
    *adsGunTiltYawFactor = v30->gunTilt->adsGunTiltYawFactor;
    *adsGunTiltRollFactor = v30->gunTilt->adsGunTiltRollFactor;
    *adsGunTiltOffset = v30->gunTilt->adsGunTiltOffset;
  }
  else
  {
LABEL_48:
    v32 = adsGunTiltPitchFactor;
    v33 = hipGunTiltRollFactor;
    v34 = hipGunTiltYawFactor;
    v35 = hipGunTiltPitchFactor;
  }
  __asm { vmaxss  xmm3, xmm6, xmm7 }
  v37 = LODWORD(FLOAT_1_0);
  *(float *)&v37 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v37 + 1) = (v37 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v37 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v37;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm8, xmm2
  }
  *v35 = *(float *)&_XMM4 * *v35;
  *v34 = *(float *)&_XMM4 * *v34;
  *v33 = *(float *)&_XMM4 * *v33;
  *v32 = *(float *)&_XMM4 * *v32;
  *adsGunTiltYawFactor = *(float *)&_XMM4 * *adsGunTiltYawFactor;
  *adsGunTiltRollFactor = *(float *)&_XMM4 * *adsGunTiltRollFactor;
}

/*
==============
BG_GetHandFromWeaponEvent
==============
*/
__int64 BG_GetHandFromWeaponEvent(int event)
{
  __int64 result; 

  switch ( event )
  {
    case 17:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 55:
    case 66:
    case 67:
    case 70:
    case 71:
      result = 1i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

/*
==============
BG_GetHeatProperties
==============
*/
void BG_GetHeatProperties(const Weapon *weapon, const bool isAlternate, float *outAccumulationPerShot, float *outDissipationPerSecond)
{
  const WeaponDef *v8; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v11; 
  WeaponAttachment **v12; 
  float *p_heatAccumulationPerShot; 
  WeaponAttachment **v16; 
  WeaponAttachment *v17; 
  float heatAccumulationScale; 
  __int128 heatAccumulationScale_low; 
  float heatDissipationScale; 
  __int128 heatDissipationScale_low; 
  __int128 v23; 
  __int128 v28; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19270, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *outAccumulationPerShot = v8->heatAccumulationPerShot;
  *outDissipationPerSecond = v8->heatDissipationPerSecond;
  v11 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19281, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      p_heatAccumulationPerShot = &(*v12)->heat->heatAccumulationPerShot;
      if ( p_heatAccumulationPerShot )
        break;
      ++v9;
      ++v12;
      if ( v9 >= (unsigned int)v11 )
        goto LABEL_13;
    }
    *outAccumulationPerShot = *p_heatAccumulationPerShot;
    *outDissipationPerSecond = p_heatAccumulationPerShot[1];
  }
LABEL_13:
  _XMM6 = LODWORD(FLOAT_1_0);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)v11 )
  {
    v16 = attachments;
    do
    {
      v17 = *v16;
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19298, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      heatAccumulationScale = v17->heatAccumulationScale;
      if ( heatAccumulationScale > 0.0 )
      {
        heatAccumulationScale_low = LODWORD(v17->heatAccumulationScale);
        *(float *)&heatAccumulationScale_low = (float)(heatAccumulationScale + *(float *)&_XMM6) - 1.0;
        _XMM6 = heatAccumulationScale_low;
      }
      heatDissipationScale = v17->heatDissipationScale;
      if ( heatDissipationScale > 0.0 )
      {
        heatDissipationScale_low = LODWORD(v17->heatDissipationScale);
        *(float *)&heatDissipationScale_low = (float)(heatDissipationScale + *(float *)&_XMM8) - 1.0;
        _XMM8 = heatDissipationScale_low;
      }
      ++v16;
      --v11;
    }
    while ( v11 );
  }
  __asm { vmaxss  xmm2, xmm6, xmm9 }
  v23 = LODWORD(FLOAT_1_0);
  *(float *)&v23 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v23 + 1) = (v23 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v23 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v23;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm7, xmm0
  }
  *outAccumulationPerShot = *(float *)&_XMM1 * *outAccumulationPerShot;
  __asm { vmaxss  xmm3, xmm8, xmm9 }
  v28 = LODWORD(FLOAT_1_0);
  *(float *)&v28 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v28 + 1) = (v28 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v28 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v28;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  *outDissipationPerSecond = *(float *)&_XMM0 * *outDissipationPerSecond;
}

/*
==============
BG_GetHeatSmokeProperties
==============
*/
void BG_GetHeatSmokeProperties(const Weapon *weapon, const bool isAlternate, float *outSmokeStartThreshold, float *outSmokeStopThreshold)
{
  const WeaponDef *v8; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v11; 
  WeaponAttachment **v12; 
  AttHeat *heat; 
  WeaponAttachment **v15; 
  WeaponAttachment *v16; 
  float heatSmokeThresholdScale; 
  __int128 heatSmokeThresholdScale_low; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19321, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *outSmokeStartThreshold = v8->heatSmokeStartThreshold;
  *outSmokeStopThreshold = v8->heatSmokeStopThreshold;
  v11 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19332, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      heat = (*v12)->heat;
      if ( heat )
        break;
      ++v9;
      ++v12;
      if ( v9 >= (unsigned int)v11 )
        goto LABEL_13;
    }
    *outSmokeStartThreshold = heat->heatSmokeStartThreshold;
    *outSmokeStopThreshold = heat->heatSmokeStopThreshold;
  }
LABEL_13:
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)v11 )
  {
    v15 = attachments;
    do
    {
      v16 = *v15;
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19348, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      heatSmokeThresholdScale = v16->heatSmokeThresholdScale;
      if ( heatSmokeThresholdScale > 0.0 )
      {
        heatSmokeThresholdScale_low = LODWORD(v16->heatSmokeThresholdScale);
        *(float *)&heatSmokeThresholdScale_low = (float)(heatSmokeThresholdScale + *(float *)&_XMM6) - 1.0;
        _XMM6 = heatSmokeThresholdScale_low;
      }
      ++v15;
      --v11;
    }
    while ( v11 );
  }
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v20 = LODWORD(FLOAT_1_0);
  *(float *)&v20 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v20;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm3, xmm7, xmm2
  }
  *outSmokeStartThreshold = *(float *)&_XMM1 * *outSmokeStartThreshold;
  *outSmokeStopThreshold = *(float *)&_XMM1 * *outSmokeStopThreshold;
}

/*
==============
BG_GetHipIdleValues
==============
*/
void BG_GetHipIdleValues(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, float *hipIdleAmount, float *adsIdleAmount, float *hipIdleSpeed, float *adsIdleSpeed)
{
  float *v7; 
  float *v9; 
  float *v11; 
  const WeaponDef *v13; 
  unsigned int v14; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v19; 
  __int64 v20; 
  WeaponAttachment *v21; 
  float idleHipMotionScale; 
  __int128 idleHipMotionScale_low; 
  float idleADSMotionScale; 
  __int128 v25; 
  float idleADSMotionTimeScale; 
  __int128 idleADSMotionTimeScale_low; 
  __int128 v29; 
  __int128 v34; 
  __int128 v39; 
  WeaponAttachment **v43; 
  WeaponAttachment *v44; 
  float *p_hipIdleAmount; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v47; 
  const dvar_t *v48; 
  float value; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  float *v52; 
  float *v53; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  bitarray<64> v56; 

  v56 = perks;
  v7 = adsIdleAmount;
  v9 = adsIdleSpeed;
  v11 = hipIdleSpeed;
  v52 = adsIdleAmount;
  v53 = adsIdleSpeed;
  if ( !hipIdleAmount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12112, ASSERT_TYPE_ASSERT, "(hipIdleAmount)", (const char *)&queryFormat, "hipIdleAmount") )
    __debugbreak();
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12113, ASSERT_TYPE_ASSERT, "(adsIdleAmount)", (const char *)&queryFormat, "adsIdleAmount") )
    __debugbreak();
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12114, ASSERT_TYPE_ASSERT, "(hipIdleSpeed)", (const char *)&queryFormat, "hipIdleSpeed") )
    __debugbreak();
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12115, ASSERT_TYPE_ASSERT, "(adsIdleSpeed)", (const char *)&queryFormat, "adsIdleSpeed") )
    __debugbreak();
  v13 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v14 = 0;
  *hipIdleAmount = v13->fHipIdleAmount;
  *v7 = v13->fAdsIdleAmount;
  *v11 = v13->hipIdleSpeed;
  *v9 = v13->adsIdleSpeed;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM10 = LODWORD(FLOAT_1_0);
  _XMM9 = LODWORD(FLOAT_1_0);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v19 = attachments;
    v20 = WeaponAttachments_Internal;
    do
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12129, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v21 = *v19;
      idleHipMotionScale = (*v19)->idleHipMotionScale;
      if ( idleHipMotionScale >= 0.0 )
      {
        idleHipMotionScale_low = LODWORD((*v19)->idleHipMotionScale);
        *(float *)&idleHipMotionScale_low = (float)(idleHipMotionScale + *(float *)&_XMM10) - 1.0;
        _XMM10 = idleHipMotionScale_low;
      }
      idleADSMotionScale = v21->idleADSMotionScale;
      if ( idleADSMotionScale >= 0.0 )
      {
        v25 = _XMM9;
        *(float *)&v25 = (float)(*(float *)&_XMM9 + idleADSMotionScale) - 1.0;
        _XMM9 = v25;
      }
      idleADSMotionTimeScale = v21->idleADSMotionTimeScale;
      if ( idleADSMotionTimeScale >= 0.0 )
      {
        idleADSMotionTimeScale_low = LODWORD(v21->idleADSMotionTimeScale);
        *(float *)&idleADSMotionTimeScale_low = (float)(idleADSMotionTimeScale + *(float *)&_XMM8) - 1.0;
        _XMM8 = idleADSMotionTimeScale_low;
      }
      ++v19;
      --v20;
    }
    while ( v20 );
    v7 = v52;
    v9 = v53;
  }
  __asm { vmaxss  xmm2, xmm10, xmm7 }
  v29 = LODWORD(FLOAT_1_0);
  *(float *)&v29 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v29 + 1) = (v29 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v29 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v29;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm5
    vblendvps xmm10, xmm2, xmm6, xmm0
    vmaxss  xmm3, xmm9, xmm7
  }
  v34 = LODWORD(FLOAT_1_0);
  *(float *)&v34 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v34 + 1) = (v34 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v34 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v34;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm5
    vblendvps xmm9, xmm3, xmm6, xmm2
    vmaxss  xmm3, xmm8, xmm7
  }
  v39 = LODWORD(FLOAT_1_0);
  *(float *)&v39 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v39 + 1) = (v39 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v39 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v39;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm5
    vblendvps xmm6, xmm3, xmm6, xmm2
  }
  if ( WeaponAttachments_Internal )
  {
    v43 = attachments;
    while ( 1 )
    {
      if ( !*v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12149, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v44 = *v43;
      p_hipIdleAmount = &(*v43)->idleSettings->hipIdleAmount;
      if ( p_hipIdleAmount )
        break;
      ++v14;
      ++v43;
      if ( v14 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    *hipIdleAmount = *(float *)&_XMM10 * *p_hipIdleAmount;
    *v11 = *(float *)&_XMM10 * v44->idleSettings->hipIdleSpeed;
  }
LABEL_35:
  *v7 = *(float *)&_XMM9 * *v7;
  *v9 = *(float *)&_XMM6 * *v9;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x1Au);
  v47 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(attachmentSlots) = 64;
      LODWORD(numAttachmentSlots) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v47 & 0x1F)) & v56.array[v47 >> 5]) != 0 )
    {
      v48 = DCONST_DVARFLT_perk_reducedSwayScale;
      if ( !DCONST_DVARFLT_perk_reducedSwayScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_reducedSwayScale") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v48);
      value = v48->current.value;
      *v7 = value * *v7;
      *v9 = value * *v9;
    }
  }
}

/*
==============
BG_GetHipOffsetLerpType
==============
*/
void BG_GetHipOffsetLerpType(const Weapon *r_weapon, bool isAlternate, AdsOffsetInterpolationType *outHipOffsetLerpType)
{
  __int64 WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outHipOffsetLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22397, ASSERT_TYPE_ASSERT, "(outHipOffsetLerpType)", (const char *)&queryFormat, "outHipOffsetLerpType") )
    __debugbreak();
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *outHipOffsetLerpType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hipOffsetLerpType;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v7 = attachments;
    do
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22407, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v7)->overridehipOffsetLerpType )
        *outHipOffsetLerpType = (*v7)->hipOffsetLerpType;
      ++v7;
      --WeaponAttachments_Internal;
    }
    while ( WeaponAttachments_Internal );
  }
}

/*
==============
BG_GetHipSpread
==============
*/
void BG_GetHipSpread(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMax)
{
  float *v13; 
  float *v15; 
  const WeaponDef *v18; 
  unsigned int v19; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v22; 
  __int64 v23; 
  float hipSpreadScale; 
  __int128 v25; 
  WeaponAttachment **v26; 
  WeaponAttachment *v27; 
  float *p_hipSpreadStandMin; 
  float *v29; 
  float *v30; 
  __int128 v32; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v13 = hipSpreadDuckedMax;
  v15 = hipSpreadProneMin;
  if ( !hipSpreadStandMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13799, ASSERT_TYPE_ASSERT, "(hipSpreadStandMin)", (const char *)&queryFormat, "hipSpreadStandMin") )
    __debugbreak();
  if ( !hipSpreadStandMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13800, ASSERT_TYPE_ASSERT, "(hipSpreadStandMax)", (const char *)&queryFormat, "hipSpreadStandMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13801, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMin)", (const char *)&queryFormat, "hipSpreadDuckedMin") )
    __debugbreak();
  if ( !hipSpreadDuckedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13802, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMax)", (const char *)&queryFormat, "hipSpreadDuckedMax") )
    __debugbreak();
  if ( !hipSpreadProneMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13803, ASSERT_TYPE_ASSERT, "(hipSpreadProneMin)", (const char *)&queryFormat, "hipSpreadProneMin") )
    __debugbreak();
  if ( !hipSpreadProneMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13804, ASSERT_TYPE_ASSERT, "(hipSpreadProneMax)", (const char *)&queryFormat, "hipSpreadProneMax") )
    __debugbreak();
  v18 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipSpreadStandMin = v18->fHipSpreadStandMin;
  *hipSpreadStandMax = v18->hipSpreadStandMax;
  *hipSpreadDuckedMin = v18->fHipSpreadDuckedMin;
  *hipSpreadDuckedMax = v18->hipSpreadDuckedMax;
  *hipSpreadProneMin = v18->fHipSpreadProneMin;
  *hipSpreadProneMax = v18->hipSpreadProneMax;
  v19 = 0;
  *hipSpreadSprintMin = v18->hipSpreadSprintMin;
  *hipSpreadSprintMax = v18->hipSpreadSprintMax;
  *hipSpreadInAirMin = v18->hipSpreadInAirMin;
  *hipSpreadInAirMax = v18->hipSpreadInAirMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v22 = attachments;
    v23 = WeaponAttachments_Internal;
    do
    {
      if ( !*v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13823, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      hipSpreadScale = (*v22)->hipSpreadScale;
      if ( hipSpreadScale != 0.0 )
      {
        v25 = _XMM6;
        *(float *)&v25 = (float)(*(float *)&_XMM6 + hipSpreadScale) - 1.0;
        _XMM6 = v25;
      }
      ++v22;
      --v23;
    }
    while ( v23 );
    v13 = hipSpreadDuckedMax;
    v15 = hipSpreadProneMin;
  }
  if ( WeaponAttachments_Internal )
  {
    v26 = attachments;
    while ( 1 )
    {
      if ( !*v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13832, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v27 = *v26;
      p_hipSpreadStandMin = &(*v26)->hipSpread->hipSpreadStandMin;
      if ( p_hipSpreadStandMin )
        break;
      ++v19;
      ++v26;
      if ( v19 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    v29 = hipSpreadStandMin;
    v30 = hipSpreadProneMax;
    *hipSpreadStandMin = *p_hipSpreadStandMin;
    *hipSpreadStandMax = v27->hipSpread->hipSpreadMax;
    *hipSpreadDuckedMin = v27->hipSpread->hipSpreadDuckedMin;
    *v13 = v27->hipSpread->hipSpreadDuckedMax;
    *v15 = v27->hipSpread->hipSpreadProneMin;
    *hipSpreadProneMax = v27->hipSpread->hipSpreadProneMax;
    *hipSpreadSprintMin = v27->hipSpread->hipSpreadSprintMin;
    *hipSpreadSprintMax = v27->hipSpread->hipSpreadSprintMax;
    *hipSpreadInAirMin = v27->hipSpread->hipSpreadSprintMin;
    *hipSpreadInAirMax = v27->hipSpread->hipSpreadSprintMax;
  }
  else
  {
LABEL_35:
    v29 = hipSpreadStandMin;
    v30 = hipSpreadProneMax;
  }
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v32 = LODWORD(FLOAT_1_0);
  *(float *)&v32 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v32 + 1) = (v32 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v32 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v32;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm7, xmm2
  }
  *v29 = *(float *)&_XMM4 * *v29;
  *hipSpreadStandMax = *(float *)&_XMM4 * *hipSpreadStandMax;
  *hipSpreadDuckedMin = *(float *)&_XMM4 * *hipSpreadDuckedMin;
  *v13 = *(float *)&_XMM4 * *v13;
  *v15 = *(float *)&_XMM4 * *v15;
  *v30 = *(float *)&_XMM4 * *v30;
  *hipSpreadSprintMin = *(float *)&_XMM4 * *hipSpreadSprintMin;
  *hipSpreadSprintMax = *(float *)&_XMM4 * *hipSpreadSprintMax;
  *hipSpreadInAirMin = *(float *)&_XMM4 * *hipSpreadInAirMin;
  *hipSpreadInAirMax = *(float *)&_XMM4 * *hipSpreadInAirMax;
}

/*
==============
BG_GetHipSpreadWithDecay
==============
*/
void BG_GetHipSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMoveMax, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMoveMax, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMoveMax, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMoveMax, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMoveMax, float *hipSpreadInAirMax, float *hipSpreadDecayRate, float *hipSpreadProneDecay, float *hipSpreadDuckedDecay, float *hipSpreadSprintDecay, float *hipSpreadInAirDecay, float *hipSpreadTurnAdd, float *hipSpreadMoveAdd)
{
  __int128 v24; 
  float *v26; 
  float *v27; 
  const WeaponDef *v29; 
  unsigned int v30; 
  unsigned int WeaponAttachments_Internal; 
  __int128 v32; 
  WeaponAttachment **v33; 
  __int64 v34; 
  float hipSpreadScale; 
  __int128 v36; 
  WeaponAttachment **v37; 
  WeaponAttachment *v38; 
  float *p_hipSpreadStandMin; 
  float *v40; 
  float *v41; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v46; 

  v26 = hipSpreadDuckedMoveMax;
  v27 = hipSpreadStandMoveMax;
  if ( !hipSpreadStandMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13921, ASSERT_TYPE_ASSERT, "(hipSpreadStandMin)", (const char *)&queryFormat, "hipSpreadStandMin") )
    __debugbreak();
  if ( !hipSpreadStandMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13922, ASSERT_TYPE_ASSERT, "(hipSpreadStandMax)", (const char *)&queryFormat, "hipSpreadStandMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13923, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMin)", (const char *)&queryFormat, "hipSpreadDuckedMin") )
    __debugbreak();
  if ( !hipSpreadDuckedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13924, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMax)", (const char *)&queryFormat, "hipSpreadDuckedMax") )
    __debugbreak();
  if ( !hipSpreadProneMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13925, ASSERT_TYPE_ASSERT, "(hipSpreadProneMin)", (const char *)&queryFormat, "hipSpreadProneMin") )
    __debugbreak();
  if ( !hipSpreadProneMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13926, ASSERT_TYPE_ASSERT, "(hipSpreadProneMax)", (const char *)&queryFormat, "hipSpreadProneMax") )
    __debugbreak();
  if ( !hipSpreadDecayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13928, ASSERT_TYPE_ASSERT, "(hipSpreadDecayRate)", (const char *)&queryFormat, "hipSpreadDecayRate") )
    __debugbreak();
  if ( !hipSpreadProneDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13929, ASSERT_TYPE_ASSERT, "(hipSpreadProneDecay)", (const char *)&queryFormat, "hipSpreadProneDecay") )
    __debugbreak();
  if ( !hipSpreadDuckedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13930, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedDecay)", (const char *)&queryFormat, "hipSpreadDuckedDecay") )
    __debugbreak();
  if ( !hipSpreadTurnAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13931, ASSERT_TYPE_ASSERT, "(hipSpreadTurnAdd)", (const char *)&queryFormat, "hipSpreadTurnAdd") )
    __debugbreak();
  if ( !hipSpreadMoveAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13932, ASSERT_TYPE_ASSERT, "(hipSpreadMoveAdd)", (const char *)&queryFormat, "hipSpreadMoveAdd") )
    __debugbreak();
  if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13934, ASSERT_TYPE_ASSERT, "(hipSpreadStandMoveMax)", (const char *)&queryFormat, "hipSpreadStandMoveMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMoveMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13935, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMoveMax)", (const char *)&queryFormat, "hipSpreadDuckedMoveMax") )
    __debugbreak();
  if ( !hipSpreadProneMoveMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13936, ASSERT_TYPE_ASSERT, "(hipSpreadProneMoveMax)", (const char *)&queryFormat, "hipSpreadProneMoveMax") )
    __debugbreak();
  v29 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipSpreadStandMin = v29->fHipSpreadStandMin;
  *hipSpreadStandMax = v29->hipSpreadStandMax;
  *hipSpreadDuckedMin = v29->fHipSpreadDuckedMin;
  *hipSpreadDuckedMax = v29->hipSpreadDuckedMax;
  v30 = 0;
  *hipSpreadProneMin = v29->fHipSpreadProneMin;
  *hipSpreadProneMax = v29->hipSpreadProneMax;
  *hipSpreadSprintMin = v29->hipSpreadSprintMin;
  *hipSpreadSprintMax = v29->hipSpreadSprintMax;
  *hipSpreadInAirMin = v29->hipSpreadInAirMin;
  *hipSpreadInAirMax = v29->hipSpreadInAirMax;
  *v27 = v29->hipSpreadStandMoveMax;
  *hipSpreadDuckedMoveMax = v29->hipSpreadDuckedMoveMax;
  *hipSpreadProneMoveMax = v29->hipSpreadProneMoveMax;
  *hipSpreadSprintMoveMax = v29->hipSpreadSprintMoveMax;
  *hipSpreadInAirMoveMax = v29->hipSpreadInAirMoveMax;
  *hipSpreadDecayRate = v29->fHipSpreadDecayRate;
  *hipSpreadProneDecay = v29->fHipSpreadProneDecay;
  *hipSpreadDuckedDecay = v29->fHipSpreadDuckedDecay;
  *hipSpreadSprintDecay = v29->hipSpreadSprintDecay;
  *hipSpreadInAirDecay = v29->hipSpreadInAirDecay;
  *hipSpreadTurnAdd = v29->fHipSpreadTurnAdd;
  *hipSpreadMoveAdd = v29->fHipSpreadMoveAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v32 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v46 = v24;
    v33 = attachments;
    v34 = WeaponAttachments_Internal;
    do
    {
      if ( !*v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13969, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      hipSpreadScale = (*v33)->hipSpreadScale;
      if ( hipSpreadScale != 0.0 )
      {
        v36 = v32;
        *(float *)&v36 = *(float *)&v32 * hipSpreadScale;
        v32 = v36;
      }
      ++v33;
      --v34;
    }
    while ( v34 );
    v27 = hipSpreadStandMoveMax;
    v26 = hipSpreadDuckedMoveMax;
  }
  if ( WeaponAttachments_Internal )
  {
    v37 = attachments;
    while ( 1 )
    {
      if ( !*v37 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13976, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v38 = *v37;
      p_hipSpreadStandMin = &(*v37)->hipSpread->hipSpreadStandMin;
      if ( p_hipSpreadStandMin )
        break;
      ++v30;
      ++v37;
      if ( v30 >= WeaponAttachments_Internal )
        goto LABEL_59;
    }
    v41 = hipSpreadDuckedMax;
    v40 = hipSpreadProneMin;
    *hipSpreadStandMin = *p_hipSpreadStandMin;
    *hipSpreadStandMax = v38->hipSpread->hipSpreadMax;
    *hipSpreadDuckedMin = v38->hipSpread->hipSpreadDuckedMin;
    *hipSpreadDuckedMax = v38->hipSpread->hipSpreadDuckedMax;
    *hipSpreadProneMin = v38->hipSpread->hipSpreadProneMin;
    *hipSpreadProneMax = v38->hipSpread->hipSpreadProneMax;
    *hipSpreadSprintMin = v38->hipSpread->hipSpreadSprintMin;
    *hipSpreadSprintMax = v38->hipSpread->hipSpreadSprintMax;
    *hipSpreadInAirMin = v38->hipSpread->hipSpreadInAirMin;
    *hipSpreadInAirMax = v38->hipSpread->hipSpreadInAirMax;
    *v27 = v38->hipSpread->hipSpreadStandMoveMax;
    *v26 = v38->hipSpread->hipSpreadDuckedMoveMax;
    *hipSpreadProneMoveMax = v38->hipSpread->hipSpreadProneMoveMax;
    *hipSpreadSprintMoveMax = v38->hipSpread->hipSpreadSprintMoveMax;
    *hipSpreadInAirMoveMax = v38->hipSpread->hipSpreadInAirMoveMax;
    *hipSpreadDecayRate = v38->hipSpread->hipSpreadDecayRate;
    *hipSpreadProneDecay = v38->hipSpread->hipSpreadProneDecay;
    *hipSpreadDuckedDecay = v38->hipSpread->hipSpreadDuckedDecay;
    *hipSpreadSprintDecay = v38->hipSpread->hipSpreadSprintDecay;
    *hipSpreadInAirDecay = v38->hipSpread->hipSpreadInAirDecay;
    *hipSpreadTurnAdd = v38->hipSpread->hipSpreadTurnAdd;
    *hipSpreadMoveAdd = v38->hipSpread->hipSpreadMoveAdd;
  }
  else
  {
LABEL_59:
    v40 = hipSpreadProneMin;
    v41 = hipSpreadDuckedMax;
  }
  *hipSpreadStandMin = *(float *)&v32 * *hipSpreadStandMin;
  *hipSpreadStandMax = *(float *)&v32 * *hipSpreadStandMax;
  *hipSpreadDuckedMin = *(float *)&v32 * *hipSpreadDuckedMin;
  *v41 = *(float *)&v32 * *v41;
  *v40 = *(float *)&v32 * *v40;
  *hipSpreadProneMax = *(float *)&v32 * *hipSpreadProneMax;
  *hipSpreadSprintMin = *(float *)&v32 * *hipSpreadSprintMin;
  *hipSpreadSprintMax = *(float *)&v32 * *hipSpreadSprintMax;
  *hipSpreadInAirMin = *(float *)&v32 * *hipSpreadInAirMin;
  *hipSpreadInAirMax = *(float *)&v32 * *hipSpreadInAirMax;
  *hipSpreadDecayRate = *(float *)&v32 * *hipSpreadDecayRate;
  *hipSpreadProneDecay = *(float *)&v32 * *hipSpreadProneDecay;
  *hipSpreadDuckedDecay = *(float *)&v32 * *hipSpreadDuckedDecay;
  *hipSpreadSprintDecay = *(float *)&v32 * *hipSpreadSprintDecay;
  *hipSpreadInAirDecay = *(float *)&v32 * *hipSpreadInAirDecay;
  *hipSpreadTurnAdd = *(float *)&v32 * *hipSpreadTurnAdd;
  *hipSpreadMoveAdd = *(float *)&v32 * *hipSpreadMoveAdd;
  *v27 = *(float *)&v32 * *v27;
  *v26 = *(float *)&v32 * *v26;
  *hipSpreadProneMoveMax = *(float *)&v32 * *hipSpreadProneMoveMax;
  *hipSpreadSprintMoveMax = *(float *)&v32 * *hipSpreadSprintMoveMax;
  *hipSpreadInAirMoveMax = *(float *)&v32 * *hipSpreadInAirMoveMax;
}

/*
==============
BG_GetHitmarkerType
==============
*/
__int64 BG_GetHitmarkerType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  HitmarkerType hitmarkerType; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttHitmarker *hitmarker; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v10; 
  __int64 v11; 
  AttHitmarker *v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  hitmarkerType = HITMARKER_TYPE_SMALL;
  if ( v4 )
    hitmarkerType = v4->hitmarkerType;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
  {
    hitmarker = WeaponPrimaryAttachment->hitmarker;
    if ( hitmarker )
      return (unsigned int)hitmarker->hitmarkerType;
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    v11 = WeaponAttachments_Internal;
    do
    {
      v12 = (*v10)->hitmarker;
      if ( v12 )
      {
        if ( v12->hitmarkerType > hitmarkerType )
          hitmarkerType = v12->hitmarkerType;
      }
      ++v10;
      --v11;
    }
    while ( v11 );
  }
  return (unsigned int)hitmarkerType;
}

/*
==============
BG_GetHudOutlineAltInScopeColor
==============
*/
void BG_GetHudOutlineAltInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3174, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3175, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3186, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[4];
    outColor->v[1] = v[5];
    outColor->v[2] = v[6];
    v12 = v[7];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineDepthTest
==============
*/
bool BG_GetHudOutlineDepthTest(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3361, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3362, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3373, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineDepthTest;
}

/*
==============
BG_GetHudOutlineFill
==============
*/
bool BG_GetHudOutlineFill(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3386, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3387, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3398, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineFill;
}

/*
==============
BG_GetHudOutlineFillColor0
==============
*/
void BG_GetHudOutlineFillColor0(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3201, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3202, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3213, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[8];
    outColor->v[1] = v[9];
    outColor->v[2] = v[10];
    v12 = v[11];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineFillColor1
==============
*/
void BG_GetHudOutlineFillColor1(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3228, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3229, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3240, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[12];
    outColor->v[1] = v[13];
    outColor->v[2] = v[14];
    v12 = v[15];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineInScopeColor
==============
*/
void BG_GetHudOutlineInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3147, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3148, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3159, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = *v;
    outColor->v[1] = v[1];
    outColor->v[2] = v[2];
    v12 = v[3];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineOccludedInlineColor
==============
*/
void BG_GetHudOutlineOccludedInlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3282, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3283, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3294, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[20];
    outColor->v[1] = v[21];
    outColor->v[2] = v[22];
    v12 = v[23];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineOccludedInteriorColor
==============
*/
void BG_GetHudOutlineOccludedInteriorColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3309, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3310, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3321, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[24];
    outColor->v[1] = v[25];
    outColor->v[2] = v[26];
    v12 = v[27];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineOccludedOutlineColor
==============
*/
void BG_GetHudOutlineOccludedOutlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  float *v; 
  float v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3255, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3256, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3267, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v = (*v10)->outline->outlineColor.v;
      if ( v )
        break;
      ++v9;
      ++v10;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    outColor->v[0] = v[16];
    outColor->v[1] = v[17];
    outColor->v[2] = v[18];
    v12 = v[19];
  }
  else
  {
LABEL_14:
    *(_QWORD *)outColor->v = 0i64;
    outColor->v[2] = 0.0;
    v12 = 0.0;
  }
  outColor->v[3] = v12;
}

/*
==============
BG_GetHudOutlineScriptControlled
==============
*/
bool BG_GetHudOutlineScriptControlled(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3411, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3412, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3423, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineScriptControlled;
}

/*
==============
BG_GetHudOutlineWeapon
==============
*/
_BOOL8 BG_GetHudOutlineWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  bool outlineEnemies; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3134, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3135, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  outlineEnemies = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->outlineEnemies;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return outlineEnemies;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7685, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return outlineEnemies;
  }
  return outline->outlineEnemies;
}

/*
==============
BG_GetHudOutlineWidth
==============
*/
float BG_GetHudOutlineWidth(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3336, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3337, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return FLOAT_1_0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3348, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return FLOAT_1_0;
  }
  return outline->outlineWidth;
}

/*
==============
BG_GetHybridScopeEnablerAttachment
==============
*/
WeaponAttachment *BG_GetHybridScopeEnablerAttachment(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **outDataAttachment)
{
  int v3; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v7; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  if ( outDataAttachment )
    *outDataAttachment = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0i64;
  for ( i = attachments; ; ++i )
  {
    v7 = *i;
    if ( !*i )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
    }
    adsOverlay = v7->adsOverlay;
    if ( adsOverlay )
    {
      if ( adsOverlay->hybridToggle )
        break;
    }
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0i64;
  }
  if ( outDataAttachment )
    *outDataAttachment = adsOverlay->hybridScopeAttachment;
  return v7;
}

/*
==============
BG_GetHybridScopeInfo
==============
*/
void BG_GetHybridScopeInfo(const Weapon *r_weapon, bool isAlternate, BgHybridScopeInfo *outHybridScopeInfo)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v7; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  outHybridScopeInfo->hybridScopeAttachment = NULL;
  *(_QWORD *)&outHybridScopeInfo->hybridScope1To2FovTransBegin = 0i64;
  v4 = 0;
  *(_QWORD *)&outHybridScopeInfo->hybridScope2To1FovTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hybridScope1To2ScopeFadeTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hybridScope2To1ScopeFadeTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hasHybridScope = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      v7 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7523, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v7->type == ATTACHMENT_SCOPE )
      {
        adsOverlay = v7->adsOverlay;
        if ( adsOverlay )
        {
          if ( adsOverlay->hybridToggle )
            break;
        }
      }
      if ( ++v4 >= WeaponAttachments_Internal )
        return;
    }
    outHybridScopeInfo->hasHybridScope = 1;
    outHybridScopeInfo->hybridScopeAttachment = v7->adsOverlay->hybridScopeAttachment;
    outHybridScopeInfo->hybridScope1To2FovTransBegin = v7->adsOverlay->hybridScope1To2FovTransBegin;
    outHybridScopeInfo->hybridScope1To2FovTransEnd = v7->adsOverlay->hybridScope1To2FovTransEnd;
    outHybridScopeInfo->hybridScope2To1FovTransBegin = v7->adsOverlay->hybridScope2To1FovTransBegin;
    outHybridScopeInfo->hybridScope2To1FovTransEnd = v7->adsOverlay->hybridScope2To1FovTransEnd;
    outHybridScopeInfo->hybridScope1To2ScopeFadeTransBegin = v7->adsOverlay->hybridScope1To2ScopeFadeTransBegin;
    outHybridScopeInfo->hybridScope1To2ScopeFadeTransEnd = v7->adsOverlay->hybridScope1To2ScopeFadeTransEnd;
    outHybridScopeInfo->hybridScope2To1ScopeFadeTransBegin = v7->adsOverlay->hybridScope2To1ScopeFadeTransBegin;
    outHybridScopeInfo->hybridScope2To1ScopeFadeTransEnd = v7->adsOverlay->hybridScope2To1ScopeFadeTransEnd;
  }
}

/*
==============
BG_GetHyperBurstInfo
==============
*/
const HyperBurstInfo *BG_GetHyperBurstInfo(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const HyperBurstInfo *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hyperBurstInfo;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22322, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->hyperBurstInfo;
    if ( result )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hyperBurstInfo;
  }
  return result;
}

/*
==============
BG_GetIgnoreHitEntityCount
==============
*/
__int64 BG_GetIgnoreHitEntityCount(const BulletFireParams *bp)
{
  __int64 result; 

  result = (unsigned int)bp->ignoreHitEntCount;
  if ( (int)result >= 16 )
    return 16i64;
  return result;
}

/*
==============
BG_GetImpactDamageAndModForProjectile
==============
*/
__int64 BG_GetImpactDamageAndModForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, const vec3_t *origStart, vec3_t *hitPos, meansOfDeath_t *outMOD)
{
  weapClass_t weapClass; 
  int BulletDamageForProjectile; 
  unsigned int v12; 
  bool v13; 
  __int64 result; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16674, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( !outMOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16679, ASSERT_TYPE_ASSERT, "(outMOD)", (const char *)&queryFormat, "outMOD") )
    __debugbreak();
  weapClass = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapClass;
  if ( weapClass < WEAPCLASS_RIFLE )
    goto LABEL_11;
  if ( weapClass > WEAPCLASS_SPREAD )
  {
    if ( weapClass == WEAPCLASS_PISTOL )
    {
      BulletDamageForProjectile = BG_GetBulletDamageForProjectile(damageCalcType, r_weapon, isAlternate, rangeScale, origStart, hitPos);
      *outMOD = MOD_PISTOL_BULLET;
      goto LABEL_12;
    }
    if ( weapClass != WEAPCLASS_BEAM )
    {
LABEL_11:
      BulletDamageForProjectile = BG_GetDamage(damageCalcType, r_weapon, isAlternate);
      *outMOD = MOD_IMPACT;
      goto LABEL_12;
    }
  }
  BulletDamageForProjectile = BG_GetBulletDamageForProjectile(damageCalcType, r_weapon, isAlternate, rangeScale, origStart, hitPos);
  *outMOD = MOD_RIFLE_BULLET;
LABEL_12:
  v12 = BulletDamageForProjectile;
  v13 = !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet;
  result = v12;
  if ( !v13 )
    *outMOD = MOD_FIRE_BULLET;
  return result;
}

/*
==============
BG_GetKickAlignedInputScalar
==============
*/
float BG_GetKickAlignedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->kickAlignedInputScalar;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20735, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->kickAlignedInputScalar;
  }
  return AttachmentViewKick->kickAlignedInputScalar;
}

/*
==============
BG_GetKickOpposedInputScalar
==============
*/
float BG_GetKickOpposedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->kickOpposedInputScalar;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20757, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->kickOpposedInputScalar;
  }
  return AttachmentViewKick->kickOpposedInputScalar;
}

/*
==============
BG_GetLUICrosshairWidget
==============
*/
const char *BG_GetLUICrosshairWidget(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  const char *szLUICrosshairWidget; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  szLUICrosshairWidget = BG_WeaponCompleteDef(r_weapon, isAlternate)->szLUICrosshairWidget;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return szLUICrosshairWidget;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16522, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return szLUICrosshairWidget;
  }
  return general->szLUICrosshairWidget;
}

/*
==============
BG_GetLasers
==============
*/
void BG_GetLasers(const Weapon *r_weapon, const LaserDef **viewModelLaser, const LaserDef **viewModelLaserAlt, const LaserDef **friendlyLaser, const LaserDef **enemyLaser)
{
  const WeaponDef *v9; 
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  WeaponAttachment *v13; 
  const LaserDef **p_laserTypeViewModel; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !friendlyLaser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7165, ASSERT_TYPE_ASSERT, "(friendlyLaser)", (const char *)&queryFormat, "friendlyLaser") )
    __debugbreak();
  if ( !enemyLaser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7166, ASSERT_TYPE_ASSERT, "(enemyLaser)", (const char *)&queryFormat, "enemyLaser") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7169, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *viewModelLaser = v9->laserTypeViewModel;
  v10 = 0;
  *viewModelLaserAlt = v9->laserTypeViewModelAlt;
  *friendlyLaser = v9->laserTypeFriendly;
  *enemyLaser = v9->laserTypeEnemy;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, 0, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    do
    {
      v13 = *v12;
      if ( *v12 )
      {
        p_laserTypeViewModel = (const LaserDef **)&v13->laser->laserTypeViewModel;
        if ( p_laserTypeViewModel )
        {
          *viewModelLaser = *p_laserTypeViewModel;
          *viewModelLaserAlt = v13->laser->laserTypeViewModelAlt;
          *friendlyLaser = v13->laser->laserTypeFriendly;
          *enemyLaser = v13->laser->laserTypeEnemy;
          return;
        }
      }
      else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7183, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      {
        __debugbreak();
      }
      ++v10;
      ++v12;
    }
    while ( v10 < WeaponAttachments_Internal );
  }
}

/*
==============
BG_GetLinearDamageRange
==============
*/
void BG_GetLinearDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *minDamageRange, float *maxDamageRange)
{
  float *v6; 
  float *v8; 
  __int64 v10; 
  const WeaponDef *v12; 
  float v13; 
  float v14; 
  unsigned int v15; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v18; 
  __int64 v19; 
  float damageScale; 
  __int128 v21; 
  __int128 v23; 
  WeaponAttachment **v29; 
  AttDamage *damage; 
  float v31; 
  float v32; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = maxDamageRange;
  v8 = minDamageRange;
  v10 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9423, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( !minDamageRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9431, ASSERT_TYPE_ASSERT, "(minDamageRange)", (const char *)&queryFormat, "minDamageRange") )
    __debugbreak();
  if ( !maxDamageRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9432, ASSERT_TYPE_ASSERT, "(maxDamageRange)", (const char *)&queryFormat, "maxDamageRange") )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( (unsigned int)v10 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v13 = v12->damageInfo.damageData[v10].minDamageRange;
  if ( v13 < 0.0 )
    v13 = v12->damageInfo.damageData[0].minDamageRange;
  *minDamageRange = v13;
  v14 = v12->damageInfo.damageData[v10].maxDamageRange;
  if ( v14 < 0.0 )
    v14 = v12->damageInfo.damageData[0].maxDamageRange;
  v15 = 0;
  *maxDamageRange = v14;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v18 = attachments;
    v19 = WeaponAttachments_Internal;
    do
    {
      if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9449, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damageScale = (*v18)->damageScale;
      if ( damageScale != 0.0 )
      {
        v21 = _XMM6;
        *(float *)&v21 = (float)(*(float *)&_XMM6 + damageScale) - 1.0;
        _XMM6 = v21;
      }
      ++v18;
      --v19;
    }
    while ( v19 );
    v6 = maxDamageRange;
    v8 = minDamageRange;
  }
  __asm { vmaxss  xmm3, xmm6, xmm7 }
  v23 = LODWORD(FLOAT_1_0);
  *(float *)&v23 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v23 + 1) = (v23 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v23 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM2 = v23;
  __asm
  {
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm8, xmm0
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm8, xmm3, xmm8, xmm0
  }
  if ( WeaponAttachments_Internal )
  {
    v29 = attachments;
    while ( 1 )
    {
      if ( !*v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9461, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damage = (*v29)->damage;
      if ( damage )
        break;
      ++v15;
      ++v29;
      if ( v15 >= WeaponAttachments_Internal )
        goto LABEL_42;
    }
    if ( (unsigned int)v10 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa) )
        __debugbreak();
    }
    v31 = damage->damageInfo.damageData[v10].minDamageRange;
    if ( v31 < 0.0 )
      v31 = damage->damageInfo.damageData[0].minDamageRange;
    *v8 = v31;
    v32 = damage->damageInfo.damageData[v10].maxDamageRange;
    if ( v32 < 0.0 )
      *v6 = damage->damageInfo.damageData[0].maxDamageRange;
    else
      *v6 = v32;
  }
LABEL_42:
  *v8 = *(float *)&_XMM6 * *v8;
  *v6 = *(float *)&_XMM8 * *v6;
  *v8 = rangeScale * *v8;
  *v6 = rangeScale * *v6;
}

/*
==============
BG_GetLocationDamageMultipliers
==============
*/
const float *BG_GetLocationDamageMultipliers(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float *locationDamageMultipliers; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const float *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  locationDamageMultipliers = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->locationDamageMultipliers;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return locationDamageMultipliers;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9518, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->locationDamage;
    if ( result )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return locationDamageMultipliers;
  }
  return result;
}

/*
==============
BG_GetMeleeAutoAimHeight
==============
*/
float BG_GetMeleeAutoAimHeight(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9076, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->aim_automelee_region_height;
  v4 = DCONST_DVARMPSPFLT_aim_automelee_region_height;
  if ( !DCONST_DVARMPSPFLT_aim_automelee_region_height && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_region_height") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeAutoAimLerp
==============
*/
float BG_GetMeleeAutoAimLerp(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9012, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->aim_automelee_lerp;
  v4 = DCONST_DVARFLT_aim_automelee_lerp;
  if ( !DCONST_DVARFLT_aim_automelee_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_lerp") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeAutoAimMaxPitchMovement
==============
*/
float BG_GetMeleeAutoAimMaxPitchMovement(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9028, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->aim_automelee_maxPitchMovement;
  v4 = DCONST_DVARFLT_aim_automelee_maxPitchMovement;
  if ( !DCONST_DVARFLT_aim_automelee_maxPitchMovement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_maxPitchMovement") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeAutoAimMaxYawMovement
==============
*/
float BG_GetMeleeAutoAimMaxYawMovement(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9044, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->aim_automelee_maxYawMovement;
  v4 = DCONST_DVARFLT_aim_automelee_maxYawMovement;
  if ( !DCONST_DVARFLT_aim_automelee_maxYawMovement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_maxYawMovement") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeAutoAimWidth
==============
*/
float BG_GetMeleeAutoAimWidth(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9060, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->aim_automelee_region_width;
  v4 = DCONST_DVARMPSPFLT_aim_automelee_region_width;
  if ( !DCONST_DVARMPSPFLT_aim_automelee_region_width && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_region_width") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeComboSeqCount
==============
*/
__int64 BG_GetMeleeComboSeqCount(const Weapon *r_weapon)
{
  int v2; 
  unsigned int v3; 
  const WeaponDef *v4; 
  const WeaponDef *v5; 
  unsigned int numAnimOverrides; 
  __int64 v7; 
  const WeaponCompleteDef *v8; 
  OverrideBinding *bindings; 
  __int64 slot; 
  __int64 v13; 
  __int64 v15; 
  __int64 v16; 

  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19780, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  v2 = 1;
  v3 = 0;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4->numAnimOverrides )
    goto LABEL_27;
  do
  {
    v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    numAnimOverrides = v5->numAnimOverrides;
    if ( !numAnimOverrides )
      break;
    if ( v3 >= numAnimOverrides )
    {
      LODWORD(v16) = v5->numAnimOverrides;
      LODWORD(v15) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19733, ASSERT_TYPE_ASSERT, "(unsigned)( overrideIndex ) < (unsigned)( weapDef->numAnimOverrides )", "overrideIndex doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    v7 = v3;
    if ( !v5->animOverrides[v7].numBindings )
      break;
    v8 = BG_WeaponCompleteDef(r_weapon, 0);
    bindings = v5->animOverrides[v7].bindings;
    if ( !bindings->numBindingLists && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19741, ASSERT_TYPE_ASSERT, "(overrideBinding->numBindingLists != 0)", (const char *)&queryFormat, "overrideBinding->numBindingLists != 0") )
      __debugbreak();
    _RBX = bindings->bindingLists;
    if ( _RBX->slot >= (unsigned int)ATT_SLOT_COUNT )
    {
      LODWORD(v16) = 14;
      LODWORD(v15) = _RBX->slot;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19744, ASSERT_TYPE_ASSERT, "(unsigned)( overrideList->slot ) < (unsigned)( ATT_SLOT_COUNT )", "overrideList->slot doesn't index ATT_SLOT_COUNT\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    slot = _RBX->slot;
    __asm { tzcnt   ebx, [rbx+4] }
    v13 = (__int64)&v8->attachments[slot];
    if ( _EBX >= *(_DWORD *)v13 )
    {
      LODWORD(v16) = *(_DWORD *)v13;
      LODWORD(v15) = _EBX;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19748, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentList->attachmentCount )", "attachmentIndex doesn't index attachmentList->attachmentCount\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 8i64 * _EBX) + 16i64) != scr_const.combosequence )
      break;
    ++v2;
    ++v3;
  }
  while ( v3 < v4->numAnimOverrides );
  if ( v2 <= 1 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19802, ASSERT_TYPE_ASSERT, "(comboCount > 1)", (const char *)&queryFormat, "comboCount > 1") )
      __debugbreak();
  }
  return (unsigned int)v2;
}

/*
==============
BG_GetMeleeCountToFinisher
==============
*/
bool BG_GetMeleeCountToFinisher(const Weapon *r_weapon, bool isAlternate, int *outCountToFinisher)
{
  unsigned int v3; 
  const dvar_t *v7; 
  bool result; 
  const WeaponDef *v9; 
  bool hasMeleeFinisher; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v12; 
  WeaponAttachment **v13; 
  AttMelee *melee; 
  WeaponAttachment **v15; 
  __int64 v16; 
  __int64 v17; 
  int v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  if ( !outCountToFinisher && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8846, ASSERT_TYPE_ASSERT, "( outCountToFinisher ) != ( nullptr )", "%s != %s\n\t%p, %p", "outCountToFinisher", "nullptr", NULL, NULL) )
    __debugbreak();
  v7 = DCONST_DVARMPBOOL_player_meleeFinisherEnabled;
  if ( !DCONST_DVARMPBOOL_player_meleeFinisherEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeFinisherEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return 0;
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  hasMeleeFinisher = v9->hasMeleeFinisher;
  *outCountToFinisher = v9->iMeleeCountToFinisher;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v13 = attachments;
    while ( 1 )
    {
      if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8863, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      melee = (*v13)->melee;
      if ( melee )
        break;
      ++v3;
      ++v13;
      if ( v3 >= (unsigned int)v12 )
        goto LABEL_18;
    }
    hasMeleeFinisher = melee->hasMeleeFinisher;
    *outCountToFinisher = melee->meleeCountToFinisher;
LABEL_18:
    v15 = attachments;
    v16 = v12;
    do
    {
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8875, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v17 = (__int64)*v15++;
      v18 = *outCountToFinisher + *(_DWORD *)(v17 + 892);
      *outCountToFinisher = v18;
      --v16;
    }
    while ( v16 );
  }
  else
  {
    v18 = *outCountToFinisher;
  }
  if ( v18 > 7 )
    v18 = 7;
  if ( v18 < 1 )
    v18 = 1;
  result = hasMeleeFinisher;
  *outCountToFinisher = v18;
  return result;
}

/*
==============
BG_GetMeleeDamage
==============
*/
__int64 BG_GetMeleeDamage(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  int iMeleeDamage; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v7; 
  WeaponAttachment **v8; 
  AttMelee *melee; 
  WeaponAttachment **v10; 
  float meleeDamageScale; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iMeleeDamage = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iMeleeDamage;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v7 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v8 = attachments;
    while ( 1 )
    {
      if ( !*v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8821, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      melee = (*v8)->melee;
      if ( melee )
        break;
      ++v4;
      ++v8;
      if ( v4 >= (unsigned int)v7 )
        goto LABEL_10;
    }
    iMeleeDamage = melee->meleeDamage;
LABEL_10:
    v10 = attachments;
    do
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8832, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      meleeDamageScale = (*v10)->meleeDamageScale;
      if ( meleeDamageScale > 0.0 )
        iMeleeDamage = (int)(float)((float)iMeleeDamage * meleeDamageScale);
      ++v10;
      --v7;
    }
    while ( v7 );
  }
  return (unsigned int)iMeleeDamage;
}

/*
==============
BG_GetMeleeHeight
==============
*/
float BG_GetMeleeHeight(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8996, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->player_meleeHeight;
  v4 = DCONST_DVARFLT_player_meleeHeight;
  if ( !DCONST_DVARFLT_player_meleeHeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeHeight") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMeleeInterruptTime
==============
*/
void BG_GetMeleeInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outToMeleeInterruptTime, int *outInterruptTime, int *outToFireInterruptTime)
{
  int *v8; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v13; 
  bool v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  float value; 
  __int128 v20; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  WeaponAttachment **v25; 
  __int64 v26; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v28; 
  __int128 v30; 
  const dvar_t *v34; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = outToMeleeInterruptTime;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10059, ASSERT_TYPE_ASSERT, "( weaponMap ) != ( nullptr )", "%s != %s\n\t%p, %p", "weaponMap", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10060, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outToMeleeInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10061, ASSERT_TYPE_ASSERT, "( outToMeleeInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outToMeleeInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10062, ASSERT_TYPE_ASSERT, "( outInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outToFireInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10063, ASSERT_TYPE_ASSERT, "( outToFireInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outToFireInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v13 = BG_UsingAlternateMelee(ps);
  if ( isFatal )
  {
    v14 = !v13;
    v15 = 42i64;
    v16 = 44i64;
    if ( v13 )
      v15 = 66i64;
    if ( v13 )
      v16 = 68i64;
    v17 = 40i64;
    v18 = 64i64;
  }
  else
  {
    v14 = !v13;
    v15 = 34i64;
    v16 = 36i64;
    if ( v13 )
      v15 = 58i64;
    v17 = 30i64;
    if ( v13 )
      v16 = 60i64;
    v18 = 54i64;
  }
  if ( !v14 )
    v17 = v18;
  *outToMeleeInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v15, NUM_WEAP_ANIMS);
  *outInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v16, NUM_WEAP_ANIMS);
  value = FLOAT_1_0;
  *outToFireInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v17, NUM_WEAP_ANIMS);
  v20 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v23 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM1 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v25 = attachments;
    v26 = WeaponAttachments_Internal;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, CurrentWeaponForPlayer, isAlternate, *v25, v23);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10097, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v28 = v20;
      ++v25;
      *(float *)&v28 = (float)(*(float *)&v20 + OverrideAttachmentWhenApplicable->stateTimersScale) - 1.0;
      v20 = v28;
      _XMM1 = v28;
      --v26;
    }
    while ( v26 );
    v8 = outToMeleeInterruptTime;
  }
  __asm { vmaxss  xmm3, xmm1, xmm0 }
  v30 = LODWORD(FLOAT_1_0);
  *(float *)&v30 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v30 + 1) = (v30 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v30 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM0 = v30;
  __asm
  {
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm7, xmm3, xmm6, xmm2
  }
  if ( BG_HasPerk(&ps->perks, 0x19u) )
  {
    v34 = DCONST_DVARFLT_perk_fasterMeleeScale;
    if ( !DCONST_DVARFLT_perk_fasterMeleeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fasterMeleeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v34);
    value = v34->current.value;
  }
  *v8 = (int)(float)((float)((float)*v8 * *(float *)&_XMM7) * value);
  *outInterruptTime = (int)(float)((float)((float)*outInterruptTime * *(float *)&_XMM7) * value);
  *outToFireInterruptTime = (int)(float)((float)((float)*outToFireInterruptTime * *(float *)&_XMM7) * value);
}

/*
==============
BG_GetMeleeRange
==============
*/
float BG_GetMeleeRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const bool getChargeRange)
{
  const Weapon *CurrentWeaponForPlayer; 
  const WeaponDef *v7; 
  bool v8; 
  unsigned __int16 weaponIdx; 
  bool HasPerk; 
  bool v11; 
  EffectiveStance EffectiveStance; 
  float MeleeRangeInternal; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8939, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8940, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  BG_UsingAlternate(ps);
  v7 = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8945, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v8 = BG_UsingAlternate(ps);
  if ( !BG_IsMeleeOnlyWeapon(CurrentWeaponForPlayer, v8) )
  {
    weaponIdx = BG_GetFirstEquippedWeaponBySlot(weaponMap, ps, WEAPON_SLOT_MELEE)->weaponIdx;
    if ( weaponIdx )
    {
      v7 = BG_WeaponDefAtIndex(weaponIdx);
      if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8953, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
    }
  }
  HasPerk = BG_HasPerk(&ps->perks, 0x14u);
  v11 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x1Du);
  EffectiveStance = PM_GetEffectiveStance(ps);
  MeleeRangeInternal = BG_GetMeleeRangeInternal(v7, getChargeRange, HasPerk, EffectiveStance);
  return MeleeRangeInternal * BG_GetMeleeRangeSlideScale(v11);
}

/*
==============
BG_GetMeleeRangeByWeapon
==============
*/
float BG_GetMeleeRangeByWeapon(const Weapon *r_weapon, const bool isAlternate, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance, const bool isSliding)
{
  const WeaponDef *v9; 
  float MeleeRangeInternal; 

  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8965, ASSERT_TYPE_ASSERT, "(r_weapon.weaponIdx != 0)", (const char *)&queryFormat, "r_weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8969, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  MeleeRangeInternal = BG_GetMeleeRangeInternal(v9, getChargeRange, hasExtendedMelee, stance);
  return MeleeRangeInternal * BG_GetMeleeRangeSlideScale(isSliding);
}

/*
==============
BG_GetMeleeRangeInternal
==============
*/
float BG_GetMeleeRangeInternal(const WeaponDef *weapDef, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance)
{
  const dvar_t *v8; 
  double Float_Internal_DebugName; 
  __int32 v10; 
  __int32 v11; 
  __int32 v12; 
  __int32 v13; 
  const dvar_t *v14; 
  const char *v15; 

  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8888, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( getChargeRange && hasExtendedMelee )
  {
    v8 = DCONST_DVARFLT_perk_extendedMeleeRange;
    if ( !DCONST_DVARFLT_perk_extendedMeleeRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_extendedMeleeRange") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    LODWORD(Float_Internal_DebugName) = v8->current.integer;
    return *(float *)&Float_Internal_DebugName;
  }
  if ( weapDef->meleeOverrideValues )
  {
    if ( stance == PM_EFF_STANCE_DEFAULT )
      goto LABEL_15;
    v10 = stance - 1;
    if ( !v10 )
    {
      *(float *)&Float_Internal_DebugName = weapDef->playerMeleeRangeProne;
      return *(float *)&Float_Internal_DebugName;
    }
    v11 = v10 - 1;
    if ( !v11 )
    {
      if ( getChargeRange )
        *(float *)&Float_Internal_DebugName = weapDef->playerMeleeRangeChargeCrouched;
      else
        *(float *)&Float_Internal_DebugName = weapDef->playerMeleeRangeCrouched;
      return *(float *)&Float_Internal_DebugName;
    }
    if ( v11 == 1 )
    {
LABEL_15:
      if ( getChargeRange )
        *(float *)&Float_Internal_DebugName = weapDef->playerMeleeRangeChargeStanding;
      else
        *(float *)&Float_Internal_DebugName = weapDef->playerMeleeRangeStanding;
      return *(float *)&Float_Internal_DebugName;
    }
    goto LABEL_26;
  }
  if ( stance == PM_EFF_STANCE_DEFAULT )
    goto LABEL_33;
  v12 = stance - 1;
  if ( !v12 )
  {
    v14 = DCONST_DVARFLT_player_meleeRangeProne;
    v15 = "player_meleeRangeProne";
LABEL_36:
    Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(v14, v15);
    return *(float *)&Float_Internal_DebugName;
  }
  v13 = v12 - 1;
  if ( !v13 )
  {
    if ( getChargeRange )
    {
      v14 = DCONST_DVARFLT_player_meleeRangeChargeCrouched;
      v15 = "player_meleeRangeChargeCrouched";
    }
    else
    {
      v14 = DCONST_DVARFLT_player_meleeRangeCrouched;
      v15 = "player_meleeRangeCrouched";
    }
    goto LABEL_36;
  }
  if ( v13 == 1 )
  {
LABEL_33:
    if ( getChargeRange )
    {
      v14 = DCONST_DVARFLT_player_meleeRangeChargeStanding;
      v15 = "player_meleeRangeChargeStanding";
    }
    else
    {
      v14 = DCONST_DVARFLT_player_meleeRangeStanding;
      v15 = "player_meleeRangeStanding";
    }
    goto LABEL_36;
  }
LABEL_26:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8926, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "unreachable code") )
    __debugbreak();
  LODWORD(Float_Internal_DebugName) = 0;
  return *(float *)&Float_Internal_DebugName;
}

/*
==============
BG_GetMeleeRangeSlideScale
==============
*/
float BG_GetMeleeRangeSlideScale(const bool isSliding)
{
  const dvar_t *v1; 

  if ( !isSliding )
    return FLOAT_1_0;
  v1 = DCONST_DVARMPSPFLT_player_meleeRangeSlideScale;
  if ( !DCONST_DVARMPSPFLT_player_meleeRangeSlideScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeRangeSlideScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  return v1->current.value;
}

/*
==============
BG_GetMeleeTime
==============
*/
void BG_GetMeleeTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outMeleeTime, int *outMeleeDamageTime, int *outMeleeViewLockTime)
{
  int *v8; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  float value; 
  __int128 v18; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v21; 
  WeaponAttachment **v23; 
  __int64 v24; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v26; 
  __int128 v28; 
  const dvar_t *v32; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = outMeleeTime;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9980, ASSERT_TYPE_ASSERT, "( weaponMap ) != ( nullptr )", "%s != %s\n\t%p, %p", "weaponMap", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9981, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9982, ASSERT_TYPE_ASSERT, "( outMeleeTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeDamageTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9983, ASSERT_TYPE_ASSERT, "( outMeleeDamageTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeDamageTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeViewLockTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9984, ASSERT_TYPE_ASSERT, "( outMeleeViewLockTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeViewLockTime", "nullptr", NULL, NULL) )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v13 = BG_UsingAlternateMelee(ps);
  if ( isFatal )
  {
    if ( v13 )
    {
      v14 = 48i64;
      v15 = 62i64;
      v16 = 50i64;
    }
    else
    {
      v14 = 24i64;
      v15 = 38i64;
      v16 = 26i64;
    }
  }
  else if ( v13 )
  {
    v14 = 46i64;
    v15 = 52i64;
    v16 = 56i64;
  }
  else
  {
    v14 = 22i64;
    v15 = 28i64;
    v16 = 32i64;
  }
  *outMeleeTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v14, NUM_WEAP_ANIMS);
  *outMeleeDamageTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v15, NUM_WEAP_ANIMS);
  value = FLOAT_1_0;
  *outMeleeViewLockTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v16, NUM_WEAP_ANIMS);
  v18 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v21 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM1 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v23 = attachments;
    v24 = WeaponAttachments_Internal;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, CurrentWeaponForPlayer, isAlternate, *v23, v21);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10037, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v26 = v18;
      ++v23;
      *(float *)&v26 = (float)(*(float *)&v18 + OverrideAttachmentWhenApplicable->stateTimersScale) - 1.0;
      v18 = v26;
      _XMM1 = v26;
      --v24;
    }
    while ( v24 );
    v8 = outMeleeTime;
  }
  __asm { vmaxss  xmm3, xmm1, xmm0 }
  v28 = LODWORD(FLOAT_1_0);
  *(float *)&v28 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v28 + 1) = (v28 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v28 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM0 = v28;
  __asm
  {
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm7, xmm3, xmm6, xmm2
  }
  if ( BG_HasPerk(&ps->perks, 0x19u) )
  {
    v32 = DCONST_DVARFLT_perk_fasterMeleeScale;
    if ( !DCONST_DVARFLT_perk_fasterMeleeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fasterMeleeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    value = v32->current.value;
  }
  *v8 = (int)(float)((float)((float)*v8 * *(float *)&_XMM7) * value);
  *outMeleeDamageTime = (int)(float)((float)((float)*outMeleeDamageTime * *(float *)&_XMM7) * value);
  *outMeleeViewLockTime = (int)(float)((float)((float)*outMeleeViewLockTime * *(float *)&_XMM7) * value);
}

/*
==============
BG_GetMeleeWidth
==============
*/
float BG_GetMeleeWidth(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 
  const dvar_t *v4; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8980, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v2->meleeOverrideValues )
    return v2->player_meleeWidth;
  v4 = DCONST_DVARFLT_player_meleeWidth;
  if ( !DCONST_DVARFLT_player_meleeWidth && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeWidth") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.value;
}

/*
==============
BG_GetMidDamage
==============
*/
void BG_GetMidDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMid1Damage, int *outMid2Damage, int *outMid3Damage)
{
  __int64 v8; 
  const WeaponDef *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttDamage *damage; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  __int64 v19; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8786, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( (unsigned int)v8 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v11 = 0;
  *outMid1Damage = v10->damageInfo.damageData[v8].mid1Damage;
  *outMid2Damage = v10->damageInfo.damageData[v8].mid2Damage;
  *outMid3Damage = v10->damageInfo.damageData[v8].mid3Damage;
  v19 = v8;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8800, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damage = (*i)->damage;
      if ( damage )
        break;
      if ( ++v11 >= WeaponAttachments_Internal )
        return;
    }
    if ( (unsigned int)v8 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa) )
        __debugbreak();
    }
    *outMid1Damage = damage->damageInfo.damageData[v19].mid1Damage;
    *outMid2Damage = damage->damageInfo.damageData[v19].mid2Damage;
    *outMid3Damage = damage->damageInfo.damageData[v19].mid3Damage;
  }
}

/*
==============
BG_GetMinDamage
==============
*/
__int64 BG_GetMinDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  __int64 v8; 
  int v9; 
  __int64 v10; 
  int outMinDamage; 
  int outMaxDamage; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v9 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8678, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v9) )
      __debugbreak();
    LODWORD(v10) = 3;
    LODWORD(v8) = damageCalcType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8680, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", v8, v10) )
      __debugbreak();
  }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (unsigned int)outMinDamage;
}

/*
==============
BG_GetMinMaxDamage
==============
*/
void BG_GetMinMaxDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMinDamage, int *outMaxDamage)
{
  __int64 v6; 
  const WeaponDef *v9; 
  __int64 v10; 
  int minDamage; 
  int damage; 
  int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  int *v16; 
  int v17; 
  int v18; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8759, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( (unsigned int)v6 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v10 = 10 * v6;
  minDamage = v9->damageInfo.damageData[v6].minDamage;
  if ( minDamage < 0 )
    minDamage = v9->damageInfo.damageData[0].minDamage;
  *outMinDamage = minDamage;
  damage = v9->damageInfo.damageData[(unsigned __int64)v10 / 0xA].damage;
  if ( damage < 0 )
    damage = v9->damageInfo.damageData[0].damage;
  *outMaxDamage = damage;
  v13 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8774, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v16 = (int *)(*i)->damage;
      if ( v16 )
        break;
      if ( ++v13 >= WeaponAttachments_Internal )
        return;
    }
    if ( (unsigned int)v6 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa) )
        __debugbreak();
    }
    v17 = v16[v10];
    if ( v17 < 0 )
      v17 = *v16;
    *outMinDamage = v17;
    v18 = v16[v10 + 4];
    if ( v18 < 0 )
      v18 = v16[4];
    *outMaxDamage = v18;
  }
}

/*
==============
BG_GetMotionBlurProperties
==============
*/
void BG_GetMotionBlurProperties(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, const bool isAlternate, const float adsLerp, float *outBlur, int *outBlurDurationMs, float *outBlurDecayExponent)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment *v15; 
  __int64 v16; 
  float hipFireMotionBlurDecayExponent; 
  WeaponAttachment *v18; 
  bool v19; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  unsigned int v21; 
  WeaponAttachment **v22; 
  AttPost *post; 
  AttPost *v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  __int64 v45; 
  WeaponAttachment **v46; 
  unsigned int *v47; 
  float v52; 
  float v54; 
  float v55; 
  __int128 v56; 
  __int128 v60; 
  __int128 v67; 
  __int128 v70; 
  __int128 v71; 
  __int128 v72; 
  __int128 v73; 
  int *v74; 
  __int128 v76; 
  float v80; 
  __int128 v82; 
  float v86; 
  __int128 v88; 
  __int128 v93; 
  WeaponAttachment *outDataAttachment; 
  float v98; 
  float adsFireMotionBlur; 
  float adsFireMotionBlurDurationMs; 
  float hipFireMotionBlur; 
  float hipFireMotionBlurDurationMs; 
  float v103; 
  float adsFireMotionBlurDecayExponent; 
  float *v105; 
  int *v106; 
  float *v107; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  weaponIdx = weapon->weaponIdx;
  v105 = outBlur;
  v106 = outBlurDurationMs;
  v107 = outBlurDecayExponent;
  v13 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19366, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  adsFireMotionBlur = v13->adsFireMotionBlur;
  adsFireMotionBlurDurationMs = (float)v13->adsFireMotionBlurDurationMs;
  adsFireMotionBlurDecayExponent = v13->adsFireMotionBlurDecayExponent;
  hipFireMotionBlur = v13->hipFireMotionBlur;
  v15 = NULL;
  v16 = WeaponAttachments_Internal;
  hipFireMotionBlurDurationMs = (float)v13->hipFireMotionBlurDurationMs;
  hipFireMotionBlurDecayExponent = v13->hipFireMotionBlurDecayExponent;
  v18 = NULL;
  outDataAttachment = NULL;
  v19 = hybridScopeFraction->fraction > 0.0;
  v103 = hipFireMotionBlurDecayExponent;
  if ( v19 && BG_CanHybridToggle(ps, weapon, isAlternate) )
  {
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
    v15 = outDataAttachment;
    v18 = (WeaponAttachment *)HybridScopeEnablerAttachment;
  }
  v21 = 0;
  if ( (_DWORD)v16 )
  {
    v22 = attachments;
    while ( 1 )
    {
      if ( !*v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19388, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      post = (*v22)->post;
      if ( post )
        break;
      ++v21;
      ++v22;
      if ( v21 >= (unsigned int)v16 )
        goto LABEL_22;
    }
    if ( v18 && v18 == *v22 && v15 && (v24 = v15->post) != NULL )
    {
      v25 = sinf_0((float)(hybridScopeFraction->fraction - 0.5) * 3.1415927);
      v26 = (float)(v25 * 0.5) + 0.5;
      v27 = 0.5 - (float)(v25 * 0.5);
      v28 = _mm_cvtepi32_ps((__m128i)(unsigned int)v24->adsFireMotionBlurDurationMs).m128_f32[0] * v26;
      v29 = v26 * v24->adsFireMotionBlurDecayExponent;
      v30 = _mm_cvtepi32_ps((__m128i)(unsigned int)post->adsFireMotionBlurDurationMs).m128_f32[0] * v27;
      v31 = v27 * post->adsFireMotionBlurDecayExponent;
      adsFireMotionBlur = (float)(v26 * v24->adsFireMotionBlur) + (float)(v27 * post->adsFireMotionBlur);
      v32 = v30 + v28;
      v33 = v27 * post->hipFireMotionBlur;
      adsFireMotionBlurDurationMs = v32;
      v34 = v31 + v29;
      v35 = v26 * v24->hipFireMotionBlur;
      v36 = _mm_cvtepi32_ps((__m128i)(unsigned int)post->hipFireMotionBlurDurationMs).m128_f32[0] * v27;
      v37 = v27 * post->hipFireMotionBlurDecayExponent;
      adsFireMotionBlurDecayExponent = v34;
      v38 = v33 + v35;
      v39 = v26 * v24->hipFireMotionBlurDecayExponent;
      hipFireMotionBlurDurationMs = v36 + (float)(_mm_cvtepi32_ps((__m128i)(unsigned int)v24->hipFireMotionBlurDurationMs).m128_f32[0] * v26);
      hipFireMotionBlur = v38;
      v40 = v37 + v39;
    }
    else
    {
      adsFireMotionBlur = post->adsFireMotionBlur;
      adsFireMotionBlurDurationMs = (float)post->adsFireMotionBlurDurationMs;
      adsFireMotionBlurDecayExponent = post->adsFireMotionBlurDecayExponent;
      hipFireMotionBlur = post->hipFireMotionBlur;
      hipFireMotionBlurDurationMs = (float)post->hipFireMotionBlurDurationMs;
      v40 = post->hipFireMotionBlurDecayExponent;
    }
    v103 = v40;
  }
LABEL_22:
  _XMM1 = LODWORD(FLOAT_1_0);
  v98 = FLOAT_1_0;
  _XMM15 = LODWORD(FLOAT_1_0);
  _XMM14 = LODWORD(FLOAT_1_0);
  _XMM13 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)v16 )
  {
    v45 = v16;
    v46 = attachments;
    do
    {
      v47 = (unsigned int *)*v46;
      if ( !*v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19433, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      _XMM7 = v47[208];
      _XMM6 = v47[209];
      LODWORD(_XMM8) = v47[210];
      _XMM10 = v47[211];
      if ( v18 && v18 == (WeaponAttachment *)v47 && v15 )
      {
        v52 = sinf_0((float)(hybridScopeFraction->fraction - 0.5) * 3.1415927);
        _XMM4 = LODWORD(v15->adsFireMotionBlurScale);
        v54 = v52 * 0.5;
        v55 = (float)(v52 * 0.5) + 0.5;
        if ( *(float *)&_XMM7 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM4 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm7, xmm4, xmm9, xmm2
          }
        }
        else if ( *(float *)&_XMM4 > 0.0 )
        {
          v56 = LODWORD(FLOAT_0_5);
          *(float *)&v56 = (float)((float)(0.5 - v54) * *(float *)&_XMM7) + (float)(*(float *)&_XMM4 * v55);
          _XMM7 = v56;
        }
        _XMM4 = LODWORD(v15->adsFireMotionBlurDurationScale);
        if ( *(float *)&_XMM6 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM4 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm6, xmm4, xmm9, xmm2
          }
        }
        else if ( *(float *)&_XMM4 > 0.0 )
        {
          v60 = LODWORD(FLOAT_0_5);
          *(float *)&v60 = (float)((float)(0.5 - v54) * *(float *)&_XMM6) + (float)(*(float *)&_XMM4 * v55);
          _XMM6 = v60;
        }
        _XMM4 = LODWORD(v15->hipFireMotionBlurScale);
        if ( *(float *)&_XMM8 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM4 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm8, xmm4, xmm9, xmm2
          }
        }
        else if ( *(float *)&_XMM4 > 0.0 )
        {
          *(float *)&_XMM8 = (float)((float)(0.5 - v54) * *(float *)&_XMM8) + (float)(*(float *)&_XMM4 * v55);
        }
        _XMM4 = LODWORD(v15->hipFireMotionBlurDurationScale);
        if ( *(float *)&_XMM10 <= 0.0 )
        {
          _XMM0 = *(float *)&_XMM4 > 0.0;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm10, xmm4, xmm9, xmm2
          }
        }
        else if ( *(float *)&_XMM4 > 0.0 )
        {
          v67 = LODWORD(FLOAT_0_5);
          *(float *)&v67 = (float)((float)(0.5 - v54) * *(float *)&_XMM10) + (float)(*(float *)&_XMM4 * v55);
          _XMM10 = v67;
        }
      }
      if ( *(float *)&_XMM7 <= 0.0 )
      {
        _XMM1 = LODWORD(v98);
      }
      else
      {
        v70 = _XMM7;
        *(float *)&v70 = (float)(*(float *)&_XMM7 + v98) - 1.0;
        _XMM1 = v70;
        v98 = *(float *)&v70;
      }
      if ( *(float *)&_XMM6 > 0.0 )
      {
        v71 = _XMM6;
        *(float *)&v71 = (float)(*(float *)&_XMM6 + *(float *)&_XMM15) - 1.0;
        _XMM15 = v71;
      }
      if ( *(float *)&_XMM8 > 0.0 )
      {
        v72 = _XMM14;
        *(float *)&v72 = (float)(*(float *)&_XMM14 + *(float *)&_XMM8) - 1.0;
        _XMM14 = v72;
      }
      if ( *(float *)&_XMM10 > 0.0 )
      {
        v73 = _XMM10;
        *(float *)&v73 = (float)(*(float *)&_XMM10 + *(float *)&_XMM13) - 1.0;
        _XMM13 = v73;
      }
      ++v46;
      --v45;
    }
    while ( v45 );
  }
  v74 = v106;
  __asm { vmaxss  xmm2, xmm1, xmm9 }
  v76 = LODWORD(FLOAT_1_0);
  *(float *)&v76 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v76 + 1) = (v76 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v76 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v76;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm1, xmm2, xmm12, xmm0
  }
  v80 = *(float *)&_XMM1 * adsFireMotionBlur;
  __asm { vmaxss  xmm3, xmm15, xmm9 }
  v82 = LODWORD(FLOAT_1_0);
  *(float *)&v82 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v82 + 1) = (v82 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v82 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v82;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm3, xmm12, xmm2
  }
  v86 = *(float *)&_XMM0 * adsFireMotionBlurDurationMs;
  __asm { vmaxss  xmm3, xmm14, xmm9 }
  v88 = LODWORD(FLOAT_1_0);
  *(float *)&v88 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v88 + 1) = (v88 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v88 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v88;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm3, xmm12, xmm2
    vmaxss  xmm3, xmm13, xmm9
  }
  v93 = LODWORD(FLOAT_1_0);
  *(float *)&v93 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v93 + 1) = (v93 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v93 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v93;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm4, xmm3, xmm12, xmm2
  }
  *(float *)&v93 = *(float *)&_XMM4 * hipFireMotionBlurDurationMs;
  *v105 = (float)((float)(1.0 - adsLerp) * (float)(*(float *)&_XMM0 * hipFireMotionBlur)) + (float)(v80 * adsLerp);
  *(float *)&_XMM2 = *(float *)&v93 * (float)(1.0 - adsLerp);
  *(float *)&_XMM0 = adsLerp * adsFireMotionBlurDecayExponent;
  *(float *)&v93 = (float)(1.0 - adsLerp) * v103;
  *v74 = (int)(float)(*(float *)&_XMM2 + (float)(v86 * adsLerp));
  *v107 = *(float *)&v93 + *(float *)&_XMM0;
}

/*
==============
BG_GetMountEdgeToEyeDistance
==============
*/
void BG_GetMountEdgeToEyeDistance(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, float *outForward, float *outAbove)
{
  const WeaponDef *v8; 
  float mountTopEdgeToEyeDistanceAbove; 

  if ( !outForward && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21869, ASSERT_TYPE_ASSERT, "(outForward)", (const char *)&queryFormat, "outForward") )
    __debugbreak();
  if ( !outAbove && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21870, ASSERT_TYPE_ASSERT, "(outAbove)", (const char *)&queryFormat, "outAbove") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8 )
    goto LABEL_8;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    *outForward = v8->mountTopEdgeToEyeDistanceForward;
    mountTopEdgeToEyeDistanceAbove = v8->mountTopEdgeToEyeDistanceAbove;
    goto LABEL_13;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
  {
    *outForward = v8->mountSideEdgeToEyeDistanceForward;
    mountTopEdgeToEyeDistanceAbove = v8->mountSideEdgeToEyeDistanceAbove;
  }
  else
  {
LABEL_8:
    *outForward = 0.0;
    mountTopEdgeToEyeDistanceAbove = 0.0;
  }
LABEL_13:
  *outAbove = mountTopEdgeToEyeDistanceAbove;
}

/*
==============
BG_GetMountEnterExitDuration
==============
*/
void BG_GetMountEnterExitDuration(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, int *outEnterDurationMs, int *outExitDurationMs)
{
  const WeaponDef *v8; 
  int mountTopExitDurationMs; 

  if ( !outEnterDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21943, ASSERT_TYPE_ASSERT, "(outEnterDurationMs)", (const char *)&queryFormat, "outEnterDurationMs") )
    __debugbreak();
  if ( !outExitDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21944, ASSERT_TYPE_ASSERT, "(outExitDurationMs)", (const char *)&queryFormat, "outExitDurationMs") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8 )
  {
    *outEnterDurationMs = 1;
LABEL_17:
    *outExitDurationMs = 1;
    goto LABEL_18;
  }
  if ( mountType == MOUNT_TYPE_TOP )
  {
    *outEnterDurationMs = v8->mountTopEnterDurationMs;
    mountTopExitDurationMs = v8->mountTopExitDurationMs;
  }
  else if ( (unsigned int)(mountType - 2) > 1 )
  {
    *outEnterDurationMs = 1;
    mountTopExitDurationMs = 1;
  }
  else
  {
    *outEnterDurationMs = v8->mountSideEnterDurationMs;
    mountTopExitDurationMs = v8->mountSideExitDurationMs;
  }
  *outExitDurationMs = mountTopExitDurationMs;
  if ( *outEnterDurationMs <= 0 )
  {
    *outEnterDurationMs = 1;
    mountTopExitDurationMs = *outExitDurationMs;
  }
  if ( mountTopExitDurationMs <= 0 )
    goto LABEL_17;
LABEL_18:
  if ( *outEnterDurationMs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21981, ASSERT_TYPE_ASSERT, "(0 < *outEnterDurationMs)", (const char *)&queryFormat, "0 < *outEnterDurationMs") )
    __debugbreak();
  if ( *outExitDurationMs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21982, ASSERT_TYPE_ASSERT, "(0 < *outExitDurationMs)", (const char *)&queryFormat, "0 < *outExitDurationMs") )
    __debugbreak();
}

/*
==============
BG_GetMountFOVScale
==============
*/
float BG_GetMountFOVScale(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->mountFOVScale;
  else
    return FLOAT_1_0;
}

/*
==============
BG_GetMountGunCenterScale
==============
*/
float BG_GetMountGunCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopGunCenterScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideGunCenterScale;
}

/*
==============
BG_GetMountGunIdleScale
==============
*/
float BG_GetMountGunIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopGunIdleMotionScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideGunIdleMotionScale;
}

/*
==============
BG_GetMountGunKickScale
==============
*/
float BG_GetMountGunKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopGunKickScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideGunKickScale;
}

/*
==============
BG_GetMountRumble
==============
*/
const WeaponDef *BG_GetMountRumble(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountRumble;
  return result;
}

/*
==============
BG_GetMountSideRoll
==============
*/
void BG_GetMountSideRoll(const Weapon *r_weapon, bool isAlternate, float *outRollDeg, float *outStartFrac, float *outEndFrac)
{
  const WeaponDef *v7; 

  *outRollDeg = 0.0;
  *outStartFrac = 0.0;
  *outEndFrac = 1.0;
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v7 )
  {
    *outRollDeg = v7->mountSideRoll;
    *outStartFrac = v7->mountSideRollStartFrac;
    *outEndFrac = v7->mountSideRollEndFrac;
  }
}

/*
==============
BG_GetMountTransitionEnabled
==============
*/
const WeaponDef *BG_GetMountTransitionEnabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountSideTransitionEnable;
  return result;
}

/*
==============
BG_GetMountViewCenterScale
==============
*/
float BG_GetMountViewCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopViewCenterScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideViewCenterScale;
}

/*
==============
BG_GetMountViewIdleScale
==============
*/
float BG_GetMountViewIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopViewIdleMotionScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideViewIdleMotionScale;
}

/*
==============
BG_GetMountViewKickScale
==============
*/
float BG_GetMountViewKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 )
    return FLOAT_1_0;
  if ( mountType == MOUNT_TYPE_TOP )
    return v4->mountTopViewKickScale;
  if ( (unsigned int)(mountType - 2) > 1 )
    return FLOAT_1_0;
  return v4->mountSideViewKickScale;
}

/*
==============
BG_GetMountViewmodelOffset
==============
*/
float BG_GetMountViewmodelOffset(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->mountViewmodelOffset;
  else
    return 0.0;
}

/*
==============
BG_GetMoveSpeedScale
==============
*/
void BG_GetMoveSpeedScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *moveSpeedScaleOut, float *adsMoveSpeedScaleOut)
{
  float *v7; 
  const WeaponDef *v11; 
  unsigned int v12; 
  __int64 WeaponAttachments_Internal; 
  WeaponAttachment **v14; 
  WeaponAttachment *v15; 
  float *p_moveSpeedScale; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v18; 
  __int64 v21; 
  const WeaponAttachment **v22; 
  bool v23; 
  const WeaponAttachment *v24; 
  float *v25; 
  __int128 v26; 
  __int128 v27; 
  __int128 v28; 
  __int128 v29; 
  __int128 v30; 
  __int128 v31; 
  __int128 v33; 
  __int128 v38; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v7 = adsMoveSpeedScaleOut;
  if ( !moveSpeedScaleOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8194, ASSERT_TYPE_ASSERT, "(moveSpeedScaleOut)", (const char *)&queryFormat, "moveSpeedScaleOut") )
    __debugbreak();
  if ( !adsMoveSpeedScaleOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8195, ASSERT_TYPE_ASSERT, "(adsMoveSpeedScaleOut)", (const char *)&queryFormat, "adsMoveSpeedScaleOut") )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = 0;
  *moveSpeedScaleOut = v11->moveSpeedScale;
  *adsMoveSpeedScaleOut = v11->adsMoveSpeedScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v14 = attachments;
    while ( 1 )
    {
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8203, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v15 = *v14;
      p_moveSpeedScale = &(*v14)->movement->moveSpeedScale;
      if ( p_moveSpeedScale )
        break;
      ++v12;
      ++v14;
      if ( v12 >= (unsigned int)WeaponAttachments_Internal )
        goto LABEL_16;
    }
    *moveSpeedScaleOut = *p_moveSpeedScale;
    *adsMoveSpeedScaleOut = v15->movement->adsMoveSpeedScale;
  }
LABEL_16:
  v18 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM6 = LODWORD(FLOAT_1_0);
  _XMM9 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v21 = WeaponAttachments_Internal;
    v22 = (const WeaponAttachment **)attachments;
    do
    {
      if ( !*v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8218, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v23 = BG_AttachmentUseMainSettings(*v22, isAlternate, v18);
      v24 = *v22;
      if ( v23 )
        v25 = &v24->movementScaleMain->moveSpeedScale;
      else
        v25 = &v24->movementScale->moveSpeedScale;
      if ( v25 )
      {
        v27 = _XMM9;
        *(float *)&v27 = *(float *)&_XMM9 + v25[1];
        v26 = v27;
        v29 = _XMM6;
        *(float *)&v29 = *(float *)&_XMM6 + *v25;
        v28 = v29;
        v30 = v26;
        *(float *)&v30 = *(float *)&v26 - 1.0;
        _XMM9 = v30;
        v31 = v28;
        *(float *)&v31 = *(float *)&v28 - 1.0;
        _XMM6 = v31;
      }
      ++v22;
      --v21;
    }
    while ( v21 );
    v7 = adsMoveSpeedScaleOut;
  }
  __asm { vmaxss  xmm2, xmm6, xmm7 }
  v33 = LODWORD(FLOAT_1_0);
  *(float *)&v33 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v33 + 1) = (v33 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v33 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v33;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm8, xmm0
  }
  *moveSpeedScaleOut = *(float *)&_XMM1 * *moveSpeedScaleOut;
  __asm { vmaxss  xmm3, xmm9, xmm7 }
  v38 = LODWORD(FLOAT_1_0);
  *(float *)&v38 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v38 + 1) = (v38 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v38 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v38;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm8, xmm2
  }
  *v7 = *(float *)&_XMM0 * *v7;
}

/*
==============
BG_GetMultipleReloadClipPercentage
==============
*/
float BG_GetMultipleReloadClipPercentage(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->multipleReloadClipPercentage;
}

/*
==============
BG_GetNextSpectateViewWeapons
==============
*/
char BG_GetNextSpectateViewWeapons(const BgWeaponMap *const weaponMap, const characterInfo_t *const ci, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  Weapon (*v4)[24]; 
  const characterInfo_t *v5; 
  unsigned int v6; 
  const Weapon *__ptr32 const *v7; 
  const Weapon *v8; 
  const WeaponDef *v9; 
  unsigned int v10; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v12; 
  WeaponAttachment **v13; 
  WeaponAttachment *v14; 
  unsigned __int8 v15; 
  unsigned __int8 v16; 
  int numModelVariations; 
  int v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v22; 
  __int64 v23; 
  unsigned int v24; 
  const Weapon *__ptr32 const *i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = outViewWeapons;
  v5 = ci;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22635, ASSERT_TYPE_ASSERT, "( ( weaponMap != nullptr ) )", "( weaponMap ) = %p", NULL) )
    __debugbreak();
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22636, ASSERT_TYPE_ASSERT, "( ( ci != nullptr ) )", "( ci ) = %p", NULL) )
    __debugbreak();
  v6 = 0;
  v7 = NEXT_SPECTATE_WEAPON_MEMBERS;
  v24 = 0;
  for ( i = NEXT_SPECTATE_WEAPON_MEMBERS; ; ++i )
  {
    v8 = (const Weapon *)((char *)v5 + *(int *)v7);
    if ( v8->weaponIdx )
      break;
LABEL_36:
    ++v6;
    v7 = i + 1;
    v24 = v6;
    if ( v6 >= 2 )
      return 1;
  }
  v9 = BG_WeaponDefAtIndex(v8->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22562, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v9->hasAnyTransientModels )
    goto LABEL_35;
  if ( *(_WORD *)&v9->transientBaseViewFlags )
    goto LABEL_33;
  v10 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(v8, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
  {
LABEL_35:
    v5 = ci;
    goto LABEL_36;
  }
  v12 = attachmentIds;
  v13 = attachments;
  while ( 1 )
  {
    v14 = *v13;
    if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22581, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v15 = *v12;
    if ( *v12 >= 0x1Du )
    {
      LODWORD(v23) = 29;
      LODWORD(v22) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22584, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v22, v23) )
        __debugbreak();
    }
    v16 = v8->attachmentVariationIndices[v15];
    if ( v16 >= 0x10u )
    {
      LODWORD(v23) = 16;
      LODWORD(v22) = v16;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22587, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v22, v23) )
        __debugbreak();
    }
    numModelVariations = v14->numModelVariations;
    if ( v16 < numModelVariations )
    {
      if ( v16 >= (unsigned int)numModelVariations )
      {
        LODWORD(v23) = v14->numModelVariations;
        LODWORD(v22) = v16;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22594, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( attachment->numModelVariations )", "variationIndex doesn't index attachment->numModelVariations\n\t%i not in [0, %i)", v22, v23) )
          __debugbreak();
      }
      v18 = v14->transientViewFlags | v14->transientWorldFlags;
      if ( _bittest(&v18, v16) )
        break;
    }
    ++v10;
    ++v13;
    ++v12;
    if ( v10 >= AllWeaponAttachmentsWithIds )
    {
      v6 = v24;
      v4 = outViewWeapons;
      goto LABEL_35;
    }
  }
  v6 = v24;
  v4 = outViewWeapons;
LABEL_33:
  v19 = *inOutWeaponCount;
  if ( (unsigned int)v19 < 0x18 )
  {
    v20 = v19;
    *(__m256i *)&(*v4)[v20].weaponIdx = *(__m256i *)&v8->weaponIdx;
    *(_OWORD *)&(*v4)[v20].attachmentVariationIndices[5] = *(_OWORD *)&v8->attachmentVariationIndices[5];
    *(double *)&(*v4)[v20].attachmentVariationIndices[21] = *(double *)&v8->attachmentVariationIndices[21];
    *(_DWORD *)&(*v4)[v20].weaponCamo = *(_DWORD *)&v8->weaponCamo;
    ++*inOutWeaponCount;
    goto LABEL_35;
  }
  return 0;
}

/*
==============
BG_GetNotetrackOverrides
==============
*/
char BG_GetNotetrackOverrides(const Weapon *r_weapon, bool isAlternate, unsigned int *numMappings, const scr_string_t **keys, const scr_string_t **values)
{
  unsigned int AllWeaponAttachmentsWithIds; 
  __int64 v9; 
  const WeaponCompleteDef *v10; 
  scr_string_t attachment; 
  unsigned int v12; 
  WeaponAttachment **v13; 
  WeaponAttachment *v14; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !numMappings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2563, ASSERT_TYPE_ASSERT, "(numMappings)", (const char *)&queryFormat, "numMappings") )
    __debugbreak();
  if ( !keys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2564, ASSERT_TYPE_ASSERT, "(keys)", (const char *)&queryFormat, "keys") )
    __debugbreak();
  if ( !values && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2565, ASSERT_TYPE_ASSERT, "(values)", (const char *)&queryFormat, "values") )
    __debugbreak();
  if ( !isAlternate )
    return 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return 0;
  v9 = 0i64;
  v10 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v10->numNotetrackOverrides )
    return 0;
  while ( 1 )
  {
    attachment = v10->notetrackOverrides[v9].attachment;
    if ( attachment )
      break;
LABEL_21:
    v9 = (unsigned int)(v9 + 1);
    if ( (unsigned int)v9 >= v10->numNotetrackOverrides )
      return 0;
  }
  v12 = 0;
  v13 = attachments;
  while ( 1 )
  {
    v14 = *v13;
    if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1789, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v14->internalName == attachment )
      break;
    ++v12;
    ++v13;
    if ( v12 >= AllWeaponAttachmentsWithIds )
      goto LABEL_21;
  }
  *keys = v10->notetrackOverrides[v9].notetrackSoundMapKeys;
  *values = v10->notetrackOverrides[v9].notetrackSoundMapValues;
  *numMappings = v10->notetrackOverrides[v9].numSoundMappings;
  return 1;
}

/*
==============
BG_GetOffhandAllowsSprint
==============
*/
bool BG_GetOffhandAllowsSprint(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9774, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->offhandAllowsSprint;
}

/*
==============
BG_GetOffhandClass
==============
*/
__int64 BG_GetOffhandClass(const playerState_s *ps, const OffhandSlot slot, const BgWeaponMap *weaponMap)
{
  OffhandClass outOffhandClass; 

  outOffhandClass = OFFHAND_CLASS_NONE;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2645, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_GameInterface_GetOffhandClass(ps, slot, weaponMap, &outOffhandClass) )
    return (unsigned int)outOffhandClass;
  switch ( slot )
  {
    case OFFHAND_SLOT_PRIMARY:
      return (unsigned int)ps->weapCommon.offhandPrimary;
    case OFFHAND_SLOT_SECONDARY:
      return (unsigned int)ps->weapCommon.offhandSecondary;
    case OFFHAND_SLOT_SPECIAL:
      return (unsigned int)ps->weapCommon.offhandSpecial;
  }
  if ( slot != OFFHAND_SLOT_SCRIPTED )
    return (unsigned int)outOffhandClass;
  else
    return (unsigned int)ps->weapCommon.offhandScripted;
}

/*
==============
BG_GetOffhandMaxHoldTime
==============
*/
__int64 BG_GetOffhandMaxHoldTime(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9788, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v4->maxHoldTime;
}

/*
==============
BG_GetOffhandOverCookIsNotLethal
==============
*/
bool BG_GetOffhandOverCookIsNotLethal(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9802, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->overCookIsNotLethal;
}

/*
==============
BG_GetOnePieceReticle
==============
*/
Material *BG_GetOnePieceReticle(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  Material *reticleOnePiece; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reticleOnePiece = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reticleOnePiece;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return reticleOnePiece;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16612, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return reticleOnePiece;
  }
  return general->reticleOnePiece;
}

/*
==============
BG_GetOtherAdsDownAnim
==============
*/
__int64 BG_GetOtherAdsDownAnim(const weapAnimFiles_t adsAnim)
{
  if ( adsAnim == WEAP_ANIM_ADS_DOWN )
    return 408i64;
  if ( adsAnim != WEAP_ANIM_ADS_DOWN_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17863, ASSERT_TYPE_ASSERT, "(adsAnim == WEAP_ANIM_ADS_DOWN_NVG)", (const char *)&queryFormat, "adsAnim == WEAP_ANIM_ADS_DOWN_NVG") )
    __debugbreak();
  return 407i64;
}

/*
==============
BG_GetOtherAdsSettleAnim
==============
*/
__int64 BG_GetOtherAdsSettleAnim(const weapAnimFiles_t adsSettleAnim)
{
  if ( adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS )
    return 165i64;
  if ( adsSettleAnim != WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17900, ASSERT_TYPE_ASSERT, "(adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG)", (const char *)&queryFormat, "adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG") )
    __debugbreak();
  return 164i64;
}

/*
==============
BG_GetOtherAdsUpAnim
==============
*/
__int64 BG_GetOtherAdsUpAnim(const weapAnimFiles_t adsAnim)
{
  if ( adsAnim == WEAP_ANIM_ADS_UP )
    return 406i64;
  if ( adsAnim != WEAP_ANIM_ADS_UP_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17831, ASSERT_TYPE_ASSERT, "(adsAnim == WEAP_ANIM_ADS_UP_NVG)", (const char *)&queryFormat, "adsAnim == WEAP_ANIM_ADS_UP_NVG") )
    __debugbreak();
  return 405i64;
}

/*
==============
BG_GetOverlay
==============
*/
AttADSOverlay *BG_GetOverlay(const Weapon *r_weapon, bool isAlternate)
{
  bool v3; 
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = isAlternate && BG_HasUnderbarrelAmmo(r_weapon);
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v3, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (AttADSOverlay *)&v4->overlay;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15369, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->adsOverlay;
    if ( result )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (AttADSOverlay *)&v4->overlay;
  }
  return result;
}

/*
==============
BG_GetOverlayReticle
==============
*/
__int64 BG_GetOverlayReticle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const ADSOverlay *Overlay; 

  if ( ps && BG_PWF_UseAlternateAsOffhand(ps) && r_weapon->weaponAttachments[9] )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15517, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
      __debugbreak();
    isAlternate = 0;
  }
  Overlay = BG_GetOverlay(r_weapon, isAlternate);
  if ( Overlay )
    return (unsigned int)Overlay->reticle;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15523, ASSERT_TYPE_ASSERT, "(overlay)", (const char *)&queryFormat, "overlay") )
    __debugbreak();
  return MEMORY[0x44];
}

/*
==============
BG_GetOverrideAttachmentWhenApplicable
==============
*/
WeaponAttachment *BG_GetOverrideAttachmentWhenApplicable(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  WeaponAttachment *result; 
  WeaponAttachment *outDataAttachment; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 477, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 478, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  if ( !usingHybridScope )
    return (WeaponAttachment *)attachment;
  outDataAttachment = NULL;
  HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
  result = outDataAttachment;
  if ( !outDataAttachment || HybridScopeEnablerAttachment != attachment )
    return (WeaponAttachment *)attachment;
  return result;
}

/*
==============
BG_GetPenetrateMultiplier
==============
*/
float BG_GetPenetrateMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v4; 
  float penetrateMultiplier; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7884, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  penetrateMultiplier = v4->penetrateMultiplier;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return penetrateMultiplier;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7892, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return penetrateMultiplier;
  }
  return penetration->penetrateMultiplier;
}

/*
==============
BG_GetPenetrateType
==============
*/
__int64 BG_GetPenetrateType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  PenetrateType penetrateType; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7859, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7860, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  penetrateType = v4->penetrateType;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)penetrateType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7869, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return (unsigned int)penetrateType;
  }
  return (unsigned int)penetration->penetrateType;
}

/*
==============
BG_GetPlayerDamageRange
==============
*/
void BG_GetPlayerDamageRange(const WeaponDamageCalcType damageCalcType, const BgWeaponMap *weaponMap, const playerState_s *ps, const bitarray<64> *r_perks, const Weapon *r_weapon, bool isAlternate, float *minDamageRange, float *maxDamageRange)
{
  double ADSDamageRangeScale; 
  const dvar_t *v13; 
  float value; 
  int v16; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v16 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9493, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v16) )
      __debugbreak();
  }
  ADSDamageRangeScale = BG_GetADSDamageRangeScale(weaponMap, ps, r_weapon, isAlternate);
  BG_GetDamageRange(damageCalcType, r_weapon, isAlternate, *(float *)&ADSDamageRangeScale, minDamageRange, maxDamageRange);
  if ( BG_HasPerk(r_perks, 0x18u) )
  {
    v13 = DCONST_DVARFLT_perk_longerRangeScale;
    if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    value = v13->current.value;
    *minDamageRange = value * *minDamageRange;
    *maxDamageRange = value * *maxDamageRange;
  }
}

/*
==============
BG_GetProjectileSpeed
==============
*/
void BG_GetProjectileSpeed(const Weapon *r_weapon, bool isAlternate, int *projectileSpeed, int *projectileSpeedUp)
{
  const WeaponDef *v8; 
  int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v12; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !projectileSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17038, ASSERT_TYPE_ASSERT, "(projectileSpeed)", (const char *)&queryFormat, "projectileSpeed") )
    __debugbreak();
  if ( !projectileSpeedUp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17039, ASSERT_TYPE_ASSERT, "(projectileSpeedUp)", (const char *)&queryFormat, "projectileSpeedUp") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *projectileSpeed = v8->iProjectileSpeed;
  *projectileSpeedUp = v8->iProjectileSpeedUp;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17048, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *i;
      projectile = (*i)->projectile;
      if ( projectile )
        break;
      if ( ++v9 >= WeaponAttachments_Internal )
        return;
    }
    *projectileSpeed = projectile->projectileSpeed;
    *projectileSpeedUp = v12->projectile->projectileSpeedUp;
  }
}

/*
==============
BG_GetRegularWeaponFieldTime
==============
*/
__int64 BG_GetRegularWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const WeaponDef *weapDef, __int64 offset, unsigned __int16 timer, const weapAnimFiles_t dependentAnimType)
{
  __int64 v8; 
  bool v10; 
  const Weapon *v11; 
  const playerState_s *v12; 
  unsigned int v13; 
  unsigned int v14; 
  AnimOverride *animOverrides; 
  __int64 v16; 
  unsigned int numBindings; 
  AnimOverride *v18; 
  WeaponAnimPackage *overridesAlt; 
  const CarryObjectDef *PlayerCarryObjectDef; 
  CarryAnimOverride *i; 
  WeaponAnimPackage *animPackage; 
  WeaponAnimPackage *animPackageAlt; 
  unsigned __int16 v25; 
  WeaponAnimPackageStateTimers *timers; 

  v8 = 0i64;
  v10 = isAlternate;
  v11 = r_weapon;
  v12 = ps;
  v13 = 0;
  v14 = 0;
  if ( weapDef->numAnimOverrides )
  {
    do
    {
      animOverrides = weapDef->animOverrides;
      v16 = v14;
      numBindings = animOverrides[v16].numBindings;
      v18 = &animOverrides[v16];
      if ( numBindings > v13 )
      {
        if ( BG_WeaponHasOverride(v11, v18->bindings, numBindings) && (isAlternate && (overridesAlt = weapDef->animOverrides[v16].overridesAlt) != NULL || (overridesAlt = weapDef->animOverrides[v16].overrides) != NULL) && *(unsigned __int16 *)((char *)&overridesAlt->timers->iDetonateDelay + offset) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || overridesAlt->anims[dependentAnimType]) )
        {
          v13 = v18->numBindings;
          timer = *(unsigned __int16 *)((char *)&overridesAlt->timers->iDetonateDelay + offset);
        }
        v11 = r_weapon;
      }
      ++v14;
    }
    while ( v14 < weapDef->numAnimOverrides );
    v10 = isAlternate;
    v8 = 0i64;
    v12 = ps;
  }
  if ( !v12 || !BG_CarryObject_IsActive(v12) )
    return timer;
  PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(v12);
  if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1903, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  for ( i = weapDef->carryAnimOverrides; i->carryObjectType != PlayerCarryObjectDef->type; ++i )
  {
    if ( ++v8 >= 5 )
      return timer;
  }
  animPackage = i->animPackage;
  animPackageAlt = i->animPackageAlt;
  if ( !animPackage && !animPackageAlt )
    return timer;
  if ( !v10 || !animPackageAlt )
  {
    if ( animPackage )
    {
      timers = animPackage->timers;
      if ( *(unsigned __int16 *)((char *)&timers->iDetonateDelay + offset) != 0xFFFF )
        return *(unsigned __int16 *)((char *)&timers->iDetonateDelay + offset);
    }
    return timer;
  }
  v25 = *(unsigned __int16 *)((char *)&animPackageAlt->timers->iDetonateDelay + offset);
  if ( v25 == 0xFFFF )
    return timer;
  return v25;
}

/*
==============
BG_GetReloadAnimFileType
==============
*/
__int64 BG_GetReloadAnimFileType(weapAnimFiles_t animFile)
{
  __int64 result; 

  if ( (unsigned int)(animFile - 381) <= 7 )
    return 3i64;
  if ( (unsigned int)(animFile - 389) <= 7 )
    return 4i64;
  if ( (unsigned int)(animFile - 286) <= 0x11 )
    return 1i64;
  result = 0i64;
  if ( (unsigned int)(animFile - 304) <= 0x11 )
    return 2i64;
  return result;
}

/*
==============
BG_GetReloadTimeScale
==============
*/
float BG_GetReloadTimeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip, bool isUsingFastReloadStateTimer)
{
  __int128 v6; 
  __int128 v7; 
  float v12; 
  bool v13; 
  bool v14; 
  bool v15; 
  double Float_Internal_DebugName; 
  double v17; 
  double v18; 
  __int128 v19; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v22; 
  WeaponAttachment **v24; 
  __int64 v25; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v27; 
  __int128 v29; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v36; 
  __int128 v37; 

  v37 = v6;
  v36 = v7;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10855, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10856, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v12 = FLOAT_1_0;
  v13 = BG_UseFastReload(ps, r_weapon, isAlternate);
  v14 = BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  v15 = v14;
  if ( v13 || v14 )
  {
    if ( BG_GameInterface_HasFastReloadPerkVariant(&ps->perks) )
    {
      Float_Internal_DebugName = BG_GameInterface_ApplyFastReloadPerkVariantScaling(ps, 1.0);
LABEL_19:
      v12 = *(float *)&Float_Internal_DebugName;
      goto LABEL_20;
    }
    if ( isUsingFastReloadStateTimer )
    {
      if ( v13 && v15 )
      {
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplierEmpty, "perk_weapReloadMultiplierEmpty");
        goto LABEL_19;
      }
    }
    else
    {
      if ( v13 )
      {
        v17 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplier, "perk_weapReloadMultiplier");
        v12 = *(float *)&v17;
      }
      if ( v15 )
      {
        v18 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplierEmpty, "perk_weapReloadMultiplierEmpty");
        v12 = v12 * *(float *)&v18;
      }
    }
  }
LABEL_20:
  v19 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v22 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM0 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v24 = attachments;
    v25 = WeaponAttachments_Internal;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v24, v22);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10903, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v27 = v19;
      ++v24;
      *(float *)&v27 = (float)(*(float *)&v19 + OverrideAttachmentWhenApplicable->reloadTimersScale) - 1.0;
      v19 = v27;
      _XMM0 = v27;
      --v25;
    }
    while ( v25 );
  }
  __asm { vmaxss  xmm3, xmm0, xmm4 }
  v29 = LODWORD(FLOAT_1_0);
  *(float *)&v29 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v29 + 1) = (v29 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v29 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v29;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  if ( (float)(v12 * *(float *)&_XMM0) <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10910, ASSERT_TYPE_ASSERT, "(reloadTimeScale > 0.0f)", (const char *)&queryFormat, "reloadTimeScale > 0.0f") )
    __debugbreak();
  return v12 * *(float *)&_XMM0;
}

/*
==============
BG_GetReloadType
==============
*/
__int64 BG_GetReloadType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ReloadType reloadType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reloadType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)reloadType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7841, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
    {
      if ( reload->segmentedReload )
        break;
    }
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)reloadType;
  }
  return 1i64;
}

/*
==============
BG_GetReticleType
==============
*/
__int64 BG_GetReticleType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ReticleType reticleType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reticleType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reticleType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)reticleType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16498, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)reticleType;
  }
  return (unsigned int)general->reticleType;
}

/*
==============
BG_GetScopeAttachment
==============
*/
const WeaponAttachment *BG_GetScopeAttachment(const Weapon *r_weapon)
{
  return BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
}

/*
==============
BG_GetScopeDriftDelay
==============
*/
float BG_GetScopeDriftDelay(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  const AttScopeDriftSettings *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return ScopeDriftSettings->fScopeDriftDelay;
  else
    return v4->fScopeDriftDelay;
}

/*
==============
BG_GetScopeDriftLerpInTime
==============
*/
float BG_GetScopeDriftLerpInTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  const AttScopeDriftSettings *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return ScopeDriftSettings->fScopeDriftLerpInTime;
  else
    return v4->fScopeDriftLerpInTime;
}

/*
==============
BG_GetScopeDriftLerpOutTime
==============
*/
float BG_GetScopeDriftLerpOutTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  const AttScopeDriftSettings *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return ScopeDriftSettings->fScopeDriftLerpOutTime;
  else
    return v4->fScopeDriftLerpOutTime;
}

/*
==============
BG_GetScopeDriftSettings
==============
*/
WeaponAttachment *BG_GetScopeDriftSettings(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *v2; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v5; 
  unsigned int v6; 
  WeaponAttachment **v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v5 = 0;
  v6 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    do
    {
      if ( v2 )
        break;
      v2 = *v7;
      if ( *v7 )
      {
        if ( v2->shareAmmoWithAlt )
        {
          if ( isAlternate )
            v2 = (WeaponAttachment *)v2->scopeDriftSettings;
          else
            v2 = (WeaponAttachment *)v2->scopeDriftSettingsMain;
        }
        else
        {
          v2 = (WeaponAttachment *)v2->scopeDriftSettings;
        }
      }
      ++v5;
      ++v7;
    }
    while ( v5 < v6 );
  }
  return v2;
}

/*
==============
BG_GetScopeDriftSteadyFactor
==============
*/
float BG_GetScopeDriftSteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return *(float *)&ScopeDriftSettings->internalName;
  else
    return v4->fScopeDriftSteadyFactor;
}

/*
==============
BG_GetScopeDriftSteadyTime
==============
*/
float BG_GetScopeDriftSteadyTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return *(float *)&ScopeDriftSettings->szDisplayName;
  else
    return v4->fScopeDriftSteadyTime;
}

/*
==============
BG_GetScopeDriftUnsteadyFactor
==============
*/
float BG_GetScopeDriftUnsteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *ScopeDriftSettings; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  ScopeDriftSettings = BG_GetScopeDriftSettings(r_weapon, isAlternate);
  if ( ScopeDriftSettings )
    return *(float *)&ScopeDriftSettings->overrideCategoryName;
  else
    return v4->fScopeDriftUnsteadyFactor;
}

/*
==============
BG_GetScopeLensSettings
==============
*/
void BG_GetScopeLensSettings(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  GfxScopeInfo *v7; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *scopeAttachment; 
  const dvar_t *v14; 
  bool v15; 
  const dvar_t *v16; 
  const WeaponCompleteDef *v17; 
  const char *v18; 
  const char *szInternalName; 
  AttSight *sight; 
  AttPost *post; 
  __int64 v22; 
  float v23; 
  float v24; 
  float v25; 
  char dofViewModelPhysicalFocalTag; 
  char dofSceneIsOverridden; 
  float *scopeFadeInfo; 
  __int64 v29; 
  const dvar_t *v30; 
  float v31; 
  const dvar_t *v32; 
  float v33; 
  bool playerUsesNVGHalfADS; 

  v7 = settingOut;
  if ( !settingOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15821, ASSERT_TYPE_ASSERT, "(settingOut)", (const char *)&queryFormat, "settingOut") )
    __debugbreak();
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15822, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v7->foundSight = 0;
  *(_WORD *)&v7->dofOverride = 0;
  if ( isAlternate && (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL), (scopeAttachment = WeaponPrimaryAttachment) != NULL) && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && !WeaponPrimaryAttachment->shareAmmoWithAlt || (scopeAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE)) != NULL )
  {
    v14 = DVARBOOL_cg_drawGun;
    if ( !DVARBOOL_cg_drawGun && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_drawGun") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    if ( v14->current.enabled )
    {
      v15 = BG_PlayerUsesNVGHalfADS(ps, handler);
      v16 = DVARBOOL_bg_showWeaponAndAttachment;
      playerUsesNVGHalfADS = v15;
      if ( !DVARBOOL_bg_showWeaponAndAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponAndAttachment") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v16);
      if ( v16->current.enabled )
      {
        v17 = BG_WeaponCompleteDef(r_weapon, isAlternate);
        v18 = "null";
        szInternalName = "null";
        if ( v17->szInternalName )
          szInternalName = v17->szInternalName;
        Com_Printf(17, "weaponDef=%s", szInternalName);
        if ( scopeAttachment )
        {
          if ( scopeAttachment->szInternalName )
            v18 = scopeAttachment->szInternalName;
          Com_Printf(17, " attachment=%s", v18);
        }
        Com_Printf(17, "\n");
        Dvar_SetBool_Internal(DVARBOOL_bg_showWeaponAndAttachment, 0);
      }
      if ( scopeAttachment )
      {
        sight = scopeAttachment->sight;
        if ( sight )
        {
          v7->foundSight = 1;
          BG_CalculateScopeFadeFractions(handler, ps, r_weapon, isAlternate, adsFrac, playerUsesNVGHalfADS, scopeAttachment, hybridScopeFraction, v7);
          v7->scopeUseDualFov = sight->useDualFOV;
          v7->scopeUseHybridSetup = BG_CanHybridToggle(ps, r_weapon, isAlternate);
          v7->scopeLensInnerDisk = sight->scopeLensInnerDisk;
          v7->scopeLensInnerDiskMag = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensInnerDiskMag) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensOuterRing = sight->scopeLensOuterRing;
          v7->scopeLensOuterRingMag = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensOuterRingMag) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensRadius = sight->scopeLensRadius;
          v7->scopeLensColorRed = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensColorRed) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensColorGreen = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensColorGreen) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensColorBlue = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensColorBlue) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensBrightness = (float)(v7->scopeFadeInfo[0].fadeInFrac * sight->scopeLensBrightness) + (float)(1.0 - v7->scopeFadeInfo[0].fadeInFrac);
          v7->scopeLensFadeStart = sight->scopeLensFadeStart;
          v7->scopeLensFadeEnd = sight->scopeLensFadeEnd;
          v7->scopeEyeRelief_focusDistance = sight->scopeEyeRelief_focusDistance;
          v7->scopeEyeRelief_focuseUVScale = sight->scopeEyeRelief_focuseUVScale;
          v7->scopeEyeRelief_outOfFocusDistance = sight->scopeEyeRelief_outOfFocusDistance;
          v7->scopeEyeRelief_outOfFocuseUVScale = sight->scopeEyeRelief_outOfFocuseUVScale;
          v7->scopeEyeRelief_idleMovementScale = sight->scopeEyeRelief_idleMovementScale;
          v7->scopeEyeRelief_fullSpeedMovementScale = sight->scopeEyeRelief_fullSpeedMovementScale;
          v7->scopeEyeRelief_maxMovement = sight->scopeEyeRelief_maxMovement;
          v7->scopeEyeRelief_hipMovementScale = sight->scopeEyeRelief_hipMovementScale;
          v7->scopeEyeRelief_hipMaxMovement = sight->scopeEyeRelief_hipMaxMovement;
          v7->scopeEyeRelief_idleSway_freq = sight->scopeEyeRelief_idleSway_freq;
          v7->scopeEyeRelief_idleSway_movement = sight->scopeEyeRelief_idleSway_movement;
          v7->scopeEyeRelief_fullSpeedSway_freq = sight->scopeEyeRelief_fullSpeedSway_freq;
          v7->scopeEyeRelief_fullSpeedSway_movement = sight->scopeEyeRelief_fullSpeedSway_movement;
        }
      }
      if ( !playerUsesNVGHalfADS )
      {
        if ( scopeAttachment )
        {
          post = scopeAttachment->post;
          if ( post )
          {
            v22 = 0i64;
            if ( hybridScopeFraction->fraction > 0.0 && BG_CanHybridToggle(ps, r_weapon, isAlternate) )
            {
              settingOut = NULL;
              BG_GetHybridScopeEnablerAttachment(r_weapon, isAlternate, (const WeaponAttachment **)&settingOut);
              if ( settingOut )
              {
                if ( *(_QWORD *)&settingOut[1].scopeLensFadeStart )
                  v22 = *(_QWORD *)&settingOut[1].scopeLensFadeStart;
              }
            }
            v7->dofOverride = 1;
            if ( v22 )
            {
              v23 = sinf_0((float)(hybridScopeFraction->fraction - 0.5) * 3.1415927) * 0.5;
              v24 = 0.5 - v23;
              v25 = v23 + 0.5;
              v7->dofViewModelPhysicalFstop = (float)((float)(v23 + 0.5) * *(float *)(v22 + 24)) + (float)((float)(0.5 - v23) * post->dofViewModelPhysicalFstop);
              v7->dofViewModelPhysicalFocusDistance = (float)((float)(v23 + 0.5) * *(float *)(v22 + 28)) + (float)((float)(0.5 - v23) * post->dofViewModelPhysicalFocusDistance);
              if ( hybridScopeFraction->increasing )
                dofViewModelPhysicalFocalTag = *(_BYTE *)(v22 + 48);
              else
                dofViewModelPhysicalFocalTag = post->dofViewModelPhysicalFocalTag;
              v7->dofViewModelPhysicalFocalTag = dofViewModelPhysicalFocalTag;
              v7->dofPhysicalFstop = (float)(v24 * post->dofPhysicalFstop) + (float)(v25 * *(float *)(v22 + 32));
              v7->dofPhysicalFocusDistance = (float)(v24 * post->dofPhysicalFocusDistance) + (float)(v25 * *(float *)(v22 + 36));
              if ( 1.0 == hybridScopeFraction->fraction )
              {
                dofSceneIsOverridden = *(_BYTE *)(v22 + 49);
LABEL_46:
                v7->dofSceneIsOverridden = dofSceneIsOverridden;
                goto LABEL_47;
              }
            }
            else
            {
              v7->dofViewModelPhysicalFstop = post->dofViewModelPhysicalFstop;
              v7->dofViewModelPhysicalFocusDistance = post->dofViewModelPhysicalFocusDistance;
              v7->dofViewModelPhysicalFocalTag = post->dofViewModelPhysicalFocalTag;
              v7->dofPhysicalFstop = post->dofPhysicalFstop;
              v7->dofPhysicalFocusDistance = post->dofPhysicalFocusDistance;
            }
            dofSceneIsOverridden = post->dofSceneIsOverridden;
            goto LABEL_46;
          }
        }
      }
    }
  }
LABEL_47:
  if ( !v7->foundSight )
  {
    v7->adsSmoothFade = 0;
    scopeFadeInfo = (float *)v7->scopeFadeInfo;
    v29 = 2i64;
    do
    {
      v30 = DCONST_DVARBOOL_bg_scopeFadeIn;
      if ( !DCONST_DVARBOOL_bg_scopeFadeIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeIn") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v30);
      if ( v30->current.enabled && v7->adsSmoothFade )
        v31 = adsFrac;
      else
        v31 = FLOAT_1_0;
      scopeFadeInfo[1] = v31;
      v32 = DCONST_DVARBOOL_bg_scopeFadeOut;
      if ( !DCONST_DVARBOOL_bg_scopeFadeOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeOut") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v32);
      if ( v32->current.enabled && v7->adsSmoothFade )
        v33 = 1.0 - adsFrac;
      else
        v33 = FLOAT_1_0;
      *scopeFadeInfo = v33;
      scopeFadeInfo += 2;
      --v29;
    }
    while ( v29 );
    *(_WORD *)&v7->scopeUseDualFov = 0;
    v7->scopeLensInnerDisk = 0.30000001;
    v7->scopeLensInnerDiskMag = 1.0;
    v7->scopeLensOuterRing = 0.5;
    v7->scopeLensOuterRingMag = 1.0;
    v7->scopeLensRadius = 1.64;
    v7->scopeLensColorRed = 1.0;
    v7->scopeLensColorGreen = 1.0;
    v7->scopeLensColorBlue = 1.0;
    v7->scopeLensBrightness = 1.0;
    v7->scopeLensFadeStart = 1.0;
    v7->scopeLensFadeEnd = 1.0;
    v7->scopeEyeRelief_focusDistance = 2.0;
    v7->scopeEyeRelief_focuseUVScale = 0.80000001;
    v7->scopeEyeRelief_outOfFocusDistance = 10.0;
    v7->scopeEyeRelief_outOfFocuseUVScale = 5.0;
    v7->scopeEyeRelief_idleMovementScale = 0.5;
    v7->scopeEyeRelief_fullSpeedMovementScale = 1.0;
    v7->scopeEyeRelief_maxMovement = 0.30000001;
    v7->scopeEyeRelief_idleSway_freq = 0.5;
    v7->scopeEyeRelief_idleSway_movement = 0.0099999998;
    v7->scopeEyeRelief_fullSpeedSway_freq = 3.0;
    v7->scopeEyeRelief_fullSpeedSway_movement = 0.02;
  }
  if ( !v7->dofOverride )
  {
    v7->dofViewModelPhysicalFstop = 22.0;
    strcpy((char *)&v7->dofViewModelPhysicalFocusDistance, "shA");
    v7->dofPhysicalFstop = 22.0;
    v7->dofPhysicalFocusDistance = 29.301001;
  }
}

/*
==============
BG_GetSfxPackage
==============
*/
WeaponSFXPackage *BG_GetSfxPackage(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int AllWeaponAttachmentsCount; 
  WeaponSFXPackage *sfxPackage; 
  unsigned int numBindings; 
  unsigned int i; 
  __int64 v9; 
  SFXOverride *v10; 
  WeaponSFXPackage *overridesAlt; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2244, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  sfxPackage = v4->sfxPackage;
  if ( AllWeaponAttachmentsCount )
  {
    numBindings = 0;
    for ( i = 0; i < v4->numSfxOverrides; ++i )
    {
      v9 = i;
      v10 = &v4->sfxOverrides[v9];
      if ( v10->numBindings > numBindings && BG_WeaponHasOverride(r_weapon, v10->bindings, v10->numBindings) && (isAlternate && (overridesAlt = v4->sfxOverrides[v9].overridesAlt) != NULL || (overridesAlt = v4->sfxOverrides[v9].overrides) != NULL) )
      {
        numBindings = v10->numBindings;
        sfxPackage = overridesAlt;
      }
    }
  }
  return sfxPackage;
}

/*
==============
BG_GetShelvedDamageForRange
==============
*/
__int64 BG_GetShelvedDamageForRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float range)
{
  __int64 v5; 
  const Weapon *v7; 
  const WeaponDef *v8; 
  __int64 v9; 
  int minDamage; 
  int damage; 
  unsigned int v12; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v14; 
  AttDamage *v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  const dvar_t *v19; 
  __int64 size; 
  __int64 sizea; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  int mid1Damage; 
  int mid2Damage; 
  int mid3Damage; 
  float rangeArray; 
  float v31; 
  float v32; 
  float v33; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v5 = damageCalcType;
  v7 = r_weapon;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9349, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(v7->weaponIdx);
  BG_GetShelvedDamageRanges((const WeaponDamageCalcType)v5, v7, isAlternate, rangeScale, &rangeArray, 4);
  if ( (unsigned int)v5 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(size) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", size, attachmentSlots) )
      __debugbreak();
  }
  v9 = v5;
  minDamage = v8->damageInfo.damageData[v5].minDamage;
  mid1Damage = v8->damageInfo.damageData[v5].mid1Damage;
  mid3Damage = v8->damageInfo.damageData[v5].mid3Damage;
  mid2Damage = v8->damageInfo.damageData[v5].mid2Damage;
  if ( minDamage < 0 )
    minDamage = v8->damageInfo.damageData[0].minDamage;
  damage = v8->damageInfo.damageData[v5].damage;
  if ( damage < 0 )
    damage = v8->damageInfo.damageData[0].damage;
  v12 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v7, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v14 = attachments;
    while ( 1 )
    {
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9371, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v15 = (*v14)->damage;
      if ( v15 )
        break;
      ++v12;
      ++v14;
      if ( v12 >= WeaponAttachments_Internal )
      {
        v7 = r_weapon;
        goto LABEL_19;
      }
    }
    if ( (unsigned int)v5 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(sizea) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", sizea, attachmentSlotsa) )
        __debugbreak();
    }
    minDamage = v15->damageInfo.damageData[v5].minDamage;
    v18 = v15->damageInfo.damageData[v5].mid1Damage;
    v17 = v15->damageInfo.damageData[v5].mid2Damage;
    v16 = v15->damageInfo.damageData[v9].mid3Damage;
    if ( minDamage < 0 )
      minDamage = v15->damageInfo.damageData[0].minDamage;
    damage = v15->damageInfo.damageData[v9].damage;
    v7 = r_weapon;
    if ( damage < 0 )
      damage = v15->damageInfo.damageData[0].damage;
  }
  else
  {
LABEL_19:
    v16 = mid3Damage;
    v17 = mid2Damage;
    v18 = mid1Damage;
  }
  if ( range < rangeArray )
    return (unsigned int)damage;
  v19 = DVARBOOL_bg_bulletsUseMaxDamageMinRange;
  if ( !DVARBOOL_bg_bulletsUseMaxDamageMinRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletsUseMaxDamageMinRange") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  if ( v19->current.enabled && BG_GetWeaponClass(v7, isAlternate) != WEAPCLASS_SPREAD )
    return (unsigned int)damage;
  if ( v31 > 0.0 && range < v31 )
    return v18;
  if ( v32 > 0.0 && range < v32 )
    return v17;
  if ( v33 <= 0.0 || range >= v33 )
    return (unsigned int)minDamage;
  return v16;
}

/*
==============
BG_GetShelvedDamageRanges
==============
*/

__int64 __fastcall BG_GetShelvedDamageRanges(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, float *rangeArray, int size)
{
  WeaponDamageCalcType v8; 
  __m128 v9; 
  const WeaponDef *v10; 
  unsigned int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v14; 
  __int64 v15; 
  float damageScale; 
  __int128 damageScale_low; 
  float *v18; 
  __int128 v20; 
  __m128 v24; 
  __m128 v25; 
  __int64 v26; 
  float maxDamageRange; 
  unsigned int v28; 
  WeaponAttachment **v29; 
  AttDamage *damage; 
  float v31; 
  __int64 v32; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = damageCalcType;
  v9 = *(__m128 *)&rangeScale;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9287, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( size != 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9288, ASSERT_TYPE_ASSERT, "(size == 4)", (const char *)&queryFormat, "size == MAX_WEAPON_SHELF_RANGES") )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v11 = 0;
  _XMM7 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v14 = attachments;
    v15 = WeaponAttachments_Internal;
    do
    {
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9301, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damageScale = (*v14)->damageScale;
      if ( damageScale != 0.0 )
      {
        damageScale_low = LODWORD((*v14)->damageScale);
        *(float *)&damageScale_low = (float)(damageScale + *(float *)&_XMM7) - 1.0;
        _XMM7 = damageScale_low;
      }
      ++v14;
      --v15;
    }
    while ( v15 );
    v8 = damageCalcType;
  }
  rangeArray[3] = 0.0;
  v18 = rangeArray + 2;
  rangeArray[2] = 0.0;
  *(_QWORD *)rangeArray = 0i64;
  __asm { vmaxss  xmm3, xmm7, xmm6 }
  v20 = LODWORD(FLOAT_1_0);
  *(float *)&v20 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v20;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm8, xmm2
  }
  v24 = v9;
  v24.m128_f32[0] = v9.m128_f32[0] * *(float *)&_XMM0;
  v25 = _mm_shuffle_ps(v24, v24, 0);
  if ( (unsigned int)v8 >= WEAP_DMG_CALC_TYPE_NUM )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v26 = v8;
  rangeArray[1] = v10->damageInfo.damageData[v8].mid1DamageRange;
  *v18 = v10->damageInfo.damageData[v8].mid2DamageRange;
  rangeArray[3] = v10->damageInfo.damageData[v8].mid3DamageRange;
  maxDamageRange = v10->damageInfo.damageData[v8].maxDamageRange;
  if ( maxDamageRange < 0.0 )
    maxDamageRange = v10->damageInfo.damageData[0].maxDamageRange;
  v28 = 0;
  *rangeArray = maxDamageRange;
  if ( WeaponAttachments_Internal )
  {
    v29 = attachments;
    while ( 1 )
    {
      if ( !*v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9316, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damage = (*v29)->damage;
      if ( damage )
        break;
      ++v28;
      ++v29;
      if ( v28 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
    {
      LODWORD(attachmentSlots) = 3;
      LODWORD(numAttachmentSlots) = damageCalcType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    rangeArray[1] = damage->damageInfo.damageData[v26].mid1DamageRange;
    *v18 = damage->damageInfo.damageData[v26].mid2DamageRange;
    rangeArray[3] = damage->damageInfo.damageData[v26].mid3DamageRange;
    v31 = damage->damageInfo.damageData[v26].maxDamageRange;
    if ( v31 < 0.0 )
      *rangeArray = damage->damageInfo.damageData[0].maxDamageRange;
    else
      *rangeArray = v31;
  }
LABEL_35:
  v32 = 0i64;
  *(__m128 *)rangeArray = _mm128_mul_ps(v25, *(__m128 *)rangeArray);
  if ( size < 4i64 )
  {
LABEL_41:
    while ( v32 < size )
    {
      if ( rangeArray[v32] <= 0.0 )
        break;
      ++v11;
      ++v32;
    }
  }
  else
  {
    while ( *(v18 - 2) > 0.0 )
    {
      if ( *(v18 - 1) <= 0.0 )
        return v11 + 1;
      if ( *v18 <= 0.0 )
        return v11 + 2;
      if ( v18[1] <= 0.0 )
        return v11 + 3;
      v11 += 4;
      v32 += 4i64;
      v18 += 4;
      if ( v32 >= size - 3i64 )
        goto LABEL_41;
    }
  }
  return v11;
}

/*
==============
BG_GetShootingDirectionScaleForAngleType
==============
*/
float BG_GetShootingDirectionScaleForAngleType(bitarray<64> perks, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const float adsFraction, const WeaponAngleType angleType)
{
  double Float_Internal_DebugName; 
  const dvar_t *v11; 
  const char *v12; 
  float v13; 
  double v14; 
  float v15; 
  float v16; 
  const WeaponDef *v17; 
  double ADSGunBobBulletDirScale; 
  unsigned int v19; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v21; 
  const WeaponAttachment **p_outAdvancedIdleSettings; 
  AttGunKick *AttachmentGunKick; 
  const WeaponDef *v24; 
  double v25; 
  float v26; 
  double v27; 
  const WeaponDef *v28; 
  WeaponOffsetPatternDescription *weaponOffsetPatterns; 
  __int64 v30; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponDef *v33; 
  SwaySettings outAdvancedIdleSettings; 
  unsigned __int8 attachmentIds[32]; 

  switch ( angleType )
  {
    case WEAPON_ANGLE_TYPE_BASE:
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBaseAds, "bg_bulletDirScaleBaseAds");
      v11 = DCONST_DVARFLT_bg_bulletDirScaleBaseHip;
      v12 = "bg_bulletDirScaleBaseHip";
      goto LABEL_3;
    case WEAPON_ANGLE_TYPE_BASE_PIVOT_STAND:
    case WEAPON_ANGLE_TYPE_BASE_PIVOT_CROUCH:
    case WEAPON_ANGLE_TYPE_CLIENT_SPRING:
    case WEAPON_ANGLE_TYPE_CLIENT_MOTION_TORSO:
    case WEAPON_ANGLE_TYPE_CLIENT_MOTION_GUN:
    case WEAPON_ANGLE_TYPE_SKYDIVE:
      goto $LN22_36;
    case WEAPON_ANGLE_TYPE_BOB:
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBobAds, "bg_bulletDirScaleBobAds");
      v11 = DCONST_DVARFLT_bg_bulletDirScaleBobHip;
      v12 = "bg_bulletDirScaleBobHip";
      goto LABEL_3;
    case WEAPON_ANGLE_TYPE_IDLE:
      v17 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
      if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20150, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      v15 = (float)(1.0 - adsFraction) * v17->bulletDirGunAngleModifierIdleHip;
      v16 = adsFraction * v17->bulletDirGunAngleModifierIdleAds;
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_IDLE_ADVANCED_1:
      BG_GetAdvancedIdleSettings(perks, r_weapon, isAlternate, (AdvancedIdleSettings *)&outAdvancedIdleSettings);
      *(float *)&ADSGunBobBulletDirScale = (float)((float)(1.0 - adsFraction) * outAdvancedIdleSettings.hip.common.pitchScale) + (float)(adsFraction * outAdvancedIdleSettings.ads.common.yawScale);
      return *(float *)&ADSGunBobBulletDirScale;
    case WEAPON_ANGLE_TYPE_IDLE_ADVANCED_2:
      BG_GetAdvancedIdleSettings(perks, r_weapon, isAlternate, (AdvancedIdleSettings *)&outAdvancedIdleSettings);
      *(float *)&ADSGunBobBulletDirScale = (float)((float)(1.0 - adsFraction) * *(float *)&outAdvancedIdleSettings.adv.enabled) + (float)(adsFraction * outAdvancedIdleSettings.adv.torsoGoalViewSpeedToMaxDeadzone_viewspeed.v[1]);
      return *(float *)&ADSGunBobBulletDirScale;
    case WEAPON_ANGLE_TYPE_SWAY:
      BG_GetSwaySettings(weaponMap, ps, r_weapon, isAlternate, &outAdvancedIdleSettings);
      *(float *)&ADSGunBobBulletDirScale = (float)((float)(1.0 - adsFraction) * outAdvancedIdleSettings.hip.common.gunAngleScale) + (float)(adsFraction * outAdvancedIdleSettings.ads.common.gunAngleScale);
      return *(float *)&ADSGunBobBulletDirScale;
    case WEAPON_ANGLE_TYPE_RECOIL:
      v33 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
      if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20180, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      v19 = 0;
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&outAdvancedIdleSettings, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      v21 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
      if ( !WeaponAttachments_Internal )
        goto LABEL_27;
      p_outAdvancedIdleSettings = (const WeaponAttachment **)&outAdvancedIdleSettings;
      break;
    case WEAPON_ANGLE_TYPE_TILT:
      v24 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
      if ( !v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20202, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      v15 = (float)(1.0 - adsFraction) * v24->bulletDirGunAngleModifierGunTiltHip;
      v16 = adsFraction * v24->bulletDirGunAngleModifierGunTiltAds;
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_ADSBOB:
      ADSGunBobBulletDirScale = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBobAds, "bg_bulletDirScaleBobAds");
      *(float *)&ADSGunBobBulletDirScale = *(float *)&ADSGunBobBulletDirScale * adsFraction;
      return *(float *)&ADSGunBobBulletDirScale;
    case WEAPON_ANGLE_TYPE_MOVEMENTTILT:
      ADSGunBobBulletDirScale = BG_GetADSGunBobBulletDirScale(weaponMap, ps, r_weapon, isAlternate);
      *(float *)&ADSGunBobBulletDirScale = *(float *)&ADSGunBobBulletDirScale * adsFraction;
      return *(float *)&ADSGunBobBulletDirScale;
    case WEAPON_ANGLE_TYPE_DAMAGEKICK:
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleDamageKickAds, "bg_bulletDirScaleDamageKickAds");
      v11 = DCONST_DVARFLT_bg_bulletDirScaleDamageKickHip;
      v12 = "bg_bulletDirScaleDamageKickHip";
LABEL_3:
      v13 = *(float *)&Float_Internal_DebugName;
      v14 = Dvar_GetFloat_Internal_DebugName(v11, v12);
      v15 = *(float *)&v14 * (float)(1.0 - adsFraction);
      v16 = v13 * adsFraction;
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_MOUNT:
      v25 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleMountAds, "bg_bulletDirScaleMountAds");
      v26 = *(float *)&v25;
      v27 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleMountHip, "bg_bulletDirScaleMountHip");
      ADSGunBobBulletDirScale = I_fclamp(*(float *)&v27, v26, adsFraction);
      return *(float *)&ADSGunBobBulletDirScale;
    default:
      if ( (unsigned int)(angleType - 18) > 0xB )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20266, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled weapon angle type: %d", angleType) )
          __debugbreak();
      }
      else
      {
        v28 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
        if ( !v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20249, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
          __debugbreak();
        if ( angleType - 18 < v28->numWeaponOffsetPatterns )
        {
          weaponOffsetPatterns = v28->weaponOffsetPatterns;
          v30 = 9i64 * (int)angleType - 162;
          if ( *((_DWORD *)&weaponOffsetPatterns->transformType + 2 * v30) == 3 )
          {
            LODWORD(ADSGunBobBulletDirScale) = *((_DWORD *)&weaponOffsetPatterns->bulletDirScale + 2 * v30);
            return *(float *)&ADSGunBobBulletDirScale;
          }
        }
      }
$LN22_36:
      LODWORD(ADSGunBobBulletDirScale) = 0;
      return *(float *)&ADSGunBobBulletDirScale;
  }
  while ( 1 )
  {
    if ( !*p_outAdvancedIdleSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20188, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *p_outAdvancedIdleSettings, v21);
    if ( AttachmentGunKick )
      break;
    ++v19;
    ++p_outAdvancedIdleSettings;
    if ( v19 >= WeaponAttachments_Internal )
    {
LABEL_27:
      v15 = (float)(1.0 - adsFraction) * v33->bulletDirGunAngleModifierGunKickHip;
      v16 = adsFraction * v33->bulletDirGunAngleModifierGunKickAds;
      goto LABEL_28;
    }
  }
  v15 = (float)(1.0 - adsFraction) * AttachmentGunKick->bulletDirGunAngleModifierGunKickHip;
  v16 = adsFraction * AttachmentGunKick->bulletDirGunAngleModifierGunKickAds;
LABEL_28:
  *(float *)&ADSGunBobBulletDirScale = v15 + v16;
  return *(float *)&ADSGunBobBulletDirScale;
}

/*
==============
BG_GetSideReticle
==============
*/
void BG_GetSideReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleSide, int *reticleSideSize, bool *spin45)
{
  const WeaponDef *v9; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v13; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !reticleSide && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16575, ASSERT_TYPE_ASSERT, "(reticleSide)", (const char *)&queryFormat, "reticleSide") )
    __debugbreak();
  if ( !reticleSideSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16576, ASSERT_TYPE_ASSERT, "(reticleSideSize)", (const char *)&queryFormat, "reticleSideSize") )
    __debugbreak();
  if ( !spin45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16577, ASSERT_TYPE_ASSERT, "(spin45)", (const char *)&queryFormat, "spin45") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = 0;
  *reticleSide = v9->reticleSide;
  *reticleSideSize = v9->iReticleSideSize;
  *spin45 = v9->reticleSpin45;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16587, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v13 = *i;
      general = (*i)->general;
      if ( general )
        break;
      if ( ++v10 >= WeaponAttachments_Internal )
        return;
    }
    *reticleSide = general->reticleSide;
    *reticleSideSize = v13->general->reticleSideSize;
    *spin45 = v13->general->reticleSpin45;
  }
}

/*
==============
BG_GetSlideSpread
==============
*/
void BG_GetSlideSpread(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMax)
{
  const WeaponDef *v8; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  __int64 v13; 
  float slideSpreadScale; 
  __int128 slideSpreadScale_low; 
  WeaponAttachment **v16; 
  WeaponAttachment *v17; 
  float *p_slideSpreadMin; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outSlideSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13871, ASSERT_TYPE_ASSERT, "(outSlideSpreadMin)", (const char *)&queryFormat, "outSlideSpreadMin") )
    __debugbreak();
  if ( !outSlideSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13872, ASSERT_TYPE_ASSERT, "(outSlideSpreadMax)", (const char *)&queryFormat, "outSlideSpreadMax") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *outSlideSpreadMin = v8->slideSpreadMin;
  *outSlideSpreadMax = v8->slideSpreadMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    v13 = WeaponAttachments_Internal;
    do
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13882, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      slideSpreadScale = (*v12)->slideSpreadScale;
      if ( slideSpreadScale != 0.0 )
      {
        slideSpreadScale_low = LODWORD((*v12)->slideSpreadScale);
        *(float *)&slideSpreadScale_low = (float)(slideSpreadScale + *(float *)&_XMM6) - 1.0;
        _XMM6 = slideSpreadScale_low;
      }
      ++v12;
      --v13;
    }
    while ( v13 );
  }
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    while ( 1 )
    {
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13891, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v17 = *v16;
      p_slideSpreadMin = &(*v16)->slideSpread->slideSpreadMin;
      if ( p_slideSpreadMin )
        break;
      ++v9;
      ++v16;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    *outSlideSpreadMin = *p_slideSpreadMin;
    *outSlideSpreadMax = v17->slideSpread->slideSpreadMax;
  }
LABEL_24:
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v20 = LODWORD(FLOAT_1_0);
  *(float *)&v20 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v20;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm3, xmm7, xmm2
  }
  *outSlideSpreadMin = *(float *)&_XMM1 * *outSlideSpreadMin;
  *outSlideSpreadMax = *(float *)&_XMM1 * *outSlideSpreadMax;
}

/*
==============
BG_GetSlideSpreadWithDecay
==============
*/
void BG_GetSlideSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMoveMax, float *outSlideSpreadMax, float *outSlideSpreadDecayRate, float *outSlideSpreadTurnAdd)
{
  float *v7; 
  float *v8; 
  const WeaponDef *v12; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v16; 
  __int64 v17; 
  float slideSpreadScale; 
  __int128 slideSpreadScale_low; 
  WeaponAttachment **v20; 
  WeaponAttachment *v21; 
  float *p_slideSpreadMin; 
  float *v23; 
  __int128 v25; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v7 = outSlideSpreadTurnAdd;
  v8 = outSlideSpreadMoveMax;
  if ( !outSlideSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14039, ASSERT_TYPE_ASSERT, "(outSlideSpreadMin)", (const char *)&queryFormat, "outSlideSpreadMin") )
    __debugbreak();
  if ( !outSlideSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14040, ASSERT_TYPE_ASSERT, "(outSlideSpreadMax)", (const char *)&queryFormat, "outSlideSpreadMax") )
    __debugbreak();
  if ( !outSlideSpreadDecayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14041, ASSERT_TYPE_ASSERT, "(outSlideSpreadDecayRate)", (const char *)&queryFormat, "outSlideSpreadDecayRate") )
    __debugbreak();
  if ( !outSlideSpreadTurnAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14042, ASSERT_TYPE_ASSERT, "(outSlideSpreadTurnAdd)", (const char *)&queryFormat, "outSlideSpreadTurnAdd") )
    __debugbreak();
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14043, ASSERT_TYPE_ASSERT, "(outSlideSpreadMoveMax)", (const char *)&queryFormat, "outSlideSpreadMoveMax") )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outSlideSpreadMin = v12->slideSpreadMin;
  v13 = 0;
  *outSlideSpreadMax = v12->slideSpreadMax;
  *outSlideSpreadDecayRate = v12->slideSpreadDecayRate;
  *outSlideSpreadTurnAdd = v12->slideSpreadTurnAdd;
  *v8 = v12->slideSpreadMoveMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    v17 = WeaponAttachments_Internal;
    do
    {
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14057, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      slideSpreadScale = (*v16)->slideSpreadScale;
      if ( slideSpreadScale != 0.0 )
      {
        slideSpreadScale_low = LODWORD((*v16)->slideSpreadScale);
        *(float *)&slideSpreadScale_low = (float)(slideSpreadScale + *(float *)&_XMM6) - 1.0;
        _XMM6 = slideSpreadScale_low;
      }
      ++v16;
      --v17;
    }
    while ( v17 );
    v8 = outSlideSpreadMoveMax;
    v7 = outSlideSpreadTurnAdd;
  }
  if ( WeaponAttachments_Internal )
  {
    v20 = attachments;
    while ( 1 )
    {
      if ( !*v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14066, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v21 = *v20;
      p_slideSpreadMin = &(*v20)->slideSpread->slideSpreadMin;
      if ( p_slideSpreadMin )
        break;
      ++v13;
      ++v20;
      if ( v13 >= WeaponAttachments_Internal )
        goto LABEL_32;
    }
    v23 = outSlideSpreadMin;
    *outSlideSpreadMin = *p_slideSpreadMin;
    *outSlideSpreadMax = v21->slideSpread->slideSpreadMax;
    *outSlideSpreadDecayRate = v21->slideSpread->slideSpreadDecayRate;
    *v7 = v21->slideSpread->slideSpreadTurnAdd;
    *v8 = v21->slideSpread->slideSpreadMoveMax;
  }
  else
  {
LABEL_32:
    v23 = outSlideSpreadMin;
  }
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v25 = LODWORD(FLOAT_1_0);
  *(float *)&v25 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v25 + 1) = (v25 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v25 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v25;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm7, xmm2
  }
  *v23 = *(float *)&_XMM4 * *v23;
  *outSlideSpreadMax = *(float *)&_XMM4 * *outSlideSpreadMax;
  *outSlideSpreadDecayRate = *(float *)&_XMM4 * *outSlideSpreadDecayRate;
  *v7 = *(float *)&_XMM4 * *v7;
  *v8 = *(float *)&_XMM4 * *v8;
}

/*
==============
BG_GetSpreadForWeapon
==============
*/
void BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon *r_weapon, float *minSpread, float *maxSpread)
{
  __int128 v4; 
  __int128 v5; 
  __int128 v6; 
  __int128 v7; 
  float spreadOverride; 
  int aimSpreadStateLast; 
  int aimSpreadStateCurrent; 
  const SuitDef *SuitDef; 
  int viewheight_crouch; 
  int viewheight_stand; 
  float v18; 
  double v19; 
  float v20; 
  float v21; 
  float v22; 
  double Float_Internal_DebugName; 
  int Int_Internal_DebugName; 
  float v25; 
  double v26; 
  double v27; 
  float v28; 
  double v29; 
  float v30; 
  int v31; 
  float viewHeightCurrent; 
  bool v33; 
  bool v34; 
  int v35; 
  int v36; 
  float v37; 
  bool v38; 
  float v39; 
  float v40; 
  double v41; 
  int v42; 
  float v43; 
  double v44; 
  double v45; 
  double v46; 
  float v47; 
  const dvar_t *v48; 
  float value; 
  int v50; 
  __int128 v51; 
  const dvar_t *v54; 
  const dvar_t *v55; 
  float spreadMinOut; 
  float hipSpreadDuckedMin; 
  float v58; 
  float v59; 
  float hipSpreadDuckedMax; 
  float v61; 
  float v62; 
  float hipSpreadInAirMax; 
  float hipSpreadInAirMin; 
  float hipSpreadSprintMax; 
  float hipSpreadSprintMin; 
  float hipSpreadProneMax; 
  float hipSpreadProneMin; 
  float hipSpreadStandMax; 
  float hipSpreadStandMin; 
  float outSlideSpreadMax; 
  float outSlideSpreadMin; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 
  __int128 v83; 
  __int128 v84; 
  __int128 v85; 
  __int128 v86; 
  float spreadMaxOut; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4526, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( ps->weapCommon.spreadOverrideState == 2 )
  {
    *minSpread = (float)ps->weapCommon.spreadOverride;
    spreadOverride = (float)ps->weapCommon.spreadOverride;
    goto LABEL_50;
  }
  aimSpreadStateLast = ps->weapCommon.aimSpreadStateLast;
  v86 = v4;
  v85 = v5;
  v84 = v6;
  if ( aimSpreadStateLast >= 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4542, ASSERT_TYPE_ASSERT, "(lastState < AIM_SPREAD_STATE_COUNT)", (const char *)&queryFormat, "lastState < AIM_SPREAD_STATE_COUNT") )
    __debugbreak();
  aimSpreadStateCurrent = ps->weapCommon.aimSpreadStateCurrent;
  if ( aimSpreadStateCurrent >= 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4545, ASSERT_TYPE_ASSERT, "(currentState < AIM_SPREAD_STATE_COUNT)", (const char *)&queryFormat, "currentState < AIM_SPREAD_STATE_COUNT") )
    __debugbreak();
  hipSpreadDuckedMin = *(float *)&ps->weapCommon.aimSpreadStateChangeTime;
  BG_GetSpreadMinMaxForState(ps, r_weapon, (const AimSpreadState)aimSpreadStateLast, &spreadMinOut, &spreadMaxOut);
  BG_GetSpreadMinMaxForState(ps, r_weapon, (const AimSpreadState)aimSpreadStateCurrent, &v58, &v59);
  SuitDef = BG_GetSuitDef(ps->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4554, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  v83 = v7;
  if ( aimSpreadStateLast == 2 )
  {
    if ( aimSpreadStateCurrent == 1 )
    {
      viewheight_crouch = SuitDef->viewheight_crouch;
      viewheight_stand = SuitDef->viewheight_stand;
LABEL_18:
      v18 = (float)(ps->viewHeightCurrent - (float)viewheight_crouch) / (float)(viewheight_stand - viewheight_crouch);
LABEL_19:
      v19 = I_fclamp(v18, 0.0, 1.0);
      v20 = *(float *)&v19;
LABEL_48:
      v30 = spreadMaxOut;
      v28 = spreadMinOut;
      goto LABEL_49;
    }
    if ( aimSpreadStateCurrent == 3 )
    {
      v21 = ps->viewHeightCurrent - (float)SuitDef->viewheight_crouch;
      v22 = v21 / (float)(BG_Suit_GetProneViewHeight(SuitDef) - SuitDef->viewheight_crouch);
      I_fclamp(v22, 0.0, 1.0);
      v20 = v22;
      if ( !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_bg_crouchToProneSpreadEnabled, "bg_crouchToProneSpreadEnabled") )
        goto LABEL_48;
      if ( v22 >= 1.0 )
      {
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpreadRecover, "bg_crouchToProneSpreadRecover");
        Int_Internal_DebugName = Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_crouchToProneSpreadRecoverDelay, "bg_crouchToProneSpreadRecoverDelay");
        v25 = (float)(ps->serverTime - LODWORD(hipSpreadDuckedMin) - Int_Internal_DebugName) / *(float *)&Float_Internal_DebugName;
        v26 = I_fclamp(v25, 0.0, 1.0);
        v20 = v25;
        if ( *(float *)&v26 >= 1.0 )
          goto LABEL_48;
      }
      else
      {
        v20 = 0.0;
      }
      v27 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
      v28 = spreadMinOut * *(float *)&v27;
      v29 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
      v30 = spreadMaxOut * *(float *)&v29;
      goto LABEL_49;
    }
    goto LABEL_40;
  }
  if ( aimSpreadStateLast != 1 )
  {
    if ( aimSpreadStateLast == 3 && aimSpreadStateCurrent == 2 )
    {
      v47 = ps->viewHeightCurrent - (float)BG_Suit_GetProneViewHeight(SuitDef);
      v18 = v47 / (float)(SuitDef->viewheight_crouch - BG_Suit_GetProneViewHeight(SuitDef));
      goto LABEL_19;
    }
    goto LABEL_40;
  }
  if ( aimSpreadStateCurrent == 2 )
  {
    viewheight_crouch = SuitDef->viewheight_stand;
    viewheight_stand = SuitDef->viewheight_crouch;
    goto LABEL_18;
  }
  if ( aimSpreadStateCurrent != 3 )
  {
LABEL_40:
    v48 = DCONST_DVARFLT_aim_spread_lerp_time;
    if ( !DCONST_DVARFLT_aim_spread_lerp_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_spread_lerp_time") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v48);
    value = v48->current.value;
    if ( value > 0.0 )
    {
      v50 = ps->serverTime - LODWORD(hipSpreadDuckedMin);
      if ( v50 < 0 )
        v50 = 0;
      v51 = 0i64;
      *(float *)&v51 = (float)v50 * 0.001;
      _XMM1 = v51;
      __asm { vminss  xmm2, xmm1, xmm3 }
      v20 = *(float *)&_XMM2 / value;
    }
    else
    {
      v20 = FLOAT_1_0;
    }
    goto LABEL_48;
  }
  v31 = SuitDef->viewheight_crouch;
  viewHeightCurrent = ps->viewHeightCurrent;
  v33 = BG_UsingAlternate(ps);
  if ( viewHeightCurrent >= (float)v31 )
  {
    BG_GetHipSpread(r_weapon, v33, &hipSpreadStandMin, &hipSpreadStandMax, &hipSpreadDuckedMin, &hipSpreadDuckedMax, &hipSpreadProneMin, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, &hipSpreadInAirMax);
    v34 = BG_UsingAlternate(ps);
    BG_GetSlideSpread(r_weapon, v34, &outSlideSpreadMin, &outSlideSpreadMax);
    v35 = SuitDef->viewheight_stand;
    v36 = SuitDef->viewheight_crouch;
    v58 = hipSpreadDuckedMin;
    v37 = ps->viewHeightCurrent;
    v59 = hipSpreadDuckedMax;
    v18 = (float)(v37 - (float)v35) / (float)(v36 - v35);
    goto LABEL_19;
  }
  BG_GetHipSpread(r_weapon, v33, &v80, &v79, &v61, &v62, &v78, &v77, &v76, &v75, &v74, &v73);
  v38 = BG_UsingAlternate(ps);
  BG_GetSlideSpread(r_weapon, v38, &v82, &v81);
  v28 = v61;
  v30 = v62;
  v39 = ps->viewHeightCurrent - (float)SuitDef->viewheight_crouch;
  v40 = v39 / (float)(BG_Suit_GetProneViewHeight(SuitDef) - SuitDef->viewheight_crouch);
  I_fclamp(v40, 0.0, 1.0);
  v20 = v40;
  if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_bg_crouchToProneSpreadEnabled, "bg_crouchToProneSpreadEnabled") )
  {
    if ( v40 >= 1.0 )
    {
      v41 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpreadRecover, "bg_crouchToProneSpreadRecover");
      v42 = Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_directStandToProneSpreadRecoverDelay, "bg_directStandToProneSpreadRecoverDelay");
      v43 = (float)(ps->serverTime - LODWORD(hipSpreadDuckedMin) - v42) / *(float *)&v41;
      v44 = I_fclamp(v43, 0.0, 1.0);
      v20 = v43;
      if ( *(float *)&v44 >= 1.0 )
        goto LABEL_49;
    }
    else
    {
      v20 = 0.0;
    }
    v45 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
    v28 = *(float *)&v45 * v28;
    v46 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
    v30 = *(float *)&v46 * v30;
  }
LABEL_49:
  spreadOverride = (float)((float)(v59 - v30) * v20) + v30;
  *minSpread = (float)((float)(v58 - v28) * v20) + v28;
LABEL_50:
  *maxSpread = spreadOverride;
  if ( ps->weapCommon.spreadOverrideState == 1 )
    *maxSpread = (float)ps->weapCommon.spreadOverride;
  if ( BG_HasPerk(&ps->perks, 0) )
  {
    v54 = DVARFLT_perk_weapSpreadMultiplier;
    if ( !DVARFLT_perk_weapSpreadMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapSpreadMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v54);
    *minSpread = v54->current.value * *minSpread;
    v55 = DVARFLT_perk_weapSpreadMultiplier;
    if ( !DVARFLT_perk_weapSpreadMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapSpreadMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v55);
    *maxSpread = v55->current.value * *maxSpread;
  }
  BG_GameInterface_ModifySpreadForWeapon(ps, r_weapon, minSpread, maxSpread);
}

/*
==============
BG_GetSpreadMinMaxForState
==============
*/
void BG_GetSpreadMinMaxForState(const playerState_s *ps, const Weapon *r_weapon, const AimSpreadState state, float *spreadMinOut, float *spreadMaxOut)
{
  float *v9; 
  bool v10; 
  bool v11; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float hipSpreadProneMin; 
  float hipSpreadProneMax; 
  float hipSpreadSprintMin; 
  float hipSpreadSprintMax; 
  float outSlideSpreadMin; 
  float outSlideSpreadMax; 
  float hipSpreadInAirMin; 
  float hipSpreadInAirMax; 
  float hipSpreadDuckedMin; 
  float hipSpreadStandMin; 
  float hipSpreadDuckedMax; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4445, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !spreadMinOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4446, ASSERT_TYPE_ASSERT, "(spreadMinOut)", (const char *)&queryFormat, "spreadMinOut") )
    __debugbreak();
  v9 = spreadMaxOut;
  if ( !spreadMaxOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4447, ASSERT_TYPE_ASSERT, "(spreadMaxOut)", (const char *)&queryFormat, "spreadMaxOut") )
    __debugbreak();
  *spreadMinOut = 0.0;
  *v9 = 0.0;
  v10 = BG_UsingAlternate(ps);
  BG_GetHipSpread(r_weapon, v10, &hipSpreadStandMin, (float *)&spreadMaxOut, &hipSpreadDuckedMin, &hipSpreadDuckedMax, &hipSpreadProneMin, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, &hipSpreadInAirMax);
  v11 = BG_UsingAlternate(ps);
  BG_GetSlideSpread(r_weapon, v11, &outSlideSpreadMin, &outSlideSpreadMax);
  switch ( state )
  {
    case AIM_SPREAD_STATE_INVALID:
    case AIM_SPREAD_STATE_STAND:
      v12 = *(float *)&spreadMaxOut;
      *spreadMinOut = hipSpreadStandMin;
      *v9 = v12;
      break;
    case AIM_SPREAD_STATE_CROUCH:
      v13 = hipSpreadDuckedMax;
      *spreadMinOut = hipSpreadDuckedMin;
      *v9 = v13;
      break;
    case AIM_SPREAD_STATE_PRONE:
      v14 = hipSpreadProneMax;
      *spreadMinOut = hipSpreadProneMin;
      *v9 = v14;
      break;
    case AIM_SPREAD_STATE_SLIDE:
      v16 = outSlideSpreadMax;
      *spreadMinOut = outSlideSpreadMin;
      *v9 = v16;
      break;
    case AIM_SPREAD_STATE_SPRINT:
      v15 = hipSpreadSprintMax;
      *spreadMinOut = hipSpreadSprintMin;
      *v9 = v15;
      break;
    case AIM_SPREAD_STATE_IN_AIR:
      v17 = hipSpreadInAirMax;
      *spreadMinOut = hipSpreadInAirMin;
      *v9 = v17;
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4517, ASSERT_TYPE_ASSERT, "(0)", (const char *)&queryFormat, "0") )
        __debugbreak();
      break;
  }
}

/*
==============
BG_GetSprintAdditiveAnim
==============
*/
__int64 BG_GetSprintAdditiveAnim(weapAnimFiles_t relativeAnim)
{
  switch ( relativeAnim )
  {
    case WEAP_ANIM_SPRINT_IN:
      return 94i64;
    case WEAP_ANIM_SPRINT_LOOP:
      return 95i64;
    case WEAP_ANIM_SPRINT_OUT:
      return 97i64;
  }
  return (unsigned int)relativeAnim;
}

/*
==============
BG_GetSprintAnim
==============
*/
__int64 BG_GetSprintAnim(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t relativeAnim)
{
  weapAnimFiles_t v9; 
  weapAnimFiles_t suitAnim; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = relativeAnim;
  switch ( relativeAnim )
  {
    case WEAP_ANIM_SPRINT_IN:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_IN;
      break;
    case WEAP_ANIM_SPRINT_LOOP:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_LOOP;
      break;
    case WEAP_ANIM_SPRINT_OUT:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
      break;
    default:
      suitAnim = relativeAnim;
      break;
  }
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, relativeAnim, suitAnim) )
    return (unsigned int)suitAnim;
  return (unsigned int)v9;
}

/*
==============
BG_GetSprintOutTimeScale
==============
*/
float BG_GetSprintOutTimeScale(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate)
{
  __int128 v4; 
  __int128 v5; 
  unsigned __int16 weaponIdx; 
  const WeaponDef *v14; 
  const WeaponDef *v15; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v18; 
  WeaponAttachment **v19; 
  __int64 v20; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v22; 
  const dvar_t *v23; 
  __int128 v24; 
  const dvar_t *v25; 
  __int128 v26; 
  __int128 v28; 
  __int128 v32; 
  float v36; 
  const WeaponDef *v37; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v40; 
  __int128 v41; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11403, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11404, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponIdx = r_weapon->weaponIdx;
  if ( !r_weapon->weaponIdx )
    return FLOAT_1_0;
  v41 = v4;
  v40 = v5;
  _XMM6 = LODWORD(FLOAT_1_0);
  _XMM7 = LODWORD(FLOAT_1_0);
  v14 = BG_WeaponDefAtIndex(weaponIdx);
  v37 = v14;
  v15 = v14;
  if ( v14 )
  {
    _XMM7 = LODWORD(v14->sprintOutTimerScale);
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    v18 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
    if ( (_DWORD)WeaponAttachments_Internal )
    {
      v19 = attachments;
      v20 = WeaponAttachments_Internal;
      do
      {
        OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v19, v18);
        if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11424, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        v22 = _XMM6;
        ++v19;
        *(float *)&v22 = (float)(*(float *)&_XMM6 + OverrideAttachmentWhenApplicable->sprintOutTimerScale) - 1.0;
        _XMM6 = v22;
        --v20;
      }
      while ( v20 );
    }
    v15 = v37;
  }
  if ( BG_CanSprintFire(ps) )
  {
    v23 = DCONST_DVARFLT_perk_sprintFireSprintOutTimeMultiplier;
    if ( !DCONST_DVARFLT_perk_sprintFireSprintOutTimeMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_sprintFireSprintOutTimeMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v23);
    v24 = _XMM7;
    *(float *)&v24 = *(float *)&_XMM7 * v23->current.value;
    _XMM7 = v24;
  }
  if ( BG_HasPerk(&ps->perks, 0x13u) )
  {
    v25 = DVARFLT_perk_sprintRecoveryMultiplierActual;
    if ( !DVARFLT_perk_sprintRecoveryMultiplierActual && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_sprintRecoveryMultiplierActual") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    v26 = _XMM7;
    *(float *)&v26 = *(float *)&_XMM7 * v25->current.value;
    _XMM7 = v26;
  }
  __asm { vmaxss  xmm2, xmm6, xmm9 }
  v28 = LODWORD(FLOAT_1_0);
  *(float *)&v28 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v28 + 1) = (v28 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v28 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v28;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm8, xmm0
  }
  v32 = LODWORD(FLOAT_1_0);
  *(float *)&v32 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v32 + 1) = (v32 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v32 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v32;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm8, xmm2
  }
  v36 = *(float *)&_XMM0 * *(float *)&_XMM5;
  if ( v15->weapClass != WEAPCLASS_TURRET && v36 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11450, ASSERT_TYPE_ASSERT, "( ( 0.0f < sprintOutTimeScale ) )", "( sprintOutTimeScale ) = %g", v36) )
    __debugbreak();
  return v36;
}

/*
==============
BG_GetStandWeaponOffset
==============
*/
void BG_GetStandWeaponOffset(const Weapon *r_weapon, bool isAlternate, vec3_t *outStandOffset, vec3_t *outStandOffsetAngles, vec3_t *outStandOffsetPivot)
{
  __int64 WeaponAttachments_Internal; 
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  __int128 v13; 
  __int128 v14; 
  const WeaponDef *v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  WeaponAttachment **v21; 
  vec3_t *v22; 
  __int128 v23; 
  __int128 v24; 
  __int128 v25; 
  __int128 v26; 
  __int128 v27; 
  __int128 v28; 
  float v29; 
  float v30; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v16 = 0.0;
  v17 = 0.0;
  *outStandOffset = v15->vStandOfs;
  *outStandOffsetAngles = v15->vStandOfsRot;
  *outStandOffsetPivot = v15->vStandOfsRotPivot;
  v18 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v21 = attachments;
    do
    {
      if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22376, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v22 = (vec3_t *)*v21;
      if ( (*v21)->overrideStandOfs )
      {
        outStandOffset->v[0] = v22[52].v[0];
        outStandOffset->v[1] = v22[52].v[1];
        outStandOffset->v[2] = v22[52].v[2];
        outStandOffsetAngles->v[0] = v22[53].v[0];
        outStandOffsetAngles->v[1] = v22[53].v[1];
        outStandOffsetAngles->v[2] = v22[53].v[2];
        *outStandOffsetPivot = v22[54];
      }
      v23 = v10;
      *(float *)&v23 = *(float *)&v10 + v22[55].v[1];
      v10 = v23;
      v24 = v11;
      *(float *)&v24 = *(float *)&v11 + v22[55].v[2];
      v11 = v24;
      v25 = v12;
      *(float *)&v25 = *(float *)&v12 + v22[56].v[0];
      v12 = v25;
      v26 = v13;
      *(float *)&v26 = *(float *)&v13 + v22[56].v[1];
      v13 = v26;
      v27 = v14;
      *(float *)&v27 = *(float *)&v14 + v22[56].v[2];
      v14 = v27;
      v28 = v9;
      *(float *)&v28 = *(float *)&v9 + v22[55].v[0];
      v9 = v28;
      ++v21;
      v16 = *(float *)&v10;
      v17 = *(float *)&v11;
      v18 = *(float *)&v12;
      v19 = *(float *)&v13;
      v20 = *(float *)&v14;
      --WeaponAttachments_Internal;
    }
    while ( WeaponAttachments_Internal );
  }
  v29 = v16 + outStandOffset->v[1];
  outStandOffset->v[0] = *(float *)&v9 + outStandOffset->v[0];
  outStandOffset->v[2] = v17 + outStandOffset->v[2];
  outStandOffset->v[1] = v29;
  v30 = v19 + outStandOffsetAngles->v[1];
  outStandOffsetAngles->v[0] = v18 + outStandOffsetAngles->v[0];
  outStandOffsetAngles->v[2] = v20 + outStandOffsetAngles->v[2];
  outStandOffsetAngles->v[1] = v30;
}

/*
==============
BG_GetSwayScalar
==============
*/
float BG_GetSwayScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const int gameTime)
{
  bool hybridScope; 
  bool v10; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  int ADSZoomLevel; 
  __int64 v14; 
  double WeaponOrOffhandAdsFrac; 
  float v16; 
  float v17; 
  float v18; 
  double ADSZoomLevelFraction; 
  int v20; 
  int v21; 
  float v22; 
  float v23; 
  float v24; 
  BgHybridScopeFraction WeaponAttachments_Internal; 
  float v26; 
  const PlayerEquippedWeaponState *v27; 
  WeaponAttachment **v29; 
  float v30; 
  float v31; 
  __int128 v32; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v34; 
  bool v35; 
  __int128 v37; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 
  SwaySettings outSwaySettings; 
  __int64 v45; 
  float v46; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( ps )
  {
    if ( weaponMap )
    {
      EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
      if ( EquippedWeaponStateConst )
      {
        hybridScope = EquippedWeaponStateConst->hybridScope;
        goto LABEL_5;
      }
    }
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19863, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
  {
    __debugbreak();
  }
  hybridScope = 0;
LABEL_5:
  v10 = 0;
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  if ( hybridScope )
  {
    hybridScopeFractionInfo.fraction = FLOAT_1_0;
    hybridScopeFractionInfo.increasing = 1;
  }
  else
  {
    hybridScopeFractionInfo = 0i64;
  }
  v12 = BG_UsingAlternate(ps);
  BG_GetADSZoomInfo(weaponMap, r_weapon, v12, &hybridScopeFractionInfo, &outZoomInfo);
  ADSZoomLevel = BG_GetADSZoomLevel(weaponMap, ps, r_weapon, outZoomInfo.zoomCount);
  v14 = ADSZoomLevel;
  if ( ADSZoomLevel >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19872, ASSERT_TYPE_ASSERT, "(adsZoomLevel < 3)", "%s\n\tYou must introduce new ADS sway scalars to support the new zoom levels added. Supported: 3 Needed %d", "adsZoomLevel < 3", 3) )
    __debugbreak();
  BG_GetSwaySettings(weaponMap, ps, r_weapon, isAlternate, &outSwaySettings);
  WeaponOrOffhandAdsFrac = BG_GetWeaponOrOffhandAdsFrac(weaponMap, ps);
  v16 = 1.0 - *(float *)&WeaponOrOffhandAdsFrac;
  v17 = (float)(*(float *)&WeaponOrOffhandAdsFrac * outSwaySettings.ads.adsSwayScale[v14]) + (float)(1.0 - *(float *)&WeaponOrOffhandAdsFrac);
  v18 = *(float *)&WeaponOrOffhandAdsFrac;
  ADSZoomLevelFraction = BG_GetADSZoomLevelFraction(weaponMap, ps, r_weapon, isAlternate, gameTime);
  v20 = 0;
  v45 = 0i64;
  v46 = 0.0;
  do
  {
    v21 = v20 + 1;
    v22 = (float)(v20 + 1);
    if ( *(float *)&ADSZoomLevelFraction <= v22 )
    {
      if ( v20 == 2 )
      {
        v23 = v22 - *(float *)&ADSZoomLevelFraction;
        v24 = 1.0 - v23;
        v21 = 0;
      }
      else
      {
        v24 = *(float *)&ADSZoomLevelFraction - (float)v20;
        v23 = 1.0 - v24;
      }
      *((float *)&v45 + v20) = v23;
      *((float *)&v45 + v21) = v24;
      goto LABEL_23;
    }
    ++v20;
  }
  while ( v21 < 3 );
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13000, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_GetADSZoomLevelWeights should have never reached here. adsZoomLevelFraction: %f", *(float *)&ADSZoomLevelFraction) )
    __debugbreak();
LABEL_23:
  WeaponAttachments_Internal = (BgHybridScopeFraction)BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v26 = FLOAT_1_0;
  if ( ps )
  {
    if ( weaponMap )
    {
      v27 = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
      if ( v27 )
        v10 = v27->hybridScope;
    }
  }
  _XMM1 = LODWORD(FLOAT_1_0);
  if ( LODWORD(WeaponAttachments_Internal.fraction) )
  {
    v29 = attachments;
    v30 = v46;
    v31 = *((float *)&v45 + 1);
    v32 = (unsigned int)v45;
    hybridScopeFractionInfo = WeaponAttachments_Internal;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v29, v10);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19898, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v34 = v32;
      *(float *)&v34 = (float)((float)((float)((float)((float)(*(float *)&v32 * OverrideAttachmentWhenApplicable->adsSwayScale) + (float)(v31 * OverrideAttachmentWhenApplicable->adsSwayScale2)) + (float)(v30 * OverrideAttachmentWhenApplicable->adsSwayScale3)) * v18) + (float)(v16 * OverrideAttachmentWhenApplicable->hipSwayScale)) + v26;
      ++v29;
      v35 = (*(_QWORD *)&hybridScopeFractionInfo)-- == 1i64;
      *(float *)&v34 = *(float *)&v34 - 1.0;
      v26 = *(float *)&v34;
      _XMM1 = v34;
    }
    while ( !v35 );
  }
  __asm { vmaxss  xmm3, xmm1, xmm0 }
  v37 = LODWORD(FLOAT_1_0);
  *(float *)&v37 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v37 + 1) = (v37 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v37 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM0 = v37;
  __asm
  {
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
  }
  return v17 * *(float *)&_XMM0;
}

/*
==============
BG_GetSwaySettings
==============
*/
void BG_GetSwaySettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, SwaySettings *outSwaySettings)
{
  const playerState_s *v8; 
  SwaySettings *p_swaySettings; 
  SwaySettings *v10; 
  __int64 v11; 
  __int128 v12; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v16; 
  WeaponAttachment **v17; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  SwaySettings *swaySettings; 
  float lerpSpeed; 
  float v21; 
  float swayTransitionLerpSpeed; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = ps;
  if ( !outSwaySettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22234, ASSERT_TYPE_ASSERT, "(outSwaySettings)", (const char *)&queryFormat, "outSwaySettings") )
    __debugbreak();
  p_swaySettings = &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->swaySettings;
  v10 = outSwaySettings;
  v11 = 2i64;
  do
  {
    v10 = (SwaySettings *)((char *)v10 + 128);
    v12 = *(_OWORD *)&p_swaySettings->hip.common.maxAngle;
    p_swaySettings = (SwaySettings *)((char *)p_swaySettings + 128);
    *(_OWORD *)v10[-1].adv.torsoMass.v = v12;
    *(_OWORD *)v10[-1].adv.torsoDamper.v = *(_OWORD *)p_swaySettings[-1].adv.torsoDamper.v;
    *(_OWORD *)&v10[-1].adv.gunGoalViewSpeedToOffset_graph = *(_OWORD *)&p_swaySettings[-1].adv.gunGoalViewSpeedToOffset_graph;
    *(_OWORD *)v10[-1].adv.gunGoalViewSpeedToOffset_offset.v = *(_OWORD *)p_swaySettings[-1].adv.gunGoalViewSpeedToOffset_offset.v;
    *(_OWORD *)v10[-1].adv.gunSpring.v = *(_OWORD *)p_swaySettings[-1].adv.gunSpring.v;
    *(_OWORD *)v10[-1].adv.gunPivotPoint.v = *(_OWORD *)p_swaySettings[-1].adv.gunPivotPoint.v;
    *(_OWORD *)&v10[-1].adv.fireDurationMs = *(_OWORD *)&p_swaySettings[-1].adv.fireDurationMs;
    *(_OWORD *)&v10[-1].adv.fireTorsoDeadzoneScale = *(_OWORD *)&p_swaySettings[-1].adv.fireTorsoDeadzoneScale;
    --v11;
  }
  while ( v11 );
  *(_WORD *)&outSwaySettings->overrideHip = 0;
  v13 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v16 = v8 && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, v8, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v17 = attachments;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v8, r_weapon, isAlternate, *v17, v16);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22248, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      swaySettings = OverrideAttachmentWhenApplicable->swaySettings;
      if ( swaySettings )
      {
        if ( !outSwaySettings->overrideHip && swaySettings->overrideHip )
        {
          lerpSpeed = outSwaySettings->hip.common.lerpSpeed;
          outSwaySettings->hip = swaySettings->hip;
          outSwaySettings->adv = swaySettings->adv;
          if ( swaySettings->hip.common.lerpSpeed < 0.0 )
            outSwaySettings->hip.common.lerpSpeed = lerpSpeed;
          outSwaySettings->overrideHip = 1;
        }
        if ( !outSwaySettings->overrideAds && swaySettings->overrideAds )
        {
          v21 = outSwaySettings->ads.common.lerpSpeed;
          swayTransitionLerpSpeed = outSwaySettings->ads.swayTransitionLerpSpeed;
          outSwaySettings->ads = swaySettings->ads;
          if ( swaySettings->ads.common.lerpSpeed < 0.0 )
            outSwaySettings->ads.common.lerpSpeed = v21;
          if ( swaySettings->ads.swayTransitionLerpSpeed < 0.0 )
            outSwaySettings->ads.swayTransitionLerpSpeed = swayTransitionLerpSpeed;
          outSwaySettings->overrideAds = 1;
        }
      }
      if ( outSwaySettings->overrideHip && outSwaySettings->overrideAds )
        break;
      v8 = ps;
      ++v13;
      ++v17;
    }
    while ( v13 < WeaponAttachments_Internal );
  }
}

/*
==============
BG_GetTargetAssistAngleRange
==============
*/
void BG_GetTargetAssistAngleRange(const Weapon *r_weapon, bool isAlternate, const float fallbackAngle, const float fallbackRange, float *outAngle, float *outRange)
{
  unsigned int v8; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponDef *v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *v12; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9186, ASSERT_TYPE_ASSERT, "(outAngle)", (const char *)&queryFormat, "outAngle") )
    __debugbreak();
  if ( !outRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9187, ASSERT_TYPE_ASSERT, "(outRange)", (const char *)&queryFormat, "outRange") )
    __debugbreak();
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outAngle = v10->targetAssistAngle;
  *outRange = v10->targetAssistRange;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9198, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *v11;
      targetAssist = (*v11)->targetAssist;
      if ( targetAssist )
        break;
      ++v8;
      ++v11;
      if ( v8 >= WeaponAttachments_Internal )
        goto LABEL_16;
    }
    *outAngle = targetAssist->targetAssistAngle;
    *outRange = v12->targetAssist->targetAssistRange;
  }
LABEL_16:
  if ( *outAngle < 0.001 )
    *outAngle = fallbackAngle;
  if ( *outRange < 0.001 )
    *outRange = fallbackRange;
}

/*
==============
BG_GetTargetAssistBehavior
==============
*/
__int64 BG_GetTargetAssistBehavior(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  targetAssistBehavior_t targetAssistBehavior; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  targetAssistBehavior = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistBehavior;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)targetAssistBehavior;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9124, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    targetAssist = (*i)->targetAssist;
    if ( targetAssist )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)targetAssistBehavior;
  }
  return (unsigned int)targetAssist->targetAssistBehavior;
}

/*
==============
BG_GetTargetAssistType
==============
*/
__int64 BG_GetTargetAssistType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  targetAssistType_t targetAssistType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  targetAssistType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)targetAssistType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9100, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    targetAssist = (*i)->targetAssist;
    if ( targetAssist )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)targetAssistType;
  }
  return (unsigned int)targetAssist->targetAssistType;
}

/*
==============
BG_GetTopMountYawMax
==============
*/
float BG_GetTopMountYawMax(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->mountTopYawMax;
  else
    return FLOAT_180_0;
}

/*
==============
BG_GetTurretFireType
==============
*/
__int64 BG_GetTurretFireType(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9871, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v4->turretFireType;
}

/*
==============
BG_GetUnderbarrelAttachment
==============
*/
const WeaponAttachment *BG_GetUnderbarrelAttachment(const Weapon *r_weapon)
{
  return BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
}

/*
==============
BG_GetViewAndGunKickScalars
==============
*/
void BG_GetViewAndGunKickScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outViewKickPitchScale, float *outViewKickYawScale, float *outGunKickPitchScale, float *outGunKickYawScale)
{
  bool v8; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v22; 
  __int64 v23; 
  WeaponAttachment **v24; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  const dvar_t *v26; 
  float viewKickPitchScale; 
  float viewKickYawScale; 
  float gunKickPitchScale; 
  float gunKickYawScale; 
  __int128 v31; 
  __int128 v32; 
  __int128 v33; 
  __int128 v34; 
  __int128 v35; 
  __int128 viewKickPitchScale_low; 
  __int128 v37; 
  __int128 viewKickYawScale_low; 
  __int128 v39; 
  __int128 v40; 
  __int128 v41; 
  __int128 v42; 
  __int128 v43; 
  __int128 v44; 
  __int128 v45; 
  __int128 v46; 
  __int128 v48; 
  __int128 v52; 
  __int128 v57; 
  __int128 v61; 
  __int128 v66; 
  __int128 v70; 
  __int128 v75; 
  __int128 v78; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = isAlternate;
  _XMM6 = LODWORD(FLOAT_1_0);
  _XMM9 = LODWORD(FLOAT_1_0);
  _XMM13 = LODWORD(FLOAT_1_0);
  _XMM10 = LODWORD(FLOAT_1_0);
  _XMM14 = LODWORD(FLOAT_1_0);
  _XMM11 = LODWORD(FLOAT_1_0);
  _XMM15 = LODWORD(FLOAT_1_0);
  _XMM12 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v22 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v23 = WeaponAttachments_Internal;
    v24 = attachments;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v8, *v24, v22);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14542, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v26 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
      if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v26);
      viewKickPitchScale = OverrideAttachmentWhenApplicable->viewKickPitchScale;
      viewKickYawScale = OverrideAttachmentWhenApplicable->viewKickYawScale;
      gunKickPitchScale = OverrideAttachmentWhenApplicable->gunKickPitchScale;
      gunKickYawScale = OverrideAttachmentWhenApplicable->gunKickYawScale;
      if ( v26->current.enabled )
      {
        v31 = _XMM9;
        *(float *)&v31 = *(float *)&_XMM9 * viewKickPitchScale;
        _XMM9 = v31;
        v32 = _XMM10;
        *(float *)&v32 = *(float *)&_XMM10 * viewKickYawScale;
        _XMM10 = v32;
        v33 = _XMM11;
        *(float *)&v33 = *(float *)&_XMM11 * gunKickPitchScale;
        _XMM11 = v33;
        v34 = _XMM12;
        *(float *)&v34 = *(float *)&_XMM12 * gunKickYawScale;
        _XMM12 = v34;
      }
      else
      {
        viewKickPitchScale_low = LODWORD(OverrideAttachmentWhenApplicable->viewKickPitchScale);
        *(float *)&viewKickPitchScale_low = viewKickPitchScale + *(float *)&_XMM6;
        v35 = viewKickPitchScale_low;
        viewKickYawScale_low = LODWORD(OverrideAttachmentWhenApplicable->viewKickYawScale);
        *(float *)&viewKickYawScale_low = viewKickYawScale + *(float *)&_XMM13;
        v37 = viewKickYawScale_low;
        v39 = v35;
        *(float *)&v39 = *(float *)&v35 - 1.0;
        _XMM6 = v39;
        v40 = v37;
        *(float *)&v40 = *(float *)&v37 - 1.0;
        _XMM13 = v40;
        v42 = _XMM14;
        *(float *)&v42 = *(float *)&_XMM14 + gunKickPitchScale;
        v41 = v42;
        v44 = _XMM15;
        *(float *)&v44 = *(float *)&_XMM15 + gunKickYawScale;
        v43 = v44;
        v45 = v41;
        *(float *)&v45 = *(float *)&v41 - 1.0;
        _XMM14 = v45;
        v46 = v43;
        *(float *)&v46 = *(float *)&v43 - 1.0;
        _XMM15 = v46;
      }
      v8 = isAlternate;
      ++v24;
      --v23;
    }
    while ( v23 );
  }
  __asm { vmaxss  xmm2, xmm6, xmm5 }
  v48 = LODWORD(FLOAT_1_0);
  *(float *)&v48 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v48 + 1) = (v48 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v48 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v48;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm7
    vblendvps xmm3, xmm2, xmm8, xmm0
  }
  v52 = LODWORD(FLOAT_1_0);
  *(float *)&v52 = 1.0 - *(float *)&_XMM9;
  *((_QWORD *)&v52 + 1) = (v52 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v52 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM9) & _xmm);
  _XMM1 = v52;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm9, xmm8, xmm2
  }
  *outViewKickPitchScale = *(float *)&_XMM0 * *(float *)&_XMM3;
  __asm { vmaxss  xmm3, xmm13, xmm5 }
  v57 = LODWORD(FLOAT_1_0);
  *(float *)&v57 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v57 + 1) = (v57 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v57 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v57;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm4, xmm3, xmm8, xmm2
  }
  v61 = LODWORD(FLOAT_1_0);
  *(float *)&v61 = 1.0 - *(float *)&_XMM10;
  *((_QWORD *)&v61 + 1) = (v61 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v61 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM10) & _xmm);
  _XMM1 = v61;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm10, xmm8, xmm2
  }
  *outViewKickYawScale = *(float *)&_XMM0 * *(float *)&_XMM4;
  __asm { vmaxss  xmm3, xmm14, xmm5 }
  v66 = LODWORD(FLOAT_1_0);
  *(float *)&v66 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v66 + 1) = (v66 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v66 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v66;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm4, xmm3, xmm8, xmm2
  }
  v70 = LODWORD(FLOAT_1_0);
  *(float *)&v70 = 1.0 - *(float *)&_XMM11;
  *((_QWORD *)&v70 + 1) = (v70 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v70 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM11) & _xmm);
  _XMM1 = v70;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm11, xmm8, xmm2
  }
  *outGunKickPitchScale = *(float *)&_XMM0 * *(float *)&_XMM4;
  __asm { vmaxss  xmm3, xmm15, xmm5 }
  v75 = LODWORD(FLOAT_1_0);
  *(float *)&v75 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v75 + 1) = (v75 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v75 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v75;
  __asm { vcmplesd xmm2, xmm1, xmm7 }
  v78 = LODWORD(FLOAT_1_0);
  *(float *)&v78 = 1.0 - *(float *)&_XMM12;
  *((_QWORD *)&v78 + 1) = (v78 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v78 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM12) & _xmm);
  _XMM1 = v78;
  __asm
  {
    vblendvps xmm4, xmm3, xmm8, xmm2
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm12, xmm8, xmm2
  }
  *outGunKickYawScale = *(float *)&_XMM0 * *(float *)&_XMM4;
}

/*
==============
BG_GetViewKickMaintainFraction
==============
*/
float BG_GetViewKickMaintainFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  __int128 v8; 
  float viewKickMaintainFraction; 
  char v10; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  __int64 v14; 
  WeaponAttachment **v15; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttViewKick *viewKick; 
  __int128 v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = LODWORD(FLOAT_1_0);
  viewKickMaintainFraction = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->viewKickMaintainFraction;
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v13 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v14 = WeaponAttachments_Internal;
    v15 = attachments;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v15, v13);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20809, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !v10 )
      {
        viewKick = OverrideAttachmentWhenApplicable->viewKick;
        if ( viewKick )
        {
          viewKickMaintainFraction = viewKick->viewKickMaintainFraction;
          v10 = 1;
        }
      }
      v18 = v8;
      *(float *)&v18 = *(float *)&v8 * OverrideAttachmentWhenApplicable->viewKickMaintainFractionScale;
      v8 = v18;
      ++v15;
      --v14;
    }
    while ( v14 );
  }
  return viewKickMaintainFraction * *(float *)&v8;
}

/*
==============
BG_GetViewKickMaxAngles
==============
*/
void BG_GetViewKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  vec2_t *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *outMaxAngles = *(vec2_t *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fViewMaxPitch;
  if ( WeaponAttachments_Internal )
  {
    for ( i = (const WeaponAttachment **)attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20859, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = (vec2_t *)BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
      if ( AttachmentViewKick )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return;
    }
    *outMaxAngles = AttachmentViewKick[44];
  }
}

/*
==============
BG_GetViewKickSpeed
==============
*/
void BG_GetViewKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickAccel, float *hipViewKickReturnAccelScale, float *hipViewKickReturnSpeedCurveScale, float *adsViewKickAccel, float *adsViewKickReturnAccelScale, float *adsViewKickReturnSpeedCurveScale)
{
  const Weapon *v11; 
  const WeaponDef *v14; 
  const WeaponCompleteDef *v15; 
  unsigned int v16; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v18; 
  __int128 v20; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  WeaponAttachment **v22; 
  __int64 v23; 
  const BgWeaponMap *v24; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  const dvar_t *v26; 
  bool v27; 
  float viewCenterScale; 
  __int128 v29; 
  __int128 v30; 
  const dvar_t *v32; 
  EffectiveStance EffectiveStance; 
  __int64 v34; 
  WeaponAttachment **v35; 
  __int64 v36; 
  WeaponAttachment *v37; 
  float *p_adsCrouchViewKickFactorScale; 
  __int128 v39; 
  __int128 v40; 
  ContextMountType type; 
  const WeaponDef *v42; 
  float mountTopViewCenterScale; 
  __int128 v45; 
  const WeaponAttachment **v46; 
  AttViewKick *AttachmentViewKick; 
  float *v48; 
  __int128 v50; 
  __int128 v54; 
  __int128 v58; 
  bool v62; 
  unsigned int v64; 
  const WeaponDef *v67; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v11 = r_weapon;
  if ( !hipViewKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15251, ASSERT_TYPE_ASSERT, "(hipViewKickAccel)", (const char *)&queryFormat, "hipViewKickAccel") )
    __debugbreak();
  if ( !adsViewKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15252, ASSERT_TYPE_ASSERT, "(adsViewKickAccel)", (const char *)&queryFormat, "adsViewKickAccel") )
    __debugbreak();
  if ( !hipViewKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15253, ASSERT_TYPE_ASSERT, "(hipViewKickReturnAccelScale)", (const char *)&queryFormat, "hipViewKickReturnAccelScale") )
    __debugbreak();
  if ( !hipViewKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15254, ASSERT_TYPE_ASSERT, "(hipViewKickReturnSpeedCurveScale)", (const char *)&queryFormat, "hipViewKickReturnSpeedCurveScale") )
    __debugbreak();
  if ( !adsViewKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15255, ASSERT_TYPE_ASSERT, "(adsViewKickReturnAccelScale)", (const char *)&queryFormat, "adsViewKickReturnAccelScale") )
    __debugbreak();
  if ( !adsViewKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15256, ASSERT_TYPE_ASSERT, "(adsViewKickReturnSpeedCurveScale)", (const char *)&queryFormat, "adsViewKickReturnSpeedCurveScale") )
    __debugbreak();
  v67 = BG_WeaponDefAtIndex(v11->weaponIdx);
  v14 = v67;
  v15 = BG_WeaponCompleteDef(v11, isAlternate);
  *hipViewKickAccel = v15->fHipViewKickCenterSpeed;
  *adsViewKickAccel = v15->fAdsViewKickCenterSpeed;
  v16 = 0;
  *hipViewKickReturnAccelScale = v67->hipViewKickReturnAccelScale;
  *hipViewKickReturnSpeedCurveScale = v67->hipViewKickReturnSpeedCurveScale;
  *adsViewKickReturnAccelScale = v67->adsViewKickReturnAccelScale;
  *adsViewKickReturnSpeedCurveScale = v67->adsViewKickReturnSpeedCurveScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v11, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v18 = WeaponAttachments_Internal;
  v64 = WeaponAttachments_Internal;
  _XMM10 = LODWORD(FLOAT_1_0);
  v20 = LODWORD(FLOAT_1_0);
  v62 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, v11)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)v18 )
  {
    v22 = attachments;
    v23 = v18;
    v24 = weaponMap;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(v24, ps, v11, isAlternate, *v22, v62);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15275, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( OverrideAttachmentWhenApplicable->viewCenterScale != 0.0 )
      {
        v26 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v26);
        v27 = !v26->current.enabled;
        v11 = r_weapon;
        viewCenterScale = OverrideAttachmentWhenApplicable->viewCenterScale;
        if ( v27 )
        {
          v30 = _XMM10;
          *(float *)&v30 = (float)(*(float *)&_XMM10 + viewCenterScale) - 1.0;
          _XMM10 = v30;
        }
        else
        {
          v29 = v20;
          *(float *)&v29 = *(float *)&v20 * viewCenterScale;
          v20 = v29;
        }
      }
      ++v22;
      --v23;
    }
    while ( v23 );
    v14 = v67;
    LODWORD(v18) = v64;
    v16 = 0;
  }
  _XMM7 = LODWORD(FLOAT_1_0);
  if ( ps->weapCommon.fWeaponPosFrac > 0.5 )
  {
    v32 = DVARBOOL_killswitch_weapon_stance_recenter_scale_enabled;
    if ( !DVARBOOL_killswitch_weapon_stance_recenter_scale_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_stance_recenter_scale_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    if ( v32->current.enabled )
    {
      EffectiveStance = PM_GetEffectiveStance(ps);
      if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
      {
        _XMM7 = LODWORD(v14->adsCrouchViewKickFactor);
      }
      else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
      {
        _XMM7 = LODWORD(v14->adsProneViewKickFactor);
      }
      if ( (_DWORD)v18 )
      {
        v34 = (unsigned int)v18;
        v35 = attachments;
        v36 = EffectiveStance;
        do
        {
          v37 = *v35;
          if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15308, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          p_adsCrouchViewKickFactorScale = &v37->adsStanceScales->adsCrouchViewKickFactorScale;
          if ( p_adsCrouchViewKickFactorScale )
          {
            if ( v36 == 2 )
            {
              v39 = _XMM7;
              *(float *)&v39 = *(float *)&_XMM7 * *p_adsCrouchViewKickFactorScale;
              _XMM7 = v39;
            }
            else if ( v36 == 1 )
            {
              v40 = _XMM7;
              *(float *)&v40 = *(float *)&_XMM7 * p_adsCrouchViewKickFactorScale[2];
              _XMM7 = v40;
            }
          }
          ++v35;
          --v34;
        }
        while ( v34 );
        LODWORD(v18) = v64;
        v16 = 0;
      }
    }
  }
  type = ps->mountState.surface.type;
  v42 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v42 )
    goto LABEL_60;
  if ( type == MOUNT_TYPE_TOP )
  {
    mountTopViewCenterScale = v42->mountTopViewCenterScale;
  }
  else
  {
    if ( (unsigned int)(type - 2) > 1 )
    {
LABEL_60:
      mountTopViewCenterScale = FLOAT_1_0;
      goto LABEL_65;
    }
    mountTopViewCenterScale = v42->mountSideViewCenterScale;
  }
LABEL_65:
  v45 = v20;
  *(float *)&v45 = *(float *)&v20 * (float)((float)(ps->mountState.mountFraction * mountTopViewCenterScale) + (float)(1.0 - ps->mountState.mountFraction));
  _XMM8 = v45;
  if ( (_DWORD)v18 )
  {
    v46 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15332, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *v46, v62);
      if ( AttachmentViewKick )
        break;
      ++v16;
      ++v46;
      if ( v16 >= (unsigned int)v18 )
        goto LABEL_72;
    }
    *hipViewKickAccel = AttachmentViewKick->hipViewKickCenterSpeed;
    v48 = adsViewKickAccel;
    *adsViewKickAccel = AttachmentViewKick->adsViewKickCenterSpeed;
    *hipViewKickReturnAccelScale = AttachmentViewKick->hipViewKickReturnAccelScale;
    *hipViewKickReturnSpeedCurveScale = AttachmentViewKick->hipViewKickReturnSpeedCurveScale;
    *adsViewKickReturnAccelScale = AttachmentViewKick->adsViewKickReturnAccelScale;
    *adsViewKickReturnSpeedCurveScale = AttachmentViewKick->adsViewKickReturnSpeedCurveScale;
  }
  else
  {
LABEL_72:
    v48 = adsViewKickAccel;
  }
  __asm { vmaxss  xmm2, xmm10, xmm11 }
  v50 = LODWORD(FLOAT_1_0);
  *(float *)&v50 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v50 + 1) = (v50 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v50 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v50;
  __asm
  {
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm3, xmm2, xmm9, xmm0
  }
  v54 = LODWORD(FLOAT_1_0);
  *(float *)&v54 = 1.0 - *(float *)&_XMM8;
  *((_QWORD *)&v54 + 1) = (v54 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v54 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM8) & _xmm);
  _XMM1 = v54;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm8, xmm9, xmm2
  }
  v58 = LODWORD(FLOAT_1_0);
  *(float *)&v58 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v58 + 1) = (v58 & (unsigned __int128)(unsigned int)_xmm) >> 64;
  *(double *)&v58 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v58;
  *hipViewKickAccel = (float)(*(float *)&_XMM0 * *(float *)&_XMM3) * *hipViewKickAccel;
  __asm
  {
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm1, xmm7, xmm9, xmm2
  }
  *v48 = (float)(*(float *)&_XMM1 * (float)(*(float *)&_XMM0 * *(float *)&_XMM3)) * *v48;
}

/*
==============
BG_GetViewKickYawAndPitch
==============
*/
void BG_GetViewKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickPitchMin, float *hipViewKickPitchMax, float *hipViewKickYawMin, float *hipViewKickYawMax, float *hipViewKickMagMin, float *adsViewKickPitchMin, float *adsViewKickPitchMax, float *adsViewKickYawMin, float *adsViewKickYawMax, float *adsViewKickMagMin)
{
  const playerState_s *v14; 
  const Weapon *v15; 
  float *v16; 
  const WeaponDef *v17; 
  EffectiveStance EffectiveStance; 
  __int64 v19; 
  float adsCrouchViewKickFactor; 
  unsigned int v21; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v25; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v27; 
  __int64 v28; 
  WeaponAttachment **v29; 
  __int64 v30; 
  WeaponAttachment *v31; 
  AttADSStanceScales *adsStanceScales; 
  const dvar_t *v33; 
  __int128 adsProneViewKickFactorScale_low; 
  __int128 v35; 
  __int128 v36; 
  __int128 v38; 
  __int128 v42; 
  float v46; 
  ContextMountType type; 
  const WeaponDef *v48; 
  float mountTopViewKickScale; 
  const WeaponAttachment **v50; 
  AttViewKick *AttachmentViewKick; 
  float *v52; 
  float *v53; 
  float *v54; 
  float *v55; 
  unsigned int v57; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v14 = ps;
  v15 = r_weapon;
  v16 = adsViewKickPitchMin;
  if ( !hipViewKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15129, ASSERT_TYPE_ASSERT, "(hipViewKickPitchMin)", (const char *)&queryFormat, "hipViewKickPitchMin") )
    __debugbreak();
  if ( !hipViewKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15130, ASSERT_TYPE_ASSERT, "(hipViewKickPitchMax)", (const char *)&queryFormat, "hipViewKickPitchMax") )
    __debugbreak();
  if ( !hipViewKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15131, ASSERT_TYPE_ASSERT, "(hipViewKickYawMin)", (const char *)&queryFormat, "hipViewKickYawMin") )
    __debugbreak();
  if ( !hipViewKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15132, ASSERT_TYPE_ASSERT, "(hipViewKickYawMax)", (const char *)&queryFormat, "hipViewKickYawMax") )
    __debugbreak();
  if ( !hipViewKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15133, ASSERT_TYPE_ASSERT, "(hipViewKickMagMin)", (const char *)&queryFormat, "hipViewKickMagMin") )
    __debugbreak();
  if ( !adsViewKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15134, ASSERT_TYPE_ASSERT, "(adsViewKickPitchMin)", (const char *)&queryFormat, "adsViewKickPitchMin") )
    __debugbreak();
  if ( !adsViewKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15135, ASSERT_TYPE_ASSERT, "(adsViewKickPitchMax)", (const char *)&queryFormat, "adsViewKickPitchMax") )
    __debugbreak();
  if ( !adsViewKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15136, ASSERT_TYPE_ASSERT, "(adsViewKickYawMin)", (const char *)&queryFormat, "adsViewKickYawMin") )
    __debugbreak();
  if ( !adsViewKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15137, ASSERT_TYPE_ASSERT, "(adsViewKickYawMax)", (const char *)&queryFormat, "adsViewKickYawMax") )
    __debugbreak();
  if ( !adsViewKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15138, ASSERT_TYPE_ASSERT, "(adsViewKickMagMin)", (const char *)&queryFormat, "adsViewKickMagMin") )
    __debugbreak();
  v17 = BG_WeaponDefAtIndex(v15->weaponIdx);
  *hipViewKickPitchMin = v17->fHipViewKickPitchMin;
  *hipViewKickPitchMax = v17->fHipViewKickPitchMax;
  *hipViewKickYawMin = v17->fHipViewKickYawMin;
  *hipViewKickYawMax = v17->fHipViewKickYawMax;
  *hipViewKickMagMin = v17->fHipViewKickMagMin;
  *adsViewKickPitchMin = v17->fAdsViewKickPitchMin;
  *adsViewKickPitchMax = v17->fAdsViewKickPitchMax;
  *adsViewKickYawMin = v17->fAdsViewKickYawMin;
  *adsViewKickYawMax = v17->fAdsViewKickYawMax;
  *adsViewKickMagMin = v17->fAdsViewKickMagMin;
  EffectiveStance = PM_GetEffectiveStance(v14);
  v19 = EffectiveStance;
  adsCrouchViewKickFactor = FLOAT_1_0;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    adsCrouchViewKickFactor = v17->adsCrouchViewKickFactor;
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    adsCrouchViewKickFactor = v17->adsProneViewKickFactor;
  }
  v21 = 0;
  _XMM9 = LODWORD(FLOAT_1_0);
  _XMM7 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v15, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v25 = WeaponAttachments_Internal;
  v57 = WeaponAttachments_Internal;
  v27 = v14 && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, v14, v15)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)v25 )
  {
    v28 = v25;
    v29 = attachments;
    v30 = v19;
    while ( 1 )
    {
      v31 = *v29;
      if ( !*v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15172, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsStanceScales = v31->adsStanceScales;
      if ( !adsStanceScales )
        goto LABEL_59;
      if ( v30 == 2 )
        break;
      if ( v30 == 1 )
      {
        v33 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v33);
        adsProneViewKickFactorScale_low = LODWORD(adsStanceScales->adsProneViewKickFactorScale);
        goto LABEL_56;
      }
LABEL_59:
      ++v29;
      if ( !--v28 )
      {
        LODWORD(v25) = v57;
        v21 = 0;
        v14 = ps;
        v15 = r_weapon;
        v16 = adsViewKickPitchMin;
        goto LABEL_61;
      }
    }
    v33 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
    if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    adsProneViewKickFactorScale_low = LODWORD(adsStanceScales->adsCrouchViewKickFactorScale);
LABEL_56:
    if ( v33->current.enabled )
    {
      v35 = _XMM7;
      *(float *)&v35 = *(float *)&_XMM7 * *(float *)&adsProneViewKickFactorScale_low;
      _XMM7 = v35;
    }
    else
    {
      v36 = adsProneViewKickFactorScale_low;
      *(float *)&v36 = (float)(*(float *)&adsProneViewKickFactorScale_low + *(float *)&_XMM9) - 1.0;
      _XMM9 = v36;
    }
    goto LABEL_59;
  }
LABEL_61:
  __asm { vmaxss  xmm2, xmm9, xmm6 }
  v38 = LODWORD(FLOAT_1_0);
  *(float *)&v38 = 1.0 - *(float *)&_XMM2;
  *((_QWORD *)&v38 + 1) = (v38 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v38 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM2) & _xmm);
  _XMM1 = v38;
  __asm
  {
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm8, xmm0
  }
  v42 = LODWORD(FLOAT_1_0);
  *(float *)&v42 = 1.0 - *(float *)&_XMM7;
  *((_QWORD *)&v42 + 1) = (v42 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v42 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM7) & _xmm);
  _XMM1 = v42;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm8, xmm2
  }
  v46 = (float)(*(float *)&_XMM0 * adsCrouchViewKickFactor) * *(float *)&_XMM5;
  if ( v14->mountState.mountFraction > 0.0 )
  {
    type = v14->mountState.surface.type;
    v48 = BG_WeaponDefAtIndex(v15->weaponIdx);
    if ( !v48 )
      goto LABEL_63;
    if ( type == MOUNT_TYPE_TOP )
    {
      mountTopViewKickScale = v48->mountTopViewKickScale;
      goto LABEL_68;
    }
    if ( (unsigned int)(type - 2) <= 1 )
      mountTopViewKickScale = v48->mountSideViewKickScale;
    else
LABEL_63:
      mountTopViewKickScale = FLOAT_1_0;
LABEL_68:
    v46 = (float)((float)(1.0 - v14->mountState.mountFraction) * v46) + (float)(v14->mountState.mountFraction * mountTopViewKickScale);
  }
  if ( (_DWORD)v25 )
  {
    v50 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15215, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, v14, v15, isAlternate, *v50, v27);
      if ( AttachmentViewKick )
        break;
      ++v21;
      ++v50;
      if ( v21 >= (unsigned int)v25 )
        goto LABEL_76;
    }
    v54 = adsViewKickYawMin;
    v53 = adsViewKickYawMax;
    *hipViewKickPitchMin = AttachmentViewKick->hipViewKickPitchMin;
    *hipViewKickPitchMax = AttachmentViewKick->hipViewKickPitchMax;
    *hipViewKickYawMin = AttachmentViewKick->hipViewKickYawMin;
    *hipViewKickYawMax = AttachmentViewKick->hipViewKickYawMax;
    *hipViewKickMagMin = AttachmentViewKick->hipViewKickMagMin;
    v55 = adsViewKickPitchMax;
    *v16 = AttachmentViewKick->adsViewKickPitchMin;
    *adsViewKickPitchMax = AttachmentViewKick->adsViewKickPitchMax;
    *adsViewKickYawMin = AttachmentViewKick->adsViewKickYawMin;
    *adsViewKickYawMax = AttachmentViewKick->adsViewKickYawMax;
    v52 = adsViewKickMagMin;
    *adsViewKickMagMin = AttachmentViewKick->adsViewKickMagMin;
  }
  else
  {
LABEL_76:
    v52 = adsViewKickMagMin;
    v53 = adsViewKickYawMax;
    v54 = adsViewKickYawMin;
    v55 = adsViewKickPitchMax;
  }
  *v16 = v46 * *v16;
  *v55 = v46 * *v55;
  *v54 = v46 * *v54;
  *v53 = v46 * *v53;
  *v52 = v46 * *v52;
}

/*
==============
BG_GetWeaponAdsGunBobSettings
==============
*/
AttADSGunBobSettings *BG_GetWeaponAdsGunBobSettings(const Weapon *r_weapon, bool isAlternate, bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  AttADSGunBobSettings *adsGunBobSettingsMain; 
  unsigned int WeaponAttachments_Internal; 
  int v9; 
  WeaponAttachment **i; 
  WeaponAttachment *v11; 
  AttADSOverlay *adsOverlay; 
  bool v13; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  adsGunBobSettingsMain = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, Menu, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( adsGunBobSettingsMain )
        return adsGunBobSettingsMain;
      v11 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12456, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !ignoreSpreadFromScopes || v11->type )
      {
        if ( !v11 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12374, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
        }
        adsOverlay = v11->adsOverlay;
        if ( adsOverlay && adsOverlay->hybridToggle )
        {
          v13 = !isUsingHybridScope;
          goto LABEL_20;
        }
        if ( v11->shareAmmoWithAlt )
        {
          v13 = !isAlternate;
LABEL_20:
          if ( v13 )
            adsGunBobSettingsMain = v11->adsGunBobSettingsMain;
          else
            adsGunBobSettingsMain = v11->adsGunBobSettings;
          goto LABEL_23;
        }
        adsGunBobSettingsMain = v11->adsGunBobSettings;
      }
LABEL_23:
      if ( ++v9 >= WeaponAttachments_Internal )
        return adsGunBobSettingsMain;
    }
  }
  return 0i64;
}

/*
==============
BG_GetWeaponAdsSettings
==============
*/
AttADSSettings *BG_GetWeaponAdsSettings(const Weapon *r_weapon, bool isAlternate, bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  AttADSSettings *adsSettings; 
  unsigned int WeaponAttachments_Internal; 
  int v9; 
  WeaponAttachment **i; 
  WeaponAttachment *v11; 
  WeaponAttachment *v12; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *hybridScopeAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  adsSettings = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)1, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( adsSettings )
        return adsSettings;
      v11 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12432, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !ignoreSpreadFromScopes || v11->type )
      {
        v12 = *i;
        if ( !*i )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12346, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
        }
        adsOverlay = v12->adsOverlay;
        if ( !adsOverlay || !adsOverlay->hybridToggle )
        {
          if ( v12->shareAmmoWithAlt )
          {
            if ( isAlternate )
              adsSettings = v12->adsSettings;
            else
              adsSettings = v12->adsSettingsMain;
            goto LABEL_24;
          }
LABEL_20:
          adsSettings = v12->adsSettings;
          goto LABEL_24;
        }
        if ( !isUsingHybridScope )
          goto LABEL_20;
        hybridScopeAttachment = adsOverlay->hybridScopeAttachment;
        if ( !hybridScopeAttachment )
          goto LABEL_20;
        adsSettings = hybridScopeAttachment->adsSettings;
      }
LABEL_24:
      if ( ++v9 >= WeaponAttachments_Internal )
        return adsSettings;
    }
  }
  return 0i64;
}

/*
==============
BG_GetWeaponAltReloadAnimsEnabled
==============
*/
_BOOL8 BG_GetWeaponAltReloadAnimsEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  bool v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v4; 
  __int64 v5; 
  WeaponAttachment *v6; 
  AttDlcOverrides *dlcOverrides; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v4 = attachments;
    v5 = WeaponAttachments_Internal;
    do
    {
      v6 = *v4;
      if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23071, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      dlcOverrides = v6->dlcOverrides;
      if ( dlcOverrides && dlcOverrides->useFloatOverride[1] )
        v2 = dlcOverrides->floatOverride[1] != 0.0;
      ++v4;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}

/*
==============
BG_GetWeaponAnglesForShootingDirection
==============
*/
void BG_GetWeaponAnglesForShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t (*anglesCategorized)[30], vec3_t *outAngles)
{
  const vec3_t (*v6)[30]; 
  bool v7; 
  const Weapon *v8; 
  int v10; 
  const WeaponDef *v11; 
  bool aimDownSight; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v14; 
  WeaponAttachment **v15; 
  AttSight *sight; 
  const ADSOverlay *Overlay; 
  float fWeaponPosFrac; 
  const BgWeaponMap *v19; 
  float ShootingDirectionScaleForAngleType; 
  float v21; 
  bool v23; 
  vec3_t weaponMapa; 
  vec3_t r_weapona[2]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = anglesCategorized;
  v7 = isAlternate;
  v8 = r_weapon;
  *(_QWORD *)r_weapona[0].v = r_weapon;
  *(_QWORD *)weaponMapa.v = weaponMap;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20276, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anglesCategorized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20277, ASSERT_TYPE_ASSERT, "(anglesCategorized)", (const char *)&queryFormat, "anglesCategorized") )
    __debugbreak();
  v10 = 0;
  *(_QWORD *)outAngles->v = 0i64;
  outAngles->v[2] = 0.0;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20110, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !v8->weaponIdx )
    goto LABEL_34;
  v23 = ps->weapCommon.fWeaponPosFrac > 0.0;
  v11 = BG_WeaponDefAtIndex(v8->weaponIdx);
  aimDownSight = v11->aimDownSight || v11->turretADSEnabled && v11->weapClass == WEAPCLASS_TURRET;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v8, v7, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v14 = 0;
  if ( WeaponAttachments_Internal )
  {
    v15 = attachments;
    while ( 1 )
    {
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      sight = (*v15)->sight;
      if ( sight )
        break;
      ++v14;
      ++v15;
      if ( v14 >= WeaponAttachments_Internal )
        goto LABEL_25;
    }
    aimDownSight = sight->aimDownSight;
  }
LABEL_25:
  v7 = isAlternate;
  v8 = *(const Weapon **)r_weapona[0].v;
  Overlay = BG_GetOverlay(*(const Weapon **)r_weapona[0].v, isAlternate);
  if ( !Overlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20120, ASSERT_TYPE_ASSERT, "(adsOverlay)", (const char *)&queryFormat, "adsOverlay") )
    __debugbreak();
  if ( v23 && aimDownSight && Overlay->reticle == WEAPOVERLAYRETICLE_NONE )
  {
    fWeaponPosFrac = ps->weapCommon.fWeaponPosFrac;
    if ( fWeaponPosFrac <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20284, ASSERT_TYPE_ASSERT, "(hipFire || adsFraction > 0.0f)", (const char *)&queryFormat, "hipFire || adsFraction > 0.0f") )
      __debugbreak();
  }
  else
  {
LABEL_34:
    fWeaponPosFrac = 0.0;
  }
  v19 = *(const BgWeaponMap **)weaponMapa.v;
  do
  {
    ShootingDirectionScaleForAngleType = BG_GetShootingDirectionScaleForAngleType(ps->perks, v19, ps, v8, v7, fWeaponPosFrac, (const WeaponAngleType)v10);
    *(_QWORD *)&r_weapona[0].y = 0i64;
    r_weapona[0].v[0] = 0.0;
    SlerpAngles(r_weapona, (const vec3_t *)v6, ShootingDirectionScaleForAngleType, &weaponMapa);
    v21 = weaponMapa.v[1] + outAngles->v[1];
    outAngles->v[0] = weaponMapa.v[0] + outAngles->v[0];
    ++v10;
    v6 = (const vec3_t (*)[30])((char *)v6 + 12);
    outAngles->v[2] = weaponMapa.v[2] + outAngles->v[2];
    outAngles->v[1] = v21;
  }
  while ( v10 < 30 );
}

/*
==============
BG_GetWeaponAttachments
==============
*/
unsigned int BG_GetWeaponAttachments(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
}

/*
==============
BG_GetWeaponAttachmentsUsingHighStockPriority
==============
*/
unsigned int BG_GetWeaponAttachmentsUsingHighStockPriority(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_ORDER_STOCK_PRIORITIZED);
}

/*
==============
BG_GetWeaponAttachmentsWithIds
==============
*/
unsigned int BG_GetWeaponAttachmentsWithIds(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
}

/*
==============
BG_GetWeaponAttachments_Internal
==============
*/
__int64 BG_GetWeaponAttachments_Internal(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds, const UnderbarrelMainModeFieldType underbarrelMainModeFieldType, const unsigned int numAttachmentSlots, const AttachmentSlot *attachmentSlots)
{
  const Weapon *v7; 
  const WeaponAttachment **v9; 
  __int64 v11; 
  unsigned int v12; 
  bool v14; 
  const WeaponCompleteDef *v15; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v17; 
  const WeaponAttachment *v18; 
  const WeaponAttachment *v19; 
  AttADSSettings *adsSettingsMain; 
  char v21; 
  bool v22; 
  bool v23; 
  AttADSGunBobSettings *adsGunBobSettingsMain; 
  char v25; 
  const WeaponAttachment *v26; 
  const AttachmentSlot *v27; 
  int v28; 
  const WeaponAttachment *v29; 
  __int64 v30; 
  int v32; 
  __int64 v34; 
  __int64 v35; 
  const WeaponAttachment *v36; 
  const WeaponAttachment *v37; 
  __int64 v38; 
  __int16 v39; 
  char numAttachmentSlotsa; 

  v7 = r_weapon;
  v9 = attachments;
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1346, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  if ( !attachmentIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1347, ASSERT_TYPE_ASSERT, "(attachmentIds)", (const char *)&queryFormat, "attachmentIds") )
    __debugbreak();
  v11 = numAttachmentSlots;
  if ( numAttachmentSlots > 0xE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1348, ASSERT_TYPE_ASSERT, "( numAttachmentSlots ) <= ( ATT_SLOT_COUNT )", "%s <= %s\n\t%u, %u", "numAttachmentSlots", "ATT_SLOT_COUNT", numAttachmentSlots, 14) )
    __debugbreak();
  v12 = 0;
  DebugWipe(v9, 0xE8ui64);
  if ( !v7->weaponIdx )
    return 0i64;
  v14 = isAlternate && BG_HasUnderbarrelAmmo(v7);
  v15 = BG_WeaponCompleteDef(v7, 0);
  v36 = NULL;
  v37 = NULL;
  v39 = 0;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(v7, ATT_SLOT_UNDERBARREL);
  v17 = WeaponPrimaryAttachment;
  if ( !WeaponPrimaryAttachment || (v36 = WeaponPrimaryAttachment, v37 = WeaponPrimaryAttachment, v18 = WeaponPrimaryAttachment, (v19 = BG_GetWeaponPrimaryAttachment(v7, ATT_SLOT_UNDERBARREL)) == NULL) || v19->weapClass == WEAPCLASS_NONE )
  {
    v21 = 0;
    numAttachmentSlotsa = 0;
    goto LABEL_58;
  }
  if ( v14 )
  {
    LOBYTE(v39) = 1;
    HIBYTE(v39) = !v17->shareAmmoWithAlt;
    goto LABEL_60;
  }
  if ( underbarrelMainModeFieldType != 1 )
  {
    switch ( underbarrelMainModeFieldType )
    {
      case 2:
        v23 = v17->adsSettingsScaleMain > 0.0;
        break;
      case 3:
        v23 = v17->adsSpreadScaleMain > 0.0;
        break;
      case 4:
        adsGunBobSettingsMain = v17->adsGunBobSettingsMain;
        v25 = 0;
        v22 = adsGunBobSettingsMain == NULL;
        if ( adsGunBobSettingsMain )
          v25 = 1;
        v21 = v25;
        goto LABEL_33;
      case 5:
        if ( v17->adsGunBobScaleScaleMain > 0.0 )
        {
LABEL_41:
          v21 = 0;
          numAttachmentSlotsa = 0;
LABEL_42:
          if ( v14 && (v7->weaponAttachments[9] || v7->weaponAttachments[11] || v7->weaponAttachments[12] | (unsigned __int16)(v7->visualAttachmentHighAddr << 8) || v7->weaponOthers) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1394, ASSERT_TYPE_ASSERT, "(!isAlternate || ( !scopeAttachmentIndex && !modifierAttachmentIndex && !visualAttachmentIndex && !r_weapon.weaponOthers ))", (const char *)&queryFormat, "!isAlternate || ( !scopeAttachmentIndex && !modifierAttachmentIndex && !visualAttachmentIndex && !r_weapon.weaponOthers )") )
            __debugbreak();
          v26 = v36;
          goto LABEL_50;
        }
        v23 = v17->adsGunBobTiltScaleScaleMain > 0.0;
        break;
      case 6:
        v23 = v17->adsGunBobTiltBulletDirScaleScaleMain > 0.0;
        break;
      default:
        goto LABEL_56;
    }
    if ( v23 )
      goto LABEL_41;
LABEL_56:
    v21 = 0;
    numAttachmentSlotsa = 0;
    v36 = NULL;
    v37 = NULL;
    goto LABEL_58;
  }
  adsSettingsMain = v17->adsSettingsMain;
  v21 = 0;
  v22 = adsSettingsMain == NULL;
  if ( adsSettingsMain )
    v21 = 1;
LABEL_33:
  LOBYTE(v39) = v21;
  numAttachmentSlotsa = v21;
  if ( v22 )
  {
    v36 = NULL;
    v37 = NULL;
  }
LABEL_58:
  if ( !v21 )
    goto LABEL_42;
  v18 = v36;
LABEL_60:
  if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1370, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tInvalid weapon specified when trying to get attachments for '%s' ", "weapAttachment", v15->szInternalName) )
    __debugbreak();
  *v9 = v18;
  *attachmentIds = 10;
  if ( HIBYTE(v39) )
  {
    if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1383, ASSERT_TYPE_ASSERT, "(attachments[attachmentCount])", (const char *)&queryFormat, "attachments[attachmentCount]") )
      __debugbreak();
    return 1i64;
  }
  v21 = v39;
  v12 = 1;
  v26 = v37;
  numAttachmentSlotsa = v39;
  v36 = v37;
LABEL_50:
  if ( (_DWORD)v11 )
  {
    v27 = attachmentSlots;
    v38 = v11;
    while ( 1 )
    {
      v28 = *v27;
      if ( *v27 == ATT_SLOT_UNDERBARREL )
        break;
      if ( v28 < 13 )
        goto LABEL_70;
      if ( v28 != 13 )
      {
        SLODWORD(v34) = *v27;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1440, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid attachment slot %d specified by the attachment ordering\n", v34) )
          __debugbreak();
        goto LABEL_77;
      }
      if ( v15->attachments[13].attachmentCount > 0x10 )
      {
        LODWORD(v35) = 16;
        LODWORD(v34) = v15->attachments[13].attachmentCount;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1421, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", v34, v35) )
          __debugbreak();
      }
      _ESI = v7->weaponOthers;
      if ( v7->weaponOthers )
      {
        do
        {
          v32 = _ESI;
          __asm { tzcnt   ebx, esi }
          if ( _EBX >= v15->attachments[13].attachmentCount )
          {
            LODWORD(v35) = v15->attachments[13].attachmentCount;
            LODWORD(v34) = _EBX;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1427, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          if ( v12 >= 0x1D )
          {
            LODWORD(v35) = 29;
            LODWORD(v34) = v12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1428, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          attachments[v12] = v15->attachments[13].attachments[_EBX];
          if ( _EBX >= 0x10 )
          {
            LODWORD(v35) = 16;
            LODWORD(v34) = _EBX;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          attachmentIds[v12++] = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
          _ESI ^= 1 << _EBX;
        }
        while ( 1 << _EBX != v32 );
        v21 = numAttachmentSlotsa;
        v7 = r_weapon;
        v9 = attachments;
        goto LABEL_75;
      }
LABEL_76:
      v11 = v38;
LABEL_77:
      v26 = v36;
LABEL_78:
      ++v27;
      --v11;
      attachmentSlots = v27;
      v38 = v11;
      if ( !v11 )
        return v12;
    }
    if ( !v26 || v21 )
      goto LABEL_78;
LABEL_70:
    v29 = BG_GetWeaponPrimaryAttachment(v7, (const AttachmentSlot)v28);
    if ( v29 )
    {
      if ( v12 >= 0x1D )
      {
        LODWORD(v35) = 29;
        LODWORD(v34) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1411, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v34, v35) )
          __debugbreak();
      }
      v30 = v12;
      v9[v12++] = v29;
      attachmentIds[v30] = truncate_cast<unsigned char,enum AttachmentSlot>((AttachmentSlot)v28);
LABEL_75:
      v27 = attachmentSlots;
      goto LABEL_76;
    }
    goto LABEL_76;
  }
  return v12;
}

/*
==============
BG_GetWeaponBurstCount
==============
*/
__int64 BG_GetWeaponBurstCount(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  int burstCount; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  AttAmmoGeneral *ammogeneral; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  burstCount = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->burstCount;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6974, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammogeneral = (*v7)->ammogeneral;
      if ( ammogeneral )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    burstCount = ammogeneral->burstCount;
  }
LABEL_10:
  if ( BG_GetWeaponFireType(r_weapon, isAlternate) != WEAPON_FIRETYPE_BURST && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6984, ASSERT_TYPE_ASSERT, "(fireType == WEAPON_FIRETYPE_BURST)", (const char *)&queryFormat, "fireType == WEAPON_FIRETYPE_BURST") )
    __debugbreak();
  if ( burstCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6985, ASSERT_TYPE_ASSERT, "(burstCount > 0)", (const char *)&queryFormat, "burstCount > 0") )
    __debugbreak();
  if ( burstCount > 31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6986, ASSERT_TYPE_ASSERT, "(burstCount <= ( ( 1 << 5 ) - 1 ))", (const char *)&queryFormat, "burstCount <= PLAYER_WEAPONSHOTCOUNT_MAX") )
    __debugbreak();
  return (unsigned int)burstCount;
}

/*
==============
BG_GetWeaponClass
==============
*/
__int64 BG_GetWeaponClass(const Weapon *r_weapon, bool isAlternate)
{
  bool v3; 
  int v4; 
  weapClass_t weapClass; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  __int64 result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = isAlternate && BG_HasUnderbarrelAmmo(r_weapon);
  v4 = 0;
  weapClass = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapClass;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v3, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)weapClass;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16452, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (unsigned int)(*i)->weapClass;
    if ( (_DWORD)result != 14 )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)weapClass;
  }
  return result;
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/
weapClass_t BG_GetWeaponClassForAnimCondition(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2102, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_IsRemoteTurretActiveFlags(&es->lerp.eFlags) )
    return 8;
  else
    return BG_GetWeaponClass(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/
weapClass_t BG_GetWeaponClassForAnimCondition(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2166, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsRemoteTurretActiveFlags(&ps->eFlags) )
    return 8;
  else
    return BG_GetWeaponClass(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponDismembermentEnabled
==============
*/
_BOOL8 BG_GetWeaponDismembermentEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  const WeaponDef *v4; 
  bool v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  __int64 v8; 
  WeaponAttachment *v9; 
  AttDlcOverrides *dlcOverrides; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23033, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v5 = v4->dlcFloat[0] != 0.0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    v8 = WeaponAttachments_Internal;
    do
    {
      v9 = *v7;
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23045, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      dlcOverrides = v9->dlcOverrides;
      if ( dlcOverrides && dlcOverrides->useFloatOverride[0] )
        v5 = dlcOverrides->floatOverride[0] != 0.0;
      ++v7;
      --v8;
    }
    while ( v8 );
  }
  return v5;
}

/*
==============
BG_GetWeaponEffect
==============
*/
FxCombinedDef BG_GetWeaponEffect(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  unsigned int numBindings; 
  const WeaponDef *v6; 
  WeaponVFXPackage *vfxPackage; 
  __int64 v9; 
  unsigned int i; 
  __int64 v11; 
  VFXOverride *v12; 
  WeaponVFXPackage *overridesAlt; 

  numBindings = 0;
  if ( (offset < 0 || (unsigned __int64)offset > 0xE0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2401, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof(WeaponVFXPackageDefs) )", "offset not in [0, sizeof(WeaponVFXPackageDefs)]\n\t%i not in [%i, %i]", offset, 0i64, 224) )
    __debugbreak();
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  vfxPackage = v6->vfxPackage;
  if ( !vfxPackage )
    return 0i64;
  v9 = *(__int64 *)((char *)&vfxPackage->vfx->viewFlashEffect.particleSystemDef + offset);
  if ( BG_GetAllWeaponAttachmentsCount(r_weapon) )
  {
    for ( i = 0; i < v6->numVfxOverrides; ++i )
    {
      v11 = i;
      v12 = &v6->vfxOverrides[v11];
      if ( v12->numBindings > numBindings && BG_WeaponHasOverride(r_weapon, v12->bindings, v12->numBindings) && (isAlternate && (overridesAlt = v6->vfxOverrides[v11].overridesAlt) != NULL || (overridesAlt = v6->vfxOverrides[v11].overrides) != NULL) )
      {
        numBindings = v12->numBindings;
        v9 = *(__int64 *)((char *)&overridesAlt->vfx->viewFlashEffect.particleSystemDef + offset);
      }
    }
  }
  return (FxCombinedDef)v9;
}

/*
==============
BG_GetWeaponExplicitHideTags
==============
*/
void BG_GetWeaponExplicitHideTags(const Weapon *r_weapon, const bool isAlternate, const bool isViewModel, const unsigned __int64 hideTagBufferSize, scr_string_t *outHideTagBuffer, unsigned __int64 *outHideTagCount)
{
  unsigned __int64 *v7; 
  unsigned __int64 v10; 
  __int64 v11; 
  unsigned __int64 v12; 
  const WeaponCompleteDef *v13; 
  unsigned __int64 i; 
  int v15; 
  int v16; 
  int v17; 
  int v18; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int64 v20; 
  unsigned __int64 v21; 
  WeaponAttachment *v22; 
  unsigned int numHideTagsNonViewModel; 
  scr_string_t *v24; 
  scr_string_t *p_last; 
  int *v26; 
  scr_string_t v27; 
  int v28; 
  char *v29; 
  __int64 v30; 
  unsigned __int64 v31; 
  scr_string_t *v32; 
  unsigned __int64 v33; 
  scr_string_t *p_first; 
  char *v35; 
  scr_string_t v36; 
  scr_string_t v37; 
  char *v38; 
  __int64 v39; 
  unsigned __int64 v40; 
  scr_string_t *v41; 
  __int64 v42; 
  scr_string_t *p_Src; 
  char *v44; 
  scr_string_t v45; 
  scr_string_t v46; 
  char *v47; 
  __int64 v48; 
  unsigned __int64 v49; 
  scr_string_t *v50; 
  __int64 v51; 
  int v52; 
  scr_string_t *v53; 
  __int64 v55; 
  unsigned __int64 v56; 
  scr_string_t last; 
  int v58[31]; 
  scr_string_t first; 
  char v60[588]; 
  scr_string_t Src; 
  char v62[1164]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v7 = outHideTagCount;
  if ( !outHideTagBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5811, ASSERT_TYPE_ASSERT, "(outHideTagBuffer)", (const char *)&queryFormat, "outHideTagBuffer") )
    __debugbreak();
  if ( hideTagBufferSize < 0x142 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5812, ASSERT_TYPE_ASSERT, "((((1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) * (5) * 2) + 32) <= hideTagBufferSize)", (const char *)&queryFormat, "MAX_WEAP_ATTACHMENT_HIDE_TAGS <= hideTagBufferSize") )
    __debugbreak();
  v10 = 0i64;
  v55 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  for ( i = 0i64; i < 0x20; i += 4i64 )
  {
    v15 = v13->hideTags[v11];
    if ( !v15 )
      break;
    v58[v11 - 1] = v15;
    v16 = v13->hideTags[v11 + 1];
    if ( !v16 )
    {
      ++v11;
      goto LABEL_17;
    }
    v58[v11] = v16;
    v17 = v13->hideTags[v11 + 2];
    if ( !v17 )
    {
      v11 += 2i64;
      goto LABEL_17;
    }
    v58[v11 + 1] = v17;
    v18 = v13->hideTags[v11 + 3];
    if ( !v18 )
    {
      v11 += 3i64;
LABEL_17:
      v55 = v11;
      break;
    }
    v58[v11 + 2] = v18;
    v11 += 4i64;
    v55 = v11;
  }
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  v20 = 0i64;
  v56 = AllWeaponAttachmentsWithIds;
  v21 = 0i64;
  if ( AllWeaponAttachmentsWithIds )
  {
    do
    {
      v22 = attachments[v20];
      if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5840, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      memcpy_0(&v60[4 * v21 - 4], v22->showTags, 4i64 * v22->numShowTags);
      if ( v22->numShowTags > 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5843, ASSERT_TYPE_ASSERT, "(attachment->numShowTags <= (5))", (const char *)&queryFormat, "attachment->numShowTags <= MAX_ATTACH_SHOWHIDE_TAGS") )
        __debugbreak();
      v21 += v22->numShowTags;
      if ( v21 > 0x91 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5845, ASSERT_TYPE_ASSERT, "(attachShowTagCount <= ( sizeof( *array_counter( attachShowTags ) ) + 0 ))", (const char *)&queryFormat, "attachShowTagCount <= ARRAY_COUNT( attachShowTags )") )
        __debugbreak();
      memcpy_0(&v62[4 * v12 - 4], v22->hideTags, 4i64 * v22->numHideTags);
      if ( v22->numHideTags > 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5848, ASSERT_TYPE_ASSERT, "(attachment->numHideTags <= (5))", (const char *)&queryFormat, "attachment->numHideTags <= MAX_ATTACH_SHOWHIDE_TAGS") )
        __debugbreak();
      v12 += v22->numHideTags;
      if ( v12 > 0x122 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5850, ASSERT_TYPE_ASSERT, "(attachHideTagCount <= ( sizeof( *array_counter( attachHideTags ) ) + 0 ))", (const char *)&queryFormat, "attachHideTagCount <= ARRAY_COUNT( attachHideTags )") )
        __debugbreak();
      if ( !isViewModel )
      {
        numHideTagsNonViewModel = v22->numHideTagsNonViewModel;
        if ( numHideTagsNonViewModel )
        {
          memcpy_0(&v62[4 * v12 - 4], v22->hideTagsNonViewModel, 4i64 * numHideTagsNonViewModel);
          v12 += v22->numHideTagsNonViewModel;
        }
      }
      ++v20;
    }
    while ( v20 < v56 );
    v7 = outHideTagCount;
    v11 = v55;
  }
  v24 = (scr_string_t *)&v58[v11 - 1];
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&last, v24, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &last != v24 )
  {
    p_last = &last;
    v26 = v58;
    if ( v58 != (int *)v24 )
    {
      v27 = last;
      while ( 1 )
      {
        v28 = *v26;
        v29 = (char *)(v26 + 1);
        if ( v27 == *v26 )
          break;
        p_last = (scr_string_t *)v26++;
        v27 = v28;
        if ( v29 == (char *)v24 )
          goto LABEL_52;
      }
      v30 = 0i64;
      v31 = (unsigned __int64)((char *)v24 - v29 + 3) >> 2;
      if ( v29 > (char *)v24 )
        v31 = 0i64;
      if ( v31 )
      {
        do
        {
          if ( *p_last != *(_DWORD *)v29 )
            *++p_last = *(scr_string_t *)v29;
          v29 += 4;
          ++v30;
        }
        while ( v30 != v31 );
      }
      v24 = p_last + 1;
    }
  }
LABEL_52:
  v32 = (scr_string_t *)&v60[4 * v21 - 4];
  v33 = v24 - &last;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&first, v32, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &first != v32 )
  {
    p_first = &first;
    v35 = v60;
    if ( v60 != (char *)v32 )
    {
      v36 = first;
      while ( 1 )
      {
        v37 = *(_DWORD *)v35;
        v38 = v35 + 4;
        if ( v36 == *(_DWORD *)v35 )
          break;
        p_first = (scr_string_t *)v35;
        v35 += 4;
        v36 = v37;
        if ( v38 == (char *)v32 )
          goto LABEL_65;
      }
      v39 = 0i64;
      v40 = (unsigned __int64)((char *)v32 - v38 + 3) >> 2;
      if ( v38 > (char *)v32 )
        v40 = 0i64;
      if ( v40 )
      {
        do
        {
          if ( *p_first != *(_DWORD *)v38 )
            *++p_first = *(scr_string_t *)v38;
          v38 += 4;
          ++v39;
        }
        while ( v39 != v40 );
      }
      v32 = p_first + 1;
    }
  }
LABEL_65:
  v41 = (scr_string_t *)&v62[4 * v12 - 4];
  v42 = v32 - &first;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&Src, v41, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &Src != v41 )
  {
    p_Src = &Src;
    v44 = v62;
    if ( v62 != (char *)v41 )
    {
      v45 = Src;
      while ( 1 )
      {
        v46 = *(_DWORD *)v44;
        v47 = v44 + 4;
        if ( v45 == *(_DWORD *)v44 )
          break;
        p_Src = (scr_string_t *)v44;
        v44 += 4;
        v45 = v46;
        if ( v47 == (char *)v41 )
          goto LABEL_78;
      }
      v48 = 0i64;
      v49 = (unsigned __int64)((char *)v41 - v47 + 3) >> 2;
      if ( v47 > (char *)v41 )
        v49 = 0i64;
      if ( v49 )
      {
        do
        {
          if ( *p_Src != *(_DWORD *)v47 )
            *++p_Src = *(scr_string_t *)v47;
          v47 += 4;
          ++v48;
        }
        while ( v48 != v49 );
      }
      v41 = p_Src + 1;
    }
  }
LABEL_78:
  *v7 = 0i64;
  v50 = (scr_string_t *)&v60[4 * v42 - 4];
  v51 = v41 - &Src;
  if ( v33 )
  {
    do
    {
      v52 = v58[v10 - 1];
      v53 = &first;
      if ( &first == v50 )
        goto LABEL_84;
      while ( *v53 != v52 )
      {
        if ( ++v53 == v50 )
          goto LABEL_84;
      }
      if ( v53 == v50 )
LABEL_84:
        outHideTagBuffer[(*v7)++] = v52;
      ++v10;
    }
    while ( v10 < v33 );
    v10 = *v7;
  }
  memcpy_0(&outHideTagBuffer[v10], &Src, 4 * v51);
  *v7 += v51;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(outHideTagBuffer, &outHideTagBuffer[*v7], (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  *v7 = std::unique<enum scr_string_t *,std::equal_to<void>>(outHideTagBuffer, &outHideTagBuffer[*v7], (std::equal_to<void>)isViewModel) - outHideTagBuffer;
}

/*
==============
BG_GetWeaponFieldTime
==============
*/
unsigned __int16 BG_GetWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, offset, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetWeaponFieldTimeWithDependentAnimation
==============
*/
__int64 BG_GetWeaponFieldTimeWithDependentAnimation(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset, const weapAnimFiles_t dependentAnimType)
{
  int meleeComboSeqIdx; 
  const WeaponDef *v11; 
  const WeaponDef *v12; 
  WeaponAnimPackage *szXAnims; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  unsigned __int16 v16; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 timer; 
  __int64 v25; 

  meleeComboSeqIdx = 0;
  if ( (offset < 0 || (unsigned __int64)offset > 0x172) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2098, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof(WeaponAnimPackageStateTimers) )", "offset not in [0, sizeof(WeaponAnimPackageStateTimers)]\n\t%i not in [%i, %i]", offset, 0i64, 370) )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = v11;
  szXAnims = v11->szXAnims;
  if ( !szXAnims )
    return 0i64;
  if ( isDualWielding )
  {
    szXAnimsLeftHanded = v11->szXAnimsLeftHanded;
    if ( szXAnimsLeftHanded )
      return *(unsigned __int16 *)((char *)&szXAnimsLeftHanded->timers->iDetonateDelay + offset);
  }
  v16 = *(unsigned __int16 *)((char *)&szXAnims->timers->iDetonateDelay + offset);
  IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  if ( IsMeleeComboOverride )
  {
    if ( ps )
      meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
    AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
    v20 = AnimOverrideIdxForMeleeComboSeq;
    if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
    {
      if ( AnimOverrideIdxForMeleeComboSeq >= v12->numAnimOverrides )
      {
        LODWORD(v25) = v12->numAnimOverrides;
        LODWORD(timer) = AnimOverrideIdxForMeleeComboSeq;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1852, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", timer, v25) )
          __debugbreak();
      }
      v21 = (__int64)&v12->animOverrides[v20];
      v22 = *(_QWORD *)(v21 + 16);
      if ( isAlternate && (v23 = *(_QWORD *)(v21 + 24)) != 0 )
      {
        if ( *(_WORD *)(offset + *(_QWORD *)(v23 + 16)) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || *(_QWORD *)(*(_QWORD *)(v23 + 8) + 8i64 * (int)dependentAnimType)) )
          return *(unsigned __int16 *)(offset + *(_QWORD *)(v23 + 16));
      }
      else if ( v22 && *(_WORD *)(offset + *(_QWORD *)(v22 + 16)) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8i64 * (int)dependentAnimType)) )
      {
        return *(unsigned __int16 *)(offset + *(_QWORD *)(v22 + 16));
      }
    }
  }
  else if ( AllWeaponAttachmentsCount )
  {
    return BG_GetRegularWeaponFieldTime(ps, r_weapon, isAlternate, v12, offset, v16, dependentAnimType);
  }
  return v16;
}

/*
==============
BG_GetWeaponFireEventBoneIndex
==============
*/
__int64 BG_GetWeaponFireEventBoneIndex(unsigned int param)
{
  unsigned int v1; 

  v1 = (unsigned __int16)param - 1;
  if ( v1 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned int>(unsigned int)", "signed", (unsigned __int16)param - 1i64, "unsigned", v1) )
    __debugbreak();
  return v1;
}

/*
==============
BG_GetWeaponFireType
==============
*/
__int64 BG_GetWeaponFireType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapFireType_t fireType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoGeneral *ammogeneral; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fireType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fireType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)fireType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammogeneral = (*i)->ammogeneral;
    if ( ammogeneral )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)fireType;
  }
  return (unsigned int)ammogeneral->fireType;
}

/*
==============
BG_GetWeaponFireWeaponID
==============
*/
Weapon *BG_GetWeaponFireWeaponID(Weapon *result, unsigned int param)
{
  *result = NULL_WEAPON;
  result->weaponIdx = truncate_cast<unsigned short,unsigned int>(HIWORD(param));
  return result;
}

/*
==============
BG_GetWeaponFlashTagname
==============
*/
TagPair *BG_GetWeaponFlashTagname(TagPair *result, const Weapon *r_weapon, bool isAlternate, int chamberIndex)
{
  const dvar_t *v8; 
  scr_string_t tag_flash_2; 

  if ( (unsigned int)chamberIndex > 0x1F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6385, ASSERT_TYPE_ASSERT, "(0 <= chamberIndex && chamberIndex <= (( ( 1 << 5 ) - 1 )))", (const char *)&queryFormat, "0 <= chamberIndex && chamberIndex <= PLAYER_WEAPONCHAMBER_MAX") )
    __debugbreak();
  v8 = DVARBOOL_useTagFlashSilenced;
  if ( !DVARBOOL_useTagFlashSilenced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "useTagFlashSilenced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( !v8->current.enabled || !BG_IsSilenced(r_weapon, isAlternate) )
  {
    if ( chamberIndex )
    {
      if ( isAlternate )
      {
        result->m_primaryTagName = scr_const.tag_flash_alt_2;
        result->m_fallbackTagName = scr_const.tag_flash_2;
        return result;
      }
      tag_flash_2 = scr_const.tag_flash_2;
    }
    else
    {
      if ( isAlternate )
      {
        result->m_primaryTagName = scr_const.tag_flash_alt;
        result->m_fallbackTagName = scr_const.tag_flash;
        return result;
      }
      tag_flash_2 = scr_const.tag_flash;
    }
    goto LABEL_23;
  }
  if ( chamberIndex )
  {
    if ( isAlternate )
    {
      result->m_primaryTagName = scr_const.tag_flash_alt_2;
      result->m_fallbackTagName = scr_const.tag_flash_2_silenced;
      return result;
    }
    tag_flash_2 = scr_const.tag_flash_2_silenced;
LABEL_23:
    result->m_fallbackTagName = 0;
    result->m_primaryTagName = tag_flash_2;
    return result;
  }
  if ( !isAlternate )
  {
    tag_flash_2 = scr_const.tag_flash_silenced;
    goto LABEL_23;
  }
  result->m_primaryTagName = scr_const.tag_flash_alt;
  result->m_fallbackTagName = scr_const.tag_flash_silenced;
  return result;
}

/*
==============
BG_GetWeaponInspectEnabled
==============
*/
char BG_GetWeaponInspectEnabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v4 && v4->enableWeaponInspect )
  {
    v5 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( !WeaponAttachments_Internal )
      return 1;
    for ( i = attachments; !(*i)->disableWeaponInspect; ++i )
    {
      if ( ++v5 >= WeaponAttachments_Internal )
        return 1;
    }
  }
  return 0;
}

/*
==============
BG_GetWeaponInspectTime
==============
*/
__int64 BG_GetWeaponInspectTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 360i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetWeaponLaserSettings
==============
*/
void BG_GetWeaponLaserSettings(const Weapon *r_weapon, const bool isAlternate, LaserSettings *outLaserSettings)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  AttLaser *laser; 
  const WeaponDef *v9; 
  __int16 v10; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17948, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      laser = (*v7)->laser;
      if ( laser )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    *(double *)&outLaserSettings->forceLaserOn = *(double *)&laser->laserSettings.forceLaserOn;
    v10 = *(_WORD *)&laser->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  else
  {
LABEL_8:
    v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    *(double *)&outLaserSettings->forceLaserOn = *(double *)&v9->laserSettings.forceLaserOn;
    v10 = *(_WORD *)&v9->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  *(_WORD *)&outLaserSettings->remotePlayerNVGHipLaserEnabled = v10;
}

/*
==============
BG_GetWeaponMeleeAnimProperties
==============
*/
WeaponAnimPackage *BG_GetWeaponMeleeAnimProperties(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool isUsingAlternateMelee, bool *outIsRandomized, MeleeAnimType *outAnimType, unsigned __int8 *outAnimSets)
{
  unsigned int v8; 
  const WeaponDef *v12; 
  WeaponAnimPackage *result; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  bool v15; 
  WeaponAnimPackage *v16; 
  MeleeAnimType v17; 
  WeaponAnimPackage *v18; 
  unsigned __int8 v19; 
  WeaponAnimPackage *v20; 
  int meleeAnimAltCount; 
  bool altMeleeRandomizeAnims; 
  WeaponAnimPackage *szXAnims; 
  MeleeAnimType meleeAnimAltType; 
  WeaponAnimPackage *v25; 
  unsigned __int8 meleeAnimAltSet; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  int meleeComboSeqIdx; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 
  char v34; 
  MeleeAnimType v35; 
  unsigned __int8 v36; 
  unsigned __int64 v37; 
  __int64 v38; 
  AnimOverride *animOverrides; 
  unsigned int numBindings; 
  AnimOverride *v41; 
  WeaponAnimPackage *v42; 
  bool meleeRandomizeAnims; 
  MeleeAnimType meleeAnimPrimaryType; 
  unsigned __int8 meleeAnimPrimarySet; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  __int64 v49; 

  v8 = 0;
  if ( !outIsRandomized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2140, ASSERT_TYPE_ASSERT, "( outIsRandomized ) != ( nullptr )", "%s != %s\n\t%p, %p", "outIsRandomized", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAnimType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2141, ASSERT_TYPE_ASSERT, "( outAnimType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAnimType", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAnimSets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2142, ASSERT_TYPE_ASSERT, "( outAnimSets ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAnimSets", "nullptr", NULL, NULL) )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  result = v12->szXAnims;
  if ( !result )
  {
    *outIsRandomized = 0;
    *outAnimType = COUNT|DODGE;
    *outAnimSets = 0;
    return result;
  }
  if ( !isDualWielding || (szXAnimsLeftHanded = v12->szXAnimsLeftHanded) == NULL )
  {
    if ( isUsingAlternateMelee )
    {
      meleeAnimAltCount = result->meleeAnimAltCount;
      altMeleeRandomizeAnims = result->altMeleeRandomizeAnims;
    }
    else
    {
      meleeAnimAltCount = result->meleeAnimPrimaryCount;
      altMeleeRandomizeAnims = result->meleeRandomizeAnims;
    }
    *outIsRandomized = altMeleeRandomizeAnims;
    szXAnims = v12->szXAnims;
    if ( isUsingAlternateMelee )
      meleeAnimAltType = szXAnims->meleeAnimAltType;
    else
      meleeAnimAltType = szXAnims->meleeAnimPrimaryType;
    *outAnimType = meleeAnimAltType;
    v25 = v12->szXAnims;
    if ( isUsingAlternateMelee )
      meleeAnimAltSet = v25->meleeAnimAltSet;
    else
      meleeAnimAltSet = v25->meleeAnimPrimarySet;
    *outAnimSets = meleeAnimAltSet;
    IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
    AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
    if ( IsMeleeComboOverride )
    {
      meleeComboSeqIdx = 0;
      if ( ps )
        meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
      AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
      v31 = AnimOverrideIdxForMeleeComboSeq;
      if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
      {
        if ( AnimOverrideIdxForMeleeComboSeq >= v12->numAnimOverrides )
        {
          LODWORD(v47) = v12->numAnimOverrides;
          LODWORD(v46) = AnimOverrideIdxForMeleeComboSeq;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2193, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v46, v47) )
            __debugbreak();
        }
        v32 = (__int64)&v12->animOverrides[v31];
        if ( isAlternate )
          v33 = *(_QWORD *)(v32 + 24);
        else
          v33 = *(_QWORD *)(v32 + 16);
        if ( v33 )
        {
          if ( isUsingAlternateMelee )
          {
            meleeAnimAltCount = *(_DWORD *)(v33 + 40);
            v34 = *(_BYTE *)(v33 + 45);
          }
          else
          {
            meleeAnimAltCount = *(_DWORD *)(v33 + 28);
            v34 = *(_BYTE *)(v33 + 33);
          }
          *outIsRandomized = v34;
          if ( isUsingAlternateMelee )
            v35 = *(_DWORD *)(v33 + 36);
          else
            v35 = *(_DWORD *)(v33 + 24);
          *outAnimType = v35;
          if ( isUsingAlternateMelee )
            v36 = *(_BYTE *)(v33 + 44);
          else
            v36 = *(_BYTE *)(v33 + 32);
          *outAnimSets = v36;
        }
      }
    }
    else if ( !AllWeaponAttachmentsCount )
    {
      return (WeaponAnimPackage *)(unsigned int)meleeAnimAltCount;
    }
    v37 = 0i64;
    if ( v12->numAnimOverrides )
    {
      v38 = 0i64;
      do
      {
        animOverrides = v12->animOverrides;
        numBindings = animOverrides[v38].numBindings;
        if ( numBindings > v8 && BG_WeaponHasOverride(r_weapon, animOverrides[v38].bindings, numBindings) )
        {
          v41 = v12->animOverrides;
          v42 = isAlternate ? v41[v38].overridesAlt : v41[v38].overrides;
          if ( v42 )
          {
            if ( isUsingAlternateMelee )
            {
              meleeAnimAltCount = v42->meleeAnimAltCount;
              meleeRandomizeAnims = v42->altMeleeRandomizeAnims;
            }
            else
            {
              meleeAnimAltCount = v42->meleeAnimPrimaryCount;
              meleeRandomizeAnims = v42->meleeRandomizeAnims;
            }
            *outIsRandomized = meleeRandomizeAnims;
            if ( isUsingAlternateMelee )
              meleeAnimPrimaryType = v42->meleeAnimAltType;
            else
              meleeAnimPrimaryType = v42->meleeAnimPrimaryType;
            *outAnimType = meleeAnimPrimaryType;
            if ( isUsingAlternateMelee )
              meleeAnimPrimarySet = v42->meleeAnimAltSet;
            else
              meleeAnimPrimarySet = v42->meleeAnimPrimarySet;
            *outAnimSets = meleeAnimPrimarySet;
            v8 = animOverrides[v38].numBindings;
          }
        }
        ++v37;
        ++v38;
      }
      while ( v37 < v12->numAnimOverrides );
    }
    if ( meleeAnimAltCount > 4 )
    {
      LODWORD(v49) = 4;
      LODWORD(v48) = meleeAnimAltCount;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2230, ASSERT_TYPE_ASSERT, "( meleeAnimCount ) <= ( (4) )", "%s <= %s\n\t%i, %i", "meleeAnimCount", "MAX_RANDOM_MELEE_ANIM_PACKAGES", v48, v49) )
        __debugbreak();
    }
    return (WeaponAnimPackage *)(unsigned int)meleeAnimAltCount;
  }
  if ( isUsingAlternateMelee )
    v15 = szXAnimsLeftHanded->altMeleeRandomizeAnims;
  else
    v15 = szXAnimsLeftHanded->meleeRandomizeAnims;
  *outIsRandomized = v15;
  v16 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    v17 = v16->meleeAnimAltType;
  else
    v17 = v16->meleeAnimPrimaryType;
  *outAnimType = v17;
  v18 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    v19 = v18->meleeAnimAltSet;
  else
    v19 = v18->meleeAnimPrimarySet;
  *outAnimSets = v19;
  v20 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    return (WeaponAnimPackage *)(unsigned int)v20->meleeAnimAltCount;
  else
    return (WeaponAnimPackage *)(unsigned int)v20->meleeAnimPrimaryCount;
}

/*
==============
BG_GetWeaponOffhandClass
==============
*/
__int64 BG_GetWeaponOffhandClass(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 

  weaponIdx = r_weapon->weaponIdx;
  if ( weaponIdx )
    return (unsigned int)BG_WeaponDefAtIndex(weaponIdx)->offhandClass;
  else
    return 0i64;
}

/*
==============
BG_GetWeaponOffhandSlot
==============
*/
OffhandSlot BG_GetWeaponOffhandSlot(const playerState_s *ps, const BgWeaponMap *weaponMap, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *EquippedWeaponState; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20318, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20319, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( r_weapon->weaponIdx && (EquippedWeaponState = BG_GetEquippedWeaponState(weaponMap, ps, r_weapon)) != NULL )
    return EquippedWeaponState->offhandSlot;
  else
    return 0;
}

/*
==============
BG_GetWeaponOtherAttachment
==============
*/
WeaponAttachment *BG_GetWeaponOtherAttachment(const Weapon *r_weapon, const unsigned int otherIndex)
{
  __int64 v2; 
  const WeaponCompleteDef *v4; 
  WeaponAttachment *v5; 
  __int64 v7; 
  __int64 v8; 

  v2 = otherIndex;
  if ( otherIndex >= 0x10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 818, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", otherIndex, 16) )
    __debugbreak();
  if ( (truncate_cast<unsigned short,int>(1 << v2) & r_weapon->weaponOthers) == 0 )
    return 0i64;
  v4 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( (unsigned int)v2 >= v4->attachments[13].attachmentCount )
  {
    LODWORD(v8) = v4->attachments[13].attachmentCount;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 824, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v5 = v4->attachments[13].attachments[v2];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 826, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v4->szInternalName) )
    __debugbreak();
  return v5;
}

/*
==============
BG_GetWeaponPrimaryAttachment
==============
*/
const WeaponAttachment *BG_GetWeaponPrimaryAttachment(const Weapon *r_weapon, const AttachmentSlot attachment)
{
  __int64 v2; 
  bool v4; 
  __int64 v5; 
  unsigned __int16 v6; 
  const WeaponCompleteDef *v7; 
  __int64 v8; 
  const char **p_szInternalName; 
  __int64 v10; 
  __int64 v12; 
  __int64 v13; 

  v2 = attachment;
  v4 = attachment < ATT_SLOT_OTHER;
  if ( (unsigned int)attachment >= ATT_SLOT_OTHER )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 799, ASSERT_TYPE_ASSERT, "(unsigned)( attachment ) < (unsigned)( ATT_SLOT_PRIMARY_COUNT )", "attachment doesn't index ATT_SLOT_PRIMARY_COUNT\n\t%i not in [0, %i)", attachment, 13) )
      __debugbreak();
    v4 = (int)v2 < 13;
  }
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  if ( (_DWORD)v2 == 12 )
  {
    v5 = 12i64;
    v6 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
  }
  else
  {
    v5 = v2;
    v6 = r_weapon->weaponAttachments[v2];
  }
  if ( !v6 )
    return 0i64;
  v7 = BG_WeaponCompleteDef(r_weapon, 0);
  v8 = v5;
  p_szInternalName = &v7->szInternalName;
  if ( v6 > v7->attachments[v8].attachmentCount )
  {
    LODWORD(v13) = 1;
    LODWORD(v12) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", v12, v13, v7->attachments[v8].attachmentCount) )
      __debugbreak();
  }
  v10 = *(_QWORD *)&p_szInternalName[v8 * 2 + 6][8 * v6 - 8];
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", *p_szInternalName) )
    __debugbreak();
  return (const WeaponAttachment *)v10;
}

/*
==============
BG_GetWeaponSfxPackageSound
==============
*/
SndAliasList *BG_GetWeaponSfxPackageSound(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  SndAliasLookup v2; 

  v2.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage, offset).name;
  if ( v2.name && *v2.name )
    return SND_TryFindAlias(v2.name);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSfxPackageSoundLookup
==============
*/
SndAliasLookup BG_GetWeaponSfxPackageSoundLookup(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  if ( (offset < 0 || (unsigned __int64)offset > 0x328) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2286, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof( WeaponSFXPackageSounds ) )", "offset not in [0, sizeof( WeaponSFXPackageSounds )]\n\t%i not in [%i, %i]", offset, 0i64, 808) )
    __debugbreak();
  if ( sfxPackage )
    return *(SndAliasLookup *)((char *)&sfxPackage->sounds->name + offset);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSfxPackageSoundWithFallback
==============
*/
SndAliasList *BG_GetWeaponSfxPackageSoundWithFallback(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  __int64 v4; 
  SndAliasLookup v5; 
  const char *name; 
  SndAliasList *result; 
  const dvar_t *v8; 
  SndAliasLookup v9; 

  v4 = 0i64;
  v5.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage, offset).name;
  name = v5.name;
  if ( !v5.name || !*v5.name )
    return 0i64;
  result = SND_TryFindAlias(v5.name);
  if ( !result )
  {
    v8 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.enabled )
    {
      v9.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage->transientFallbackPackage, offset).name;
      if ( v9.name )
      {
        if ( *v9.name )
          return SND_TryFindAlias(v9.name);
      }
      return (SndAliasList *)v4;
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
BG_GetWeaponSound
==============
*/
SndAliasList *BG_GetWeaponSound(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 
  SndAliasLookup v5; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  v5.name = BG_GetWeaponSfxPackageSoundLookup(SfxPackage, offset).name;
  if ( v5.name && *v5.name )
    return SND_TryFindAlias(v5.name);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSoundLookup
==============
*/
SndAliasLookup BG_GetWeaponSoundLookup(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundLookup(SfxPackage, offset);
}

/*
==============
BG_GetWeaponSoundWithFallback
==============
*/
const SndAliasList *BG_GetWeaponSoundWithFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, offset);
}

/*
==============
BG_GetWeaponSoundWithWeaponSfxPackageFallback
==============
*/
const SndAliasList *BG_GetWeaponSoundWithWeaponSfxPackageFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 
  const SndAliasList *result; 
  const WeaponDef *v7; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  result = BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, offset);
  if ( !result )
  {
    v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2380, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return BG_GetWeaponSfxPackageSoundWithFallback(v7->sfxPackage, offset);
  }
  return result;
}

/*
==============
BG_GetWeaponStreamedModels
==============
*/
__int64 BG_GetWeaponStreamedModels(const Weapon *weapon, const XModel *(*outList)[32], const bool viewModel)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v7; 
  const XModel *gunXModelRightHand; 
  unsigned int AllWeaponAttachmentsWithIds; 
  const WeaponAttachment **v10; 
  unsigned __int8 *v11; 
  __int64 v12; 
  const WeaponAttachment *v13; 
  unsigned __int8 v14; 
  unsigned __int8 v15; 
  int v16; 
  const XModel *AttachmentModel; 
  __int64 v19; 
  __int64 v20; 
  unsigned int outCurListPos[4]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22484, ASSERT_TYPE_ASSERT, "(outList)", (const char *)&queryFormat, "outList") )
    __debugbreak();
  weaponIdx = weapon->weaponIdx;
  outCurListPos[0] = 0;
  if ( !weaponIdx )
    return 0i64;
  v7 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22494, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v7->hasAnyTransientModels )
    return 0i64;
  if ( *(_WORD *)&v7->transientBaseViewFlags )
  {
    if ( viewModel )
    {
      BG_AddStreamedWeaponModelToList(v7->gunXModel, outList, outCurListPos);
      BG_AddStreamedWeaponModelToList(v7->gunXModelLeftHand, outList, outCurListPos);
      gunXModelRightHand = v7->gunXModelRightHand;
    }
    else
    {
      BG_AddStreamedWeaponModelToList(v7->worldModel, outList, outCurListPos);
      BG_AddStreamedWeaponModelToList(v7->worldXModelLeftHand, outList, outCurListPos);
      gunXModelRightHand = v7->worldXModelRightHand;
    }
    BG_AddStreamedWeaponModelToList(gunXModelRightHand, outList, outCurListPos);
  }
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( AllWeaponAttachmentsWithIds )
  {
    v10 = (const WeaponAttachment **)attachments;
    v11 = attachmentIds;
    v12 = AllWeaponAttachmentsWithIds;
    do
    {
      v13 = *v10;
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22523, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v14 = *v11;
      if ( *v11 >= 0x1Du )
      {
        LODWORD(v20) = 29;
        LODWORD(v19) = v14;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22526, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      v15 = weapon->attachmentVariationIndices[v14];
      if ( v15 >= 0x10u )
      {
        LODWORD(v20) = 16;
        LODWORD(v19) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22529, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      if ( v15 < (int)v13->numModelVariations )
      {
        v16 = v13->transientViewFlags | v13->transientWorldFlags;
        if ( _bittest(&v16, v15) )
        {
          AttachmentModel = BG_GetAttachmentModel(*v10, v15, viewModel);
          BG_AddStreamedWeaponModelToList(AttachmentModel, outList, outCurListPos);
        }
      }
      ++v11;
      ++v10;
      --v12;
    }
    while ( v12 );
  }
  return outCurListPos[0];
}

/*
==============
BG_GetWeaponThermalPlayerFadeDistStartAndEnd
==============
*/
__int64 BG_GetWeaponThermalPlayerFadeDistStartAndEnd(const Weapon *r_weapon, const bool isAlternate, vec2_t *outStartAndEnd)
{
  unsigned __int8 v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  __int64 v7; 
  WeaponAttachment *v8; 
  AttDlcOverrides *dlcOverrides; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  *outStartAndEnd = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    v7 = WeaponAttachments_Internal;
    do
    {
      v8 = *v6;
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23101, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      dlcOverrides = v8->dlcOverrides;
      if ( dlcOverrides && dlcOverrides->useFloatOverride[2] )
      {
        v4 = 1;
        outStartAndEnd->v[0] = dlcOverrides->floatOverride[2];
        outStartAndEnd->v[1] = v8->dlcOverrides->floatOverride[3];
      }
      ++v6;
      --v7;
    }
    while ( v7 );
  }
  return v4;
}

/*
==============
BG_GetWeaponType
==============
*/
__int64 BG_GetWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapType_t weapType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  __int64 result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  weapType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)weapType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16425, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (unsigned int)(*i)->weaponType;
    if ( (_DWORD)result )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)weapType;
  }
  return result;
}

/*
==============
BG_GungHoSprintLoopTime
==============
*/
__int64 BG_GungHoSprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 178i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_GUNGHO_SPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_HasADSAltSwitchAnims
==============
*/
bool BG_HasADSAltSwitchAnims(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  const PlayerWeaponAnimArrays *v4; 
  bool v5; 
  bool result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19150, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19153, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v5 = v4 && v4->normalAnimArray[327] && v4->normalAnimArray[330];
  result = v4 != (const PlayerWeaponAnimArrays *)-4976i64 && v4->altAnimArray[327] && v4->altAnimArray[330];
  if ( v5 )
  {
    if ( result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19161, ASSERT_TYPE_ASSERT, "(!( mainPackageHasAltRaiseDropAnims && altPackageHasAltRaiseDropAnims ))", "%s\n\tYou can only place the ADS alt switch animations on either the main or the alt animation package. Not both at the same time.", "!( mainPackageHasAltRaiseDropAnims && altPackageHasAltRaiseDropAnims )") )
      __debugbreak();
    return 1;
  }
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_HasDefaultViewModel
==============
*/
bool BG_HasDefaultViewModel(const Weapon *r_weapon)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->defaultViewModel != NULL;
}

/*
==============
BG_HasDefaultWorldModel
==============
*/
bool BG_HasDefaultWorldModel(const Weapon *r_weapon)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->defaultWorldModel != NULL;
}

/*
==============
BG_HasDualFOV
==============
*/
_BOOL8 BG_HasDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment *v10; 
  const WeaponAttachment *v11; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  WeaponAttachment **i; 
  WeaponAttachment *v15; 
  AttSight *sight; 
  WeaponAttachment *outDataAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2948, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v8 = 0;
  outDataAttachment = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = NULL;
  v11 = NULL;
  if ( ps )
  {
    if ( weaponMap )
    {
      EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
      if ( EquippedWeaponStateConst )
      {
        if ( EquippedWeaponStateConst->hybridScope )
        {
          HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(r_weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
          v10 = outDataAttachment;
          v11 = HybridScopeEnablerAttachment;
        }
      }
    }
  }
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useDualFOV;
  for ( i = attachments; ; ++i )
  {
    v15 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2964, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v11 == v15 )
    {
      if ( v10 )
        v15 = v10;
    }
    sight = v15->sight;
    if ( sight )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useDualFOV;
  }
  return sight->useDualFOV;
}

/*
==============
BG_HasDualFOVEquipped
==============
*/
bool BG_HasDualFOVEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  bool v5; 
  int HasUnderbarrelWeapon; 
  bool outIsAlternate; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3019, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3020, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(weaponMap, ps, &outIsAlternate);
  if ( !ps )
    goto LABEL_13;
  v5 = outIsAlternate;
  if ( !outIsAlternate )
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
  if ( !BG_PWF_UseAlternateAsOffhand(ps) )
  {
LABEL_13:
    v5 = outIsAlternate;
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
  }
  HasUnderbarrelWeapon = BG_HasUnderbarrelWeapon(ViewmodelOrOffhandADSSupportWeapon);
  v5 = outIsAlternate;
  if ( HasUnderbarrelWeapon )
    v5 = 0;
  outIsAlternate = v5;
  return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
}

/*
==============
BG_HasForegrip
==============
*/
_BOOL8 BG_HasForegrip(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v2; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v2 = WeaponPrimaryAttachment;
  return WeaponPrimaryAttachment && !BG_IsUnderbarrelGl(WeaponPrimaryAttachment) && !BG_IsUnderbarrelShotgun(v2);
}

/*
==============
BG_HasHoldBreathAbility
==============
*/
__int64 BG_HasHoldBreathAbility(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  bool v4; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned __int8 canHoldBreath; 
  unsigned int v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  AttHoldBreath *holdBreath; 
  bool v13; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2822, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2823, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActive(ps) || BG_IsUsingOffhandGestureWeapon(ps) )
    return 0i64;
  v13 = BG_UsingAlternate(ps);
  v4 = v13;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  canHoldBreath = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->canHoldBreath;
  v7 = 0;
  if ( BG_HasPerk(&ps->perks, 0x17u) )
  {
    canHoldBreath = 1;
  }
  else
  {
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v13, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    v9 = 0;
    if ( WeaponAttachments_Internal )
    {
      v10 = attachments;
      while ( 1 )
      {
        if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2854, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        holdBreath = (*v10)->holdBreath;
        if ( holdBreath )
          break;
        ++v9;
        ++v10;
        if ( v9 >= WeaponAttachments_Internal )
          goto LABEL_20;
      }
      canHoldBreath = holdBreath->canHoldBreath;
LABEL_20:
      v4 = v13;
    }
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND|WEAPON_LADDER_AIM) )
    return canHoldBreath;
  if ( canHoldBreath && BG_UsingSniperScope(weaponMap, ps) && BG_GetWeaponClass(CurrentWeaponForPlayer, v4) != WEAPCLASS_ITEM )
    return 1;
  return v7;
}

/*
==============
BG_HasLadderHand
==============
*/
bool BG_HasLadderHand(const playerState_s *ps)
{
  const dvar_t *v2; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20943, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v2 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  return v2->current.enabled && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x32u);
}

/*
==============
BG_HasPredictedProjectileAttachment
==============
*/
bool BG_HasPredictedProjectileAttachment(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  bool result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  result = 0;
  if ( WeaponPrimaryAttachment )
  {
    projectile = WeaponPrimaryAttachment->projectile;
    if ( projectile )
    {
      if ( projectile->isPredictedProjectile )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_HasThermalScope
==============
*/
_BOOL8 BG_HasThermalScope(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  bool thermalScope; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  thermalScope = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->thermalScope;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return thermalScope;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15545, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    adsOverlay = (*i)->adsOverlay;
    if ( adsOverlay )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return thermalScope;
  }
  return adsOverlay->thermalScope;
}

/*
==============
BG_HasUnderbarrelAmmo
==============
*/
bool BG_HasUnderbarrelAmmo(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  bool v3; 
  const Weapon *v4; 
  const WeaponAttachment *v5; 
  bool result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v3 = WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE;
  v4 = r_weapon;
  if ( !v3 )
    v4 = &NULL_WEAPON;
  result = 0;
  if ( r_weapon->weaponIdx )
  {
    v5 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
    if ( v5 )
    {
      if ( v5->weapClass != WEAPCLASS_NONE )
        return 1;
    }
    if ( v4->weaponIdx )
      return 1;
  }
  return result;
}

/*
==============
BG_HasUnderbarrelAttachment
==============
*/
bool BG_HasUnderbarrelAttachment(const Weapon *r_weapon, bool isAlternate, const scr_string_t attachmentName)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  if ( !attachmentName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1828, ASSERT_TYPE_ASSERT, "(attachmentName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "attachmentName != NULL_SCR_STRING") )
    __debugbreak();
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LOBYTE(WeaponPrimaryAttachment) = WeaponPrimaryAttachment->internalName == attachmentName;
  return (char)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelGL
==============
*/
int BG_HasUnderbarrelGL(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LODWORD(WeaponPrimaryAttachment) = BG_IsUnderbarrelGl(WeaponPrimaryAttachment);
  return (int)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelShotgun
==============
*/
int BG_HasUnderbarrelShotgun(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LODWORD(WeaponPrimaryAttachment) = BG_IsUnderbarrelShotgun(WeaponPrimaryAttachment);
  return (int)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelWeapon
==============
*/
_BOOL8 BG_HasUnderbarrelWeapon(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v2; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v2 = WeaponPrimaryAttachment;
  return WeaponPrimaryAttachment && (BG_IsUnderbarrelGl(WeaponPrimaryAttachment) || BG_IsUnderbarrelShotgun(v2));
}

/*
==============
BG_HasVRLegendaryScope
==============
*/
char BG_HasVRLegendaryScope(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; (*i)->type || (*i)->internalName != scr_const.vrlscope; ++i )
  {
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_HasVRScope
==============
*/
char BG_HasVRScope(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  scr_string_t internalName; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( (*i)->type == ATTACHMENT_SCOPE )
    {
      internalName = (*i)->internalName;
      if ( internalName == scr_const.vrscope || internalName == scr_const.vrlscope )
        break;
    }
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_HasVariableZoom
==============
*/
bool BG_HasVariableZoom(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  bool v7; 

  v7 = BG_UsingAlternate(ps);
  return BG_ADSZoomCount(weaponMap, ps, r_weapon, v7) > 1;
}

/*
==============
BG_HeatSmokeEffect
==============
*/
void BG_HeatSmokeEffect(const Weapon *r_weapon, bool isAlternate, bool isViewmodel, FxCombinedDef *muzzleSmoke, FxCombinedDef *barrelSmoke, FxCombinedDef *ejectionPortSmoke)
{
  FxCombinedDef *v8; 
  __int64 v9; 

  if ( isViewmodel )
  {
    if ( muzzleSmoke )
      muzzleSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 112i64).particleSystemDef;
    if ( barrelSmoke )
      barrelSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 128i64).particleSystemDef;
    v8 = ejectionPortSmoke;
    if ( ejectionPortSmoke )
    {
      v9 = 144i64;
LABEL_14:
      v8->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, v9).particleSystemDef;
    }
  }
  else
  {
    if ( muzzleSmoke )
      muzzleSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 120i64).particleSystemDef;
    if ( barrelSmoke )
      barrelSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 136i64).particleSystemDef;
    v8 = ejectionPortSmoke;
    if ( ejectionPortSmoke )
    {
      v9 = 152i64;
      goto LABEL_14;
    }
  }
}

/*
==============
BG_HideBone
==============
*/
unsigned __int8 BG_HideBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return BG_HideBoneByModelRange(bone, obj, partBits, startModel, -1);
}

/*
==============
BG_HideBoneByModelRange
==============
*/
__int64 BG_HideBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  unsigned __int8 childIndex[24]; 
  unsigned __int8 index; 

  if ( startModel < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5037, ASSERT_TYPE_ASSERT, "( startModel ) >= ( 0 )", "%s >= %s\n\t%i, %i", "startModel", "0", startModel, 0i64) )
    __debugbreak();
  index = -2;
  if ( DObjGetBoneIndexFromModelRange(obj, bone, startModel, lastModelInclusive, &index) )
  {
    bitarray_base<bitarray<256>>::setBit(partBits, index);
    for ( childIndex[0] = -2; DObjGetNextChildBoneIndex(obj, index, childIndex); partBits->array[(unsigned __int64)childIndex[0] >> 5] |= 0x80000000 >> (childIndex[0] & 0x1F) )
      ;
  }
  return index;
}

/*
==============
BG_HideIronSights
==============
*/
void BG_HideIronSights(DObj *obj, int startModel, int lastModelInclusive, bool hideRail)
{
  DObjPartBits *p_hidePartBits; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5134, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  p_hidePartBits = &obj->hidePartBits;
  if ( hideRail )
    BG_HideBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, p_hidePartBits, startModel, lastModelInclusive);
  else
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, p_hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_HideSlingBonesForDObj
==============
*/
void BG_HideSlingBonesForDObj(DObj *obj, bool hideBones)
{
  const scr_string_t **v4; 
  __int64 v5; 
  DObjPartBits *p_hidePartBits; 
  scr_string_t v7; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( DObjHasProceduralBones(obj) )
  {
    v4 = SLING_HIDE_BONES;
    v5 = 6i64;
    do
    {
      p_hidePartBits = &obj->hidePartBits;
      v7 = **v4;
      if ( hideBones )
        BG_HideBoneByModelRange(v7, obj, p_hidePartBits, 0, -1);
      else
        BG_ShowBoneByModelRange(v7, obj, p_hidePartBits, 0, -1);
      ++v4;
      --v5;
    }
    while ( v5 );
  }
}

/*
==============
BG_HideSniperScene
==============
*/
void BG_HideSniperScene(const Weapon *r_weapon, DObj *obj)
{
  const scr_string_t **v4; 
  unsigned int i; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5543, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  if ( BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, &obj->hidePartBits, 0, -1) <= 0xFDu )
  {
    v4 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
    for ( i = 0; i < 0xD; ++i )
      BG_ToggleBoneVisibilityInAllModels(**v4++, obj, &obj->hidePartBits, 1);
  }
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, 0, -1);
}

/*
==============
BG_HideWarningIcons
==============
*/
_BOOL8 BG_HideWarningIcons(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hideWarningIcons;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16261, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hideWarningIcons;
  }
  return ui->hideWarningIcons;
}

/*
==============
BG_HipSpreadFireAdd
==============
*/
float BG_HipSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  __int128 v2; 
  int v5; 
  float fHipSpreadFireAdd; 
  unsigned int WeaponAttachments_Internal; 
  __int128 v8; 
  WeaponAttachment **v9; 
  __int64 v10; 
  float hipSpreadScale; 
  __int128 v12; 
  WeaponAttachment **i; 
  AttHipSpread *hipSpread; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  __int128 v18; 

  v5 = 0;
  fHipSpreadFireAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fHipSpreadFireAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v8 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v18 = v2;
    v9 = attachments;
    v10 = WeaponAttachments_Internal;
    do
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14103, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      hipSpreadScale = (*v9)->hipSpreadScale;
      if ( hipSpreadScale != 0.0 )
      {
        v12 = v8;
        *(float *)&v12 = *(float *)&v8 * hipSpreadScale;
        v8 = v12;
      }
      ++v9;
      --v10;
    }
    while ( v10 );
  }
  if ( !WeaponAttachments_Internal )
    return *(float *)&v8 * fHipSpreadFireAdd;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14110, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    hipSpread = (*i)->hipSpread;
    if ( hipSpread )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return *(float *)&v8 * fHipSpreadFireAdd;
  }
  return *(float *)&v8 * hipSpread->hipSpreadFireAdd;
}

/*
==============
BG_HoldBreathMaxTime
==============
*/
__int64 BG_HoldBreathMaxTime(const playerState_s *const ps)
{
  const dvar_t *v2; 
  bitarray<64> *p_perks; 
  int v4; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2881, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v2 = DCONST_DVARFLT_player_breath_hold_time;
  if ( !DCONST_DVARFLT_player_breath_hold_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_hold_time") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  p_perks = &ps->perks;
  v4 = (int)(float)(v2->current.value * 1000.0);
  if ( BG_HasPerk(&ps->perks, 4u) )
  {
    v5 = DVARFLT_perk_extraBreath;
    if ( !DVARFLT_perk_extraBreath && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_extraBreath") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    v4 += (int)(float)(v5->current.value * 1000.0);
  }
  if ( BG_HasPerk(p_perks, 0x12u) )
  {
    v6 = DVARFLT_perk_improvedExtraBreath;
    if ( !DVARFLT_perk_improvedExtraBreath && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_improvedExtraBreath") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    v4 += (int)(float)(v6->current.value * 1000.0);
  }
  result = 0i64;
  if ( v4 > 0 )
    return (unsigned int)v4;
  return result;
}

/*
==============
BG_HoldingBreath
==============
*/
_BOOL8 BG_HoldingBreath(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2872, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return ps->holdBreathTimer > 0;
}

/*
==============
BG_HudIcon
==============
*/
GfxImage *BG_HudIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  GfxImage **p_hudIcon; 
  GfxImage *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hudIcon;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16180, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    p_hudIcon = &(*i)->ui->hudIcon;
    if ( p_hudIcon )
    {
      result = *p_hudIcon;
      if ( *p_hudIcon )
        break;
    }
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hudIcon;
  }
  return result;
}

/*
==============
BG_HybridToggleIsAllowed
==============
*/
bool BG_HybridToggleIsAllowed(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *handler)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7570, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7571, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7572, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  return (ps->weapState[0].weaponState & 0xFFFFFFEF) == 0 || PM_Weapon_IsInInterruptibleState(weaponMap, ps, WEAPON_HAND_DEFAULT, handler);
}

/*
==============
BG_IdleCrouchFactor
==============
*/
float BG_IdleCrouchFactor(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float fIdleCrouchFactor; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttIdleSettings *idleSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fIdleCrouchFactor = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fIdleCrouchFactor;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return fIdleCrouchFactor;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12183, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    idleSettings = (*i)->idleSettings;
    if ( idleSettings )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return fIdleCrouchFactor;
  }
  return idleSettings->idleCrouchFactor;
}

/*
==============
BG_IdleProneFactor
==============
*/
float BG_IdleProneFactor(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float fIdleProneFactor; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttIdleSettings *idleSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fIdleProneFactor = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fIdleProneFactor;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return fIdleProneFactor;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12208, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    idleSettings = (*i)->idleSettings;
    if ( idleSettings )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return fIdleProneFactor;
  }
  return idleSettings->idleProneFactor;
}

/*
==============
BG_InADS
==============
*/
bool BG_InADS(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3586, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return 1.0 == ps->weapCommon.fWeaponPosFrac;
}

/*
==============
BG_InheritsPerks
==============
*/
_BOOL8 BG_InheritsPerks(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool inheritsPerks; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  inheritsPerks = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->inheritsPerks;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return inheritsPerks;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8063, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return inheritsPerks;
  }
  return general->inheritsPerks;
}

/*
==============
BG_InitClientWeapons
==============
*/
void BG_InitClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20428, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !cs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20429, ASSERT_TYPE_ASSERT, "(cs)", (const char *)&queryFormat, "cs") )
    __debugbreak();
  *(_QWORD *)&cs->serverDobjHeldWeapon.m_mapEntryId = 0i64;
}

/*
==============
BG_InitPlayerWeapons
==============
*/
void BG_InitPlayerWeapons(playerState_s *ps)
{
  ActionSlotParam *actionSlotParam; 
  int v3; 
  unsigned int v4; 
  unsigned int *p_eventParm; 
  unsigned int v6; 
  unsigned int *v7; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  actionSlotParam = ps->actionSlotParam;
  *(_QWORD *)&ps->weapCommon.weaponHandle.m_mapEntryId = 0i64;
  v3 = 0;
  ps->weapCommon.offHandHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->weapCommon.lastWeaponHandle.m_mapEntryId = 0i64;
  ps->weapCommon.weaponAnimArrayHandle.m_mapEntryId = 0;
  ps->weapCommon.forcedViewAnimWeaponHandle.m_mapEntryId = 0;
  ps->weapCommon.forcedViewAnimOriginalWeaponHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->throwbackWeaponHandle.m_mapEntryId = 0i64;
  *(_QWORD *)&ps->serverDobjTurretWeapon.m_mapEntryId = 0i64;
  ps->highPriorityWeapInfo.weaponHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->weaponsEquipped[0].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[2].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[4].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[6].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[8].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[10].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[12].m_mapEntryId = 0i64;
  ps->weaponsEquipped[14].m_mapEntryId = 0;
  do
  {
    if ( BG_ActionSlotIsWeaponType(ps, v3) )
      actionSlotParam->specifyWeapon.weaponHandle.m_mapEntryId = 0;
    ++v3;
    ++actionSlotParam;
  }
  while ( v3 < 7 );
  v4 = 0;
  p_eventParm = &ps->unpredictableEvents[0].eventParm;
  do
  {
    if ( BG_IsWeaponEvent(*(p_eventParm - 1)) )
      *p_eventParm = 0;
    ++v4;
    p_eventParm += 2;
  }
  while ( v4 < 4 );
  v6 = 0;
  v7 = &ps->pe.events[0].eventParm;
  do
  {
    if ( BG_IsWeaponEvent(*(v7 - 1)) )
      *v7 = 0;
    ++v6;
    v7 += 2;
  }
  while ( v6 < 4 );
}

/*
==============
BG_InterruptTimeCommon
==============
*/
__int64 BG_InterruptTimeCommon(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  __int128 v10; 
  __int64 WeaponAttachments_Internal; 
  const BgWeaponMap *v12; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v14; 
  __int64 v16; 
  WeaponAttachment **v17; 
  const WeaponAttachment *v18; 
  const BgWeaponMap *v19; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  __int128 v21; 
  __int128 v23; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10267, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, offset, NUM_WEAP_ANIMS);
  v10 = LODWORD(FLOAT_1_0);
  WeaponAttachments_Internal = (unsigned int)BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = pmoveHandler->GetWeaponMap(pmoveHandler);
  v14 = ps && v12 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v12, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  _XMM1 = LODWORD(FLOAT_1_0);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v16 = WeaponAttachments_Internal;
    v17 = attachments;
    do
    {
      v18 = *v17;
      v19 = pmoveHandler->GetWeaponMap(pmoveHandler);
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(v19, ps, r_weapon, isAlternate, v18, v14);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10280, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v21 = v10;
      ++v17;
      *(float *)&v21 = (float)(*(float *)&v10 + OverrideAttachmentWhenApplicable->reloadTimersScale) - 1.0;
      v10 = v21;
      _XMM1 = v21;
      --v16;
    }
    while ( v16 );
  }
  __asm { vmaxss  xmm3, xmm1, xmm0 }
  v23 = LODWORD(FLOAT_1_0);
  *(float *)&v23 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v23 + 1) = (v23 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v23 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM0 = v23;
  __asm
  {
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 1 }
  return (unsigned int)(int)*(float *)&_XMM4;
}

/*
==============
BG_IsADSFireOnly
==============
*/
_BOOL8 BG_IsADSFireOnly(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool adsFireOnly; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsFireOnly = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsFireOnly;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsFireOnly;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7434, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsFireOnly;
  }
  return sight->adsFire;
}

/*
==============
BG_IsAdsVisionSetActive
==============
*/
bool BG_IsAdsVisionSetActive(const BgHandler *handler, const playerState_s *ps, const Weapon *weapon, bool isAlternate, BgAdsVisionSetInfo *outVisionSetInfo)
{
  const BgWeaponMap *v9; 
  BgAdsVisionSetInfo *AdsVisionSetInfo; 
  double v11; 
  double WeaponOrOffhandAdsFrac; 
  BgAdsVisionSetInfo result; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15487, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15488, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = handler->GetWeaponMap(handler);
  AdsVisionSetInfo = BG_GetAdsVisionSetInfo(&result, v9, ps, weapon, isAlternate);
  v11 = *(double *)&AdsVisionSetInfo->visionSetBlendOutTimeMs;
  *(_OWORD *)&outVisionSetInfo->visionSetName = *(_OWORD *)&AdsVisionSetInfo->visionSetName;
  *(double *)&outVisionSetInfo->visionSetBlendOutTimeMs = v11;
  if ( BG_PlayerUsesNVGHalfADS(ps, handler) || !outVisionSetInfo->applyVisionSet )
    return 0;
  WeaponOrOffhandAdsFrac = BG_GetWeaponOrOffhandAdsFrac(v9, ps);
  return *(float *)&WeaponOrOffhandAdsFrac >= outVisionSetInfo->visionSetADSFraction;
}

/*
==============
BG_IsAimDownSight
==============
*/
_BOOL8 BG_IsAimDownSight(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = v4->aimDownSight || v4->turretADSEnabled && v4->weapClass == WEAPCLASS_TURRET;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v5;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return v5;
  }
  return sight->aimDownSight;
}

/*
==============
BG_IsAnimInWeaponPackages
==============
*/
char BG_IsAnimInWeaponPackages(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const int meleeComboSeqIdx, const weapAnimFiles_t animType)
{
  const WeaponDef *v9; 
  WeaponAnimPackage *szXAnims; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  __int64 v13; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  unsigned int v16; 
  AnimOverride *animOverrides; 
  char v18; 
  __int64 v19; 
  WeaponAnimPackage *overridesAlt; 
  bool v21; 
  WeaponAnimPackage *overrides; 
  unsigned int numBindings; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  __int64 v30; 

  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2456, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnims = v9->szXAnims;
  if ( !szXAnims )
    return 0;
  if ( isDualWielding )
  {
    szXAnimsLeftHanded = v9->szXAnimsLeftHanded;
    if ( szXAnimsLeftHanded )
      return szXAnimsLeftHanded->anims[animType] != NULL;
  }
  v13 = animType;
  if ( szXAnims->anims[v13] )
    return 1;
  IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  if ( !IsMeleeComboOverride )
  {
    if ( AllWeaponAttachmentsCount )
    {
      v16 = 0;
      if ( v9->numAnimOverrides )
      {
        while ( 1 )
        {
          animOverrides = v9->animOverrides;
          v18 = 0;
          v19 = v16;
          if ( isAlternate )
          {
            overridesAlt = animOverrides[v19].overridesAlt;
            if ( overridesAlt && overridesAlt->anims[v13] )
              v18 = 1;
            v21 = v18 == 0;
          }
          else
          {
            overrides = animOverrides[v19].overrides;
            if ( !overrides )
              goto LABEL_22;
            v21 = overrides->anims[v13] == NULL;
          }
          if ( !v21 )
          {
            numBindings = animOverrides[v19].numBindings;
            if ( numBindings )
            {
              if ( BG_WeaponHasOverride(r_weapon, animOverrides[v19].bindings, numBindings) )
                return 1;
            }
          }
LABEL_22:
          if ( ++v16 >= v9->numAnimOverrides )
            return 0;
        }
      }
    }
    return 0;
  }
  AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
  v25 = AnimOverrideIdxForMeleeComboSeq;
  if ( AnimOverrideIdxForMeleeComboSeq < 0 )
    return 0;
  if ( AnimOverrideIdxForMeleeComboSeq >= v9->numAnimOverrides )
  {
    LODWORD(v30) = AnimOverrideIdxForMeleeComboSeq;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2488, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v30, v9->numAnimOverrides) )
      __debugbreak();
  }
  v26 = (__int64)&v9->animOverrides[v25];
  v27 = *(_QWORD *)(v26 + 16);
  if ( isAlternate )
  {
    v28 = *(_QWORD *)(v26 + 24);
    if ( v28 )
    {
      v29 = *(_QWORD *)(v28 + 8);
      return *(_QWORD *)(v13 * 8 + v29) != 0;
    }
    return 0;
  }
  if ( !v27 )
    return 0;
  v29 = *(_QWORD *)(v27 + 8);
  return *(_QWORD *)(v13 * 8 + v29) != 0;
}

/*
==============
BG_IsArmorPiercing
==============
*/
_BOOL8 BG_IsArmorPiercing(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool armorPiercing; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  armorPiercing = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->armorPiercing;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return armorPiercing;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7351, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return armorPiercing;
  }
  return penetration->armorPiercing;
}

/*
==============
BG_IsAttachmentHybridThermal
==============
*/
bool BG_IsAttachmentHybridThermal(const WeaponAttachment *attachment)
{
  AttADSOverlay *adsOverlay; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7638, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  return BG_CanAttachmentHybridToggle(attachment) && (adsOverlay = attachment->adsOverlay->hybridScopeAttachment->adsOverlay) != NULL && adsOverlay->thermalScope;
}

/*
==============
BG_IsBallPassValid
==============
*/
bool BG_IsBallPassValid(const playerState_s *ps, const Weapon *r_weapon)
{
  const WeaponDef *v4; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19585, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19577, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->weapClass == WEAPCLASS_BALL && GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagStrict(&ps->otherFlags, (POtherFlagsMP)48);
}

/*
==============
BG_IsBallWeapon
==============
*/
bool BG_IsBallWeapon(const Weapon *r_weapon)
{
  const WeaponDef *v1; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19577, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v1->weapClass == WEAPCLASS_BALL;
}

/*
==============
BG_IsBeamStyleTracer
==============
*/
bool BG_IsBeamStyleTracer(const Weapon *r_weapon, bool isAlternate)
{
  tracerStyle_t tracerStyle; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v6; 
  AttAmmoTracer *v7; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  tracerStyle = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->tracerStyle;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v6 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( WeaponPrimaryAttachment && (v7 = WeaponPrimaryAttachment->tracer) != NULL && isAlternate )
  {
    tracerStyle = v7->tracerStyle;
  }
  else
  {
    v8 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7284, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        tracer = (*i)->tracer;
        if ( tracer )
        {
          if ( *i != v6 )
            break;
        }
        if ( ++v8 >= WeaponAttachments_Internal )
          return tracerStyle == TRACERSTYLE_BEAM;
      }
      tracerStyle = tracer->tracerStyle;
    }
  }
  return tracerStyle == TRACERSTYLE_BEAM;
}

/*
==============
BG_IsBeamWeapon
==============
*/
bool BG_IsBeamWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  weapClass_t WeaponClass; 

  WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
  return WeaponClass == WEAPCLASS_BEAM || WeaponClass == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM;
}

/*
==============
BG_IsBoltAction
==============
*/
_BOOL8 BG_IsBoltAction(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bBoltAction; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bBoltAction = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bBoltAction;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bBoltAction;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8031, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bBoltAction;
  }
  return general->boltAction;
}

/*
==============
BG_IsBoneVisibleOnEitherHand
==============
*/
char BG_IsBoneVisibleOnEitherHand(const LocalClientNum_t localClientNum, const char *bone)
{
  scr_string_t String; 
  cg_t *LocalClientGlobals; 
  int v5; 
  bool v6; 
  WeaponHand *i; 
  DObj *viewModelDObj; 
  __int64 v10; 
  __int64 v11; 
  unsigned __int8 index; 

  String = SL_FindString(bone);
  if ( !String )
    return 0;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v5 = 0;
  v6 = 1;
  for ( i = LocalClientGlobals->m_weaponHand; ; ++i )
  {
    if ( !v6 )
    {
      LODWORD(v11) = 2;
      LODWORD(v10) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    viewModelDObj = i->viewModelDObj;
    if ( i->viewModelDObj )
    {
      index = -2;
      if ( !DObjGetBoneIndexFromStartModel(viewModelDObj, String, 0, &index) || !bitarray_base<bitarray<256>>::testBit(&viewModelDObj->hidePartBits, index) )
        break;
    }
    v6 = (unsigned int)++v5 < 2;
    if ( v5 >= 2 )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsChargeShotWeapon
==============
*/
bool BG_IsChargeShotWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  const WeaponAttachment *Attachment; 
  const WeaponAttachment *v6; 
  WeaponChargeType chargeType; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6487, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6492, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    chargeType = v6->charged->chargeType;
  }
  else
  {
    chargeType = v4->chargeType;
  }
  return (chargeType & 0xFFFFFFF7) != 0;
}

/*
==============
BG_IsEnergyBullet
==============
*/
_BOOL8 BG_IsEnergyBullet(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bEnergyBullet;
}

/*
==============
BG_IsExecutionDog
==============
*/
bool BG_IsExecutionDog(const Weapon *weapon)
{
  const WeaponCompleteDef *v2; 

  if ( !BG_IsMeleeOnlyWeapon(weapon, 0) )
    return 0;
  v2 = BG_WeaponCompleteDef(weapon, 0);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19666, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  return v2->szInternalName && !I_strncmp("iw8_execution_dog", v2->szInternalName, 0x11ui64);
}

/*
==============
BG_IsFauxFists
==============
*/
bool BG_IsFauxFists(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  bool v5; 
  AmmoStore *v6; 
  int v7; 
  AmmoStore result; 
  AmmoStore r_clip2; 

  if ( BG_GetWeaponType(r_weapon, 0) != WEAPTYPE_PROJECTILE || BG_GetWeaponClass(r_weapon, 0) != WEAPCLASS_THROWINGKNIFE )
    return 0;
  v5 = BG_UsingAlternate(ps);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1257, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = BG_AmmoStoreForWeapon(&result, r_weapon, v5);
  v7 = 0;
  r_clip2 = *v6;
  while ( !BG_IsClipCompatible(&ps->weapCommon.ammoInClip[v7].clipIndex, &r_clip2) )
  {
    if ( (unsigned int)++v7 >= 0xF )
      return 1;
  }
  return !(ps->weapCommon.ammoInClip[v7].ammoCount[0] + ps->weapCommon.ammoInClip[v7].ammoCount[1]);
}

/*
==============
BG_IsFistsWeapon
==============
*/
bool BG_IsFistsWeapon(const Weapon *r_weapon)
{
  const WeaponCompleteDef *v1; 
  const char *szInternalName; 
  __int64 v3; 
  int v4; 
  char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v1 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19625, ASSERT_TYPE_ASSERT, "(weaponCompleteDef)", (const char *)&queryFormat, "weaponCompleteDef") )
    __debugbreak();
  szInternalName = v1->szInternalName;
  v3 = 0x7FFFFFFFi64;
  v4 = 1;
  if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v5 = (char *)("iw7_fists_mp" - szInternalName);
  while ( 1 )
  {
    v6 = szInternalName[(_QWORD)v5];
    v7 = v3;
    v8 = *szInternalName++;
    --v3;
    if ( !v7 )
    {
LABEL_11:
      v4 = 0;
      return v4 == 0;
    }
    if ( v6 != v8 )
      break;
    if ( !v6 )
      goto LABEL_11;
  }
  if ( v6 < v8 )
    v4 = -1;
  return v4 == 0;
}

/*
==============
BG_IsForceForegripIK
==============
*/
char BG_IsForceForegripIK(const Weapon *r_weapon, const bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    v5 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 855, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v5->forceForegripIK )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsForceUseWeapon
==============
*/
__int64 BG_IsForceUseWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->forceUse;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20900, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0xF61];
}

/*
==============
BG_IsHighPrecisionClientFireEvent
==============
*/
bool BG_IsHighPrecisionClientFireEvent(const int eventId)
{
  unsigned __int64 v1; 
  __int64 v2; 
  bool result; 

  result = 0;
  if ( (unsigned int)eventId <= 0x33 )
  {
    v1 = eventId;
    v2 = 0xF1D0000000000i64;
    if ( _bittest64(&v2, v1) )
      return 1;
  }
  return result;
}

/*
==============
BG_IsHighPrecisionClientFireEventEnabled
==============
*/
bool BG_IsHighPrecisionClientFireEventEnabled(const int eventId, const entityState_t *es)
{
  unsigned __int64 v2; 
  const dvar_t *v4; 
  __int64 v5; 
  bool result; 

  v2 = eventId;
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20642, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  v4 = DVARBOOL_killswitch_high_precision_player_fire_event_enabled;
  if ( !DVARBOOL_killswitch_high_precision_player_fire_event_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_high_precision_player_fire_event_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  result = 0;
  if ( v4->current.enabled && es->eType == ET_PLAYER && (unsigned int)v2 <= 0x33 )
  {
    v5 = 0xF1D0000000000i64;
    if ( _bittest64(&v5, v2) )
      return 1;
  }
  return result;
}

/*
==============
BG_IsHitSurfaceTransparent
==============
*/
bool BG_IsHitSurfaceTransparent(const trace_t *trace)
{
  int surfaceFlags; 
  int v2; 
  bool result; 

  result = 1;
  if ( (trace->contents & 0x10) == 0 )
  {
    surfaceFlags = trace->surfaceFlags;
    if ( (surfaceFlags & 0x800) == 0 )
    {
      v2 = surfaceFlags & 0x1F80000;
      if ( v2 != 4718592 && v2 != 19922944 && v2 != 20447232 && v2 != 20971520 )
        return 0;
    }
  }
  return result;
}

/*
==============
BG_IsIgnoreEntInBP
==============
*/
char BG_IsIgnoreEntInBP(const BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 
  __int64 v5; 
  int *i; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 532, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  ignoreHitEntCount = bp->ignoreHitEntCount;
  if ( ignoreHitEntCount >= 16 )
    ignoreHitEntCount = 16;
  if ( ignoreHitEntCount <= 0 )
    return 0;
  v5 = 0i64;
  for ( i = bp->ignoreHitEntityQueue; *i != entityIndex; ++i )
  {
    if ( ++v5 >= ignoreHitEntCount )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsImpalingBullet
==============
*/
_BOOL8 BG_IsImpalingBullet(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool impaling; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  impaling = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->impaling;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return impaling;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7372, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return impaling;
  }
  return penetration->impaling;
}

/*
==============
BG_IsIncendiaryBullet
==============
*/
_BOOL8 BG_IsIncendiaryBullet(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet;
}

/*
==============
BG_IsLadderAiming
==============
*/
char BG_IsLadderAiming(const Weapon *currentWeapon, const playerState_s *ps, bool isAlternate)
{
  const dvar_t *v6; 
  const dvar_t *v7; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20920, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( !v6->current.enabled )
    return 0;
  v7 = DCONST_DVARMPBOOL_ladderEnableWeapon;
  if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
    __debugbreak();
  if ( (Dvar_CheckFrontendServerThread(v7), v7->current.enabled) && (BG_IsLadderWeapon(currentWeapon, isAlternate) || BG_GetAmmoInClipForWeapon(ps, currentWeapon, isAlternate, WEAPON_HAND_DEFAULT)) && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) && (unsigned int)(ps->ladderState.mode - 2) <= 1 )
    return 1;
  else
    return 0;
}

/*
==============
BG_IsLadderWeapon
==============
*/
bool BG_IsLadderWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v2; 
  const dvar_t *v4; 
  const WeaponDef *v5; 

  v2 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled )
    return 0;
  v4 = DCONST_DVARMPBOOL_ladderEnableWeapon;
  if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
    return 0;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20913, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v5->ladderWeapon;
}

/*
==============
BG_IsLastShotWeaponEvent
==============
*/
bool BG_IsLastShotWeaponEvent(int event)
{
  bool result; 

  switch ( event )
  {
    case '*':
    case ',':
    case '1':
    case '3':
    case '=':
    case '?':
    case 'A':
    case 'C':
    case 'E':
    case 'G':
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

/*
==============
BG_IsMeleeAnim
==============
*/
bool BG_IsMeleeAnim(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17;
}

/*
==============
BG_IsMeleeAnimFatal
==============
*/
bool BG_IsMeleeAnimFatal(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_FATAL;
}

/*
==============
BG_IsMeleeAnimHit
==============
*/
bool BG_IsMeleeAnimHit(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_HIT;
}

/*
==============
BG_IsMeleeAnimMiss
==============
*/
bool BG_IsMeleeAnimMiss(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_FIRST;
}

/*
==============
BG_IsMeleeAnimState
==============
*/
bool BG_IsMeleeAnimState(int animState)
{
  return (unsigned int)(animState - 10) <= 2;
}

/*
==============
BG_IsMeleeComboOverride
==============
*/
bool BG_IsMeleeComboOverride(const Weapon *r_weapon, const unsigned int overrideIndex)
{
  __int64 v3; 
  const WeaponDef *v4; 
  unsigned int numAnimOverrides; 
  __int64 v6; 
  const WeaponCompleteDef *v7; 
  OverrideBinding *bindings; 
  __int64 slot; 
  __int64 v12; 
  __int64 v14; 
  int v15; 
  __int64 v16; 
  unsigned int v17; 

  v3 = overrideIndex;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  numAnimOverrides = v4->numAnimOverrides;
  if ( !numAnimOverrides )
    return 0;
  if ( (unsigned int)v3 >= numAnimOverrides )
  {
    v17 = v4->numAnimOverrides;
    v15 = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19733, ASSERT_TYPE_ASSERT, "(unsigned)( overrideIndex ) < (unsigned)( weapDef->numAnimOverrides )", "overrideIndex doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v15, v17) )
      __debugbreak();
  }
  v6 = v3;
  if ( !v4->animOverrides[v6].numBindings )
    return 0;
  v7 = BG_WeaponCompleteDef(r_weapon, 0);
  bindings = v4->animOverrides[v6].bindings;
  if ( !bindings->numBindingLists && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19741, ASSERT_TYPE_ASSERT, "(overrideBinding->numBindingLists != 0)", (const char *)&queryFormat, "overrideBinding->numBindingLists != 0") )
    __debugbreak();
  _RBX = bindings->bindingLists;
  if ( _RBX->slot >= (unsigned int)ATT_SLOT_COUNT )
  {
    LODWORD(v16) = 14;
    LODWORD(v14) = _RBX->slot;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19744, ASSERT_TYPE_ASSERT, "(unsigned)( overrideList->slot ) < (unsigned)( ATT_SLOT_COUNT )", "overrideList->slot doesn't index ATT_SLOT_COUNT\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  slot = _RBX->slot;
  __asm { tzcnt   ebx, [rbx+4] }
  v12 = (__int64)&v7->attachments[slot];
  if ( _EBX >= *(_DWORD *)v12 )
  {
    LODWORD(v16) = *(_DWORD *)v12;
    LODWORD(v14) = _EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19748, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentList->attachmentCount )", "attachmentIndex doesn't index attachmentList->attachmentCount\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8i64 * _EBX) + 16i64) == scr_const.combosequence;
}

/*
==============
BG_IsMeleeComboWeapon
==============
*/
bool BG_IsMeleeComboWeapon(const Weapon *r_weapon)
{
  return BG_IsMeleeComboOverride(r_weapon, 0);
}

/*
==============
BG_IsMeleeOnlyAxe
==============
*/
char BG_IsMeleeOnlyAxe(const Weapon *r_weapon, const bool isAlternate)
{
  const WeaponCompleteDef *v4; 
  const char *szInternalName; 
  __int64 v6; 
  char *v7; 
  char v8; 
  __int64 v9; 
  char v10; 

  if ( !BG_IsMeleeOnlyWeapon(r_weapon, isAlternate) )
    return 0;
  v4 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  szInternalName = v4->szInternalName;
  v6 = 0x7FFFFFFFi64;
  if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v7 = (char *)("iw7_axe_mpr_melee" - szInternalName);
  do
  {
    v8 = szInternalName[(_QWORD)v7];
    v9 = v6;
    v10 = *szInternalName++;
    --v6;
    if ( !v9 )
      break;
    if ( v8 != v10 )
      return 0;
  }
  while ( v8 );
  return 1;
}

/*
==============
BG_IsMeleeOnlyWeapon
==============
*/
bool BG_IsMeleeOnlyWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v6; 
  int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v6 = BG_WeaponDefAtIndex(weaponIdx);
  if ( isAlternate && BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE )
    return 1;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
  {
    v7 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; (*i)->internalName != scr_const.meleervn; ++i )
      {
        if ( ++v7 >= WeaponAttachments_Internal )
          return v6->meleeOnly;
      }
      return 1;
    }
  }
  return v6->meleeOnly;
}

/*
==============
BG_IsMountTopStrafeEnabled
==============
*/
bool BG_IsMountTopStrafeEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return 0;
}

/*
==============
BG_IsMountTypeEnabled
==============
*/
bool BG_IsMountTypeEnabled(const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, const ContextMountType mountType)
{
  const dvar_t *v7; 
  const WeaponDef *v8; 
  bool v9; 
  const dvar_t *v11; 
  bool v12; 
  __int64 v13; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22138, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)mountType >= COUNT_MOUNT_TYPE )
  {
    LODWORD(v13) = mountType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22139, ASSERT_TYPE_ASSERT, "(unsigned)( mountType ) < (unsigned)( COUNT_MOUNT_TYPE )", "mountType doesn't index COUNT_MOUNT_TYPE\n\t%i not in [0, %i)", v13, 4) )
      __debugbreak();
  }
  v7 = DCONST_DVARMPBOOL_mount_enable;
  if ( !DCONST_DVARMPBOOL_mount_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "mount_enable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return 0;
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8 )
    return 0;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    v11 = DCONST_DVARMPBOOL_mount_enable_top;
    if ( !DCONST_DVARMPBOOL_mount_enable_top && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "mount_enable_top") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    v12 = v11->current.enabled && v8->mountTopEnable;
    if ( ps && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x27u) )
      return 0;
    return v12;
  }
  else
  {
    if ( (unsigned int)(mountType - 2) > 1 )
      return 0;
    v9 = Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_mount_enable_side, "mount_enable_side") && v8->mountSideEnable;
    if ( ps )
    {
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x28u) )
        return 0;
    }
  }
  return v9;
}

/*
==============
BG_IsOffhandWeaponType
==============
*/
_BOOL8 BG_IsOffhandWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  weapType_t WeaponType; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  return BG_WeaponTypeIsOffhand(WeaponType);
}

/*
==============
BG_IsPlayingLadderAnims
==============
*/
bool BG_IsPlayingLadderAnims(const characterInfo_t *ci)
{
  unsigned int Animset; 
  unsigned int Anim; 
  bool v4; 
  const PlayerAnimEntry *animation; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9943, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW) && PlayerASM_IsEnabled() && !ci->usingAnimState )
  {
    Animset = BG_PlayerASM_GetAnimset(ci);
    Anim = BG_PlayerASM_GetAnim(ci, MOVEMENT);
    v4 = BG_PlayerASM_IsLadderAlias(Anim, Animset) == 0;
  }
  else
  {
    animation = ci->legs.animation;
    if ( !animation )
      return 0;
    v4 = (animation->flags & 2) == 0;
  }
  return !v4;
}

/*
==============
BG_IsPlayingVehicleOccupancyAnims
==============
*/
bool BG_IsPlayingVehicleOccupancyAnims(const characterInfo_t *ci)
{
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9936, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->enableVehicleOccupancyAnimations == 1;
}

/*
==============
BG_IsPredictedProjectileWeapon
==============
*/
bool BG_IsPredictedProjectileWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  bool result; 

  result = 1;
  if ( !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->isPredictedProjectile )
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
    if ( !WeaponPrimaryAttachment )
      return 0;
    projectile = WeaponPrimaryAttachment->projectile;
    if ( !projectile || !projectile->isPredictedProjectile )
      return 0;
  }
  return result;
}

/*
==============
BG_IsRifleBullet
==============
*/
_BOOL8 BG_IsRifleBullet(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bRifleBullet; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bRifleBullet = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRifleBullet;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bRifleBullet;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7326, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bRifleBullet;
  }
  return penetration->rifleBullet;
}

/*
==============
BG_IsRiotShield
==============
*/
__int64 BG_IsRiotShield(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int8 v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAddOns *addOns; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapType == WEAPTYPE_RIOTSHIELD;
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8087, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      addOns = (*i)->addOns;
      if ( addOns )
        break;
      if ( ++v5 >= WeaponAttachments_Internal )
        return v4;
    }
    v4 |= addOns->riotShield;
  }
  return v4;
}

/*
==============
BG_IsSilenced
==============
*/
_BOOL8 BG_IsSilenced(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  bool silenced; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  AttAddOns *addOns; 
  unsigned __int8 v9; 
  const WeaponCompleteDef *v10; 
  const WeaponCompleteDef *v11; 
  WeaponAttachment *v12; 
  AttAddOns *v13; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  silenced = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->silenced;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7996, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      addOns = (*v7)->addOns;
      if ( addOns )
      {
        silenced = addOns->silenced;
        if ( addOns->silenced )
          break;
      }
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    if ( !silenced && isAlternate )
    {
      v9 = r_weapon->weaponAttachments[10];
      if ( v9 )
      {
        v10 = BG_WeaponCompleteDef(r_weapon, 0);
        v11 = v10;
        if ( v9 > v10->attachments[10].attachmentCount )
        {
          LODWORD(attachmentSlots) = 1;
          LODWORD(numAttachmentSlots) = v9;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", numAttachmentSlots, attachmentSlots, v10->attachments[10].attachmentCount) )
            __debugbreak();
        }
        v12 = v11->attachments[10].attachments[v9 - 1];
        if ( v12 )
        {
          v13 = v12->addOns;
          if ( v13 )
            return v13->silenced;
        }
        else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v11->szInternalName) )
        {
          __debugbreak();
        }
      }
    }
  }
  return silenced;
}

/*
==============
BG_IsSwimWeapon
==============
*/
bool BG_IsSwimWeapon(const Weapon *r_weapon)
{
  scr_string_t swim; 
  const WeaponAttachment *WeaponPrimaryAttachment; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) )
    return 0;
  swim = scr_const.swim;
  if ( !scr_const.swim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1828, ASSERT_TYPE_ASSERT, "(attachmentName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "attachmentName != NULL_SCR_STRING") )
    __debugbreak();
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->internalName == swim;
}

/*
==============
BG_IsTargetAssistActive
==============
*/
bool BG_IsTargetAssistActive(const playerState_s *ps, const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  const Weapon *v4; 
  unsigned int v8; 
  targetAssistType_t targetAssistType; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  AttTargetAssist *targetAssist; 
  unsigned int v14; 
  WeaponAttachment **v15; 
  AttTargetAssist *v16; 
  bool targetAssistOnlyAvailableInAds; 
  char v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = r_weapon;
  v8 = 0;
  targetAssistType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v4, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = 0;
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9100, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      targetAssist = (*v12)->targetAssist;
      if ( targetAssist )
        break;
      ++v11;
      ++v12;
      if ( v11 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    targetAssistType = targetAssist->targetAssistType;
LABEL_10:
    v4 = r_weapon;
  }
  if ( targetAssistType != TARGET_ASSISTTYPPE_CONE )
    return 0;
  v14 = BG_GetWeaponAttachments_Internal(v4, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( v14 )
  {
    v15 = attachments;
    while ( 1 )
    {
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9171, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v16 = (*v15)->targetAssist;
      if ( v16 )
        break;
      ++v8;
      ++v15;
      if ( v8 >= v14 )
      {
        v4 = r_weapon;
        goto LABEL_20;
      }
    }
    targetAssistOnlyAvailableInAds = v16->targetAssistOnlyAvailableInAds;
  }
  else
  {
LABEL_20:
    targetAssistOnlyAvailableInAds = BG_WeaponDefAtIndex(v4->weaponIdx)->targetAssistOnlyAvailableInAds;
  }
  if ( !ps )
  {
    if ( !es || !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&es->lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x19u) )
      goto LABEL_23;
LABEL_30:
    v18 = 1;
    return !targetAssistOnlyAvailableInAds || v18;
  }
  if ( BG_InADS(ps) )
    goto LABEL_30;
LABEL_23:
  v18 = 0;
  return !targetAssistOnlyAvailableInAds || v18;
}

/*
==============
BG_IsThermalEnabled
==============
*/
bool BG_IsThermalEnabled(const BgWeaponMap *weaponMap, const Weapon *r_weapon, const playerState_s *ps)
{
  bool v6; 
  unsigned int v7; 
  bool v8; 
  bool thermalScope; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttADSOverlay *adsOverlay; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7655, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7656, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = BG_UsingAlternate(ps);
  v7 = 0;
  v8 = v6;
  if ( ps && v6 && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v8 = 0;
  thermalScope = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->thermalScope;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15545, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      adsOverlay = (*v11)->adsOverlay;
      if ( adsOverlay )
        break;
      ++v7;
      ++v11;
      if ( v7 >= WeaponAttachments_Internal )
        goto LABEL_21;
    }
    thermalScope = adsOverlay->thermalScope;
  }
LABEL_21:
  result = 0;
  if ( thermalScope && (BG_InADS(ps) || BG_IsUsingOffhandGestureWeaponADSActive(ps)) )
  {
    EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
    if ( EquippedWeaponStateConst )
    {
      if ( EquippedWeaponStateConst->thermalEnabled )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_IsThrowingAxe
==============
*/
bool BG_IsThrowingAxe(const Weapon *r_weapon)
{
  return BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE;
}

/*
==============
BG_IsTopMountYawClamped
==============
*/
const WeaponDef *BG_IsTopMountYawClamped(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountTopYawClamp;
  return result;
}

/*
==============
BG_IsUnderbarrelGl
==============
*/
_BOOL8 BG_IsUnderbarrelGl(const WeaponAttachment *weapAttachment)
{
  if ( !weapAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 756, ASSERT_TYPE_ASSERT, "(weapAttachment)", (const char *)&queryFormat, "weapAttachment") )
    __debugbreak();
  return weapAttachment->weapClass == WEAPCLASS_GRENADE && weapAttachment->weaponType == WEAPTYPE_PROJECTILE;
}

/*
==============
BG_IsUnderbarrelShotgun
==============
*/
_BOOL8 BG_IsUnderbarrelShotgun(const WeaponAttachment *weapAttachment)
{
  if ( !weapAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 764, ASSERT_TYPE_ASSERT, "(weapAttachment)", (const char *)&queryFormat, "weapAttachment") )
    __debugbreak();
  return weapAttachment->weapClass == WEAPCLASS_SPREAD && (weapAttachment->weaponType & 0xFFFFFFFD) == 0;
}

/*
==============
BG_IsUsingDualFOV
==============
*/
bool BG_IsUsingDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  bool v5; 
  int HasUnderbarrelWeapon; 
  bool outIsAlternate; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3057, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3058, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3019, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3020, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(weaponMap, ps, &outIsAlternate);
  if ( !ps )
    goto LABEL_19;
  v5 = outIsAlternate;
  if ( !outIsAlternate )
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
  if ( !BG_PWF_UseAlternateAsOffhand(ps) )
  {
LABEL_19:
    v5 = outIsAlternate;
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
  }
  HasUnderbarrelWeapon = BG_HasUnderbarrelWeapon(ViewmodelOrOffhandADSSupportWeapon);
  v5 = outIsAlternate;
  if ( HasUnderbarrelWeapon )
    v5 = 0;
  outIsAlternate = v5;
  return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
}

/*
==============
BG_IsUsingFastReloadStateTimer
==============
*/
char BG_IsUsingFastReloadStateTimer(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  int *v10; 
  __int64 v12; 
  bool v13; 
  unsigned __int64 v14; 
  bool v15; 
  bool v16; 
  __int64 v17; 
  bool v18; 
  char v19; 
  bool v20; 
  int ammoInClip; 
  char v22; 
  bool v23; 
  ReloadType ReloadType; 
  PlayerHandIndex fmt; 
  bool hasFastReloadOverride; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10168, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = &ps->commandTime + 20 * v6;
  if ( (unsigned int)(v10[339] - 18) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10173, ASSERT_TYPE_ASSERT, "(( (weapState.weaponState == WEAPON_RELOADING) || (weapState.weaponState == WEAPON_RELOAD_START) || ( (weapState.weaponState == WEAPON_RELOAD_END) || (weapState.weaponState == WEAPON_RELOAD_END_RECHAMBER) ) ))", (const char *)&queryFormat, "WEAPONSTATE_RELOADING( weapState.weaponState )") )
    __debugbreak();
  if ( v10[339] == 18 )
  {
    v23 = isAlternate;
    ReloadType = BG_GetReloadType(r_weapon, isAlternate);
    hasFastReloadOverride = 0;
    switch ( ReloadType )
    {
      case RELOAD_TYPE_MULTIPLE_PERCENTAGE:
        BG_ReloadMultipleTimePercentageBased(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, &hasFastReloadOverride);
        break;
      case RELOAD_TYPE_MULTIPLE_BULLET:
        BG_ReloadMultipleTimeBulletBased(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, &hasFastReloadOverride);
        break;
      case RELOAD_TYPE_SEGMENTED:
        goto LABEL_30;
      default:
        if ( ReloadType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10204, ASSERT_TYPE_ASSERT, "(reloadType == RELOAD_TYPE_NORMAL)", (const char *)&queryFormat, "reloadType == RELOAD_TYPE_NORMAL") )
          __debugbreak();
        if ( (v10[331] & 0xFFFFFF7F) != 17 )
LABEL_30:
          BG_ReloadTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, isDualWielding, v10[345], &hasFastReloadOverride);
        else
          BG_ReloadEmptyTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, isDualWielding, &hasFastReloadOverride);
        break;
    }
    return hasFastReloadOverride;
  }
  if ( v10[339] != 19 )
  {
    if ( v10[339] != 20 )
    {
      if ( v10[339] != 21 )
        return 0;
      v12 = 2 * (5 * v6 + 85);
      fmt = (int)v6;
      v13 = isAlternate;
      v14 = *((unsigned int *)&ps->commandTime + 2 * v12);
      v15 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, fmt, v10[345], WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
      v16 = isDualWielding;
      v17 = (v14 >> 2) & 1;
      v18 = v15;
      BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, isDualWielding, 4i64 * (unsigned int)v17 + 112, NUM_WEAP_ANIMS);
      BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 114, NUM_WEAP_ANIMS);
      v19 = 0;
      if ( v18 )
      {
        if ( BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 124, NUM_WEAP_ANIMS) )
        {
          BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 126, NUM_WEAP_ANIMS);
          return 1;
        }
      }
      return v19;
    }
    hasFastReloadOverride = 0;
    BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, v10[345], &hasFastReloadOverride);
    return hasFastReloadOverride;
  }
  v20 = isAlternate;
  ammoInClip = v10[345];
  v22 = 0;
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 96i64, NUM_WEAP_ANIMS);
  if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, v20, (PlayerHandIndex)v6, ammoInClip, WEAP_ANIM_FAST_RELOAD_START) )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v20, isDualWielding, 98i64, NUM_WEAP_ANIMS) != 0;
  return v22;
}

/*
==============
BG_IsUsingHybridScope
==============
*/
bool BG_IsUsingHybridScope(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 

  return ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
}

/*
==============
BG_IsUsingWorldIKTargets
==============
*/
bool BG_IsUsingWorldIKTargets(const characterInfo_t *ci)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v2; 

  weaponIdx = ci->dobjTurretWeapon.weaponIdx;
  if ( !weaponIdx )
    return 0;
  v2 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9816, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->useTurret3pIK;
}

/*
==============
BG_IsValidWeapon
==============
*/
char BG_IsValidWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v4; 
  unsigned int v5; 
  AttachmentList *v6; 
  int v7; 
  bool v8; 
  unsigned int v9; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  WeaponAttachment *v13; 
  unsigned int numReticles; 
  unsigned int v15; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( r_weapon->weaponIdx < 0x226u )
  {
    v4 = BG_WeaponCompleteDef(r_weapon, 0);
    if ( v4 )
    {
      if ( r_weapon->weaponCamo < BG_Camo_GetCamoCount() )
      {
        v5 = 0;
        v6 = v4->attachments;
        v7 = 0;
        v8 = 1;
        while ( 1 )
        {
          if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
            __debugbreak();
          v9 = v7 == 12 ? r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8) : r_weapon->weaponAttachments[v7];
          if ( v9 > v6->attachmentCount )
            break;
          ++v7;
          ++v6;
          v8 = v7 < 13;
          if ( (unsigned int)v7 >= 0xD )
          {
            if ( (~(unsigned __int16)((1 << v4->attachments[13].attachmentCount) - 1) & r_weapon->weaponOthers) != 0 )
              return 0;
            if ( r_weapon->scopeVariation )
            {
              AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
              v11 = 0;
              if ( AllWeaponAttachmentsWithIds )
              {
                v12 = attachments;
                while ( 1 )
                {
                  v13 = *v12;
                  if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20592, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
                    __debugbreak();
                  numReticles = v13->numReticles;
                  if ( numReticles )
                  {
                    v15 = v13->numReticles;
                    if ( v5 > numReticles )
                      v15 = v5;
                    v5 = v15;
                    if ( r_weapon->scopeVariation >= numReticles )
                      break;
                  }
                  ++v11;
                  ++v12;
                  if ( v11 >= AllWeaponAttachmentsWithIds )
                  {
                    if ( !v5 )
                      return 0;
                    goto LABEL_26;
                  }
                }
              }
            }
            else
            {
LABEL_26:
              if ( !isAlternate )
                return 1;
              WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
              if ( WeaponPrimaryAttachment )
              {
                if ( WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE )
                  return 1;
              }
            }
            return 0;
          }
        }
      }
    }
  }
  return 0;
}

/*
==============
BG_IsWeaponHybridThermal
==============
*/
bool BG_IsWeaponHybridThermal(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  AttADSOverlay *adsOverlay; 
  AttADSOverlay *v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7624, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v8 = *i;
    if ( (*i)->type == ATTACHMENT_SCOPE )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0;
  }
  if ( !v8 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7638, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
  }
  adsOverlay = v8->adsOverlay;
  if ( !adsOverlay )
    return 0;
  if ( !adsOverlay->hybridToggle )
    return 0;
  v11 = adsOverlay->hybridScopeAttachment->adsOverlay;
  if ( !v11 )
    return 0;
  return v11->thermalScope;
}

/*
==============
BG_IsWeaponLaserEndViewCenterInAds
==============
*/
__int16 BG_IsWeaponLaserEndViewCenterInAds(const Weapon *r_weapon, const bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  AttLaser *laser; 
  unsigned __int16 v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v10[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v10, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17948, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      laser = (*v5)->laser;
      if ( laser )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    v7 = *(_WORD *)&laser->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  else
  {
LABEL_8:
    v7 = *(_WORD *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  return HIBYTE(v7);
}

/*
==============
BG_IsWeaponRecoilDelayed
==============
*/
bool BG_IsWeaponRecoilDelayed(const pmove_t *pm, const playerState_s *ps)
{
  int v4; 
  const dvar_t *v5; 

  if ( !pm && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22197, ASSERT_TYPE_ASSERT, "(pm)", (const char *)&queryFormat, "pm") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22198, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = pm->cmd.serverTime - ps->weapState[0].weaponFireTime;
  v5 = DCONST_DVARFLT_weaponRecoilDecayDelay;
  if ( !DCONST_DVARFLT_weaponRecoilDecayDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "weaponRecoilDecayDelay") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  return v4 < (int)(float)(v5->current.value * 1000.0);
}

/*
==============
BG_IsWeaponUsableInState
==============
*/
bool BG_IsWeaponUsableInState(const playerState_s *ps, const Weapon *r_weapon)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3574, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  BG_UsingAlternate(ps);
  return !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blocksProne || !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0);
}

/*
==============
BG_IsWeaponValid
==============
*/
bool BG_IsWeaponValid(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  unsigned __int16 v6; 
  unsigned __int16 v7; 
  WeaponMapEntry *m_entries; 
  unsigned __int16 v9; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3547, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3548, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !r_weapon->weaponIdx || r_weapon->weaponIdx >= BG_GetNumWeapons() )
    return 0;
  if ( !weaponMap->m_entries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 186, ASSERT_TYPE_ASSERT, "(m_entries != nullptr)", (const char *)&queryFormat, "m_entries != nullptr") )
    __debugbreak();
  if ( !BgWeaponMap::ms_runtimeSizeInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 228, ASSERT_TYPE_ASSERT, "(ms_runtimeSizeInitialized)", (const char *)&queryFormat, "ms_runtimeSizeInitialized") )
    __debugbreak();
  v6 = BgWeaponMap::ms_runtimeSize;
  v7 = 1;
  if ( BgWeaponMap::ms_runtimeSize <= 1u )
    return 0;
  m_entries = weaponMap->m_entries;
  while ( 1 )
  {
    if ( !m_entries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 161, ASSERT_TYPE_ASSERT, "(m_entries != nullptr)", (const char *)&queryFormat, "m_entries != nullptr") )
      __debugbreak();
    v9 = truncate_cast<unsigned short,unsigned int>(v7);
    if ( !BgWeaponMap::ms_runtimeSizeInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 228, ASSERT_TYPE_ASSERT, "(ms_runtimeSizeInitialized)", (const char *)&queryFormat, "ms_runtimeSizeInitialized") )
      __debugbreak();
    if ( v9 >= BgWeaponMap::ms_runtimeSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 165, ASSERT_TYPE_ASSERT, "(mapEntryIndex < BgWeaponMap::GetRuntimeSize())", "%s\n\tHandle supplied to BgWeaponMap::GetWeapon does not index the map.", "mapEntryIndex < BgWeaponMap::GetRuntimeSize()") )
      __debugbreak();
    m_entries = weaponMap->m_entries;
    if ( m_entries[v9].index == v9 && !memcmp_0(&m_entries[v7].weapon, r_weapon, 0x3Cui64) )
      break;
    if ( ++v7 >= v6 )
      return 0;
  }
  return BG_PlayerHasWeapon(weaponMap, ps, r_weapon) != 0;
}

/*
==============
BG_KickAngles
==============
*/
void BG_KickAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, int updateFrameTime, int *inOutKickTimeRemaining, vec3_t *inOutKickAVel, vec3_t *inOutRawKickAngles, vec3_t *outKickAngles, bool *inOutKickNeedsToCrossCenter)
{
  Weapon *v12; 
  bool v13; 
  bool v14; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v17; 
  unsigned int v18; 
  const WeaponAttachment **v19; 
  AttViewKick *AttachmentViewKick; 
  bool v21; 
  Weapon *v22; 
  playerState_s *v23; 
  double v24; 
  float v25; 
  float v26; 
  __int64 v27; 
  float v28; 
  int v29; 
  int v30; 
  BgWeaponMap *v31; 
  unsigned int v32; 
  playerState_s *v33; 
  unsigned int v34; 
  const PlayerEquippedWeaponState *v35; 
  bool v36; 
  unsigned int v37; 
  const WeaponAttachment **v38; 
  AttViewKick *v39; 
  bool v40; 
  vec3_t *v41; 
  vec2_t *v42; 
  float v43; 
  float v44; 
  float v45; 
  float *hipViewKickReturnAccelScale; 
  float *adsViewKickAccel; 
  float *adsViewKickReturnAccelScale; 
  bool v49; 
  bool useNewViewKick; 
  bool v51; 
  float outViewKickPitchScale; 
  float outViewKickYawScale[2]; 
  float hipViewKickReturnSpeedCurveScale[2]; 
  playerState_s *psa; 
  float outGunKickYawScale; 
  float outGunKickPitchScale; 
  float v58; 
  float v59; 
  float adsViewKickReturnSpeedCurveScale; 
  float hipViewKickAccel; 
  float v62; 
  BgWeaponMap *weaponMapa; 
  vec2_t *inOutAngles; 
  Weapon *weapon; 
  vec2_t *inOutAngularVel; 
  bool *v67; 
  vec3_t *v68; 
  vec3_t maxAngles; 
  WeaponAttachment *attachments[30]; 
  WeaponAttachment *v71[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v73[32]; 

  inOutAngularVel = (vec2_t *)inOutKickAVel;
  weaponMapa = (BgWeaponMap *)weaponMap;
  inOutAngles = (vec2_t *)inOutRawKickAngles;
  v68 = outKickAngles;
  v67 = inOutKickNeedsToCrossCenter;
  psa = (playerState_s *)ps;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4364, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4365, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weapon = (Weapon *)BG_GetViewmodelWeapon(weaponMap, ps);
  v12 = weapon;
  v49 = BG_UsingAlternate(ps);
  if ( !BG_UsingSniperScope(weaponMap, ps) || (v51 = 1, !BG_HasPerk(&ps->perks, 0x29u)) )
    v51 = 0;
  v13 = BG_UsingAlternate(ps);
  BG_GetViewKickSpeed(weaponMap, ps, weapon, v13, &hipViewKickAccel, &v62, hipViewKickReturnSpeedCurveScale, &v58, &v59, &adsViewKickReturnSpeedCurveScale);
  v14 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v12, v14, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v17 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, v12)) != NULL && EquippedWeaponStateConst->hybridScope;
  v18 = 0;
  *(_QWORD *)maxAngles.v = *(_QWORD *)&BG_WeaponDefAtIndex(v12->weaponIdx)->fViewMaxPitch;
  if ( WeaponAttachments_Internal )
  {
    v19 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20859, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMapa, psa, weapon, v14, *v19, v17);
      if ( AttachmentViewKick )
        break;
      ++v18;
      ++v19;
      if ( v18 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    *(_QWORD *)maxAngles.v = *(_QWORD *)&AttachmentViewKick->viewMaxPitch;
  }
LABEL_24:
  v21 = v49;
  v22 = weapon;
  v23 = psa;
  maxAngles.v[2] = 0.0;
  outViewKickPitchScale = FLOAT_1_0;
  outViewKickYawScale[0] = FLOAT_1_0;
  outGunKickPitchScale = FLOAT_1_0;
  outGunKickYawScale = FLOAT_1_0;
  BG_GetViewAndGunKickScalars(weaponMapa, psa, weapon, v49, &outViewKickPitchScale, outViewKickYawScale, &outGunKickPitchScale, &outGunKickYawScale);
  if ( v23->weapCommon.fWeaponPosFrac <= 0.5 )
  {
    *(_QWORD *)&v24 = LODWORD(hipViewKickAccel);
    v25 = v62;
    v26 = hipViewKickReturnSpeedCurveScale[0];
  }
  else
  {
    *(_QWORD *)&v24 = LODWORD(v58);
    v25 = v59;
    v26 = adsViewKickReturnSpeedCurveScale;
  }
  v27 = (unsigned int)((updateFrameTime + *inOutKickTimeRemaining) / KICK_ANGLES_TIME_STEP);
  v28 = (float)KICK_ANGLES_TIME_STEP * 0.001;
  if ( KICK_ANGLES_MAX_TIME_STEPS >= (int)v27 )
  {
    v29 = (updateFrameTime + *inOutKickTimeRemaining) % KICK_ANGLES_TIME_STEP;
  }
  else
  {
    v27 = (unsigned int)KICK_ANGLES_MAX_TIME_STEPS;
    v29 = 0;
  }
  *inOutKickTimeRemaining = v29;
  v30 = KICK_ANGLES_TIME_STEP;
  if ( KICK_ANGLES_TIME_STEP <= 0 )
  {
    LODWORD(adsViewKickReturnAccelScale) = KICK_ANGLES_TIME_STEP;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4414, ASSERT_TYPE_ASSERT, "( 0 ) < ( KICK_ANGLES_TIME_STEP )", "%s < %s\n\t%i, %i", "0", "KICK_ANGLES_TIME_STEP", 0i64, adsViewKickReturnAccelScale) )
      __debugbreak();
    v30 = KICK_ANGLES_TIME_STEP;
  }
  if ( *inOutKickTimeRemaining < 0 || *inOutKickTimeRemaining > v30 - 1 )
  {
    LODWORD(adsViewKickAccel) = v30 - 1;
    LODWORD(hipViewKickReturnAccelScale) = *inOutKickTimeRemaining;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4415, ASSERT_TYPE_ASSERT, "( 0 ) <= ( inOutKickTimeRemaining ) && ( inOutKickTimeRemaining ) <= ( KICK_ANGLES_TIME_STEP - 1 )", "inOutKickTimeRemaining not in [0, KICK_ANGLES_TIME_STEP - 1]\n\t%i not in [%i, %i]", hipViewKickReturnAccelScale, 0i64, adsViewKickAccel) )
      __debugbreak();
  }
  if ( (int)v27 < 0 )
  {
    LODWORD(adsViewKickReturnAccelScale) = v27;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4416, ASSERT_TYPE_ASSERT, "( 0 ) <= ( frameSteps )", "%s <= %s\n\t%i, %i", "0", "frameSteps", 0i64, adsViewKickReturnAccelScale) )
      __debugbreak();
  }
  if ( (int)v27 > KICK_ANGLES_MAX_TIME_STEPS )
  {
    LODWORD(adsViewKickReturnAccelScale) = KICK_ANGLES_MAX_TIME_STEPS;
    LODWORD(adsViewKickAccel) = v27;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4417, ASSERT_TYPE_ASSERT, "( frameSteps ) <= ( KICK_ANGLES_MAX_TIME_STEPS )", "%s <= %s\n\t%i, %i", "frameSteps", "KICK_ANGLES_MAX_TIME_STEPS", adsViewKickAccel, adsViewKickReturnAccelScale) )
      __debugbreak();
  }
  if ( (int)v27 > 0 )
  {
    v31 = weaponMapa;
    *(_QWORD *)hipViewKickReturnSpeedCurveScale = v27;
    do
    {
      useNewViewKick = BG_WeaponDefAtIndex(v22->weaponIdx)->useNewViewKick;
      v32 = BG_GetWeaponAttachments_Internal(v22, v21, (const WeaponAttachment **)v71, v73, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      v33 = psa;
      v34 = v32;
      v36 = v31 && (v35 = BG_GetEquippedWeaponStateConst(v31, psa, v22)) != NULL && v35->hybridScope;
      v37 = 0;
      if ( v34 )
      {
        v38 = (const WeaponAttachment **)v71;
        while ( 1 )
        {
          if ( !*v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14470, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
            __debugbreak();
          v39 = BG_GetAttachmentViewKick(v31, v33, v22, v49, *v38, v36);
          if ( v39 )
            break;
          ++v37;
          ++v38;
          if ( v37 >= v34 )
          {
            v27 = *(_QWORD *)hipViewKickReturnSpeedCurveScale;
            goto LABEL_58;
          }
        }
        v40 = v39->useNewViewKick;
        v27 = *(_QWORD *)hipViewKickReturnSpeedCurveScale;
      }
      else
      {
LABEL_58:
        v40 = useNewViewKick;
      }
      if ( v40 )
        BG_CalculateKickMovement(v28, (const vec2_t *)&maxAngles, 1.0, 1.0, *(float *)&v24, v25, v26, inOutAngles, inOutAngularVel, v67);
      else
        BG_CalculateKickMovement_Legacy(v28, &maxAngles, v24, v22, v51, (vec3_t *)inOutAngularVel, (vec3_t *)inOutAngles);
      v21 = v49;
      *(_QWORD *)hipViewKickReturnSpeedCurveScale = --v27;
    }
    while ( v27 );
  }
  v41 = v68;
  v42 = inOutAngles;
  v43 = inOutAngles->v[0];
  v68->v[0] = inOutAngles->v[0];
  v44 = v42->v[1];
  v45 = v43 * outViewKickPitchScale;
  v41->v[1] = v44;
  *(float *)&v42 = v42[1].v[0];
  v41->v[1] = v44 * outViewKickYawScale[0];
  v41->v[0] = v45;
  LODWORD(v41->v[2]) = (_DWORD)v42;
}

/*
==============
BG_LadderAimADSRaiseInterruptTime
==============
*/
__int64 BG_LadderAimADSRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 164i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimADSRaiseTime
==============
*/
__int64 BG_LadderAimADSRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 162i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimDropInterruptTime
==============
*/
__int64 BG_LadderAimDropInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 168i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimDropTime
==============
*/
__int64 BG_LadderAimDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 166i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimRaiseInterruptTime
==============
*/
__int64 BG_LadderAimRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u);
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 164i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimRaiseTime
==============
*/
__int64 BG_LadderAimRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 

  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) )
    LOWORD(result) = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 162i64, NUM_WEAP_ANIMS);
  else
    LOWORD(result) = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 158i64, NUM_WEAP_ANIMS);
  return (unsigned __int16)result;
}

/*
==============
BG_LadderClimbDropTime
==============
*/
__int64 BG_LadderClimbDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 156i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderClimbRaiseTime
==============
*/
__int64 BG_LadderClimbRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 154i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderVaultTime
==============
*/
__int64 BG_LadderVaultTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 152i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LeapCancelTime
==============
*/
__int64 BG_LeapCancelTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 218i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_CANCEL, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_LeapInTime
==============
*/
__int64 BG_LeapInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 212i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_IN, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_LeapOutTime
==============
*/
__int64 BG_LeapOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 216i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_OUT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MapWeaponAnimIndexToMeleeIndex
==============
*/
__int64 BG_MapWeaponAnimIndexToMeleeIndex(weapAnimFiles_t animIndex)
{
  unsigned __int32 v2; 

  if ( (unsigned int)(animIndex - 262) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17761, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
    __debugbreak();
  v2 = (animIndex - 262) % 3;
  if ( v2 > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17764, ASSERT_TYPE_ASSERT, "(MELEE_ANIM_FIRST <= meleeIndex && meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "MELEE_ANIM_FIRST <= meleeIndex && meleeIndex < NUM_MELEE_ANIMS") )
    __debugbreak();
  return v2;
}

/*
==============
BG_MapWeaponAnimStateToAnimIndex
==============
*/
weapAnimFiles_t BG_MapWeaponAnimStateToAnimIndex(const BgWeaponMap *weaponMap, const playerState_s *ps, int animState, bool previousMelee, const Weapon *r_weapon, bool bIsAlternate, PlayerHandIndex handIndex, const BgHandler *pmoveHandler)
{
  int AmmoInClipForWeapon; 
  int v14; 
  int v15; 
  int v16; 
  bool isMeleeVariationAltPrev; 
  int altMeleeVariation; 
  int v19; 
  int v20; 
  bool v21; 
  int v22; 
  bool v23; 
  int v24; 
  bool v25; 
  int v26; 
  bool v27; 
  int v28; 
  bool v29; 
  bool v30; 
  bool IsSprintAdditive; 
  int v32; 
  bool v33; 
  int v34; 
  bool v35; 
  int v36; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18017, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  AmmoInClipForWeapon = BG_GetAmmoInClipForWeapon(ps, r_weapon, bIsAlternate, handIndex);
  switch ( animState )
  {
    case 0:
    case 1:
      if ( AmmoInClipForWeapon )
        return 236;
      return 237;
    case 2:
      return 238;
    case 3:
      return 239;
    case 4:
      return 241;
    case 5:
      return 242;
    case 6:
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17908, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17909, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
        __debugbreak();
      v14 = 347;
      if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_FIRE_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) || !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
        return 346;
      return v14;
    case 7:
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17926, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17927, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
        __debugbreak();
      v15 = 349;
      if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_LASTSHOT_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) || !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
        return 348;
      return v15;
    case 8:
      return 243;
    case 9:
      return 244;
    case 10:
    case 11:
    case 12:
      v16 = animState - 10;
      if ( (unsigned int)v16 > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17744, ASSERT_TYPE_ASSERT, "(BG_IsMeleeAnimState( animState ))", (const char *)&queryFormat, "BG_IsMeleeAnimState( animState )") )
        __debugbreak();
      isMeleeVariationAltPrev = BG_UsingAlternateMelee(ps);
      if ( isMeleeVariationAltPrev )
        altMeleeVariation = ps->weapCommon.altMeleeVariation;
      else
        altMeleeVariation = ps->weapCommon.meleeVariation;
      if ( previousMelee )
      {
        isMeleeVariationAltPrev = ps->weapCommon.isMeleeVariationAltPrev;
        if ( isMeleeVariationAltPrev )
          altMeleeVariation = ps->weapCommon.altMeleeVariationPrev;
        else
          altMeleeVariation = ps->weapCommon.meleeVariationPrev;
      }
      if ( altMeleeVariation >= 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17753, ASSERT_TYPE_ASSERT, "(meleeAnimPkgIndex < (4))", (const char *)&queryFormat, "meleeAnimPkgIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
        __debugbreak();
      if ( (unsigned int)altMeleeVariation > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1177, ASSERT_TYPE_ASSERT, "(0 <= meleeSetIndex && meleeSetIndex < (4))", (const char *)&queryFormat, "0 <= meleeSetIndex && meleeSetIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
        __debugbreak();
      if ( v16 >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1178, ASSERT_TYPE_ASSERT, "(meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "meleeIndex < NUM_MELEE_ANIMS") )
        __debugbreak();
      v19 = altMeleeVariation + 4 * isMeleeVariationAltPrev;
      v20 = v19 + v16 + 2 * v19 + 262;
      if ( (unsigned int)(v19 + v16 + 2 * v19) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1186, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
        __debugbreak();
      return v20;
    case 13:
    case 71:
      return 325;
    case 14:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      return 322;
    case 15:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      return 323;
    case 16:
      return BG_ReloadMultipleAnimOverride(weaponMap, ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, 0);
    case 17:
      return BG_ReloadMultipleAnimOverride(weaponMap, ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, 1);
    case 18:
      v21 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_START);
      v22 = 292;
      if ( v21 )
        return 310;
      return v22;
    case 19:
      v23 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_START_TWO);
      v24 = 295;
      if ( v23 )
        return 313;
      return v24;
    case 20:
      v25 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_END);
      v26 = 298;
      if ( v25 )
        return 316;
      return v26;
    case 21:
      v27 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
      v28 = 301;
      if ( v27 )
        return 319;
      return v28;
    case 22:
      return 329;
    case 23:
      return 330;
    case 24:
      return 331;
    case 25:
      return 326;
    case 26:
      return 327;
    case 27:
      return 328;
    case 28:
      return 334;
    case 29:
      return 333;
    case 30:
      return 336;
    case 31:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      else
        return 335;
    case 32:
      IsSprintAdditive = BG_IsSprintAdditive(weaponMap, ps);
      v32 = 337;
      if ( IsSprintAdditive )
        return 94;
      return v32;
    case 33:
      return 338;
    case 34:
      v33 = BG_IsSprintAdditive(weaponMap, ps);
      v34 = 339;
      if ( v33 )
        return 95;
      return v34;
    case 35:
      v35 = BG_IsSprintAdditive(weaponMap, ps);
      v36 = 341;
      if ( v35 )
        return 97;
      return v36;
    case 36:
      return 342;
    case 37:
      return 343;
    case 38:
      return 344;
    case 39:
      return 240;
    case 40:
      return 345;
    case 41:
      return 400;
    case 44:
      return 398;
    case 45:
      if ( handIndex )
        return 398;
      else
        return 399;
    case 46:
      return 403;
    case 47:
      return 402;
    case 48:
      return 352;
    case 49:
      return 355;
    case 50:
      return 354;
    case 51:
      return 353;
    case 53:
      v29 = BG_UsingAlternate(ps);
      if ( BG_IsLadderWeapon(r_weapon, v29) && (v30 = BG_UsingAlternate(ps), BG_GetAmmoInClipForWeapon(ps, r_weapon, v30, WEAPON_HAND_DEFAULT)) )
        return 379;
      else
        return 378;
    case 54:
      return 375;
    case 55:
    case 67:
      return 236;
    case 56:
      return 374;
    case 57:
      return 363;
    case 58:
      return 364;
    case 59:
      return 366;
    case 60:
      return 365;
    case 61:
      return 367;
    case 62:
      return 368;
    case 63:
      return 369;
    case 64:
      return 370;
    case 65:
      return 371;
    case 66:
      return 372;
    case 68:
      return 376;
    case 69:
      return 377;
    case 70:
      return 380;
    case 72:
      return 245;
    case 73:
      return 247;
    case 74:
      return 248;
    case 75:
      return 249;
    case 76:
      return 250;
    case 77:
      return 251;
    case 78:
    case 79:
      return 252;
    case 80:
      return 254;
    case 81:
      return 255;
    case 82:
      return 258;
    case 83:
      return 322;
    case 85:
      return 433;
    default:
      Com_Printf(19, "BG_MapWeaponAnimStateToAnimIndex: Unknown weapon animation %i\n", (unsigned int)animState);
      return 236;
  }
}

/*
==============
BG_MapWeaponAnimStateToMeleeAnimIndex
==============
*/
__int64 BG_MapWeaponAnimStateToMeleeAnimIndex(const playerState_s *ps, bool previous, int animState)
{
  int v3; 
  bool isMeleeVariationAltPrev; 
  int altMeleeVariation; 
  int v8; 
  unsigned int v9; 

  v3 = animState - 10;
  if ( (unsigned int)(animState - 10) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17744, ASSERT_TYPE_ASSERT, "(BG_IsMeleeAnimState( animState ))", (const char *)&queryFormat, "BG_IsMeleeAnimState( animState )") )
    __debugbreak();
  isMeleeVariationAltPrev = BG_UsingAlternateMelee(ps);
  if ( isMeleeVariationAltPrev )
    altMeleeVariation = ps->weapCommon.altMeleeVariation;
  else
    altMeleeVariation = ps->weapCommon.meleeVariation;
  if ( previous )
  {
    isMeleeVariationAltPrev = ps->weapCommon.isMeleeVariationAltPrev;
    if ( isMeleeVariationAltPrev )
      altMeleeVariation = ps->weapCommon.altMeleeVariationPrev;
    else
      altMeleeVariation = ps->weapCommon.meleeVariationPrev;
  }
  if ( altMeleeVariation >= 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17753, ASSERT_TYPE_ASSERT, "(meleeAnimPkgIndex < (4))", (const char *)&queryFormat, "meleeAnimPkgIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
    __debugbreak();
  if ( (unsigned int)altMeleeVariation > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1177, ASSERT_TYPE_ASSERT, "(0 <= meleeSetIndex && meleeSetIndex < (4))", (const char *)&queryFormat, "0 <= meleeSetIndex && meleeSetIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
    __debugbreak();
  if ( v3 >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1178, ASSERT_TYPE_ASSERT, "(meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "meleeIndex < NUM_MELEE_ANIMS") )
    __debugbreak();
  v8 = altMeleeVariation + 4 * isMeleeVariationAltPrev;
  v9 = v8 + v3 + 2 * v8 + 262;
  if ( (unsigned int)(v8 + v3 + 2 * v8) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1186, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
    __debugbreak();
  return v9;
}

/*
==============
BG_MaxAmmo
==============
*/
__int64 BG_MaxAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  weapType_t WeaponType; 
  const WeaponDef *v7; 
  unsigned int MaxAmmo; 
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v13; 
  __int64 v14; 
  float ammunitionScale; 
  __int128 ammunitionScale_low; 
  WeaponAttachment **v17; 
  AttAmmunition *ammunition; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  if ( BG_WeaponTypeIsOffhand(WeaponType) && hasIncreasedOffhandAmmoPerk )
  {
    v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8432, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return (unsigned int)v7->iPerkMaxAmmo;
  }
  else
  {
    MaxAmmo = BG_WeaponOverrides_GetMaxAmmo(r_weapon);
    v10 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    _XMM6 = LODWORD(FLOAT_1_0);
    if ( WeaponAttachments_Internal )
    {
      v13 = attachments;
      v14 = WeaponAttachments_Internal;
      do
      {
        if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8455, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunitionScale = (*v13)->ammunitionScale;
        if ( ammunitionScale != 0.0 )
        {
          ammunitionScale_low = LODWORD((*v13)->ammunitionScale);
          *(float *)&ammunitionScale_low = (float)(ammunitionScale + *(float *)&_XMM6) - 1.0;
          _XMM6 = ammunitionScale_low;
        }
        ++v13;
        --v14;
      }
      while ( v14 );
    }
    if ( WeaponAttachments_Internal )
    {
      v17 = attachments;
      while ( 1 )
      {
        if ( !*v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8464, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunition = (*v17)->ammunition;
        if ( ammunition )
          break;
        ++v10;
        ++v17;
        if ( v10 >= WeaponAttachments_Internal )
          goto LABEL_24;
      }
      MaxAmmo = ammunition->maxAmmo;
    }
LABEL_24:
    __asm { vmaxss  xmm3, xmm6, xmm8 }
    v20 = LODWORD(FLOAT_1_0);
    *(float *)&v20 = 1.0 - *(float *)&_XMM3;
    *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
    *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
    _XMM1 = v20;
    __asm
    {
      vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vblendvps xmm1, xmm3, xmm7, xmm2
    }
    return (unsigned int)(int)(float)(_mm_cvtepi32_ps((__m128i)MaxAmmo).m128_f32[0] * *(float *)&_XMM1);
  }
}

/*
==============
BG_MeleeImpactRumble
==============
*/
RumbleInfo *BG_MeleeImpactRumble(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  RumbleInfo *meleeImpactRumble; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttRumbles *rumbles; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  meleeImpactRumble = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->meleeImpactRumble;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return meleeImpactRumble;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16400, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    rumbles = (*i)->rumbles;
    if ( rumbles )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return meleeImpactRumble;
  }
  return rumbles->meleeImpactRumble;
}

/*
==============
BG_MoveCycleJogTime
==============
*/
__int64 BG_MoveCycleJogTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 234i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_JOG, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11745, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleJogTime(): Additive Jog Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleSprintTime
==============
*/
__int64 BG_MoveCycleSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 236i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_SPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11766, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleSprintTime(): Additive Sprint Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleSuperSprintTime
==============
*/
__int64 BG_MoveCycleSuperSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 238i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_SUPERSPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleSuperSprintTime(): Additive SuperSprint Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleWalkTime
==============
*/
__int64 BG_MoveCycleWalkTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 232i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_START, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11724, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleWalkTime(): Additive Walk Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveTransitionTime
==============
*/
__int64 BG_MoveTransitionTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, movementTransition_t transitionType)
{
  __int64 v9; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  weapAnimFiles_t v11; 
  int AnimTime; 
  __int64 dependentAnimType; 
  __int64 dependentAnimTypea; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11845, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  switch ( transitionType )
  {
    case MOVE_TRANS_DOWNFROM_SUPERSPRINT:
      v9 = 250i64;
      break;
    case MOVE_TRANS_DOWNFROM_SPRINT:
      v9 = 248i64;
      break;
    case MOVE_TRANS_TO_WALK:
      goto LABEL_12;
    case MOVE_TRANS_TO_JOG:
      v9 = 242i64;
      break;
    case MOVE_TRANS_TO_SPRINT:
      v9 = 244i64;
      break;
    case MOVE_TRANS_TO_SUPERSPRINT:
      v9 = 246i64;
      break;
    default:
      LODWORD(dependentAnimType) = transitionType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11813, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown movementTransition_t encountered: %i", dependentAnimType) )
        __debugbreak();
LABEL_12:
      v9 = 240i64;
      break;
  }
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, v9, NUM_WEAP_ANIMS);
  switch ( transitionType )
  {
    case MOVE_TRANS_DOWNFROM_SUPERSPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SUPERSPRINT_TO_WALK;
      break;
    case MOVE_TRANS_DOWNFROM_SPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SPRINT_TO_WALK;
      break;
    case MOVE_TRANS_TO_WALK:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_JOG_TO_WALK;
      break;
    case MOVE_TRANS_TO_JOG:
      goto LABEL_21;
    case MOVE_TRANS_TO_SPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_WALK_TO_SPRINT;
      break;
    case MOVE_TRANS_TO_SUPERSPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_WALK_TO_SUPERSPRINT;
      break;
    default:
      LODWORD(dependentAnimTypea) = transitionType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11837, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown movementTransition_t encountered: %i", dependentAnimTypea) )
        __debugbreak();
LABEL_21:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_START;
      break;
  }
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, v11, isAlternate, isDualWielding, NULL);
  if ( AnimTime > 0 )
    return (unsigned int)AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MultipleReloadInterruptTime
==============
*/
__int64 BG_MultipleReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t animIndex)
{
  __int64 result; 
  char *WeaponName; 
  char output[1024]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10303, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  switch ( animIndex )
  {
    case WEAP_ANIM_ALT_MELEE_LAST:
    case WEAP_ANIM_RELOAD_ADS:
    case WEAP_ANIM_RELOAD_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 258i64);
      break;
    case WEAP_ANIM_RELOAD_EMPTY:
    case WEAP_ANIM_RELOAD_EMPTY_ADS:
    case WEAP_ANIM_RELOAD_EMPTY_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 260i64);
      break;
    case WEAP_ANIM_FAST_RELOAD_FIRST:
    case WEAP_ANIM_FAST_RELOAD_ADS:
    case WEAP_ANIM_FAST_RELOAD_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 288i64);
      break;
    case WEAP_ANIM_FAST_RELOAD_EMPTY:
    case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS:
    case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 290i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FIRST:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 272i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_2:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 274i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_3:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 276i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_4:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 278i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_5:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 280i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_6:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 282i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_7:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 284i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_8:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 286i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_FIRST:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 302i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_2:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 304i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_3:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 306i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_4:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 308i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_5:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 310i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_6:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 312i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_7:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 314i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_8:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 316i64);
      break;
    default:
      WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F5A5C0, 548i64, (unsigned int)animIndex, WeaponName);
      result = 0i64;
      break;
  }
  return result;
}

/*
==============
BG_NoADSWhenMagIsEmpty
==============
*/
_BOOL8 BG_NoADSWhenMagIsEmpty(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool noAdsWhenMagEmpty; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  noAdsWhenMagEmpty = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->noAdsWhenMagEmpty;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return noAdsWhenMagEmpty;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7491, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return noAdsWhenMagEmpty;
  }
  return sight->noAdsWhenMagEmpty;
}

/*
==============
BG_NoPartialReload
==============
*/
_BOOL8 BG_NoPartialReload(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bNoPartialReload; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bNoPartialReload = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bNoPartialReload;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bNoPartialReload;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7924, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bNoPartialReload;
  }
  return reload->noPartialReload;
}

/*
==============
BG_OffhandIsUnderbarrelWeapon
==============
*/
int BG_OffhandIsUnderbarrelWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, unsigned __int64 whichOffhandButton)
{
  __int16 v3; 
  const dvar_t *v6; 
  const dvar_t *v7; 

  v3 = whichOffhandButton;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1114, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1115, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) )
    return 0;
  v6 = DVARBOOL_bg_underbarrelWeaponEnabled;
  if ( !DVARBOOL_bg_underbarrelWeaponEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_underbarrelWeaponEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( !v6->current.enabled )
    return 0;
  v7 = DCONST_DVARBOOL_bg_offhandUnderbarrelEnabled;
  if ( !DCONST_DVARBOOL_bg_offhandUnderbarrelEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_offhandUnderbarrelEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled && (v3 & 0x1000) != 0 )
    return BG_AnyUnderbarrelWeaponEquipped(weaponMap, ps);
  else
    return 0;
}

/*
==============
BG_OffhandUnderbarrelInitAllowed
==============
*/
_BOOL8 BG_OffhandUnderbarrelInitAllowed(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1139, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x10u) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0xFu) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xAu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0i64;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2296, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagValues::ms_mpValue == ACTIVE && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, ACTIVE, 0x22u) || BG_IsTurretActive(ps) )
    return 0i64;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2184, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&ps->eFlags, ACTIVE, 0xBu) && ps->vehicleState.entity == 2047;
}

/*
==============
BG_OneHandedViewModelAnimsValid
==============
*/
_BOOL8 BG_OneHandedViewModelAnimsValid(const WeaponDef *weapDef)
{
  WeaponAnimPackage *szXAnimsRightHanded; 

  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2738, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnimsRightHanded = weapDef->szXAnimsRightHanded;
  return szXAnimsRightHanded && *((_QWORD *)szXAnimsRightHanded->anims + 236);
}

/*
==============
BG_PackClientWeaponFireEventParm
==============
*/
__int64 BG_PackClientWeaponFireEventParm(const tmat33_t<vec3_t> *fireAxis)
{
  vec3_t angles; 

  AxisToAngles(fireAxis, &angles);
  _XMM6 = 0i64;
  __asm
  {
    vroundss xmm3, xmm6, xmm2, 1
    vroundss xmm1, xmm6, xmm3, 1
  }
  return (unsigned __int16)(int)*(float *)&_XMM3 | ((unsigned __int16)(int)*(float *)&_XMM1 << 16);
}

/*
==============
BG_PickUpIcon
==============
*/
GfxImage *BG_PickUpIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  GfxImage *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->pickupIcon;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16199, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
    {
      result = ui->pickupIcon;
      if ( result )
        break;
    }
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->pickupIcon;
  }
  return result;
}

/*
==============
BG_PlayAltGesturesForOffhandWeapons
==============
*/
__int64 BG_PlayAltGesturesForOffhandWeapons(const Weapon *r_weapon)
{
  const WeaponDef *v1; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v1 )
    return v1->playAltGesturesForOffhandWeapons;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7449, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0x108D];
}

/*
==============
BG_PlayerDualWieldingCompatibleWeapon
==============
*/
char BG_PlayerDualWieldingCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  AmmoStore *v8; 
  unsigned int v9; 
  const Weapon *Weapon; 
  const Weapon *v11; 
  __int64 v13; 
  __int64 v14; 
  AmmoStore v15; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4965, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4966, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  r_ammo2 = *v8;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v9 >= 0xF )
    {
      LODWORD(v14) = 15;
      LODWORD(v13) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v9]);
    v11 = Weapon;
    if ( Weapon->weaponIdx )
    {
      if ( !isAlternate || BG_HasUnderbarrelAmmo(Weapon) )
      {
        result = *BG_AmmoStoreForWeapon(&v15, v11, isAlternate);
        if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
        {
          if ( BG_PlayerDualWieldingWeapon(weaponMap, ps, v11) )
            break;
        }
      }
    }
    if ( (int)++v9 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_PlayerHasCompatibleWeapon
==============
*/
char BG_PlayerHasCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  AmmoStore *v8; 
  unsigned int v9; 
  const Weapon *Weapon; 
  const Weapon *v11; 
  __int64 v13; 
  __int64 v14; 
  AmmoStore v15; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4937, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4938, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  r_ammo2 = *v8;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v9 >= 0xF )
    {
      LODWORD(v14) = 15;
      LODWORD(v13) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v9]);
    v11 = Weapon;
    if ( Weapon->weaponIdx )
    {
      if ( !isAlternate || BG_HasUnderbarrelAmmo(Weapon) )
      {
        result = *BG_AmmoStoreForWeapon(&v15, v11, isAlternate);
        if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
          break;
      }
    }
    if ( (int)++v9 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_PlayerLastWeaponHand
==============
*/
PlayerHandIndex BG_PlayerLastWeaponHand(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6125, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6126, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  return BG_PlayerLastWeaponHandForWeapon(weaponMap, ps, CurrentWeaponForPlayer);
}

/*
==============
BG_PlayerLastWeaponHandForViewWeapon
==============
*/
PlayerHandIndex BG_PlayerLastWeaponHandForViewWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6115, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6116, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  return BG_PlayerLastWeaponHandForWeapon(weaponMap, ps, ViewmodelWeapon);
}

/*
==============
BG_PlayerLastWeaponHandForWeapon
==============
*/
_BOOL8 BG_PlayerLastWeaponHandForWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6136, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6137, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_PlayerDualWieldingWeapon(weaponMap, ps, r_weapon) || BG_HasLadderHand(ps);
}

/*
==============
BG_PlayerOffhandGetSlotName
==============
*/
__int64 BG_PlayerOffhandGetSlotName(const OffhandSlot slot)
{
  int v3; 
  int v4; 
  int v5[6]; 

  v5[0] = scr_const.none;
  v5[1] = scr_const.primaryoffhand;
  v5[2] = scr_const.secondaryoffhand;
  v5[3] = scr_const.specialoffhand;
  v5[4] = scr_const.scriptoffhand;
  v5[5] = scr_const.tauntoffhand;
  if ( (unsigned __int8)slot >= OFFHAND_SLOT_COUNT )
  {
    v4 = 6;
    v3 = (unsigned __int8)slot;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4767, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( OFFHAND_SLOT_COUNT )", "slot doesn't index OFFHAND_SLOT_COUNT\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (unsigned int)v5[(unsigned __int8)slot];
}

/*
==============
BG_PlayerUsesNVGHalfADS
==============
*/
char BG_PlayerUsesNVGHalfADS(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  const BgWeaponMap *v4; 
  const Weapon *ViewmodelWeapon; 
  bool v6; 
  int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17772, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17773, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2222, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 7u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_UP_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
  {
    v4 = pmoveHandler->GetWeaponMap(pmoveHandler);
    ViewmodelWeapon = BG_GetViewmodelWeapon(v4, ps);
    v6 = BG_UsingAlternate(ps);
    v7 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v6, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( !WeaponAttachments_Internal )
      return 1;
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17794, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      sight = (*i)->sight;
      if ( sight )
      {
        if ( sight->blockNVGADS )
          break;
      }
      if ( ++v7 >= WeaponAttachments_Internal )
        return 1;
    }
  }
  return 0;
}

/*
==============
BG_PlayerWeaponCountWeaponsBySlot
==============
*/
__int64 BG_PlayerWeaponCountWeaponsBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  unsigned int v6; 
  unsigned int i; 
  const Weapon *Weapon; 
  const WeaponDef *v9; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  weapInventoryType_t inventoryType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4799, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4800, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = 0;
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
    {
      v9 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( Weapon->weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      inventoryType = v9->inventoryType;
      if ( (inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY) && *(_DWORD *)p_slot == slot )
        ++v6;
    }
  }
  return v6;
}

/*
==============
BG_PlayerWeaponGetCycleSlot
==============
*/
__int64 BG_PlayerWeaponGetCycleSlot(WeaponSlot currentSlot, int cycleSlot)
{
  WeaponSlot outNeededSlot; 

  if ( BG_GameInterface_PlayerWeaponGetCycleSlot(currentSlot, cycleSlot, &outNeededSlot) )
    return (unsigned int)outNeededSlot;
  if ( cycleSlot )
    return (unsigned int)(currentSlot == WEAPON_SLOT_PRIMARY) + 1;
  return (unsigned int)currentSlot;
}

/*
==============
BG_PlayerWeaponGetEquippedSlot
==============
*/
const PlayerEquippedWeaponState *BG_PlayerWeaponGetEquippedSlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *result; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4904, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4905, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
  if ( result )
    return (const PlayerEquippedWeaponState *)(unsigned int)result->slot;
  return result;
}

/*
==============
BG_PlayerWeaponGetSlot
==============
*/
__int64 BG_PlayerWeaponGetSlot(const Weapon *r_weapon)
{
  const WeaponDef *v1; 
  weapInventoryType_t inventoryType; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4885, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  inventoryType = v1->inventoryType;
  if ( inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY )
    return (unsigned int)v1->slot;
  else
    return 0i64;
}

/*
==============
BG_PlayerWeaponGetSlotName
==============
*/
const char *BG_PlayerWeaponGetSlotName(const WeaponSlot slot)
{
  __int64 v1; 
  int v4; 

  v1 = slot;
  if ( (unsigned int)slot >= WEAPON_SLOT_NUM )
  {
    v4 = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4748, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( WEAPON_SLOT_NUM )", "slot doesn't index WEAPON_SLOT_NUM\n\t%i not in [0, %i)", slot, v4) )
      __debugbreak();
  }
  return s_weaponSlotNames[v1];
}

/*
==============
BG_PlayerWeaponIsSlotFull
==============
*/
bool BG_PlayerWeaponIsSlotFull(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  int v6; 
  unsigned int v7; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4922, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4923, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = 0;
  if ( slot == WEAPON_SLOT_PRIMARY )
  {
    v7 = 2;
  }
  else if ( slot == WEAPON_SLOT_HEAVY || slot == WEAPON_SLOT_MELEE )
  {
    v7 = 1;
  }
  else
  {
    v7 = 1;
    if ( slot != WEAPON_SLOT_EXECUTION )
    {
      if ( slot == WEAPON_SLOT_ACCESSORY )
        v6 = 1;
      v7 = v6;
    }
  }
  return BG_PlayerWeaponCountWeaponsBySlot(weaponMap, ps, slot) >= v7;
}

/*
==============
BG_PreFireSound
==============
*/
const SndAliasList *BG_PreFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 80);
}

/*
==============
BG_PreFireTime
==============
*/
__int64 BG_PreFireTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 230i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_PredictionGetClientTrajectoryBlendOutTime
==============
*/
__int64 BG_PredictionGetClientTrajectoryBlendOutTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  __int64 result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  projectile = WeaponPrimaryAttachment->projectile;
  if ( !projectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  if ( !projectile->isPredictedProjectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  result = (unsigned int)projectile->clientTrajectoryBlendOutTime;
  if ( !(_DWORD)result )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  return result;
}

/*
==============
BG_PredictionGetServerTrajectoryBlendInTime
==============
*/
__int64 BG_PredictionGetServerTrajectoryBlendInTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  __int64 result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  projectile = WeaponPrimaryAttachment->projectile;
  if ( !projectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  if ( !projectile->isPredictedProjectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  result = (unsigned int)projectile->serverTrajectoryBlendInTime;
  if ( !(_DWORD)result )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  return result;
}

/*
==============
BG_ProceduralGunMotionDisabled
==============
*/
bool BG_ProceduralGunMotionDisabled(const playerState_s *ps)
{
  const dvar_t *v1; 
  bool result; 

  v1 = DCONST_DVARBOOL_bg_disableProceduralGunMotion;
  if ( !DCONST_DVARBOOL_bg_disableProceduralGunMotion && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_disableProceduralGunMotion") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
    return 1;
  result = BG_Skydive_IsSkydiving(ps);
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_ProjBeaconEffect
==============
*/
FxCombinedDef BG_ProjBeaconEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)v4->projBeaconEffect.particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17621, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (FxCombinedDef)v4->projBeaconEffect.particleSystemDef;
  }
  return (FxCombinedDef)projectile->projBeaconEffect.particleSystemDef;
}

/*
==============
BG_ProjBodyEffect
==============
*/
FxCombinedDef BG_ProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projBodyEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17574, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projBodyEffect.particleSystemDef;
}

/*
==============
BG_ProjDisabledTimeoutEffect
==============
*/
_BOOL8 BG_ProjDisabledTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableFxOnTimeout;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17352, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableFxOnTimeout;
  }
  return projectile->disableFxOnTimeout;
}

/*
==============
BG_ProjDudEffect
==============
*/
FxCombinedDef BG_ProjDudEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projDudEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17263, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projDudEffect.particleSystemDef;
}

/*
==============
BG_ProjDudSound
==============
*/
SndAliasList *BG_ProjDudSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17310, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projDudSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 640i64);
  }
}

/*
==============
BG_ProjExplosionEffect
==============
*/
FxCombinedDef BG_ProjExplosionEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17149, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projExplosionEffect.particleSystemDef;
}

/*
==============
BG_ProjExplosionEffectForceNormalUp
==============
*/
_BOOL8 BG_ProjExplosionEffectForceNormalUp(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool projExplosionEffectForceNormalUp; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projExplosionEffectForceNormalUp = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffectForceNormalUp;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projExplosionEffectForceNormalUp;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17175, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projExplosionEffectForceNormalUp;
  }
  return projectile->projExplosionEffectForceNormalUp;
}

/*
==============
BG_ProjExplosionEffectInheritParentDirection
==============
*/
_BOOL8 BG_ProjExplosionEffectInheritParentDirection(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffectInheritParentDirection;
}

/*
==============
BG_ProjExplosionReflectionClass
==============
*/
WeaponSFXPackage *BG_ProjExplosionReflectionClass(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *result; 
  unsigned int projExplosionReflClass; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  result = BG_GetSfxPackage(r_weapon, isAlternate);
  if ( result )
  {
    projExplosionReflClass = result->projExplosionReflClass;
    v6 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17237, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        projectile = (*i)->projectile;
        if ( projectile )
          break;
        if ( ++v6 >= WeaponAttachments_Internal )
          return (WeaponSFXPackage *)projExplosionReflClass;
      }
      return (WeaponSFXPackage *)projectile->projExplosionReflClass;
    }
    return (WeaponSFXPackage *)projExplosionReflClass;
  }
  return result;
}

/*
==============
BG_ProjExplosionSound
==============
*/
SndAliasList *BG_ProjExplosionSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17205, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projExplosionSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 632i64);
  }
}

/*
==============
BG_ProjExplosionType
==============
*/
__int64 BG_ProjExplosionType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapProjExposion_t projExplosion; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projExplosion = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosion;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)projExplosion;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17123, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)projExplosion;
  }
  return (unsigned int)projectile->projExplosionType;
}

/*
==============
BG_ProjIgnitionDelay
==============
*/
__int64 BG_ProjIgnitionDelay(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int projIgnitionDelay; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projIgnitionDelay = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projIgnitionDelay;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projIgnitionDelay;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17646, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projIgnitionDelay;
  }
  return (unsigned int)projectile->projIgnitionDelay;
}

/*
==============
BG_ProjIgnitionEffect
==============
*/
FxCombinedDef BG_ProjIgnitionEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projIgnitionEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17672, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projIgnitionEffect.particleSystemDef;
}

/*
==============
BG_ProjIgnitionSound
==============
*/
SndAliasList *BG_ProjIgnitionSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17694, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projIgnitionSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 656i64);
  }
}

/*
==============
BG_ProjImpactExplode
==============
*/
_BOOL8 BG_ProjImpactExplode(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bProjImpactExplode; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bProjImpactExplode = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjImpactExplode;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bProjImpactExplode;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17399, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bProjImpactExplode;
  }
  return projectile->projImpactExplode;
}

/*
==============
BG_ProjTimeoutEffect
==============
*/
FxCombinedDef BG_ProjTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projTimeoutEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17288, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projTimeoutEffect.particleSystemDef;
}

/*
==============
BG_ProjTimeoutSound
==============
*/
SndAliasList *BG_ProjTimeoutSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17331, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projTimeoutSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 648i64);
  }
}

/*
==============
BG_ProjTrailEffect
==============
*/
FxCombinedDef BG_ProjTrailEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projTrailEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17599, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projTrailEffect.particleSystemDef;
}

/*
==============
BG_ProjTrajectoryEvents
==============
*/
bool BG_ProjTrajectoryEvents(const Weapon *r_weapon, bool isAlternate)
{
  bool result; 

  result = Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED);
  if ( result )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjTrajectoryEvents;
  return result;
}

/*
==============
BG_ProjWhizByEnabled
==============
*/
bool BG_ProjWhizByEnabled(const Weapon *r_weapon, bool isAlternate)
{
  bool result; 

  result = Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED);
  if ( result )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjWhizByEnabled;
  return result;
}

/*
==============
BG_ProjectileActivateDist
==============
*/
__int64 BG_ProjectileActivateDist(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iProjectileActivateDist; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iProjectileActivateDist = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iProjectileActivateDist;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iProjectileActivateDist;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17073, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iProjectileActivateDist;
  }
  return (unsigned int)projectile->projectileActivateDist;
}

/*
==============
BG_ProjectileModel
==============
*/
XModel *BG_ProjectileModel(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  XModel *projectileModel; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projectileModel = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projectileModel;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projectileModel;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17098, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projectileModel;
  }
  return projectile->projectileModel;
}

/*
==============
BG_QuickDropTime
==============
*/
__int64 BG_QuickDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 142i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_QuickRaiseTime
==============
*/
__int64 BG_QuickRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 144i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RaiseTime
==============
*/
__int64 BG_RaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 134i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberBoltTime
==============
*/
__int64 BG_RechamberBoltTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 14i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberTime
==============
*/
__int64 BG_RechamberTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 10i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberTimeOneHanded
==============
*/
__int64 BG_RechamberTimeOneHanded(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 12i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberWhileADS
==============
*/
_BOOL8 BG_RechamberWhileADS(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bRechamberWhileAds; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bRechamberWhileAds = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRechamberWhileAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bRechamberWhileAds;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7467, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bRechamberWhileAds;
  }
  return sight->rechamberWhileAds;
}

/*
==============
BG_ReloadAddTime
==============
*/
__int64 BG_ReloadAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  bool v11; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10678, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v11 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 80, NUM_WEAP_ANIMS);
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 82, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadAmmoAdd
==============
*/
__int64 BG_ReloadAmmoAdd(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iReloadAmmoAdd; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iReloadAmmoAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iReloadAmmoAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iReloadAmmoAdd;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8627, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iReloadAmmoAdd;
  }
  return (unsigned int)ammunition->reloadAmmoAdd;
}

/*
==============
BG_ReloadDisabled
==============
*/
_BOOL8 BG_ReloadDisabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool reloadDisabled; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7944, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  reloadDisabled = v4->reloadDisabled;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return reloadDisabled;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return reloadDisabled;
  }
  return reload->reloadDisabled;
}

/*
==============
BG_ReloadEmptyAddTime
==============
*/
__int64 BG_ReloadEmptyAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  bool v10; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10705, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v10 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 88i64, NUM_WEAP_ANIMS);
  if ( !v10 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 90i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEmptyInterruptTime
==============
*/
__int64 BG_ReloadEmptyInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10494, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 260i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 290i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEmptyTime
==============
*/
__int64 BG_ReloadEmptyTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool *hasFastReloadOverride)
{
  bool v9; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  v9 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, 0, WEAP_ANIM_FAST_RELOAD_EMPTY);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 76i64, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v9 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 78i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEndInterruptTime
==============
*/
__int64 BG_ReloadEndInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  unsigned int v10; 
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 
  __int64 v13; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10618, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = (unsigned int)ps->weapState[v6].weapHandFlags >> 2;
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding);
  if ( (v10 & 1) != 0 )
  {
    offset = 266i64;
    v13 = 296i64;
  }
  else
  {
    offset = 264i64;
    v13 = 294i64;
  }
  if ( IsUsingFastReloadStateTimer )
    offset = v13;
  return BG_InterruptTimeCommon(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEndRechamberInterruptTime
==============
*/
__int64 BG_ReloadEndRechamberInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  unsigned int v10; 
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 
  __int64 v13; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10638, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = (unsigned int)ps->weapState[v6].weapHandFlags >> 2;
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding);
  if ( (v10 & 1) != 0 )
  {
    offset = 270i64;
    v13 = 300i64;
  }
  else
  {
    offset = 268i64;
    v13 = 298i64;
  }
  if ( IsUsingFastReloadStateTimer )
    offset = v13;
  return BG_InterruptTimeCommon(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEndRechamberTime
==============
*/
__int64 BG_ReloadEndRechamberTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, int *outShellEjectTime, bool *hasFastReloadOverride)
{
  unsigned __int64 v11; 
  bool v12; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned __int16 v14; 
  unsigned int v15; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  v11 = ((unsigned __int64)(unsigned int)ps->weapState[hand].weapHandFlags >> 2) & 1;
  v12 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 112, NUM_WEAP_ANIMS);
  *outShellEjectTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 114, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v12 )
    return WeaponFieldTimeWithDependentAnimation;
  v14 = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 124, NUM_WEAP_ANIMS);
  v15 = v14;
  if ( !v14 )
    return WeaponFieldTimeWithDependentAnimation;
  *outShellEjectTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 126, NUM_WEAP_ANIMS);
  result = v15;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEndTime
==============
*/
__int64 BG_ReloadEndTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  unsigned __int64 weapHandFlags; 
  bool v11; 
  __int64 v12; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  weapHandFlags = (unsigned int)ps->weapState[hand].weapHandFlags;
  v11 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_END);
  v12 = (weapHandFlags >> 2) & 1;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64 * (unsigned int)v12 + 108, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64 * (unsigned int)v12 + 120, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadInterruptTime
==============
*/
__int64 BG_ReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10291, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 258i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 288i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadMultipleAnimOverride
==============
*/
__int64 BG_ReloadMultipleAnimOverride(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex handIndex, int empty)
{
  const Weapon *CurrentWeaponForPlayer; 
  int AmmoNotInClip; 
  __int64 v13; 
  int v14; 
  int v15; 
  ReloadType ReloadType; 
  int ammoInClipBeforeReload; 
  int v20; 
  bool v21; 
  char v22; 
  const PlayerWeaponAnimArrays *v23; 
  bool v25; 
  unsigned int v26; 
  __int64 ammoInClip; 
  __int64 ammoInClipa; 
  __int64 reloadAnimFile; 
  int ClipSize; 
  __int64 v31; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11015, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11016, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  ClipSize = BG_GetClipSize(ps, CurrentWeaponForPlayer, isAlternate);
  AmmoNotInClip = BG_GetAmmoNotInClip(ps, CurrentWeaponForPlayer, isAlternate);
  v13 = handIndex;
  v31 = v13 * 80;
  v14 = ClipSize - ps->weapState[v13].ammoInClipBeforeReload;
  if ( v14 > AmmoNotInClip )
    v14 = AmmoNotInClip;
  v15 = v14 - 1;
  ReloadType = BG_GetReloadType(r_weapon, isAlternate);
  if ( ReloadType == RELOAD_TYPE_MULTIPLE_PERCENTAGE )
  {
    if ( empty )
    {
      ammoInClipBeforeReload = ps->weapState[v13].ammoInClipBeforeReload;
      goto LABEL_44;
    }
    BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    _XMM0 = 0i64;
    __asm { vroundss xmm4, xmm0, xmm2, 1 }
    v15 = ((int)*(float *)&_XMM4 + v14 - 1) / (int)*(float *)&_XMM4 - 1;
    ReloadType = RELOAD_TYPE_MULTIPLE_PERCENTAGE;
  }
  v20 = 0;
  if ( v15 > 0 )
    v20 = v15;
  if ( (unsigned int)(ReloadType - 2) > 1 )
    goto LABEL_43;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10993, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( v20 >= 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10995, ASSERT_TYPE_ASSERT, "(ammoNeeded < 8)", (const char *)&queryFormat, "ammoNeeded < MAX_RELOAD_MULTIPLE_ANIMS") )
    __debugbreak();
  v21 = BG_PlayerDualWielding(ps) != 0;
  if ( !BG_UsingAlternate(ps) )
  {
    if ( !v21 )
      goto LABEL_28;
    goto LABEL_26;
  }
  if ( v21 )
  {
LABEL_26:
    if ( handIndex == WEAPON_HAND_LEFT )
      goto LABEL_27;
LABEL_28:
    v22 = 0;
    goto LABEL_29;
  }
LABEL_27:
  v22 = 1;
LABEL_29:
  v23 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11002, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( v22 )
    v23 = (const PlayerWeaponAnimArrays *)((char *)v23 + 4976);
  if ( v23->normalAnimArray[g_reloadMultipleAnimMap[v20]] )
  {
    if ( (unsigned int)v20 >= 8 )
    {
      LODWORD(ammoInClip) = v20;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11059, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( ( sizeof( *array_counter( g_reloadMultipleAnimMap ) ) + 0 ) )", "animIndex doesn't index ARRAY_COUNT( g_reloadMultipleAnimMap )\n\t%i not in [0, %i)", ammoInClip, 8) )
        __debugbreak();
      LODWORD(reloadAnimFile) = 8;
      LODWORD(ammoInClipa) = v20;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11060, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( ( sizeof( *array_counter( g_reloadMultipleFastAnimMap ) ) + 0 ) )", "animIndex doesn't index ARRAY_COUNT( g_reloadMultipleFastAnimMap )\n\t%i not in [0, %i)", ammoInClipa, reloadAnimFile) )
        __debugbreak();
    }
    if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, *(unsigned int *)((char *)&ps->weapState[0].ammoInClipBeforeReload + v31), g_reloadMultipleFastAnimMap[v20]) )
      return (unsigned int)g_reloadMultipleFastAnimMap[v20];
    else
      return (unsigned int)g_reloadMultipleAnimMap[v20];
  }
LABEL_43:
  ammoInClipBeforeReload = *(unsigned int *)((char *)&ps->weapState[0].ammoInClipBeforeReload + v31);
  if ( empty )
  {
LABEL_44:
    if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, ammoInClipBeforeReload, WEAP_ANIM_FAST_RELOAD_EMPTY) )
      return 307i64;
    else
      return 289i64;
  }
  v25 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, ammoInClipBeforeReload, WEAP_ANIM_FAST_RELOAD_FIRST);
  v26 = 286;
  if ( v25 )
    return 304;
  return v26;
}

/*
==============
BG_ReloadMultipleTimeBulletBased
==============
*/
__int64 BG_ReloadMultipleTimeBulletBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  __int64 v7; 
  bool *v10; 
  bool v11; 
  bool v12; 
  char *v13; 
  int v14; 
  unsigned int v15; 
  int v16; 
  int started; 
  int v18; 
  __int64 isDualWielding; 
  bool v21; 

  v7 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10379, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(isDualWielding) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10380, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( ( sizeof( *array_counter( ps->weapState ) ) + 0 ) )", "hand doesn't index ARRAY_COUNT( ps->weapState )\n\t%i not in [0, %i)", isDualWielding, 2) )
      __debugbreak();
  }
  v10 = hasFastReloadOverride;
  v11 = isAlternate;
  v12 = isAlternate;
  v13 = (char *)ps + 80 * v7;
  *hasFastReloadOverride = 0;
  LODWORD(hasFastReloadOverride) = BG_GetAmmoNotInClip(ps, r_weapon, v12);
  v14 = BG_GetClipSize(ps, r_weapon, v11) - *((_DWORD *)v13 + 345);
  v15 = *((_DWORD *)v13 + 339) - 18;
  v21 = 0;
  if ( v15 > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10391, ASSERT_TYPE_ASSERT, "(( (weapState.weaponState == WEAPON_RELOADING) || (weapState.weaponState == WEAPON_RELOAD_START) || ( (weapState.weaponState == WEAPON_RELOAD_END) || (weapState.weaponState == WEAPON_RELOAD_END_RECHAMBER) ) ))", (const char *)&queryFormat, "WEAPONSTATE_RELOADING( weapState.weaponState )") )
    __debugbreak();
  v16 = BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v7, r_weapon, v11, 0, *((_DWORD *)v13 + 345), &v21);
  *v10 |= v21;
  started = BG_ReloadStartAddTime(ps, r_weapon, v11, 0, *((_DWORD *)v13 + 345), 0, &v21);
  *v10 |= v21;
  v18 = BG_ReloadAddTime(ps, r_weapon, v11, 0, *((_DWORD *)v13 + 345), 0, &v21);
  *v10 |= v21;
  if ( v14 > (int)hasFastReloadOverride )
    v14 = (int)hasFastReloadOverride;
  if ( v14 <= 1 )
    return (unsigned int)(started + v16);
  else
    return (unsigned int)(v16 + started + v18 * (v14 - 1));
}

/*
==============
BG_ReloadMultipleTimePercentageBased
==============
*/
__int64 BG_ReloadMultipleTimePercentageBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  __int64 v7; 
  bool *v9; 
  int AmmoNotInClip; 
  int ClipSize; 
  int v12; 
  int ammoInClipBeforeReload; 
  int v16; 
  int started; 
  int v18; 
  int v19; 
  __int64 isSecondRound; 
  int v22; 
  bool v24; 

  v7 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10419, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(isSecondRound) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10420, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( ( sizeof( *array_counter( ps->weapState ) ) + 0 ) )", "hand doesn't index ARRAY_COUNT( ps->weapState )\n\t%i not in [0, %i)", isSecondRound, 2) )
      __debugbreak();
  }
  v9 = hasFastReloadOverride;
  *hasFastReloadOverride = 0;
  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  AmmoNotInClip = BG_GetAmmoNotInClip(ps, r_weapon, isAlternate);
  ClipSize = BG_GetClipSize(ps, r_weapon, isAlternate);
  v24 = 0;
  v12 = ClipSize;
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm3, 1 }
  ammoInClipBeforeReload = ps->weapState[v7].ammoInClipBeforeReload;
  v16 = ClipSize - ammoInClipBeforeReload;
  if ( ClipSize - ammoInClipBeforeReload > AmmoNotInClip )
    v16 = AmmoNotInClip;
  LODWORD(hasFastReloadOverride) = ((int)*(float *)&_XMM1 + v16 - 1) / (int)*(float *)&_XMM1;
  started = BG_ReloadStartAddTime(ps, r_weapon, isAlternate, 0, ammoInClipBeforeReload, 0, &v24);
  *v9 |= v24;
  v18 = BG_ReloadAddTime(ps, r_weapon, isAlternate, 0, ps->weapState[v7].ammoInClipBeforeReload, 0, &v24);
  *v9 |= v24;
  v22 = v18;
  v19 = BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v7, r_weapon, isAlternate, 0, ps->weapState[v7].ammoInClipBeforeReload, &v24);
  *v9 |= v24;
  if ( v12 == v16 )
  {
    v19 = BG_ReloadEmptyTime(ps, pmoveHandler, (const PlayerHandIndex)v7, r_weapon, isAlternate, 0, &v24);
    *v9 |= v24;
  }
  if ( (int)hasFastReloadOverride <= 1 )
    return (unsigned int)(v19 + started);
  else
    return (unsigned int)(started + v19 + v22 * ((_DWORD)hasFastReloadOverride - 1));
}

/*
==============
BG_ReloadStartAdd
==============
*/
__int64 BG_ReloadStartAdd(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iReloadStartAdd; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iReloadStartAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iReloadStartAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iReloadStartAdd;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8651, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iReloadStartAdd;
  }
  return (unsigned int)ammunition->reloadStartAdd;
}

/*
==============
BG_ReloadStartAddTime
==============
*/
__int64 BG_ReloadStartAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  bool v11; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10729, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v11 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 100, NUM_WEAP_ANIMS);
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 102, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadStartInterruptTime
==============
*/
__int64 BG_ReloadStartInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10608, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 262i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 292i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadStartTime
==============
*/
__int64 BG_ReloadStartTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 96i64, NUM_WEAP_ANIMS);
  if ( !BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_START) )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 98i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadTime
==============
*/
__int64 BG_ReloadTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  __int64 result; 

  *hasFastReloadOverride = 0;
  if ( !BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_FIRST) )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 70i64, NUM_WEAP_ANIMS);
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 72i64, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = (unsigned __int16)result != 0;
  if ( !(_WORD)result )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 70i64, NUM_WEAP_ANIMS);
  return result;
}

/*
==============
BG_RemoveIgnoreEntFromBP
==============
*/
void BG_RemoveIgnoreEntFromBP(BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 
  int v5; 
  int v6; 
  bool v7; 
  int *ignoreHitEntityQueue; 
  int *v9; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 584, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  ignoreHitEntCount = bp->ignoreHitEntCount;
  if ( ignoreHitEntCount >= 16 || ignoreHitEntCount )
  {
    v5 = bp->ignoreHitEntCount;
    v6 = 0;
    v7 = v5 < 0;
    if ( v5 > 0 )
    {
      ignoreHitEntityQueue = bp->ignoreHitEntityQueue;
      while ( *ignoreHitEntityQueue != entityIndex )
      {
        ++v6;
        ++ignoreHitEntityQueue;
        if ( v6 >= v5 )
          goto LABEL_12;
      }
      v9 = &bp->ignoreHitEntityQueue[(v5 - 1) % 16];
      bp->ignoreHitEntityQueue[v6] = *v9;
      *v9 = -1;
      v5 = --bp->ignoreHitEntCount;
LABEL_12:
      v7 = v5 < 0;
    }
    if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 607, ASSERT_TYPE_ASSERT, "(bp->ignoreHitEntCount >= 0)", (const char *)&queryFormat, "bp->ignoreHitEntCount >= 0") )
      __debugbreak();
  }
}

/*
==============
BG_RemoveWeaponAndGlobalAmmo
==============
*/
void BG_RemoveWeaponAndGlobalAmmo(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  AmmoStore *v8; 
  char v9; 
  unsigned int v10; 
  const Weapon *Weapon; 
  const Weapon *v12; 
  int v13; 
  AmmoStore v15; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3599, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3600, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  v10 = 0;
  r_ammo2 = *v8;
  do
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(weaponMap, ps->weaponsEquipped[v10]);
    v12 = Weapon;
    if ( isAlternate || memcmp_0(Weapon, r_weapon, 0x3Cui64) )
    {
      result = *BG_AmmoStoreForWeapon(&v15, v12, 0);
      if ( BG_IsAmmoCompatible(&result, &r_ammo2) || BG_HasUnderbarrelAmmo(v12) && (result = *BG_AmmoStoreForWeapon(&v15, v12, 1), BG_IsAmmoCompatible(&result, &r_ammo2)) )
        v9 = 1;
    }
    else
    {
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 851, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 852, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      weaponMap->SetWeapon(weaponMap, &ps->weaponsEquipped[v10], &NULL_WEAPON);
    }
    ++v10;
  }
  while ( v10 < 0xF );
  v13 = 0;
  if ( !v9 )
  {
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1288, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    while ( !BG_IsAmmoCompatible(&ps->weapCommon.ammoNotInClip[v13].ammoType, &r_ammo2) )
    {
      if ( (unsigned int)++v13 >= 0xF )
        return;
    }
    if ( (playerState_s *)((char *)ps + 68 * v13) != (playerState_s *)-1912i64 )
    {
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.weaponIdx = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.stickerIndices[3] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.weaponAttachments[2] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.weaponAttachments[10] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.attachmentVariationIndices[5] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.attachmentVariationIndices[13] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.attachmentVariationIndices[21] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v13].ammoType.weapon.weaponCamo = 0i64;
      ps->weapCommon.ammoNotInClip[v13].ammoCount = 0;
    }
  }
}

/*
==============
BG_RequireAmmoUsedPerShot
==============
*/
_BOOL8 BG_RequireAmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8589, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  }
  return ammunition->requireAmmoUsedPerShot;
}

/*
==============
BG_RequiredAmmoPerShot
==============
*/
__int64 BG_RequiredAmmoPerShot(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v6; 
  WeaponAttachment **v7; 
  AttAmmunition *ammunition; 
  bool requireAmmoUsedPerShot; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  __int64 result; 
  int iAmmoUsedPerShot; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v6 = 0;
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8589, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunition = (*v7)->ammunition;
      if ( ammunition )
        break;
      ++v6;
      ++v7;
      if ( v6 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    requireAmmoUsedPerShot = ammunition->requireAmmoUsedPerShot;
  }
  else
  {
LABEL_8:
    requireAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  }
  if ( !requireAmmoUsedPerShot )
    return 1i64;
  v10 = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( v10 )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8567, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      result = (unsigned int)(*v11)->ammoUsedPerShotOverride;
      if ( (int)result > 0 )
        break;
      ++v2;
      ++v11;
      if ( v2 >= v10 )
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    iAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iAmmoUsedPerShot;
    result = 1i64;
    if ( iAmmoUsedPerShot > 0 )
      return (unsigned int)iAmmoUsedPerShot;
  }
  return result;
}

/*
==============
BG_ScaleKickValue
==============
*/
void BG_ScaleKickValue(float *kickPitch, float *kickYaw, const float kickMagMin)
{
  float v5; 
  float v6; 
  float v7; 
  float v8; 

  if ( !kickPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3724, ASSERT_TYPE_ASSERT, "(kickPitch)", (const char *)&queryFormat, "kickPitch") )
    __debugbreak();
  if ( !kickYaw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3725, ASSERT_TYPE_ASSERT, "(kickYaw)", (const char *)&queryFormat, "kickYaw") )
    __debugbreak();
  v5 = *kickPitch;
  v6 = *kickYaw;
  v7 = (float)(v6 * v6) + (float)(v5 * v5);
  if ( v7 > 0.0000010000001 && v7 < (float)(kickMagMin * kickMagMin) )
  {
    v8 = fsqrt(v7);
    *kickPitch = (float)(kickMagMin / v8) * v5;
    *kickYaw = (float)(kickMagMin / v8) * v6;
  }
}

/*
==============
BG_ScopeOutlinesAgents
==============
*/
bool BG_ScopeOutlinesAgents(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7816, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineAgents;
}

/*
==============
BG_ScopeOutlinesCharacters
==============
*/
bool BG_ScopeOutlinesCharacters(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7794, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineCharacters;
}

/*
==============
BG_ScopeOutlinesEnemies
==============
*/
_BOOL8 BG_ScopeOutlinesEnemies(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool outlineEnemies; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  outlineEnemies = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->outlineEnemies;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return outlineEnemies;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7685, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return outlineEnemies;
  }
  return outline->outlineEnemies;
}

/*
==============
BG_ScopeOutlinesLockOn
==============
*/
bool BG_ScopeOutlinesLockOn(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7751, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineLockOn;
}

/*
==============
BG_ScopeOutlinesScriptMovers
==============
*/
bool BG_ScopeOutlinesScriptMovers(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7729, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineScriptMovers;
}

/*
==============
BG_ScopeOutlinesTurrets
==============
*/
bool BG_ScopeOutlinesTurrets(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7773, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineTurrets;
}

/*
==============
BG_ScopeOutlinesVehicles
==============
*/
bool BG_ScopeOutlinesVehicles(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7707, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineVehicles;
}

/*
==============
BG_ScopeToggleOffInterruptTime
==============
*/
__int64 BG_ScopeToggleOffInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 358i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_ScopeToggleOffTime
==============
*/
__int64 BG_ScopeToggleOffTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 
  bool v7; 
  const char *WeaponNameComplete; 
  char output[1024]; 

  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 256i64, NUM_WEAP_ANIMS);
  if ( (unsigned __int16)result == 0xFFFF )
  {
    v7 = BG_UsingAlternate(ps);
    WeaponNameComplete = BG_GetWeaponNameComplete(r_weapon, v7, output, 0x400u);
    Com_PrintError(17, "ERROR: Weapon \"%s\" is set up as hybrid scope but it does not have a scope toggle off state timer set. Using default scope toggle time (%d).\n", WeaponNameComplete, 100i64);
    return 100i64;
  }
  return result;
}

/*
==============
BG_ScopeToggleOnInterruptTime
==============
*/
__int64 BG_ScopeToggleOnInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 356i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_ScopeToggleOnTime
==============
*/
__int64 BG_ScopeToggleOnTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 
  bool v7; 
  const char *WeaponNameComplete; 
  char output[1024]; 

  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 254i64, NUM_WEAP_ANIMS);
  if ( (unsigned __int16)result == 0xFFFF )
  {
    v7 = BG_UsingAlternate(ps);
    WeaponNameComplete = BG_GetWeaponNameComplete(r_weapon, v7, output, 0x400u);
    Com_PrintError(17, "ERROR: Weapon \"%s\" is set up as hybrid scope but it does not have a scope toggle on state timer set. Using default scope toggle time (%d).\n", WeaponNameComplete, 100i64);
    return 100i64;
  }
  return result;
}

/*
==============
BG_SetGlobalAmmo
==============
*/
void BG_SetGlobalAmmo(playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoCount)
{
  int v6; 
  GlobalAmmo *GlobalAmmoSlot; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  r_ammo2 = *BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1288, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = 0;
  while ( !BG_IsAmmoCompatible(&ps->weapCommon.ammoNotInClip[v6].ammoType, &r_ammo2) )
  {
    if ( (unsigned int)++v6 >= 0xF )
      goto LABEL_9;
  }
  if ( (playerState_s *)((char *)ps + 68 * v6) == (playerState_s *)-1912i64 )
  {
LABEL_9:
    GlobalAmmoSlot = BG_FindGlobalAmmoSlot(ps);
    GlobalAmmoSlot->ammoType = r_ammo2;
    GlobalAmmoSlot->ammoCount = ammoCount;
    return;
  }
  ps->weapCommon.ammoNotInClip[v6].ammoCount = ammoCount;
}

/*
==============
BG_SetGlobalAmmoForAmmoType
==============
*/
void BG_SetGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  __m256i *GlobalAmmoSlot; 

  GlobalAmmoSlot = (__m256i *)BG_GlobalAmmoForAmmoType(ps, r_ammoType);
  if ( !GlobalAmmoSlot )
  {
    GlobalAmmoSlot = (__m256i *)BG_FindGlobalAmmoSlot(ps);
    *GlobalAmmoSlot = *(__m256i *)&r_ammoType->weapon.weaponIdx;
    GlobalAmmoSlot[1] = *(__m256i *)&r_ammoType->weapon.attachmentVariationIndices[5];
  }
  GlobalAmmoSlot[2].m256i_i32[0] = ammoCount;
}

/*
==============
BG_SetMustHaveAltAnim
==============
*/
void BG_SetMustHaveAltAnim(int weaponHasUnderbarrelAmmo, XAnimParts **normalAnimArray, XAnimParts **altAnimArray, weapAnimFiles_t weaponAnim)
{
  __int64 v4; 
  XAnimParts *v8; 

  v4 = weaponAnim;
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18318, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18319, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( weaponHasUnderbarrelAmmo && !altAnimArray[v4] )
  {
    v8 = normalAnimArray[v4];
    if ( v8 )
      altAnimArray[v4] = v8;
  }
}

/*
==============
BG_SetWeaponDelay
==============
*/
void BG_SetWeaponDelay(const BgWeaponMap *weaponMap, playerState_s *ps, const PlayerHandIndex hand, int weaponDelay, const char *const reason)
{
  __int64 v6; 
  const Weapon *ViewmodelWeapon; 
  bool v10; 
  const char *v11; 
  int v12; 
  const char *fmt; 
  __int64 v14; 
  const char *v15; 
  char output[1024]; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23118, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v6 >= 2 )
  {
    LODWORD(v14) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23119, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v14, 2) )
      __debugbreak();
  }
  if ( weaponDelay == 0xFFFF || (unsigned int)weaponDelay > 0x7FFF )
  {
    ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
    v10 = BG_UsingAlternate(ps);
    BG_GetWeaponNameComplete(ViewmodelWeapon, v10, output, 0x400u);
    v11 = "Set by Code";
    if ( weaponDelay == 0xFFFF )
    {
      v12 = 23135;
      if ( reason )
        v11 = reason;
      v15 = v11;
      fmt = "Undefined weapon delay timer is used. Weapon Delay: %d Reason: %s Weapon: %s. Please report this to the weapon designers.";
    }
    else
    {
      v12 = 23139;
      if ( reason )
        v11 = reason;
      v15 = v11;
      fmt = "Out of bounds weapon delay timer is used. Weapon Delay: %d Reason: %s Weapon: %s. Please report this to the weapon designers.";
    }
    LODWORD(v14) = weaponDelay;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", v12, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, fmt, v14, v15, output) )
      __debugbreak();
  }
  ps->weapState[v6].weaponDelay = weaponDelay;
}

/*
==============
BG_ShotCount
==============
*/
__int64 BG_ShotCount(const Weapon *r_weapon, bool isAlternate)
{
  int v5; 
  unsigned int shotCount; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM )
    return 1i64;
  v5 = 0;
  shotCount = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->shotCount;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8548, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunition = (*i)->ammunition;
      if ( ammunition )
        break;
      if ( ++v5 >= WeaponAttachments_Internal )
        return shotCount;
    }
    return (unsigned int)ammunition->shotCount;
  }
  return shotCount;
}

/*
==============
BG_ShouldApplyWeaponAnglesToShootingDirection
==============
*/
bool BG_ShouldApplyWeaponAnglesToShootingDirection(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  bool v6; 
  const WeaponDef *v7; 
  bool aimDownSight; 
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttSight *sight; 
  const ADSOverlay *Overlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20110, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 0;
  v6 = ps->weapCommon.fWeaponPosFrac > 0.0;
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  aimDownSight = v7->aimDownSight || v7->turretADSEnabled && v7->weapClass == WEAPCLASS_TURRET;
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      sight = (*v11)->sight;
      if ( sight )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_19;
    }
    aimDownSight = sight->aimDownSight;
  }
LABEL_19:
  Overlay = BG_GetOverlay(r_weapon, isAlternate);
  if ( !Overlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20120, ASSERT_TYPE_ASSERT, "(adsOverlay)", (const char *)&queryFormat, "adsOverlay") )
    __debugbreak();
  return v6 && aimDownSight && Overlay->reticle == WEAPOVERLAYRETICLE_NONE;
}

/*
==============
BG_ShouldBlendFireAnims
==============
*/
_BOOL8 BG_ShouldBlendFireAnims(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blendFireAnimations;
}

/*
==============
BG_ShowBone
==============
*/
unsigned __int8 BG_ShowBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return BG_ShowBoneByModelRange(bone, obj, partBits, startModel, -1);
}

/*
==============
BG_ShowBoneByModelRange
==============
*/
__int64 BG_ShowBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  unsigned __int8 childIndex[24]; 
  unsigned __int8 index; 

  if ( startModel < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5063, ASSERT_TYPE_ASSERT, "( startModel ) >= ( 0 )", "%s >= %s\n\t%i, %i", "startModel", "0", startModel, 0i64) )
    __debugbreak();
  index = -2;
  if ( DObjGetBoneIndexFromModelRange(obj, bone, startModel, lastModelInclusive, &index) )
  {
    bitarray_base<bitarray<256>>::resetBit(partBits, index);
    for ( childIndex[0] = -2; DObjGetNextChildBoneIndex(obj, index, childIndex); partBits->array[(unsigned __int64)childIndex[0] >> 5] &= ~(0x80000000 >> (childIndex[0] & 0x1F)) )
      ;
  }
  return index;
}

/*
==============
BG_ShowHideTagsBasedOnAltMode
==============
*/
void BG_ShowHideTagsBasedOnAltMode(const Weapon *r_weapon, DObj *obj, bool isAlternate, bool raisingToAlt, bool hideReticle, bool overrideHamr, bool hamrOn)
{
  if ( hideReticle )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
    goto LABEL_8;
  }
  if ( isAlternate || overrideHamr && hamrOn )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
LABEL_8:
    if ( isAlternate )
      goto LABEL_11;
    goto LABEL_9;
  }
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
LABEL_9:
  if ( !raisingToAlt )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_show_alt, obj, &obj->hidePartBits, 0, -1);
    return;
  }
LABEL_11:
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_show_alt, obj, &obj->hidePartBits, 0, -1);
}

/*
==============
BG_ShowIronSights
==============
*/
void BG_ShowIronSights(DObj *obj, int startModel, int lastModelInclusive)
{
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5157, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_ShowSniperScene
==============
*/
void BG_ShowSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj)
{
  bool v6; 
  unsigned int v7; 
  const scr_string_t **v8; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5515, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v6 = BG_ShowViewModelInDualFOV(r_weapon, isAlternate);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  if ( !v6 && BG_HideBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, &obj->hidePartBits, 0, -1) <= 0xFDu )
  {
    v7 = 0;
    v8 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
    do
    {
      BG_ToggleBoneVisibilityInAllModels(**v8, obj, &obj->hidePartBits, 0);
      ++v7;
      ++v8;
    }
    while ( v7 < 0xD );
  }
}

/*
==============
BG_ShowViewModelInDualFOV
==============
*/
_BOOL8 BG_ShowViewModelInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->showViewModelInDualFOV;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2988, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->showViewModelInDualFOV;
  }
  return sight->showViewModelInDualFOV;
}

/*
==============
BG_SkydiveFreefallRaiseTime
==============
*/
int BG_SkydiveFreefallRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveOpenParachuteTime
==============
*/
int BG_SkydiveOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteDetachTime
==============
*/
__int64 BG_SkydiveParachuteDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 

  v3 = DCONST_DVARINT_skydive_cut_parachute_anim_time;
  if ( !DCONST_DVARINT_skydive_cut_parachute_anim_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "skydive_cut_parachute_anim_time") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.unsignedInt;
}

/*
==============
BG_SkydiveParachuteFastLandingTime
==============
*/
int BG_SkydiveParachuteFastLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_FAST_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteFastLandingVelocity
==============
*/
float BG_SkydiveParachuteFastLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11671, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides->skydiveParachuteFastLandVelocity;
}

/*
==============
BG_SkydiveParachuteMidAirDetachTime
==============
*/
int BG_SkydiveParachuteMidAirDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingTime
==============
*/
int BG_SkydiveParachuteSlowHardLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_HARD_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingVelocity
==============
*/
float BG_SkydiveParachuteSlowHardLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11651, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides->skydiveParachuteSlowHardLandVelocity;
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingTime
==============
*/
int BG_SkydiveParachuteSlowSoftLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_SOFT_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingVelocity
==============
*/
float BG_SkydiveParachuteSlowSoftLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11631, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides->skydiveParachuteSlowSoftLandVelocity;
}

/*
==============
BG_SkydiveParachuteStillLandingTime
==============
*/
int BG_SkydiveParachuteStillLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_STILL_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveQuickOpenParachuteTime
==============
*/
int BG_SkydiveQuickOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveSuperDiveInTime
==============
*/
int BG_SkydiveSuperDiveInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveSuperDiveOutTime
==============
*/
int BG_SkydiveSuperDiveOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, isAlternate, 0, NULL);
}

/*
==============
BG_SlideSpreadFireAdd
==============
*/
float BG_SlideSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  float slideSpreadFireAdd; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v8; 
  __int64 v9; 
  float slideSpreadScale; 
  __int128 v11; 
  WeaponAttachment **v12; 
  AttSlideSpread *slideSpread; 
  __int128 v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  slideSpreadFireAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->slideSpreadFireAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _XMM6 = LODWORD(FLOAT_1_0);
  if ( WeaponAttachments_Internal )
  {
    v8 = attachments;
    v9 = WeaponAttachments_Internal;
    do
    {
      if ( !*v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14135, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      slideSpreadScale = (*v8)->slideSpreadScale;
      if ( slideSpreadScale != 0.0 )
      {
        v11 = _XMM6;
        *(float *)&v11 = (float)(*(float *)&_XMM6 + slideSpreadScale) - 1.0;
        _XMM6 = v11;
      }
      ++v8;
      --v9;
    }
    while ( v9 );
  }
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14144, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      slideSpread = (*v12)->slideSpread;
      if ( slideSpread )
        break;
      ++v4;
      ++v12;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_18;
    }
    slideSpreadFireAdd = slideSpread->slideSpreadFireAdd;
  }
LABEL_18:
  __asm { vmaxss  xmm3, xmm6, xmm8 }
  v15 = LODWORD(FLOAT_1_0);
  *(float *)&v15 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v15 + 1) = (v15 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v15 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v15;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  return *(float *)&_XMM0 * slideSpreadFireAdd;
}

/*
==============
BG_SmoothFadeSniperScene
==============
*/
void BG_SmoothFadeSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float adsFrac)
{
  DObjPartBits *p_hidePartBits; 
  DObjPartBits *v8; 
  DObjPartBits *v9; 
  unsigned __int8 v10; 
  unsigned int v11; 
  const scr_string_t **v12; 

  p_hidePartBits = &obj->hidePartBits;
  if ( adsFrac < 0.0 )
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  else
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  v8 = &obj->hidePartBits;
  if ( adsFrac >= 1.0 )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v8, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v8, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  if ( !BG_ShowViewModelInDualFOV(r_weapon, isAlternate) )
  {
    v9 = &obj->hidePartBits;
    if ( adsFrac >= 1.0 )
      v10 = BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v9, 0, -1);
    else
      v10 = BG_HideBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v9, 0, -1);
    if ( v10 <= 0xFDu )
    {
      v11 = 0;
      v12 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
      do
      {
        BG_ToggleBoneVisibilityInAllModels(**v12, obj, &obj->hidePartBits, adsFrac < 1.0);
        ++v11;
        ++v12;
      }
      while ( v11 < 0xD );
    }
  }
}

/*
==============
BG_SprintInTime
==============
*/
__int64 BG_SprintInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  weapAnimFiles_t SprintAnim; 
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 
  const dvar_t *v11; 
  float value; 
  int v13; 

  SprintAnim = BG_GetSprintAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_IN);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 170i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, SprintAnim, isAlternate, isDualWielding, NULL);
  v11 = DCONST_DVARMPFLT_bg_sprintInTimeScale;
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( !DCONST_DVARMPFLT_bg_sprintInTimeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_sprintInTimeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  value = v11->current.value;
  if ( value <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11369, ASSERT_TYPE_ASSERT, "(bgSprintInTimeScale > 0.0f)", (const char *)&queryFormat, "bgSprintInTimeScale > 0.0f") )
    __debugbreak();
  v13 = (int)(float)((float)WeaponFieldTimeWithDependentAnimation * value);
  if ( v13 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11372, ASSERT_TYPE_ASSERT, "(sprintInTime > 0)", (const char *)&queryFormat, "sprintInTime > 0") )
    __debugbreak();
  return (unsigned int)v13;
}

/*
==============
BG_SprintLoopTime
==============
*/
__int64 BG_SprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  weapAnimFiles_t v8; 
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 
  const dvar_t *v11; 
  float value; 
  int v13; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = WEAP_ANIM_SPRINT_LOOP;
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_LOOP, WEAP_ANIM_ADDITIVE_SPRINT_LOOP) )
    v8 = WEAP_ANIM_ADDITIVE_SPRINT_LOOP;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 172i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, v8, isAlternate, isDualWielding, NULL);
  v11 = DCONST_DVARMPFLT_bg_sprintLoopTimeScale;
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( !DCONST_DVARMPFLT_bg_sprintLoopTimeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_sprintLoopTimeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  value = v11->current.value;
  if ( value <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11392, ASSERT_TYPE_ASSERT, "(bgSprintLoopTimeScale > 0.0f)", (const char *)&queryFormat, "bgSprintLoopTimeScale > 0.0f") )
    __debugbreak();
  v13 = (int)(float)((float)WeaponFieldTimeWithDependentAnimation * value);
  if ( v13 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11395, ASSERT_TYPE_ASSERT, "(sprintLoopTime > 0)", (const char *)&queryFormat, "sprintLoopTime > 0") )
    __debugbreak();
  return (unsigned int)v13;
}

/*
==============
BG_SprintOutInterruptTime
==============
*/
__int64 BG_SprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  const dvar_t *v9; 
  bool v10; 
  int WeaponFieldTimeWithDependentAnimation; 
  bool v12; 
  weapAnimFiles_t v13; 
  bool ShouldUseSuitAnim; 
  double SprintOutTimeScale; 
  int outInterruptTime; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11482, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11483, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v9 = DCONST_DVARMPBOOL_movementAnimProto;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    v10 = isDualWielding;
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 352i64, NUM_WEAP_ANIMS);
    outInterruptTime = 0;
    if ( BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SPRINT_TO_WALK, isAlternate, v10, &outInterruptTime) )
      WeaponFieldTimeWithDependentAnimation = outInterruptTime;
  }
  else
  {
    v12 = isDualWielding;
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 340i64, NUM_WEAP_ANIMS);
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v13 = WEAP_ANIM_SPRINT_OUT;
    ShouldUseSuitAnim = BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, v12, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_ADDITIVE_SPRINT_OUT);
    outInterruptTime = 0;
    if ( ShouldUseSuitAnim )
      v13 = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
    if ( BG_Suit_GetAnimTime(ps, r_weapon, v13, isAlternate, v12, &outInterruptTime) )
      WeaponFieldTimeWithDependentAnimation = outInterruptTime;
  }
  SprintOutTimeScale = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  return (unsigned int)(int)(float)(*(float *)&SprintOutTimeScale * (float)WeaponFieldTimeWithDependentAnimation);
}

/*
==============
BG_SprintOutTime
==============
*/
__int64 BG_SprintOutTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  weapAnimFiles_t v10; 
  int AnimTime; 
  double SprintOutTimeScale; 
  float v13; 
  __int64 dependentAnimType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11459, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11460, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 174i64, NUM_WEAP_ANIMS);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = WEAP_ANIM_SPRINT_OUT;
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_ADDITIVE_SPRINT_OUT) )
    v10 = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, v10, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  SprintOutTimeScale = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  v13 = *(float *)&SprintOutTimeScale * (float)WeaponFieldTimeWithDependentAnimation;
  if ( (int)v13 <= 0 )
  {
    LODWORD(dependentAnimType) = (int)v13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11474, ASSERT_TYPE_ASSERT, "( ( 0 < sprintOutTime ) )", "( sprintOutTime ) = %i", dependentAnimType) )
      __debugbreak();
  }
  return (unsigned int)(int)v13;
}

/*
==============
BG_StartAmmo
==============
*/
__int64 BG_StartAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  weapType_t WeaponType; 
  const WeaponDef *v7; 
  unsigned int v9; 
  unsigned int iStartAmmo; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v13; 
  __int64 v14; 
  float ammunitionScale; 
  __int128 v16; 
  WeaponAttachment **v17; 
  AttAmmunition *ammunition; 
  __int128 v20; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  if ( BG_WeaponTypeIsOffhand(WeaponType) && hasIncreasedOffhandAmmoPerk )
  {
    v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8480, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return (unsigned int)v7->iPerkStartAmmo;
  }
  else
  {
    v9 = 0;
    iStartAmmo = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iStartAmmo;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    _XMM6 = LODWORD(FLOAT_1_0);
    if ( WeaponAttachments_Internal )
    {
      v13 = attachments;
      v14 = WeaponAttachments_Internal;
      do
      {
        if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8504, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunitionScale = (*v13)->ammunitionScale;
        if ( ammunitionScale != 0.0 )
        {
          v16 = _XMM6;
          *(float *)&v16 = (float)(*(float *)&_XMM6 + ammunitionScale) - 1.0;
          _XMM6 = v16;
        }
        ++v13;
        --v14;
      }
      while ( v14 );
    }
    if ( WeaponAttachments_Internal )
    {
      v17 = attachments;
      while ( 1 )
      {
        if ( !*v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8513, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunition = (*v17)->ammunition;
        if ( ammunition )
          break;
        ++v9;
        ++v17;
        if ( v9 >= WeaponAttachments_Internal )
          goto LABEL_24;
      }
      iStartAmmo = ammunition->startAmmo;
    }
LABEL_24:
    __asm { vmaxss  xmm3, xmm6, xmm8 }
    v20 = LODWORD(FLOAT_1_0);
    *(float *)&v20 = 1.0 - *(float *)&_XMM3;
    *((_QWORD *)&v20 + 1) = (v20 & (unsigned __int128)_xmm) >> 64;
    *(double *)&v20 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
    _XMM1 = v20;
    __asm
    {
      vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vblendvps xmm1, xmm3, xmm7, xmm2
    }
    return (unsigned int)(int)(float)(_mm_cvtepi32_ps((__m128i)iStartAmmo).m128_f32[0] * *(float *)&_XMM1);
  }
}

/*
==============
BG_StartingGunKickPercent
==============
*/
float BG_StartingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  const WeaponDef *v6; 
  float adsStartingGunKickPercent; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  float *p_hipStartingGunKickPercent; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    adsStartingGunKickPercent = v6->adsStartingGunKickPercent;
  else
    adsStartingGunKickPercent = v6->hipStartingGunKickPercent;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsStartingGunKickPercent;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14198, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    p_hipStartingGunKickPercent = &(*i)->kickScaling->hipStartingGunKickPercent;
    if ( p_hipStartingGunKickPercent )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return adsStartingGunKickPercent;
  }
  if ( ads )
    return p_hipStartingGunKickPercent[3];
  else
    return *p_hipStartingGunKickPercent;
}

/*
==============
BG_StartingKickBullets
==============
*/
__int64 BG_StartingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int adsStartingKickBullets; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsStartingKickBullets = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsStartingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsStartingKickBullets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14165, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsStartingKickBullets;
  }
  return (unsigned int)kickScaling->adsStartingKickBullets;
}

/*
==============
BG_StartingViewKickPercent
==============
*/
float BG_StartingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  const WeaponDef *v6; 
  float adsStartingViewKickPercent; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    adsStartingViewKickPercent = v6->adsStartingViewKickPercent;
  else
    adsStartingViewKickPercent = v6->hipStartingViewKickPercent;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsStartingViewKickPercent;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14238, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return adsStartingViewKickPercent;
  }
  if ( ads )
    return kickScaling->adsStartingViewKickPercent;
  else
    return kickScaling->hipStartingViewKickPercent;
}

/*
==============
BG_StowedOcclusionTestEnabled
==============
*/
bool BG_StowedOcclusionTestEnabled(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v3; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v3 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1701, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v3->worldModel && v3->stowedOcclusionTestEnabled && !BG_IsRiotShield(r_weapon, 0);
}

/*
==============
BG_StunnedTimeBegin
==============
*/
__int64 BG_StunnedTimeBegin(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 182i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_StunnedTimeEnd
==============
*/
__int64 BG_StunnedTimeEnd(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 186i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_StunnedTimeLoop
==============
*/
__int64 BG_StunnedTimeLoop(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 184i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_SuperSprintOutInterruptTime
==============
*/
__int64 BG_SuperSprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool v9; 
  int WeaponFieldTimeWithDependentAnimation; 
  double SprintOutTimeScale; 
  int outInterruptTime; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11522, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11523, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v9 = isDualWielding;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 354i64, NUM_WEAP_ANIMS);
  outInterruptTime = 0;
  if ( BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SUPERSPRINT_TO_WALK, isAlternate, v9, &outInterruptTime) )
    WeaponFieldTimeWithDependentAnimation = outInterruptTime;
  SprintOutTimeScale = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  return (unsigned int)(int)(float)(*(float *)&SprintOutTimeScale * (float)WeaponFieldTimeWithDependentAnimation);
}

/*
==============
BG_SyncedFOVInDualFOV
==============
*/
_BOOL8 BG_SyncedFOVInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->syncedFOVInDualFOV;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3006, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->syncedFOVInDualFOV;
  }
  return sight->syncedFOVInDualFOV;
}

/*
==============
BG_TakePlayerWeapon
==============
*/
int BG_TakePlayerWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const BgHandler *const handler, const Weapon *r_weapon, int gameTime)
{
  int result; 
  const Weapon *CurrentWeaponForPlayer; 
  const dvar_t *v11; 
  const Weapon *OffHandWeaponForPlayer; 
  const Weapon *ThrowbackWeaponForPlayer; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3649, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = BG_PlayerHasWeapon(weaponMap, ps, r_weapon);
  if ( result )
  {
    if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx)->inventoryType == WEAPINVENTORY_ALTMODE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3655, ASSERT_TYPE_ASSERT, "(BG_WeaponDef( r_weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE)", (const char *)&queryFormat, "BG_WeaponDef( r_weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE") )
      __debugbreak();
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3633, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3634, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    BG_RemoveWeaponAndGlobalAmmo(weaponMap, ps, r_weapon, 0);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
      BG_RemoveWeaponAndGlobalAmmo(weaponMap, ps, r_weapon, 1);
    BG_RemoveClipAmmo(ps, r_weapon, 0);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
      BG_RemoveClipAmmo(ps, r_weapon, 1);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, CurrentWeaponForPlayer, 0x3Cui64) )
    {
      v11 = DVARBOOL_killswitch_left_hand_throw_gesture_stuck_fix_enabled;
      if ( !DVARBOOL_killswitch_left_hand_throw_gesture_stuck_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_left_hand_throw_gesture_stuck_fix_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      if ( v11->current.enabled )
        BG_Weapon_CancelOffhand(ps, handler, weaponMap, gameTime, 0);
      BG_SetCurrentWeaponForPlayer(weaponMap, ps, &NULL_WEAPON, handler);
    }
    OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, OffHandWeaponForPlayer, 0x3Cui64) )
    {
      if ( BG_IsUsingOffhandGestureWeapon(ps) )
        BG_OffhandGestureWeaponEnd(weaponMap, ps, handler, gameTime, 0);
      if ( BG_IsUsingScriptedOffhandWeapon(ps) )
        BG_OffhandGestureScriptWeaponEnd(weaponMap, ps, gameTime, 0);
      BG_SetOffHandWeaponForPlayer(weaponMap, ps, &NULL_WEAPON);
    }
    ThrowbackWeaponForPlayer = BG_GetThrowbackWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, ThrowbackWeaponForPlayer, 0x3Cui64) )
      BG_SetThrowbackWeaponForPlayer(weaponMap, ps, &NULL_WEAPON);
    if ( Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && BG_WeaponDefAtIndex(r_weapon->weaponIdx)->isAirburstWeapon )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3712, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST )") )
        __debugbreak();
      ps->airburstMarkDistance = 0;
    }
    return 1;
  }
  return result;
}

/*
==============
BG_TargetAssistLosOffsets
==============
*/
void BG_TargetAssistLosOffsets(const Weapon *r_weapon, bool isAlternate, float *outForwardOffset, float *outRightOffset, float *outUpOffset)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  WeaponAttachment *v12; 
  AttTargetAssist *targetAssist; 
  const WeaponDef *v14; 
  float targetAssistLosOffsetUp; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outForwardOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9137, ASSERT_TYPE_ASSERT, "(outForwardOffset)", (const char *)&queryFormat, "outForwardOffset") )
    __debugbreak();
  if ( !outRightOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9138, ASSERT_TYPE_ASSERT, "(outRightOffset)", (const char *)&queryFormat, "outRightOffset") )
    __debugbreak();
  if ( !outUpOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9139, ASSERT_TYPE_ASSERT, "(outUpOffset)", (const char *)&queryFormat, "outUpOffset") )
    __debugbreak();
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9146, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *v11;
      targetAssist = (*v11)->targetAssist;
      if ( targetAssist )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_17;
    }
    *outForwardOffset = targetAssist->targetAssistLosOffsetForward;
    *outRightOffset = v12->targetAssist->targetAssistLosOffsetRight;
    targetAssistLosOffsetUp = v12->targetAssist->targetAssistLosOffsetUp;
  }
  else
  {
LABEL_17:
    v14 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    *outForwardOffset = v14->targetAssistLosOffsetForward;
    *outRightOffset = v14->targetAssistLosOffsetRight;
    targetAssistLosOffsetUp = v14->targetAssistLosOffsetUp;
  }
  *outUpOffset = targetAssistLosOffsetUp;
}

/*
==============
BG_ThrowBackIcon
==============
*/
Material *BG_ThrowBackIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->throwBackIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16239, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->throwBackIconMat;
  }
  return ui->throwBackIconMat;
}

/*
==============
BG_ThrowingBackGrenade
==============
*/
bool BG_ThrowingBackGrenade(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4990, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return ps->throwbackGrenadeOwner != 2047;
}

/*
==============
BG_TimedDetonation
==============
*/
const WeaponDef *BG_TimedDetonation(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  AttProjectile *projectile; 
  const WeaponDef *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17369, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v5)->projectile;
      if ( projectile )
        return (const WeaponDef *)projectile->timedDetonation;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( result )
      return (const WeaponDef *)result->timedDetonation;
  }
  return result;
}

/*
==============
BG_ToggleBoneVisibilityInAllModels
==============
*/
void BG_ToggleBoneVisibilityInAllModels(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, const bool visible)
{
  int v7; 
  int i; 
  DObjPartBits *p_hidePartBits; 
  unsigned __int8 v10; 
  int ModelIndexForBoneIndex; 
  __int64 v12; 
  __int64 v13; 

  v7 = -1;
  for ( i = 0; ; i = ModelIndexForBoneIndex + 1 )
  {
    p_hidePartBits = &obj->hidePartBits;
    v10 = visible ? BG_ShowBoneByModelRange(bone, obj, p_hidePartBits, i, -1) : BG_HideBoneByModelRange(bone, obj, p_hidePartBits, i, -1);
    if ( v10 > 0xFDu )
      break;
    ModelIndexForBoneIndex = DObjGetModelIndexForBoneIndex(obj, v10);
    if ( ModelIndexForBoneIndex >= (unsigned int)obj->numModels )
    {
      LODWORD(v13) = obj->numModels;
      LODWORD(v12) = ModelIndexForBoneIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5389, ASSERT_TYPE_ASSERT, "(unsigned)( modelIdx ) < (unsigned)( obj->numModels )", "modelIdx doesn't index obj->numModels\n\t%i not in [0, %i)", v12, v13) )
        __debugbreak();
    }
    if ( ModelIndexForBoneIndex >= obj->numModels - 1 )
      break;
    if ( ModelIndexForBoneIndex <= v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5397, ASSERT_TYPE_ASSERT, "(modelIdx > prevmodelIdx)", (const char *)&queryFormat, "modelIdx > prevmodelIdx") )
      __debugbreak();
    v7 = ModelIndexForBoneIndex;
  }
}

/*
==============
BG_TracerType
==============
*/
TracerDef *BG_TracerType(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v7; 
  TracerDef *tracerType; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v10; 
  TracerDef **p_tracerType; 
  TracerDef *result; 
  int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  bitarray<64> v19; 

  v19 = perks;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v7 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_7;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v7 & 0x1F)) & v19.array[v7 >> 5]) == 0 || (tracerType = v5->overchargeTracerType) == NULL )
LABEL_7:
    tracerType = v5->tracerType;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v10 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( !WeaponPrimaryAttachment || (p_tracerType = &WeaponPrimaryAttachment->tracer->tracerType) == NULL || (result = *p_tracerType) == NULL || !isAlternate )
  {
    if ( v5->tracerOverrideEnabled )
    {
      v13 = 0;
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      if ( WeaponAttachments_Internal )
      {
        for ( i = attachments; ; ++i )
        {
          if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7135, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
            __debugbreak();
          tracer = (*i)->tracer;
          if ( tracer )
          {
            if ( *i != v10 && tracer->tracerType )
              break;
          }
          if ( ++v13 >= WeaponAttachments_Internal )
            return tracerType;
        }
        return tracer->tracerType;
      }
    }
    return tracerType;
  }
  return result;
}

/*
==============
BG_TurretMaxCorrectionAngle
==============
*/
float BG_TurretMaxCorrectionAngle(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0.0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9858, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->maxCorrectionAngle;
}

/*
==============
BG_TurretSpawnsProjectileAtMuzzle
==============
*/
bool BG_TurretSpawnsProjectileAtMuzzle(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9830, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->spawnProjAtMuzzle;
}

/*
==============
BG_TurretSpinSound
==============
*/
SndAliasLookup BG_TurretSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 

  if ( r_weapon->weaponIdx && (SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate)) != NULL )
    return (SndAliasLookup)SfxPackage->sounds->turretSpinSnd.name;
  else
    return 0i64;
}

/*
==============
BG_TurretStopSpinSound
==============
*/
SndAliasLookup BG_TurretStopSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 

  if ( r_weapon->weaponIdx && (SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate)) != NULL )
    return (SndAliasLookup)SfxPackage->sounds->turretStopSnd.name;
  else
    return 0i64;
}

/*
==============
BG_TurretUsesBulletCorrection
==============
*/
bool BG_TurretUsesBulletCorrection(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9844, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->correctBulletTrajectory;
}

/*
==============
BG_TurretWeaponUses3pIK
==============
*/
bool BG_TurretWeaponUses3pIK(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9816, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->useTurret3pIK;
}

/*
==============
BG_UniqueAmmoUnderbarrelAttachment
==============
*/
const WeaponAttachment *BG_UniqueAmmoUnderbarrelAttachment(const Weapon *weapon, const bool isAlternate)
{
  const WeaponAttachment *result; 

  if ( !isAlternate )
    return 0i64;
  result = BG_GetWeaponPrimaryAttachment(weapon, ATT_SLOT_UNDERBARREL);
  if ( !result || result->weapClass == WEAPCLASS_NONE || result->shareAmmoWithAlt )
    return 0i64;
  return result;
}

/*
==============
BG_UnpackClientWeaponFireEventParm
==============
*/
void BG_UnpackClientWeaponFireEventParm(const unsigned int eventParm, tmat33_t<vec3_t> *outFireAxis)
{
  float v2; 
  float v3; 
  vec3_t angles; 

  v2 = (float)(unsigned __int16)eventParm;
  angles.v[0] = v2 * 0.0054931641;
  v3 = (float)HIWORD(eventParm);
  angles.v[1] = v3 * 0.0054931641;
  angles.v[2] = 0.0;
  AnglesToAxis(&angles, outFireAxis);
}

/*
==============
BG_UpdateLastWeaponHand
==============
*/
void BG_UpdateLastWeaponHand(const BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *weapon)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23022, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23023, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ps->weapCommon.lastWeaponHand = BG_PlayerDualWieldingWeapon(weaponMap, ps, weapon) != 0;
}

/*
==============
BG_UpdateSecondaryWeaponVisibilities
==============
*/
void BG_UpdateSecondaryWeaponVisibilities(const BgAnimStatic *bgameAnim, const BgWeaponMap *weaponMap, const entityState_t *es, characterInfo_t *ci)
{
  const BgAnimStatic *v7; 
  unsigned __int16 weaponIdx; 
  int isUsingWeaponAltMode; 
  int playerAnimType; 
  const WeaponDef *v11; 
  int v12; 
  BOOL v13; 
  unsigned int Anim; 
  unsigned int Animset; 
  unsigned int v16; 
  const Weapon *v17; 
  const BgAnimStatic *v18; 
  unsigned __int16 v19; 
  BOOL v20; 
  const WeaponDef *v21; 
  int DoesNotFullyAnimateViewmodelEntityState; 
  scr_string_t hide; 
  scr_string_t show; 
  int v25; 
  int v26; 
  SuitAnimType SuitAnimIndex; 
  SuitAnimType v28; 
  const Weapon *OffHandWeaponForPlayerEntity; 
  unsigned __int16 v30; 
  BOOL v31; 
  int v32; 
  const WeaponDef *v33; 
  bool usingThrownWeapon; 
  bool usingKillstreakTrigger; 
  bool hideLeftHandWeapon; 
  bool hideWeapon; 
  bool stowHeldWeapon; 
  BOOL v39; 
  int v40; 
  unsigned int packedAnimIndex; 
  int animNum; 
  int animNuma; 
  int bgameAnimb; 
  int v47; 
  BOOL v48; 

  v7 = bgameAnim;
  if ( !bgameAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21420, ASSERT_TYPE_ASSERT, "(bgameAnim)", (const char *)&queryFormat, "bgameAnim") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21421, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21422, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21423, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  weaponIdx = ci->dobjHeldWeapon.weaponIdx;
  if ( !weaponIdx )
    return;
  BG_WeaponDefAtIndex(weaponIdx);
  isUsingWeaponAltMode = ci->isUsingWeaponAltMode;
  if ( BG_GetWeaponType(&ci->dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(&ci->dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE && isUsingWeaponAltMode )
  {
    playerAnimType = 8;
  }
  else
  {
    v11 = BG_WeaponDefAtIndex(ci->dobjHeldWeapon.weaponIdx);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20880, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    playerAnimType = v11->playerAnimType;
  }
  v12 = 0;
  v40 = playerAnimType;
  v13 = 0;
  if ( BG_GetWeaponType(&ci->dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(&ci->dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE && ci->isUsingWeaponAltMode )
    v13 = 1;
  v47 = 0;
  animNum = 0;
  v48 = 0;
  v39 = 0;
  if ( !PlayerASM_IsEnabled() )
  {
    animNuma = BG_AnimationMP_GetLegsAnimation(es);
    bgameAnimb = BG_AnimationMP_GetTorsoAnimation(es);
    v26 = bgameAnimb;
    SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(es);
    v28 = SuitAnimIndex;
    if ( ci->usingAnimState )
    {
LABEL_121:
      v12 = 0;
      goto LABEL_122;
    }
    if ( !BG_IsThrowOrPrepareAnim(bgameAnimb, SuitAnimIndex) && !BG_IsGestureAnim(bgameAnimb, v28) )
      goto LABEL_109;
    OffHandWeaponForPlayerEntity = BG_GetOffHandWeaponForPlayerEntity(weaponMap, es);
    if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_GRENADE )
    {
      if ( BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.grenade_on, scr_const.grenade_off, 0.0) )
        v13 = 0;
    }
    else if ( BG_IsGestureAnim(bgameAnimb, v28) && playerAnimType == 32 )
    {
      v30 = OffHandWeaponForPlayerEntity->weaponIdx;
      if ( OffHandWeaponForPlayerEntity->weaponIdx )
      {
LABEL_98:
        if ( ci->dualWielding )
        {
          v31 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.akimbo_off, scr_const.akimbo_on, 0.0);
          v30 = OffHandWeaponForPlayerEntity->weaponIdx;
          v32 = v31;
          v47 = v31;
        }
        else
        {
          v32 = 0;
        }
        v33 = BG_WeaponDefAtIndex(v30);
        if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21594, ASSERT_TYPE_ASSERT, "(offhandWeapDef)", (const char *)&queryFormat, "offhandWeapDef") )
          __debugbreak();
        if ( v33->weapType != WEAPTYPE_SCRIPT )
        {
          if ( BG_GetWeaponType(OffHandWeaponForPlayerEntity, 0) == WEAPTYPE_GRENADE && BG_WeaponDoesNotFullyAnimateViewmodelEntityState(es, OffHandWeaponForPlayerEntity, 0) )
            v48 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.grenade_on, scr_const.grenade_off, 0.0);
          goto LABEL_108;
        }
        v26 = bgameAnimb;
        if ( BG_IsGestureAnim(bgameAnimb, v28) && v33->scriptedAnimType )
        {
          if ( ci->dualWielding )
            v32 = 1;
          v47 = v32;
          if ( v33->worldModel )
            v48 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.show, scr_const.hide, 0.0);
        }
LABEL_109:
        if ( !ci->usingAnimState )
        {
          if ( BG_IsKillstreakTriggerAnim(v26, v28) )
            v39 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.phone_on, scr_const.phone_off, 0.0);
          if ( !ci->usingAnimState )
          {
            v12 = 0;
            if ( BG_IsLadderAnim(animNuma, v28) )
              v13 = 1;
            goto LABEL_122;
          }
        }
        goto LABEL_121;
      }
      if ( BG_IsThrowingAxe(&ci->dobjHeldWeapon) )
        v13 = !BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.axe_on, scr_const.axe_off, 0.0);
    }
    v30 = OffHandWeaponForPlayerEntity->weaponIdx;
    if ( !OffHandWeaponForPlayerEntity->weaponIdx )
    {
LABEL_108:
      v26 = bgameAnimb;
      goto LABEL_109;
    }
    goto LABEL_98;
  }
  packedAnimIndex = BG_PlayerASM_GetAnim(es, MOVEMENT);
  Anim = BG_PlayerASM_GetAnim(es, DODGE);
  Animset = BG_PlayerASM_GetAnimset(es);
  v16 = Animset;
  if ( !ci->usingAnimState )
  {
    if ( BG_PlayerASM_IsRocketHideShowAlias(Anim, Animset) )
      animNum = !BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.rocket_on, scr_const.rocket_off, 0.0);
    if ( !ci->usingAnimState && (BG_PlayerASM_IsThrowOrPrepareAlias(Anim, v16) || BG_PlayerASM_IsGestureAlias(Anim, v16)) )
    {
      v17 = BG_GetOffHandWeaponForPlayerEntity(weaponMap, es);
      if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_GRENADE )
      {
        v18 = bgameAnim;
        if ( !BG_CheckTorsoAnimForModelVisibility(bgameAnim, es, ci, scr_const.grenade_on, scr_const.grenade_off, 0.0) )
          v13 = 1;
      }
      else if ( BG_PlayerASM_IsGestureAlias(Anim, v16) && v40 == 32 )
      {
        v19 = v17->weaponIdx;
        if ( v17->weaponIdx )
        {
          v18 = bgameAnim;
          goto LABEL_52;
        }
        v18 = bgameAnim;
        if ( BG_IsThrowingAxe(&ci->dobjHeldWeapon) )
          v13 = !BG_CheckTorsoAnimForModelVisibility(bgameAnim, es, ci, scr_const.axe_on, scr_const.axe_off, 0.0);
      }
      else
      {
        v18 = bgameAnim;
      }
      v19 = v17->weaponIdx;
      if ( !v17->weaponIdx )
      {
LABEL_43:
        v7 = bgameAnim;
LABEL_44:
        v12 = 0;
        goto LABEL_45;
      }
LABEL_52:
      if ( ci->dualWielding )
      {
        v20 = BG_CheckTorsoAnimForModelVisibility(v18, es, ci, scr_const.akimbo_off, scr_const.akimbo_on, 0.0);
        v19 = v17->weaponIdx;
        v47 = v20;
      }
      v21 = BG_WeaponDefAtIndex(v19);
      if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21488, ASSERT_TYPE_ASSERT, "(offhandWeapDef)", (const char *)&queryFormat, "offhandWeapDef") )
        __debugbreak();
      if ( v21->weapType == WEAPTYPE_SCRIPT )
      {
        if ( !BG_PlayerASM_IsGestureAlias(Anim, v16) || !v21->scriptedAnimType )
          goto LABEL_43;
        v25 = v47;
        v7 = bgameAnim;
        if ( ci->dualWielding )
          v25 = 1;
        v47 = v25;
        if ( !v21->worldModel )
          goto LABEL_44;
        hide = scr_const.hide;
        show = scr_const.show;
      }
      else
      {
        if ( BG_GetWeaponType(v17, 0) != WEAPTYPE_GRENADE )
          goto LABEL_43;
        DoesNotFullyAnimateViewmodelEntityState = BG_WeaponDoesNotFullyAnimateViewmodelEntityState(es, v17, 0);
        v7 = bgameAnim;
        if ( !DoesNotFullyAnimateViewmodelEntityState )
          goto LABEL_44;
        hide = scr_const.grenade_off;
        show = scr_const.grenade_on;
      }
      v48 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, show, hide, 0.0);
      goto LABEL_44;
    }
  }
LABEL_45:
  if ( !ci->usingAnimState )
  {
    if ( BG_PlayerASM_IsKillstreakTriggerAlias(Anim, v16) )
      v39 = BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.phone_on, scr_const.phone_off, 0.0);
    if ( !ci->usingAnimState )
    {
      if ( BG_PlayerASM_IsLadderAlias(Anim, v16) )
      {
        v13 = 1;
      }
      else if ( BG_PlayerASM_IsLadderAimAlias(Anim, v16) )
      {
        v13 = 0;
      }
      else if ( BG_PlayerASM_IsLadderAlias(packedAnimIndex, v16) )
      {
        v13 = 1;
      }
      else if ( BG_PlayerASM_IsLadderAimAlias(packedAnimIndex, v16) )
      {
        v13 = 0;
      }
      if ( !ci->usingAnimState && (BG_PlayerASM_IsRaiseWeaponAlias(Anim, v16) || BG_PlayerASM_IsDropWeaponAlias(Anim, v16)) )
      {
        if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_EQUIP_DEPLOY )
        {
          if ( !BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.gun_on, scr_const.gun_off, 0.0) )
            v13 = 1;
        }
        else if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) != WEAPTYPE_GRENADE && !BG_CheckTorsoAnimForModelVisibility(v7, es, ci, scr_const.gun_on, scr_const.gun_off, 0.0) )
        {
          v13 = 1;
          v12 = 1;
        }
      }
    }
  }
  if ( animNum )
  {
    if ( ci->hideRocket )
      goto LABEL_125;
    ci->hideRocket = 1;
    goto LABEL_124;
  }
LABEL_122:
  if ( !ci->hideRocket )
    goto LABEL_125;
  ci->hideRocket = 0;
LABEL_124:
  ci->dobjDirty = 1;
LABEL_125:
  usingThrownWeapon = ci->usingThrownWeapon;
  if ( v48 )
  {
    if ( usingThrownWeapon )
      goto LABEL_131;
    ci->usingThrownWeapon = 1;
  }
  else
  {
    if ( !usingThrownWeapon )
      goto LABEL_131;
    ci->usingThrownWeapon = 0;
  }
  ci->dobjDirty = 1;
LABEL_131:
  usingKillstreakTrigger = ci->usingKillstreakTrigger;
  if ( v39 )
  {
    if ( usingKillstreakTrigger )
      goto LABEL_137;
    ci->usingKillstreakTrigger = 1;
  }
  else
  {
    if ( !usingKillstreakTrigger )
      goto LABEL_137;
    ci->usingKillstreakTrigger = 0;
  }
  ci->dobjDirty = 1;
LABEL_137:
  hideLeftHandWeapon = ci->hideLeftHandWeapon;
  if ( v47 )
  {
    if ( hideLeftHandWeapon )
      goto LABEL_143;
    ci->hideLeftHandWeapon = 1;
  }
  else
  {
    if ( !hideLeftHandWeapon )
      goto LABEL_143;
    ci->hideLeftHandWeapon = 0;
  }
  ci->dobjDirty = 1;
LABEL_143:
  hideWeapon = ci->hideWeapon;
  if ( v13 )
  {
    if ( !hideWeapon )
    {
      ci->hideWeapon = 1;
      goto LABEL_148;
    }
  }
  else if ( hideWeapon )
  {
    ci->hideWeapon = 0;
LABEL_148:
    ci->dobjDirty = 1;
  }
  stowHeldWeapon = ci->stowHeldWeapon;
  if ( v12 )
  {
    if ( stowHeldWeapon )
      return;
    ci->stowHeldWeapon = 1;
  }
  else
  {
    if ( !stowHeldWeapon )
      return;
    ci->stowHeldWeapon = 0;
  }
  ci->dobjDirty = 1;
}

/*
==============
BG_UpdateVisibilitySlingBones
==============
*/
void BG_UpdateVisibilitySlingBones(const entityState_t *es, DObj *obj, bool isClientCorpse, const Weapon *r_heldWeapon, const Weapon *r_stowedWeapon, int heldWeaponIndex, int stowedWeaponIndex, unsigned __int16 clientOnly, bool forceShowBones)
{
  char v11; 
  const WeaponDef *v13; 
  unsigned __int16 weaponIdx; 
  char v15; 
  unsigned __int16 v16; 
  char v17; 
  int v18; 
  scr_string_t tag_sling; 
  entityType_s eType; 
  int v21; 
  const scr_string_t **v22; 
  __int64 v23; 
  scr_string_t stowTag; 
  char v25; 
  const scr_string_t **v26; 
  __int64 v27; 
  int modelIndex; 
  unsigned __int8 inOutIndex; 
  bool v30; 

  v30 = isClientCorpse;
  v11 = isClientCorpse;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5649, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v13 = NULL;
  if ( (_BYTE)clientOnly && Sys_IsServerThread() )
    return;
  weaponIdx = r_heldWeapon->weaponIdx;
  v15 = 0;
  v16 = r_stowedWeapon->weaponIdx;
  v17 = 0;
  clientOnly = weaponIdx;
  if ( v16 )
  {
    v13 = BG_WeaponDefAtIndex(v16);
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5675, ASSERT_TYPE_ASSERT, "(stowedWeapDef)", (const char *)&queryFormat, "stowedWeapDef") )
      __debugbreak();
  }
  if ( weaponIdx )
  {
    v18 = heldWeaponIndex;
    if ( heldWeaponIndex >= 0 )
    {
      tag_sling = scr_const.tag_sling;
      if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_public_inline.h", 89, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
        __debugbreak();
      if ( !tag_sling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_public_inline.h", 90, ASSERT_TYPE_ASSERT, "(name != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "name != NULL_SCR_STRING") )
        __debugbreak();
      inOutIndex = -2;
      modelIndex = 0;
      if ( DObjGetBoneIndexInternal_19(obj, tag_sling, &inOutIndex, &modelIndex) )
      {
        if ( stowedWeaponIndex < 0 || modelIndex < stowedWeaponIndex )
        {
          if ( modelIndex < v18 )
            Com_PrintWarning(19, "BG_UpdateVisibilitySlingBones(): 'tag_sling' found on the character. It needs to be on the held/stowed weapon models/attachments.");
          else
            v15 = 1;
        }
        else
        {
          v17 = 1;
        }
      }
      v11 = v30;
    }
    weaponIdx = clientOnly;
  }
  LOBYTE(clientOnly) = 0;
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 595, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = es->eType;
  LOBYTE(clientOnly) = 0;
  if ( (unsigned __int16)eType <= ET_AGENT )
  {
    v21 = 131111;
    if ( _bittest(&v21, eType) )
    {
      if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) != 1 )
      {
        if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) != 2 )
        {
          if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) == 3 )
          {
            LOBYTE(clientOnly) = 1;
            goto LABEL_36;
          }
          goto LABEL_45;
        }
        LOBYTE(clientOnly) = 1;
      }
      LOBYTE(clientOnly) = 1;
    }
  }
LABEL_45:
  if ( !weaponIdx && !v16 || !v17 && !v15 || v11 || (!v16 || (stowTag = v13->stowTag, stowTag != scr_const.tag_stowed_chest) && stowTag != scr_const.tag_stowed_chest2 ? (v25 = 0) : (v25 = 1), !v15 && (!v25 || !v17)) )
  {
LABEL_36:
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( DObjHasProceduralBones(obj) )
    {
      v22 = SLING_HIDE_BONES;
      v23 = 6i64;
      do
      {
        BG_HideBoneByModelRange(**v22++, obj, &obj->hidePartBits, 0, -1);
        --v23;
      }
      while ( v23 );
    }
    return;
  }
  if ( forceShowBones )
  {
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( DObjHasProceduralBones(obj) )
    {
      v26 = SLING_HIDE_BONES;
      v27 = 6i64;
      do
      {
        BG_ShowBoneByModelRange(**v26++, obj, &obj->hidePartBits, 0, -1);
        --v27;
      }
      while ( v27 );
    }
  }
}

/*
==============
BG_UpdateWeaponCosmeticBones
==============
*/
void BG_UpdateWeaponCosmeticBones(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  __int64 v9; 
  XModel **viewModelVariations; 
  XModel *v11; 
  scr_string_t tag_cosmetic; 
  int v13; 
  int v14; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_VISUAL);
  if ( WeaponPrimaryAttachment && (v9 = r_weapon->attachmentVariationIndices[12], (int)v9 < (signed int)WeaponPrimaryAttachment->numModelVariations) && (viewModelVariations = WeaponPrimaryAttachment->viewModelVariations, (v11 = viewModelVariations[v9]) != NULL) && DObjGetModelIndex(obj, viewModelVariations[v9]) != -1 )
  {
    if ( WeaponPrimaryAttachment->attachPoint == scr_const.tag_cosmetic )
      goto LABEL_13;
    if ( !v11->numBones )
    {
      v14 = 0;
      v13 = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 173, ASSERT_TYPE_ASSERT, "(unsigned)( boneIndex ) < (unsigned)( model->numBones )", "boneIndex doesn't index model->numBones\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    if ( !v11->boneNames && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 174, ASSERT_TYPE_ASSERT, "(model->boneNames)", (const char *)&queryFormat, "model->boneNames") )
      __debugbreak();
    tag_cosmetic = scr_const.tag_cosmetic;
    if ( *v11->boneNames == scr_const.tag_cosmetic )
    {
LABEL_13:
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_cosmetic, obj, &obj->hidePartBits, startModel, lastModelInclusive);
      return;
    }
  }
  else
  {
    tag_cosmetic = scr_const.tag_cosmetic;
  }
  BG_HideBoneByModelRange(tag_cosmetic, obj, &obj->hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_UpdateWeaponGlass
==============
*/
void BG_UpdateWeaponGlass(const float adsFrac, DObj *const obj, const bool adsSmoothFade)
{
  const dvar_t *v5; 
  const dvar_t *v6; 
  DObjPartBits *p_hidePartBits; 
  const dvar_t *v8; 
  scr_string_t tag_glass_ads; 
  DObjPartBits *v10; 
  DObj *v11; 
  scr_string_t tag_glass_hip2; 
  DObjPartBits *v13; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5595, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v5 = DCONST_DVARBOOL_bg_debugWeaponGlass;
  if ( !DCONST_DVARBOOL_bg_debugWeaponGlass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_debugWeaponGlass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled )
  {
    v6 = DCONST_DVARBOOL_bg_showWeaponGlassHip;
    if ( !DCONST_DVARBOOL_bg_showWeaponGlassHip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassHip") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    p_hidePartBits = &obj->hidePartBits;
    if ( v6->current.enabled )
    {
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
    }
    else
    {
      BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
      BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
    }
    v8 = DCONST_DVARBOOL_bg_showWeaponGlassADS;
    if ( !DCONST_DVARBOOL_bg_showWeaponGlassADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassADS") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    tag_glass_ads = scr_const.tag_glass_ads;
    v10 = &obj->hidePartBits;
    v11 = obj;
    if ( v8->current.enabled )
      goto LABEL_18;
LABEL_24:
    BG_HideBoneByModelRange(tag_glass_ads, v11, v10, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
    return;
  }
  v13 = &obj->hidePartBits;
  if ( !adsSmoothFade )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v13, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, &obj->hidePartBits, 0, -1);
    tag_glass_hip2 = scr_const.tag_glass_hip2;
    goto LABEL_26;
  }
  if ( adsFrac >= 1.0 )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, v13, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, v13, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  tag_glass_ads = scr_const.tag_glass_ads;
  v10 = &obj->hidePartBits;
  v11 = obj;
  if ( adsFrac < 0.0 )
    goto LABEL_24;
LABEL_18:
  BG_ShowBoneByModelRange(tag_glass_ads, v11, v10, 0, -1);
  tag_glass_hip2 = scr_const.tag_glass_ads2;
LABEL_26:
  BG_ShowBoneByModelRange(tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
}

/*
==============
BG_UpdateWeaponGlassDebug
==============
*/
void BG_UpdateWeaponGlassDebug(const float adsFrac, DObj *const obj)
{
  const dvar_t *v2; 
  DObjPartBits *p_hidePartBits; 
  const dvar_t *v5; 
  DObjPartBits *v6; 

  v2 = DCONST_DVARBOOL_bg_showWeaponGlassHip;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassHip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassHip") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  p_hidePartBits = &obj->hidePartBits;
  if ( v2->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  v5 = DCONST_DVARBOOL_bg_showWeaponGlassADS;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassADS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = &obj->hidePartBits;
  if ( v5->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v6, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v6, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
  }
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObj
==============
*/
void BG_UpdateWeaponHidePartBitsForDObj(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel)
{
  const dvar_t *v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 outHideTagCount; 
  scr_string_t outHideTagBuffer[324]; 

  if ( !obj )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5794, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5774, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
  }
  v8 = DCONST_DVARMPBOOL_player_isInZeroGLevel;
  if ( !DCONST_DVARMPBOOL_player_isInZeroGLevel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_isInZeroGLevel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off, obj, &obj->hidePartBits, startModel, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off2, obj, &obj->hidePartBits, startModel, -1);
  }
  v9 = 0i64;
  outHideTagCount = 0i64;
  BG_GetWeaponExplicitHideTags(r_weapon, 0, isViewModel, 0x142ui64, outHideTagBuffer, &outHideTagCount);
  v10 = outHideTagCount;
  if ( outHideTagCount )
  {
    do
      BG_HideBoneByModelRange(outHideTagBuffer[v9++], obj, &obj->hidePartBits, startModel, -1);
    while ( v9 < v10 );
  }
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObjByModelRange
==============
*/
void BG_UpdateWeaponHidePartBitsForDObjByModelRange(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel, int lastModelInclusive)
{
  const dvar_t *v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 outHideTagCount; 
  scr_string_t outHideTagBuffer[324]; 

  if ( !obj )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5794, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5774, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
  }
  v9 = DCONST_DVARMPBOOL_player_isInZeroGLevel;
  if ( !DCONST_DVARMPBOOL_player_isInZeroGLevel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_isInZeroGLevel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off2, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  }
  v10 = 0i64;
  outHideTagCount = 0i64;
  BG_GetWeaponExplicitHideTags(r_weapon, 0, isViewModel, 0x142ui64, outHideTagBuffer, &outHideTagCount);
  v11 = outHideTagCount;
  if ( outHideTagCount )
  {
    do
      BG_HideBoneByModelRange(outHideTagBuffer[v10++], obj, &obj->hidePartBits, startModel, lastModelInclusive);
    while ( v10 < v11 );
  }
}

/*
==============
BG_UpdatedWeaponBones
==============
*/
void BG_UpdatedWeaponBones(const Weapon *r_weapon, DObj *obj, int startModel)
{
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, startModel, -1);
  BG_UpdatedWeaponIronSightBones(r_weapon, obj, startModel, -1);
}

/*
==============
BG_UpdatedWeaponBonesByModelRange
==============
*/
void BG_UpdatedWeaponBonesByModelRange(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, startModel, lastModelInclusive);
  BG_UpdatedWeaponIronSightBones(r_weapon, obj, startModel, lastModelInclusive);
}

/*
==============
BG_UpdatedWeaponIronSightBones
==============
*/
void BG_UpdatedWeaponIronSightBones(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v9; 
  AttSight *sight; 
  const WeaponAttachment *v11; 
  AttSight *v12; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( (WeaponPrimaryAttachment || (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL) && WeaponPrimaryAttachment->ignoreIronSights )
  {
    BG_ShowIronSights(obj, startModel, lastModelInclusive);
    return;
  }
  v9 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( v9 )
  {
    sight = v9->sight;
    if ( sight && sight->hideRailWithThisScope )
    {
      BG_HideIronSights(obj, startModel, lastModelInclusive, 1);
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if ( BG_HasUnderbarrelAmmo(r_weapon) && BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)->hideIronSightsWithThisAttachment )
  {
LABEL_12:
    BG_HideIronSights(obj, startModel, lastModelInclusive, 0);
    goto LABEL_14;
  }
  BG_ShowIronSights(obj, startModel, lastModelInclusive);
LABEL_14:
  v11 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( v11 || (v11 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL )
  {
    v12 = v11->sight;
    if ( v12 )
    {
      if ( v12->forceIronSightDown )
      {
        if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5212, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
          __debugbreak();
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
      }
    }
  }
}

/*
==============
BG_UseADSFireAnim
==============
*/
bool BG_UseADSFireAnim(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  const WeaponDef *v6; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v8; 
  float adsFireAnimFrac; 
  AttADSSettings *WeaponAdsSettings; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13762, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13763, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, GameModeFlagValues::ms_mpValue, 0x36u) )
    return 1;
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13726, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v6 = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx);
  v8 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  adsFireAnimFrac = v6->adsFireAnimFrac;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(CurrentWeaponForPlayer, v5, v8, 0);
  if ( WeaponAdsSettings )
    adsFireAnimFrac = WeaponAdsSettings->adsFireAnimFrac;
  return adsFireAnimFrac < ps->weapCommon.fWeaponPosFrac;
}

/*
==============
BG_UseAngularGunKick
==============
*/
_BOOL8 BG_UseAngularGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useAngularGunKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useAngularGunKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useAngularGunKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useAngularGunKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14493, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentGunKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useAngularGunKick;
  }
  return AttachmentGunKick->useAngularGunKick;
}

/*
==============
BG_UseAngularViewKick
==============
*/
_BOOL8 BG_UseAngularViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useAngularViewKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useAngularViewKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useAngularViewKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useAngularViewKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14516, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useAngularViewKick;
  }
  return AttachmentViewKick->useAngularViewKick;
}

/*
==============
BG_UseFastADSAnims
==============
*/
bool BG_UseFastADSAnims(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttMovement *movement; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8256, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    movement = (*i)->movement;
    if ( movement )
      break;
    movement = (*i)->movementScale;
    if ( movement )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return movement->fastADS3PAnims;
}

/*
==============
BG_UseFastOffhand
==============
*/
bool BG_UseFastOffhand(const playerState_s *ps, const BgWeaponMap *weaponMap)
{
  const Weapon *OffHandWeaponForPlayer; 
  bool v5; 
  bool result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10792, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = 0;
  if ( BG_HasPerk(&ps->perks, 0x15u) )
  {
    OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(weaponMap, ps);
    v5 = BG_UsingAlternate(ps);
    if ( BG_InheritsPerks(OffHandWeaponForPlayer, v5) )
      return 1;
  }
  return result;
}

/*
==============
BG_UseFastReload
==============
*/
bool BG_UseFastReload(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10811, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return (BG_HasPerk(&ps->perks, 1u) || BG_GameInterface_HasFastReloadPerkVariant(&ps->perks)) && BG_InheritsPerks(r_weapon, isAlternate);
}

/*
==============
BG_UseFastReloadAnims
==============
*/
bool BG_UseFastReloadAnims(const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex hand, int ammoInClip, weapAnimFiles_t reloadAnimFile)
{
  bool result; 
  int v12; 
  char v13; 
  int v14; 
  const PlayerWeaponAnimArrays *v15; 
  XAnimParts *const *altAnimArray; 
  int v17; 
  int v18[282]; 
  __m256i v19; 
  __m256i v20; 
  int v21; 
  int v22; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10917, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_UseFastReload(ps, r_weapon, isAlternate) || (result = BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip)) )
  {
    if ( (unsigned int)(reloadAnimFile - 381) > 7 )
    {
      if ( (unsigned int)(reloadAnimFile - 389) > 7 )
      {
        if ( (unsigned int)(reloadAnimFile - 286) > 0x11 )
        {
          v12 = 0;
          if ( (unsigned int)(reloadAnimFile - 304) <= 0x11 )
            v12 = 2;
        }
        else
        {
          v12 = 1;
        }
        v13 = 0;
      }
      else
      {
        v12 = 4;
        v13 = 1;
      }
    }
    else
    {
      v12 = 3;
      v13 = 1;
    }
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10929, ASSERT_TYPE_ASSERT, "(reloadAnimFileType != RELOAD_ANIM_FILE_TYPE_INVALID)", (const char *)&queryFormat, "reloadAnimFileType != RELOAD_ANIM_FILE_TYPE_INVALID") )
      __debugbreak();
    v14 = BG_PlayerDualWielding(ps);
    v15 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
    altAnimArray = (XAnimParts *const *)v15;
    if ( v14 && hand == WEAPON_HAND_LEFT || isAlternate )
      altAnimArray = v15->altAnimArray;
    if ( v13 )
    {
      if ( v12 == 3 )
      {
        v17 = g_reloadMultipleFastAnimMap[reloadAnimFile - 381];
        return BG_WeaponAnimExists(altAnimArray, v17) != 0;
      }
    }
    else if ( v12 == 1 )
    {
      v19 = _ymm;
      v20 = _ymm;
      v21 = 320;
      v22 = 321;
      v17 = v18[reloadAnimFile];
      return BG_WeaponAnimExists(altAnimArray, v17) != 0;
    }
    v17 = reloadAnimFile;
    return BG_WeaponAnimExists(altAnimArray, v17) != 0;
  }
  return result;
}

/*
==============
BG_UseFastReloadLowAmmo
==============
*/
bool BG_UseFastReloadLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip)
{
  const dvar_t *v8; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10829, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !BG_HasPerk(&ps->perks, 2u) || !BG_InheritsPerks(r_weapon, isAlternate) )
    return 0;
  v8 = DVARBOOL_perk_weapReloadMultiplierEmptyOnLowAmmo;
  if ( !DVARBOOL_perk_weapReloadMultiplierEmptyOnLowAmmo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapReloadMultiplierEmptyOnLowAmmo") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
    return ammoInClip <= BG_GetClipLowAmmo(ps, r_weapon, isAlternate);
  else
    return ammoInClip == 0;
}

/*
==============
BG_UseLeftTriggerAltFireMode
==============
*/
bool BG_UseLeftTriggerAltFireMode(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && WeaponPrimaryAttachment->useLeftTriggerAltFire;
}

/*
==============
BG_UseQuickSwitchAnims
==============
*/
bool BG_UseQuickSwitchAnims(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const BgHandler *pmoveHandler, const bool checkRaise)
{
  unsigned __int16 WeaponFieldTimeWithDependentAnimation; 
  const PlayerWeaponAnimArrays *v11; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19169, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( checkRaise )
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 144i64, NUM_WEAP_ANIMS);
  else
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 142i64, NUM_WEAP_ANIMS);
  if ( WeaponFieldTimeWithDependentAnimation )
  {
    v11 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19179, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    if ( isAlternate )
      v11 = (const PlayerWeaponAnimArrays *)((char *)v11 + 4976);
    LOBYTE(WeaponFieldTimeWithDependentAnimation) = v11->normalAnimArray[!checkRaise + 333] != NULL;
  }
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_UseScopeDrift
==============
*/
_BOOL8 BG_UseScopeDrift(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  bool v5; 
  const Weapon *CurrentWeaponForPlayer; 
  int v7; 
  bool useScopeDrift; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2901, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2902, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActive(ps) )
    return 0i64;
  v5 = BG_UsingAlternate(ps);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_HIGH|WEAPON_LADDER_AIM) )
  {
    v7 = 0;
    useScopeDrift = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->useScopeDrift;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2923, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        sight = (*i)->sight;
        if ( sight )
          break;
        if ( ++v7 >= WeaponAttachments_Internal )
          return useScopeDrift;
      }
      return sight->useScopeDrift;
    }
    return useScopeDrift;
  }
  else
  {
    return BG_UsingSniperScope(weaponMap, ps) && BG_GetWeaponClass(CurrentWeaponForPlayer, v5) != WEAPCLASS_ITEM;
  }
}

/*
==============
BG_UseSmoothGunKick
==============
*/
_BOOL8 BG_UseSmoothGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useNewGunKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useNewGunKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useNewGunKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useNewGunKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14447, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentGunKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useNewGunKick;
  }
  return AttachmentGunKick->useNewGunKick;
}

/*
==============
BG_UseSmoothViewKick
==============
*/
_BOOL8 BG_UseSmoothViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useNewViewKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useNewViewKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useNewViewKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useNewViewKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14470, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useNewViewKick;
  }
  return AttachmentViewKick->useNewViewKick;
}

/*
==============
BG_UsesContinousAdsIdleTransiton
==============
*/
_BOOL8 BG_UsesContinousAdsIdleTransiton(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  WeaponAttachment *v6; 
  AttIdleSettings *idleSettings; 
  const WeaponDef *v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      v6 = *v5;
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12228, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      idleSettings = v6->idleSettings;
      if ( idleSettings )
        return idleSettings->useUninterruptedAdsIdleMotion;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12236, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v8->useUninterruptedAdsIdleMotion;
  }
}

/*
==============
BG_UsesReverseWeaponSpread
==============
*/
bool BG_UsesReverseWeaponSpread(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  float *p_hipSpreadStandMin; 
  const WeaponDef *v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v11[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v11, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13780, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      p_hipSpreadStandMin = &(*v5)->hipSpread->hipSpreadStandMin;
      if ( p_hipSpreadStandMin )
        return p_hipSpreadStandMin[5] < *p_hipSpreadStandMin;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    return v7->hipSpreadStandMax < v7->fHipSpreadStandMin;
  }
}

/*
==============
BG_UsesShelvedDamageFalloff
==============
*/
bool BG_UsesShelvedDamageFalloff(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  __int64 v5; 
  const WeaponDef *v6; 
  int v7; 
  unsigned int WeaponAttachments_Internal; 
  float minDamageRange; 
  float maxDamageRange; 
  WeaponAttachment **i; 
  AttDamage *damage; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v5 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9251, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v7 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( (unsigned int)v5 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  minDamageRange = v6->damageInfo.damageData[v5].minDamageRange;
  if ( minDamageRange < 0.0 )
    minDamageRange = v6->damageInfo.damageData[0].minDamageRange;
  maxDamageRange = v6->damageInfo.damageData[v5].maxDamageRange;
  if ( maxDamageRange < 0.0 )
    maxDamageRange = v6->damageInfo.damageData[0].maxDamageRange;
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9269, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damage = (*i)->damage;
      if ( damage )
        break;
      if ( ++v7 >= WeaponAttachments_Internal )
        return minDamageRange == 0.0 && maxDamageRange > 0.0;
    }
    if ( (unsigned int)v5 >= 3 )
    {
      LODWORD(attachmentSlots) = 3;
      LODWORD(numAttachmentSlots) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    minDamageRange = damage->damageInfo.damageData[v5].minDamageRange;
    if ( minDamageRange < 0.0 )
      minDamageRange = damage->damageInfo.damageData[0].minDamageRange;
    maxDamageRange = damage->damageInfo.damageData[v5].maxDamageRange;
    if ( maxDamageRange < 0.0 )
      maxDamageRange = damage->damageInfo.damageData[0].maxDamageRange;
  }
  return minDamageRange == 0.0 && maxDamageRange > 0.0;
}

/*
==============
BG_UsingSniperScope
==============
*/
_BOOL8 BG_UsingSniperScope(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  double v6; 
  float v7; 
  float v8; 
  float v9; 
  double v10; 
  double v11; 
  const Weapon *v12; 
  bool v13; 
  const ADSOverlay *Overlay; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2802, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2803, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v5, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, 1.0, 6u);
  v7 = *(float *)&v6;
  v8 = (float)(ps->commandTimeInterpolated - ps->weapCommon.lastReloadStateChangeTime);
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
    v9 = (float)(v8 * outAdsTransOutSpeedMs) + v7;
  else
    v9 = v7 - (float)(v8 * outAdsTransInSpeedMs);
  v10 = I_fclamp(v9, 0.0, 1.0);
  v11 = I_fclamp((float)(1.0 - *(float *)&v10) * ps->weapCommon.fWeaponPosFrac, 0.0, 1.0);
  if ( *(float *)&v11 <= 0.0 )
    return 0i64;
  v12 = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v13 = BG_UsingAlternate(ps);
  Overlay = BG_GetOverlay(v12, v13);
  if ( !Overlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2809, ASSERT_TYPE_ASSERT, "(overlay)", (const char *)&queryFormat, "overlay") )
    __debugbreak();
  return Overlay->reticle != WEAPOVERLAYRETICLE_NONE;
}

/*
==============
BG_VMProjBodyEffect
==============
*/
FxCombinedDef BG_VMProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->vmProjBodyEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17549, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->vmProjBodyEffect.particleSystemDef;
}

/*
==============
BG_ValidateWeapon
==============
*/
char BG_ValidateWeapon(const Weapon *r_weapon)
{
  AttachmentSlot v2; 
  const WeaponCompleteDef *v3; 
  bool v4; 
  unsigned __int16 v5; 

  if ( !BG_WeaponSetup_Initialized() )
    return 1;
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3480, ASSERT_TYPE_ASSERT, "(BG_ValidateWeaponNumber( r_weapon ))", (const char *)&queryFormat, "BG_ValidateWeaponNumber( r_weapon )") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 1;
  v2 = ATT_SLOT_RECEIVER;
  v3 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3488, ASSERT_TYPE_ASSERT, "( ( weapCompleteDef != nullptr ) )", "( weapCompleteDef ) = %p", NULL) )
    __debugbreak();
  v4 = 1;
  while ( 1 )
  {
    if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
      __debugbreak();
    v5 = v2 == ATT_SLOT_VISUAL ? r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8) : r_weapon->weaponAttachments[v2];
    if ( !BG_ValidateWeaponAttachment(v3, v2, v5) )
      break;
    v4 = ++v2 < ATT_SLOT_OTHER;
    if ( (unsigned int)v2 >= ATT_SLOT_OTHER )
    {
      LOWORD(_EBX) = r_weapon->weaponOthers;
      if ( !(_WORD)_EBX )
        return 1;
      while ( 1 )
      {
        _EBX = (unsigned __int16)_EBX;
        __asm { tzcnt   edi, ebx }
        if ( _EDI > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)_EDI, "unsigned", _EDI) )
          __debugbreak();
        if ( !BG_ValidateWeaponAttachment(v3, ATT_SLOT_OTHER, (unsigned __int8)_EDI) )
          break;
        _EBX = (unsigned __int16)_EBX ^ (1 << _EDI);
        if ( !(_WORD)_EBX )
          return 1;
      }
      return 0;
    }
  }
  return 0;
}

/*
==============
BG_ValidateWeaponAttachment
==============
*/
char BG_ValidateWeaponAttachment(const WeaponCompleteDef *const weapCompleteDef, const AttachmentSlot slot, const unsigned __int16 weaponAttachmentIndex)
{
  __int64 v3; 
  AttachmentList *v5; 
  const char *v6; 
  const dvar_t *v7; 
  char *fmt; 
  __int64 v10; 
  int v11; 
  unsigned int attachmentCount; 

  v3 = slot;
  if ( !weaponAttachmentIndex )
    return 1;
  v5 = &weapCompleteDef->attachments[slot];
  if ( (const WeaponCompleteDef *const)((char *)weapCompleteDef + 16 * slot) == (const WeaponCompleteDef *const)-40i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3453, ASSERT_TYPE_ASSERT, "( ( attachmentList != nullptr ) )", "( attachmentList ) = %p", &weapCompleteDef->attachments[slot]) )
    __debugbreak();
  if ( weaponAttachmentIndex <= v5->attachmentCount )
    return 1;
  if ( (unsigned int)v3 >= 0xE )
  {
    v11 = 14;
    LODWORD(v10) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 155, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( ( sizeof( *array_counter( ATTACHMENT_SLOT_NAMES ) ) + 0 ) )", "slot doesn't index ARRAY_COUNT( ATTACHMENT_SLOT_NAMES )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  v6 = off_147EBF7B0[v3];
  v7 = DCONST_DVARBOOL_bg_weapons_pedantic;
  if ( !DCONST_DVARBOOL_bg_weapons_pedantic && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_weapons_pedantic") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled )
  {
    attachmentCount = v5->attachmentCount;
    LODWORD(v10) = weaponAttachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 167, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "WARNING: Attachment index %u in slot %s is out of bounds (%u)!\n", v10, v6, attachmentCount) )
      __debugbreak();
  }
  LODWORD(fmt) = v5->attachmentCount;
  Com_PrintWarning(17, "WARNING: Attachment index %u in slot %s is out of bounds (%u)!\n", weaponAttachmentIndex, v6, fmt);
  return 0;
}

/*
==============
BG_ValidateWeaponNumber
==============
*/
bool BG_ValidateWeaponNumber(const Weapon *r_weapon)
{
  return r_weapon->weaponIdx < BG_GetNumWeapons();
}

/*
==============
BG_ValidateWeaponNumberOffhand
==============
*/
bool BG_ValidateWeaponNumberOffhand(const Weapon *r_weapon)
{
  unsigned int weaponIdx; 
  OffhandClass offhandClass; 
  bool result; 

  weaponIdx = r_weapon->weaponIdx;
  result = 0;
  if ( weaponIdx < BG_GetNumWeapons() )
  {
    if ( !(_WORD)weaponIdx )
      return 1;
    offhandClass = BG_WeaponDefAtIndex(weaponIdx)->offhandClass;
    if ( offhandClass )
    {
      if ( offhandClass < OFFHAND_CLASS_COUNT )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_ViewFlashADSEffect
==============
*/
FxCombinedDef BG_ViewFlashADSEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 56i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 16i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 40i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 16i64);
  }
  return result;
}

/*
==============
BG_ViewFlashEffect
==============
*/
FxCombinedDef BG_ViewFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 48i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 0i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 24i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 0i64);
  }
  return result;
}

/*
==============
BG_ViewLastShotEjectEffect
==============
*/
FxCombinedDef BG_ViewLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 88i64);
}

/*
==============
BG_ViewMagEjectEffect
==============
*/
FxCombinedDef BG_ViewMagEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 104i64);
}

/*
==============
BG_ViewModelAnimExists
==============
*/
_BOOL8 BG_ViewModelAnimExists(const playerState_s *ps, weapAnimFiles_t anim, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  __int64 v4; 
  const PlayerWeaponAnimArrays *v8; 
  bool v9; 
  __int64 v11; 

  v4 = anim;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2761, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x260 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2762, ASSERT_TYPE_ASSERT, "(unsigned)( anim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "anim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v11, 608) )
      __debugbreak();
  }
  v8 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2765, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v9 = BG_PlayerDualWielding(ps) != 0;
  if ( BG_UsingAlternate(ps) )
  {
    if ( !v9 )
    {
LABEL_15:
      v8 = (const PlayerWeaponAnimArrays *)((char *)v8 + 4976);
      return v8->normalAnimArray[v4] != NULL;
    }
  }
  else if ( !v9 )
  {
    return v8->normalAnimArray[v4] != NULL;
  }
  if ( hand == WEAPON_HAND_LEFT )
    goto LABEL_15;
  return v8->normalAnimArray[v4] != NULL;
}

/*
==============
BG_ViewModelBlendSpaceExists
==============
*/
_BOOL8 BG_ViewModelBlendSpaceExists(const playerState_s *ps, WeaponBlendSpaceType blendSpaceType, const BgHandler *pmoveHandler)
{
  __int64 v3; 
  const PlayerWeaponAnimArrays *v6; 
  __int64 v8; 

  v3 = blendSpaceType;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2784, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2785, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( (unsigned int)v3 >= 8 )
  {
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2786, ASSERT_TYPE_ASSERT, "(unsigned)( blendSpaceType ) < (unsigned)( WEAPON_BLEND_SPACE_COUNT )", "blendSpaceType doesn't index WEAPON_BLEND_SPACE_COUNT\n\t%i not in [0, %i)", v8, 8) )
      __debugbreak();
  }
  v6 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2789, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  return v6->blendSpaces[v3] != NULL;
}

/*
==============
BG_ViewShellEjectEffect
==============
*/
FxCombinedDef BG_ViewShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 72i64);
}

/*
==============
BG_WalkLoopTime
==============
*/
__int64 BG_WalkLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 176i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_WALK_START, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_WarningIconsDelay
==============
*/
float BG_WarningIconsDelay(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->warningIconsDelay;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16280, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->warningIconsDelay;
  }
  return ui->warningIconsDelay;
}

/*
==============
BG_WeapDetonateType
==============
*/
__int64 BG_WeapDetonateType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return (unsigned int)v2->detonateType;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0xFC4];
}

/*
==============
BG_WeapHasDetonator
==============
*/
bool BG_WeapHasDetonator(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->detonateType != DETONATE_TYPE_NONE;
}

/*
==============
BG_WeapHasGestureDetonation
==============
*/
bool BG_WeapHasGestureDetonation(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->detonateType == DETONATE_TYPE_GESTURE;
}

/*
==============
BG_WeaponADSFractionAffectedByReload
==============
*/
double BG_WeaponADSFractionAffectedByReload(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  double v6; 
  float v7; 
  float v8; 
  float v9; 
  double v10; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v5, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, 1.0, 6u);
  v7 = *(float *)&v6;
  v8 = (float)(ps->commandTimeInterpolated - ps->weapCommon.lastReloadStateChangeTime);
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
    v9 = (float)(v8 * outAdsTransOutSpeedMs) + v7;
  else
    v9 = v7 - (float)(v8 * outAdsTransInSpeedMs);
  v10 = I_fclamp(v9, 0.0, 1.0);
  return I_fclamp((float)(1.0 - *(float *)&v10) * ps->weapCommon.fWeaponPosFrac, 0.0, 1.0);
}

/*
==============
BG_WeaponAIFuseTime
==============
*/
__int64 BG_WeaponAIFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->aiFuseTime;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19137, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->aiFuseTime;
  }
  return (unsigned int)projectile->aiFuseTime;
}

/*
==============
BG_WeaponAnimExists
==============
*/
_BOOL8 BG_WeaponAnimExists(XAnimParts *const *weaponAnims, int animIndex)
{
  __int64 v2; 

  v2 = animIndex;
  if ( !weaponAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10754, ASSERT_TYPE_ASSERT, "(weaponAnims)", (const char *)&queryFormat, "weaponAnims") )
    __debugbreak();
  if ( (int)v2 >= 608 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10755, ASSERT_TYPE_ASSERT, "(animIndex < NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "animIndex < NUM_WEAP_VIEWMODEL_ANIMS") )
    __debugbreak();
  return weaponAnims[v2] != NULL;
}

/*
==============
BG_WeaponAnimNumberExists
==============
*/
int BG_WeaponAnimNumberExists(const BgWeaponMap *weaponMap, const playerState_s *ps, int weaponAnimNumber, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  bool v9; 
  const Weapon *ViewmodelWeapon; 
  weapAnimFiles_t v11; 
  PlayerHandIndex handIndex; 

  if ( (unsigned int)weaponAnimNumber >= 0x56 )
  {
    handIndex = 86;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2748, ASSERT_TYPE_ASSERT, "(unsigned)( weaponAnimNumber ) < (unsigned)( MAX_WP_ANIMATIONS )", "weaponAnimNumber doesn't index MAX_WP_ANIMATIONS\n\t%i not in [0, %i)", weaponAnimNumber, handIndex) )
      __debugbreak();
  }
  v9 = BG_UsingAlternate(ps);
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  v11 = BG_MapWeaponAnimStateToAnimIndex(weaponMap, ps, weaponAnimNumber, 0, ViewmodelWeapon, v9, hand, pmoveHandler);
  return BG_ViewModelAnimExists(ps, v11, hand, pmoveHandler);
}

/*
==============
BG_WeaponAttachmentAdsSmoothFade
==============
*/
bool BG_WeaponAttachmentAdsSmoothFade(const Weapon *r_weapon, const bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttSight *sight; 

  return (isAlternate && (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && !WeaponPrimaryAttachment->shareAmmoWithAlt || (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE)) != NULL) && (sight = WeaponPrimaryAttachment->sight) != NULL && sight->adsSmoothFade;
}

/*
==============
BG_WeaponBlocksProne
==============
*/
_BOOL8 BG_WeaponBlocksProne(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blocksProne;
}

/*
==============
BG_WeaponBulletFire_ExplodeOnImpact
==============
*/
bool BG_WeaponBulletFire_ExplodeOnImpact(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 
  const dvar_t *v6; 
  bool result; 
  bitarray<64> r_perks; 

  r_perks = perks;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6261, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  if ( v5->bBulletExplosiveDamage )
    return 1;
  v6 = DVARBOOL_bg_forceExplosiveBullets;
  if ( !DVARBOOL_bg_forceExplosiveBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_forceExplosiveBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled )
    return 1;
  result = BG_HasPerk(&r_perks, 0x22u);
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetClientHitEvent
==============
*/
__int64 BG_WeaponBulletFire_GetClientHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  __int64 result; 
  __int64 v5; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6238, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  if ( !meansOfDeath )
    goto LABEL_8;
  if ( meansOfDeath <= 2 )
    goto LABEL_14;
  if ( meansOfDeath != 3 )
  {
    if ( meansOfDeath != 9 )
    {
LABEL_8:
      LODWORD(v5) = meansOfDeath;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6250, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported Bullet meansOfDeath '%i' for GetClientHitEvent", v5) )
        __debugbreak();
      return 0i64;
    }
LABEL_14:
    result = 96i64;
    if ( serverPlayerHitEvent )
      return 213i64;
    return result;
  }
  result = 97i64;
  if ( serverPlayerHitEvent )
    return 214i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetExplDmg
==============
*/
float BG_WeaponBulletFire_GetExplDmg(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  float bulletExplDmgMult; 
  const dvar_t *v6; 
  float value; 
  int outMaxDamage; 
  int outMinDamage; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6358, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  bulletExplDmgMult = v4->bulletExplDmgMult;
  if ( bulletExplDmgMult <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6359, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplDmgMult > 0.0f ) )", "( weapDef->bulletExplDmgMult ) = %g", bulletExplDmgMult) )
    __debugbreak();
  v6 = DVARFLT_bg_bulletExplDmgFactor;
  if ( !DVARFLT_bg_bulletExplDmgFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplDmgFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  value = v6->current.value;
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(WEAP_DMG_CALC_TYPE_DEFAULT, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (float)((float)outMaxDamage * value) * v4->bulletExplDmgMult;
}

/*
==============
BG_WeaponBulletFire_GetExplDmgMin
==============
*/
float BG_WeaponBulletFire_GetExplDmgMin(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  float bulletExplDmgMultMin; 
  const dvar_t *v6; 
  float value; 
  int outMaxDamage; 
  int outMinDamage; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6347, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  bulletExplDmgMultMin = v4->bulletExplDmgMultMin;
  if ( bulletExplDmgMultMin < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6348, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplDmgMultMin >= 0.0f ) )", "( weapDef->bulletExplDmgMultMin ) = %g", bulletExplDmgMultMin) )
    __debugbreak();
  v6 = DVARFLT_bg_bulletExplDmgFactor;
  if ( !DVARFLT_bg_bulletExplDmgFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplDmgFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  value = v6->current.value;
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(WEAP_DMG_CALC_TYPE_DEFAULT, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (float)((float)outMaxDamage * value) * v4->bulletExplDmgMultMin;
}

/*
==============
BG_WeaponBulletFire_GetExplRadius
==============
*/
float BG_WeaponBulletFire_GetExplRadius(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  float bulletExplRadiusMult; 
  const dvar_t *v6; 
  float value; 
  const dvar_t *v8; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6371, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  bulletExplRadiusMult = v4->bulletExplRadiusMult;
  if ( bulletExplRadiusMult <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6372, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplRadiusMult > 0.0f ) )", "( weapDef->bulletExplRadiusMult ) = %g", bulletExplRadiusMult) )
    __debugbreak();
  v6 = DVARFLT_bg_bulletExplRadius;
  if ( !DVARFLT_bg_bulletExplRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplRadius") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  value = v6->current.value;
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG )
    return value * v4->bulletExplRadiusMult;
  v8 = DVARFLT_bg_alienBulletExplRadius;
  if ( !DVARFLT_bg_alienBulletExplRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_alienBulletExplRadius") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  return v8->current.value * v4->bulletExplRadiusMult;
}

/*
==============
BG_WeaponBulletFire_GetHitEvent
==============
*/
__int64 BG_WeaponBulletFire_GetHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  __int64 result; 
  __int64 v5; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6217, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  if ( !meansOfDeath )
    goto LABEL_9;
  if ( meansOfDeath <= 2 )
    goto LABEL_15;
  if ( meansOfDeath != 3 )
  {
    if ( meansOfDeath != 9 && meansOfDeath != 20 )
    {
LABEL_9:
      LODWORD(v5) = meansOfDeath;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6230, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported Bullet meansOfDeath '%i' for GetHitEvent", v5) )
        __debugbreak();
      return 0i64;
    }
LABEL_15:
    result = 93i64;
    if ( serverPlayerHitEvent )
      return 211i64;
    return result;
  }
  result = 94i64;
  if ( serverPlayerHitEvent )
    return 212i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetMethodOfDeath
==============
*/
__int64 BG_WeaponBulletFire_GetMethodOfDeath(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  weapClass_t WeaponClass; 
  __int64 result; 
  unsigned int v8; 
  bool bRifleBullet; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
  if ( WeaponClass == WEAPCLASS_BEAM || WeaponClass == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM )
    return 2i64;
  if ( BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate) )
    return 3i64;
  if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet )
    return 20i64;
  v8 = 0;
  bRifleBullet = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRifleBullet;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7326, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      penetration = (*v11)->penetration;
      if ( penetration )
        break;
      ++v8;
      ++v11;
      if ( v8 >= WeaponAttachments_Internal )
        goto LABEL_17;
    }
    bRifleBullet = penetration->rifleBullet;
  }
LABEL_17:
  result = 1i64;
  if ( bRifleBullet )
    return 2i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_ShouldPenetrate
==============
*/
bool BG_WeaponBulletFire_ShouldPenetrate(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 

  v3 = DCONST_DVARMPBOOL_bullet_penetration_enabled;
  if ( !DCONST_DVARMPBOOL_bullet_penetration_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bullet_penetration_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.enabled && (unsigned int)(BG_GetPenetrateType(r_weapon, isAlternate) - 1) <= 3 && !BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldRicochet
==============
*/
bool BG_WeaponBulletFire_ShouldRicochet(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 
  tracerStyle_t tracerStyle; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v9; 
  AttAmmoTracer *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = DCONST_DVARBOOL_bullet_ricochet_enabled;
  if ( !DCONST_DVARBOOL_bullet_ricochet_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bullet_ricochet_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled || BG_GetPenetrateType(r_weapon, isAlternate) != PENETRATE_TYPE_RICOCHET || BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate) || BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET || BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bEnergyBullet && Dvar_GetBool_Internal_DebugName(DVARBOOL_disable_energy_bullet_ricochet, "disable_energy_bullet_ricochet") )
    return 0;
  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  tracerStyle = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->tracerStyle;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v9 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( WeaponPrimaryAttachment && (v10 = WeaponPrimaryAttachment->tracer) != NULL && isAlternate )
  {
    tracerStyle = v10->tracerStyle;
  }
  else
  {
    v11 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7284, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        tracer = (*i)->tracer;
        if ( tracer )
        {
          if ( *i != v9 )
            break;
        }
        if ( ++v11 >= WeaponAttachments_Internal )
          return tracerStyle != TRACERSTYLE_BEAM;
      }
      tracerStyle = tracer->tracerStyle;
    }
  }
  return tracerStyle != TRACERSTYLE_BEAM;
}

/*
==============
BG_WeaponBulletFire_ShouldSpread
==============
*/
bool BG_WeaponBulletFire_ShouldSpread(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6280, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  return BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_SPREAD && !BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate);
}

/*
==============
BG_WeaponCanAutoReload
==============
*/
bool BG_WeaponCanAutoReload(const playerState_s *ps, const Weapon *currentWeapon, bool isAlternate)
{
  const WeaponDef *v6; 
  bool reloadDisabled; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7963, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x13u) )
    return 0;
  v6 = BG_WeaponDefAtIndex(currentWeapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7944, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  reloadDisabled = v6->reloadDisabled;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(currentWeapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      reload = (*i)->reload;
      if ( reload )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return !reloadDisabled;
    }
    reloadDisabled = reload->reloadDisabled;
  }
  return !reloadDisabled;
}

/*
==============
BG_WeaponCharge_GetAttachment
==============
*/
WeaponAttachment *BG_WeaponCharge_GetAttachment(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  __int64 v6; 
  const char *WeaponName; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char output[1024]; 

  v2 = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    v6 = WeaponAttachments_Internal;
    do
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6456, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v5)->charged )
      {
        if ( v2 )
        {
          WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
          Com_PrintWarning(14, "Weapon '%s' has multiple attachments '%s' with charged overrides. Am using '%s'\n", WeaponName, (*v5)->szDisplayName, v2->szDisplayName);
        }
        else
        {
          v2 = *v5;
        }
      }
      ++v5;
      --v6;
    }
    while ( v6 );
  }
  return v2;
}

/*
==============
BG_WeaponCharge_GetChargeDownSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6606, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6611, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeDownSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeDownSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeDownSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeDownSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeDownToUpSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeDownToUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6622, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6627, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeDownToUpSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeDownToUpSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeDownToUpSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeDownToUpSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeMaxSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeMaxSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6654, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6659, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeMaxSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeMaxSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeMaxSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeMaxSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeUpSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6590, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6595, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeUpSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeUpSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeUpSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeUpSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeUpToDownSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeUpToDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6638, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6643, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeUpToDownSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeUpToDownSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeUpToDownSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeUpToDownSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetCostPerShot
==============
*/
float BG_WeaponCharge_GetCostPerShot(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6542, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeCostPerShot;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6547, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeCostPerShot;
}

/*
==============
BG_WeaponCharge_GetEmptyCooldown
==============
*/
float BG_WeaponCharge_GetEmptyCooldown(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6558, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeEmptyCooldown;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6563, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeEmptyCooldown;
}

/*
==============
BG_WeaponCharge_GetFireAtMaxDamageMultiplier
==============
*/
float BG_WeaponCharge_GetFireAtMaxDamageMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6574, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeFireAtMaxDamageMultiplier;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6579, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeFireAtMaxDamageMultiplier;
}

/*
==============
BG_WeaponCharge_GetGain
==============
*/
float BG_WeaponCharge_GetGain(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6510, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeGain;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6515, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeGain;
}

/*
==============
BG_WeaponCharge_GetHudReveal
==============
*/
_BOOL8 BG_WeaponCharge_GetHudReveal(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6670, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeHudReveal;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6675, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeHudReveal;
}

/*
==============
BG_WeaponCharge_GetLossWhenIdle
==============
*/
float BG_WeaponCharge_GetLossWhenIdle(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6526, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeLossWhenIdle;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6531, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeLossWhenIdle;
}

/*
==============
BG_WeaponCharge_GetMeterBoneCount
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneCount(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 
  __int64 result; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6728, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6733, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    result = (unsigned int)v6->charged->chargeMeterEffectBoneCount;
  }
  else
  {
    result = (unsigned int)v4->chargeMeterEffectBoneCount;
  }
  if ( (int)result > 16 )
    return 16i64;
  return result;
}

/*
==============
BG_WeaponCharge_GetMeterBoneMaxCount
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneMaxCount()
{
  return 16i64;
}

/*
==============
BG_WeaponCharge_GetMeterBoneName
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneName(unsigned int chargeIndex)
{
  __int64 result; 

  switch ( chargeIndex )
  {
    case 0u:
      goto $LN7_85;
    case 1u:
      result = (unsigned int)scr_const.tag_charge_fx02;
      break;
    case 2u:
      result = (unsigned int)scr_const.tag_charge_fx03;
      break;
    case 3u:
      result = (unsigned int)scr_const.tag_charge_fx04;
      break;
    case 4u:
      result = (unsigned int)scr_const.tag_charge_fx05;
      break;
    case 5u:
      result = (unsigned int)scr_const.tag_charge_fx06;
      break;
    case 6u:
      result = (unsigned int)scr_const.tag_charge_fx07;
      break;
    case 7u:
      result = (unsigned int)scr_const.tag_charge_fx08;
      break;
    case 8u:
      result = (unsigned int)scr_const.tag_charge_fx09;
      break;
    case 9u:
      result = (unsigned int)scr_const.tag_charge_fx10;
      break;
    case 0xAu:
      result = (unsigned int)scr_const.tag_charge_fx11;
      break;
    case 0xBu:
      result = (unsigned int)scr_const.tag_charge_fx12;
      break;
    case 0xCu:
      result = (unsigned int)scr_const.tag_charge_fx13;
      break;
    case 0xDu:
      result = (unsigned int)scr_const.tag_charge_fx14;
      break;
    case 0xEu:
      result = (unsigned int)scr_const.tag_charge_fx15;
      break;
    case 0xFu:
      result = (unsigned int)scr_const.tag_charge_fx16;
      break;
    default:
      if ( chargeIndex < 0x10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6770, ASSERT_TYPE_ASSERT, "(chargeIndex >= ( 16 ))", (const char *)&queryFormat, "chargeIndex >= PLAYER_WEAPONCHARGE_BONE_TAG_COUNT") )
        __debugbreak();
      Com_PrintWarning(17, "CHARGE_BONE_TAG_NAMES needs to be added to (%d)\n", chargeIndex);
$LN7_85:
      result = (unsigned int)scr_const.tag_charge_fx01;
      break;
  }
  return result;
}

/*
==============
BG_WeaponCharge_GetMeterEffect
==============
*/
FxCombinedDef BG_WeaponCharge_GetMeterEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6711, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return (FxCombinedDef)v4->chargeMeterEffect.particleSystemDef;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6716, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return (FxCombinedDef)v6->charged->chargeMeterEffect.particleSystemDef;
}

/*
==============
BG_WeaponCharge_GetRumble
==============
*/
RumbleInfo *BG_WeaponCharge_GetRumble(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 
  RumbleInfo *result; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6686, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
  {
    result = v4->chargeRumble;
    if ( result )
      return result;
    return 0i64;
  }
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6691, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  result = v6->charged->chargeRumble;
  if ( !result )
    return 0i64;
  return result;
}

/*
==============
BG_WeaponCharge_GetType
==============
*/
__int64 BG_WeaponCharge_GetType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6487, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return (unsigned int)v4->chargeType;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6492, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeType;
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelEntityState
==============
*/
_BOOL8 BG_WeaponDoesNotFullyAnimateViewmodelEntityState(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v6; 

  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 941, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 949, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2547, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( (es->lerp.u.player.playerFlags & 0x80) != 0 )
    return BG_WeapHasGestureDetonation(r_weapon, 0);
  else
    return v6->noFullViewmodelAnimations;
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelPlayerState
==============
*/
_BOOL8 BG_WeaponDoesNotFullyAnimateViewmodelPlayerState(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v6; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 916, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 924, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2539, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, ACTIVE, 0x1Eu) )
    return BG_WeapHasGestureDetonation(r_weapon, 0);
  else
    return v6->noFullViewmodelAnimations;
}

/*
==============
BG_WeaponFireRecoil
==============
*/
void BG_WeaponFireRecoil(const BgWeaponMap *weaponMap, const playerState_s *ps, PlayerHandIndex hand, const float pitchMove, const float yawMove, const vec2_t *gunKickAngles, const vec2_t *viewKickAngles, vec2_t *outGunKickAVel, bool *outGunNeedsToCrossCenter, vec3_t *outViewKickAVel, bool *outViewNeedsToCrossCenter)
{
  __int64 v13; 
  float v14; 
  const Weapon *ViewmodelWeapon; 
  bool v16; 
  float v17; 
  float fWeaponPosFrac; 
  bool v19; 
  float v20; 
  float v21; 
  const dvar_t *v22; 
  double v23; 
  bool v24; 
  double v25; 
  unsigned int v26; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v28; 
  WeaponAttachment **v29; 
  AttKickScaling *kickScaling; 
  float v31; 
  const dvar_t *v32; 
  double v33; 
  bool v34; 
  double v35; 
  float v36; 
  unsigned int v37; 
  BgWeaponMap *v38; 
  unsigned int v39; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v41; 
  const WeaponAttachment **v42; 
  AttViewKick *AttachmentViewKick; 
  bool v44; 
  float v45; 
  float v46; 
  float v47; 
  double v48; 
  float v49; 
  double v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float *v58; 
  float v59; 
  float v60; 
  float v61; 
  double v62; 
  float v63; 
  double v64; 
  float v65; 
  float v66; 
  const dvar_t *v67; 
  const dvar_t *v68; 
  float v69; 
  bool v70; 
  BgWeaponMap *v71; 
  float v72; 
  float v73; 
  vec2_t *v74; 
  float v75; 
  float v76; 
  bool v77; 
  float v78; 
  float v79; 
  bool useAngularViewKick; 
  float outPitchAVel; 
  float kickYaw; 
  unsigned int pHoldrand; 
  float outPitchInputScalar; 
  float outYawInputScalar; 
  BgWeaponMap *weaponMapa; 
  float adsViewKickYawMin; 
  float adsViewKickYawMax; 
  float adsViewKickPitchMin; 
  float adsViewKickPitchMax; 
  float hipViewKickMagMin; 
  float hipViewKickYawMin; 
  float hipViewKickYawMax; 
  float hipViewKickPitchMin; 
  float hipViewKickPitchMax; 
  float adsGunKickPitchMax; 
  float adsGunKickPitchMin; 
  float adsGunKickYawMin; 
  float adsGunKickYawMax; 
  float adsGunKickMagMin; 
  float hipGunKickPitchMax; 
  float hipGunKickPitchMin; 
  float hipGunKickYawMin; 
  float hipGunKickYawMax[2]; 
  float hipGunKickMagMin[2]; 
  float adsViewKickMagMin; 
  bool *v107; 
  vec2_t *v108; 
  bool *v109; 
  WeaponAttachment *attachments[30]; 
  WeaponAttachment *v111[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v113[32]; 

  v107 = outGunNeedsToCrossCenter;
  weaponMapa = (BgWeaponMap *)weaponMap;
  v109 = outViewNeedsToCrossCenter;
  *(_QWORD *)hipGunKickYawMax = outViewKickAVel;
  v108 = outGunKickAVel;
  v13 = hand;
  v14 = 0.0;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3805, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3806, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  pHoldrand = 16811 * ps->serverTime + 17891 * ps->weapCommon.adsStartTime;
  BG_srand(&pHoldrand);
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  v16 = BG_UsingAlternate(ps);
  v17 = FLOAT_1_0;
  fWeaponPosFrac = ps->weapCommon.fWeaponPosFrac;
  v19 = v16;
  v20 = FLOAT_1_0;
  v21 = FLOAT_1_0;
  *(_QWORD *)hipGunKickMagMin = 80 * v13;
  if ( ps->weapState[v13].weaponStartingKickTime > 0 )
  {
    v22 = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
    if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    if ( fWeaponPosFrac < v22->current.value )
    {
      v23 = BG_StartingGunKickPercent(ViewmodelWeapon, v19, 0);
      v24 = 0;
    }
    else
    {
      v23 = BG_StartingGunKickPercent(ViewmodelWeapon, v19, 1);
      v24 = 1;
    }
    v20 = *(float *)&v23;
    v25 = BG_StartingViewKickPercent(ViewmodelWeapon, v19, v24);
    v21 = *(float *)&v25;
  }
  v26 = 0;
  outPitchInputScalar = *(float *)&BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx)->adsEndingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v19, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v28 = 0;
  if ( WeaponAttachments_Internal )
  {
    v29 = attachments;
    while ( 1 )
    {
      if ( !*v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14266, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      kickScaling = (*v29)->kickScaling;
      if ( kickScaling )
        break;
      ++v28;
      ++v29;
      if ( v28 >= WeaponAttachments_Internal )
        goto LABEL_22;
    }
    v31 = *(float *)&kickScaling->adsEndingKickBullets;
  }
  else
  {
LABEL_22:
    v31 = outPitchInputScalar;
  }
  if ( SLODWORD(v31) > 0 && *(int *)((char *)&ps->weapState[0].weaponEndingKickTime + *(_QWORD *)hipGunKickMagMin) <= 0 )
  {
    v32 = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
    if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    if ( fWeaponPosFrac < v32->current.value )
    {
      v33 = BG_EndingGunKickPercent(ViewmodelWeapon, v19, 0);
      v34 = 0;
    }
    else
    {
      v33 = BG_EndingGunKickPercent(ViewmodelWeapon, v19, 1);
      v34 = 1;
    }
    v20 = *(float *)&v33;
    v35 = BG_EndingViewKickPercent(ViewmodelWeapon, v19, v34);
    v21 = *(float *)&v35;
  }
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xDu) )
  {
    v36 = (float)ps->recoilScale * 0.0099999998;
    v20 = v20 * v36;
    v21 = v21 * v36;
  }
  useAngularViewKick = BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx)->useAngularViewKick;
  v37 = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v19, (const WeaponAttachment **)v111, v113, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v38 = weaponMapa;
  v39 = v37;
  v41 = weaponMapa && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMapa, ps, ViewmodelWeapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( v39 )
  {
    v42 = (const WeaponAttachment **)v111;
    while ( 1 )
    {
      if ( !*v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14516, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMapa, ps, ViewmodelWeapon, v19, *v42, v41);
      if ( AttachmentViewKick )
        break;
      ++v26;
      ++v42;
      if ( v26 >= v39 )
      {
        v38 = weaponMapa;
        goto LABEL_47;
      }
    }
    v44 = AttachmentViewKick->useAngularViewKick;
    v38 = weaponMapa;
  }
  else
  {
LABEL_47:
    v44 = useAngularViewKick;
  }
  if ( v44 )
  {
    BG_CalculateKickPolar(v38, 1, ps, ViewmodelWeapon, v19, &pHoldrand, &outPitchAVel, &kickYaw);
    v45 = kickYaw;
    v46 = outPitchAVel;
  }
  else
  {
    BG_GetViewKickYawAndPitch(v38, ps, ViewmodelWeapon, v19, &hipViewKickPitchMin, &hipViewKickPitchMax, &hipViewKickYawMin, &hipViewKickYawMax, &hipViewKickMagMin, &adsViewKickPitchMin, &adsViewKickPitchMax, &adsViewKickYawMin, &adsViewKickYawMax, &adsViewKickMagMin);
    v47 = ps->weapCommon.fWeaponPosFrac;
    v48 = BG_random(&pHoldrand);
    v49 = *(float *)&v48;
    v50 = BG_random(&pHoldrand);
    v51 = 1.0 - *(float *)&v50;
    v52 = 1.0 - v49;
    if ( v47 <= 0.0 )
    {
      v14 = hipViewKickMagMin;
      v45 = (float)(v51 * hipViewKickYawMin) + (float)(*(float *)&v50 * hipViewKickYawMax);
      v53 = (float)(v52 * hipViewKickPitchMin) + (float)(v49 * hipViewKickPitchMax);
    }
    else
    {
      v14 = adsViewKickMagMin;
      v45 = (float)(v51 * adsViewKickYawMin) + (float)(*(float *)&v50 * adsViewKickYawMax);
      v53 = (float)(v52 * adsViewKickPitchMin) + (float)(v49 * adsViewKickPitchMax);
    }
    LODWORD(v46) = LODWORD(v53) ^ _xmm;
  }
  BG_CalculateRecoilInputScalars(v38, ps, ViewmodelWeapon, v19, v46, v45, pitchMove, yawMove, &outPitchInputScalar, &outYawInputScalar);
  v54 = (float)(v21 * outPitchInputScalar) * v46;
  v55 = v45 * (float)(v21 * outYawInputScalar);
  kickYaw = v55;
  outPitchAVel = v54;
  v57 = v14 * v21;
  v56 = v14 * v21;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xCu) )
  {
    v54 = v54 * 5.0;
    outPitchAVel = v54;
  }
  if ( !BG_UseAngularGunKick(v38, ps, ViewmodelWeapon, v19) )
  {
    BG_ScaleKickValue(&outPitchAVel, &kickYaw, v57);
    v55 = kickYaw;
    v54 = outPitchAVel;
  }
  v58 = *(float **)hipGunKickYawMax;
  **(float **)hipGunKickYawMax = v54;
  v58[1] = v55;
  v58[2] = v55 * -0.5;
  if ( BG_UseAngularGunKick(v38, ps, ViewmodelWeapon, v19) )
  {
    BG_CalculateKickPolar(v38, 0, ps, ViewmodelWeapon, v19, &pHoldrand, &outPitchAVel, &kickYaw);
    v59 = kickYaw;
    v60 = outPitchAVel;
  }
  else
  {
    BG_GetGunKickYawAndPitch(v38, ps, ViewmodelWeapon, v19, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, hipGunKickYawMax, hipGunKickMagMin, &adsGunKickPitchMin, &adsGunKickPitchMax, &adsGunKickYawMin, &adsGunKickYawMax, &adsGunKickMagMin);
    v61 = ps->weapCommon.fWeaponPosFrac;
    v62 = BG_random(&pHoldrand);
    v63 = *(float *)&v62;
    v64 = BG_random(&pHoldrand);
    v65 = 1.0 - v63;
    v66 = 1.0 - *(float *)&v64;
    if ( v61 <= 0.0 )
    {
      v56 = hipGunKickMagMin[0];
      v60 = (float)(v63 * hipGunKickPitchMax) + (float)(v65 * hipGunKickPitchMin);
      v59 = (float)(v66 * hipGunKickYawMin) + (float)(*(float *)&v64 * hipGunKickYawMax[0]);
    }
    else
    {
      v56 = adsGunKickMagMin;
      v59 = (float)(v66 * adsGunKickYawMin) + (float)(*(float *)&v64 * adsGunKickYawMax);
      v60 = (float)(v63 * adsGunKickPitchMax) + (float)(v65 * adsGunKickPitchMin);
    }
  }
  if ( BG_HasPerk(&ps->perks, 0x34u) )
  {
    v67 = DCONST_DVARFLT_perk_improved_gun_kick_scale;
    if ( !DCONST_DVARFLT_perk_improved_gun_kick_scale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_improved_gun_kick_scale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v67);
    v20 = v20 * v67->current.value;
  }
  v68 = DCONST_DVARBOOL_viewKickInputScalarsAffectGunKick;
  v69 = FLOAT_1_0;
  outPitchInputScalar = FLOAT_1_0;
  outYawInputScalar = FLOAT_1_0;
  if ( !DCONST_DVARBOOL_viewKickInputScalarsAffectGunKick && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewKickInputScalarsAffectGunKick") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v68);
  v70 = !v68->current.enabled;
  v71 = weaponMapa;
  if ( !v70 )
  {
    BG_CalculateRecoilInputScalars(weaponMapa, ps, ViewmodelWeapon, v19, v60, v59, pitchMove, yawMove, &outPitchInputScalar, &outYawInputScalar);
    v69 = outYawInputScalar;
    v17 = outPitchInputScalar;
  }
  v72 = (float)(v17 * v20) * v60;
  v73 = v59 * (float)(v69 * v20);
  kickYaw = v73;
  outPitchAVel = v72;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xCu) )
  {
    v72 = v72 * 5.0;
    outPitchAVel = v72;
  }
  if ( !BG_UseAngularGunKick(v71, ps, ViewmodelWeapon, v19) )
  {
    BG_ScaleKickValue(&outPitchAVel, &kickYaw, v56 * v20);
    v73 = kickYaw;
    v72 = outPitchAVel;
  }
  v74 = v108;
  v108->v[0] = v72;
  v74->v[1] = v73;
  v75 = viewKickAngles->v[0];
  v76 = viewKickAngles->v[1];
  v77 = ((float)(v75 * v75) > 0.0000010000001 || (float)(v76 * v76) > 0.0000010000001) && (float)((float)(v76 * v58[1]) + (float)(v75 * *v58)) < 0.0;
  *v109 = v77;
  v78 = gunKickAngles->v[0];
  v79 = gunKickAngles->v[1];
  *v107 = ((float)(v78 * v78) > 0.0000010000001 || (float)(v79 * v79) > 0.0000010000001) && (float)((float)(v78 * v74->v[0]) + (float)(v79 * v74->v[1])) < 0.0;
}

/*
==============
BG_WeaponFuseTime
==============
*/
__int64 BG_WeaponFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->fuseTime;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19116, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->fuseTime;
  }
  return (unsigned int)projectile->fuseTime;
}

/*
==============
BG_WeaponGetAltModePlayerAnimType
==============
*/
const WeaponAttachment *BG_WeaponGetAltModePlayerAnimType(const Weapon *r_weapon)
{
  const WeaponAttachment *result; 

  result = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( result )
    return (const WeaponAttachment *)(unsigned int)result->altModePlayerAnimType;
  return result;
}

/*
==============
BG_WeaponGetAnimParts
==============
*/
XAnimParts *BG_WeaponGetAnimParts(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler)
{
  __int64 v5; 
  XAnimParts *result; 
  const PlayerWeaponAnimArrays *v10; 
  bool v11; 
  __int64 v12; 

  v5 = eWeaponAnim;
  if ( eWeaponAnim == WEAP_ANIM_ROOT )
    return 0i64;
  v10 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18240, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v11 = BG_PlayerDualWielding(ps) != 0;
  if ( !bIsAlternate )
  {
    if ( !v11 )
      goto LABEL_12;
LABEL_10:
    if ( hand != WEAPON_HAND_LEFT )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( v11 )
    goto LABEL_10;
LABEL_11:
  v10 = (const PlayerWeaponAnimArrays *)((char *)v10 + 4976);
LABEL_12:
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18254, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( (unsigned int)v5 >= 0x260 )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18255, ASSERT_TYPE_ASSERT, "(unsigned)( eWeaponAnim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "eWeaponAnim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v12, 608) )
      __debugbreak();
  }
  result = v10->normalAnimArray[v5];
  if ( !result )
    return v10->normalAnimArray[236];
  return result;
}

/*
==============
BG_WeaponGetNotetrackMilliseconds
==============
*/
__int64 BG_WeaponGetNotetrackMilliseconds(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler, const scr_string_t notetrackName, int *outDuration)
{
  __int64 v7; 
  const PlayerWeaponAnimArrays *v11; 
  bool v12; 
  const XAnimParts *v13; 
  double NotetrackTimeFromParts; 
  float v15; 
  __int64 v17; 

  v7 = eWeaponAnim;
  if ( eWeaponAnim == WEAP_ANIM_ROOT )
    return 0xFFFFFFFFi64;
  v11 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18240, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v12 = BG_PlayerDualWielding(ps) != 0;
  if ( bIsAlternate )
  {
    if ( !v12 )
    {
LABEL_10:
      v11 = (const PlayerWeaponAnimArrays *)((char *)v11 + 4976);
      goto LABEL_11;
    }
  }
  else if ( !v12 )
  {
    goto LABEL_11;
  }
  if ( hand == WEAPON_HAND_LEFT )
    goto LABEL_10;
LABEL_11:
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18254, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( (unsigned int)v7 >= 0x260 )
  {
    LODWORD(v17) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18255, ASSERT_TYPE_ASSERT, "(unsigned)( eWeaponAnim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "eWeaponAnim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v17, 608) )
      __debugbreak();
  }
  v13 = v11->normalAnimArray[v7];
  if ( !v13 )
  {
    v13 = v11->normalAnimArray[236];
    if ( !v13 )
      return 0xFFFFFFFFi64;
  }
  if ( !notetrackName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18276, ASSERT_TYPE_ASSERT, "(notetrackName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "notetrackName != NULL_SCR_STRING") )
    __debugbreak();
  NotetrackTimeFromParts = XAnimGetNotetrackTimeFromParts(v13, notetrackName);
  if ( *(float *)&NotetrackTimeFromParts <= 0.0 )
    return 0xFFFFFFFFi64;
  v15 = (float)((float)v13->numframes * 1000.0) / v13->framerate;
  if ( outDuration )
    *outDuration = (int)v15;
  return (unsigned int)(int)(float)(v15 * *(float *)&NotetrackTimeFromParts);
}

/*
==============
BG_WeaponGetPlayerAnimType
==============
*/
__int64 BG_WeaponGetPlayerAnimType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 

  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE && isAlternate )
    return 8i64;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20880, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v5->playerAnimType;
}

/*
==============
BG_WeaponHasOverride
==============
*/
char BG_WeaponHasOverride(const Weapon *r_weapon, const OverrideBinding *const bindings, const unsigned int bindingCount)
{
  unsigned int v6; 
  int *p_attachmentVarIndex; 
  int *v8; 
  unsigned int v9; 
  AttachmentSlot *v10; 
  __int64 v11; 
  unsigned int v12; 
  unsigned int v13; 
  int *v14; 
  int v15; 
  int v17; 
  int v18; 
  unsigned __int8 v20; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  AttachmentSlot slot; 

  if ( bindingCount && !bindings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2016, ASSERT_TYPE_ASSERT, "(bindingCount == 0 || bindings)", (const char *)&queryFormat, "bindingCount == 0 || bindings") )
    __debugbreak();
  v6 = 0;
  if ( bindingCount )
  {
    p_attachmentVarIndex = &bindings->attachmentVarIndex;
LABEL_7:
    v8 = p_attachmentVarIndex - 4;
    if ( p_attachmentVarIndex == (int *)16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1954, ASSERT_TYPE_ASSERT, "(binding)", (const char *)&queryFormat, "binding") )
      __debugbreak();
    v9 = 0;
    if ( !*v8 )
      return 0;
    while ( 1 )
    {
      v10 = (AttachmentSlot *)(*((_QWORD *)p_attachmentVarIndex - 1) + 68i64 * v9);
      v11 = *(int *)v10;
      if ( (int)v11 >= 13 )
      {
        if ( (_DWORD)v11 == 13 )
        {
          _EDI = v10[1] & r_weapon->weaponOthers;
          if ( _EDI )
          {
            v17 = *p_attachmentVarIndex;
            while ( 1 )
            {
              v18 = _EDI;
              if ( v17 < 0 )
                break;
              __asm { tzcnt   ebx, edi }
              if ( _EBX >= 0x10 )
              {
                LODWORD(v24) = 16;
                LODWORD(v22) = _EBX;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1992, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v22, v24) )
                  __debugbreak();
                LODWORD(v25) = 16;
                LODWORD(v23) = _EBX;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v23, v25) )
                  __debugbreak();
              }
              v20 = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
              v17 = *p_attachmentVarIndex;
              if ( r_weapon->attachmentVariationIndices[v20] == *p_attachmentVarIndex )
                break;
              _EDI ^= 1 << _EBX;
              if ( 1 << _EBX == v18 )
                goto LABEL_43;
            }
LABEL_28:
            ++v6;
            p_attachmentVarIndex += 6;
            if ( v6 >= bindingCount )
              return 1;
            goto LABEL_7;
          }
        }
        else
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F57750, 5964i64);
        }
      }
      else
      {
        slot = *v10;
        if ( (_DWORD)v11 == 12 )
          v12 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
        else
          v12 = r_weapon->weaponAttachments[v11];
        if ( v12 )
        {
          v13 = v12 - 1;
          if ( v12 - 1 >= Com_GetWeaponAttachmentSlotSize(&slot) )
          {
            LODWORD(v24) = Com_GetWeaponAttachmentSlotSize(&slot);
            LODWORD(v22) = v12 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1969, ASSERT_TYPE_ASSERT, "(unsigned)( bindingAttachmentIndex ) < (unsigned)( Com_GetWeaponAttachmentSlotSize( slot ) )", "bindingAttachmentIndex doesn't index Com_GetWeaponAttachmentSlotSize( slot )\n\t%i not in [0, %i)", v22, v24) )
              __debugbreak();
          }
          v14 = (int *)(v10 + 1);
          if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 12, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
            __debugbreak();
          if ( v13 >= 0x200 )
          {
            LODWORD(v24) = 512;
            LODWORD(v22) = v12 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v22, v24) )
              __debugbreak();
          }
          v15 = v14[(v12 - 1i64) >> 5];
          if ( _bittest(&v15, v13 & 0x1F) )
          {
            if ( *p_attachmentVarIndex < 0 || r_weapon->attachmentVariationIndices[slot] == *p_attachmentVarIndex )
              goto LABEL_28;
          }
        }
      }
LABEL_43:
      if ( ++v9 >= *v8 )
        return 0;
    }
  }
  return 1;
}

/*
==============
BG_WeaponHasStreamedModels
==============
*/
char BG_WeaponHasStreamedModels(const Weapon *weapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v3; 
  unsigned int v4; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v6; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  unsigned __int8 v9; 
  unsigned __int8 v10; 
  int numModelVariations; 
  int v12; 
  __int64 v14; 
  __int64 v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  weaponIdx = weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v3 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22562, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v3->hasAnyTransientModels )
    return 0;
  if ( !*(_WORD *)&v3->transientBaseViewFlags )
  {
    v4 = 0;
    AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(weapon, (const WeaponAttachment **)attachments, attachmentIds);
    if ( AllWeaponAttachmentsWithIds )
    {
      v6 = attachmentIds;
      for ( i = attachments; ; ++i )
      {
        v8 = *i;
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22581, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        v9 = *v6;
        if ( *v6 >= 0x1Du )
        {
          LODWORD(v15) = 29;
          LODWORD(v14) = v9;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22584, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        v10 = weapon->attachmentVariationIndices[v9];
        if ( v10 >= 0x10u )
        {
          LODWORD(v15) = 16;
          LODWORD(v14) = v10;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22587, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        numModelVariations = v8->numModelVariations;
        if ( v10 < numModelVariations )
        {
          if ( v10 >= (unsigned int)numModelVariations )
          {
            LODWORD(v15) = v8->numModelVariations;
            LODWORD(v14) = v10;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22594, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( attachment->numModelVariations )", "variationIndex doesn't index attachment->numModelVariations\n\t%i not in [0, %i)", v14, v15) )
              __debugbreak();
          }
          v12 = v8->transientViewFlags | v8->transientWorldFlags;
          if ( _bittest(&v12, v10) )
            break;
        }
        ++v4;
        ++v6;
        if ( v4 >= AllWeaponAttachmentsWithIds )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

/*
==============
BG_WeaponHasStreamedModelsErrorCheck
==============
*/
bool BG_WeaponHasStreamedModelsErrorCheck(const Weapon *weapon)
{
  return !g_usedDebugZone && BG_WeaponHasStreamedModels(weapon);
}

/*
==============
BG_WeaponIsDualWield
==============
*/
char BG_WeaponIsDualWield(const Weapon *r_weapon)
{
  int v1; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v1 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17725, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    if ( (*i)->isAkimboAttachment )
      break;
    if ( ++v1 >= AllWeaponAttachmentsWithIds )
      return 0;
  }
  return 1;
}

/*
==============
BG_WeaponRadiusDamageDetailTrace
==============
*/
bool BG_WeaponRadiusDamageDetailTrace(const Weapon *r_weapon, bool isAlternate)
{
  return (unsigned int)(BG_GetWeaponType(r_weapon, isAlternate) - 2) <= 2;
}

/*
==============
BG_WeaponReloadingFraction
==============
*/
double BG_WeaponReloadingFraction(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  double v6; 
  float v7; 
  float v8; 
  float v9; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v5, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, 1.0, 6u);
  v7 = *(float *)&v6;
  v8 = (float)(ps->commandTimeInterpolated - ps->weapCommon.lastReloadStateChangeTime);
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
    v9 = (float)(v8 * outAdsTransOutSpeedMs) + v7;
  else
    v9 = v7 - (float)(v8 * outAdsTransInSpeedMs);
  return I_fclamp(v9, 0.0, 1.0);
}

/*
==============
BG_WeaponResetADSReloadFraction
==============
*/
void BG_WeaponResetADSReloadFraction(playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ps->weapCommon.lastReloadFraction = MSG_PackUnsignedFloat(0.0, 1.0, 6u);
  *(_QWORD *)&ps->weapCommon.lastReloadStateChangeTime = 0i64;
}

/*
==============
BG_WeaponStickinessType
==============
*/
__int64 BG_WeaponStickinessType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->stickiness;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18974, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->stickiness;
  }
  return (unsigned int)projectile->stickiness;
}

/*
==============
BG_WeaponSticksToFloors
==============
*/
bool BG_WeaponSticksToFloors(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponStickinessType(r_weapon, isAlternate) != WEAPSTICKINESS_NONE;
}

/*
==============
BG_WeaponSticksToNonStick
==============
*/
_BOOL8 BG_WeaponSticksToNonStick(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToNonStick;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19074, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToNonStick;
  }
  return projectile->stickToNonStick;
}

/*
==============
BG_WeaponSticksToPlayers
==============
*/
_BOOL8 BG_WeaponSticksToPlayers(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToPlayers;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19011, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToPlayers;
  }
  return projectile->stickToPlayers;
}

/*
==============
BG_WeaponSticksToTurrets
==============
*/
_BOOL8 BG_WeaponSticksToTurrets(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToTurrets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19053, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToTurrets;
  }
  return projectile->stickToTurrets;
}

/*
==============
BG_WeaponSticksToVehicles
==============
*/
_BOOL8 BG_WeaponSticksToVehicles(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToVehicles;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19032, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToVehicles;
  }
  return projectile->stickToVehicles;
}

/*
==============
BG_WeaponSticksToWalls
==============
*/
bool BG_WeaponSticksToWalls(const Weapon *r_weapon, bool isAlternate)
{
  WeapStickinessType v2; 

  v2 = BG_WeaponStickinessType(r_weapon, isAlternate);
  return ((v2 - 1) & 0xFFFFFFFA) == 0 && v2 != WEAPSTICKINESS_GROUND_ORIENT;
}

/*
==============
BG_Weapon_CheckFriendlyFire
==============
*/
bool BG_Weapon_CheckFriendlyFire(const playerState_s *ps)
{
  return !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 3u);
}

/*
==============
BG_Weapon_FiresOnWeaponSwitch
==============
*/
_BOOL8 BG_Weapon_FiresOnWeaponSwitch(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1021, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->firesOnWeaponSwitch;
}

/*
==============
BG_Weapon_GetCameraFireEffect
==============
*/
FxCombinedDef BG_Weapon_GetCameraFireEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return (FxCombinedDef)v2->cameraFireEffect.particleSystemDef;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 988, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (FxCombinedDef)MEMORY[0x1108];
}

/*
==============
BG_Weapon_GetCameraFireEffectDurationSec
==============
*/
float BG_Weapon_GetCameraFireEffectDurationSec(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->cameraFireEffectDurationSec;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 997, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0x1110];
}

/*
==============
BG_Weapon_GetPrimaryAttachmentIndex
==============
*/
unsigned __int16 BG_Weapon_GetPrimaryAttachmentIndex(const Weapon *weapon, const AttachmentSlot *slot)
{
  __int64 v4; 

  if ( *(int *)slot >= 13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  v4 = *(int *)slot;
  if ( (_DWORD)v4 == 12 )
    return weapon->weaponAttachments[12] | (weapon->visualAttachmentHighAddr << 8);
  else
    return weapon->weaponAttachments[v4];
}

/*
==============
BG_Weapon_OffhandDisabled
==============
*/
__int64 BG_Weapon_OffhandDisabled(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1052, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 1i64;
  if ( !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x1Eu) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) || ps->skydivePlayerState.state[0] == 5) )
    return 2i64;
  return 0i64;
}

/*
==============
BG_Weapon_OffhandDisablesHold
==============
*/
_BOOL8 BG_Weapon_OffhandDisablesHold(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1045, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->disableHolding;
}

/*
==============
BG_Weapon_SetPrimaryAttachmentIndex
==============
*/
void BG_Weapon_SetPrimaryAttachmentIndex(const AttachmentSlot *slot, const unsigned __int16 attachmentIndex, Weapon *outWeapon)
{
  AttachmentSlot v6; 

  if ( *(int *)slot >= 13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23176, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  v6 = *slot;
  if ( *slot == ATT_SLOT_VISUAL )
  {
    outWeapon->weaponAttachments[12] = truncate_cast<unsigned char,int>((unsigned __int8)attachmentIndex);
    outWeapon->visualAttachmentHighAddr = truncate_cast<unsigned char,int>(HIBYTE(attachmentIndex));
  }
  else
  {
    if ( attachmentIndex > 0xFFu )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned short>(unsigned short)", "unsigned", (unsigned __int8)attachmentIndex, "unsigned", attachmentIndex) )
        __debugbreak();
      v6 = *slot;
    }
    outWeapon->weaponAttachments[v6] = attachmentIndex;
  }
}

/*
==============
BG_Weapon_UsingAutoFireOnSwitchWeapon
==============
*/
bool BG_Weapon_UsingAutoFireOnSwitchWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 
  const WeaponDef *v6; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1028, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1029, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  BG_UsingAlternate(ps);
  if ( ViewmodelWeapon->weaponIdx )
  {
    v6 = BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx);
    if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1021, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v6->firesOnWeaponSwitch;
  }
  else
  {
    return 0;
  }
}

/*
==============
BG_WeaponsDifferOnlyInVariantForInstantSwitch
==============
*/
_BOOL8 BG_WeaponsDifferOnlyInVariantForInstantSwitch(const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeapFlags, const Weapon *r_weaponA, const Weapon *r_weaponB)
{
  bool v7; 
  __m256i v8; 
  __int128 v9; 
  unsigned __int8 weaponCamo; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> v12; 
  __m256i Buf1; 
  __int128 v14; 
  __int64 v15; 
  int v16; 

  v12 = prevWeapFlags;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18949, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps", v12) )
    __debugbreak();
  v7 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x14u);
  if ( v7 == GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v12, ACTIVE, 0x14u) || !memcmp_0(r_weaponA, r_weaponB, 0x3Cui64) )
    return 0i64;
  v8 = *(__m256i *)&r_weaponA->weaponIdx;
  v9 = *(_OWORD *)&r_weaponA->attachmentVariationIndices[5];
  v16 = *(_DWORD *)&r_weaponA->weaponCamo;
  weaponCamo = r_weaponB->weaponCamo;
  Buf1 = v8;
  v15 = *(_QWORD *)&r_weaponA->attachmentVariationIndices[21];
  v14 = v9;
  LOBYTE(v16) = weaponCamo;
  return memcmp_0(&Buf1, r_weaponB, 0x3Cui64) == 0;
}

/*
==============
BG_WeaponsUtil_AdvanceWeapon
==============
*/
bool BG_WeaponsUtil_AdvanceWeapon(Weapon *inOutWeapon)
{
  return BG_WeaponsUtil_IterateWeaponInternal<bool (*)(void *,WeaponAttachment const * const *,unsigned int,unsigned short &,unsigned char &),unsigned short (*)(unsigned int *,unsigned short)>(inOutWeapon, (bool (__fastcall *)(void *, const WeaponAttachment *const *, unsigned int, unsigned __int16 *, unsigned __int8 *))BG_WeaponsUtil_ChooseNextAttachment, (unsigned __int16 (__fastcall *)(unsigned int *, unsigned __int16))BG_WeaponsUtil_ChooseNextWeaponIdx, NULL);
}

/*
==============
BG_WeaponsUtil_ChooseNextAttachment
==============
*/
bool BG_WeaponsUtil_ChooseNextAttachment(void *__formal, const WeaponAttachment *const *const attachments, const unsigned int attachmentCount, unsigned __int16 *outChosenIndex, unsigned __int8 *outVariationIndex)
{
  unsigned __int16 v6; 
  unsigned __int8 v9; 
  __int64 v10; 
  __int64 v11; 
  const WeaponAttachment *const *v12; 
  bool result; 
  int v14; 

  v6 = *outChosenIndex;
  v9 = *outVariationIndex;
  if ( !attachments )
    goto LABEL_14;
  if ( !v6 )
    goto LABEL_7;
  v10 = (unsigned int)v6 - 1;
  if ( (unsigned int)v10 >= attachmentCount )
  {
    v14 = v6 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22725, ASSERT_TYPE_ASSERT, "(unsigned)( attachIndex ) < (unsigned)( attachmentCount )", "attachIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v14, attachmentCount) )
      __debugbreak();
  }
  ++*outVariationIndex;
  if ( !BG_WeaponsUtil_ChooseNextVariation(attachments[v10], outVariationIndex) )
  {
LABEL_7:
    v11 = *outChosenIndex;
    if ( (unsigned int)v11 < attachmentCount )
    {
      v12 = &attachments[v11];
      while ( 1 )
      {
        if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22736, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
          __debugbreak();
        *outVariationIndex = 0;
        LODWORD(v11) = v11 + 1;
        if ( BG_WeaponsUtil_ChooseNextVariation(*v12, outVariationIndex) )
          break;
        ++v12;
        if ( (unsigned int)v11 >= attachmentCount )
          goto LABEL_14;
      }
      *outChosenIndex = truncate_cast<unsigned short,unsigned int>(v11);
      return 1;
    }
LABEL_14:
    *outChosenIndex = v6;
    result = 0;
    *outVariationIndex = v9;
    return result;
  }
  return 1;
}

/*
==============
BG_WeaponsUtil_ChooseNextVariation
==============
*/
char BG_WeaponsUtil_ChooseNextVariation(const WeaponAttachment *const attachment, unsigned __int8 *outVariationIndex)
{
  unsigned int v4; 
  unsigned int numModelVariations; 
  int v6; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22698, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  v4 = *outVariationIndex;
  numModelVariations = attachment->numModelVariations;
  if ( v4 >= numModelVariations )
    return 0;
  while ( 1 )
  {
    v6 = attachment->transientViewFlags | attachment->transientWorldFlags;
    if ( _bittest(&v6, v4) )
      break;
    if ( ++v4 >= numModelVariations )
      return 0;
  }
  if ( v4 > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)v4, "unsigned", v4) )
    __debugbreak();
  *outVariationIndex = v4;
  return 1;
}

/*
==============
BG_WeaponsUtil_ChooseNextWeaponIdx
==============
*/
__int64 BG_WeaponsUtil_ChooseNextWeaponIdx(unsigned int *randSeed, int lastWeaponIdx)
{
  return (unsigned int)(lastWeaponIdx + 1);
}

/*
==============
BG_WeaponsUtil_ChooseRandomAttachment
==============
*/
char BG_WeaponsUtil_ChooseRandomAttachment(unsigned int *randSeed, const WeaponAttachment *const *const attachments, const unsigned int attachmentCount, unsigned __int16 *outChosenIndex, unsigned __int8 *outVariationIndex)
{
  __int64 v9; 
  const WeaponAttachment *v10; 
  unsigned int v11; 

  if ( attachments && attachmentCount )
  {
    if ( !randSeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22761, ASSERT_TYPE_ASSERT, "(randSeed)", (const char *)&queryFormat, "randSeed") )
      __debugbreak();
    v9 = (unsigned int)BG_irand(0, attachmentCount, randSeed);
    v10 = attachments[v9];
    if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22765, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v11 = BG_irand(0, v10->numModelVariations, randSeed);
    *outChosenIndex = truncate_cast<unsigned short,unsigned int>(v9 + 1);
    *outVariationIndex = truncate_cast<unsigned char,unsigned int>(v11);
    return 1;
  }
  else
  {
    *outChosenIndex = 0;
    *outVariationIndex = 0;
    return 0;
  }
}

/*
==============
BG_WeaponsUtil_ChooseRandomWeaponIdx
==============
*/
__int64 BG_WeaponsUtil_ChooseRandomWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  int NumWeapons; 
  const WeaponDef *v5; 
  weapClass_t weapClass; 
  int v7; 
  unsigned __int16 v8; 
  WeaponDef *v9; 
  __int64 v11; 
  __int64 v12; 

  NumWeapons = BG_GetNumWeapons();
  v5 = BG_WeaponDefAtIndex(lastWeaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22787, ASSERT_TYPE_ASSERT, "(lastWeapDef)", (const char *)&queryFormat, "lastWeapDef") )
    __debugbreak();
  weapClass = v5->weapClass;
  if ( !randSeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22791, ASSERT_TYPE_ASSERT, "(randSeed)", (const char *)&queryFormat, "randSeed") )
    __debugbreak();
  do
  {
    v7 = BG_irand(1, NumWeapons, randSeed);
    v8 = v7;
    if ( (v7 < 0 || (unsigned int)v7 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,int>(int)", "unsigned", (unsigned __int16)v7, "signed", v7) )
      __debugbreak();
    if ( v8 > bg_lastParsedWeaponIndex )
    {
      LODWORD(v12) = bg_lastParsedWeaponIndex;
      LODWORD(v11) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v11, v12) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v9 = bg_weaponDefs[v8];
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22798, ASSERT_TYPE_ASSERT, "(nextWeapDef)", (const char *)&queryFormat, "nextWeapDef") )
      __debugbreak();
  }
  while ( v9->weapClass != weapClass );
  return v8;
}

/*
==============
BG_WeaponsUtil_RandomizeWeapon
==============
*/
void BG_WeaponsUtil_RandomizeWeapon(Weapon *inOutWeapon, unsigned int *randSeed)
{
  BG_WeaponsUtil_IterateWeaponInternal<bool (*)(unsigned int *,WeaponAttachment const * const *,unsigned int,unsigned short &,unsigned char &),unsigned short (*)(unsigned int *,unsigned short)>(inOutWeapon, (bool (__fastcall *)(unsigned int *, const WeaponAttachment *const *, unsigned int, unsigned __int16 *, unsigned __int8 *))BG_WeaponsUtil_ChooseRandomAttachment, (unsigned __int16 (__fastcall *)(unsigned int *, unsigned __int16))BG_WeaponsUtil_ChooseRandomWeaponIdx, randSeed);
}

/*
==============
BG_Weapons_AttachHeldWeapon
==============
*/
__int64 BG_Weapons_AttachHeldWeapon(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, int *outWeaponModelIndex1, int *outWeaponModelIndex2, bool isServer, XAnimWeaponIKModelsContainer *outWeaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  XAnimWeaponIKModelsContainer *v9; 
  const characterInfo_t *v10; 
  DObjModel *v12; 
  const Weapon *p_dobjHeldWeapon; 
  PlayerHandIndex v14; 
  int *v15; 
  bool v16; 
  XModel *WeaponModels; 
  const char *WeaponName; 
  unsigned __int16 v19; 
  __int64 v20; 
  const XModel *v21; 
  DObjModel *v22; 
  const char *name; 
  const char *v24; 
  __int64 v25; 
  signed __int64 v26; 
  char v27; 
  __int64 v28; 
  char v29; 
  unsigned __int16 v30; 
  unsigned __int64 v31; 
  DObjModel *v32; 
  const WeaponCompleteDef *v33; 
  const char *szInternalName; 
  __int64 v35; 
  char *v36; 
  char v37; 
  __int64 v38; 
  char v39; 
  scr_string_t tag_accessory_right; 
  DObjCamoParams *v41; 
  unsigned __int64 v42; 
  CharacterModelType *v43; 
  __int64 isUsingDetonator; 
  DObjModel *isUsingDetonatora; 
  __int64 isUsingCensorshipWorldModel; 
  DObjCamoParams *v48; 
  bool IsRiotShield; 
  unsigned __int16 v50; 
  DObjModel *dobjModelsa; 
  XAnimWeaponIKModelsContainer *v52; 
  PlayerHandIndex v53; 
  int *v54; 
  const characterInfo_t *v55; 
  weapType_t WeaponType; 
  Weapon *v57; 
  DObjCamoParams *camoParams; 
  XModel *model; 
  CharacterModelType (*v60)[32]; 
  int *v61; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  v9 = outWeaponIKModels;
  v10 = ci;
  v54 = outWeaponModelIndex2;
  v12 = dobjModels;
  v52 = outWeaponIKModels;
  v60 = outModelTypes;
  v61 = outWeaponModelIndex1;
  v55 = ci;
  dobjModelsa = dobjModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21096, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21097, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !outWeaponModelIndex1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21098, ASSERT_TYPE_ASSERT, "(outWeaponModelIndex1)", (const char *)&queryFormat, "outWeaponModelIndex1") )
    __debugbreak();
  if ( !outWeaponModelIndex2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21099, ASSERT_TYPE_ASSERT, "(outWeaponModelIndex2)", (const char *)&queryFormat, "outWeaponModelIndex2") )
    __debugbreak();
  if ( !outWeaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21100, ASSERT_TYPE_ASSERT, "(outWeaponIKModels)", (const char *)&queryFormat, "outWeaponIKModels") )
    __debugbreak();
  p_dobjHeldWeapon = &v10->dobjHeldWeapon;
  v57 = &v10->dobjHeldWeapon;
  WeaponType = BG_GetWeaponType(&v10->dobjHeldWeapon, 0);
  IsRiotShield = BG_IsRiotShield(&v10->dobjHeldWeapon, 0);
  if ( !v10->dualWielding || v10->usingKillstreakTrigger || (v53 = WEAPON_HAND_LEFT, v10->hideLeftHandWeapon) )
    v53 = WEAPON_HAND_DEFAULT;
  v14 = WEAPON_HAND_DEFAULT;
  *outWeaponModelIndex1 = numModels;
  v15 = v54;
  *v54 = -1;
  do
  {
    v16 = isServer || !v10->dobjHeldWeaponLoaded;
    WeaponModels = BG_GetWeaponModels(v14, p_dobjHeldWeapon, 0, v16, v10->dualWielding != 0, 0, 0);
    model = WeaponModels;
    if ( WeaponModels )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(v9, v14, WeaponModels) )
      {
        WeaponName = BG_GetWeaponName(p_dobjHeldWeapon, output, 0x400u);
        LODWORD(isUsingCensorshipWorldModel) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21128, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", isUsingCensorshipWorldModel, WeaponName) )
          __debugbreak();
      }
      camoParams = BG_Camo_GetWeaponDObjCamoParams(p_dobjHeldWeapon, 0, &outLocalParams);
      if ( IsRiotShield )
      {
        v19 = 0;
        if ( !numModels )
        {
LABEL_88:
          v9 = v52;
          goto LABEL_89;
        }
        do
        {
          v20 = v19;
          v21 = v12[v20].model;
          v22 = &v12[v20];
          if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21087, ASSERT_TYPE_ASSERT, "(weapModel)", (const char *)&queryFormat, "weapModel") )
            __debugbreak();
          name = v21->name;
          if ( !v21->name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
            __debugbreak();
          v24 = "weapon_wm_riotshield";
          v25 = 20i64;
          if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
            __debugbreak();
          v26 = name - "weapon_wm_riotshield";
          while ( 1 )
          {
            v27 = v24[v26];
            v28 = v25;
            v29 = *v24++;
            --v25;
            if ( !v28 )
            {
LABEL_43:
              DObjInitModel(model, v22->boneName, v22->ignoreCollision, 0, camoParams, v22);
              v12 = dobjModelsa;
              goto LABEL_87;
            }
            if ( v27 != v29 )
              break;
            if ( !v27 )
              goto LABEL_43;
          }
          v12 = dobjModelsa;
          ++v19;
        }
        while ( v19 < numModels );
      }
      else
      {
        if ( v10->hideWeapon )
          goto LABEL_89;
        if ( numModels >= 0xFEu )
        {
          LODWORD(isUsingCensorshipWorldModel) = 254;
          LODWORD(isUsingDetonator) = numModels;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21151, ASSERT_TYPE_ASSERT, "(unsigned)( numModels ) < (unsigned)( ( DOBJ_MAX_PARTS ) )", "numModels doesn't index DOBJ_MAX_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
            __debugbreak();
        }
        if ( v14 == WEAPON_HAND_LEFT )
          *v15 = numModels;
        v30 = numModels;
        v31 = numModels;
        v32 = &dobjModelsa[numModels];
        if ( BG_GetWeaponType(p_dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(p_dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE )
        {
LABEL_66:
          tag_accessory_right = 0;
        }
        else
        {
          if ( BG_IsMeleeOnlyWeapon(p_dobjHeldWeapon, 0) )
          {
            v33 = BG_WeaponCompleteDef(p_dobjHeldWeapon, 0);
            if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
              __debugbreak();
            szInternalName = v33->szInternalName;
            v35 = 0x7FFFFFFFi64;
            if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
              __debugbreak();
            v36 = (char *)("iw7_axe_mpr_melee" - szInternalName);
            while ( 1 )
            {
              v37 = szInternalName[(_QWORD)v36];
              v38 = v35;
              v39 = *szInternalName++;
              --v35;
              if ( !v38 )
              {
LABEL_65:
                p_dobjHeldWeapon = v57;
                v10 = v55;
                goto LABEL_66;
              }
              if ( v37 != v39 )
                break;
              if ( !v37 )
                goto LABEL_65;
            }
            v10 = v55;
            p_dobjHeldWeapon = v57;
          }
          if ( WeaponType == WEAPTYPE_GRENADE || (unsigned int)(WeaponType - 6) <= 2 )
          {
            tag_accessory_right = scr_const.tag_accessory_right;
          }
          else if ( v14 )
          {
            tag_accessory_right = scr_const.tag_weapon_left;
          }
          else
          {
            tag_accessory_right = scr_const.tag_weapon_right;
            if ( v10->leftHandGun )
              tag_accessory_right = scr_const.tag_weapon_left;
          }
        }
        isUsingDetonatora = v32;
        v41 = camoParams;
        DObjInitModel(model, tag_accessory_right, isServer, 0, camoParams, isUsingDetonatora);
        v50 = ++numModels;
        if ( isServer || v16 )
        {
          v12 = dobjModelsa;
        }
        else
        {
          v48 = v41;
          v12 = dobjModelsa;
          BG_AddWeaponAttachmentModels(p_dobjHeldWeapon, v14, v10->dualWielding != 0, 0, 0, 0, dobjModelsa, 0xFEu, &v50, v52, v48);
          numModels = v50;
        }
        if ( numModels <= v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21171, ASSERT_TYPE_ASSERT, "(numModels > numModelsBeforeAdd)", (const char *)&queryFormat, "numModels > numModelsBeforeAdd") )
          __debugbreak();
        if ( v31 < numModels )
        {
          v42 = numModels - v31;
          v43 = &(*v60)[v31];
          while ( v42 )
          {
            *v43++ = (v14 == WEAPON_HAND_LEFT) + 12;
            --v42;
          }
        }
      }
LABEL_87:
      v15 = v54;
      goto LABEL_88;
    }
LABEL_89:
    v10 = v55;
    ++v14;
    p_dobjHeldWeapon = &v55->dobjHeldWeapon;
  }
  while ( v14 <= v53 );
  if ( *v61 >= numModels )
    *v61 = -1;
  return numModels;
}

/*
==============
BG_Weapons_AttachHeldWeaponIKTargets
==============
*/
__int64 BG_Weapons_AttachHeldWeaponIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModelLeft, XModel *ikTargetModelRight, bool isServer, unsigned int *inOutFirstWeaponModelIdx, unsigned int *inOutFirstWeaponBoneIdx, int *heldWeaponModelIdx1, int *heldWeaponModelIdx2, int *stowedWeaponModelIdx, const XAnimWeaponIKModelsContainer *weaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  unsigned int v15; 
  Weapon *p_dobjHeldWeapon; 
  bool dobjHeldWeaponLoaded; 
  bool v18; 
  bool isUsingCensorshipWorldModel; 
  const dvar_t *v20; 
  const ExecutionDef *Def; 
  bool v22; 
  int v23; 
  DObjModel *v24; 
  DObjModel *v25; 
  unsigned int v26; 
  unsigned __int16 v27; 
  bool IsRoboticIKEnabled; 
  XAnimIKTagRequest *v29; 
  XModel *v30; 
  CharacterModelType (*v31)[32]; 
  XAnimWeaponIKModelsContainer *v32; 
  signed int v33; 
  int numBones; 
  unsigned int *v35; 
  bool requiresAkimboIK; 
  XModel *v37; 
  signed int v38; 
  __int64 isUsingDetonator; 
  unsigned __int16 numModelsa; 
  unsigned int *v42; 
  DObjModel *dobjModelsa; 
  XAnimWeaponIKModelsContainer *weaponModels; 
  CharacterModelType (*v45)[32]; 
  XModel *tagIKTargetModel; 
  int *v47; 
  XModel *v48; 
  int *v49; 
  XAnimIKTagRequest result; 
  XAnimIKTagRequest tagRequest; 

  dobjModelsa = dobjModels;
  v45 = outModelTypes;
  v48 = ikTargetModelLeft;
  numModelsa = numModels;
  tagIKTargetModel = ikTargetModelRight;
  v42 = inOutFirstWeaponBoneIdx;
  v47 = heldWeaponModelIdx2;
  v49 = stowedWeaponModelIdx;
  weaponModels = (XAnimWeaponIKModelsContainer *)weaponIKModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21191, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21192, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !inOutFirstWeaponModelIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21193, ASSERT_TYPE_ASSERT, "(inOutFirstWeaponModelIdx)", (const char *)&queryFormat, "inOutFirstWeaponModelIdx") )
    __debugbreak();
  if ( !inOutFirstWeaponBoneIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21194, ASSERT_TYPE_ASSERT, "(inOutFirstWeaponBoneIdx)", (const char *)&queryFormat, "inOutFirstWeaponBoneIdx") )
    __debugbreak();
  if ( !heldWeaponModelIdx1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21195, ASSERT_TYPE_ASSERT, "(heldWeaponModelIdx1)", (const char *)&queryFormat, "heldWeaponModelIdx1") )
    __debugbreak();
  if ( !heldWeaponModelIdx2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21196, ASSERT_TYPE_ASSERT, "(heldWeaponModelIdx2)", (const char *)&queryFormat, "heldWeaponModelIdx2") )
    __debugbreak();
  if ( !stowedWeaponModelIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21197, ASSERT_TYPE_ASSERT, "(stowedWeaponModelIdx)", (const char *)&queryFormat, "stowedWeaponModelIdx") )
    __debugbreak();
  v15 = 0;
  if ( numModelsa > 0xFEu )
  {
    LODWORD(isUsingDetonator) = numModelsa;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21198, ASSERT_TYPE_ASSERT, "( 0 ) <= ( numModels ) && ( numModels ) <= ( ( DOBJ_MAX_PARTS ) )", "numModels not in [0, DOBJ_MAX_SUBMODELS]\n\t%i not in [%i, %i]", isUsingDetonator, 0i64, 254) )
      __debugbreak();
  }
  if ( !weaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21199, ASSERT_TYPE_ASSERT, "(weaponIKModels)", (const char *)&queryFormat, "weaponIKModels") )
    __debugbreak();
  if ( !ikTargetModelLeft && !ikTargetModelRight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21200, ASSERT_TYPE_ASSERT, "(ikTargetModelLeft || ikTargetModelRight)", (const char *)&queryFormat, "ikTargetModelLeft || ikTargetModelRight") )
    __debugbreak();
  if ( !ci->hideWeapon && !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
  {
    p_dobjHeldWeapon = &ci->dobjHeldWeapon;
    dobjHeldWeaponLoaded = ci->dobjHeldWeaponLoaded;
    v18 = ci->isUsingWeaponAltMode == 1;
    isUsingCensorshipWorldModel = 0;
    if ( BG_Execution_IsExecutionWeaponPresent(ci) )
    {
      v20 = DVARBOOL_execution_prop_ik_enabled;
      if ( !DVARBOOL_execution_prop_ik_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "execution_prop_ik_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v20);
      if ( v20->current.enabled )
      {
        Def = BG_Execution_GetDef(ci->execution);
        if ( Def )
        {
          if ( Def->propWeaponEnableIK )
          {
            if ( ci->dualWielding && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21225, ASSERT_TYPE_ASSERT, "(!ci->dualWielding)", (const char *)&queryFormat, "!ci->dualWielding") )
              __debugbreak();
            p_dobjHeldWeapon = &ci->dobjExecutionWeapon;
            dobjHeldWeaponLoaded = ci->dobjExecutionWeaponLoaded && !BG_Execution_ShouldHideExecutionWeapon(&ci->dobjExecutionWeapon);
            v18 = 0;
            isUsingCensorshipWorldModel = BG_Weapons_UseCensorshipWorldModel();
          }
        }
      }
    }
    if ( p_dobjHeldWeapon->weaponIdx && memcmp_0(p_dobjHeldWeapon, &ci->dobjStowedWeapon, 0x3Cui64) )
    {
      v22 = isServer || !dobjHeldWeaponLoaded;
      if ( BG_GetWeaponModels(WEAPON_HAND_DEFAULT, p_dobjHeldWeapon, 0, v22, ci->dualWielding != 0, 0, isUsingCensorshipWorldModel) )
      {
        v23 = 0;
        v24 = dobjModelsa;
        if ( numModelsa )
        {
          v25 = dobjModelsa;
          while ( 1 )
          {
            v26 = XModelNumBones(v25->model) + v15;
            if ( v26 > 0xFE )
              break;
            ++v23;
            ++v25;
            v15 = v26;
            if ( v23 >= numModelsa )
              goto LABEL_59;
          }
        }
        else
        {
LABEL_59:
          if ( v15 + 2 <= 0xFE )
          {
            v27 = numModelsa;
            IsRoboticIKEnabled = BG_Suit_IsRoboticIKEnabled(ci->suitIndex);
            v29 = XAnimIKSetupTagRequest(&result, p_dobjHeldWeapon, v18, IsRoboticIKEnabled, 0, ci->dualWielding == 1);
            v30 = tagIKTargetModel;
            v31 = v45;
            v32 = weaponModels;
            tagRequest = *v29;
            if ( !tagIKTargetModel || (v33 = XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_RIGHT_HAND, tagIKTargetModel, weaponModels, &tagRequest, dobjModelsa, &numModelsa, v45), v33 == -1) || v33 >= (int)*inOutFirstWeaponModelIdx )
            {
              v35 = v42;
            }
            else
            {
              ++*inOutFirstWeaponModelIdx;
              numBones = v30->numBones;
              v35 = v42;
              *v42 += numBones;
            }
            if ( *v47 >= 0 && v27 != numModelsa )
              *v47 += numModelsa - v27;
            requiresAkimboIK = tagRequest.requiresAkimboIK;
            if ( ci->dualWielding )
              requiresAkimboIK = 1;
            v37 = v48;
            tagRequest.requiresAkimboIK = requiresAkimboIK;
            if ( v48 )
            {
              v38 = XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_LEFT_HAND, v48, v32, &tagRequest, v24, &numModelsa, v31);
              if ( v38 != -1 && v38 < (int)*inOutFirstWeaponModelIdx )
              {
                ++*inOutFirstWeaponModelIdx;
                *v35 += v37->numBones;
              }
            }
            if ( *v49 >= 0 && v27 != numModelsa )
              *v49 += numModelsa - v27;
          }
        }
      }
    }
  }
  return numModelsa;
}

/*
==============
BG_Weapons_AttachWorldIKTargets
==============
*/
__int64 BG_Weapons_AttachWorldIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModel, bool isServer, CharacterModelType (*outModelTypes)[32])
{
  int v9; 
  int v10; 
  DObjModel *v11; 
  const XModel *model; 
  CharacterModelType (*v14)[32]; 
  int attachedModelIdx; 
  unsigned __int16 numModelsa; 

  numModelsa = numModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21319, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21320, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v9 = 0;
  if ( numModelsa > 0xFEu )
  {
    LODWORD(v14) = numModelsa;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21321, ASSERT_TYPE_ASSERT, "( 0 ) <= ( numModels ) && ( numModels ) <= ( ( DOBJ_MAX_PARTS ) )", "numModels not in [0, DOBJ_MAX_SUBMODELS]\n\t%i not in [%i, %i]", v14, 0i64, 254) )
      __debugbreak();
  }
  v10 = 0;
  if ( numModelsa )
  {
    v11 = dobjModels;
    do
    {
      model = v11->model;
      if ( !v11->model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      ++v10;
      v9 += model->numBones;
      ++v11;
    }
    while ( v10 < numModelsa );
  }
  if ( (unsigned int)(v9 + 2) <= 0xFE )
    XAnimIKAttachTargetToTag(ikTargetModel, scr_const.tag_origin, dobjModels, &numModelsa, &attachedModelIdx, outModelTypes);
  else
    Com_PrintWarning(16, "Failed to attach world ik targets to player dobj - too many bones.\n");
  return numModelsa;
}

/*
==============
BG_Weapons_GetAttachBone
==============
*/
__int64 BG_Weapons_GetAttachBone(const characterInfo_t *ci, weapType_t weapType, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand)
{
  const WeaponCompleteDef *v9; 
  const char *szInternalName; 
  __int64 v11; 
  char *v12; 
  char v13; 
  __int64 v14; 
  char v15; 
  __int64 result; 

  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE )
    return 0i64;
  if ( BG_IsMeleeOnlyWeapon(r_weapon, isAlternate) )
  {
    v9 = BG_WeaponCompleteDef(r_weapon, isAlternate);
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
      __debugbreak();
    szInternalName = v9->szInternalName;
    v11 = 0x7FFFFFFFi64;
    if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v12 = (char *)("iw7_axe_mpr_melee" - szInternalName);
    do
    {
      v13 = szInternalName[(_QWORD)v12];
      v14 = v11;
      v15 = *szInternalName++;
      --v11;
      if ( !v14 )
        break;
      if ( v13 != v15 )
        goto LABEL_15;
    }
    while ( v13 );
    return 0i64;
  }
LABEL_15:
  if ( weapType == WEAPTYPE_GRENADE || (unsigned int)(weapType - 6) <= 2 )
    return (unsigned int)scr_const.tag_accessory_right;
  if ( hand )
    return (unsigned int)scr_const.tag_weapon_left;
  result = (unsigned int)scr_const.tag_weapon_right;
  if ( ci->leftHandGun )
    return (unsigned int)scr_const.tag_weapon_left;
  return result;
}

/*
==============
BG_Weapons_GetScriptedAnimEvent
==============
*/
__int64 BG_Weapons_GetScriptedAnimEvent(const Weapon *offHandWeapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v2; 

  weaponIdx = offHandWeapon->weaponIdx;
  if ( weaponIdx && (v2 = BG_WeaponDefAtIndex(weaponIdx), v2->weapType == WEAPTYPE_SCRIPT) )
    return (unsigned int)v2->scriptedAnimEvent;
  else
    return 0i64;
}

/*
==============
BG_Weapons_IsRiotShieldModel
==============
*/
__int64 BG_Weapons_IsRiotShieldModel(const XModel *weapModel)
{
  const char *name; 
  const char *v3; 
  __int64 v4; 
  int v5; 
  signed __int64 v6; 
  char v7; 
  __int64 v8; 
  char v9; 
  unsigned int v10; 

  if ( !weapModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21087, ASSERT_TYPE_ASSERT, "(weapModel)", (const char *)&queryFormat, "weapModel") )
    __debugbreak();
  name = weapModel->name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
    __debugbreak();
  v3 = "weapon_wm_riotshield";
  v4 = 20i64;
  v5 = 1;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v6 = name - "weapon_wm_riotshield";
  while ( 1 )
  {
    v7 = v3[v6];
    v8 = v4;
    v9 = *v3++;
    --v4;
    v10 = 0;
    if ( !v8 )
    {
LABEL_14:
      v5 = 0;
      goto LABEL_15;
    }
    if ( v7 != v9 )
      break;
    if ( !v7 )
      goto LABEL_14;
  }
  if ( v7 < v9 )
    v5 = -1;
LABEL_15:
  LOBYTE(v10) = v5 == 0;
  return v10;
}

/*
==============
BG_Weapons_IsRiotShieldModelName
==============
*/
__int64 BG_Weapons_IsRiotShieldModelName(const char *const modelName)
{
  const char *v2; 
  __int64 v3; 
  signed __int64 v4; 
  char v5; 
  __int64 v6; 
  char v7; 

  if ( !modelName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
    __debugbreak();
  v2 = "weapon_wm_riotshield";
  v3 = 20i64;
  if ( !modelName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v4 = modelName - "weapon_wm_riotshield";
  while ( 1 )
  {
    v5 = v2[v4];
    v6 = v3;
    v7 = *v2++;
    --v3;
    if ( !v6 )
      return 1i64;
    if ( v5 != v7 )
      break;
    if ( !v5 )
      return 1i64;
  }
  return 0i64;
}

/*
==============
BG_WorldFlashEffect
==============
*/
FxCombinedDef BG_WorldFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 64i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 8i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 32i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 8i64);
  }
  return result;
}

/*
==============
BG_WorldLastShotEjectEffect
==============
*/
FxCombinedDef BG_WorldLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 96i64);
}

/*
==============
BG_WorldShellEjectEffect
==============
*/
FxCombinedDef BG_WorldShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 80i64);
}

/*
==============
BG_turretGetTagForFiringMuzzle
==============
*/
__int64 BG_turretGetTagForFiringMuzzle(const entityState_t *es, const Weapon *r_weapon)
{
  scr_string_t tag_flash; 
  const WeaponDef *v4; 
  int v5; 

  tag_flash = scr_const.tag_flash;
  if ( !r_weapon->weaponIdx )
    return (unsigned int)scr_const.tag_flash;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9871, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v4->turretFireType == TURRET_ALTERNATE_FIRE )
  {
    v5 = es->lerp.u.anonymous.data[7];
    if ( v5 > 15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9898, ASSERT_TYPE_ASSERT, "(shotCount <= ((1 << (4)) - 1))", (const char *)&queryFormat, "shotCount <= TURRET_SHOT_COUNT_MAX") )
      __debugbreak();
    if ( (v5 & 1) != 0 )
      return (unsigned int)scr_const.tag_flash_2;
  }
  return (unsigned int)tag_flash;
}

/*
==============
BGSpreadSetting::CalculateSpread
==============
*/
void BGSpreadSetting::CalculateSpread(BGSpreadSetting *this, int shotIndex, float *spreadMinOut, float *spreadMaxOut, float *angleMinOut, float *angleMaxOut)
{
  int m_shotCountInner; 
  float v11; 

  if ( !spreadMinOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 692, ASSERT_TYPE_ASSERT, "(spreadMinOut)", (const char *)&queryFormat, "spreadMinOut") )
    __debugbreak();
  if ( !spreadMaxOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 693, ASSERT_TYPE_ASSERT, "(spreadMaxOut)", (const char *)&queryFormat, "spreadMaxOut") )
    __debugbreak();
  if ( !angleMinOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 694, ASSERT_TYPE_ASSERT, "(angleMinOut)", (const char *)&queryFormat, "angleMinOut") )
    __debugbreak();
  if ( !angleMaxOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 695, ASSERT_TYPE_ASSERT, "(angleMaxOut)", (const char *)&queryFormat, "angleMaxOut") )
    __debugbreak();
  m_shotCountInner = this->m_shotCountInner;
  if ( shotIndex >= m_shotCountInner )
  {
    if ( shotIndex == m_shotCountInner )
      this->m_angleRange = 360.0 / (float)(2 * (this->m_shotCount - m_shotCountInner));
    *spreadMinOut = this->m_initSpreadMax * 0.33000001;
    *spreadMaxOut = this->m_initSpreadMax;
    v11 = (float)((float)((float)((float)(shotIndex - this->m_shotCountInner) * this->m_angleRange) * 2.0) + this->m_angleStart) + 180.0;
  }
  else
  {
    *spreadMinOut = 0.0;
    *spreadMaxOut = this->m_initSpreadMax * 0.33000001;
    v11 = (float)((float)(this->m_angleRange * 2.0) * (float)shotIndex) + this->m_angleStart;
  }
  *angleMinOut = v11;
  *angleMaxOut = v11 + this->m_angleRange;
}

/*
==============
TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes
==============
*/
unsigned __int8 TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, const scr_string_t tagName)
{
  __int64 v5; 
  int NumModels; 
  scr_string_t v10; 
  int ModelIndexForBoneIndex; 
  __int64 v12; 
  __int64 v13; 
  __int64 v15; 
  __int64 v16; 
  unsigned __int8 index; 

  v5 = modelTypeCount;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 366, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 367, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !modelTypesToSearch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 368, ASSERT_TYPE_ASSERT, "(modelTypesToSearch)", (const char *)&queryFormat, "modelTypesToSearch") )
    __debugbreak();
  NumModels = DObjGetNumModels(obj);
  if ( NumModels < 1 )
    return -2;
  v10 = tagName;
  index = -2;
  if ( !DObjGetBoneIndexFromStartModel(obj, tagName, 0, &index) )
    return -2;
  while ( 1 )
  {
    ModelIndexForBoneIndex = DObjGetModelIndexForBoneIndex(obj, index);
    v12 = ModelIndexForBoneIndex;
    if ( ModelIndexForBoneIndex >= (unsigned int)NumModels )
    {
      LODWORD(v16) = NumModels;
      LODWORD(v15) = ModelIndexForBoneIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 384, ASSERT_TYPE_ASSERT, "(unsigned)( foundModelIndex ) < (unsigned)( numModels )", "foundModelIndex doesn't index numModels\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    v13 = 0i64;
    if ( v5 > 0 )
      break;
LABEL_18:
    index = -2;
    if ( (int)v12 >= NumModels - 1 || !DObjGetBoneIndexFromStartModel(obj, v10, v12 + 1, &index) )
      return -2;
  }
  while ( ci->dobjModelTypes[v12] != modelTypesToSearch[v13] )
  {
    if ( ++v13 >= v5 )
      goto LABEL_18;
  }
  return index;
}

/*
==============
TagPair::GetFallbackTagName
==============
*/
__int64 TagPair::GetFallbackTagName(TagPair *this)
{
  return (unsigned int)this->m_fallbackTagName;
}

/*
==============
BgWeaponScalarAccumulator::GetFinalValue
==============
*/
float BgWeaponScalarAccumulator::GetFinalValue(BgWeaponScalarAccumulator *this, const float baseValue)
{
  __int128 v4; 
  __int128 v9; 

  _XMM2 = LODWORD(this->m_additiveScale);
  __asm { vmaxss  xmm3, xmm2, xmm0 }
  v4 = LODWORD(FLOAT_1_0);
  *(float *)&v4 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v4 + 1) = (v4 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v4 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM2 = v4;
  __asm
  {
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm7, xmm0
  }
  _XMM3 = LODWORD(this->m_multiplicativeScale);
  v9 = LODWORD(FLOAT_1_0);
  *(float *)&v9 = 1.0 - *(float *)&_XMM3;
  *((_QWORD *)&v9 + 1) = (v9 & (unsigned __int128)_xmm) >> 64;
  *(double *)&v9 = COERCE_FLOAT(COERCE_UNSIGNED_INT(1.0 - *(float *)&_XMM3) & _xmm);
  _XMM1 = v9;
  __asm
  {
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
  }
  return (float)(*(float *)&_XMM0 * baseValue) * *(float *)&_XMM6;
}

/*
==============
TagPair::GetPrimaryTagName
==============
*/
__int64 TagPair::GetPrimaryTagName(TagPair *this)
{
  return (unsigned int)this->m_primaryTagName;
}

/*
==============
TagPair::GetTagNameAndBoneIndex
==============
*/
char TagPair::GetTagNameAndBoneIndex(TagPair *this, const DObj *obj, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  scr_string_t m_fallbackTagName; 
  int modelIndex; 

  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 325, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 326, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *outTagName = this->m_primaryTagName;
  *outBoneIndex = -2;
  if ( obj && (this->m_primaryTagName || this->m_fallbackTagName) )
  {
    if ( DObjGetBoneIndexInternal_19(obj, this->m_primaryTagName, outBoneIndex, &modelIndex) )
      return 1;
    *outBoneIndex = -2;
    m_fallbackTagName = this->m_fallbackTagName;
    if ( m_fallbackTagName && DObjGetBoneIndexInternal_19(obj, m_fallbackTagName, outBoneIndex, &modelIndex) )
    {
      *outTagName = this->m_fallbackTagName;
      return 1;
    }
  }
  return 0;
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/
char TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  unsigned __int8 v11; 
  unsigned __int8 BoneIndexForTagNameMatchingCharacterModelTypes; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 433, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 434, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 435, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *outTagName = this->m_primaryTagName;
  *outBoneIndex = -2;
  if ( obj )
  {
    if ( this->m_primaryTagName )
    {
      BoneIndexForTagNameMatchingCharacterModelTypes = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, modelTypesToSearch, modelTypeCount, (const scr_string_t)this->m_primaryTagName);
      if ( BoneIndexForTagNameMatchingCharacterModelTypes != 0xFE )
      {
        *outTagName = this->m_primaryTagName;
        *outBoneIndex = BoneIndexForTagNameMatchingCharacterModelTypes;
        return 1;
      }
      goto LABEL_13;
    }
    if ( this->m_fallbackTagName )
    {
LABEL_13:
      if ( this->m_fallbackTagName )
      {
        v11 = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, modelTypesToSearch, modelTypeCount, (const scr_string_t)this->m_fallbackTagName);
        if ( v11 != 0xFE )
        {
          *outTagName = this->m_fallbackTagName;
          *outBoneIndex = v11;
          return 1;
        }
      }
    }
  }
  return 0;
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/
char TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType modelTypeToSearch, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  scr_string_t *v9; 
  unsigned __int8 *v10; 
  unsigned __int8 v11; 
  unsigned __int8 BoneIndexForTagNameMatchingCharacterModelTypes; 
  CharacterModelType modelTypesToSearch; 

  modelTypesToSearch = modelTypeToSearch;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 433, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v9 = outTagName;
  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 434, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  v10 = outBoneIndex;
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 435, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *v9 = this->m_primaryTagName;
  *v10 = -2;
  if ( obj )
  {
    if ( this->m_primaryTagName )
    {
      BoneIndexForTagNameMatchingCharacterModelTypes = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, &modelTypesToSearch, 1, (const scr_string_t)this->m_primaryTagName);
      if ( BoneIndexForTagNameMatchingCharacterModelTypes != 0xFE )
      {
        *v9 = this->m_primaryTagName;
        *v10 = BoneIndexForTagNameMatchingCharacterModelTypes;
        return 1;
      }
      goto LABEL_13;
    }
    if ( this->m_fallbackTagName )
    {
LABEL_13:
      if ( this->m_fallbackTagName )
      {
        v11 = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, &modelTypesToSearch, 1, (const scr_string_t)this->m_fallbackTagName);
        if ( v11 != 0xFE )
        {
          *v9 = this->m_fallbackTagName;
          *v10 = v11;
          return 1;
        }
      }
    }
  }
  return 0;
}

/*
==============
BGSpreadSetting::Init
==============
*/
void BGSpreadSetting::Init(BGSpreadSetting *this, float angleStart, int shotCount, float initSpreadMin, float initSpreadMax)
{
  int v5; 

  this->m_angleStart = angleStart;
  this->m_initSpreadMax = initSpreadMax;
  v5 = (int)(float)((float)shotCount * 0.25);
  this->m_shotCount = shotCount;
  if ( v5 < 1 )
    v5 = 1;
  this->m_shotCountInner = v5;
  this->m_angleRange = 360.0 / (float)(2 * v5);
  this->m_initSpreadMin = initSpreadMin;
}

/*
==============
TagPair::IsEmpty
==============
*/
bool TagPair::IsEmpty(TagPair *this)
{
  return !this->m_primaryTagName && !this->m_fallbackTagName;
}

/*
==============
BgWeaponScalarAccumulator::Reset
==============
*/
void BgWeaponScalarAccumulator::Reset(BgWeaponScalarAccumulator *this)
{
  this->m_additiveScale = 1.0;
  this->m_multiplicativeScale = 1.0;
}

/*
==============
TagPair::SetFallbackTagName
==============
*/
void TagPair::SetFallbackTagName(TagPair *this, scr_string_t tagName)
{
  this->m_fallbackTagName = tagName;
}

/*
==============
TagPair::SetPrimaryTagName
==============
*/
void TagPair::SetPrimaryTagName(TagPair *this, scr_string_t tagName)
{
  this->m_primaryTagName = tagName;
}

