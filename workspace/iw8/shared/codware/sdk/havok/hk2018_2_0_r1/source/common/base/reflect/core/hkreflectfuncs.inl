/*
==============
hkReflect::upCast<hclClothContainer,void>
==============
*/

hclClothContainer *__fastcall hkReflect::upCast<hclClothContainer,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@UhclClothContainer@@X@hkReflect@@YAPEAUhclClothContainer@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsBodyQualityList,void>
==============
*/

HavokPhysicsBodyQualityList *__fastcall hkReflect::upCast<HavokPhysicsBodyQualityList,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsBodyQualityList@@X@hkReflect@@YAPEAVHavokPhysicsBodyQualityList@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void>,void>
==============
*/

hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void> *__fastcall hkReflect::upCast<hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void>,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@U?$hkTuple@V?$hkArray@PEAVhknpConvexShape@@UhkContainerHeapAllocator@@@@V?$hkArray@MUhkContainerHeapAllocator@@@@XXXXXX@@X@hkReflect@@YAPEAU?$hkTuple@V?$hkArray@PEAVhknpConvexShape@@UhkContainerHeapAllocator@@@@V?$hkArray@MUhkContainerHeapAllocator@@@@XXXXXX@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsMaterialList,void>
==============
*/

HavokPhysicsMaterialList *__fastcall hkReflect::upCast<HavokPhysicsMaterialList,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsMaterialList@@X@hkReflect@@YAPEAVHavokPhysicsMaterialList@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsShapeList,void>
==============
*/

HavokPhysicsShapeList *__fastcall hkReflect::upCast<HavokPhysicsShapeList,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsShapeList@@X@hkReflect@@YAPEAVHavokPhysicsShapeList@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsXModelLOD,void>
==============
*/

HavokPhysicsXModelLOD *__fastcall hkReflect::upCast<HavokPhysicsXModelLOD,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsXModelLOD@@X@hkReflect@@YAPEAVHavokPhysicsXModelLOD@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<hknpShape,void>
==============
*/

hknpShape *__fastcall hkReflect::upCast<hknpShape,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VhknpShape@@X@hkReflect@@YAPEAVhknpShape@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsMotionPropertiesList,void>
==============
*/

HavokPhysicsMotionPropertiesList *__fastcall hkReflect::upCast<HavokPhysicsMotionPropertiesList,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsMotionPropertiesList@@X@hkReflect@@YAPEAVHavokPhysicsMotionPropertiesList@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<HavokPhysicsAsset,void>
==============
*/

HavokPhysicsAsset *__fastcall hkReflect::upCast<HavokPhysicsAsset,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@VHavokPhysicsAsset@@X@hkReflect@@YAPEAVHavokPhysicsAsset@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<void>
==============
*/

void *__fastcall hkReflect::upCast<void>(void *object, const hkReflect::Type *srcType, const hkReflect::Type *toType)
{
  return ??$upCast@X@hkReflect@@YAPEAXPEAXPEBVType@0@1@Z(object, srcType, toType);
}

/*
==============
hkReflect::upCast<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>,void>
==============
*/

hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *__fastcall hkReflect::upCast<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>,void>(void *object, const hkReflect::Type *srcType)
{
  return ??$upCast@V?$hkArray@PEBVType@hkReflect@@UhkContainerHeapAllocator@@@@X@hkReflect@@YAPEAV?$hkArray@PEBVType@hkReflect@@UhkContainerHeapAllocator@@@@PEAXPEBVType@0@@Z(object, srcType);
}

/*
==============
hkReflect::upCast<hknpShape,void>
==============
*/
hknpShape *hkReflect::upCast<hknpShape,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &hknpShape::typeData) )
    return (hknpShape *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<void>
==============
*/
void *hkReflect::upCast<void>(void *object, const hkReflect::Type *srcType, const hkReflect::Type *toType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, toType) )
    return object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>,void>
==============
*/
hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *hkReflect::upCast<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &hkReflect::ReflectionOf<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>>::typeData) )
    return (hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsAsset,void>
==============
*/
HavokPhysicsAsset *hkReflect::upCast<HavokPhysicsAsset,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsAsset::typeData) )
    return (HavokPhysicsAsset *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsBodyQualityList,void>
==============
*/
HavokPhysicsBodyQualityList *hkReflect::upCast<HavokPhysicsBodyQualityList,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsBodyQualityList::typeData) )
    return (HavokPhysicsBodyQualityList *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsMaterialList,void>
==============
*/
HavokPhysicsMaterialList *hkReflect::upCast<HavokPhysicsMaterialList,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsMaterialList::typeData) )
    return (HavokPhysicsMaterialList *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsMotionPropertiesList,void>
==============
*/
HavokPhysicsMotionPropertiesList *hkReflect::upCast<HavokPhysicsMotionPropertiesList,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsMotionPropertiesList::typeData) )
    return (HavokPhysicsMotionPropertiesList *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsShapeList,void>
==============
*/
HavokPhysicsShapeList *hkReflect::upCast<HavokPhysicsShapeList,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsShapeList::typeData) )
    return (HavokPhysicsShapeList *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<HavokPhysicsXModelLOD,void>
==============
*/
HavokPhysicsXModelLOD *hkReflect::upCast<HavokPhysicsXModelLOD,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &HavokPhysicsXModelLOD::typeData) )
    return (HavokPhysicsXModelLOD *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void>,void>
==============
*/
hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void> *hkReflect::upCast<hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void>,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &hkReflect::ReflectionOf<hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void>>::typeData) )
    return (hkTuple<hkArray<hknpConvexShape *,hkContainerHeapAllocator>,hkArray<float,hkContainerHeapAllocator>,void,void,void,void,void,void> *)object;
  else
    return 0i64;
}

/*
==============
hkReflect::upCast<hclClothContainer,void>
==============
*/
hclClothContainer *hkReflect::upCast<hclClothContainer,void>(void *object, const hkReflect::Type *srcType)
{
  if ( srcType && hkReflect::Type::extendsOrEquals((hkReflect::Type *)srcType, &hclClothContainer::typeData) )
    return (hclClothContainer *)object;
  else
    return 0i64;
}

