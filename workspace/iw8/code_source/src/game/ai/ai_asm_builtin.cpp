/*
==============
ASM_ChooseAnim_WeaponClass
==============
*/

bool __fastcall ASM_ChooseAnim_WeaponClass(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_WeaponClass@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_CheckArrivalType
==============
*/

bool __fastcall ASM_CheckArrivalType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_CheckArrivalType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsRequestedStance
==============
*/

bool __fastcall ASM_IsRequestedStance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsRequestedStance@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldAbortExecution
==============
*/

bool __fastcall ASM_ShouldAbortExecution(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldAbortExecution@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsExposed_Crouch
==============
*/

bool __fastcall ASM_IsExposed_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsExposed_Crouch@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_GrenadeReturnThrowRequested
==============
*/

bool __fastcall ASM_GrenadeReturnThrowRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_GrenadeReturnThrowRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShootStyleMG
==============
*/

bool __fastcall ASM_ShootStyleMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootStyleMG@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldRunNGun
==============
*/

bool __fastcall ASM_ShouldRunNGun(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldRunNGun@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasDoorShuffleNodeInDir
==============
*/

bool __fastcall ASM_HasDoorShuffleNodeInDir(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasDoorShuffleNodeInDir@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_MoveTypeIs
==============
*/

bool __fastcall ASM_MoveTypeIs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_MoveTypeIs@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_BurstCount
==============
*/

bool __fastcall ASM_ChooseAnim_BurstCount(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_BurstCount@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ReturnAnimID
==============
*/

void __fastcall ASM_ReturnAnimID(int entryIndex, void *pOutValue)
{
  ?ASM_ReturnAnimID@@YAXHPEAX@Z(entryIndex, pOutValue);
}

/*
==============
ASM_ShootParamsChanged
==============
*/

bool __fastcall ASM_ShootParamsChanged(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootParamsChanged@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_WeaponSwitch
==============
*/

bool __fastcall ASM_ChooseAnim_WeaponSwitch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_WeaponSwitch@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_IsSuppressed
==============
*/

bool __fastcall ASM_ChooseAnim_IsSuppressed(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_IsSuppressed@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_Transition_ReturnFalse
==============
*/

bool __fastcall ASM_Transition_ReturnFalse(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_Transition_ReturnFalse@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStopForNewStrafePath
==============
*/

bool __fastcall ASM_ShouldStopForNewStrafePath(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStopForNewStrafePath@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_Execution_Victim
==============
*/

bool __fastcall ASM_ChooseAnim_Execution_Victim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_Execution_Victim@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCoverStand
==============
*/

bool __fastcall ASM_IsCoverStand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverStand@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_MeleeRequested
==============
*/

bool __fastcall ASM_MeleeRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_MeleeRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCoverLeft_Crouch
==============
*/

bool __fastcall ASM_IsCoverLeft_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverLeft_Crouch@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldSwitchWeaponsInCover
==============
*/

bool __fastcall ASM_ShouldSwitchWeaponsInCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldSwitchWeaponsInCover@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShootShouldWaitForNotetrackAim
==============
*/

bool __fastcall ASM_ShootShouldWaitForNotetrackAim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootShouldWaitForNotetrackAim@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsNotRequestedCoverState
==============
*/

bool __fastcall ASM_IsNotRequestedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsNotRequestedCoverState@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_StairsWithinDistance
==============
*/

bool __fastcall ASM_StairsWithinDistance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_StairsWithinDistance@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsWeaponClass
==============
*/

bool __fastcall ASM_IsWeaponClass(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsWeaponClass@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStrafeStart
==============
*/

bool __fastcall ASM_ShouldStrafeStart(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStrafeStart@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsHighestAllowedStance
==============
*/

bool __fastcall ASM_IsHighestAllowedStance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsHighestAllowedStance@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_FaceMotionAndOriented
==============
*/

bool __fastcall ASM_FaceMotionAndOriented(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_FaceMotionAndOriented@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldAimDown
==============
*/

bool __fastcall ASM_ShouldAimDown(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldAimDown@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_BlindfireRequested
==============
*/

bool __fastcall ASM_BlindfireRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_BlindfireRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCoverRight_Stand
==============
*/

bool __fastcall ASM_IsCoverRight_Stand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverRight_Stand@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_NotShouldShootMG
==============
*/

bool __fastcall ASM_NotShouldShootMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_NotShouldShootMG@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShootUpdateParams
==============
*/

bool __fastcall ASM_ShootUpdateParams(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootUpdateParams@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
SetupMotionWarp
==============
*/

void __fastcall SetupMotionWarp(int entNum, const vec3_t *animDelta, const vec4_t *qAnimRot, const vec3_t *targetPos, const vec3_t *targetAngles, float animDuration)
{
  ?SetupMotionWarp@@YAXHAEBTvec3_t@@Tvec4_t@@T1@2M@Z(entNum, animDelta, qAnimRot, targetPos, targetAngles, animDuration);
}

/*
==============
ASM_GrenadeAvoidRequested
==============
*/

bool __fastcall ASM_GrenadeAvoidRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_GrenadeAvoidRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsSniper
==============
*/

bool __fastcall ASM_IsSniper(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsSniper@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShootStyleSingle
==============
*/

bool __fastcall ASM_ShootStyleSingle(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootStyleSingle@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
AI_ASM_GetBuiltinFunc
==============
*/

bool (__fastcall *__fastcall AI_ASM_GetBuiltinFunc(int i))(int, const scr_string_t, const scr_string_t, int, ASM_Function_Param *, void *)
{
  return ?AI_ASM_GetBuiltinFunc@@YAP6A_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@ZH@Z(i);
}

/*
==============
ASM_IsCoverRight_Crouch
==============
*/

bool __fastcall ASM_IsCoverRight_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverRight_Crouch@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_WeaponClassPrepended
==============
*/

bool __fastcall ASM_ChooseAnim_WeaponClassPrepended(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_WeaponClassPrepended@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_MeleeChargeRequested
==============
*/

bool __fastcall ASM_MeleeChargeRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_MeleeChargeRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsRequestedCoverExposeType
==============
*/

bool __fastcall ASM_IsRequestedCoverExposeType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsRequestedCoverExposeType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ReturnAnimIDUndefined
==============
*/

void __fastcall ASM_ReturnAnimIDUndefined(void *pOutValue)
{
  ?ASM_ReturnAnimIDUndefined@@YAXPEAX@Z(pOutValue);
}

/*
==============
ASM_IsNotRequestedCoverExposedAndType
==============
*/

bool __fastcall ASM_IsNotRequestedCoverExposedAndType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsNotRequestedCoverExposedAndType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_PlayAnim
==============
*/

bool __fastcall ASM_PlayAnim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_PlayAnim@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldDropRocketLauncher
==============
*/

bool __fastcall ASM_ShouldDropRocketLauncher(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldDropRocketLauncher@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasShuffleNodeInDir
==============
*/

bool __fastcall ASM_HasShuffleNodeInDir(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasShuffleNodeInDir@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldEnterStairsState
==============
*/

bool __fastcall ASM_ShouldEnterStairsState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldEnterStairsState@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_GetAnimID
==============
*/

int __fastcall ASM_GetAnimID(int entNum, const scr_string_t asmName, const scr_string_t toStateName)
{
  return ?ASM_GetAnimID@@YAHHW4scr_string_t@@0@Z(entNum, asmName, toStateName);
}

/*
==============
ASM_IsBlackboardTrue
==============
*/

bool __fastcall ASM_IsBlackboardTrue(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsBlackboardTrue@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsOnAnyStairs
==============
*/

bool __fastcall ASM_IsOnAnyStairs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsOnAnyStairs@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCoverLeft_Stand
==============
*/

bool __fastcall ASM_IsCoverLeft_Stand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverLeft_Stand@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStopRunNGunForward
==============
*/

bool __fastcall ASM_ShouldStopRunNGunForward(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStopRunNGunForward@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_ExposedReload
==============
*/

bool __fastcall ASM_ChooseAnim_ExposedReload(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_ExposedReload@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
SetupMotionWarp
==============
*/

void __fastcall SetupMotionWarp(int entNum, const vec3_t *animDelta, const vec4_t *qAnimRot, const vec3_t *targetPos, const vec3_t *targetAngles, int animDuration)
{
  ?SetupMotionWarp@@YAXHAEBTvec3_t@@Tvec4_t@@T1@2H@Z(entNum, animDelta, qAnimRot, targetPos, targetAngles, animDuration);
}

/*
==============
ASM_ShouldSnapToCover
==============
*/

bool __fastcall ASM_ShouldSnapToCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldSnapToCover@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_MoveRequested
==============
*/

bool __fastcall ASM_MoveRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_MoveRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_WeaponClass_Reload
==============
*/

bool __fastcall ASM_ChooseAnim_WeaponClass_Reload(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_WeaponClass_Reload@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_PlayMoveLoop_CodeBlend_Cleanup
==============
*/

bool __fastcall ASM_PlayMoveLoop_CodeBlend_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_PlayMoveLoop_CodeBlend_Cleanup@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasShuffleNode
==============
*/

bool __fastcall ASM_HasShuffleNode(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasShuffleNode@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim
==============
*/

bool __fastcall ASM_ChooseAnim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldPainExposedFromCover
==============
*/

bool __fastcall ASM_ShouldPainExposedFromCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldPainExposedFromCover@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldSnapToCoverWhileMoving
==============
*/

bool __fastcall ASM_ShouldSnapToCoverWhileMoving(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldSnapToCoverWhileMoving@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsRequestedCoverExposedAndType
==============
*/

bool __fastcall ASM_IsRequestedCoverExposedAndType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsRequestedCoverExposedAndType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ShouldRunNGunForward
==============
*/

bool __fastcall ShouldRunNGunForward(const AIScriptedInterface *pAI)
{
  return ?ShouldRunNGunForward@@YA_NPEBVAIScriptedInterface@@@Z(pAI);
}

/*
==============
ASM_ShouldAbortExposedCoverState
==============
*/

bool __fastcall ASM_ShouldAbortExposedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldAbortExposedCoverState@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldSwitchWeapons
==============
*/

bool __fastcall ASM_ShouldSwitchWeapons(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldSwitchWeapons@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCurrentPose
==============
*/

bool __fastcall ASM_IsCurrentPose(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCurrentPose@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasShuffleNodeOfType
==============
*/

bool __fastcall ASM_HasShuffleNodeOfType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasShuffleNodeOfType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_PlayAnim_ShootFire_Cleanup
==============
*/

bool __fastcall ASM_PlayAnim_ShootFire_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_PlayAnim_ShootFire_Cleanup@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_PlayAnim_ShootIdle_Cleanup
==============
*/

bool __fastcall ASM_PlayAnim_ShootIdle_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_PlayAnim_ShootIdle_Cleanup@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStrafeReverse
==============
*/

bool __fastcall ASM_ShouldStrafeReverse(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStrafeReverse@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_PlayFacialAnim
==============
*/

void __fastcall ASM_PlayFacialAnim(int entNum, const scr_string_t asmName, const Animset *pAnimset, int stateIndex, int entryIndex)
{
  ?ASM_PlayFacialAnim@@YAXHW4scr_string_t@@PEBUAnimset@@HH@Z(entNum, asmName, pAnimset, stateIndex, entryIndex);
}

/*
==============
ASM_MoveTypeIsNot
==============
*/

bool __fastcall ASM_MoveTypeIsNot(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_MoveTypeIsNot@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ChooseAnim_Random
==============
*/

bool __fastcall ASM_ChooseAnim_Random(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ChooseAnim_Random@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsRequestedCoverState
==============
*/

bool __fastcall ASM_IsRequestedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsRequestedCoverState@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsNotAtCoverNode
==============
*/

bool __fastcall ASM_IsNotAtCoverNode(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsNotAtCoverNode@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsCoverCrouch
==============
*/

bool __fastcall ASM_IsCoverCrouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsCoverCrouch@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldAbortShuffle
==============
*/

bool __fastcall ASM_ShouldAbortShuffle(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldAbortShuffle@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasNotetrackAimFired
==============
*/

bool __fastcall ASM_HasNotetrackAimFired(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasNotetrackAimFired@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_IsOnStairs
==============
*/

bool __fastcall ASM_IsOnStairs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_IsOnStairs@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldBeginFiring
==============
*/

bool __fastcall ASM_ShouldBeginFiring(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldBeginFiring@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_CleanupCalcArrivalType
==============
*/

bool __fastcall ASM_CleanupCalcArrivalType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_CleanupCalcArrivalType@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShootStyleFull
==============
*/

bool __fastcall ASM_ShootStyleFull(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShootStyleFull@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStopAimDown
==============
*/

bool __fastcall ASM_ShouldStopAimDown(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStopAimDown@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldShootMG
==============
*/

bool __fastcall ASM_ShouldShootMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldShootMG@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_HasTraversalWithin
==============
*/

bool __fastcall ASM_HasTraversalWithin(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_HasTraversalWithin@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldStrafe
==============
*/

bool __fastcall ASM_ShouldStrafe(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldStrafe@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_Transition_ReturnTrue
==============
*/

bool __fastcall ASM_Transition_ReturnTrue(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_Transition_ReturnTrue@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldReloadWhileMoving
==============
*/

bool __fastcall ASM_ShouldReloadWhileMoving(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldReloadWhileMoving@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ReloadRequested
==============
*/

bool __fastcall ASM_ReloadRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ReloadRequested@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_EventFired
==============
*/

bool __fastcall ASM_EventFired(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_EventFired@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_ShouldRunNGunForward
==============
*/

bool __fastcall ASM_ShouldRunNGunForward(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  return ?ASM_ShouldRunNGunForward@@YA_NHW4scr_string_t@@0HPEAUASM_Function_Param@@PEAX@Z(entNum, asmName, toStateName, numParams, pParams, pOutValue);
}

/*
==============
ASM_Transition_ReturnTrue
==============
*/
char ASM_Transition_ReturnTrue(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return 1;
}

/*
==============
ASM_EventFired
==============
*/
bool ASM_EventFired(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  Ai_Asm *v8; 
  const ASM_Instance *Instance; 
  scr_string_t StringParam; 

  v8 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v8, NULL, entNum);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 63, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != asmName )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, asmName);
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 68, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
      __debugbreak();
  }
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 72, ASSERT_TYPE_ASSERT, "(eventName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "eventName != NULL_SCR_STRING") )
    __debugbreak();
  return Common_Asm::Utils::EventFired(Instance, StringParam);
}

/*
==============
ASM_IsOnStairs
==============
*/
bool ASM_IsOnStairs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v5; 
  AIScriptedInterface *m_pAI; 
  scr_string_t StringParam; 
  AI_STAIRS_STATE v9; 
  bool result; 
  int v12; 
  AIWrapper v13; 

  v5 = entNum;
  if ( (unsigned int)entNum >= 0x800 )
  {
    v12 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 93, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v12) )
      __debugbreak();
  }
  AIWrapper::AIWrapper(&v13, &g_entities[v5]);
  m_pAI = v13.m_pAI;
  result = 0;
  if ( v13.m_pAI )
  {
    StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
    v9 = m_pAI->GetStairsState(m_pAI);
    if ( StringParam == scr_const.up && v9 == AI_STAIRS_UP )
      return 1;
    if ( StringParam == scr_const.down && v9 == AI_STAIRS_DOWN || StringParam == scr_const.none && v9 == AI_STAIRS_NONE )
      return 1;
  }
  return result;
}

/*
==============
ASM_IsOnAnyStairs
==============
*/
bool ASM_IsOnAnyStairs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AINavigator *Navigator; 
  AINavigator *v6; 
  AINavigator2D *v7; 
  int v10; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 )
  {
    v10 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 114, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v10) )
      __debugbreak();
  }
  Navigator = Nav_GetNavigator(&g_entities[v4]);
  v6 = Navigator;
  return Navigator && Navigator->PathRequested(Navigator) && (v7 = v6->Get2DNavigator(v6)) != NULL && AINavigator2D::IsOnStairs(v7);
}

/*
==============
ASM_ShouldEnterStairsState
==============
*/
bool ASM_ShouldEnterStairsState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v7; 
  AIScriptedInterface *m_pAI; 
  __int64 v9; 
  scr_string_t StringParam; 
  AI_STAIRS_STATE v11; 
  __int64 v12; 
  int v13; 
  AIWrapper v18; 
  char v19[16]; 

  v7 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 138, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v18, &g_entities[v7]);
  m_pAI = v18.m_pAI;
  if ( !v18.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 141, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v9 = m_pAI->GetAI(m_pAI);
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  v11 = m_pAI->GetStairsState(m_pAI);
  if ( v11 == AI_STAIRS_NONE )
  {
    v13 = *(_DWORD *)(v9 + 480);
    _XMM6 = LODWORD(FLOAT_36_0);
    if ( v13 != scr_const.casual && v13 != scr_const.casual_gun )
    {
      *(double *)&_XMM0 = AIScriptedInterface::GetDefaultSpeed(m_pAI);
      __asm
      {
        vcmpltss xmm2, xmm0, cs:__real@42f00000
        vblendvps xmm1, xmm6, xmm1, xmm2
      }
    }
    v11 = (*(unsigned int (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(v9 + 392) + 328i64))(*(_QWORD *)(v9 + 392), v12, v19);
  }
  return StringParam == scr_const.up && v11 == AI_STAIRS_UP || StringParam == scr_const.down && v11 == AI_STAIRS_DOWN;
}

/*
==============
ASM_IsBlackboardTrue
==============
*/
bool ASM_IsBlackboardTrue(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  scr_string_t StringParam; 

  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 86, ASSERT_TYPE_ASSERT, "(varname != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "varname != NULL_SCR_STRING") )
    __debugbreak();
  return Scr_IsBlackboardFieldTrue(entNum, StringParam);
}

/*
==============
ASM_ReloadRequested
==============
*/
_BOOL8 ASM_ReloadRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return GetBlackboard(entNum)->m_bReload;
}

/*
==============
ASM_GrenadeReturnThrowRequested
==============
*/
_BOOL8 ASM_GrenadeReturnThrowRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return GetBlackboard(entNum)->m_bGrenadeReturnThrow;
}

/*
==============
ASM_GrenadeAvoidRequested
==============
*/
_BOOL8 ASM_GrenadeAvoidRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return GetBlackboard(entNum)->m_bGrenadeAvoid;
}

/*
==============
ASM_MeleeRequested
==============
*/
_BOOL8 ASM_MeleeRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return GetBlackboard(entNum)->m_bMeleeRequested;
}

/*
==============
ASM_MeleeChargeRequested
==============
*/
bool ASM_MeleeChargeRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v7; 

  v4 = entNum;
  if ( !GetBlackboard(entNum)->m_bMeleeChargeRequested )
    return 0;
  if ( (unsigned int)v4 >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 816, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v4, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v7, &g_entities[v4]);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 817, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return AICommonInterface::HasPath(m_pAI);
}

/*
==============
ASM_BlindfireRequested
==============
*/
_BOOL8 ASM_BlindfireRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return GetBlackboard(entNum)->m_bBlindfire;
}

/*
==============
ASM_IsRequestedStance
==============
*/
bool ASM_IsRequestedStance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 
  scr_string_t StringParam; 
  ai_stance_e v9; 
  scrContext_t *v10; 
  const char *v11; 
  const char *v12; 

  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 182, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  Blackboard = GetBlackboard(entNum);
  if ( !Blackboard && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 185, ASSERT_TYPE_ASSERT, "(pBB)", (const char *)&queryFormat, "pBB") )
    __debugbreak();
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  v9 = AI_StringToStance(StringParam);
  if ( v9 == STANCE_BAD )
  {
    v10 = ScriptContext_Server();
    v11 = SL_ConvertToString(StringParam);
    v12 = j_va("IsRequestedStance: Invalid stance %s", v11);
    Scr_Error(COM_ERR_2445, v10, v12);
  }
  return Blackboard->m_DesiredStance == v9;
}

/*
==============
ASM_IsRequestedCoverState
==============
*/
bool ASM_IsRequestedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_CoverState == ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_IsNotRequestedCoverState
==============
*/
bool ASM_IsNotRequestedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_CoverState != ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_IsRequestedCoverExposeType
==============
*/
bool ASM_IsRequestedCoverExposeType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_CoverExposeType == ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_IsRequestedCoverExposedAndType
==============
*/
bool ASM_IsRequestedCoverExposedAndType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_CoverState == scr_const.exposed && Blackboard->m_CoverExposeType == ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_IsNotRequestedCoverExposedAndType
==============
*/
bool ASM_IsNotRequestedCoverExposedAndType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_CoverState != scr_const.exposed || Blackboard->m_CoverExposeType != ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_IsNotAtCoverNode
==============
*/
bool ASM_IsNotAtCoverNode(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v7; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 236, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v7, &g_entities[v4]);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 237, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return AIScriptedInterface::GetCoverNode(m_pAI) == NULL;
}

/*
==============
ASM_IsCurrentPose
==============
*/
bool ASM_IsCurrentPose(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v5; 
  ai_scripted_t *AIScripted; 
  scr_string_t StringParam; 
  ai_stance_e v9; 
  const char *v10; 

  v5 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 244, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIScripted = AI_GetAIScripted(&g_entities[v5]);
  if ( !AIScripted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 246, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  v9 = AI_StringToStance(StringParam);
  if ( v9 == STANCE_BAD )
  {
    v10 = SL_ConvertToString(StringParam);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 251, ASSERT_TYPE_ASSERT, "( stance != STANCE_BAD )", "Invalid stance %s passed to ASM_IsCurrentPose", v10) )
      __debugbreak();
  }
  return AIScripted->eCurrentStance == v9;
}

/*
==============
ASM_IsWeaponClass
==============
*/
bool ASM_IsWeaponClass(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v5; 
  ai_scripted_t *AIScripted; 
  scr_string_t StringParam; 

  v5 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 282, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIScripted = AI_GetAIScripted(&g_entities[v5]);
  if ( !AIScripted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 284, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  return IsWeaponClass((const scr_weapon_t)AIScripted->currentWeapon, StringParam);
}

/*
==============
ASM_IsSniper
==============
*/
bool ASM_IsSniper(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 782, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return AIScriptedInterface::IsSniper(m_pAI, 1);
}

/*
==============
ASM_MoveRequested
==============
*/
bool ASM_MoveRequested(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v6; 
  AIScriptedInterface *m_pAI; 
  __int64 v8; 
  AIWrapper v10; 
  vec3_t vFinalGoal; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 293, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v10, &g_entities[v6]);
  m_pAI = v10.m_pAI;
  if ( !v10.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 294, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v8 = m_pAI->GetAI(m_pAI);
  if ( numParams > 0 && *(_DWORD *)(v8 + 480) != ASM_Builtin_GetStringParam(0, pParams, numParams) || !m_pAI->IsCodeMoveRequested(m_pAI) )
    return 0;
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(v8 + 392) + 216i64))(*(_QWORD *)(v8 + 392)) )
    return 1;
  AICommonInterface::GetPathFinalGoal(m_pAI, &vFinalGoal);
  return !AICommonInterface::PointNearPointSqDist(m_pAI, (const vec3_t *)(*(_QWORD *)v8 + 304i64), &vFinalGoal, 4.0);
}

/*
==============
ASM_ShootShouldWaitForNotetrackAim
==============
*/
bool ASM_ShootShouldWaitForNotetrackAim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const ASM_State *State; 

  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, entNum);
  State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
  if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 319, ASSERT_TYPE_ASSERT, "(pState)", (const char *)&queryFormat, "pState") )
    __debugbreak();
  return (State->m_Flags & 2) != 0 && !Common_Asm::Utils::EventFired(Instance, (const scr_string_t)scr_const.start_aim);
}

/*
==============
ASM_HasNotetrackAimFired
==============
*/
bool ASM_HasNotetrackAimFired(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  Ai_Asm *v5; 
  ASM_Instance *Instance; 

  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, entNum);
  return (Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState)->m_Flags & 2) == 0 || Common_Asm::Utils::EventFired(Instance, (const scr_string_t)scr_const.start_aim);
}

/*
==============
ASM_ShouldShootMG
==============
*/
bool ASM_ShouldShootMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  ai_common_t *v5; 
  bool result; 
  AIWrapper v7; 

  AIWrapper::AIWrapper(&v7, &g_entities[entNum]);
  m_pAI = v7.m_pAI;
  v5 = v7.m_pAI->GetAI(v7.m_pAI);
  if ( IsWeaponClass(SLODWORD(v5[2].sight.lastEnemySightPos.v[2]), (const scr_string_t)scr_const.mg) )
    return 1;
  result = AICommonInterface::IsUsingTurret(m_pAI);
  if ( result )
    return 1;
  return result;
}

/*
==============
ASM_NotShouldShootMG
==============
*/
bool ASM_NotShouldShootMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  ai_common_t *v5; 
  AIWrapper v7; 

  AIWrapper::AIWrapper(&v7, &g_entities[entNum]);
  m_pAI = v7.m_pAI;
  v5 = v7.m_pAI->GetAI(v7.m_pAI);
  return !IsWeaponClass(SLODWORD(v5[2].sight.lastEnemySightPos.v[2]), (const scr_string_t)scr_const.mg) && !AICommonInterface::IsUsingTurret(m_pAI);
}

/*
==============
ASM_MoveTypeIs
==============
*/
bool ASM_MoveTypeIs(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_MoveType == ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_MoveTypeIsNot
==============
*/
bool ASM_MoveTypeIsNot(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIBlackboard *Blackboard; 

  Blackboard = GetBlackboard(entNum);
  return Blackboard->m_MoveType != ASM_Builtin_GetStringParam(0, pParams, numParams);
}

/*
==============
ASM_Transition_ReturnFalse
==============
*/
bool ASM_Transition_ReturnFalse(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return 0;
}

/*
==============
ASM_ShouldAimDown
==============
*/
bool ASM_ShouldAimDown(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  Ai_Asm *v6; 
  ASM_Instance *Instance; 
  bool result; 
  double PitchToTarget; 
  AIWrapper v10; 

  AIWrapper::AIWrapper(&v10, &g_entities[entNum]);
  m_pAI = v10.m_pAI;
  v6 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v6, NULL, entNum);
  result = AIScriptedInterface::IsCurrentEnemyValid(m_pAI);
  if ( result )
  {
    PitchToTarget = AIScriptedInterface::GetPitchToTarget(m_pAI, Instance->m_pScrContext);
    return *(float *)&PitchToTarget < -45.0;
  }
  return result;
}

/*
==============
ASM_ShouldStopAimDown
==============
*/
bool ASM_ShouldStopAimDown(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  Ai_Asm *v6; 
  ASM_Instance *Instance; 
  double PitchToTarget; 
  AIWrapper v10; 

  AIWrapper::AIWrapper(&v10, &g_entities[entNum]);
  m_pAI = v10.m_pAI;
  v6 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v6, NULL, entNum);
  if ( !AIScriptedInterface::IsCurrentEnemyValid(m_pAI) )
    return 1;
  PitchToTarget = AIScriptedInterface::GetPitchToTarget(m_pAI, Instance->m_pScrContext);
  return *(float *)&PitchToTarget > -35.0;
}

/*
==============
ASM_FaceMotionAndOriented
==============
*/
bool ASM_FaceMotionAndOriented(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  float *v7; 
  double v9; 
  float v10; 
  AIWrapper v13; 
  vec3_t outLookaheadDir; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 870, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v13, &g_entities[v4]);
  m_pAI = v13.m_pAI;
  if ( !v13.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 871, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  v7 = (float *)v6;
  if ( !*(_BYTE *)(v6 + 330) )
    return 0;
  Nav_GetLookaheadDir(*(const AINavigator **)(v6 + 392), &outLookaheadDir);
  v9 = vectoyaw((const vec2_t *)&outLookaheadDir);
  v10 = (float)(*(float *)&v9 - *(float *)(*(_QWORD *)v7 + 320i64)) * 0.0027777778;
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 1 }
  return COERCE_FLOAT(COERCE_UNSIGNED_INT((float)(v10 - *(float *)&_XMM4) * 360.0) & _xmm) <= v7[719];
}

/*
==============
ASM_IsHighestAllowedStance
==============
*/
bool ASM_IsHighestAllowedStance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v5; 
  AIScriptedInterface *m_pAI; 
  scr_string_t StringParam; 
  ai_stance_e BestStance; 
  AIWrapper v11; 

  v5 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 886, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v11, &g_entities[v5]);
  m_pAI = v11.m_pAI;
  if ( !v11.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 887, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  BestStance = AIScriptedInterface::GetBestStance(m_pAI, STANCE_CROUCH);
  return StringParam == AI_StanceToString(BestStance);
}

/*
==============
ASM_ShouldStrafe
==============
*/
bool ASM_ShouldStrafe(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  AIWrapper v8; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 901, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v8, &g_entities[v4]);
  m_pAI = v8.m_pAI;
  if ( !v8.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 902, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  return *(_BYTE *)(v6 + 1741) && !*(_BYTE *)(v6 + 330) && m_pAI->IsCodeMoveRequested(m_pAI);
}

/*
==============
ASM_ShouldStrafeStart
==============
*/
bool ASM_ShouldStrafeStart(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  double PathDistToGoal; 
  AIWrapper v9; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 910, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v9, &g_entities[v4]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 911, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  if ( *(_BYTE *)(v6 + 330) || !AICommonInterface::HasPath(m_pAI) )
    return 0;
  PathDistToGoal = Nav_GetPathDistToGoal(*(const AINavigator **)(v6 + 392));
  return *(float *)&PathDistToGoal > 36.0;
}

/*
==============
ASM_ShouldStrafeReverse
==============
*/
bool ASM_ShouldStrafeReverse(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  const gentity_s *v6; 
  AIScriptedInterface *m_pAI; 
  _BYTE *v8; 
  int number; 
  Ai_Asm *v10; 
  ASM_Instance *Instance; 
  const ASM *m_pASM; 
  int frameDuration; 
  scr_string_t sharp_turn; 
  Ai_Asm *v15; 
  Ai_Asm *v16; 
  scrContext_t *v17; 
  unsigned int ArrayVariable; 
  unsigned int Object; 
  unsigned int v20; 
  float v22; 
  __int128 v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  __int128 v28; 
  float v32; 
  __int128 v33; 
  int *outParamId; 
  __int64 v38; 
  int intValue; 
  unsigned int outVar; 
  VariableValue out; 
  AIWrapper v42; 
  float v43; 
  float v44; 
  float v45; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 974, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v6 = &g_entities[v4];
  AIWrapper::AIWrapper(&v42, v6);
  m_pAI = v42.m_pAI;
  if ( !v42.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 976, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v8 = (_BYTE *)m_pAI->GetAI(m_pAI);
  if ( !v8[330] )
  {
    number = v6->s.number;
    v10 = Ai_Asm::Singleton();
    Instance = Ai_Asm::GetInstance(v10, NULL, number);
    if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 984, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
      __debugbreak();
    m_pASM = Instance->m_pASM;
    if ( Instance->m_pASM->m_Name != asmName )
    {
      Instance = Common_Asm::Utils::GetSubtree(Instance, asmName);
      m_pASM = Instance->m_pASM;
    }
    if ( Instance->m_CurState >= (unsigned int)m_pASM->m_NumStates )
    {
      LODWORD(v38) = m_pASM->m_NumStates;
      LODWORD(outParamId) = Instance->m_CurState;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 988, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", outParamId, v38) )
        __debugbreak();
    }
    if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
      __debugbreak();
    frameDuration = level.frameDuration;
    sharp_turn = scr_const.sharp_turn;
    v15 = Ai_Asm::Singleton();
    if ( Common_Asm::EventFiredWithin(v15, Instance, sharp_turn, frameDuration) )
    {
      v16 = Ai_Asm::Singleton();
      if ( Ai_Asm::GetEventData(v16, v6->s.number, Instance, scr_const.sharp_turn, &outVar, &intValue) )
      {
        v17 = ScriptContext_Server();
        ArrayVariable = FindArrayVariable(v17, outVar, intValue);
        if ( ArrayVariable )
        {
          Object = FindObject(v17, ArrayVariable);
          v20 = FindArrayVariable(v17, Object, 1);
          if ( v20 )
          {
            Scr_EvalVariable_Out(v17, v20, &out);
            if ( out.type == VAR_VECTOR )
            {
              v22 = *out.u.vectorValue;
              v23 = *(unsigned int *)(out.u.scriptCodePosValue + 4);
              v24 = *(float *)(out.u.scriptCodePosValue + 8);
              RemoveRefToValue(v17, 4, out.u);
              v25 = v22 - *(float *)(*(_QWORD *)v8 + 304i64);
              v28 = v23;
              v26 = *(float *)&v23 - *(float *)(*(_QWORD *)v8 + 308i64);
              v27 = v24 - *(float *)(*(_QWORD *)v8 + 312i64);
              *(float *)&v28 = (float)((float)(v26 * v26) + (float)(v25 * v25)) + (float)(v27 * v27);
              if ( *(float *)&v28 >= 2304.0 )
              {
                *(float *)&v28 = fsqrt(*(float *)&v28);
                _XMM1 = v28;
                __asm
                {
                  vcmpless xmm0, xmm1, cs:__real@80000000
                  vblendvps xmm0, xmm1, xmm9, xmm0
                }
                v32 = 1.0 / *(float *)&_XMM0;
                m_pAI->GetVelocity(m_pAI, (vec3_t *)&v43);
                v33 = LODWORD(v43);
                *(float *)&v33 = fsqrt((float)((float)(*(float *)&v33 * *(float *)&v33) + (float)(v44 * v44)) + (float)(v45 * v45));
                _XMM3 = v33;
                __asm
                {
                  vcmpless xmm0, xmm3, cs:__real@80000000
                  vblendvps xmm0, xmm3, xmm9, xmm0
                }
                return (float)((float)((float)((float)(v26 * v32) * (float)(v44 * (float)(1.0 / *(float *)&_XMM0))) + (float)((float)(v25 * v32) * (float)(v43 * (float)(1.0 / *(float *)&_XMM0)))) + (float)((float)(v45 * (float)(1.0 / *(float *)&_XMM0)) * (float)(v32 * v27))) < -0.5;
              }
            }
            else
            {
              RemoveRefToValue(v17, (unsigned __int8)out.type, out.u);
            }
          }
        }
      }
    }
  }
  return 0;
}

/*
==============
ASM_ShouldStopForNewStrafePath
==============
*/
bool ASM_ShouldStopForNewStrafePath(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  const gentity_s *v6; 
  AIScriptedInterface *m_pAI; 
  int number; 
  Ai_Asm *v9; 
  ASM_Instance *Instance; 
  const ASM *m_pASM; 
  int frameDuration; 
  scr_string_t sharp_turn; 
  Ai_Asm *v14; 
  Ai_Asm *v15; 
  scrContext_t *v16; 
  unsigned int ArrayVariable; 
  unsigned int Object; 
  unsigned int v19; 
  bool v21; 
  int *outParamId; 
  __int64 v23; 
  unsigned int outVar; 
  VariableValue out; 
  AIWrapper v26; 
  int intValue; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 925, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v6 = &g_entities[v4];
  AIWrapper::AIWrapper(&v26, v6);
  m_pAI = v26.m_pAI;
  if ( !v26.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 927, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( *(_BYTE *)(m_pAI->GetAI(m_pAI) + 330) )
    return 0;
  number = v6->s.number;
  v9 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v9, NULL, number);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 935, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  m_pASM = Instance->m_pASM;
  if ( Instance->m_pASM->m_Name != asmName )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, asmName);
    m_pASM = Instance->m_pASM;
  }
  if ( Instance->m_CurState >= (unsigned int)m_pASM->m_NumStates )
  {
    LODWORD(v23) = m_pASM->m_NumStates;
    LODWORD(outParamId) = Instance->m_CurState;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 939, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", outParamId, v23) )
      __debugbreak();
  }
  if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
    __debugbreak();
  frameDuration = level.frameDuration;
  sharp_turn = scr_const.sharp_turn;
  v14 = Ai_Asm::Singleton();
  if ( !Common_Asm::EventFiredWithin(v14, Instance, sharp_turn, frameDuration) )
    return 0;
  v15 = Ai_Asm::Singleton();
  if ( !Ai_Asm::GetEventData(v15, v6->s.number, Instance, scr_const.sharp_turn, &outVar, &intValue) )
    return 0;
  v16 = ScriptContext_Server();
  ArrayVariable = FindArrayVariable(v16, outVar, intValue);
  if ( !ArrayVariable )
    return 0;
  Object = FindObject(v16, ArrayVariable);
  v19 = FindArrayVariable(v16, Object, 2);
  if ( !v19 )
    return 0;
  Scr_EvalVariable_Out(v16, v19, &out);
  if ( out.type != VAR_INTEGER )
  {
    RemoveRefToValue(v16, (unsigned __int8)out.type, out.u);
    return 0;
  }
  v21 = out.u.intValue != 0;
  RemoveRefToValue(v16, 6, out.u);
  return v21;
}

/*
==============
ASM_ShouldSwitchWeapons
==============
*/
bool ASM_ShouldSwitchWeapons(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  const Weapon *v8; 
  AIWrapper v9; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1038, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v9, &g_entities[v4]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1039, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  if ( *(_DWORD *)(v6 + 532) == 14 )
    return 0;
  v8 = m_pAI->GetEquippedWeapon(m_pAI);
  return BG_GetWeaponClass(v8, 0) != *(_DWORD *)(v6 + 532);
}

/*
==============
ASM_ShouldSwitchWeaponsInCover
==============
*/
bool ASM_ShouldSwitchWeaponsInCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  int v7; 
  const Weapon *v8; 
  weapClass_t WeaponClass; 
  bool result; 
  AIWrapper v11; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1051, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v11, &g_entities[v4]);
  m_pAI = v11.m_pAI;
  if ( !v11.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1052, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  v7 = *(_DWORD *)(v6 + 532);
  result = v7 != 14 && (v8 = m_pAI->GetEquippedWeapon(m_pAI), WeaponClass = BG_GetWeaponClass(v8, 0), WeaponClass != *(_DWORD *)(v6 + 532)) && (WeaponClass == WEAPCLASS_RIFLE || WeaponClass == WEAPCLASS_PISTOL) && (!v7 || v7 == 5);
  return result;
}

/*
==============
ASM_ShouldDropRocketLauncher
==============
*/
bool ASM_ShouldDropRocketLauncher(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  const Weapon *v7; 
  int v8; 
  bool result; 
  AIWrapper v10; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v10, &g_entities[v4]);
  m_pAI = v10.m_pAI;
  if ( !v10.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1076, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  v7 = m_pAI->GetEquippedWeapon(m_pAI);
  result = BG_GetWeaponClass(v7, 0) == WEAPCLASS_ROCKETLAUNCHER && (v8 = *(_DWORD *)(v6 + 532), v8 != 14) && v8 != 7;
  return result;
}

/*
==============
ASM_PlayAnim
==============
*/
char ASM_PlayAnim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  __int64 v7; 
  AIScriptedInterface *m_pAI; 
  Ai_Asm *v9; 
  scrContext_t *v10; 
  VariableValue *top; 
  const char *v12; 
  const char *v13; 
  unsigned int v14; 
  scr_string_t AnimsetName; 
  const Animset *v16; 
  const Animset *v17; 
  const char *name; 
  const char *v19; 
  int v20; 
  Ai_Asm *v21; 
  ASM_Instance *Instance; 
  AIScriptedInterface *v23; 
  int entryIndex; 
  AnimsetState *outState; 
  AIWrapper v27; 
  AIWrapper v28; 
  Ai_Asm::ChooseAnimReturnMode m_ChooseAnimReturnMode; 
  int pOutStateIndex; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1176, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v7 = v4;
  AIWrapper::AIWrapper(&v27, &g_entities[v4]);
  m_pAI = v27.m_pAI;
  if ( !v27.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1177, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v9 = Ai_Asm::Singleton();
  m_ChooseAnimReturnMode = v9->m_ChooseAnimReturnMode;
  v9->m_ChooseAnimReturnMode = CODE;
  v10 = ScriptContext_Server();
  top = v10->m_vmPub.top;
  Common_Asm::ChooseAnim(v9, NULL, v4, asmName, toStateName, &entryIndex);
  if ( top != v10->m_vmPub.top )
  {
    v12 = SL_ConvertToString(asmName);
    v13 = SL_ConvertToString(toStateName);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1104, ASSERT_TYPE_ASSERT, "( pPrevTop == scrContext.m_vmPub.top )", "the chooseanim function for %s in ASM %s did not properly return its value with ASM_ReturnAnimID", v13, v12) )
      __debugbreak();
  }
  v9->m_ChooseAnimReturnMode = m_ChooseAnimReturnMode;
  v14 = entryIndex;
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v7].s);
  v16 = Animset_Find(AnimsetName);
  outState = NULL;
  v17 = v16;
  BG_Animset_GetStateInfoByName(v16, toStateName, &outState, &pOutStateIndex);
  if ( !outState )
  {
    name = v17->name;
    v19 = SL_ConvertToString(toStateName);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1187, ASSERT_TYPE_ASSERT, "( pState )", "unable to find state %s in animset %s", v19, name) )
      __debugbreak();
  }
  ((void (__fastcall *)(AIScriptedInterface *, const Animset *, _QWORD, _QWORD, _DWORD))m_pAI->SetAnim)(m_pAI, v17, (unsigned int)pOutStateIndex, v14, LODWORD(FLOAT_1_0));
  v20 = pOutStateIndex;
  v21 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v21, NULL, v4);
  if ( Instance->m_pASM->m_Name == asmName )
  {
    AIWrapper::AIWrapper(&v28, &g_entities[v7]);
    v23 = v28.m_pAI;
    if ( !v28.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1170, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
      __debugbreak();
    AIScriptedInterface::SetFacialIndexFromASM(v23, Instance, v17, v20, v14);
  }
  return 1;
}

/*
==============
ASM_ChooseAnim
==============
*/
char ASM_ChooseAnim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  scr_string_t AnimsetName; 
  scr_string_t StringParam; 
  int IndexOfRandomAnimFromAlias; 
  int v12; 
  const char *v13; 
  const char *v14; 
  __int64 v16; 
  int v18; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 )
  {
    v18 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1202, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v18) )
      __debugbreak();
  }
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v6].s);
  if ( numParams > 0 && (StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams)) != 0 )
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, StringParam);
  else
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromRandomAlias(AnimsetName, toStateName);
  v12 = IndexOfRandomAnimFromAlias;
  if ( IndexOfRandomAnimFromAlias < 0 || IndexOfRandomAnimFromAlias >= BG_Animset_GetNumEntriesForState(AnimsetName, toStateName) )
  {
    v13 = SL_ConvertToString(toStateName);
    v14 = SL_ConvertToString(AnimsetName);
    LODWORD(v16) = v12;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1218, ASSERT_TYPE_ASSERT, "( animIndex >= 0 && animIndex < BG_Animset_GetNumEntriesForState( animsetName, toStateName ) )", "animIndex %d out of range for animset %s state %s", v16, v14, v13) )
      __debugbreak();
  }
  ASM_ReturnAnimID(v12, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_Random
==============
*/
char ASM_ChooseAnim_Random(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  scr_string_t AnimsetName; 
  int IndexOfRandomAnimFromRandomAlias; 
  const char *v10; 
  const char *v11; 
  __int64 v13; 
  int v15; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 )
  {
    v15 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1227, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v15) )
      __debugbreak();
  }
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v6].s);
  IndexOfRandomAnimFromRandomAlias = G_Animset_GetIndexOfRandomAnimFromRandomAlias(AnimsetName, toStateName);
  if ( IndexOfRandomAnimFromRandomAlias < 0 || IndexOfRandomAnimFromRandomAlias >= BG_Animset_GetNumEntriesForState(AnimsetName, toStateName) )
  {
    v10 = SL_ConvertToString(toStateName);
    v11 = SL_ConvertToString(AnimsetName);
    LODWORD(v13) = IndexOfRandomAnimFromRandomAlias;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1233, ASSERT_TYPE_ASSERT, "( animIndex >= 0 && animIndex < BG_Animset_GetNumEntriesForState( animsetName, toStateName ) )", "animIndex %d out of range for animset %s state %s", v13, v11, v10) )
      __debugbreak();
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromRandomAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_IsSuppressed
==============
*/
char ASM_ChooseAnim_IsSuppressed(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  scr_string_t AnimsetName; 
  int IsSuppressed; 
  scr_string_t suppressed; 
  unsigned int IndexOfRandomAnimFromAlias; 
  __int64 v15; 
  __int64 v16; 
  AIWrapper v17; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1242, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v6;
  AIWrapper::AIWrapper(&v17, &g_entities[v8]);
  m_pAI = v17.m_pAI;
  if ( !v17.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1243, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  IsSuppressed = AIScriptedInterface::IsSuppressed(m_pAI);
  suppressed = scr_const.suppressed;
  if ( !IsSuppressed )
    suppressed = scr_const._default;
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, suppressed);
  if ( IndexOfRandomAnimFromAlias >= BG_Animset_GetNumEntriesForState(AnimsetName, toStateName) )
  {
    LODWORD(v16) = BG_Animset_GetNumEntriesForState(AnimsetName, toStateName);
    LODWORD(v15) = IndexOfRandomAnimFromAlias;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1253, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( BG_Animset_GetNumEntriesForState( animsetName, toStateName ) )", "animIndex doesn't index BG_Animset_GetNumEntriesForState( animsetName, toStateName )\n\t%i not in [0, %i)", v15, v16) )
      __debugbreak();
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_WeaponClass
==============
*/
char ASM_ChooseAnim_WeaponClass(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  scrContext_t *v10; 
  const Weapon *v11; 
  weapClass_t WeaponClass; 
  const char *WeaponClassName; 
  scr_string_t AnimsetName; 
  scr_string_t v15; 
  int IndexOfRandomAnimFromAlias; 
  const char *v17; 
  const char *v18; 
  const char *v19; 
  AnimsetAlias *outAlias; 
  AIWrapper v22; 
  scr_string_t aliasName; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1371, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v6;
  AIWrapper::AIWrapper(&v22, &g_entities[v6]);
  m_pAI = v22.m_pAI;
  if ( !v22.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1372, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v10 = ScriptContext_Server();
  v11 = m_pAI->GetEquippedWeapon(m_pAI);
  WeaponClass = BG_GetWeaponClass(v11, 0);
  WeaponClassName = BG_GetWeaponClassName(WeaponClass);
  aliasName = SL_GetString(WeaponClassName, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  outAlias = NULL;
  v15 = AnimsetName;
  if ( !BG_Animset_GetCompleteAliasInfo(AnimsetName, toStateName, aliasName, &outAlias) )
    Scr_SetString(&aliasName, scr_const.rifle);
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v15, toStateName, aliasName);
  Scr_SetString(&aliasName, (scr_string_t)0);
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    v17 = SL_ConvertToString(toStateName);
    v18 = SL_ConvertToString(v15);
    v19 = j_va("Animset %s state %s - unable to find alias %s", v18, v17, WeaponClassName);
    Scr_Error(COM_ERR_2448, v10, v19);
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_WeaponClassPrepended
==============
*/
char ASM_ChooseAnim_WeaponClassPrepended(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v7; 
  __int64 v9; 
  AIScriptedInterface *m_pAI; 
  AIScriptedInterface *v11; 
  ASM_Function_Param *v12; 
  AIScriptedInterface_vtbl *v13; 
  const Weapon *v14; 
  weapClass_t v15; 
  const char *v16; 
  scr_string_t v17; 
  scr_string_t v18; 
  int IndexOfRandomAnimFromAlias; 
  const char *v20; 
  const char *v21; 
  const char *v22; 
  ASM_Function_Param *v23; 
  ComErrorCode v24; 
  scrContext_t *v25; 
  AIScriptedInterface_vtbl *v26; 
  const Weapon *v27; 
  weapClass_t WeaponClass; 
  const char *WeaponClassName; 
  scr_string_t StringParam; 
  const char *v31; 
  scr_string_t AnimsetName; 
  __int64 v33; 
  scr_string_t v34; 
  __int64 v35; 
  bool v36; 
  const char *v37; 
  const char *v38; 
  const char *v39; 
  scrContext_t *v40; 
  scr_string_t String; 
  const char *v42; 
  const char *v43; 
  __int64 v45; 
  __int64 v46; 
  scr_string_t stringValue; 
  scr_string_t aliasName[2]; 
  ASM_Function_Param *v49; 
  AnimsetAlias *outAlias; 
  AnimsetAlias *v51; 
  AIWrapper v52; 
  AIWrapper v53; 
  char dest[128]; 

  v7 = entNum;
  v49 = pParams;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1401, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v9 = v7;
  AIWrapper::AIWrapper(&v52, &g_entities[v7]);
  m_pAI = v52.m_pAI;
  if ( !v52.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1402, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( numParams )
  {
    v25 = ScriptContext_Server();
    v26 = m_pAI->__vftable;
    *(_QWORD *)aliasName = v25;
    v27 = v26->GetEquippedWeapon(m_pAI);
    WeaponClass = BG_GetWeaponClass(v27, 0);
    WeaponClassName = BG_GetWeaponClassName(WeaponClass);
    StringParam = ASM_Builtin_GetStringParam(0, v49, numParams);
    v31 = SL_ConvertToString(StringParam);
    AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v9].s);
    v33 = -1i64;
    v34 = AnimsetName;
    v35 = -1i64;
    do
      v36 = v31[++v35] == 0;
    while ( !v36 );
    do
      v36 = WeaponClassName[++v33] == 0;
    while ( !v36 );
    if ( (unsigned __int64)(v35 + v33 + 1) < 0x80 )
    {
      v40 = *(scrContext_t **)aliasName;
    }
    else
    {
      v37 = SL_ConvertToString(toStateName);
      v38 = SL_ConvertToString(v34);
      LODWORD(v45) = 128;
      v39 = j_va("Animset %s state %s - alias name %s_%s exceeds max allowed length %d", v38, v37, WeaponClassName, v31, v45);
      v40 = *(scrContext_t **)aliasName;
      Scr_Error(COM_ERR_2449, *(scrContext_t **)aliasName, v39);
    }
    Com_sprintf_truncate(dest, 0x80ui64, "%s%s", WeaponClassName, v31);
    stringValue = SL_GetString(dest, 0);
    v51 = NULL;
    if ( BG_Animset_GetCompleteAliasInfo(v34, toStateName, stringValue, &v51) )
    {
      String = stringValue;
    }
    else
    {
      Com_sprintf_truncate(dest, 0x80ui64, "rifle%s", v31);
      SL_RemoveRefToString(stringValue);
      String = SL_GetString(dest, 0);
      stringValue = String;
    }
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v34, toStateName, String);
    Scr_SetString(&stringValue, (scr_string_t)0);
    if ( IndexOfRandomAnimFromAlias < 0 )
    {
      v42 = SL_ConvertToString(toStateName);
      v43 = SL_ConvertToString(v34);
      v22 = j_va("Animset %s state %s - unable to find alias %s", v43, v42, dest);
      v23 = (ASM_Function_Param *)v40;
      v24 = COM_ERR_2450;
      goto LABEL_29;
    }
  }
  else
  {
    if ( (unsigned int)v7 >= 0x800 )
    {
      LODWORD(v46) = 2048;
      LODWORD(v45) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1371, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v45, v46) )
        __debugbreak();
    }
    AIWrapper::AIWrapper(&v53, &g_entities[v9]);
    v11 = v53.m_pAI;
    if ( !v53.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1372, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
      __debugbreak();
    v12 = (ASM_Function_Param *)ScriptContext_Server();
    v13 = v11->__vftable;
    v49 = v12;
    v14 = v13->GetEquippedWeapon(v11);
    v15 = BG_GetWeaponClass(v14, 0);
    v16 = BG_GetWeaponClassName(v15);
    aliasName[0] = SL_GetString(v16, 0);
    v17 = BG_AnimationState_GetAnimsetName(&g_entities[v9].s);
    outAlias = NULL;
    v18 = v17;
    if ( !BG_Animset_GetCompleteAliasInfo(v17, toStateName, aliasName[0], &outAlias) )
      Scr_SetString(aliasName, scr_const.rifle);
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v18, toStateName, aliasName[0]);
    Scr_SetString(aliasName, (scr_string_t)0);
    if ( IndexOfRandomAnimFromAlias < 0 )
    {
      v20 = SL_ConvertToString(toStateName);
      v21 = SL_ConvertToString(v18);
      v22 = j_va("Animset %s state %s - unable to find alias %s", v21, v20, v16);
      v23 = v49;
      v24 = COM_ERR_2448;
LABEL_29:
      Scr_Error(v24, (scrContext_t *)v23, v22);
    }
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_BurstCount
==============
*/
char ASM_ChooseAnim_BurstCount(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v7; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  __int64 v10; 
  scrContext_t *v11; 
  unsigned int v12; 
  scr_string_t AnimsetName; 
  int IndexOfRandomAnimFromAlias; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  scr_string_t to[4]; 
  AIWrapper v20; 
  char dest[8]; 

  v7 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1452, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v7;
  AIWrapper::AIWrapper(&v20, &g_entities[v7]);
  m_pAI = v20.m_pAI;
  if ( !v20.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1453, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v10 = m_pAI->GetAI(m_pAI);
  to[0] = 0;
  v11 = ScriptContext_Server();
  v12 = *(unsigned __int8 *)(v10 + 522);
  if ( v12 == 1 )
  {
    Scr_SetString(to, scr_const.single);
  }
  else
  {
    Com_sprintf(dest, 8ui64, "%d", *(unsigned __int8 *)(v10 + 522));
    to[0] = SL_GetString(dest, 0);
  }
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, to[0]);
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    Scr_SetString(to, scr_const.fire);
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, to[0]);
  }
  Scr_SetString(to, (scr_string_t)0);
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    v15 = SL_ConvertToString(toStateName);
    v16 = SL_ConvertToString(AnimsetName);
    v17 = j_va("Animset %s state %s - unable to find appropriate shoot anim for %d shots", v16, v15, v12);
    Scr_Error(COM_ERR_2451, v11, v17);
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_WeaponSwitch
==============
*/
char ASM_ChooseAnim_WeaponSwitch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  __int64 v10; 
  scrContext_t *v11; 
  scr_string_t AnimsetName; 
  const Animset *v13; 
  const Weapon *v14; 
  scr_string_t name; 
  int v16; 
  const Weapon *Weapon; 
  const char *WeaponClassName; 
  scr_string_t String; 
  int IndexOfRandomAnimFromAlias; 
  const char *v22; 
  const char *v23; 
  AnimsetState *outState; 
  AnimsetAlias *outAlias; 
  AIWrapper v26; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1492, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v6;
  AIWrapper::AIWrapper(&v26, &g_entities[v8]);
  m_pAI = v26.m_pAI;
  if ( !v26.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1493, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v10 = m_pAI->GetAI(m_pAI);
  v11 = ScriptContext_Server();
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  outState = NULL;
  v13 = Animset_Find(AnimsetName);
  if ( BG_Animset_GetStateInfoByName(v13, toStateName, &outState, NULL) )
  {
    if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1507, ASSERT_TYPE_ASSERT, "(pState)", (const char *)&queryFormat, "pState") )
      __debugbreak();
    outAlias = NULL;
    v14 = m_pAI->GetEquippedWeapon(m_pAI);
    if ( BG_GetWeaponClass(v14, 0) == WEAPCLASS_ROCKETLAUNCHER && (*(_DWORD *)(v10 + 532) == 5 && BG_Animset_GetCompleteAliasInfo(v13, outState, (const scr_string_t)scr_const.drop_rpg_pistol, &outAlias) || BG_Animset_GetCompleteAliasInfo(v13, outState, (const scr_string_t)scr_const.drop_rpg, &outAlias)) || (Weapon = GScr_Weapon_GetWeapon(v11, (const scr_weapon_t)*(_DWORD *)(v10 + 1160)), Weapon->weaponIdx) && BG_GetWeaponType(Weapon, 0) == WEAPTYPE_RIOTSHIELD && BG_Animset_GetCompleteAliasInfo(v13, outState, (const scr_string_t)scr_const.drop_shield, &outAlias) )
    {
      name = outAlias->name;
    }
    else
    {
      WeaponClassName = BG_GetWeaponClassName((weapClass_t)*(_DWORD *)(v10 + 532));
      String = SL_GetString(WeaponClassName, 0);
      if ( BG_Animset_GetCompleteAliasInfo(v13, outState, String, &outAlias) )
      {
        IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v13, outState, String);
        SL_RemoveRefToString(String);
        ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
        return 1;
      }
      if ( !BG_Animset_GetCompleteAliasInfo(v13, outState, (const scr_string_t)scr_const.rifle, &outAlias) )
      {
        if ( Ai_Asm::Singleton()->m_ChooseAnimReturnMode == SCRIPT )
        {
          v22 = SL_ConvertToString(toStateName);
          v23 = j_va("State %s does not have default (rifle) anim", v22);
          Scr_Error(COM_ERR_5957, v11, v23);
        }
        if ( Ai_Asm::Singleton()->m_ChooseAnimReturnMode == CODE )
        {
          if ( !pOutValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1132, ASSERT_TYPE_ASSERT, "(pOutValue)", (const char *)&queryFormat, "pOutValue") )
            __debugbreak();
          *(_DWORD *)pOutValue = -12345;
        }
        return 0;
      }
      name = scr_const.rifle;
    }
    v16 = G_Animset_GetIndexOfRandomAnimFromAlias(v13, outState, name);
    ASM_ReturnAnimID(v16, pOutValue);
    return 1;
  }
  ASM_ReturnAnimIDUndefined(pOutValue);
  return 0;
}

/*
==============
ASM_ChooseAnim_ExposedReload
==============
*/
char ASM_ChooseAnim_ExposedReload(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v7; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  scrContext_t *v10; 
  const char *v11; 
  const char *ReloadWeapClass; 
  __int64 v13; 
  __int64 v14; 
  __int16 v15; 
  scr_string_t AnimsetName; 
  scr_string_t v17; 
  int IndexOfRandomAnimFromAlias; 
  const char *v19; 
  const char *v20; 
  const char *v21; 
  scr_string_t aliasName; 
  AnimsetAlias *outAlias; 
  AIWrapper v25; 
  char dest[128]; 

  v7 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1284, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v7;
  AIWrapper::AIWrapper(&v25, &g_entities[v7]);
  m_pAI = v25.m_pAI;
  if ( !v25.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1285, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v10 = ScriptContext_Server();
  v11 = (char *)&queryFormat.fmt + 3;
  ReloadWeapClass = ChooseAnim_GetReloadWeapClass(m_pAI);
  v13 = m_pAI->GetAI(m_pAI);
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1293, ASSERT_TYPE_ASSERT, "( pScripted )", (const char *)&queryFormat, "pScripted") )
    __debugbreak();
  v14 = *(_QWORD *)(*(_QWORD *)(v13 + 8) + 112i64);
  if ( v14 )
  {
    v15 = *(_WORD *)(v14 + 82);
    if ( v15 == 31 )
      v15 = *(_WORD *)(v14 + 118);
    if ( v15 == 2 && ((*(_DWORD *)v14 & 0x200) == 0 || (*(_DWORD *)v14 & 4) != 0) )
      v11 = "_high";
  }
  Com_sprintf(dest, 0x80ui64, "%s%s", ReloadWeapClass, v11);
  aliasName = SL_GetString(dest, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  outAlias = NULL;
  v17 = AnimsetName;
  if ( !BG_Animset_GetCompleteAliasInfo(AnimsetName, toStateName, aliasName, &outAlias) )
  {
    if ( !*v11 || (Scr_SetStringFromCharString(&aliasName, ReloadWeapClass), !BG_Animset_GetCompleteAliasInfo(v17, toStateName, aliasName, &outAlias)) )
      Scr_SetString(&aliasName, scr_const.rifle);
  }
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v17, toStateName, aliasName);
  Scr_SetString(&aliasName, (scr_string_t)0);
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    v19 = SL_ConvertToString(toStateName);
    v20 = SL_ConvertToString(v17);
    v21 = j_va("Animset %s state %s - unable to find alias %s", v20, v19, ReloadWeapClass);
    Scr_Error(COM_ERR_6054, v10, v21);
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ChooseAnim_WeaponClass_Reload
==============
*/
char ASM_ChooseAnim_WeaponClass_Reload(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  __int64 v6; 
  __int64 v8; 
  AIScriptedInterface *m_pAI; 
  scrContext_t *v10; 
  const char *ReloadWeapClass; 
  scr_string_t AnimsetName; 
  scr_string_t v13; 
  int IndexOfRandomAnimFromAlias; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  AnimsetAlias *outAlias; 
  AIWrapper v20; 
  scr_string_t aliasName; 

  v6 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1343, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v8 = v6;
  AIWrapper::AIWrapper(&v20, &g_entities[v8]);
  m_pAI = v20.m_pAI;
  if ( !v20.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1344, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v10 = ScriptContext_Server();
  ReloadWeapClass = ChooseAnim_GetReloadWeapClass(m_pAI);
  aliasName = SL_GetString(ReloadWeapClass, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName(&g_entities[v8].s);
  outAlias = NULL;
  v13 = AnimsetName;
  if ( !BG_Animset_GetCompleteAliasInfo(AnimsetName, toStateName, aliasName, &outAlias) )
    Scr_SetString(&aliasName, scr_const.rifle);
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(v13, toStateName, aliasName);
  Scr_SetString(&aliasName, (scr_string_t)0);
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    v15 = SL_ConvertToString(toStateName);
    v16 = SL_ConvertToString(v13);
    v17 = j_va("Animset %s state %s - unable to find alias %s", v16, v15, ReloadWeapClass);
    Scr_Error(COM_ERR_6055, v10, v17);
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ShootStyleSingle
==============
*/
bool ASM_ShootStyleSingle(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIWrapper v5; 

  AIWrapper::AIWrapper(&v5, &g_entities[entNum]);
  return *(_BYTE *)((__int64)v5.m_pAI->GetAI(v5.m_pAI) + 522) == 1;
}

/*
==============
ASM_ShootStyleFull
==============
*/
bool ASM_ShootStyleFull(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  char v4; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  v4 = *(_BYTE *)((__int64)v6.m_pAI->GetAI(v6.m_pAI) + 521);
  return v4 == 4 || v4 == 1;
}

/*
==============
ASM_ShootStyleMG
==============
*/
bool ASM_ShootStyleMG(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIWrapper v5; 

  AIWrapper::AIWrapper(&v5, &g_entities[entNum]);
  return *(_BYTE *)((__int64)v5.m_pAI->GetAI(v5.m_pAI) + 521) == 5;
}

/*
==============
ASM_ShootUpdateParams
==============
*/
char ASM_ShootUpdateParams(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  _BYTE *v6; 
  const char *v7; 
  scrContext_t *v8; 
  bool v9; 
  AIWrapper v11; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 711, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v11, &g_entities[v4]);
  m_pAI = v11.m_pAI;
  if ( !v11.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 712, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = (_BYTE *)m_pAI->GetAI(m_pAI);
  if ( !v6[529] )
  {
    v7 = j_va("ShootUpdateParams: ent %d shootparams invalid", (unsigned int)v4);
    v8 = ScriptContext_Server();
    Scr_Error(COM_ERR_2447, v8, v7);
  }
  v9 = v6[524] == 0;
  v6[519] = v6[518];
  if ( v9 )
    v6[524] = v6[523];
  ChooseShootStyle(m_pAI);
  v6[522] = ChooseNumShotsPerBurst(m_pAI);
  return 1;
}

/*
==============
ASM_ShootParamsChanged
==============
*/
bool ASM_ShootParamsChanged(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  _BYTE *v6; 
  AIWrapper v8; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 734, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v8, &g_entities[v4]);
  m_pAI = v8.m_pAI;
  if ( !v8.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 735, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = (_BYTE *)m_pAI->GetAI(m_pAI);
  return !v6[529] || !AIScriptedInterface::IsSniper(m_pAI, 1) && (v6[518] != v6[519] || !v6[571]);
}

/*
==============
ASM_ShouldBeginFiring
==============
*/
bool ASM_ShouldBeginFiring(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v7; 
  Ai_Asm *v9; 
  const ASM_Instance *Instance; 
  AIWrapper v11; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 758, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v11, &g_entities[v4]);
  m_pAI = v11.m_pAI;
  if ( !v11.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 759, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v7 = m_pAI->GetAI(m_pAI);
  if ( !*(_BYTE *)(v7 + 571) )
    return 0;
  if ( *(_BYTE *)(v7 + 573) )
    return 1;
  v9 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v9, NULL, v4);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 769, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name != asmName )
  {
    Instance = Common_Asm::Utils::GetSubtree(Instance, asmName);
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 774, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
      __debugbreak();
  }
  return Common_Asm::Utils::EventFired(Instance, (const scr_string_t)scr_const.burst_delay_finished);
}

/*
==============
ASM_PlayAnim_ShootFire_Cleanup
==============
*/
char ASM_PlayAnim_ShootFire_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  gentity_s *v6; 
  AIScriptedInterface *m_pAI; 
  ai_agent_t *ScriptedAgentInfo; 
  int number; 
  Ai_Asm *v10; 
  const ASM_Instance *Instance; 
  ASM_Instance *Subtree; 
  const char *v13; 
  scr_string_t AnimsetName; 
  scr_string_t m_Name; 
  int IndexOfRandomAnimFromAlias; 
  int v17; 
  const char *v18; 
  const char *v19; 
  XAnimTree *EntAnimTree; 
  XAnimSubTreeID *pOutAnimSubtreeID; 
  XAnimCurveID *pOutAnimCurveID; 
  XAnimSubTreeID v24[2]; 
  int pOutStateIndex; 
  unsigned int pOutAnimIndex; 
  unsigned int pOutGraftNode; 
  AnimsetState *outState; 
  AIAgentInterface v29; 
  AIAgentInterface *v30; 
  AIWrapper v31; 
  XAnimCurveID v32; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1565, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v6 = &g_entities[v4];
  AIWrapper::AIWrapper(&v31, v6);
  m_pAI = v31.m_pAI;
  if ( !v31.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1569, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  AIScriptedInterface::Shoot_StopSound(m_pAI);
  AIScriptedInterface::ClearShootStyleAdditive(m_pAI);
  AIAgentInterface::AIAgentInterface(&v29);
  v29.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v30 = NULL;
  if ( SV_IsAgentScripted(v6) )
  {
    ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(v6);
    if ( ScriptedAgentInfo )
    {
      v30 = &v29;
      AINewAgentInterface::SetAgent((AINewAgentInterface *)&v29, ScriptedAgentInfo);
    }
  }
  if ( !v30 )
  {
    number = v6->s.number;
    v10 = Ai_Asm::Singleton();
    Instance = Ai_Asm::GetInstance(v10, NULL, number);
    Subtree = (ASM_Instance *)Instance;
    if ( Instance->m_pASM->m_Name != asmName )
      Subtree = Common_Asm::Utils::GetSubtree(Instance, asmName);
    if ( !Subtree )
    {
      v13 = SL_ConvertToString(asmName);
      LODWORD(pOutAnimCurveID) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1581, ASSERT_TYPE_ASSERT, "( pInst )", "Unable to find asm %s for ent %d", v13, pOutAnimCurveID) )
        __debugbreak();
    }
    AnimsetName = BG_AnimationState_GetAnimsetName(&v6->s);
    if ( Subtree->m_CurState >= (unsigned int)Subtree->m_pASM->m_NumStates )
    {
      LODWORD(pOutAnimCurveID) = Subtree->m_pASM->m_NumStates;
      LODWORD(pOutAnimSubtreeID) = Subtree->m_CurState;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1584, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", pOutAnimSubtreeID, pOutAnimCurveID) )
        __debugbreak();
    }
    m_Name = Subtree->m_pASM->m_States[Subtree->m_CurState].m_Name;
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, m_Name, (const scr_string_t)scr_const.add_fire);
    outState = NULL;
    v17 = IndexOfRandomAnimFromAlias;
    BG_Animset_GetStateInfoByName(AnimsetName, m_Name, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v18 = SL_ConvertToString(AnimsetName);
      v19 = SL_ConvertToString(m_Name);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1591, ASSERT_TYPE_ASSERT, "( pState )", "Unable to find state %s in animset %s", v19, v18) )
        __debugbreak();
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, v17, &pOutAnimIndex, &pOutGraftNode, v24, &v32);
    EntAnimTree = GScr_GetEntAnimTree(v6);
    XAnimClearTreeGoalWeights(EntAnimTree, pOutGraftNode, v24[0], pOutAnimIndex, 0.2, 0, NULL, LINEAR);
  }
  return 1;
}

/*
==============
ASM_PlayAnim_ShootIdle_Cleanup
==============
*/
char ASM_PlayAnim_ShootIdle_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int64 v4; 
  gentity_s *v6; 
  AIScriptedInterface *m_pAI; 
  ai_agent_t *ScriptedAgentInfo; 
  int number; 
  Ai_Asm *v10; 
  const ASM_Instance *Instance; 
  ASM_Instance *Subtree; 
  const char *v13; 
  scr_string_t AnimsetName; 
  scr_string_t m_Name; 
  int IndexOfRandomAnimFromAlias; 
  int v17; 
  const char *v18; 
  const char *v19; 
  XAnimTree *EntAnimTree; 
  XAnimSubTreeID *pOutAnimSubtreeID; 
  XAnimCurveID *pOutAnimCurveID; 
  XAnimSubTreeID v24[2]; 
  int pOutStateIndex; 
  unsigned int pOutAnimIndex; 
  unsigned int pOutGraftNode; 
  AnimsetState *outState; 
  AIAgentInterface v29; 
  AIAgentInterface *v30; 
  AIWrapper v31; 
  XAnimCurveID v32; 

  v4 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1607, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  v6 = &g_entities[v4];
  AIWrapper::AIWrapper(&v31, v6);
  m_pAI = v31.m_pAI;
  if ( !v31.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1611, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  AIScriptedInterface::Shoot_StopSound(m_pAI);
  AIScriptedInterface::ClearShootStyleAdditive(m_pAI);
  AIAgentInterface::AIAgentInterface(&v29);
  v29.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v30 = NULL;
  if ( SV_IsAgentScripted(v6) )
  {
    ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(v6);
    if ( ScriptedAgentInfo )
    {
      v30 = &v29;
      AINewAgentInterface::SetAgent((AINewAgentInterface *)&v29, ScriptedAgentInfo);
    }
  }
  if ( !v30 )
  {
    number = v6->s.number;
    v10 = Ai_Asm::Singleton();
    Instance = Ai_Asm::GetInstance(v10, NULL, number);
    Subtree = (ASM_Instance *)Instance;
    if ( Instance->m_pASM->m_Name != asmName )
      Subtree = Common_Asm::Utils::GetSubtree(Instance, asmName);
    if ( !Subtree )
    {
      v13 = SL_ConvertToString(asmName);
      LODWORD(pOutAnimCurveID) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1623, ASSERT_TYPE_ASSERT, "( pInst )", "Unable to find asm %s for ent %d", v13, pOutAnimCurveID) )
        __debugbreak();
    }
    AnimsetName = BG_AnimationState_GetAnimsetName(&v6->s);
    if ( Subtree->m_CurState >= (unsigned int)Subtree->m_pASM->m_NumStates )
    {
      LODWORD(pOutAnimCurveID) = Subtree->m_pASM->m_NumStates;
      LODWORD(pOutAnimSubtreeID) = Subtree->m_CurState;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1626, ASSERT_TYPE_ASSERT, "(unsigned)( pInst->m_CurState ) < (unsigned)( pInst->m_pASM->m_NumStates )", "pInst->m_CurState doesn't index pInst->m_pASM->m_NumStates\n\t%i not in [0, %i)", pOutAnimSubtreeID, pOutAnimCurveID) )
        __debugbreak();
    }
    m_Name = Subtree->m_pASM->m_States[Subtree->m_CurState].m_Name;
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, m_Name, (const scr_string_t)scr_const.add_idle);
    outState = NULL;
    v17 = IndexOfRandomAnimFromAlias;
    BG_Animset_GetStateInfoByName(AnimsetName, m_Name, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v18 = SL_ConvertToString(AnimsetName);
      v19 = SL_ConvertToString(m_Name);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1633, ASSERT_TYPE_ASSERT, "( pState )", "Unable to find state %s in animset %s", v19, v18) )
        __debugbreak();
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, v17, &pOutAnimIndex, &pOutGraftNode, v24, &v32);
    EntAnimTree = GScr_GetEntAnimTree(v6);
    XAnimClearTreeGoalWeights(EntAnimTree, pOutGraftNode, v24[0], pOutAnimIndex, 0.2, 0, NULL, LINEAR);
  }
  return 1;
}

/*
==============
ASM_PlayMoveLoop_CodeBlend_Cleanup
==============
*/
char ASM_PlayMoveLoop_CodeBlend_Cleanup(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1651, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  *(_BYTE *)(m_pAI->GetAI(m_pAI) + 2910) = 0;
  return 1;
}

/*
==============
ASM_CheckArrivalType
==============
*/
bool ASM_CheckArrivalType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1662, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v7 = m_pAI->GetAI(m_pAI);
  return ASM_Builtin_GetStringParam(0, pParams, numParams) == *(_DWORD *)(v7 + 536);
}

/*
==============
ASM_CleanupCalcArrivalType
==============
*/
char ASM_CleanupCalcArrivalType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v5; 
  AIWrapper v7; 

  AIWrapper::AIWrapper(&v7, &g_entities[entNum]);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1674, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v5 = m_pAI->GetAI(m_pAI);
  Scr_SetString((scr_string_t *)(v5 + 536), (scr_string_t)0);
  return 1;
}

/*
==============
ASM_HasTraversalWithin
==============
*/
__int64 ASM_HasTraversalWithin(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  const gentity_s *v7; 
  AINavigator *Navigator; 
  __int64 v10; 

  v7 = &g_entities[entNum];
  if ( !pParams && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 357, ASSERT_TYPE_ASSERT, "(pParams)", (const char *)&queryFormat, "pParams") )
    __debugbreak();
  if ( !numParams )
  {
    LODWORD(v10) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 358, ASSERT_TYPE_ASSERT, "(unsigned)( iParam ) < (unsigned)( numParams )", "iParam doesn't index numParams\n\t%i not in [0, %i)", v10, 0) )
      __debugbreak();
  }
  if ( (unsigned int)(pParams->m_Type - 3) > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 359, ASSERT_TYPE_ASSERT, "(pParams[ iParam ].m_Type == ParamType_Int || pParams[ iParam ].m_Type == ParamType_Float)", (const char *)&queryFormat, "pParams[ iParam ].m_Type == ParamType_Int || pParams[ iParam ].m_Type == ParamType_Float") )
    __debugbreak();
  Navigator = Nav_GetNavigator(v7);
  return ((__int64 (__fastcall *)(AINavigator *))Navigator->HasTraversalWithin)(Navigator);
}

/*
==============
ASM_IsCoverCrouch
==============
*/
bool ASM_IsCoverCrouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  AIWrapper v8; 

  AIWrapper::AIWrapper(&v8, &g_entities[entNum]);
  m_pAI = v8.m_pAI;
  if ( !v8.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1696, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  return ((type - 3) & 0xFFF6) == 0 && type != 12;
}

/*
==============
ASM_IsCoverStand
==============
*/
bool ASM_IsCoverStand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  pathnode_t *v6; 
  AIWrapper v8; 

  AIWrapper::AIWrapper(&v8, &g_entities[entNum]);
  m_pAI = v8.m_pAI;
  if ( !v8.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1710, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  v6 = CoverNode;
  if ( CoverNode )
  {
    LOWORD(CoverNode) = CoverNode->constant.type;
    if ( (_WORD)CoverNode == 31 )
      LOWORD(CoverNode) = v6->dynamic.turretEntNumber;
    LOBYTE(CoverNode) = (((_WORD)CoverNode - 2) & 0xFFF7) == 0;
  }
  return (char)CoverNode;
}

/*
==============
ASM_IsCoverRight_Crouch
==============
*/
bool ASM_IsCoverRight_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1724, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  v7 = m_pAI->GetAI(m_pAI);
  return type == 6 && *(_DWORD *)(v7 + 1728) == 2;
}

/*
==============
ASM_IsCoverRight_Stand
==============
*/
bool ASM_IsCoverRight_Stand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1740, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  v7 = m_pAI->GetAI(m_pAI);
  return type == 6 && *(_DWORD *)(v7 + 1728) == 1;
}

/*
==============
ASM_IsCoverLeft_Crouch
==============
*/
bool ASM_IsCoverLeft_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1756, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  v7 = m_pAI->GetAI(m_pAI);
  return type == 7 && *(_DWORD *)(v7 + 1728) == 2;
}

/*
==============
ASM_IsCoverLeft_Stand
==============
*/
bool ASM_IsCoverLeft_Stand(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1772, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  v7 = m_pAI->GetAI(m_pAI);
  return type == 7 && *(_DWORD *)(v7 + 1728) == 1;
}

/*
==============
ASM_IsExposed_Crouch
==============
*/
bool ASM_IsExposed_Crouch(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  pathnode_t *CoverNode; 
  __int16 type; 
  __int64 v7; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1788, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( !CoverNode )
    return 0;
  type = CoverNode->constant.type;
  if ( type == 31 )
    type = CoverNode->dynamic.turretEntNumber;
  v7 = m_pAI->GetAI(m_pAI);
  return type == 9 && *(_DWORD *)(v7 + 1728) == 2;
}

/*
==============
ASM_ShouldSnapToCover
==============
*/
bool ASM_ShouldSnapToCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v5; 
  int v6; 
  const pathnode_t *CoverNode; 
  __int64 v8; 
  bool result; 
  AIWrapper v10; 

  AIWrapper::AIWrapper(&v10, &g_entities[entNum]);
  m_pAI = v10.m_pAI;
  if ( !v10.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1805, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v5 = m_pAI->GetAI(m_pAI);
  v6 = level.time - 3000;
  if ( level.time - 3000 < 0 )
    v6 = 0;
  result = 0;
  if ( *(_DWORD *)(v5 + 1552) <= v6 && !m_pAI->IsCodeMoveRequested(m_pAI) )
  {
    CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
    if ( CoverNode )
    {
      v8 = (__int64)m_pAI->GetSentient(m_pAI);
      if ( v8 )
      {
        if ( *(_QWORD *)(v8 + 112) && AIScriptedInterface::Cover_IsValidAgainstEnemy(m_pAI, CoverNode, 1) )
          return 1;
      }
    }
  }
  return result;
}

/*
==============
ASM_ShouldSnapToCoverWhileMoving
==============
*/
bool ASM_ShouldSnapToCoverWhileMoving(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v5; 
  __int64 v6; 
  bool result; 
  AIWrapper v8; 

  AIWrapper::AIWrapper(&v8, &g_entities[entNum]);
  m_pAI = v8.m_pAI;
  if ( !v8.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1833, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v5 = m_pAI->GetAI(m_pAI);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1836, ASSERT_TYPE_ASSERT, "(pScripted)", (const char *)&queryFormat, "pScripted") )
    __debugbreak();
  result = 0;
  if ( *(_BYTE *)(v5 + 1835) == 1 )
  {
    if ( AIScriptedInterface::GetCoverNode(m_pAI) )
    {
      v6 = (__int64)m_pAI->GetSentient(m_pAI);
      if ( v6 )
      {
        if ( *(_QWORD *)(v6 + 112) )
          return 1;
      }
    }
  }
  return result;
}

/*
==============
ASM_HasShuffleNode
==============
*/

bool __fastcall ASM_HasShuffleNode(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  return HasShuffleNode(entNum);
}

/*
==============
ASM_HasShuffleNodeInDir
==============
*/
bool ASM_HasShuffleNodeInDir(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIScriptedInterface *m_pAI; 
  const pathnode_t **v7; 
  const pathnode_t *v8; 
  unsigned __int16 v9; 
  scr_string_t StringParam; 
  AIWrapper v12; 

  AIWrapper::AIWrapper(&v12, &g_entities[entNum]);
  m_pAI = v12.m_pAI;
  if ( !v12.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1913, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v7 = (const pathnode_t **)m_pAI->GetAI(m_pAI);
  if ( numParams <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1916, ASSERT_TYPE_ASSERT, "( numParams > 0 )", "HasShuffleNodeInDir missing arg - must be provided with direction.") )
    __debugbreak();
  v8 = v7[68];
  if ( !v8 )
    return 0;
  v9 = Path_ConvertNodeToIndex(v7[68]);
  if ( !Path_NodeValid(v9) )
    return 0;
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  return IsShuffleNodeInDir((const vec3_t *)&(*v7)[1].dynamic.iValidTime[2], v8, StringParam);
}

/*
==============
ASM_HasDoorShuffleNodeInDir
==============
*/
char ASM_HasDoorShuffleNodeInDir(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIScriptedInterface *m_pAI; 
  const pathnode_t **v7; 
  pathnode_t *CoverNode; 
  const pathnode_t *v9; 
  unsigned __int16 v10; 
  scr_string_t StringParam; 
  __int16 type; 
  __int16 turretEntNumber; 
  AIWrapper v15; 

  AIWrapper::AIWrapper(&v15, &g_entities[entNum]);
  m_pAI = v15.m_pAI;
  if ( !v15.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1935, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v7 = (const pathnode_t **)m_pAI->GetAI(m_pAI);
  if ( numParams <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1938, ASSERT_TYPE_ASSERT, "( numParams > 0 )", "HasShuffleNodeInDir missing arg - must be provided with direction.") )
    __debugbreak();
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  if ( CoverNode || (CoverNode = AIScriptedInterface::GetPrevCoverNode(m_pAI)) != NULL )
  {
    v9 = v7[68];
    if ( v9 )
    {
      v10 = Path_ConvertNodeToIndex(v7[68]);
      if ( Path_NodeValid(v10) )
      {
        StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
        if ( IsShuffleNodeInDir((const vec3_t *)&(*v7)[1].dynamic.iValidTime[2], v9, StringParam) )
        {
          type = CoverNode->constant.type;
          if ( type == 31 )
            type = CoverNode->dynamic.turretEntNumber;
          turretEntNumber = v9->constant.type;
          if ( turretEntNumber == 31 )
            turretEntNumber = v9->dynamic.turretEntNumber;
          if ( StringParam == scr_const.right )
          {
            if ( type == 6 && turretEntNumber == 7 )
              return 1;
          }
          else if ( type == 7 && turretEntNumber == 6 )
          {
            return 1;
          }
        }
      }
    }
  }
  return 0;
}

/*
==============
ASM_HasShuffleNodeOfType
==============
*/
bool ASM_HasShuffleNodeOfType(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v7; 
  pathnode_t *v8; 
  pathnode_t *v9; 
  scr_string_t StringParam; 
  const char *v11; 
  unsigned __int16 type; 
  AIWrapper v14; 
  vec3_t v15; 
  vec3_t pos; 

  AIWrapper::AIWrapper(&v14, &g_entities[entNum]);
  m_pAI = v14.m_pAI;
  if ( !v14.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1972, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v7 = m_pAI->GetAI(m_pAI);
  if ( numParams <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1975, ASSERT_TYPE_ASSERT, "( numParams > 0 )", "HasShuffleNodeOfType missing arg - must be provided with type.") )
    __debugbreak();
  v8 = *(pathnode_t **)(v7 + 544);
  if ( !v8 )
    return 0;
  v9 = *(pathnode_t **)(*(_QWORD *)(v7 + 8) + 112i64);
  if ( !v9 )
    return 0;
  if ( v8 != v9 )
    return 0;
  pathnode_t::GetPos(v8, &pos);
  pathnode_t::GetPos(v9, &v15);
  if ( (float)((float)((float)((float)(v15.v[1] - pos.v[1]) * (float)(v15.v[1] - pos.v[1])) + (float)((float)(v15.v[0] - pos.v[0]) * (float)(v15.v[0] - pos.v[0]))) + (float)((float)(v15.v[2] - pos.v[2]) * (float)(v15.v[2] - pos.v[2]))) > 4.0 )
    return 0;
  StringParam = ASM_Builtin_GetStringParam(0, pParams, numParams);
  v11 = SL_ConvertToString(StringParam);
  type = v8->constant.type;
  if ( type == 31 )
    type = v8->dynamic.coverMultiType;
  return I_stricmp(v11, nodeStringTable[type]) == 0;
}

/*
==============
ASM_ShouldAbortShuffle
==============
*/
bool ASM_ShouldAbortShuffle(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  bool result; 
  AIWrapper v9; 

  AIWrapper::AIWrapper(&v9, &g_entities[entNum]);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2005, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v5 = m_pAI->GetAI(m_pAI);
  v6 = *(_QWORD *)(v5 + 544);
  result = 1;
  if ( v6 )
  {
    v7 = *(_QWORD *)(*(_QWORD *)(v5 + 8) + 112i64);
    if ( v7 )
    {
      if ( v6 == v7 )
        return 0;
    }
  }
  return result;
}

/*
==============
ASM_StairsWithinDistance
==============
*/
__int64 ASM_StairsWithinDistance(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams)
{
  __int64 v5; 
  AIScriptedInterface *m_pAI; 
  __int64 v9; 
  __int64 v10; 
  AIWrapper v11; 

  v5 = entNum;
  if ( (unsigned int)entNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 171, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, 2048) )
    __debugbreak();
  AIWrapper::AIWrapper(&v11, &g_entities[v5]);
  m_pAI = v11.m_pAI;
  if ( !v11.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 174, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !pParams && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 368, ASSERT_TYPE_ASSERT, "(pParams)", (const char *)&queryFormat, "pParams") )
    __debugbreak();
  if ( !numParams )
  {
    LODWORD(v10) = 0;
    LODWORD(v9) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 369, ASSERT_TYPE_ASSERT, "(unsigned)( iParam ) < (unsigned)( numParams )", "iParam doesn't index numParams\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  if ( (unsigned int)(pParams->m_Type - 3) > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm.h", 370, ASSERT_TYPE_ASSERT, "(pParams[ iParam ].m_Type == ParamType_Int || pParams[ iParam ].m_Type == ParamType_Float)", (const char *)&queryFormat, "pParams[ iParam ].m_Type == ParamType_Int || pParams[ iParam ].m_Type == ParamType_Float") )
    __debugbreak();
  return ((__int64 (__fastcall *)(AIScriptedInterface *))m_pAI->GetStairsWithinDist)(m_pAI);
}

/*
==============
ASM_ShouldAbortExposedCoverState
==============
*/
bool ASM_ShouldAbortExposedCoverState(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v7; 

  AIWrapper::AIWrapper(&v7, &g_entities[entNum]);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2025, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return !AIScriptedInterface::GetCoverNode(m_pAI) && !HasShuffleNode(entNum);
}

/*
==============
ASM_ShouldRunNGun
==============
*/
bool ASM_ShouldRunNGun(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2163, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return ShouldRunNGun(m_pAI);
}

/*
==============
ASM_ShouldRunNGunForward
==============
*/
bool ASM_ShouldRunNGunForward(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2171, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return ShouldRunNGunForward(m_pAI);
}

/*
==============
ASM_ShouldStopRunNGunForward
==============
*/
bool ASM_ShouldStopRunNGunForward(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 

  AIWrapper::AIWrapper(&v6, &g_entities[entNum]);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2179, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  return !ShouldRunNGun(m_pAI) || !ShouldRunNGunForward(m_pAI);
}

/*
==============
ASM_ShouldReloadWhileMoving
==============
*/
bool ASM_ShouldReloadWhileMoving(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  __int128 v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  __int64 v7; 
  AIWrapper v13; 

  AIWrapper::AIWrapper(&v13, &g_entities[entNum]);
  m_pAI = v13.m_pAI;
  if ( !v13.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2193, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  v7 = v6;
  if ( !*(_BYTE *)(v6 + 569) || !HasAnimSpeedThresholdEntryForArchetype(*(scr_string_t *)(v6 + 3464), scr_const.fast) || !HasAnimSpeedThresholdEntryForArchetype(*(scr_string_t *)(v7 + 3464), scr_const.jog) )
    return 0;
  *(double *)&v4 = AIScriptedInterface::GetDefaultSpeed(m_pAI);
  _XMM7 = LODWORD(FLOAT_600_0);
  _XMM6 = v4;
  GetAnimSpeedBetweenThresholdEntries(*(scr_string_t *)(v7 + 3464), scr_const.fast, scr_const.jog, 0.1);
  __asm
  {
    vcmpltss xmm2, xmm6, xmm0
    vblendvps xmm1, xmm7, xmm1, xmm2
  }
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v7 + 392) + 216i64))(*(_QWORD *)(v7 + 392));
}

/*
==============
ASM_ShouldPainExposedFromCover
==============
*/
bool ASM_ShouldPainExposedFromCover(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  gentity_s *v4; 
  AIScriptedInterface *m_pAI; 
  __int64 v6; 
  const pathnode_t *CoverNode; 
  __int64 v8; 
  gentity_s *TargetEntity; 
  EntHandle *v10; 
  gentity_s *v11; 
  bool result; 
  AIWrapper v13; 
  vec3_t pos; 

  v4 = &g_entities[entNum];
  AIWrapper::AIWrapper(&v13, v4);
  m_pAI = v13.m_pAI;
  if ( !v13.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2216, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v6 = m_pAI->GetAI(m_pAI);
  CoverNode = AIScriptedInterface::GetCoverNode(m_pAI);
  result = (CoverNode || (v8 = *(_QWORD *)(v6 + 8), (CoverNode = *(const pathnode_t **)(v8 + 112)) != NULL) && (pathnode_t::GetPos(*(pathnode_t **)(v8 + 112), &pos), (float)((float)((float)((float)(v4->r.currentOrigin.v[1] - pos.v[1]) * (float)(v4->r.currentOrigin.v[1] - pos.v[1])) + (float)((float)(v4->r.currentOrigin.v[0] - pos.v[0]) * (float)(v4->r.currentOrigin.v[0] - pos.v[0]))) + (float)((float)(v4->r.currentOrigin.v[2] - pos.v[2]) * (float)(v4->r.currentOrigin.v[2] - pos.v[2]))) < 25.0)) && (TargetEntity = AICommonInterface::GetTargetEntity(m_pAI), v10 = *(EntHandle **)(v6 + 8), v11 = TargetEntity, EntHandle::isDefined(v10 + 16)) && EntHandle::ent(v10 + 16) == v11 && !AIScriptedInterface::Cover_IsValidAgainstEnemy(m_pAI, CoverNode, 1);
  return result;
}

/*
==============
ASM_ChooseAnim_Execution_Victim
==============
*/
char ASM_ChooseAnim_Execution_Victim(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams, ASM_Function_Param *pParams, void *pOutValue)
{
  gentity_s *v7; 
  const ExecutionDef *Def; 
  const char *ExecutionAnimTypeName; 
  scr_string_t String; 
  scr_string_t AnimsetName; 
  int IndexOfRandomAnimFromAlias; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  __int64 v18; 

  v7 = &g_entities[entNum];
  if ( !v7->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2255, ASSERT_TYPE_ASSERT, "( pEnt->agent )", "ChooseAnim_Execution_Victim only works for agents.") )
    __debugbreak();
  Def = BG_Execution_GetDef(v7->agent->agentState.execution);
  if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2258, ASSERT_TYPE_ASSERT, "(execDef)", (const char *)&queryFormat, "execDef") )
    __debugbreak();
  ExecutionAnimTypeName = BG_GetExecutionAnimTypeName(Def->animType);
  String = SL_GetString(ExecutionAnimTypeName, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName(&v7->s);
  IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, String);
  SL_RemoveRefToString(String);
  if ( IndexOfRandomAnimFromAlias < 0 || IndexOfRandomAnimFromAlias >= BG_Animset_GetNumEntriesForState(AnimsetName, toStateName) )
  {
    v13 = SL_ConvertToString(toStateName);
    v14 = SL_ConvertToString(AnimsetName);
    LODWORD(v18) = IndexOfRandomAnimFromAlias;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2267, ASSERT_TYPE_ASSERT, "( animIndex >= 0 && animIndex < BG_Animset_GetNumEntriesForState( animsetName, toStateName ) )", "animIndex %d out of range for animset %s state %s", v18, v14, v13) )
      __debugbreak();
  }
  if ( IndexOfRandomAnimFromAlias < 0 )
  {
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(AnimsetName, toStateName, (const scr_string_t)scr_const._default);
    if ( IndexOfRandomAnimFromAlias < 0 || IndexOfRandomAnimFromAlias >= BG_Animset_GetNumEntriesForState(AnimsetName, toStateName) )
    {
      v15 = SL_ConvertToString(toStateName);
      v16 = SL_ConvertToString(AnimsetName);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2271, ASSERT_TYPE_ASSERT, "( animIndex >= 0 && animIndex < BG_Animset_GetNumEntriesForState( animsetName, toStateName ) )", "Unable to find default alias in animset %s state %s", v16, v15) )
        __debugbreak();
    }
  }
  ASM_ReturnAnimID(IndexOfRandomAnimFromAlias, pOutValue);
  return 1;
}

/*
==============
ASM_ShouldAbortExecution
==============
*/
bool ASM_ShouldAbortExecution(int entNum, const scr_string_t asmName, const scr_string_t toStateName, int numParams)
{
  gentity_s *v4; 

  v4 = &g_entities[entNum];
  if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2282, ASSERT_TYPE_ASSERT, "( pEnt->agent )", "ShouldAbortExecution only works for agents.") )
    __debugbreak();
  return v4->agent->agentState.execution == 255;
}

/*
==============
AI_ASM_GetBuiltinFunc
==============
*/
bool (*AI_ASM_GetBuiltinFunc(int i))(int, const scr_string_t, const scr_string_t, int, ASM_Function_Param *, void *)
{
  __int64 v1; 
  int v4; 

  v1 = i;
  if ( (unsigned int)i >= 0x62 )
  {
    v4 = 98;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 2291, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( numFuncs )", "i doesn't index numFuncs\n\t%i not in [0, %i)", i, v4) )
      __debugbreak();
  }
  return s_ASMBuiltinFuncs_1[v1].m_Func;
}

/*
==============
ASM_GetAnimID
==============
*/
__int64 ASM_GetAnimID(int entNum, const scr_string_t asmName, const scr_string_t toStateName)
{
  Ai_Asm *v6; 
  Ai_Asm::ChooseAnimReturnMode m_ChooseAnimReturnMode; 
  scrContext_t *v8; 
  VariableValue *top; 
  const char *v10; 
  const char *v11; 
  int outEntryIndex; 

  v6 = Ai_Asm::Singleton();
  m_ChooseAnimReturnMode = v6->m_ChooseAnimReturnMode;
  v6->m_ChooseAnimReturnMode = CODE;
  v8 = ScriptContext_Server();
  top = v8->m_vmPub.top;
  Common_Asm::ChooseAnim(v6, NULL, entNum, asmName, toStateName, &outEntryIndex);
  if ( top != v8->m_vmPub.top )
  {
    v10 = SL_ConvertToString(asmName);
    v11 = SL_ConvertToString(toStateName);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1104, ASSERT_TYPE_ASSERT, "( pPrevTop == scrContext.m_vmPub.top )", "the chooseanim function for %s in ASM %s did not properly return its value with ASM_ReturnAnimID", v11, v10) )
      __debugbreak();
  }
  v6->m_ChooseAnimReturnMode = m_ChooseAnimReturnMode;
  return (unsigned int)outEntryIndex;
}

/*
==============
ASM_PlayFacialAnim
==============
*/
void ASM_PlayFacialAnim(int entNum, const scr_string_t asmName, const Animset *pAnimset, int stateIndex, int entryIndex)
{
  __int64 v6; 
  Ai_Asm *v9; 
  ASM_Instance *Instance; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v12; 

  v6 = entNum;
  v9 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v9, NULL, v6);
  if ( Instance->m_pASM->m_Name == asmName )
  {
    AIWrapper::AIWrapper(&v12, &g_entities[v6]);
    m_pAI = v12.m_pAI;
    if ( !v12.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1170, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
      __debugbreak();
    AIScriptedInterface::SetFacialIndexFromASM(m_pAI, Instance, pAnimset, stateIndex, entryIndex);
  }
}

/*
==============
ASM_ReturnAnimID
==============
*/
void ASM_ReturnAnimID(int entryIndex, void *pOutValue)
{
  Ai_Asm::ChooseAnimReturnMode m_ChooseAnimReturnMode; 
  scrContext_t *v5; 

  m_ChooseAnimReturnMode = Ai_Asm::Singleton()->m_ChooseAnimReturnMode;
  if ( m_ChooseAnimReturnMode == CODE )
  {
    if ( !pOutValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1117, ASSERT_TYPE_ASSERT, "(pOutValue)", (const char *)&queryFormat, "pOutValue") )
      __debugbreak();
    *(_DWORD *)pOutValue = entryIndex;
  }
  else
  {
    if ( m_ChooseAnimReturnMode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1122, ASSERT_TYPE_ASSERT, "(returnMode == Ai_Asm::ChooseAnimReturnMode::SCRIPT)", (const char *)&queryFormat, "returnMode == Ai_Asm::ChooseAnimReturnMode::SCRIPT") )
      __debugbreak();
    v5 = ScriptContext_Server();
    Scr_AddInt(v5, entryIndex);
  }
}

/*
==============
ASM_ReturnAnimIDUndefined
==============
*/
void ASM_ReturnAnimIDUndefined(void *pOutValue)
{
  if ( Ai_Asm::Singleton()->m_ChooseAnimReturnMode == CODE )
  {
    if ( !pOutValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1132, ASSERT_TYPE_ASSERT, "(pOutValue)", (const char *)&queryFormat, "pOutValue") )
      __debugbreak();
    *(_DWORD *)pOutValue = -12345;
  }
}

/*
==============
ChooseAnim_GetReloadWeapClass
==============
*/
const char *ChooseAnim_GetReloadWeapClass(const AIScriptedInterface *pAI)
{
  const Weapon *v1; 
  weapClass_t WeaponClass; 
  weapClass_t v3; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v5; 
  __int64 v6; 
  unsigned int numModelVariations; 
  const char **p_name; 
  const char *v9; 
  int v11; 
  unsigned int v12; 

  v1 = pAI->GetEquippedWeapon(pAI);
  WeaponClass = BG_GetWeaponClass(v1, 0);
  v3 = WeaponClass;
  if ( v1->weaponIdx )
  {
    if ( WeaponClass == WEAPCLASS_SPREAD )
    {
      WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(v1, ATT_SLOT_MAGAZINE);
      v5 = WeaponPrimaryAttachment;
      if ( WeaponPrimaryAttachment )
      {
        v6 = v1->attachmentVariationIndices[3];
        numModelVariations = WeaponPrimaryAttachment->numModelVariations;
        if ( (unsigned int)v6 >= numModelVariations )
        {
          v12 = numModelVariations;
          v11 = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1271, ASSERT_TYPE_ASSERT, "(unsigned)( varIndex ) < (unsigned)( magazineAttachment->numModelVariations )", "varIndex doesn't index magazineAttachment->numModelVariations\n\t%i not in [0, %i)", v11, v12) )
            __debugbreak();
        }
        p_name = &v5->worldModelVariations[v6]->name;
        v9 = *p_name;
        if ( *p_name && (I_stristr(*p_name, "drum") || I_stristr(v9, "mag")) )
          v3 = WEAPCLASS_RIFLE;
      }
    }
  }
  return BG_GetWeaponClassName(v3);
}

/*
==============
ChooseNumShotsPerBurst
==============
*/
unsigned __int8 ChooseNumShotsPerBurst(AIScriptedInterface *pAI)
{
  const Weapon *v2; 
  __int64 v3; 
  float v4; 
  float v5; 
  float v6; 
  float v7; 
  int v8; 
  int WeaponBurstCount; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 
  int v14; 
  int v15; 
  unsigned __int16 v16; 
  __int16 v17; 
  int v18; 
  double v19; 
  unsigned int v20; 
  scrContext_t *v21; 

  v2 = pAI->GetEquippedWeapon(pAI);
  v3 = pAI->GetAI(pAI);
  if ( !*(_BYTE *)(v3 + 525) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 604, ASSERT_TYPE_ASSERT, "(pScripted->blackboard.m_ShootParams.m_bPosValid)", (const char *)&queryFormat, "pScripted->blackboard.m_ShootParams.m_bPosValid") )
    __debugbreak();
  v4 = *(float *)(v3 + 496) - *(float *)(*(_QWORD *)v3 + 304i64);
  v5 = *(float *)(v3 + 500) - *(float *)(*(_QWORD *)v3 + 308i64);
  v6 = *(float *)(v3 + 504) - *(float *)(*(_QWORD *)v3 + 312i64);
  v7 = (float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6);
  switch ( *(_BYTE *)(v3 + 521) )
  {
    case 0:
      goto $LN9_9;
    case 1:
    case 2:
      v8 = 5;
      if ( BG_GetWeaponFireType(v2, 0) == WEAPON_FIRETYPE_BURST )
      {
        WeaponBurstCount = BG_GetWeaponBurstCount(v2, 0);
      }
      else
      {
        v10 = 5;
        if ( v7 > 2560000.0 )
          v10 = 4;
        v11 = v10 - 1;
        if ( v7 <= 1562500.0 )
          v11 = v10;
        v12 = v11 - 1;
        if ( v7 <= 810000.0 )
          v12 = v11;
        v13 = G_irand(-2, 3);
        v14 = v12 - 1;
        if ( v7 <= 62500.0 )
          v14 = v12;
        WeaponBurstCount = v14 + v13;
      }
      if ( BG_GetWeaponClass(v2, 0) == WEAPCLASS_PISTOL )
      {
        if ( WeaponBurstCount < 5 )
          v8 = WeaponBurstCount;
        WeaponBurstCount = v8;
      }
      if ( WeaponBurstCount >= 1 )
      {
        v16 = *(_WORD *)(v3 + 1168);
        if ( v16 && WeaponBurstCount > v16 )
          LOBYTE(WeaponBurstCount) = *(_WORD *)(v3 + 1168);
        LOBYTE(v15) = WeaponBurstCount;
      }
      else
      {
        LOBYTE(v15) = 1;
      }
      return v15;
    case 4:
      v17 = *(_WORD *)(v3 + 1168);
      if ( !v17 )
        LOBYTE(v17) = 1;
      if ( BG_GetWeaponClass(v2, 0) != WEAPCLASS_MG )
        goto LABEL_34;
      v18 = G_irand(0, 10);
      if ( v18 >= 3 )
      {
        if ( v18 >= 8 )
        {
          LOBYTE(v17) = G_irand(12, 20);
LABEL_34:
          LOBYTE(v15) = v17;
        }
        else
        {
          LOBYTE(v15) = G_irand(6, 12);
        }
      }
      else
      {
        LOBYTE(v15) = G_irand(2, 6);
      }
      return v15;
    case 5:
      v19 = G_random();
      return (int)(float)((float)((float)(*(float *)&v19 * 1.5) + 0.5) * 10.0);
    case 6:
      v20 = *(unsigned __int8 *)(v3 + 522);
      LOBYTE(v15) = G_irand(1, 3);
      if ( (unsigned __int8)v15 == v20 )
        LOBYTE(v15) = v20 % 3 + 1;
      return v15;
    default:
      v21 = ScriptContext_Server();
      Scr_Error(COM_ERR_2446, v21, "Unknown shoot style");
$LN9_9:
      LOBYTE(v15) = 1;
      return v15;
  }
}

/*
==============
ChooseShootStyle
==============
*/
void ChooseShootStyle(AIScriptedInterface *pAI)
{
  __int64 v2; 
  char v3; 
  AIScriptedInterface_vtbl *v4; 
  __int64 v5; 
  const Weapon *v6; 
  weapClass_t WeaponClass; 
  weapFireType_t WeaponFireType; 
  bool IsUsingTurret; 
  EntHandle *v10; 
  const gentity_s *v11; 
  AIScriptedInterface *v12; 
  __int64 v13; 
  float v14; 
  EntHandle *v15; 
  char v16; 
  const gentity_s *v17; 
  int v18; 
  double v19; 
  __int64 v20; 
  char v21; 
  int v22; 
  bool v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  EntHandle *v28; 
  char v29; 
  __int64 v30; 
  __int64 v31; 
  __int64 v32; 
  AIWrapper v33; 
  vec3_t outEyePos; 

  v2 = pAI->GetAI(pAI);
  v3 = *(_BYTE *)(v2 + 1644);
  v4 = pAI->__vftable;
  if ( v3 != 7 )
  {
    v5 = (__int64)v4->GetAI(pAI);
    *(_BYTE *)(v5 + 521) = v3;
    *(_BYTE *)(v5 + 526) = 0;
    return;
  }
  v6 = v4->GetEquippedWeapon(pAI);
  WeaponClass = BG_GetWeaponClass(v6, 0);
  WeaponFireType = BG_GetWeaponFireType(v6, 0);
  IsUsingTurret = AICommonInterface::IsUsingTurret(pAI);
  if ( WeaponClass == WEAPCLASS_MG || IsUsingTurret )
  {
    v32 = pAI->GetAI(pAI);
    *(_BYTE *)(v32 + 521) = 5;
    *(_BYTE *)(v32 + 526) = 0;
  }
  else
  {
    v10 = (EntHandle *)(v2 + 508);
    if ( EntHandle::isDefined((EntHandle *)(v2 + 508)) )
    {
      v11 = EntHandle::ent((EntHandle *)(v2 + 508));
      if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 456, ASSERT_TYPE_ASSERT, "(pTargetEnt)", (const char *)&queryFormat, "pTargetEnt") )
        __debugbreak();
      AIWrapper::AIWrapper(&v33, v11);
      if ( v33.m_pAI )
      {
        if ( *(_BYTE *)((__int64)v33.m_pAI->GetAI(v33.m_pAI) + 567) )
        {
          v12 = pAI;
LABEL_14:
          v13 = pAI->GetAI(v12);
          *(_BYTE *)(v13 + 521) = 0;
          *(_BYTE *)(v13 + 526) = 0;
          return;
        }
      }
    }
    v12 = pAI;
    if ( WeaponClass == WEAPCLASS_SNIPER || WeaponClass == WEAPCLASS_ROCKETLAUNCHER )
      goto LABEL_14;
    AIScriptedInterface::GetApproxEyePos(pAI, &outEyePos, 1);
    if ( !*(_BYTE *)(v2 + 525) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 487, ASSERT_TYPE_ASSERT, "(pScripted->blackboard.m_ShootParams.m_bPosValid)", (const char *)&queryFormat, "pScripted->blackboard.m_ShootParams.m_bPosValid") )
      __debugbreak();
    v14 = (float)((float)((float)(*(float *)(v2 + 500) - outEyePos.v[1]) * (float)(*(float *)(v2 + 500) - outEyePos.v[1])) + (float)((float)(*(float *)(v2 + 496) - outEyePos.v[0]) * (float)(*(float *)(v2 + 496) - outEyePos.v[0]))) + (float)((float)(*(float *)(v2 + 504) - outEyePos.v[2]) * (float)(*(float *)(v2 + 504) - outEyePos.v[2]));
    switch ( WeaponClass )
    {
      case WEAPCLASS_PISTOL:
        if ( v14 < 62500.0 )
        {
          v15 = (EntHandle *)(v2 + 508);
          v16 = 2;
          if ( EntHandle::isDefined(v15) )
          {
            v17 = EntHandle::ent(v10);
            if ( !v17 )
            {
              v18 = 502;
              goto LABEL_44;
            }
            goto LABEL_46;
          }
          goto LABEL_60;
        }
        v19 = G_random();
        v20 = pAI->GetAI(pAI);
        v21 = 0;
        if ( (float)((float)((float)(1.0 - (float)((float)(v14 - 62500.0) * 0.0000013377927)) * 0.5) + (float)((float)((float)(v14 - 62500.0) * 0.0000013377927) * 0.2)) > *(float *)&v19 )
          v21 = 2;
        *(_BYTE *)(v20 + 521) = v21;
        *(_BYTE *)(v20 + 526) = v14 >= 810000.0;
        break;
      case WEAPCLASS_SPREAD:
        if ( BG_IsBoltAction(v6, 0) )
        {
          v22 = *(_DWORD *)(v2 + 488);
          v23 = (v22 == scr_const.exposed || v22 == scr_const.none) && *(_DWORD *)(v2 + 492) != scr_const.lean;
          v24 = pAI->GetAI(pAI);
          *(_BYTE *)(v24 + 521) = v23 ? 6 : 0;
          *(_BYTE *)(v24 + 526) = 0;
        }
        else
        {
          v25 = pAI->GetAI(pAI);
          *(_BYTE *)(v25 + 521) = 2;
          *(_BYTE *)(v25 + 526) = 0;
        }
        break;
      case WEAPCLASS_GRENADE:
        v26 = pAI->GetAI(pAI);
        *(_BYTE *)(v26 + 521) = 0;
        *(_BYTE *)(v26 + 526) = 0;
        return;
      default:
        if ( WeaponFireType == WEAPON_FIRETYPE_BURST && BG_GetWeaponBurstCount(v6, 0) > 0 )
        {
          v27 = pAI->GetAI(pAI);
          *(_BYTE *)(v27 + 521) = 1;
          *(_BYTE *)(v27 + 526) = 0;
          return;
        }
        if ( v14 < 62500.0 )
        {
          v28 = (EntHandle *)(v2 + 508);
          v16 = 4;
          if ( EntHandle::isDefined(v28) )
          {
            v17 = EntHandle::ent(v10);
            if ( !v17 )
            {
              v18 = 558;
LABEL_44:
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", v18, ASSERT_TYPE_ASSERT, "(pTarget)", (const char *)&queryFormat, "pTarget") )
                __debugbreak();
            }
LABEL_46:
            AIWrapper::AIWrapper(&v33, v17);
            if ( v33.m_pAI )
            {
              if ( *(_BYTE *)((__int64)v33.m_pAI->GetAI(v33.m_pAI) + 1645) )
                v16 = 0;
            }
          }
LABEL_60:
          v31 = pAI->GetAI(pAI);
          *(_BYTE *)(v31 + 521) = v16;
          *(_BYTE *)(v31 + 526) = 0;
          return;
        }
        if ( v14 >= 810000.0 )
        {
          v16 = v14 < 2560000.0;
          if ( ShouldDoSemiForVariety(v14) )
            v16 = 2;
          goto LABEL_60;
        }
        v29 = 1;
        if ( BG_GetWeaponType(v6, 0) == WEAPTYPE_BULLET && ((WeaponFireType - 1) & 0xFFFFFFFC) == 0 )
        {
          v29 = 1;
          if ( WeaponFireType != WEAPON_FIRETYPE_BURST )
            v29 = 2;
        }
        if ( ShouldDoSemiForVariety(v14) )
          v29 = 2;
        v30 = pAI->GetAI(pAI);
        *(_BYTE *)(v30 + 521) = v29;
        *(_BYTE *)(v30 + 526) = 1;
        break;
    }
  }
}

/*
==============
GetBlackboard
==============
*/
AIBlackboard *GetBlackboard(int entNum)
{
  __int64 v1; 
  __int64 v4; 
  int v5; 
  __int64 v6; 

  v1 = entNum;
  if ( (unsigned int)entNum >= 0x800 )
  {
    v5 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 44, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v5) )
      __debugbreak();
    LODWORD(v6) = 2048;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v4, v6) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[v1].r.isInUse != g_entityIsInUse[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 45, ASSERT_TYPE_ASSERT, "( G_IsEntityInUse( entNum ) )", (const char *)&queryFormat, "G_IsEntityInUse( entNum )") )
    __debugbreak();
  return &AI_GetAIScripted(&g_entities[v1])->blackboard;
}

/*
==============
HasShuffleNode
==============
*/
char HasShuffleNode(int entNum)
{
  AIScriptedInterface *m_pAI; 
  __int64 v2; 
  const pathnode_t *v3; 
  unsigned __int16 v4; 
  __int64 v5; 
  AIWrapper v7; 

  AIWrapper::AIWrapper(&v7, &g_entities[entNum]);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1855, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  v2 = m_pAI->GetAI(m_pAI);
  v3 = *(const pathnode_t **)(v2 + 544);
  if ( v3 )
  {
    v4 = Path_ConvertNodeToIndex(v3);
    if ( Path_NodeValid(v4) )
    {
      if ( !*(_QWORD *)(v2 + 8) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_asm_builtin.cpp", 1863, ASSERT_TYPE_ASSERT, "(pScripted->sentient)", (const char *)&queryFormat, "pScripted->sentient") )
        __debugbreak();
      v5 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + 112i64);
      if ( v5 )
      {
        if ( v5 == *(_QWORD *)(v2 + 544) && !AICommonInterface::NearClaimNode(m_pAI, 16.0) )
          return 1;
      }
    }
    *(_QWORD *)(v2 + 544) = 0i64;
  }
  return 0;
}

/*
==============
IsShuffleNodeInDir
==============
*/
bool IsShuffleNodeInDir(const vec3_t *origin, const pathnode_t *pShuffleNode, const scr_string_t dir)
{
  float v6; 
  float v7; 
  __int128 v8; 
  float v12; 
  bool v13; 
  vec3_t pos; 
  vec3_t forward; 
  vec3_t vector; 

  pathnode_t::GetPos((pathnode_t *)pShuffleNode, &pos);
  v6 = pos.v[0] - origin->v[0];
  v8 = LODWORD(pos.v[1]);
  v7 = pos.v[1] - origin->v[1];
  *(float *)&v8 = fsqrt((float)((float)(v7 * v7) + (float)(v6 * v6)) + (float)((float)(pos.v[2] - origin->v[2]) * (float)(pos.v[2] - origin->v[2])));
  _XMM5 = v8;
  __asm
  {
    vcmpless xmm0, xmm5, cs:__real@80000000
    vblendvps xmm0, xmm5, xmm1, xmm0
  }
  pathnode_t::GetAngles((pathnode_t *)pShuffleNode, &vector);
  AngleVectors(&vector, &forward, NULL, NULL);
  v12 = (float)((float)(v7 * (float)(1.0 / *(float *)&_XMM0)) * forward.v[0]) - (float)((float)(v6 * (float)(1.0 / *(float *)&_XMM0)) * forward.v[1]);
  v13 = v12 < 0.0;
  if ( v12 > 0.0 )
  {
    if ( dir == scr_const.left )
      return 1;
    v13 = v12 < 0.0;
  }
  return v13 && dir == scr_const.right;
}

/*
==============
IsWeaponClass
==============
*/
bool IsWeaponClass(const scr_weapon_t weap, const scr_string_t checkWeapClass)
{
  const scrContext_t *v4; 
  const Weapon *Weapon; 
  bool IsAlternate; 
  weapClass_t WeaponClass; 
  const char *v9; 
  const char *WeaponClassName; 

  v4 = ScriptContext_Server();
  Weapon = GScr_Weapon_GetWeapon(v4, weap);
  if ( !Weapon->weaponIdx )
    return checkWeapClass == scr_const.none;
  IsAlternate = GScr_Weapon_IsAlternate(v4, weap);
  WeaponClass = BG_GetWeaponClass(Weapon, IsAlternate);
  v9 = SL_ConvertToString(checkWeapClass);
  WeaponClassName = BG_GetWeaponClassName(WeaponClass);
  return I_stricmp(WeaponClassName, v9) == 0;
}

/*
==============
SetupMotionWarp
==============
*/
void SetupMotionWarp(int entNum, const vec3_t *animDelta, const vec4_t *qAnimRot, const vec3_t *targetPos, const vec3_t *targetAngles, int animDuration)
{
  float v10; 
  float v11; 
  float v12; 
  float v13; 
  float v14; 
  vec3_t out; 
  vec4_t v16; 
  vec4_t quat; 
  vec3_t animStartAngles; 

  AnglesToQuat(targetAngles, &quat);
  v10 = qAnimRot->v[3];
  LODWORD(v11) = LODWORD(qAnimRot->v[0]) ^ _xmm;
  LODWORD(v12) = LODWORD(qAnimRot->v[2]) ^ _xmm;
  LODWORD(v13) = LODWORD(qAnimRot->v[1]) ^ _xmm;
  v16.v[0] = (float)((float)((float)(quat.v[3] * v11) + (float)(quat.v[0] * v10)) + (float)(quat.v[1] * v12)) - (float)(quat.v[2] * v13);
  v16.v[1] = (float)((float)((float)(quat.v[3] * v13) - (float)(quat.v[0] * v12)) + (float)(quat.v[1] * v10)) + (float)(quat.v[2] * v11);
  v16.v[2] = (float)((float)((float)(quat.v[0] * v13) + (float)(quat.v[3] * v12)) - (float)(quat.v[1] * v11)) + (float)(quat.v[2] * v10);
  v16.v[3] = (float)((float)((float)(quat.v[3] * v10) - (float)(quat.v[0] * v11)) - (float)(quat.v[1] * v13)) - (float)(quat.v[2] * v12);
  QuatTransform(&v16, animDelta, &out);
  v14 = targetPos->v[1] - out.v[1];
  out.v[0] = targetPos->v[0] - out.v[0];
  out.v[2] = targetPos->v[2] - out.v[2];
  out.v[1] = v14;
  QuatToAngles(&v16, &animStartAngles);
  G_MotionWarp_StartWithAnim(entNum, &out, &animStartAngles, targetPos, targetAngles, animDuration);
}

/*
==============
SetupMotionWarp
==============
*/
void SetupMotionWarp(int entNum, const vec3_t *animDelta, const vec4_t *qAnimRot, const vec3_t *targetPos, const vec3_t *targetAngles, float animDuration)
{
  __m128 v7; 
  double v8; 
  vec4_t v9; 
  float v11; 
  unsigned __int128 v12; 
  unsigned __int128 v13; 
  vec3_t angles; 
  vec3_t targetPosa; 
  vec3_t out; 
  vec4_t v17; 
  vec4_t quat; 
  vec3_t animStartAngles; 

  v7 = (__m128)*(unsigned __int64 *)targetPos->v;
  v8 = *(double *)targetAngles->v;
  v9 = *qAnimRot;
  angles.v[2] = targetAngles->v[2];
  targetPosa.v[2] = targetPos->v[2];
  *(double *)angles.v = v8;
  AnglesToQuat(&angles, &quat);
  LODWORD(v11) = LODWORD(v9.v[0]) ^ _xmm;
  v12 = *(unsigned __int128 *)&_mm_shuffle_ps((__m128)v9, (__m128)v9, 85) ^ (unsigned int)_xmm;
  v13 = *(unsigned __int128 *)&_mm_shuffle_ps((__m128)v9, (__m128)v9, 170) ^ (unsigned int)_xmm;
  v9.v[0] = _mm_shuffle_ps((__m128)v9, (__m128)v9, 255).m128_f32[0];
  v17.v[0] = (float)((float)((float)(quat.v[0] * v9.v[0]) + (float)(quat.v[3] * v11)) + (float)(quat.v[1] * *(float *)&v13)) - (float)(quat.v[2] * *(float *)&v12);
  v17.v[1] = (float)((float)((float)(quat.v[3] * *(float *)&v12) - (float)(quat.v[0] * *(float *)&v13)) + (float)(quat.v[1] * v9.v[0])) + (float)(quat.v[2] * v11);
  v17.v[2] = (float)((float)((float)(quat.v[0] * *(float *)&v12) + (float)(quat.v[3] * *(float *)&v13)) - (float)(quat.v[1] * v11)) + (float)(quat.v[2] * v9.v[0]);
  v17.v[3] = (float)((float)((float)(quat.v[3] * v9.v[0]) - (float)(quat.v[0] * v11)) - (float)(quat.v[1] * *(float *)&v12)) - (float)(quat.v[2] * *(float *)&v13);
  QuatTransform(&v17, animDelta, &out);
  out.v[0] = v7.m128_f32[0] - out.v[0];
  out.v[2] = targetPosa.v[2] - out.v[2];
  out.v[1] = _mm_shuffle_ps(v7, v7, 85).m128_f32[0] - out.v[1];
  *(double *)targetPosa.v = *(double *)v7.m128_u64;
  QuatToAngles(&v17, &animStartAngles);
  G_MotionWarp_StartWithAnim(entNum, &out, &animStartAngles, &targetPosa, &angles, (int)(float)(animDuration * 1000.0));
}

/*
==============
ShouldDoSemiForVariety
==============
*/
bool ShouldDoSemiForVariety(float distSq)
{
  float v2; 
  double v3; 

  if ( distSq < 2560000.0 )
    return 0;
  v2 = (float)(distSq - 2560000.0) * 0.00000015527951;
  v3 = G_random();
  return (float)((float)((float)(1.0 - v2) * 0.5) + (float)(v2 * 0.2)) > *(float *)&v3;
}

/*
==============
ShouldRunNGun
==============
*/
char ShouldRunNGun(const AIScriptedInterface *pAI)
{
  __int64 v2; 
  int v3; 
  const Weapon *v5; 
  weapClass_t WeaponClass; 
  float v7; 
  unsigned __int8 v8; 
  const sentient_s *TargetSentient; 
  const sentient_s *v18; 
  const tacpoint_t *LastKnownEnemyTacPoint; 
  const tacpoint_t *v20; 

  v2 = pAI->GetAI(&pAI->AICommonInterface);
  if ( *(_BYTE *)(v2 + 1748) || !AICommonInterface::HasPath(&pAI->AICommonInterface) || *(_DWORD *)(*(_QWORD *)(v2 + 8) + 16i64) == 2 && AIScriptedInterface::IsOnStairs((AIScriptedInterface *)pAI) || AIScriptedInterface::IsDoingReacquire((AIScriptedInterface *)pAI) || !*(_BYTE *)(v2 + 330) || *(_BYTE *)(v2 + 1750) || *(_DWORD *)(v2 + 480) != scr_const.combat )
    return 0;
  v3 = *(_DWORD *)(v2 + 1736);
  if ( *(_BYTE *)(v2 + 1747) )
  {
    if ( v3 < level.time )
      return 0;
  }
  else if ( v3 > level.time || *(_BYTE *)(v2 + 2908) )
  {
    return 0;
  }
  v5 = pAI->GetEquippedWeapon(pAI);
  if ( v5->weaponIdx )
  {
    WeaponClass = BG_GetWeaponClass(v5, 0);
    if ( WeaponClass == WEAPCLASS_RIFLE || (unsigned int)(WeaponClass - 2) <= 2 )
    {
      v7 = *(float *)(v2 + 3404);
      v8 = *(_BYTE *)(v2 + 1747);
      if ( !HasAnimSpeedThresholdEntryForArchetype(*(scr_string_t *)(v2 + 3464), scr_const.fast) )
        goto LABEL_31;
      if ( !HasAnimSpeedThresholdEntryForArchetype(*(scr_string_t *)(v2 + 3464), scr_const.jog) )
        goto LABEL_31;
      _XMM0 = v8;
      __asm { vpcmpeqd xmm3, xmm0, xmm1 }
      _XMM1 = LODWORD(FLOAT_0_80000001);
      __asm { vblendvps xmm3, xmm1, xmm2, xmm3; fractionValue }
      *(double *)&_XMM0 = GetAnimSpeedBetweenThresholdEntries((scr_string_t)*(_DWORD *)(v2 + 3464), scr_const.fast, scr_const.jog, *(float *)&_XMM3);
      if ( v7 >= *(float *)&_XMM0 )
      {
LABEL_31:
        _XMM0 = *(unsigned __int8 *)(v2 + 1747);
        __asm { vpcmpeqd xmm3, xmm0, xmm1 }
        _XMM1 = LODWORD(FLOAT_100_0);
        __asm { vblendvps xmm6, xmm1, xmm2, xmm3 }
        *(double *)&_XMM0 = Nav_GetPathDistToGoal(*(const AINavigator **)(v2 + 392));
        if ( *(float *)&_XMM0 >= *(float *)&_XMM6 )
        {
          TargetSentient = AICommonInterface::GetTargetSentient(&pAI->AICommonInterface);
          if ( TargetSentient )
          {
            if ( *(_BYTE *)(v2 + 1747) )
            {
              v18 = pAI->GetSentient(pAI);
              if ( level.time - Sentient_GetSentientInfo(v18, TargetSentient)->lastKnownPosTime < 2000 )
                return 1;
            }
            LastKnownEnemyTacPoint = AICommonInterface::GetLastKnownEnemyTacPoint(&pAI->AICommonInterface, TargetSentient->ent);
            if ( LastKnownEnemyTacPoint )
            {
              v20 = Sentient_NearestTacPoint(*(sentient_s **)(v2 + 8));
              if ( v20 )
              {
                if ( TacVisGraph_HasVis(v20, LastKnownEnemyTacPoint) )
                  return 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

/*
==============
ShouldRunNGunForward
==============
*/
bool ShouldRunNGunForward(const AIScriptedInterface *pAI)
{
  gentity_s *TargetEntity; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  double v7; 
  float v8; 
  char v11; 
  vec2_t vec; 
  float v13; 
  int v14[5]; 
  bfx::AreaHandle v15; 
  bfx::LinkHandle v16; 

  if ( !AICommonInterface::HasPath(&pAI->AICommonInterface) )
    return 0;
  TargetEntity = AICommonInterface::GetTargetEntity(&pAI->AICommonInterface);
  if ( !TargetEntity )
    return 0;
  v4 = pAI->GetAI(&pAI->AICommonInterface);
  fsqrt((float)((float)(*(float *)(v4 + 2104) * *(float *)(v4 + 2104)) + (float)(*(float *)(v4 + 2108) * *(float *)(v4 + 2108))) + (float)(*(float *)(v4 + 2112) * *(float *)(v4 + 2112)));
  bfx::AreaHandle::AreaHandle(&v15);
  bfx::LinkHandle::LinkHandle(&v16);
  v11 = 0;
  LOBYTE(v5) = 1;
  (*(void (__fastcall **)(_QWORD, __int64, __int64, int *, char))(**(_QWORD **)(v4 + 392) + 416i64))(*(_QWORD *)(v4 + 392), v6, v5, v14, v11);
  vec.v[0] = TargetEntity->r.currentOrigin.v[0] - *(float *)v14;
  vec.v[1] = TargetEntity->r.currentOrigin.v[1] - *(float *)&v14[1];
  v13 = TargetEntity->r.currentOrigin.v[2] - *(float *)&v14[2];
  v7 = vectoyaw(&vec);
  v8 = (float)(*(float *)&v7 - *(float *)(*(_QWORD *)v4 + 320i64)) * 0.0027777778;
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm3, 1 }
  LOBYTE(v4) = (float)(*(float *)(v4 + 1732) * *(float *)(v4 + 1732)) > (float)((float)((float)(v8 - *(float *)&_XMM1) * (float)(v8 - *(float *)&_XMM1)) * 129600.0);
  bfx::LinkHandle::~LinkHandle(&v16);
  bfx::AreaHandle::~AreaHandle(&v15);
  return v4;
}

