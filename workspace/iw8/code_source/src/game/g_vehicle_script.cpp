/*
==============
G_VehicleScriptCmd_SetGoalYaw
==============
*/

void __fastcall G_VehicleScriptCmd_SetGoalYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetGoalYaw@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_VehicleTurretControlOff
==============
*/

void __fastcall G_VehicleScriptCmd_VehicleTurretControlOff(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_VehicleTurretControlOff@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_ClearGoalYaw
==============
*/

void __fastcall G_VehicleScriptCmd_ClearGoalYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_ClearGoalYaw@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScript_SetField
==============
*/

void __fastcall G_VehicleScript_SetField(scrContext_t *scrContext, Vehicle *veh, int offset)
{
  ?G_VehicleScript_SetField@@YAXAEAUscrContext_t@@PEAUVehicle@@H@Z(scrContext, veh, offset);
}

/*
==============
G_VehicleScriptCmd_SetAirResitance
==============
*/

void __fastcall G_VehicleScriptCmd_SetAirResitance(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetAirResitance@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_Spawn
==============
*/

void __fastcall G_VehicleScriptCmd_Spawn(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_Spawn@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_VehicleTurretControlOn
==============
*/

void __fastcall G_VehicleScriptCmd_VehicleTurretControlOn(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_VehicleTurretControlOn@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetAngularVelocity
==============
*/

void __fastcall G_VehicleScriptCmd_GetAngularVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetAngularVelocity@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetGoalPos
==============
*/

void __fastcall G_VehicleScriptCmd_SetGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetGoalPos@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_WakeUpVehicle
==============
*/

void __fastcall G_VehicleScriptCmd_WakeUpVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_WakeUpVehicle@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetYawSpeed
==============
*/

void __fastcall G_VehicleScriptCmd_SetYawSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetYawSpeed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScript_AddFields
==============
*/

void __fastcall G_VehicleScript_AddFields(scrContext_t *scrContext)
{
  ?G_VehicleScript_AddFields@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_EnableCollisionCallback
==============
*/

void __fastcall G_VehicleScriptCmd_EnableCollisionCallback(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_EnableCollisionCallback@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_IsOnGround
==============
*/

void __fastcall G_VehicleScriptCmd_IsOnGround(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_IsOnGround@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetHoverParams
==============
*/

void __fastcall G_VehicleScriptCmd_SetHoverParams(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetHoverParams@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetSpeed
==============
*/

void __fastcall G_VehicleScriptCmd_GetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetSpeed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedRotational
==============
*/

void __fastcall G_VehicleScriptCmd_GetTopSpeedRotational(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetTopSpeedRotational@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetBodyVelocity
==============
*/

void __fastcall G_VehicleScriptCmd_GetBodyVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetBodyVelocity@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetHornSound
==============
*/

void __fastcall G_VehicleScriptCmd_SetHornSound(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetHornSound@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetLookAheadTime
==============
*/

void __fastcall G_VehicleScriptCmd_SetLookAheadTime(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetLookAheadTime@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetTurretTargetEnt
==============
*/

void __fastcall G_VehicleScriptCmd_SetTurretTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetTurretTargetEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetArrayInRadius
==============
*/

void __fastcall G_VehicleScriptCmd_GetArrayInRadius(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_GetArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_AllowPlayerUse
==============
*/

void __fastcall G_VehicleScriptCmd_AllowPlayerUse(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_AllowPlayerUse@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_SetTurningAbility
==============
*/

void __fastcall G_VehicleScriptCmd_SetTurningAbility(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetTurningAbility@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SuspendVehicle
==============
*/

void __fastcall G_VehicleScriptCmd_SuspendVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SuspendVehicle@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetTurretTargetVec
==============
*/

void __fastcall G_VehicleScriptCmd_SetTurretTargetVec(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetTurretTargetVec@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScript_GetVehicleEntity
==============
*/

gentity_s *__fastcall G_VehicleScript_GetVehicleEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  return ?G_VehicleScript_GetVehicleEntity@@YAPEAUgentity_s@@AEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetMaxPitchRoll
==============
*/

void __fastcall G_VehicleScriptCmd_SetMaxPitchRoll(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetMaxPitchRoll@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_MakeCorpse
==============
*/

void __fastcall G_VehicleScriptCmd_MakeCorpse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_MakeCorpse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetActiveCount
==============
*/

void __fastcall G_VehicleScriptCmd_GetActiveCount(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_GetActiveCount@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScript_IsVehicleSuspended
==============
*/

bool __fastcall G_VehicleScript_IsVehicleSuspended(scr_entref_t entref)
{
  return ?G_VehicleScript_IsVehicleSuspended@@YA_NUscr_entref_t@@@Z(entref);
}

/*
==============
G_VehicleScriptCmd_SetLookAtEnt
==============
*/

void __fastcall G_VehicleScriptCmd_SetLookAtEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetLookAtEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetSpeed
==============
*/

void __fastcall G_VehicleScriptCmd_SetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetSpeed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetLookAheadTime
==============
*/

void __fastcall G_VehicleScriptCmd_GetLookAheadTime(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetLookAheadTime@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_ClearLookAtEnt
==============
*/

void __fastcall G_VehicleScriptCmd_ClearLookAtEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_ClearLookAtEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_HeliSetGoal
==============
*/

void __fastcall G_VehicleScriptCmd_HeliSetGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_HeliSetGoal@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_CanTurretTargetPoint
==============
*/

void __fastcall G_VehicleScriptCmd_CanTurretTargetPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_CanTurretTargetPoint@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetTargetYaw
==============
*/

void __fastcall G_VehicleScriptCmd_SetTargetYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetTargetYaw@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScript_GetField
==============
*/

void __fastcall G_VehicleScript_GetField(scrContext_t *scrContext, Vehicle *veh, int offset)
{
  ?G_VehicleScript_GetField@@YAXAEAUscrContext_t@@PEAUVehicle@@H@Z(scrContext, veh, offset);
}

/*
==============
G_VehicleScriptCmd_Precache
==============
*/

void __fastcall G_VehicleScriptCmd_Precache(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_Precache@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_ClearTargetYaw
==============
*/

void __fastcall G_VehicleScriptCmd_ClearTargetYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_ClearTargetYaw@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetArray
==============
*/

void __fastcall G_VehicleScriptCmd_GetArray(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_GetArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScriptCmd_ClearTurretTargetEnt
==============
*/

void __fastcall G_VehicleScriptCmd_ClearTurretTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_ClearTurretTargetEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetSpawnerArray
==============
*/

void __fastcall G_VehicleScriptCmd_GetSpawnerArray(scrContext_t *scrContext)
{
  ?G_VehicleScriptCmd_GetSpawnerArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_VehicleScript_CheckVehicleSuspended
==============
*/

bool __fastcall G_VehicleScript_CheckVehicleSuspended(scrContext_t *scrContext, scr_entref_t entref)
{
  return ?G_VehicleScript_CheckVehicleSuspended@@YA_NAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_VehicleGetInputValue
==============
*/

void __fastcall G_VehicleScriptCmd_VehicleGetInputValue(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_VehicleGetInputValue@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetVelocity
==============
*/

void __fastcall G_VehicleScriptCmd_GetVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetVelocity@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedReverse
==============
*/

void __fastcall G_VehicleScriptCmd_GetTopSpeedReverse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetTopSpeedReverse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_IsSuspended
==============
*/

void __fastcall G_VehicleScriptCmd_IsSuspended(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_IsSuspended@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_ResumeSpeed
==============
*/

void __fastcall G_VehicleScriptCmd_ResumeSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_ResumeSpeed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_FireWeapon
==============
*/

void __fastcall G_VehicleScriptCmd_FireWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_FireWeapon@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetWeapon
==============
*/

void __fastcall G_VehicleScriptCmd_SetWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetWeapon@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_NearGoalNotifyDist
==============
*/

void __fastcall G_VehicleScriptCmd_NearGoalNotifyDist(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_NearGoalNotifyDist@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedForward
==============
*/

void __fastcall G_VehicleScriptCmd_GetTopSpeedForward(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_GetTopSpeedForward@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_SetVehicleTeam
==============
*/

void __fastcall G_VehicleScriptCmd_SetVehicleTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  ?G_VehicleScriptCmd_SetVehicleTeam@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_VehicleScriptCmd_StopPath
==============
*/
void G_VehicleScriptCmd_StopPath(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  bool v5; 
  GVehicles *VehicleSystem; 
  unsigned int v7; 
  BgVehiclePhysicsManager *v8; 
  BgVehiclePhysicsComponent *ComponentBy; 
  int v10; 
  unsigned int vehicleId; 
  bool v12; 
  unsigned int count; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1694, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( (unsigned int)(vehicle->drivingState - 2) <= 1 )
    {
      v5 = 0;
      v12 = 0;
      if ( Scr_GetNumParam(scrContext) )
      {
        v5 = Scr_GetInt(scrContext, 0) != 0;
        v12 = v5;
      }
      if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      {
        VehicleSystem = GVehicles::GetVehicleSystem();
        v7 = 0;
        GVehicles::PhysicsGetPathComponentTypes(&count);
        if ( count )
        {
          do
          {
            if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
              __debugbreak();
            v8 = GVehicles::ms_gVehiclesSystem->PhysicsGetVehiclePhysicsManager(GVehicles::ms_gVehiclesSystem);
            BgVehiclePhysicsManager::GetComponentIdByType(v8, (unsigned int)&vehicleId, vehicle->physicsVehicle);
            if ( vehicleId && (vehicleId & 0xFF0000) < 0x20000 )
            {
              ComponentBy = BgVehiclePhysicsManager::GetComponentById<BgVehiclePhysicsComponent>(v8, (VehiclePhysicsComponentId)vehicleId);
              if ( !ComponentBy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1723, ASSERT_TYPE_ASSERT, "(vehComp)", (const char *)&queryFormat, "vehComp") )
                __debugbreak();
              ((void (__fastcall *)(GVehicles *, _QWORD))VehicleSystem->PhysicsDestroyComponent)(VehicleSystem, ComponentBy->m_id.id);
            }
            ++v7;
          }
          while ( v7 < count );
          v5 = v12;
        }
      }
      v10 = 5;
      if ( v5 )
        v10 = 0;
      vehicle->drivingState = v10;
    }
    else
    {
      Com_PrintWarning(15, "WARNING: vehicle is not currently doing a path");
    }
  }
}

/*
==============
G_VehicleScriptCmd_PausePath
==============
*/
void G_VehicleScriptCmd_PausePath(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  Vehicle *vehicle; 
  float v6; 
  int v10; 
  GVehicles *VehicleSystem; 
  unsigned int v12; 
  BgVehiclePhysicsManager *v13; 
  BgVehiclePhysicsComponent *ComponentBy; 
  unsigned int count; 
  unsigned int vehicleId; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1760, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( (unsigned int)(vehicle->drivingState - 2) <= 1 )
    {
      v6 = FLOAT_3_4028235e38;
      if ( Scr_GetNumParam(scrContext) )
      {
        *(double *)&v2 = Scr_GetFloat(scrContext, 0);
        count = v2;
        _XMM6 = v2;
        if ( (v2 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1772, ASSERT_TYPE_SANITY, "( !IS_NAN( pauseTime ) )", (const char *)&queryFormat, "!IS_NAN( pauseTime )") )
          __debugbreak();
        __asm
        {
          vcmpltss xmm0, xmm6, cs:__real@3a83126f
          vblendvps xmm0, xmm6, xmm7, xmm0
        }
        v6 = *(float *)&_XMM0;
        count = _XMM0;
      }
      v10 = 0;
      if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        goto LABEL_22;
      VehicleSystem = GVehicles::GetVehicleSystem();
      v12 = 0;
      GVehicles::PhysicsGetPathComponentTypes(&count);
      if ( *(float *)&count == 0.0 )
        goto LABEL_22;
      do
      {
        v13 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
        BgVehiclePhysicsManager::GetComponentIdByType(v13, (unsigned int)&vehicleId, vehicle->physicsVehicle);
        if ( vehicleId && (vehicleId & 0xFF0000) < 0x20000 )
        {
          ComponentBy = BgVehiclePhysicsManager::GetComponentById<BgVehiclePhysicsComponent>(v13, (VehiclePhysicsComponentId)vehicleId);
          if ( !ComponentBy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1790, ASSERT_TYPE_ASSERT, "(vehComp)", (const char *)&queryFormat, "vehComp") )
            __debugbreak();
          BgVehiclePhysicsComponent::SetPause(ComponentBy, v6);
          ++v10;
        }
        ++v12;
      }
      while ( v12 < count );
      if ( !v10 )
LABEL_22:
        Com_PrintWarning(15, "WARNING: vehicle does not have a path component to be paused");
    }
    else
    {
      Com_PrintWarning(15, "WARNING: vehicle is not currently doing a path");
    }
  }
}

/*
==============
G_VehicleScriptCmd_ResumePath
==============
*/
void G_VehicleScriptCmd_ResumePath(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  int v5; 
  GVehicles *VehicleSystem; 
  unsigned int v7; 
  BgVehiclePhysicsManager *v8; 
  BgVehiclePhysicsComponent *ComponentBy; 
  unsigned int count; 
  unsigned int vehicleId; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1830, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( (unsigned int)(vehicle->drivingState - 2) <= 1 )
    {
      v5 = 0;
      if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        goto LABEL_19;
      VehicleSystem = GVehicles::GetVehicleSystem();
      v7 = 0;
      GVehicles::PhysicsGetPathComponentTypes(&count);
      if ( !count )
        goto LABEL_19;
      do
      {
        v8 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
        BgVehiclePhysicsManager::GetComponentIdByType(v8, (unsigned int)&vehicleId, vehicle->physicsVehicle);
        if ( vehicleId && (vehicleId & 0xFF0000) < 0x20000 )
        {
          ComponentBy = BgVehiclePhysicsManager::GetComponentById<BgVehiclePhysicsComponent>(v8, (VehiclePhysicsComponentId)vehicleId);
          if ( !ComponentBy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1851, ASSERT_TYPE_ASSERT, "(vehComp)", (const char *)&queryFormat, "vehComp") )
            __debugbreak();
          if ( ComponentBy->m_pauseTime < 0.0 )
            Com_PrintWarning(15, "WARNING: vehicle path is not paused anyways");
          BgVehiclePhysicsComponent::Resume(ComponentBy);
          ++v5;
        }
        ++v7;
      }
      while ( v7 < count );
      if ( !v5 )
LABEL_19:
        Com_PrintWarning(15, "WARNING: vehicle does not have a path component to be resumed");
    }
    else
    {
      Com_PrintWarning(15, "WARNING: vehicle is not currently doing a path");
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetSwitchNode
==============
*/
void G_VehicleScriptCmd_SetSwitchNode(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  __int16 NodeIndex; 
  __int16 v6; 
  VehiclePathPos *p_pathPos; 
  __int16 v8; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1892, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    NodeIndex = G_VehiclePathScr_GetNodeIndex(scrContext, 0);
    v6 = G_VehiclePathScr_GetNodeIndex(scrContext, 1u);
    p_pathPos = &vehicle->pathPos;
    v8 = v6;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
    {
      if ( ComponentPathFollower->m_pathType != PATH_RADIANT )
      {
        Com_PrintWarning(15, "SetSwitchNode called on a non-radiant spline BgVehicleComponentPathFollower. No effect.");
        return;
      }
      p_pathPos = &ComponentPathFollower->m_path.m_vpp;
    }
    G_VehiclePath_SetPathPosSwitchNode(p_pathPos, NodeIndex, v8);
  }
}

/*
==============
G_VehicleScriptCmd_SetWaitSpeed
==============
*/
void G_VehicleScriptCmd_SetWaitSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->waitSpeed = *(float *)&Float * 17.6;
    if ( (float)(*(float *)&Float * 17.6) < 0.0 )
      Scr_ParamError(COM_ERR_2672, scrContext, 0, "Cannot have a negative wait speed on a vehicle");
  }
}

/*
==============
G_VehicleScriptCmd_SetSpeed
==============
*/
void G_VehicleScriptCmd_SetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  __int128 v8; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  BgVehicleComponentPathFollower *v11; 
  __int128 v13; 
  __int128 v16; 
  GVehicles *VehicleSystem; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    *(double *)&v2 = Scr_GetFloat(scrContext, 0);
    v8 = v2;
    *(float *)&v8 = *(float *)&v2 * 17.6;
    _XMM1 = v8;
    __asm { vmaxss  xmm6, xmm1, xmm9 }
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    v11 = ComponentPathFollower;
    if ( ComponentPathFollower )
    {
      BgVehicleComponentPathFollower::SetSpeed(ComponentPathFollower, *(float *)&_XMM6);
      if ( Scr_GetNumParam(scrContext) > 1 )
      {
        *(double *)&v2 = Scr_GetFloat(scrContext, 1u);
        v13 = v2;
        *(float *)&v13 = *(float *)&v2 * 17.6;
        _XMM1 = v13;
        __asm { vmaxss  xmm7, xmm1, xmm9 }
        if ( Scr_GetNumParam(scrContext) <= 2 )
        {
          *(float *)&_XMM6 = *(float *)&_XMM7 * 0.5;
        }
        else
        {
          *(double *)&v2 = Scr_GetFloat(scrContext, 2u);
          v16 = v2;
          *(float *)&v16 = *(float *)&v2 * 17.6;
          _XMM1 = v16;
          __asm { vmaxss  xmm6, xmm1, xmm9 }
        }
        BgVehicleComponentPathFollower::SetAcceleration(v11, *(float *)&_XMM7);
        BgVehicleComponentPathFollower::SetDeceleration(v11, *(float *)&_XMM6);
      }
    }
    else if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      GVehicles::PhysicsSetSpeed(VehicleSystem, vehicle->physicsVehicle, *(float *)&_XMM6);
    }
    else
    {
      G_VehicleScript_SetSpeedInternal(scrContext, VehicleEntity);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetSpeedImmediate
==============
*/
void G_VehicleScriptCmd_SetSpeedImmediate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  double Float; 
  const VehicleDef *ServerDef; 
  float v9; 
  float v10; 
  float v11; 
  __int128 v12; 
  float v13; 
  float manualSpeed; 
  vec3_t forward; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2087, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
    {
      Float = Scr_GetFloat(scrContext, 0);
      BgVehicleComponentPathFollower::SetSpeedImmediate(ComponentPathFollower, *(float *)&Float * 17.6);
    }
    else
    {
      ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
      G_VehicleScript_SetSpeedInternal(scrContext, VehicleEntity);
      if ( ServerDef->type != VEH_HELICOPTER || vehicle->drivingState != VEH_DRIVE_AI || (v9 = vehicle->heliPathPos.goalPosition.v[0], v10 = VehicleEntity->r.currentOrigin.v[0], v9 == v10) && VehicleEntity->r.currentOrigin.v[1] == vehicle->heliPathPos.goalPosition.v[1] && VehicleEntity->r.currentOrigin.v[2] == vehicle->heliPathPos.goalPosition.v[2] )
      {
        AngleVectors(&VehicleEntity->r.currentAngles, &forward, NULL, NULL);
      }
      else
      {
        v12 = LODWORD(vehicle->heliPathPos.goalPosition.v[1]);
        v11 = vehicle->heliPathPos.goalPosition.v[1] - VehicleEntity->r.currentOrigin.v[1];
        v13 = vehicle->heliPathPos.goalPosition.v[2] - VehicleEntity->r.currentOrigin.v[2];
        *(float *)&v12 = fsqrt((float)((float)(v11 * v11) + (float)((float)(v9 - v10) * (float)(v9 - v10))) + (float)(v13 * v13));
        _XMM4 = v12;
        __asm
        {
          vcmpless xmm0, xmm4, cs:__real@80000000
          vblendvps xmm0, xmm4, xmm1, xmm0
        }
        forward.v[0] = (float)(v9 - v10) * (float)(1.0 / *(float *)&_XMM0);
        forward.v[2] = v13 * (float)(1.0 / *(float *)&_XMM0);
        forward.v[1] = v11 * (float)(1.0 / *(float *)&_XMM0);
      }
      manualSpeed = vehicle->manualSpeed;
      vehicle->speed = manualSpeed;
      vehicle->pathSpeed = manualSpeed;
      vehicle->phys.vel.v[0] = manualSpeed * forward.v[0];
      vehicle->phys.vel.v[1] = manualSpeed * forward.v[1];
      vehicle->phys.vel.v[2] = manualSpeed * forward.v[2];
    }
  }
}

/*
==============
G_VehicleScriptCmd_RCPlaneSetTopSpeed
==============
*/
void G_VehicleScriptCmd_RCPlaneSetTopSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  G_VehicleScriptCmd_RCPlaneSetPropertyMPH(scrContext, entref, BgVehiclePhysicsRCPlane::SetTopSpeedNoBoosting);
}

/*
==============
G_VehicleScriptCmd_RCPlaneSetTopSpeedBoost
==============
*/
void G_VehicleScriptCmd_RCPlaneSetTopSpeedBoost(scrContext_t *scrContext, scr_entref_t entref)
{
  G_VehicleScriptCmd_RCPlaneSetPropertyMPH(scrContext, entref, BgVehiclePhysicsRCPlane::SetTopSpeedBoosting);
}

/*
==============
G_VehicleScriptCmd_RCPlaneSetMinSpeed
==============
*/
void G_VehicleScriptCmd_RCPlaneSetMinSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
    G_VehicleScriptCmd_RCPlaneSetPropertyMPH(scrContext, entref, BgVehiclePhysicsRCPlane::SetMinSpeed);
}

/*
==============
G_VehicleScriptCmd_InvokeTriggers
==============
*/
void G_VehicleScriptCmd_InvokeTriggers(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2237, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
    if ( !ServerDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2241, ASSERT_TYPE_ASSERT, "(vehDef)", (const char *)&queryFormat, "vehDef") )
      __debugbreak();
    if ( ServerDef->type != VEH_HELICOPTER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2242, ASSERT_TYPE_ASSERT, "(vehDef->type == VEH_HELICOPTER)", (const char *)&queryFormat, "vehDef->type == VEH_HELICOPTER") )
      __debugbreak();
    vehicle->heliPathPos.touchTriggers = Scr_GetInt(scrContext, 0) == 1;
  }
}

/*
==============
G_VehicleScriptCmd_BreakGlass
==============
*/
void G_VehicleScriptCmd_BreakGlass(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2272, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
    if ( !ServerDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2276, ASSERT_TYPE_ASSERT, "(vehDef)", (const char *)&queryFormat, "vehDef") )
      __debugbreak();
    if ( ServerDef->type != VEH_HELICOPTER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2277, ASSERT_TYPE_ASSERT, "(vehDef->type == VEH_HELICOPTER)", (const char *)&queryFormat, "vehDef->type == VEH_HELICOPTER") )
      __debugbreak();
    vehicle->heliPathPos.breakGlass = Scr_GetInt(scrContext, 0) == 1;
  }
}

/*
==============
G_VehicleScriptCmd_RotateYaw
==============
*/
void G_VehicleScriptCmd_RotateYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  double Float; 
  float v7; 
  double v10; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2308, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
    if ( ServerDef->type != VEH_TREADED || vehicle->drivingState != VEH_DRIVE_PATH_CONSTRAINED )
      Scr_Error(COM_ERR_2678, scrContext, "Vehicle_RotateYaw() only works with tanks on paths\n");
    vehicle->rotateToYawMode = VEH_ROTATE_TO_ACCEL;
    Float = Scr_GetFloat(scrContext, 0);
    v7 = *(float *)&Float * 0.0027777778;
    _XMM0 = 0i64;
    __asm { vroundss xmm4, xmm0, xmm3, 1 }
    vehicle->rotateToYaw = (float)(v7 - *(float *)&_XMM4) * 360.0;
    if ( Scr_GetNumParam(scrContext) <= 1 )
    {
      vehicle->rotateToYawAccel = ServerDef->rotAccel;
    }
    else
    {
      v10 = Scr_GetFloat(scrContext, 1u);
      vehicle->rotateToYawAccel = *(float *)&v10;
      if ( *(float *)&v10 < 0.0 )
        Scr_ParamError(COM_ERR_2679, scrContext, 1u, "Accel must be positive\n");
    }
  }
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedForward
==============
*/
void G_VehicleScriptCmd_GetTopSpeedForward(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int *vehicle; 
  const VehicleDef *ServerDef; 
  double TopSpeedFwd; 
  GVehicles *VehicleSystem; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = (unsigned int *)G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    ServerDef = G_Vehicle_GetServerDef(vehicle[163]);
    if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
    {
      *(float *)&TopSpeedFwd = ServerDef->topSpeed;
    }
    else if ( BGVehicles::PhysicsIsValid(vehicle[161]) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      TopSpeedFwd = GVehicles::PhysicsGetTopSpeedFwd(VehicleSystem, vehicle[161]);
    }
    else
    {
      LODWORD(TopSpeedFwd) = vehicle[361];
    }
    Scr_AddFloat(scrContext, *(float *)&TopSpeedFwd * 0.056818184);
  }
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedReverse
==============
*/
void G_VehicleScriptCmd_GetTopSpeedReverse(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int *vehicle; 
  const VehicleDef *ServerDef; 
  double TopSpeedBwd; 
  GVehicles *VehicleSystem; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = (unsigned int *)G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    ServerDef = G_Vehicle_GetServerDef(vehicle[163]);
    if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
    {
      *(float *)&TopSpeedBwd = ServerDef->topSpeed;
    }
    else if ( BGVehicles::PhysicsIsValid(vehicle[161]) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      TopSpeedBwd = GVehicles::PhysicsGetTopSpeedBwd(VehicleSystem, vehicle[161]);
    }
    else
    {
      LODWORD(TopSpeedBwd) = vehicle[362];
    }
    Scr_AddFloat(scrContext, *(float *)&TopSpeedBwd * 0.056818184);
  }
}

/*
==============
G_VehicleScriptCmd_GetTopSpeedRotational
==============
*/
void G_VehicleScriptCmd_GetTopSpeedRotational(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int *vehicle; 
  const VehicleDef *ServerDef; 
  float rotRate; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = (unsigned int *)G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    ServerDef = G_Vehicle_GetServerDef(vehicle[163]);
    if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
    {
      rotRate = ServerDef->rotRate;
    }
    else if ( BGVehicles::PhysicsIsValid(vehicle[161]) )
    {
      rotRate = 0.0;
    }
    else
    {
      rotRate = *((float *)vehicle + 363);
    }
    Scr_AddFloat(scrContext, rotRate);
  }
}

/*
==============
G_VehicleScriptCmd_GetSpeed
==============
*/
void G_VehicleScriptCmd_GetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v6; 
  BgVehiclePhysics *ObjectById; 
  __int128 v8; 
  __int128 v10; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2491, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      v6 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v6, vehicle->physicsVehicle);
      if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2498, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      v8 = LODWORD(ObjectById->m_transform.m[0].v[1]);
      *(float *)&v8 = (float)((float)(ObjectById->m_transform.m[0].v[1] * ObjectById->m_linearVelocityWs.v[1]) + (float)(ObjectById->m_transform.m[0].v[0] * ObjectById->m_linearVelocityWs.v[0])) + (float)(ObjectById->m_transform.m[0].v[2] * ObjectById->m_linearVelocityWs.v[2]);
      v10 = v8 & _xmm;
      *(float *)&v10 = *(float *)&v10 * 0.056818184;
      _XMM3 = v10;
      __asm
      {
        vcmpless xmm1, xmm3, cs:__real@3d4ccccd
        vblendvps xmm1, xmm3, xmm0, xmm1
      }
    }
    else
    {
      *(float *)&_XMM1 = vehicle->speed * 0.056818184;
    }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
  }
}

/*
==============
G_VehicleScriptCmd_GetVelocity
==============
*/
void G_VehicleScriptCmd_GetVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v4; 
  scrContext_t *v5; 
  vec3_t *p_linearVelocity; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  vec3_t linearVelocity; 

  v4 = G_VehicleScript_CheckVehicleSuspended(scrContext, entref);
  v5 = scrContext;
  if ( v4 )
  {
    p_linearVelocity = &vec3_origin;
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2538, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      GVehicles::PhysicsGetLinearVelocity(VehicleSystem, vehicle->physicsVehicle, &linearVelocity);
      p_linearVelocity = &linearVelocity;
    }
    else
    {
      p_linearVelocity = &vehicle->phys.vel;
    }
    v5 = scrContext;
  }
  Scr_AddVector(v5, p_linearVelocity->v);
}

/*
==============
G_VehicleScriptCmd_GetAngularVelocity
==============
*/
void G_VehicleScriptCmd_GetAngularVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  vec3_t *p_out; 
  Vehicle *vehicle; 
  bool v6; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v8; 
  BgVehiclePhysics *ObjectById; 
  vec3_t out; 
  vec3_t velWs; 
  vec3_t outVelLs; 
  tmat33_t<vec3_t> axis; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    p_out = &vec3_origin;
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2580, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    v6 = 0;
    if ( Scr_GetNumParam(scrContext) )
      v6 = Scr_GetInt(scrContext, 0) != 0;
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      v8 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v8, vehicle->physicsVehicle);
      velWs = ObjectById->m_angularVelocityWs;
      if ( v6 )
      {
        out.v[0] = 57.295776 * velWs.v[0];
        out.v[1] = 57.295776 * velWs.v[1];
        out.v[2] = 57.295776 * velWs.v[2];
      }
      else
      {
        BgVehiclePhysics::ComputeVelocityLocalSpace(ObjectById, &velWs, &outVelLs);
        out.v[0] = 57.295776 * outVelLs.v[0];
        out.v[1] = 57.295776 * outVelLs.v[1];
        out.v[2] = 57.295776 * outVelLs.v[2];
      }
    }
    else if ( v6 )
    {
      AnglesToAxis(&vehicle->phys.angles, &axis);
      AxisTransformVec3(&axis, &vehicle->phys.rotVel, &out);
    }
    else
    {
      out = vehicle->phys.rotVel;
    }
    p_out = &out;
  }
  Scr_AddVector(scrContext, p_out->v);
}

/*
==============
G_VehicleScriptCmd_GetBodyVelocity
==============
*/
void G_VehicleScriptCmd_GetBodyVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddVector(scrContext, vec3_origin.v);
  }
  else
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    Scr_AddVector(scrContext, VehicleEntity->vehicle->phys.bodyVel.v);
  }
}

/*
==============
G_VehicleScriptCmd_GetSteering
==============
*/
void G_VehicleScriptCmd_GetSteering(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  float v6; 
  float maxSteeringAngle; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2685, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    v6 = 0.0;
    maxSteeringAngle = G_Vehicle_GetServerDef(vehicle->defIndex)->vehiclePhysicsDef.maxSteeringAngle;
    if ( maxSteeringAngle > 0.0 )
      v6 = VehicleEntity->s.lerp.u.actor.impactVector.v[1] / maxSteeringAngle;
    Scr_AddFloat(scrContext, v6);
  }
}

/*
==============
G_VehicleScriptCmd_GetThrottle
==============
*/
void G_VehicleScriptCmd_GetThrottle(scrContext_t *scrContext, scr_entref_t entref)
{
  double InputControl; 
  Vehicle *vehicle; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    LODWORD(InputControl) = 0;
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2719, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    InputControl = GVehicles::PhysicsGetInputControl(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle, 0);
  }
  Scr_AddFloat(scrContext, *(float *)&InputControl);
}

/*
==============
G_VehicleScriptCmd_TurnEngineOff
==============
*/
void G_VehicleScriptCmd_TurnEngineOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2746, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    VehicleEntity->s.lerp.u.anonymous.data[1] |= 0x20u;
  }
}

/*
==============
G_VehicleScriptCmd_TurnEngineOn
==============
*/
void G_VehicleScriptCmd_TurnEngineOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2774, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    VehicleEntity->s.lerp.u.anonymous.data[1] &= ~0x20u;
  }
}

/*
==============
G_VehicleScriptCmd_GetGoalSpeedMPH
==============
*/
void G_VehicleScriptCmd_GetGoalSpeedMPH(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    Scr_AddFloat(scrContext, VehicleEntity->vehicle->manualSpeed * 0.056818184);
  }
}

/*
==============
G_VehicleScriptCmd_SetAcceleration
==============
*/
void G_VehicleScriptCmd_SetAcceleration(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2826, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2829, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->manualAccel = *(float *)&Float * 17.6;
  }
}

/*
==============
G_VehicleScriptCmd_SetDeceleration
==============
*/
void G_VehicleScriptCmd_SetDeceleration(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2854, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2857, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->manualDecel = *(float *)&Float * 17.6;
  }
}

/*
==============
G_VehicleScriptCmd_ResumeSpeed
==============
*/
void G_VehicleScriptCmd_ResumeSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
    {
      BgVehicleComponentPathFollower::SetSpeedImmediate(ComponentPathFollower, -1.0);
    }
    else
    {
      vehicle->manualMode = VEH_MANUAL_TRANS;
      Float = Scr_GetFloat(scrContext, 0);
      vehicle->manualAccel = *(float *)&Float * 17.6;
      if ( (float)(*(float *)&Float * 17.6) < 0.0 )
        Scr_ParamError(COM_ERR_2680, scrContext, 0, "Cannot set negative acceleration on vehicle");
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetLookAheadTime
==============
*/
void G_VehicleScriptCmd_SetLookAheadTime(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
      __asm { vmaxss  xmm0, xmm0, xmm1 }
      ComponentPathFollower->m_lookAheadTime = *(float *)&_XMM0;
    }
    else
    {
      Com_PrintWarning(15, "SetLookAheadTime() called on a non-physics vehicle or not following a path");
    }
  }
}

/*
==============
G_VehicleScriptCmd_GetLookAheadTime
==============
*/
void G_VehicleScriptCmd_GetLookAheadTime(scrContext_t *scrContext, scr_entref_t entref)
{
  float m_lookAheadTime; 
  Vehicle *vehicle; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    m_lookAheadTime = 0.0;
  }
  else
  {
    m_lookAheadTime = 0.0;
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
      m_lookAheadTime = ComponentPathFollower->m_lookAheadTime;
    else
      Com_PrintWarning(15, "GetLookAheadTime() called on a non-physics vehicle or not following a path");
  }
  Scr_AddFloat(scrContext, m_lookAheadTime);
}

/*
==============
G_VehicleScriptCmd_SetYawSpeed
==============
*/
void G_VehicleScriptCmd_SetYawSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  float v6; 
  double v7; 
  float v8; 
  float v9; 
  double v10; 
  float v11; 
  unsigned int NumParam; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2681, scrContext, "Vehicle must be a helicopter.");
    Float = Scr_GetFloat(scrContext, 0);
    v6 = *(float *)&Float;
    v7 = Scr_GetFloat(scrContext, 1u);
    v8 = *(float *)&v7;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v7 = Scr_GetFloat(scrContext, 2u);
    v9 = *(float *)&v7;
    if ( Scr_GetNumParam(scrContext) <= 3 )
    {
      v11 = FLOAT_0_1;
    }
    else
    {
      v10 = Scr_GetFloat(scrContext, 3u);
      v11 = *(float *)&v10;
      if ( *(float *)&v10 < 0.0 || *(float *)&v10 > 1.0 )
        Scr_ParamError(COM_ERR_2682, scrContext, 3u, "Overshoot must be in 0 to 1 range");
    }
    if ( v6 < 0.0 )
      Scr_ParamError(COM_ERR_2683, scrContext, 0, "Cannot set negative yaw speed on vehicle");
    if ( v8 < 0.0 )
      Scr_ParamError(COM_ERR_2684, scrContext, 1u, "Cannot set negative yaw acceleration on vehicle");
    if ( v9 <= 0.0 )
    {
      NumParam = Scr_GetNumParam(scrContext);
      Scr_ParamError(COM_ERR_2685, scrContext, (NumParam > 2) + 1, "Cannot set zero yaw deceleration on vehicle");
    }
    G_VehicleHeli_PathSetYawSpeed(&vehicle->heliPathPos, v6, v8, v9, v11);
  }
}

/*
==============
G_VehicleScriptCmd_SetYawSpeedByName
==============
*/
void G_VehicleScriptCmd_SetYawSpeedByName(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const char *String; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    String = Scr_GetString(scrContext, 0);
    G_VehicleHeli_PathSetYawSpeedMode(&vehicle->heliPathPos, String);
  }
}

/*
==============
G_VehicleScriptCmd_SetMaxPitchRoll
==============
*/
void G_VehicleScriptCmd_SetMaxPitchRoll(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  double v6; 
  bool v7; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3082, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_Error(COM_ERR_2686, scrContext, "Max Pitch Roll only valid for helicopters");
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->heliPathPos.maxPitchAngle = *(float *)&Float;
    v6 = Scr_GetFloat(scrContext, 1u);
    v7 = vehicle->heliPathPos.maxPitchAngle >= 0.0;
    vehicle->heliPathPos.maxRollAngle = *(float *)&v6;
    if ( !v7 )
      Scr_ParamError(COM_ERR_2687, scrContext, 0, "Cannot set negative max pitch");
    if ( vehicle->heliPathPos.maxRollAngle < 0.0 )
      Scr_ParamError(COM_ERR_2688, scrContext, 1u, "Cannot set negative max roll");
  }
}

/*
==============
G_VehicleScriptCmd_SetAirResitance
==============
*/
void G_VehicleScriptCmd_SetAirResitance(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Float = Scr_GetFloat(scrContext, 0);
    if ( *(float *)&Float < 1.0 )
    {
      Scr_ParamError(COM_ERR_2689, scrContext, 0, "Max air resistance speed must be >= 1 MPH");
      *(float *)&Float = FLOAT_1_0;
    }
    G_VehicleHeli_PathSetAirResistance(&vehicle->heliPathPos, *(float *)&Float);
  }
}

/*
==============
G_VehicleScriptCmd_SetTurningAbility
==============
*/
void G_VehicleScriptCmd_SetTurningAbility(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  double v6; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->heliPathPos.turningAbility = *(float *)&Float;
    v6 = I_fclamp(*(float *)&Float, 0.001, 1.0);
    vehicle->heliPathPos.turningAbility = *(float *)&v6;
  }
}

/*
==============
G_VehicleScriptCmd_SetJitterParams
==============
*/
void G_VehicleScriptCmd_SetJitterParams(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  double v6; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Scr_GetVector(scrContext, 0, &vehicle->jitter.jitterOffsetRange);
    if ( Scr_GetNumParam(scrContext) <= 1 )
      *(float *)&Float = FLOAT_0_5;
    else
      Float = Scr_GetFloat(scrContext, 1u);
    vehicle->jitter.jitterPeriodMin = (int)(float)(*(float *)&Float * 1000.0);
    if ( Scr_GetNumParam(scrContext) <= 2 )
      *(float *)&v6 = FLOAT_1_0;
    else
      v6 = Scr_GetFloat(scrContext, 2u);
    *(_QWORD *)&vehicle->jitter.jitterPeriodMax = (unsigned int)(int)(float)(*(float *)&v6 * 1000.0);
  }
}

/*
==============
G_VehicleScriptCmd_SetHoverParams
==============
*/
void G_VehicleScriptCmd_SetHoverParams(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  double v6; 
  double v7; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->heliPathPos.hover.hoverRadius = *(float *)&Float;
    if ( Scr_GetNumParam(scrContext) > 1 )
    {
      v6 = Scr_GetFloat(scrContext, 1u);
      vehicle->heliPathPos.hover.hoverSpeed = *(float *)&v6;
      if ( Scr_GetNumParam(scrContext) > 2 )
      {
        v7 = Scr_GetFloat(scrContext, 2u);
        vehicle->heliPathPos.hover.hoverAccel = *(float *)&v7;
      }
    }
  }
}

/*
==============
G_VehicleScriptCmd_JoltBody
==============
*/
void G_VehicleScriptCmd_JoltBody(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  int NumParam; 
  double Float; 
  float v7; 
  double v8; 
  float v9; 
  double v10; 
  float v11; 
  __int128 v12; 
  float v13; 
  vec3_t dir; 
  vec3_t vectorValue; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    NumParam = Scr_GetNumParam(scrContext);
    Scr_GetVector(scrContext, 0, &vectorValue);
    Float = Scr_GetFloat(scrContext, 1u);
    v7 = *(float *)&Float;
    if ( NumParam <= 2 )
    {
      v9 = 0.0;
      v11 = 0.0;
    }
    else
    {
      v8 = Scr_GetFloat(scrContext, 2u);
      v9 = *(float *)&v8;
      if ( *(float *)&v8 < 0.0 || *(float *)&v8 > 1.0 )
        Scr_ParamError(COM_ERR_2690, scrContext, 2u, "Speed fraction must be between [0,1]");
      v10 = Scr_GetFloat(scrContext, 3u);
      v11 = *(float *)&v10 * 17.6;
      if ( (float)(*(float *)&v10 * 17.6) < 0.0 )
        Scr_ParamError(COM_ERR_2691, scrContext, 3u, "Deceleration can't be negative");
    }
    dir.v[0] = VehicleEntity->r.currentOrigin.v[0] - vectorValue.v[0];
    v12 = LODWORD(VehicleEntity->r.currentOrigin.v[1]);
    dir.v[1] = VehicleEntity->r.currentOrigin.v[1] - vectorValue.v[1];
    v13 = VehicleEntity->r.currentOrigin.v[2] - vectorValue.v[2];
    *(float *)&v12 = fsqrt((float)((float)(dir.v[1] * dir.v[1]) + (float)(dir.v[0] * dir.v[0])) + (float)(v13 * v13));
    _XMM1 = v12;
    __asm
    {
      vcmpless xmm0, xmm1, cs:__real@80000000
      vblendvps xmm0, xmm1, xmm9, xmm0
    }
    dir.v[0] = dir.v[0] * (float)(1.0 / *(float *)&_XMM0);
    dir.v[2] = v13 * (float)(1.0 / *(float *)&_XMM0);
    dir.v[1] = dir.v[1] * (float)(1.0 / *(float *)&_XMM0);
    G_Vehicle_JoltBody(VehicleEntity, &dir, v7, v9, v11);
  }
}

/*
==============
G_VehicleScriptCmd_MakeCorpse
==============
*/
void G_VehicleScriptCmd_MakeCorpse(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  const char *v5; 
  unsigned int defIndex; 
  GVehicles *VehicleSystem; 
  int number; 
  Ai_Asm *v9; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( EntHandle::isDefined(&VehicleEntity->r.ownerNum) )
    {
      v5 = j_va("Can't make corpse on a vehicle that a player is using");
      Scr_Error(COM_ERR_2692, scrContext, v5);
    }
    else
    {
      defIndex = VehicleEntity->vehicle->defIndex;
      G_Vehicle_FreeEntity(VehicleEntity);
      VehicleSystem = GVehicles::GetVehicleSystem();
      VehicleSystem->SetVehicleCorpse(VehicleSystem, VehicleEntity, defIndex);
      AI_BT_FreeTreeInstance(VehicleEntity->s.number);
      number = VehicleEntity->s.number;
      v9 = Ai_Asm::Singleton();
      Ai_Asm::FreeInstance(v9, NULL, number);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SuspendVehicle
==============
*/
void G_VehicleScriptCmd_SuspendVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  const char *v5; 
  GVehicles *VehicleSystem; 
  GVehicleSuspendManager *SuspendManager; 

  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != HALF_HALF && (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3362, ASSERT_TYPE_ASSERT, "( Com_GameMode_GetActiveGameMode() == GameModeType::MP || Com_GameMode_GetActiveGameMode() == GameModeType::CP )", "SuspendVehicle() only supported in multiplayer") )
    __debugbreak();
  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( EntHandle::isDefined(&VehicleEntity->r.ownerNum) )
    {
      v5 = j_va("Can't suspend vehicle that a player is using");
      Scr_Error(COM_ERR_5853, scrContext, v5);
    }
    else
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      SuspendManager = GVehicles::GetSuspendManager(VehicleSystem);
      GVehicleSuspendManager::SuspendVehicle(SuspendManager, VehicleEntity);
    }
  }
}

/*
==============
G_VehicleScriptCmd_WakeUpVehicle
==============
*/
void G_VehicleScriptCmd_WakeUpVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GVehicles *VehicleSystem; 
  GVehicleSuspendManager *SuspendManager; 
  scr_string_t classname; 
  const char *v8; 
  const char *v9; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != HALF_HALF && (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3399, ASSERT_TYPE_ASSERT, "( Com_GameMode_GetActiveGameMode() == GameModeType::MP || Com_GameMode_GetActiveGameMode() == GameModeType::CP )", "WakeUpVehicle() only supported in multiplayer") )
    __debugbreak();
  if ( entclass )
  {
    Scr_ObjectError(COM_ERR_5854, scrContext, "Not an entity");
  }
  else
  {
    if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 188, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entnum, 2048) )
      __debugbreak();
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 189, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( v4->s.eType == ET_SCRIPTMOVER && v4->classname == scr_const.script_model )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      SuspendManager = GVehicles::GetSuspendManager(VehicleSystem);
      GVehicleSuspendManager::WakeUpVehicle(SuspendManager, v4);
    }
    else
    {
      classname = v4->classname;
      if ( classname )
        v8 = SL_ConvertToString(classname);
      else
        v8 = "<unnamed>";
      v9 = j_va("Trying to call WakeUpVehicle() on an entity that is not a Script Model. '%s'", v8);
      Scr_Error(COM_ERR_5855, scrContext, v9);
    }
  }
}

/*
==============
G_VehicleScriptCmd_IsSuspended
==============
*/
void G_VehicleScriptCmd_IsSuspended(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *v4; 
  GVehicles *VehicleSystem; 
  EntityClass entclass; 

  entclass = entref.entclass;
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != HALF_HALF && (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3437, ASSERT_TYPE_ASSERT, "( Com_GameMode_GetActiveGameMode() == GameModeType::MP || Com_GameMode_GetActiveGameMode() == GameModeType::CP )", "IsSuspended() only supported in multiplayer") )
    __debugbreak();
  if ( entclass || entref.entnum >= 0x800 || (v4 = &g_entities[entref.entnum], VehicleSystem = GVehicles::GetVehicleSystem(), !GVehicles::IsSuspended(VehicleSystem, v4)) )
  {
    G_VehicleScript_GetVehicleEntity(scrContext, entref);
    Scr_AddBool(scrContext, 0);
  }
  else
  {
    Scr_AddBool(scrContext, 1);
  }
}

/*
==============
G_VehicleScriptCmd_GetWheelSurface
==============
*/
void G_VehicleScriptCmd_GetWheelSurface(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  scr_string_t ConstString; 
  VehicleType type; 
  unsigned int v8; 
  scr_string_t v9; 
  const char *v10; 
  __int64 v11; 
  int v12; 
  const char *v13; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
LABEL_26:
    v13 = "none";
    goto LABEL_27;
  }
  vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3482, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
  ConstString = Scr_GetConstString(scrContext, 0);
  type = ServerDef->type;
  v8 = 0;
  v9 = ConstString;
  if ( ((type - 1) & 0xFC) == 0 && type != VEH_BOAT )
  {
    v10 = j_va("GetWheelSurface() is not set up to work with vehicle type [%s]\n", ServerDef->name);
    Scr_Error(COM_ERR_2693, scrContext, v10);
  }
  if ( v9 == scr_const.front_left )
    goto LABEL_20;
  if ( v9 != scr_const.front_right )
  {
    if ( v9 == scr_const.back_left )
    {
      v8 = 2;
      v11 = 484i64;
      goto LABEL_21;
    }
    if ( v9 == scr_const.back_right )
    {
      v8 = 3;
      v11 = 488i64;
      goto LABEL_21;
    }
    if ( v9 == scr_const.middle_left )
    {
      v8 = 4;
      v11 = 492i64;
      goto LABEL_21;
    }
    if ( v9 == scr_const.middle_right )
    {
      v8 = 5;
      v11 = 496i64;
      goto LABEL_21;
    }
    Scr_ParamError(COM_ERR_2694, scrContext, 0, "Valid wheel names are: [front_left, front_right, back_left, back_right, middle_left, middle_right]\n");
LABEL_20:
    v11 = 476i64;
    goto LABEL_21;
  }
  v8 = 1;
  v11 = 480i64;
LABEL_21:
  if ( ServerDef->type == VEH_WHEELS_4 && v8 > 3 )
    Scr_ParamError(COM_ERR_2695, scrContext, 0, "Vehicle has no middle wheels\n");
  v12 = *(_DWORD *)((char *)&vehicle->ent + v11);
  if ( !v12 )
    goto LABEL_26;
  v13 = Com_SurfaceTypeToName(v12);
LABEL_27:
  Scr_AddString(scrContext, v13);
}

/*
==============
G_VehicleScriptCmd_GetVehicleOwner
==============
*/
void G_VehicleScriptCmd_GetVehicleOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  EntHandle *p_ownerNum; 
  const gentity_s *v5; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    p_ownerNum = &G_VehicleScript_GetVehicleEntity(scrContext, entref)->r.ownerNum;
    if ( EntHandle::isDefined(p_ownerNum) )
    {
      v5 = EntHandle::ent(p_ownerNum);
      GScr_AddEntity(v5);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetVehicleLookatText
==============
*/
void G_VehicleScriptCmd_SetVehicleLookatText(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  scr_string_t ConstString; 
  scr_string_t ConstIString; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    ConstString = Scr_GetConstString(scrContext, 0);
    Scr_SetString(&vehicle->lookAtText0, ConstString);
    if ( Scr_GetNumParam(scrContext) > 1 )
    {
      ConstIString = Scr_GetConstIString(scrContext, 1u);
      Scr_SetString(&vehicle->lookAtText1, ConstIString);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetVehicleTeam
==============
*/
void G_VehicleScriptCmd_SetVehicleTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  scr_string_t ConstString; 
  unsigned int v6; 
  const scr_string_t **v7; 
  const scr_string_t **v8; 
  unsigned int i; 
  const char *v10; 
  const char *v11; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3597, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( !VehicleEntity->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3601, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ConstString = Scr_GetConstString(scrContext, 0);
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    {
      v6 = 1;
      v7 = &S_TEAMS_SP_SCR_STRINGS_4[1];
      while ( ConstString != **v7 )
      {
        ++v6;
        ++v7;
        if ( v6 >= 5 )
        {
          if ( ConstString != scr_const.only_sky )
            goto LABEL_25;
          v6 = 0;
          break;
        }
      }
    }
    else if ( ConstString == scr_const.freelook )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_teams.h", 112, ASSERT_TYPE_ASSERT, "(!Com_GameMode_SupportsFeature( Com_GameMode_Feature::TEAMS_SINGLEPLAYER ))", "%s\n\tFreeLook is MP only", "!Com_GameMode_SupportsFeature( Com_GameMode_Feature::TEAMS_SINGLEPLAYER )") )
        __debugbreak();
      v6 = 203;
    }
    else
    {
      v6 = 0;
      v8 = S_TEAMS_MP_SCR_STRINGS_4;
      for ( i = 0; i < 0xCB; ++i )
      {
        if ( ConstString == **v8 )
        {
          v6 = i;
          goto LABEL_27;
        }
        ++v8;
      }
      if ( ConstString != scr_const.none && ConstString != scr_const.neutral && ConstString != scr_const.only_sky )
      {
LABEL_25:
        v10 = SL_ConvertToString(ConstString);
        v11 = j_va("unknown team '%s'", v10);
        Scr_Error(COM_ERR_2696, scrContext, v11);
        return;
      }
    }
LABEL_27:
    VehicleEntity->vehicle->team = v6;
    if ( EntHandle::isDefined(&VehicleEntity->r.ownerNum) )
      EntHandle::ent(&VehicleEntity->r.ownerNum);
    G_Vehicle_SetEntityStateTeam(VehicleEntity, (team_t)VehicleEntity->vehicle->team);
  }
}

/*
==============
G_VehicleScriptCmd_NearGoalNotifyDist
==============
*/
void G_VehicleScriptCmd_NearGoalNotifyDist(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    Float = Scr_GetFloat(scrContext, 0);
    vehicle->heliPathPos.nearGoalNotifyDist = *(float *)&Float;
  }
}

/*
==============
G_VehicleScriptCmd_SetGoalPos
==============
*/
void G_VehicleScriptCmd_SetGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  bool v6; 
  char v7[8]; 
  vec3_t vectorValue; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 3673, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Scr_GetVector(scrContext, 0, &vectorValue);
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      ((void (__fastcall *)(GVehicles *, char *, _QWORD, vec3_t *))VehicleSystem->PhysicsCreateComponent_GoStraightTo)(VehicleSystem, v7, vehicle->physicsVehicle, &vectorValue);
      vehicle->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
    }
    else
    {
      if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
        Scr_ObjectError(COM_ERR_2697, scrContext, "Vehicle must be a helicopter.");
      if ( vehicle->manualSpeed == 0.0 || vehicle->manualAccel == 0.0 || vehicle->manualDecel == 0.0 )
        Scr_Error(COM_ERR_2698, scrContext, "Speed and acceleration must not be zero before setting goal pos");
      vehicle->manualMode = VEH_MANUAL_ON;
      vehicle->drivingState = VEH_DRIVE_AI;
      v6 = Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u) != 0;
      vehicle->useDroneLogic = 0;
      G_VehicleHeli_PathSetGoalPos(&vehicle->heliPathPos, &vectorValue, v6);
    }
  }
}

/*
==============
G_VehicleScriptCmd_EnableCollisionCallback
==============
*/
void G_VehicleScriptCmd_EnableCollisionCallback(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v6; 
  BgVehiclePhysics *ObjectById; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      v6 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v6, vehicle->physicsVehicle);
      if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 4686, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      ObjectById->m_callbackScript = Scr_GetInt(scrContext, 0) != 0;
    }
    else
    {
      Com_PrintWarning(15, "WARNING: VehPhys_EnableCollisionCallback() called on a non-physics vehicle");
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetHornSound
==============
*/
void G_VehicleScriptCmd_SetHornSound(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v6; 
  BgVehiclePhysics *ObjectById; 
  const char *String; 
  unsigned int v9; 
  const char *v10; 
  char v11; 
  char v12; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      v6 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v6, vehicle->physicsVehicle);
      if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 4721, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      String = Scr_GetString(scrContext, 0);
      v9 = 0;
      v10 = String;
      if ( String )
      {
        v11 = *String;
        if ( v11 )
        {
          v9 = 5381;
          do
          {
            ++v10;
            v12 = v11 | 0x20;
            if ( (unsigned int)(v11 - 65) >= 0x1A )
              v12 = v11;
            v9 = 65599 * v9 + v12;
            v11 = *v10;
          }
          while ( *v10 );
          if ( !v9 )
            v9 = 1;
        }
      }
      ObjectById->SetSoundHorn(ObjectById, v9);
    }
    else
    {
      Com_PrintWarning(15, "WARNING: SetVehicleHornSound() called on a non-physics vehicle");
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetGoalYaw
==============
*/
void G_VehicleScriptCmd_SetGoalYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2737, scrContext, "Vehicle must be a helicopter.");
    Float = Scr_GetFloat(scrContext, 0);
    G_VehicleHeli_PathSetGoalYaw(&vehicle->heliPathPos, *(float *)&Float);
  }
}

/*
==============
G_VehicleScriptCmd_ClearGoalYaw
==============
*/
void G_VehicleScriptCmd_ClearGoalYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2738, scrContext, "Vehicle must be a helicopter.");
    G_VehicleHeli_PathClearGoalYaw(&vehicle->heliPathPos);
  }
}

/*
==============
G_VehicleScriptCmd_SetTargetYaw
==============
*/
void G_VehicleScriptCmd_SetTargetYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2739, scrContext, "Vehicle must be a helicopter.");
    Float = Scr_GetFloat(scrContext, 0);
    G_VehicleHeli_PathSetTargetYaw(&vehicle->heliPathPos, *(float *)&Float);
  }
}

/*
==============
G_VehicleScriptCmd_ClearTargetYaw
==============
*/
void G_VehicleScriptCmd_ClearTargetYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2740, scrContext, "Vehicle must be a helicopter.");
    G_VehicleHeli_PathClearTargetYaw(&vehicle->heliPathPos);
  }
}

/*
==============
G_VehicleScriptCmd_HeliSetGoal
==============
*/
void G_VehicleScriptCmd_HeliSetGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  double Float; 
  double v6; 
  double v7; 
  VariableType Type; 
  double v9; 
  double v10; 
  HeliPathNodeData node; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( G_Vehicle_GetServerDef(vehicle->defIndex)->type != VEH_HELICOPTER )
      Scr_ObjectError(COM_ERR_2741, scrContext, "Vehicle must be a helicopter.");
    Scr_GetVector(scrContext, 0, &node.origin);
    node.setSpeed = 0;
    if ( Scr_GetType(scrContext, 1u) )
    {
      node.setSpeed = 1;
      Float = Scr_GetFloat(scrContext, 1u);
      node.speed = *(float *)&Float;
    }
    node.hasAccel = 0;
    if ( Scr_GetType(scrContext, 2u) )
    {
      node.hasAccel = 1;
      v6 = Scr_GetFloat(scrContext, 2u);
      node.accel = *(float *)&v6;
    }
    node.hasDecel = 0;
    if ( Scr_GetType(scrContext, 3u) )
    {
      node.hasDecel = 1;
      v7 = Scr_GetFloat(scrContext, 3u);
      node.decel = *(float *)&v7;
    }
    Type = Scr_GetType(scrContext, 4u);
    node.goalYawDefined = Type != VAR_UNDEFINED;
    if ( Type == VAR_UNDEFINED || (node.setGoalYaw = 1, !Scr_GetInt(scrContext, 4u)) )
      node.setGoalYaw = 0;
    node.angleVehicleDefined = Scr_GetType(scrContext, 5u) != VAR_UNDEFINED;
    v9 = Scr_GetFloat(scrContext, 6u);
    node.setAirResistance = 0;
    node.yaw = *(float *)&v9;
    if ( Scr_GetType(scrContext, 7u) )
    {
      node.setAirResistance = 1;
      v10 = Scr_GetFloat(scrContext, 7u);
      node.airResistance = *(float *)&v10;
    }
    node.hasDelay = Scr_GetInt(scrContext, 8u) != 0;
    node.stopNode = Scr_GetInt(scrContext, 9u) != 0;
    node.unload = Scr_GetInt(scrContext, 0xAu) != 0;
    node.flagWait = Scr_GetInt(scrContext, 0xBu) != 0;
    node.endOfPath = Scr_GetInt(scrContext, 0xCu) != 0;
    G_VehicleHeli_PathFromVeh(&vehicle->heliPathPos, vehicle);
    vehicle->manualMode = VEH_MANUAL_ON;
    vehicle->drivingState = VEH_DRIVE_AI;
    G_VehicleHeli_PathSetGoal(&vehicle->heliPathPos, &node);
    vehicle->manualAccel = vehicle->heliPathPos.manualAccel;
    vehicle->manualDecel = vehicle->heliPathPos.manualDecel;
    vehicle->manualSpeed = vehicle->heliPathPos.manualSpeed;
  }
}

/*
==============
G_VehicleScriptCmd_SetTurretTargetVec
==============
*/
void G_VehicleScriptCmd_SetTurretTargetVec(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const char *v6; 
  const char *v7; 
  vec3_t vectorValue; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5080, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( vehicle->drivingState == VEH_DRIVE_PLAYER )
    {
      v6 = j_va("Can't set target position on player's vehicle");
      Scr_Error(COM_ERR_2742, scrContext, v6);
    }
    if ( (float)VehicleEntity->health <= 0.0 )
    {
      v7 = j_va("Vehicle must have health to control the turret");
      Scr_Error(COM_ERR_2743, scrContext, v7);
    }
    vehicle->hasTarget = 1;
    vehicle->targetEnt = 2047;
    Scr_GetVector(scrContext, 0, &vectorValue);
    vehicle->targetOrigin = vectorValue;
    *(_QWORD *)vehicle->targetOffset.v = 0i64;
    vehicle->targetOffset.v[2] = 0.0;
  }
}

/*
==============
G_VehicleScriptCmd_SetTurretTargetEnt
==============
*/
void G_VehicleScriptCmd_SetTurretTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const char *v7; 
  gentity_s *Entity; 
  int number; 
  vec3_t vectorValue; 
  __int128 v11; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    v11 = v2;
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( (float)VehicleEntity->health <= 0.0 )
    {
      v7 = j_va("Vehicle must have health to control the turret");
      Scr_Error(COM_ERR_2744, scrContext, v7);
    }
    Entity = GScr_GetEntity(0);
    if ( Scr_GetNumParam(scrContext) <= 1 )
    {
      vectorValue.v[0] = 0.0;
      vectorValue.v[1] = 0.0;
      vectorValue.v[2] = 0.0;
    }
    else
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
    }
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 4196, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    vehicle->hasTarget = 1;
    if ( Entity )
      number = Entity->s.number;
    else
      number = 2047;
    vehicle->targetEnt = number;
    if ( Entity )
      Entity->flags.m_flags[0] |= 0x400000u;
    vehicle->targetOffset = vectorValue;
    *(_QWORD *)vehicle->targetOrigin.v = 0i64;
    vehicle->targetOrigin.v[2] = 0.0;
  }
}

/*
==============
G_VehicleScriptCmd_ClearTurretTargetEnt
==============
*/
void G_VehicleScriptCmd_ClearTurretTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 4211, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( vehicle->drivingState != VEH_DRIVE_PLAYER )
      vehicle->hasTarget = 0;
    vehicle->targetEnt = 2047;
    *(_QWORD *)vehicle->targetOrigin.v = 0i64;
    *(_QWORD *)&vehicle->targetOrigin.z = 0i64;
    *(_QWORD *)&vehicle->targetOffset.y = 0i64;
  }
}

/*
==============
G_VehicleScriptCmd_CanTurretTargetPoint
==============
*/
void G_VehicleScriptCmd_CanTurretTargetPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  int v7; 
  int Int; 
  int skipEntity1; 
  int barrel; 
  int turret_base; 
  __int128 v12; 
  float v18; 
  float v20; 
  int v21; 
  vec3_t angles; 
  vec3_t vectorValue; 
  vec3_t outPos; 
  vec3_t vec; 
  tmat43_t<vec3_t> outTagMat; 
  tmat33_t<vec3_t> out; 
  tmat33_t<vec3_t> v28; 
  tmat33_t<vec3_t> axis; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
    goto LABEL_21;
  VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
  vehicle = VehicleEntity->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5199, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
  Scr_GetVector(scrContext, 0, &vectorValue);
  v7 = 0;
  Int = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  skipEntity1 = 2047;
  if ( Scr_GetNumParam(scrContext) > 2 )
    skipEntity1 = GScr_GetEntity(2u)->s.number;
  barrel = vehicle->boneIndex.barrel;
  if ( barrel < 0 )
  {
    Scr_Error(COM_ERR_2745, scrContext, "Vehicle has no tag [tag_barrel]\n");
    return;
  }
  G_Utils_DObjGetWorldBoneIndexPos(VehicleEntity, barrel, &outPos);
  turret_base = vehicle->boneIndex.turret_base;
  if ( turret_base == -1 )
    AnglesToAxis(&vehicle->phys.angles, (tmat33_t<vec3_t> *)&outTagMat);
  else
    G_Utils_DObjGetWorldBoneIndexMatrix(VehicleEntity, turret_base, &outTagMat);
  v12 = LODWORD(vectorValue.v[1]);
  *(float *)&v12 = fsqrt((float)((float)((float)(vectorValue.v[1] - outPos.v[1]) * (float)(vectorValue.v[1] - outPos.v[1])) + (float)((float)(vectorValue.v[0] - outPos.v[0]) * (float)(vectorValue.v[0] - outPos.v[0]))) + (float)((float)(vectorValue.v[2] - outPos.v[2]) * (float)(vectorValue.v[2] - outPos.v[2])));
  _XMM4 = v12;
  __asm
  {
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
  }
  vec.v[0] = (float)(vectorValue.v[0] - outPos.v[0]) * (float)(1.0 / *(float *)&_XMM0);
  vec.v[2] = (float)(vectorValue.v[2] - outPos.v[2]) * (float)(1.0 / *(float *)&_XMM0);
  vec.v[1] = (float)(vectorValue.v[1] - outPos.v[1]) * (float)(1.0 / *(float *)&_XMM0);
  vectoangles(&vec, &angles);
  AnglesToAxis(&angles, &axis);
  MatrixTranspose((const tmat33_t<vec3_t> *)&outTagMat, &out);
  MatrixMultiply(&axis, &out, &v28);
  AxisToAngles(&v28, &angles);
  _XMM7 = 0i64;
  __asm { vroundss xmm2, xmm7, xmm1, 1 }
  v18 = (float)((float)(0.0027777778 * angles.v[0]) - *(float *)&_XMM2) * 360.0;
  __asm { vroundss xmm3, xmm7, xmm2, 1 }
  v20 = (float)((float)(0.0027777778 * angles.v[1]) - *(float *)&_XMM3) * 360.0;
  angles.v[1] = v20;
  angles.v[0] = v18;
  if ( v18 < COERCE_FLOAT(LODWORD(ServerDef->turretVertSpanUp) ^ _xmm) || v18 > ServerDef->turretVertSpanDown || v20 < COERCE_FLOAT(LODWORD(ServerDef->turretHorizSpanRight) ^ _xmm) || v20 > ServerDef->turretHorizSpanLeft )
  {
LABEL_21:
    v21 = 0;
  }
  else if ( Int )
  {
    LOBYTE(v7) = PhysicsQuery_LegacySightTrace(PHYSICS_WORLD_ID_FIRST, &outPos, &vectorValue, &bounds_origin, VehicleEntity->s.number, skipEntity1, 2049) == 0;
    v21 = v7;
  }
  else
  {
    v21 = 1;
  }
  Scr_AddInt(scrContext, v21);
}

/*
==============
G_VehicleScriptCmd_SetLookAtEnt
==============
*/
void G_VehicleScriptCmd_SetLookAtEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const char *v6; 
  const char *v7; 
  const gentity_s *Entity; 
  const char *v9; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5283, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( vehicle->drivingState == VEH_DRIVE_PLAYER )
    {
      v6 = j_va("Can't set target on player's vehicle");
      Scr_Error(COM_ERR_2746, scrContext, v6);
    }
    if ( (float)VehicleEntity->health <= 0.0 )
    {
      v7 = j_va("Vehicle must have health to control");
      Scr_Error(COM_ERR_2747, scrContext, v7);
    }
    Entity = GScr_GetEntity(0);
    if ( !Entity )
    {
      v9 = j_va("Invalid entity");
      Scr_Error(COM_ERR_2748, scrContext, v9);
    }
    EntHandle::setEnt(&vehicle->lookAtEnt, Entity);
  }
}

/*
==============
G_VehicleScriptCmd_ClearLookAtEnt
==============
*/
void G_VehicleScriptCmd_ClearLookAtEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    EntHandle::setEnt(&VehicleEntity->vehicle->lookAtEnt, NULL);
  }
}

/*
==============
G_VehicleScriptCmd_SetWeapon
==============
*/
void G_VehicleScriptCmd_SetWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  const char *String; 
  Weapon *BaseWeaponForName; 
  GWeaponMap *Instance; 
  Weapon result; 
  __m256i v9; 
  __int128 v10; 
  __int64 v11; 
  int v12; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    String = Scr_GetString(scrContext, 0);
    BaseWeaponForName = BG_FindBaseWeaponForName(&result, String);
    v9 = *(__m256i *)&BaseWeaponForName->weaponIdx;
    v10 = *(_OWORD *)&BaseWeaponForName->attachmentVariationIndices[5];
    v11 = *(_QWORD *)&BaseWeaponForName->attachmentVariationIndices[21];
    v12 = *(_DWORD *)&BaseWeaponForName->weaponCamo;
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 448, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    Instance->SetWeapon(Instance, &VehicleEntity->s.weaponHandle, (const Weapon *)&v9);
  }
}

/*
==============
G_VehicleScriptCmd_SetVehicleDef
==============
*/
void G_VehicleScriptCmd_SetVehicleDef(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  unsigned int outIndex; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Entity = GetEntity(entref);
    if ( Entity->vehicle )
    {
      String = Scr_GetString(scrContext, 0);
      if ( !G_Vehicle_GetServerDefIndex(String, &outIndex) )
      {
        v6 = j_va("SetVehicleDef: Can't find vehicle def '%s'", String);
        Scr_ParamError(COM_ERR_2752, scrContext, 0, v6);
      }
      Entity->vehicle->defIndex = outIndex;
      Entity->s.lerp.u.anonymous.data[0] = (outIndex << 7) | Entity->s.lerp.u.anonymous.data[0] & 0x7F;
    }
    else
    {
      Scr_Error(COM_ERR_2751, scrContext, "SetVehicleDef must be called on a vehicle.\n");
    }
  }
}

/*
==============
G_VehicleScriptCmd_FireWeapon
==============
*/
void G_VehicleScriptCmd_FireWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 xmm6_0; 
  __int128 xmm7_0; 
  __int128 v4; 
  __int128 v5; 
  __int128 v6; 
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  const char *v12; 
  GWeaponMap *Instance; 
  const Weapon *Weapon; 
  const char *v15; 
  const char *v16; 
  __int64 v17; 
  double v18; 
  float v19; 
  const char *v20; 
  VehicleType type; 
  int barrel; 
  const char *v23; 
  const char *v24; 
  double Float; 
  float v26; 
  int v27; 
  scr_string_t ConstLowercaseString; 
  const char *v29; 
  const char *v30; 
  int v31; 
  const char *String; 
  scr_string_t v33; 
  const char *v34; 
  const char *v35; 
  const char *v36; 
  scr_string_t FlashTag; 
  const char *v38; 
  const char *v39; 
  const gentity_s *v40; 
  const playerState_s *EntityPlayerStateConst; 
  vec3_t *p_currentAngles; 
  __int128 v43; 
  float v44; 
  __int128 v45; 
  float v46; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  int v56; 
  gentity_s *Entity; 
  int Int; 
  const char *v59; 
  int v60; 
  const gentity_s *v61; 
  int v62; 
  __int64 gameTime; 
  int BoneIndex; 
  BgMissileFireParms *v65; 
  BgMissileFireParms *fireParms; 
  int fireTime; 
  int fireDelay[3]; 
  BgWeaponParms wp; 
  vec3_t v3; 
  __int128 vectorValue; 
  __int64 v72; 
  int v73; 
  vec3_t angles; 
  tmat43_t<vec3_t> v75; 
  vec3_t dir; 
  vec3_t v2; 
  tmat43_t<vec3_t> outTagMat; 
  __int128 v79; 
  __int128 v80; 
  __int128 v81; 
  __int128 v82; 
  __int128 v83; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    v82 = xmm7_0;
    v81 = v4;
    v80 = v5;
    v79 = v6;
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5502, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
    v65 = (BgMissileFireParms *)ServerDef;
    if ( (float)VehicleEntity->health <= 0.0 )
    {
      v12 = j_va("Vehicle must have health to control the turret");
      Scr_Error(COM_ERR_2753, scrContext, v12);
    }
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(Instance, VehicleEntity->s.weaponHandle);
    if ( !Weapon->weaponIdx )
    {
      v15 = SL_ConvertToString(VehicleEntity->targetname);
      v16 = j_va("Invalid weapon specified for [%s]\n", v15);
      Scr_Error(COM_ERR_2754, scrContext, v16);
    }
    wp.weapon = *Weapon;
    wp.isAlternate = 0;
    LODWORD(v17) = Weapon->weaponIdx;
    if ( (unsigned int)v17 > bg_lastParsedWeaponIndex )
    {
      LODWORD(gameTime) = Weapon->weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gameTime, bg_lastParsedWeaponIndex) )
        __debugbreak();
    }
    v17 = (unsigned __int16)v17;
    if ( !bg_weaponDefs[(unsigned __int16)v17] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    wp.weapDef = bg_weaponDefs[v17];
    v18 = BG_ADSSpread(&wp.weapon, wp.isAlternate, 0, 0);
    v19 = *(float *)&v18;
    if ( BG_GetWeaponType(&wp.weapon, wp.isAlternate) != WEAPTYPE_BULLET && BG_GetWeaponType(&wp.weapon, wp.isAlternate) != WEAPTYPE_PROJECTILE )
    {
      v20 = j_va("Vehicles only support bullet and projectile weapons\n");
      Scr_Error(COM_ERR_2755, scrContext, v20);
    }
    type = ServerDef->type;
    if ( type != VEH_PLANE && type != VEH_HELICOPTER )
    {
      barrel = vehicle->boneIndex.barrel;
      if ( barrel < 0 )
      {
        v23 = SL_ConvertToString(VehicleEntity->targetname);
        v24 = j_va("No tag_barrel for [%s]\n", v23);
        Scr_Error(COM_ERR_2756, scrContext, v24);
        barrel = vehicle->boneIndex.barrel;
      }
      G_Utils_DObjGetWorldBoneIndexMatrix(VehicleEntity, barrel, &outTagMat);
      if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
      {
        Float = Scr_GetFloat(scrContext, 3u);
        v26 = *(float *)&Float;
      }
      else
      {
        v26 = FLOAT_1_0;
      }
      LODWORD(dir.v[0]) = LODWORD(outTagMat.m[0].v[0]) ^ _xmm;
      LODWORD(dir.v[2]) = LODWORD(outTagMat.m[0].v[2]) ^ _xmm;
      LODWORD(dir.v[1]) = LODWORD(outTagMat.m[0].v[1]) ^ _xmm;
      G_Vehicle_JoltBody(VehicleEntity, &dir, v26, 0.0, 0.0);
    }
    v27 = -1;
    if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    {
      ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
      BoneIndex = SV_Game_DObjGetBoneIndex(VehicleEntity, ConstLowercaseString);
      if ( BoneIndex < 0 )
      {
        v29 = SL_ConvertToString(ConstLowercaseString);
        v30 = j_va("unknown tag '%s'", v29);
        Scr_ParamError(COM_ERR_2757, scrContext, 0, v30);
      }
    }
    else
    {
      BoneIndex = -1;
    }
    v31 = -1;
    if ( Scr_GetNumParam(scrContext) )
    {
      String = Scr_GetString(scrContext, 0);
      if ( *String )
      {
        v33 = Scr_GetConstLowercaseString(scrContext, 0);
        v31 = SV_Game_DObjGetBoneIndex(VehicleEntity, v33);
        if ( v31 < 0 )
        {
          v34 = SL_ConvertToString(VehicleEntity->targetname);
          v35 = j_va("No tag %s for [%s]\n", String, v34);
          Scr_Error(COM_ERR_2758, scrContext, v35);
        }
      }
    }
    if ( !Scr_GetNumParam(scrContext) || v31 < 0 )
    {
      if ( vehicle->boneIndex.flash[0] < 0 )
      {
        v36 = SL_ConvertToString(VehicleEntity->targetname);
        FlashTag = BG_Vehicle_GetFlashTag(0);
        v38 = SL_ConvertToString(FlashTag);
        v39 = j_va("No %s for [%s]\n", v38, v36);
        Scr_Error(COM_ERR_2759, scrContext, v39);
      }
      else
      {
        v31 = vehicle->boneIndex.flash[0];
      }
      if ( v31 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5584, ASSERT_TYPE_SANITY, "( boneIndex >= 0 )", (const char *)&queryFormat, "boneIndex >= 0") )
        __debugbreak();
    }
    G_Utils_DObjGetWorldBoneIndexMatrix(VehicleEntity, v31, &v75);
    if ( EntHandle::isDefined(&VehicleEntity->r.ownerNum) && !vehicle->turret.barrelBlocked && vehicle->targetEnt == 2047 )
    {
      v40 = EntHandle::ent(&VehicleEntity->r.ownerNum);
      EntityPlayerStateConst = G_GetEntityPlayerStateConst(v40);
      if ( !EntityPlayerStateConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5593, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&EntityPlayerStateConst->eFlags, GameModeFlagValues::ms_spValue, 0x1Cu) && Dvar_GetBool_Internal_DebugName(DVARBOOL_vehHelicopterHeadSwayDontSwayTheTurret, "vehHelicopterHeadSwayDontSwayTheTurret") && LOBYTE(v65->targetPosOrOffset.y) == 4 )
      {
        p_currentAngles = &VehicleEntity->r.currentAngles;
      }
      else
      {
        v43 = LODWORD(vehicle->targetOrigin.v[0]);
        v83 = xmm6_0;
        v45 = v43;
        v44 = *(float *)&v43 - v75.m[3].v[0];
        wp.gunForward.v[0] = *(float *)&v43 - v75.m[3].v[0];
        wp.gunForward.v[1] = vehicle->targetOrigin.v[1] - v75.m[3].v[1];
        v46 = vehicle->targetOrigin.v[2] - v75.m[3].v[2];
        *(float *)&v45 = fsqrt((float)((float)(v44 * v44) + (float)(wp.gunForward.v[1] * wp.gunForward.v[1])) + (float)(v46 * v46));
        _XMM1 = v45;
        __asm
        {
          vcmpless xmm0, xmm1, cs:__real@80000000
          vblendvps xmm0, xmm1, xmm9, xmm0
        }
        wp.gunForward.v[0] = (float)(1.0 / *(float *)&_XMM0) * v44;
        wp.gunForward.v[2] = v46 * (float)(1.0 / *(float *)&_XMM0);
        wp.gunForward.v[1] = (float)(1.0 / *(float *)&_XMM0) * wp.gunForward.v[1];
        vectoangles(v75.m, &angles);
        vectoangles(&wp.gunForward, &v2);
        AnglesSubtract(&angles, &v2, &v3);
        *(double *)&_XMM0 = I_fclamp(v3.v[0], COERCE_FLOAT(LODWORD(wp.weapDef->aimPadding) ^ _xmm), wp.weapDef->aimPadding);
        v3.v[0] = *(float *)&_XMM0;
        *(double *)&_XMM0 = I_fclamp(v3.v[1], COERCE_FLOAT(LODWORD(wp.weapDef->aimPadding) ^ _xmm), wp.weapDef->aimPadding);
        v3.v[1] = *(float *)&_XMM0;
        v3.v[2] = 0.0;
        AnglesSubtract(&angles, &v3, &angles);
        p_currentAngles = &angles;
      }
      AngleVectors(p_currentAngles, &wp.gunForward, NULL, NULL);
      v50 = wp.gunForward.v[2];
      v51 = wp.gunForward.v[1];
      v52 = wp.gunForward.v[0];
    }
    else
    {
      v52 = v75.m[0].v[0];
      v51 = v75.m[0].v[1];
      v50 = v75.m[0].v[2];
      wp.gunForward = v75.m[0];
    }
    *(_OWORD *)wp.right.v = *(_OWORD *)v75.row1.v;
    wp.up.v[1] = v75.m[2].v[1];
    wp.forward.v[0] = v52;
    wp.forward.v[1] = v51;
    wp.forward.v[2] = v50;
    wp.up.v[2] = v75.m[2].v[2];
    if ( vehicle->turret.barrelBlocked )
    {
      LODWORD(v53) = LODWORD(vehicle->turret.barrelOffset) ^ _xmm;
      v54 = (float)(v51 * v53) + v75.m[3].v[1];
      wp.muzzleTrace.v[0] = (float)(v52 * v53) + v75.m[3].v[0];
      v55 = (float)(v50 * v53) + v75.m[3].v[2];
    }
    else
    {
      v54 = v75.m[3].v[1];
      wp.muzzleTrace.v[0] = v75.m[3].v[0];
      v55 = v75.m[3].v[2];
    }
    wp.muzzleTrace.v[2] = v55;
    wp.muzzleTrace.v[1] = v54;
    if ( BG_GetWeaponType(&wp.weapon, wp.isAlternate) == WEAPTYPE_BULLET )
    {
      v56 = 0;
      v27 = G_Bullet_Fire(VehicleEntity, v19, &wp, VehicleEntity, WEAPON_HAND_DEFAULT, level.time);
    }
    else
    {
      if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
      {
        v73 = 1;
        vectorValue = 0ui64;
        v72 = 0i64;
        fireParms = (BgMissileFireParms *)&vectorValue;
        Entity = GScr_GetEntity(1u);
        if ( Entity )
          LODWORD(vectorValue) = Entity->s.number;
        else
          LODWORD(vectorValue) = 2047;
        if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
        {
          Scr_GetVector(scrContext, 2u, (vec3_t *)((char *)&vectorValue + 4));
        }
        else
        {
          *((float *)&vectorValue + 1) = 0.0;
          *((float *)&vectorValue + 2) = 0.0;
          *((float *)&vectorValue + 3) = 0.0;
        }
        if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
        {
          Int = Scr_GetInt(scrContext, 4u);
          if ( Int + 13 > 19 )
          {
            v59 = j_va("Invalid lock strength provided to FireWeapon(). (%i)\n", (unsigned int)Int);
            Scr_Error(COM_ERR_2760, scrContext, v59);
          }
          v56 = 0;
          v60 = 0;
          if ( Int > 0 )
            v60 = Int + 13;
          HIDWORD(v72) = v60;
        }
        else
        {
          v56 = 0;
          HIDWORD(v72) = 0;
        }
      }
      else
      {
        v56 = 0;
        fireParms = NULL;
      }
      v61 = G_Weapon_RocketLauncher_Fire(VehicleEntity, Weapon, 0, WEAPON_HAND_DEFAULT, v19, &wp, &vehicle->phys.vel, level.time, fireParms, 0);
      if ( !v61 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5681, ASSERT_TYPE_ASSERT, "(missile)", (const char *)&queryFormat, "missile") )
        __debugbreak();
      GScr_AddEntity(v61);
    }
    if ( !GWeapon::ms_gWeaponSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_weapon.h", 74, ASSERT_TYPE_ASSERT, "( ms_gWeaponSystem )", (const char *)&queryFormat, "ms_gWeaponSystem") )
      __debugbreak();
    GWeapon::ms_gWeaponSystem->FireVehicleWeaponSendClientEvent(GWeapon::ms_gWeaponSystem, VehicleEntity, 40, v27, BoneIndex);
    GScr_Weapon_AddParam(scrContext, Weapon, 0);
    GScr_Notify(VehicleEntity, scr_const.weapon_fired, 1u);
    BG_GetFireTime(NULL, NULL, &wp.weapon, wp.isAlternate, 0, 0, &fireTime, fireDelay);
    v62 = fireTime;
    LOBYTE(v56) = vehicle->turret.fireBarrel == 0;
    vehicle->turret.fireBarrel = v56;
    vehicle->turret.fireTime = v62;
  }
}

/*
==============
G_VehicleScriptCmd_VehicleTurretControlOn
==============
*/
void G_VehicleScriptCmd_VehicleTurretControlOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  gentity_s *Entity; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    Entity = GScr_GetEntity(0);
    G_Vehicle_LinkPlayerTurretControlOnly(VehicleEntity, Entity);
  }
}

/*
==============
G_VehicleScriptCmd_VehicleTurretControlOff
==============
*/
void G_VehicleScriptCmd_VehicleTurretControlOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  gentity_s *Entity; 
  int number; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  int v10; 
  __int64 v11; 
  int v12; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    Entity = GScr_GetEntity(0);
    if ( !EntHandle::isDefined(&Entity->r.ownerNum) || !EntHandle::isDefined(&VehicleEntity->r.ownerNum) )
      goto LABEL_21;
    number = Entity->r.ownerNum.number;
    if ( (unsigned int)(number - 1) >= 0x7FF )
    {
      v12 = 2047;
      v10 = number - 1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 231, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v10, v12) )
        __debugbreak();
    }
    v7 = Entity->r.ownerNum.number;
    if ( (unsigned int)(v7 - 1) >= 0x800 )
    {
      LODWORD(v11) = 2048;
      LODWORD(v9) = v7 - 1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v9, v11) )
        __debugbreak();
    }
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v8 = v7 - 1;
    if ( g_entities[v8].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
      __debugbreak();
    if ( !g_entityIsInUse[v8] )
    {
      LODWORD(v11) = Entity->r.ownerNum.number - 1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 232, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v11) )
        __debugbreak();
    }
    if ( Entity->r.ownerNum.number - 1 == VehicleEntity->s.number )
      G_Vehicle_UnlinkPlayer(VehicleEntity, Entity);
    else
LABEL_21:
      Com_PrintWarning(15, "WARNING: G_VehicleScriptCmd_VehicleTurretControlOff() called but the player isn't controlling a vehicle");
  }
}

/*
==============
G_VehicleScriptCmd_IsTurretReady
==============
*/
void G_VehicleScriptCmd_IsTurretReady(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  const char *v5; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddInt(scrContext, 0);
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5787, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( vehicle->drivingState != VEH_DRIVE_PLAYER )
    {
      v5 = j_va("Must be called on a player controlled vehicle");
      Scr_ObjectError(COM_ERR_2761, scrContext, v5);
    }
    Scr_AddInt(scrContext, vehicle->turret.fireTime <= 0);
  }
}

/*
==============
G_VehicleScriptCmd_VehicleDriveTo
==============
*/
void G_VehicleScriptCmd_VehicleDriveTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  double Float; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5824, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      G_VehicleScriptCmd_StartPathFind(scrContext, entref);
    }
    else
    {
      Scr_GetVector(scrContext, 0, &vehicle->goalPosition);
      vehicle->manualMode = VEH_MANUAL_ON;
      Float = Scr_GetFloat(scrContext, 1u);
      vehicle->manualSpeed = *(float *)&Float * 17.6;
      if ( (float)(*(float *)&Float * 17.6) < 0.0 )
        Scr_ParamError(COM_ERR_2762, scrContext, 1u, "Speed can't be negative");
      if ( vehicle->drivingState == VEH_DRIVE_PLAYER )
        Com_PrintWarning(15, "WARNING: VehicleDriveTo() called to a vehicle (%d) that is controlled by the player. You'd like Unlink the player maybe.'\n", (unsigned int)VehicleEntity->s.number);
      vehicle->drivingState = VEH_DRIVE_AI;
    }
  }
}

/*
==============
G_VehicleScriptCmd_DoSpawn
==============
*/
void G_VehicleScriptCmd_DoSpawn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  const char *v4; 
  gentity_s *v5; 
  double v6; 
  double v7; 
  double v8; 
  const char *v9; 
  scr_string_t targetname; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  scr_string_t classname; 
  double v15; 
  double v16; 
  double v17; 
  const char *v18; 
  scr_string_t v19; 
  const char *v20; 
  const char *v21; 
  const gentity_s *v22; 
  scr_string_t ConstString; 
  gentity_s *Entity; 
  const gentity_s *v25; 

  entnum = entref.entnum;
  if ( entref.entclass )
    Scr_ObjectError(COM_ERR_2659, scrContext, "not an entity");
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 751, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = "<unnamed>";
  v5 = &g_entities[entnum];
  if ( v5->s.eType != ET_VEHICLE_SPAWNER )
  {
    v6 = v5->r.currentOrigin.v[2];
    v7 = v5->r.currentOrigin.v[1];
    v8 = v5->r.currentOrigin.v[0];
    v9 = SL_ConvertToString(v5->classname);
    targetname = v5->targetname;
    v11 = v9;
    if ( targetname )
      v12 = SL_ConvertToString(targetname);
    else
      v12 = "<unnamed>";
    v13 = j_va("Trying to call a vehicle spawner command on a vehicle.\nEntity '%s' Classname '%s' at (%.0f %.0f %.0f)\n", v12, v11, v8, v7, v6);
    Scr_Error(COM_ERR_2660, scrContext, v13);
  }
  classname = v5->classname;
  if ( classname != scr_const.script_vehicle )
  {
    v15 = v5->r.currentOrigin.v[2];
    v16 = v5->r.currentOrigin.v[1];
    v17 = v5->r.currentOrigin.v[0];
    v18 = SL_ConvertToString(classname);
    v19 = v5->targetname;
    v20 = v18;
    if ( v19 )
      v4 = SL_ConvertToString(v19);
    v21 = j_va("Trying to call a vehicle spawner command on a non-script_vehicle entity.\nEntity '%s' Classname '%s' at (%.0f %.0f %.0f)\n", v4, v20, v17, v16, v15);
    Scr_Error(COM_ERR_2661, scrContext, v21);
  }
  v22 = NULL;
  ConstString = 0;
  if ( Scr_GetNumParam(scrContext) )
    ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Entity = GScr_GetEntity(1u);
    v22 = Entity;
    if ( Entity )
    {
      if ( !Entity->client )
        Scr_ParamError(COM_ERR_2763, scrContext, 1u, "Parameter must be a valid client");
    }
  }
  v25 = G_VehicleSpawner_DoSpawn(v5, ConstString, v22);
  if ( v25 )
    GScr_AddEntity(v25);
}

/*
==============
G_VehicleScriptPhysCmd_IsPhysVeh
==============
*/
void G_VehicleScriptPhysCmd_IsPhysVeh(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  const VehicleDef *ServerDef; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddBool(scrContext, 0);
  }
  else
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    ServerDef = G_Vehicle_GetServerDef(VehicleEntity->vehicle->defIndex);
    Scr_AddBool(scrContext, ServerDef->vehiclePhysicsDef.physicsEnabled);
  }
}

/*
==============
G_VehicleScriptPhysCmd_Crash
==============
*/
void G_VehicleScriptPhysCmd_Crash(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  int Int; 
  GVehicles *v7; 
  unsigned int physicsVehicle; 
  int v9; 
  int v10; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5945, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( !VehicleEntity->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 5946, ASSERT_TYPE_ASSERT, "(ent->vehicle)", (const char *)&queryFormat, "ent->vehicle") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2764, scrContext, "This vehicle is not a physics vehicle.");
    if ( Scr_GetNumParam(scrContext) )
      Int = Scr_GetInt(scrContext, 0);
    else
      Int = 0;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v7 = GVehicles::ms_gVehiclesSystem;
    physicsVehicle = vehicle->physicsVehicle;
    if ( Int )
    {
      GVehicles::PhysicsCrash(GVehicles::ms_gVehiclesSystem, physicsVehicle);
    }
    else
    {
      GVehicles::PhysicsEnableCrashing(GVehicles::ms_gVehiclesSystem, physicsVehicle, 1);
      GVehicles::PhysicsWreck(v7, vehicle->physicsVehicle);
    }
    v9 = G_rand() % 2;
    v10 = 0x20000000;
    if ( !v9 )
      v10 = 0x40000000;
    VehicleEntity->s.lerp.u.anonymous.data[1] |= v10;
    vehicle->drivingState = VEH_DRIVE_NONE;
  }
}

/*
==============
G_VehicleScriptCmd_SetTopSpeedForward
==============
*/
void G_VehicleScriptCmd_SetTopSpeedForward(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  double Float; 
  float v7; 
  GVehicles *VehicleSystem; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6000, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( !VehicleEntity->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6001, ASSERT_TYPE_ASSERT, "(ent->vehicle)", (const char *)&queryFormat, "ent->vehicle") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( Scr_GetNumParam(scrContext) )
    {
      Float = Scr_GetFloat(scrContext, 0);
      v7 = *(float *)&Float;
      if ( *(float *)&Float >= 0.0 )
        goto LABEL_13;
    }
    else
    {
      v7 = FLOAT_N1_0;
    }
    Scr_ObjectError(COM_ERR_2765, scrContext, "Top speed forward must be >= 0");
LABEL_13:
    VehicleEntity->vehicle->topSpeedForward = v7 * 17.6;
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      GVehicles::PhysicsSetTopSpeedFwd(VehicleSystem, vehicle->physicsVehicle, v7 * 17.6);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetTopSpeedReverse
==============
*/
void G_VehicleScriptCmd_SetTopSpeedReverse(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  double Float; 
  float v7; 
  unsigned int physicsVehicle; 
  GVehicles *VehicleSystem; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6046, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( !VehicleEntity->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6047, ASSERT_TYPE_ASSERT, "(ent->vehicle)", (const char *)&queryFormat, "ent->vehicle") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( Scr_GetNumParam(scrContext) )
    {
      Float = Scr_GetFloat(scrContext, 0);
      v7 = *(float *)&Float;
      if ( *(float *)&Float >= 0.0 )
        goto LABEL_13;
    }
    else
    {
      v7 = FLOAT_N1_0;
    }
    Scr_ObjectError(COM_ERR_2766, scrContext, "Top speed reverse must be >= 0");
LABEL_13:
    physicsVehicle = vehicle->physicsVehicle;
    vehicle->topSpeedReverse = v7 * 17.6;
    if ( BGVehicles::PhysicsIsValid(physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      GVehicles::PhysicsSetTopSpeedBwd(VehicleSystem, vehicle->physicsVehicle, v7 * 17.6);
    }
  }
}

/*
==============
G_VehicleScriptCmd_SetTopSpeedRotational
==============
*/
void G_VehicleScriptCmd_SetTopSpeedRotational(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  double Float; 
  float v6; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6092, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( !VehicleEntity->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6093, ASSERT_TYPE_ASSERT, "(ent->vehicle)", (const char *)&queryFormat, "ent->vehicle") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) )
    {
      Float = Scr_GetFloat(scrContext, 0);
      v6 = *(float *)&Float;
      if ( *(float *)&Float >= 0.0 )
      {
LABEL_13:
        VehicleEntity->vehicle->topSpeedYawRate = v6;
        return;
      }
    }
    else
    {
      v6 = FLOAT_N1_0;
    }
    Scr_ObjectError(COM_ERR_2767, scrContext, "Top rotational speed must be >= 0");
    goto LABEL_13;
  }
}

/*
==============
G_Vehicle_ClearDrivingState
==============
*/
void G_Vehicle_ClearDrivingState(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
    G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle->drivingState = VEH_DRIVE_NONE;
}

/*
==============
G_VehicleScriptPhysCmd_Launch
==============
*/
void G_VehicleScriptPhysCmd_Launch(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *v5; 
  double Mass; 
  unsigned int physicsVehicle; 
  double Float; 
  vec3_t vectorValue; 
  vec3_t impulse; 
  vec3_t origin; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2768, scrContext, "This vehicle is not a physics vehicle.");
    Scr_GetVector(scrContext, 0, &vectorValue);
    vectorValue.v[0] = 17.6 * vectorValue.v[0];
    vectorValue.v[1] = 17.6 * vectorValue.v[1];
    vectorValue.v[2] = 17.6 * vectorValue.v[2];
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v5 = GVehicles::ms_gVehiclesSystem;
    if ( Scr_GetNumParam(scrContext) <= 2 )
    {
      if ( Scr_GetNumParam(scrContext) <= 1 )
        LODWORD(Float) = 0;
      else
        Float = Scr_GetFloat(scrContext, 1u);
      GVehicles::PhysicsLaunch(v5, vehicle->physicsVehicle, &vectorValue, *(float *)&Float);
    }
    else
    {
      Scr_GetVector(scrContext, 2u, &origin);
      Mass = GVehicles::PhysicsGetMass(v5, vehicle->physicsVehicle);
      physicsVehicle = vehicle->physicsVehicle;
      impulse.v[2] = *(float *)&Mass * vectorValue.v[2];
      impulse.v[0] = *(float *)&Mass * vectorValue.v[0];
      impulse.v[1] = *(float *)&Mass * vectorValue.v[1];
      GVehicles::PhysicsAddImpulse(v5, physicsVehicle, &impulse, &origin);
    }
  }
}

/*
==============
G_VehicleScriptPhysCmd_DisableCrashing
==============
*/
void G_VehicleScriptPhysCmd_DisableCrashing(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *v5; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2769, scrContext, "This vehicle is not a physics vehicle.");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v5 = GVehicles::ms_gVehiclesSystem;
    if ( GVehicles::PhysicsIsWrecked(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2770, scrContext, "This vehicle at is already wrecked.");
    GVehicles::PhysicsEnableCrashing(v5, vehicle->physicsVehicle, 0);
  }
}

/*
==============
G_VehicleScriptPhysCmd_EnableCrashing
==============
*/
void G_VehicleScriptPhysCmd_EnableCrashing(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2771, scrContext, "This vehicle is not a physics vehicle.");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    GVehicles::PhysicsEnableCrashing(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle, 1);
  }
}

/*
==============
G_VehicleScriptPhysCmd_SetConveyorBelt
==============
*/
void G_VehicleScriptPhysCmd_SetConveyorBelt(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  __int128 v3; 
  Vehicle *vehicle; 
  double Float; 
  float v8; 
  double v9; 
  vec2_t c; 
  __int128 v11; 
  __int128 v12; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    v12 = v2;
    v11 = v3;
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2772, scrContext, "This vehicle is not a physics vehicle.");
    Float = Scr_GetFloat(scrContext, 1u);
    v8 = *(float *)&Float * 17.6;
    if ( (float)(*(float *)&Float * 17.6) < 0.0 )
    {
      Scr_ParamError(COM_ERR_2773, scrContext, 1u, "Cannot set negative speed on vehicle");
      v8 = 0.0;
    }
    v9 = Scr_GetFloat(scrContext, 0);
    FastSinCos(*(float *)&v9 * 0.017453292, (float *)&c + 1, (float *)&c);
    c.v[0] = v8 * c.v[0];
    c.v[1] = v8 * c.v[1];
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem", *(_QWORD *)&c) )
      __debugbreak();
    GVehicles::PhysicsSetConveyorVelocity(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle, &c);
  }
}

/*
==============
G_VehicleScriptPhysCmd_ForceKeyframedMotion
==============
*/
void G_VehicleScriptPhysCmd_ForceKeyframedMotion(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2774, scrContext, "This vehicle is not a physics vehicle.");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    GVehicles::PhysicsForceKeyframedMotion(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
  }
}

/*
==============
G_VehicleScriptPhysCmd_SetDefaultMotion
==============
*/
void G_VehicleScriptPhysCmd_SetDefaultMotion(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2775, scrContext, "This vehicle is not a physics vehicle.");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    GVehicles::PhysicsSetDefaultMotion(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
  }
}

/*
==============
G_VehicleScriptPhysCmd_Deactivate
==============
*/
void G_VehicleScriptPhysCmd_Deactivate(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_ObjectError(COM_ERR_2776, scrContext, "This vehicle is not a physics vehicle.");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    GVehicles::PhysicsDeactivateAlways(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
  }
}

/*
==============
G_VehicleScriptCmd_SetDriftVelocity
==============
*/
void G_VehicleScriptCmd_SetDriftVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6414, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6417, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Scr_GetVector(scrContext, 0, &vehicle->driftVelocity);
    vehicle->driftVelocity.v[0] = 17.6 * vehicle->driftVelocity.v[0];
    vehicle->driftVelocity.v[1] = 17.6 * vehicle->driftVelocity.v[1];
    vehicle->driftVelocity.v[2] = 17.6 * vehicle->driftVelocity.v[2];
  }
}

/*
==============
G_VehicleScriptCmd_SetDriftOffset
==============
*/
void G_VehicleScriptCmd_SetDriftOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  vec3_t *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    if ( !VehicleEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6444, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    vehicle = (vec3_t *)VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6447, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Scr_GetVector(scrContext, 0, vehicle + 6);
  }
}

/*
==============
G_VehicleScriptCmd_SetWorldCollisionCapsule
==============
*/
void G_VehicleScriptCmd_SetWorldCollisionCapsule(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 
  float v6; 
  double v7; 
  float v8; 
  double v9; 
  Vehicle *vehicle; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Entity = GetEntity(entref);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6481, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( Entity->vehicle )
    {
      if ( Scr_GetNumParam(scrContext) < 3 )
        Scr_Error(COM_ERR_2778, scrContext, "Usage: Vehicle_SetWorldCollisionCapsule( <radius>, <midz>, <height> ).");
      Float = Scr_GetFloat(scrContext, 0);
      v6 = *(float *)&Float;
      v7 = Scr_GetFloat(scrContext, 1u);
      v8 = *(float *)&v7;
      v9 = Scr_GetFloat(scrContext, 2u);
      vehicle = Entity->vehicle;
      vehicle->phys.bounds.midPoint.v[2] = v8;
      *(_QWORD *)vehicle->phys.bounds.midPoint.v = 0i64;
      vehicle->phys.bounds.halfSize.v[0] = v6;
      vehicle->phys.bounds.halfSize.v[1] = v6;
      vehicle->phys.bounds.halfSize.v[2] = *(float *)&v9;
    }
    else
    {
      Scr_Error(COM_ERR_2777, scrContext, "Vehicle_SetWorldCollisionCapsule must be called on a vehicle entity.\n");
    }
  }
}

/*
==============
G_VehicleScriptCmd_AllowPlayerStandOn
==============
*/
void G_VehicleScriptCmd_AllowPlayerStandOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity->vehicle )
    Scr_ParamError(COM_ERR_6150, scrContext, 0, "Vehicle_AllowPlayerStandOn - must be called on a vehicle.");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Entity->s.lerp.u.anonymous.data[1] | 0x40000;
  if ( Int )
    v5 = Entity->s.lerp.u.anonymous.data[1] & 0xFFFBFFFF;
  Entity->s.lerp.u.anonymous.data[1] = v5;
}

/*
==============
G_VehicleScriptCmd_VehicleGetInputValue
==============
*/
void G_VehicleScriptCmd_VehicleGetInputValue(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  unsigned int Int; 
  const char *v6; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v9; 
  BgVehiclePhysics *ObjectById; 

  VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
  if ( !Scr_GetNumParam(scrContext) )
    Scr_ParamError(COM_ERR_6204, scrContext, 0, "Vehicle_GetInputValue - must be called with the input control.");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 8 )
  {
    v6 = j_va("Vehicle_GetInputValue - control must be [0..%d]", 7i64);
    Scr_ParamError(COM_ERR_6205, scrContext, 0, v6);
  }
  vehicle = VehicleEntity->vehicle;
  if ( vehicle && BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
  {
    VehicleSystem = GVehicles::GetVehicleSystem();
    v9 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
    ObjectById = BgVehiclePhysicsManager::GetObjectById(v9, vehicle->physicsVehicle);
    *(double *)&_XMM0 = BgVehiclePhysicsControls::GetValue(&ObjectById->m_controls, Int);
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, -1.0, 1.0);
    _XMM1 = _XMM0 & _xmm;
    __asm
    {
      vcmpltss xmm2, xmm1, cs:__real@3c23d70a
      vblendvps xmm1, xmm0, xmm1, xmm2; value
    }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
  }
  else
  {
    Scr_Error(COM_ERR_6206, scrContext, "Vehicle_GetInputValue() must be called on a physics enabled vehicle");
  }
}

/*
==============
G_VehicleScriptField_ReadOnly
==============
*/
void G_VehicleScriptField_ReadOnly(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  const char *v5; 
  const char *v6; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 69, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 70, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  v5 = SL_ConvertToString(*field->name);
  v6 = j_va("Vehicle field %s is read-only", v5);
  Scr_Error(COM_ERR_2645, scrContext, v6);
}

/*
==============
G_VehicleScriptField_GetSpeed
==============
*/
void G_VehicleScriptField_GetSpeed(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 78, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 79, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  Scr_AddFloat(scrContext, veh->speed * 0.056818184);
}

/*
==============
G_VehicleScriptField_GetPathSpeed
==============
*/
void G_VehicleScriptField_GetPathSpeed(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 87, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 88, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  Scr_AddFloat(scrContext, veh->pathSpeed * 0.056818184);
}

/*
==============
G_VehicleScriptField_SetTransmission
==============
*/
void G_VehicleScriptField_SetTransmission(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 98, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 99, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.forward )
  {
    veh->transMode = VEH_TRANS_FORWARD;
  }
  else if ( ConstString == scr_const.reverse )
  {
    veh->transMode = VEH_TRANS_REVERSE;
  }
  else
  {
    v7 = SL_ConvertToString(ConstString);
    v8 = j_va("Trying to set vehicle transmission to '%s'.  Must be 'forward' or 'reverse'.\n", v7);
    Scr_Error(COM_ERR_2646, scrContext, v8);
  }
}

/*
==============
G_VehicleScriptField_GetTransmission
==============
*/
void G_VehicleScriptField_GetTransmission(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  scr_string_t forward; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 121, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 122, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  forward = scr_const.forward;
  if ( veh->transMode )
    forward = scr_const.reverse;
  Scr_AddConstString(scrContext, forward);
}

/*
==============
G_VehicleScriptField_SetPathDir
==============
*/
void G_VehicleScriptField_SetPathDir(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 135, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 136, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.forward )
  {
    veh->pathDir = VEH_PATH_FORWARD;
  }
  else if ( ConstString == scr_const.reverse )
  {
    veh->pathDir = VEH_PATH_REVERSE;
  }
  else
  {
    v7 = SL_ConvertToString(ConstString);
    v8 = j_va("Trying to set vehicle path direction to '%s'.  Must be 'forward' or 'reverse'.\n", v7);
    Scr_Error(COM_ERR_2647, scrContext, v8);
  }
}

/*
==============
G_VehicleScriptField_GetPathDir
==============
*/
void G_VehicleScriptField_GetPathDir(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  scr_string_t forward; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 158, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 159, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  forward = scr_const.forward;
  if ( veh->pathDir )
    forward = scr_const.reverse;
  Scr_AddConstString(scrContext, forward);
}

/*
==============
G_VehicleScriptField_SetPathType
==============
*/
void G_VehicleScriptField_SetPathType(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  scr_string_t ConstString; 
  bool v7; 
  const char *v8; 
  const char *v9; 
  GVehicles *VehicleSystem; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 172, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 173, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.constrained )
  {
    v7 = veh->drivingState == VEH_DRIVE_PATH_FOLLOW;
    veh->pathType = VEH_PATH_CONSTRAINED;
    if ( v7 )
      veh->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
  }
  else if ( ConstString == scr_const.follow )
  {
    if ( !BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
    {
      v8 = SL_ConvertToString(scr_const.follow);
      v9 = j_va("This vehicle does not use physics.  Path type '%s' is allowed only on vehicles that use physics", v8);
      Scr_Error(COM_ERR_2648, scrContext, v9);
    }
    v7 = veh->drivingState == VEH_DRIVE_PATH_CONSTRAINED;
    veh->pathType = VEH_PATH_FOLLOW;
    if ( v7 )
    {
      veh->drivingState = VEH_DRIVE_PATH_FOLLOW;
      VehicleSystem = GVehicles::GetVehicleSystem();
      GVehicles::PhysicsSetInputControl(VehicleSystem, veh->physicsVehicle, 0, 1.0);
      GVehicles::PhysicsSetInputControl(VehicleSystem, veh->physicsVehicle, 1u, 0.0);
    }
  }
  else
  {
    v11 = SL_ConvertToString(scr_const.follow);
    v12 = SL_ConvertToString(scr_const.constrained);
    v13 = SL_ConvertToString(ConstString);
    v14 = j_va("'%s' is an illegal path type.  Must be '%s' or '%s'", v13, v12, v11);
    Scr_Error(COM_ERR_2649, scrContext, v14);
  }
}

/*
==============
G_VehicleScriptField_GetPathType
==============
*/
void G_VehicleScriptField_GetPathType(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  VehiclePathType pathType; 
  scr_string_t follow; 
  __int64 v8; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 208, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 209, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  pathType = veh->pathType;
  if ( pathType == VEH_PATH_FOLLOW )
  {
    follow = scr_const.follow;
    goto LABEL_13;
  }
  if ( pathType == VEH_PATH_CONSTRAINED )
  {
    follow = scr_const.constrained;
LABEL_13:
    Scr_AddConstString(scrContext, follow);
    return;
  }
  LODWORD(v8) = veh->pathType;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 222, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown vehicle path type %i", v8) )
    __debugbreak();
}

/*
==============
G_VehicleScriptField_SetTopSpeed
==============
*/
void G_VehicleScriptField_SetTopSpeed(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  double Float; 
  float v6; 
  unsigned int physicsVehicle; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 231, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  Float = Scr_GetFloat(scrContext, 0);
  v6 = *(float *)&Float * 17.6;
  if ( (float)(*(float *)&Float * 17.6) < 0.0 )
    Scr_ParamError(COM_ERR_2650, scrContext, 0, "Top speed must not be negative");
  physicsVehicle = veh->physicsVehicle;
  veh->topSpeedForward = v6;
  if ( BGVehicles::PhysicsIsValid(physicsVehicle) )
  {
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    GVehicles::PhysicsSetTopSpeedFwd(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, v6);
  }
}

/*
==============
G_VehicleScriptField_GetTopSpeed
==============
*/
void G_VehicleScriptField_GetTopSpeed(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  double TopSpeedFwd; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 249, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
  {
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    TopSpeedFwd = GVehicles::PhysicsGetTopSpeedFwd(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle);
  }
  else
  {
    *(float *)&TopSpeedFwd = veh->topSpeedForward;
  }
  Scr_AddFloat(scrContext, *(float *)&TopSpeedFwd * 0.056818184);
}

/*
==============
G_VehicleScriptField_SetBrake
==============
*/
void G_VehicleScriptField_SetBrake(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  double Float; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 266, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 267, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  if ( !BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
    Scr_Error(COM_ERR_2651, scrContext, "Braking can only be set on physics vehicles");
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    Scr_Error(COM_ERR_2652, scrContext, "Brake must be a value from 0 to 1");
  if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
    __debugbreak();
  GVehicles::PhysicsSetInputControl(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, 1u, *(float *)&Float);
}

/*
==============
G_VehicleScriptField_GetBrake
==============
*/
void G_VehicleScriptField_GetBrake(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  double InputControl; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 284, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
  {
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    InputControl = GVehicles::PhysicsGetInputControl(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, 1u);
  }
  else
  {
    LODWORD(InputControl) = 0;
  }
  Scr_AddFloat(scrContext, *(float *)&InputControl);
}

/*
==============
G_VehicleScriptField_SetThrottle
==============
*/
void G_VehicleScriptField_SetThrottle(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  const VehicleDef *ServerDef; 
  VehicleDrivingState drivingState; 
  double Float; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 297, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( !field && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 298, ASSERT_TYPE_ASSERT, "(field)", (const char *)&queryFormat, "field") )
    __debugbreak();
  if ( !BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
    Scr_Error(COM_ERR_2653, scrContext, "Throttle can be set only on physics vehicles");
  ServerDef = G_Vehicle_GetServerDef(veh->defIndex);
  if ( !ServerDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 304, ASSERT_TYPE_ASSERT, "(vehDef)", (const char *)&queryFormat, "vehDef") )
    __debugbreak();
  drivingState = veh->drivingState;
  if ( drivingState != VEH_DRIVE_AI )
  {
    if ( drivingState == VEH_DRIVE_PATH_FOLLOW )
      goto LABEL_14;
LABEL_21:
    Scr_Error(COM_ERR_2655, scrContext, "Throttle can be set only on vehicles on a path in follow mode.");
    return;
  }
  if ( !ServerDef->vehiclePhysicsDef.physicsEnabled )
    goto LABEL_21;
LABEL_14:
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float < 0.0 )
    Scr_Error(COM_ERR_2654, scrContext, "Throttle must be nonnegative");
  if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
    __debugbreak();
  GVehicles::PhysicsSetInputControl(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, 0, *(float *)&Float);
}

/*
==============
G_VehicleScriptField_GetThrottle
==============
*/
void G_VehicleScriptField_GetThrottle(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  double InputControl; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 327, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
  {
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    InputControl = GVehicles::PhysicsGetInputControl(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, 0);
  }
  else
  {
    LODWORD(InputControl) = 0;
  }
  Scr_AddFloat(scrContext, *(float *)&InputControl);
}

/*
==============
G_VehicleScriptField_GetOrigin
==============
*/
void G_VehicleScriptField_GetOrigin(scrContext_t *scrContext, Vehicle *veh, const VehicleScriptField *field)
{
  BgVehiclePhysicsManager *v5; 
  vehicle_physic_t *p_row3; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 338, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
  {
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v5 = GVehicles::ms_gVehiclesSystem->PhysicsGetVehiclePhysicsManager(GVehicles::ms_gVehiclesSystem);
    p_row3 = (vehicle_physic_t *)&BgVehiclePhysicsManager::GetObjectById(v5, veh->physicsVehicle)->m_transform.row3;
  }
  else
  {
    p_row3 = &veh->phys;
  }
  Scr_AddVector(scrContext, p_row3->origin.v);
}

/*
==============
G_VehicleScriptCmd_IsOnGround
==============
*/
void G_VehicleScriptCmd_IsOnGround(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v5; 
  BgVehiclePhysics *ObjectById; 
  bool v7; 

  vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
  if ( vehicle && BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
  {
    VehicleSystem = GVehicles::GetVehicleSystem();
    v5 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
    ObjectById = BgVehiclePhysicsManager::GetObjectById(v5, vehicle->physicsVehicle);
    if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 912, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
      __debugbreak();
    v7 = ObjectById->IsInAir(ObjectById);
    Scr_AddInt(scrContext, !v7);
  }
  else
  {
    Scr_Error(COM_ERR_2664, scrContext, "Vehicle_IsOnGround() must be called on a physics enabled vehicle");
  }
}

/*
==============
G_VehicleScriptCmd_Teleport
==============
*/
void G_VehicleScriptCmd_Teleport(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  gentity_s *v6; 
  playerState_s *EntityPlayerState; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  vec3_t vectorValue; 
  vec3_t angles; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1149, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &angles);
    if ( EntHandle::isDefined(&VehicleEntity->r.ownerNum) )
    {
      v6 = EntHandle::ent(&VehicleEntity->r.ownerNum);
      EntityPlayerState = G_GetEntityPlayerState(v6);
      if ( EntityPlayerState )
      {
        if ( EntityPlayerState->vehicleState.entity != 2047 )
        {
          EntityPlayerState->vehicleState.origin = vectorValue;
          EntityPlayerState->vehicleState.angles = angles;
        }
      }
    }
    G_VehicleScript_TeleportInternal(vehicle, &vectorValue, &angles);
    if ( (unsigned int)(vehicle->drivingState - 2) <= 1 )
    {
      vehicle->pathPos.origin = vectorValue;
      vehicle->pathPos.angles = angles;
    }
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
      BgVehiclePhysicsComponent::SetPause(ComponentPathFollower, 3.4028235e38);
  }
}

/*
==============
G_VehicleScriptCmd_AttachPath
==============
*/
void G_VehicleScriptCmd_AttachPath(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  __int16 NodeIndex; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  float v7; 
  vec3_t angles; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    NodeIndex = G_VehiclePathScr_GetNodeIndex(scrContext, 0);
    if ( !G_VehiclePath_AttachPathPos(&vehicle->pathPos, NodeIndex) )
      Scr_Error(COM_ERR_2666, scrContext, "AttachPath: Unable to attach to path node");
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(GVehicles::ms_gVehiclesSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
      BgVehicleComponentPathFollower::StartPath(ComponentPathFollower, NodeIndex);
    angles.v[0] = vehicle->pathPos.angles.v[0];
    v7 = vehicle->pathPos.angles.v[1];
    *(_QWORD *)&angles.y = *(_QWORD *)&vehicle->pathPos.angles.y;
    if ( vehicle->transMode == VEH_TRANS_REVERSE )
    {
      _XMM0 = 0i64;
      __asm { vroundss xmm4, xmm0, xmm2, 1 }
      angles.v[1] = (float)((float)((float)(v7 + 180.0) * 0.0027777778) - *(float *)&_XMM4) * 360.0;
    }
    G_VehicleScript_TeleportInternal(vehicle, &vehicle->pathPos.origin, &angles);
  }
}

/*
==============
G_VehicleScriptCmd_GetAttachPos
==============
*/
void G_VehicleScriptCmd_GetAttachPos(scrContext_t *scrContext, scr_entref_t entref)
{
  vec3_t *p_angles; 
  vehicle_physic_t *v5; 
  gentity_s *VehicleEntity; 
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  __int16 NodeIndex; 
  vehicle_physic_t *p_phys; 
  __int64 v11; 
  vehicle_physic_t *v12; 
  __int128 v13; 
  float v14; 
  float v15; 
  float v16; 
  VehicleType type; 
  VehiclePathPos vpp; 
  vehicle_physic_t phys; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    p_angles = &vec3_origin;
    v5 = (vehicle_physic_t *)&vec3_origin;
  }
  else
  {
    VehicleEntity = G_VehicleScript_GetVehicleEntity(scrContext, entref);
    vehicle = VehicleEntity->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1261, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
    NodeIndex = G_VehiclePathScr_GetNodeIndex(scrContext, 0);
    if ( !G_VehiclePath_AttachPathPos(&vpp, NodeIndex) )
      Scr_Error(COM_ERR_2667, scrContext, "GetAttachPos: Unable to attach to path node");
    p_phys = &vehicle->phys;
    v11 = 3i64;
    v12 = &phys;
    do
    {
      v12 = (vehicle_physic_t *)((char *)v12 + 128);
      v13 = *(_OWORD *)p_phys->origin.v;
      p_phys = (vehicle_physic_t *)((char *)p_phys + 128);
      *(_OWORD *)&v12[-1].wheelSurfType[10] = v13;
      *(_OWORD *)&v12[-1].wheelCompression[2] = *(_OWORD *)&p_phys[-1].wheelCompression[2];
      *(_OWORD *)&v12[-1].wheelCompression[6] = *(_OWORD *)&p_phys[-1].wheelCompression[6];
      *(_OWORD *)&v12[-1].wheelCompression[10] = *(_OWORD *)&p_phys[-1].wheelCompression[10];
      *(_OWORD *)&v12[-1].wheelPrevCompression[2] = *(_OWORD *)&p_phys[-1].wheelPrevCompression[2];
      *(_OWORD *)&v12[-1].wheelPrevCompression[6] = *(_OWORD *)&p_phys[-1].wheelPrevCompression[6];
      *(_OWORD *)&v12[-1].wheelPrevCompression[10] = *(_OWORD *)&p_phys[-1].wheelPrevCompression[10];
      *(_OWORD *)&v12[-1].worldTilt.z = *(_OWORD *)&p_phys[-1].worldTilt.z;
      --v11;
    }
    while ( v11 );
    v14 = vpp.origin.v[1];
    v15 = vpp.angles.v[1];
    *(_OWORD *)v12->origin.v = *(_OWORD *)p_phys->origin.v;
    v16 = vpp.origin.v[0];
    v12->prevOrigin.v[1] = p_phys->prevOrigin.v[1];
    phys.origin.v[0] = v16;
    phys.origin.v[2] = vpp.origin.v[2];
    phys.origin.v[1] = v14;
    phys.angles.v[2] = vpp.angles.v[2];
    phys.angles.v[0] = vpp.angles.v[0];
    phys.angles.v[1] = v15;
    if ( vehicle->transMode == VEH_TRANS_REVERSE )
    {
      _XMM0 = 0i64;
      __asm { vroundss xmm4, xmm0, xmm2, 1 }
      phys.angles.v[1] = (float)((float)((float)(v15 + 180.0) * 0.0027777778) - *(float *)&_XMM4) * 360.0;
    }
    G_Vehicle_ResetWheels(VehicleEntity, &phys);
    type = ServerDef->type;
    if ( type == VEH_WHEELS_4 || type == VEH_TREADED )
      G_Vehicle_GroundPlant(VehicleEntity, &phys, 0);
    p_angles = &phys.angles;
    v5 = &phys;
  }
  Scr_MakeArray(scrContext);
  Scr_AddVector(scrContext, v5->origin.v);
  Scr_AddArray(scrContext);
  Scr_AddVector(scrContext, p_angles->v);
  Scr_AddArray(scrContext);
}

/*
==============
G_VehicleScriptCmd_StartPath
==============
*/
void G_VehicleScriptCmd_StartPath(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  __int16 NodeIndex; 
  bool v6; 
  GVehicles *VehicleSystem; 
  int fmt; 
  char v9; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1320, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) )
    {
      NodeIndex = G_VehiclePathScr_GetNodeIndex(scrContext, 0);
      if ( !G_VehiclePath_AttachPathPos(&vehicle->pathPos, NodeIndex) )
        Scr_Error(COM_ERR_2668, scrContext, "StartPath: Unable to attach to path node");
      vehicle->pathPos.origin.v[0] = vehicle->phys.origin.v[0];
      vehicle->pathPos.origin.v[1] = vehicle->phys.origin.v[1];
      vehicle->pathPos.origin.v[2] = vehicle->phys.origin.v[2];
      vehicle->pathPos.angles.v[0] = vehicle->phys.angles.v[0];
      vehicle->pathPos.angles.v[1] = vehicle->phys.angles.v[1];
      vehicle->pathPos.angles.v[2] = vehicle->phys.angles.v[2];
    }
    else if ( vehicle->pathPos.nodeIdx < 0 )
    {
      Scr_Error(COM_ERR_2669, scrContext, "StartPath: Can't start vehicle on path.  Vehicle must already be attached if no node is specified");
    }
    G_VehiclePath_StartPathPos(&vehicle->pathPos);
    vehicle->pathSpeed = vehicle->speed;
    v6 = Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) != 0;
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
    {
      if ( (unsigned int)(vehicle->drivingState - 2) > 1 )
        vehicle->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
      VehicleSystem = GVehicles::GetVehicleSystem();
      LOBYTE(fmt) = v6;
      ((void (__fastcall *)(GVehicles *, char *, _QWORD, _QWORD, int))VehicleSystem->PhysicsCreateComponent_PathFollower)(VehicleSystem, &v9, vehicle->physicsVehicle, (unsigned __int16)vehicle->pathPos.nodeIdx, fmt);
    }
    else
    {
      vehicle->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
    }
  }
}

/*
==============
G_VehicleScriptCmd_StartPathNodes
==============
*/
void G_VehicleScriptCmd_StartPathNodes(scrContext_t *scrContext, scr_entref_t entref)
{
  Vehicle *vehicle; 
  unsigned int v5; 
  unsigned int ArrayObject; 
  unsigned int v7; 
  unsigned int ArraySize; 
  const char *v9; 
  unsigned int v10; 
  unsigned int FirstSibling; 
  unsigned int NextSibling; 
  unsigned int v13; 
  VariableUnion u; 
  __int64 v15; 
  bool v16; 
  float floatValue; 
  bool v18; 
  GVehicles *VehicleSystem; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  const char *v21; 
  const char *v22; 
  int fmt; 
  VariableValue v24; 
  VariableValue out; 
  char v26[16]; 
  int v27[128]; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1393, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) >= 2 )
    {
      if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      {
        v5 = 0;
        ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
        v7 = BGScr_Main_GetArrayObject(scrContext, 1u);
        ArraySize = GetArraySize(scrContext, ArrayObject);
        if ( ArraySize <= 0x20 )
        {
          v10 = 0;
          FirstSibling = FindFirstSibling(scrContext, ArrayObject);
          NextSibling = FindFirstSibling(scrContext, v7);
          if ( FirstSibling )
          {
            do
            {
              if ( !NextSibling )
              {
                Scr_Error(COM_ERR_5849, scrContext, "StartPathNodes: Times array is not the same length as points array");
                return;
              }
              Scr_EvalVariable_Out(scrContext, FirstSibling, &out);
              if ( out.type != VAR_VECTOR )
              {
                RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
                v22 = j_va("StartPathNodes: Element %d of points array is not a vector 3", v10);
                Scr_Error(COM_ERR_3826, scrContext, v22);
                return;
              }
              Scr_EvalVariable_Out(scrContext, NextSibling, &v24);
              if ( (unsigned __int8)(v24.type - 5) > 1u )
              {
                RemoveRefToVector(scrContext, out.u.vectorValue);
                RemoveRefToValue(scrContext, (unsigned __int8)v24.type, v24.u);
                v21 = j_va("StartPathNodes: Element %d of times array is not a float", v10);
                Scr_Error(COM_ERR_5850, scrContext, v21);
                return;
              }
              v13 = I_clamp(ArraySize - v5 - 1, 0, ArraySize - 1);
              u = out.u;
              v15 = 2i64 * v13;
              v16 = v24.type == VAR_FLOAT;
              v27[2 * v15] = *(_DWORD *)out.u.vectorValue;
              v27[2 * v15 + 1] = *(_DWORD *)(u.scriptCodePosValue + 4);
              v27[2 * v15 + 2] = *(_DWORD *)(u.scriptCodePosValue + 8);
              if ( v16 )
                floatValue = v24.u.floatValue;
              else
                floatValue = (float)v24.u.intValue;
              *(float *)&v27[4 * v13 + 3] = floatValue;
              if ( floatValue <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1452, ASSERT_TYPE_ASSERT, "( pointTimes[indexInOrder].w > 0.0f )", "StartPathNodes: Duration must be > 0") )
                __debugbreak();
              ++v5;
              FirstSibling = FindNextSibling(scrContext, FirstSibling);
              NextSibling = FindNextSibling(scrContext, NextSibling);
              RemoveRefToVector(scrContext, out.u.vectorValue);
              ++v10;
            }
            while ( FirstSibling );
            if ( v5 >= 4 )
              goto LABEL_25;
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1460, ASSERT_TYPE_ASSERT, "( pointCount >= 4 )", "StartPathNodes(): Need at least 4 points in the arrays") )
            __debugbreak();
LABEL_25:
          v18 = 0;
          if ( Scr_GetNumParam(scrContext) > 2 )
            Scr_GetInt(scrContext, 2u);
          if ( Scr_GetNumParam(scrContext) > 3 )
            Scr_GetFloat(scrContext, 3u);
          if ( Scr_GetNumParam(scrContext) > 4 )
            Scr_GetFloat(scrContext, 4u);
          if ( Scr_GetNumParam(scrContext) > 5 )
            Scr_GetInt(scrContext, 5u);
          if ( Scr_GetNumParam(scrContext) > 6 )
            v18 = Scr_GetInt(scrContext, 6u) != 0;
          if ( Scr_GetNumParam(scrContext) > 7 )
            Scr_GetInt(scrContext, 7u);
          LOBYTE(fmt) = v18;
          VehicleSystem = GVehicles::GetVehicleSystem();
          ((void (__fastcall *)(GVehicles *, char *, _QWORD, __int64, int))VehicleSystem->PhysicsCreateComponent_PathFollower)(VehicleSystem, v26, vehicle->physicsVehicle, 0xFFFFFFFFi64, fmt);
          ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(VehicleSystem, vehicle->physicsVehicle);
          if ( ComponentPathFollower )
          {
            ((void (__fastcall *)(BgVehicleComponentPathFollower *, int *, _QWORD))ComponentPathFollower->StartPathNodes)(ComponentPathFollower, v27, v5);
            vehicle->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
          }
          else
          {
            Com_PrintError(20, "StartPathNodes: Could not create or retrieve vehicle Path Follower component");
          }
        }
        else
        {
          v9 = j_va("StartPathNodes: Exceeded max number of elements (%d).", 32i64);
          Scr_ParamError(COM_ERR_3825, scrContext, 0, v9);
        }
      }
      else
      {
        Com_PrintError(20, "StartPathNodes: Can be only called on a physics-enabled vehicle.");
      }
    }
    else
    {
      Com_PrintError(20, "StartPathNodes: Invalid number of arguments");
    }
  }
}

/*
==============
G_VehicleScriptCmd_PathGetCurrentNode
==============
*/
void G_VehicleScriptCmd_PathGetCurrentNode(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v4; 
  scrContext_t *v5; 
  Vehicle *vehicle; 
  unsigned int physicsVehicle; 
  GVehicles *VehicleSystem; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  int CurrentNodeIndex; 

  v4 = G_VehicleScript_CheckVehicleSuspended(scrContext, entref);
  v5 = scrContext;
  if ( v4 )
  {
LABEL_12:
    Scr_AddInt(v5, 0);
    return;
  }
  vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1516, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  physicsVehicle = vehicle->physicsVehicle;
  if ( !BGVehicles::PhysicsIsValid(physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1519, ASSERT_TYPE_ASSERT, "( BGVehicles::PhysicsIsValid( vehId ) )", "Path_GetCurrentNode() only works for physics-vehicles.") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(physicsVehicle) )
  {
    VehicleSystem = GVehicles::GetVehicleSystem();
    ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(VehicleSystem, vehicle->physicsVehicle);
    if ( ComponentPathFollower )
    {
      CurrentNodeIndex = BgVehicleComponentPathFollower::GetCurrentNodeIndex(ComponentPathFollower);
      Scr_AddInt(scrContext, CurrentNodeIndex);
      return;
    }
    Com_PrintError(20, "Path_GetCurrentNode() only works for physics-vehicles following a path");
    v5 = scrContext;
    goto LABEL_12;
  }
}

/*
==============
G_VehicleScriptCmd_PathGetCurrentTime
==============
*/
void G_VehicleScriptCmd_PathGetCurrentTime(scrContext_t *scrContext, scr_entref_t entref)
{
  G_VehicleScriptCmd_PathGetterFloatProperty(scrContext, entref, (float (__fastcall *const)(BgVehicleComponentPathFollower *))BgVehicleComponentPathFollower::GetCurrentPathTime);
}

/*
==============
G_VehicleScriptCmd_PathGetCurrentNodeTime
==============
*/
void G_VehicleScriptCmd_PathGetCurrentNodeTime(scrContext_t *scrContext, scr_entref_t entref)
{
  G_VehicleScriptCmd_PathGetterFloatProperty(scrContext, entref, (float (__fastcall *const)(BgVehicleComponentPathFollower *))BgVehicleComponentPathFollower::GetCurrentNodeTime);
}

/*
==============
G_VehicleScriptCmd_StartPathFind
==============
*/
void G_VehicleScriptCmd_StartPathFind(scrContext_t *scrContext, scr_entref_t entref)
{
  int v4; 
  Vehicle *vehicle; 
  int v6; 
  GVehicles *v7; 
  __int64 physicsVehicle; 
  int v9; 
  vec3_t vectorValue; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    v4 = 0;
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1634, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      Scr_Error(COM_ERR_2670, scrContext, "StartPathFind: Only available for physics vehicles");
    if ( !Scr_GetNumParam(scrContext) )
      Scr_Error(COM_ERR_2671, scrContext, "StartPathFind: A goal position is needed");
    if ( !Nav_GetDefaultSpace() )
    {
      Com_PrintWarning(15, "StartPathFind: No Navigation mesh found");
      Scr_AddBool(scrContext, 0);
    }
    Scr_GetVector(scrContext, 0, &vectorValue);
    v6 = 2;
    v4 = 0;
    if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
      v6 = 0;
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v7 = GVehicles::ms_gVehiclesSystem;
    physicsVehicle = vehicle->physicsVehicle;
    vehicle->drivingState = VEH_DRIVE_PATH_CONSTRAINED;
    ((void (__fastcall *)(GVehicles *, int *, __int64, vec3_t *, int))v7->PhysicsCreateComponent_PathFinder)(v7, &v9, physicsVehicle, &vectorValue, v6);
    if ( v9 && (v9 & 0xFF0000u) < 0x20000 )
      v4 = 1;
  }
  Scr_AddBool(scrContext, v4);
}

/*
==============
G_VehicleScriptCmd_AllowPlayerUse
==============
*/
void G_VehicleScriptCmd_AllowPlayerUse(scrContext_t *scrContext)
{
  gentity_s *Entity; 

  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 6513, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->client )
    Scr_ParamError(COM_ERR_5856, scrContext, 0, "Must pass in a player");
  Entity->client->sess.unusableVehicles = Scr_GetInt(scrContext, 1u) == 0;
}

/*
==============
G_VehicleScriptCmd_GetActiveCount
==============
*/
void G_VehicleScriptCmd_GetActiveCount(scrContext_t *scrContext)
{
  int v1; 
  int i; 
  Vehicle *v4; 
  int v5; 

  v1 = 0;
  for ( i = 0; i < 128; ++i )
  {
    v4 = G_Vehicle_Get(i);
    v5 = v1 + 1;
    if ( !v4->ent )
      v5 = v1;
    v1 = v5;
  }
  Scr_AddInt(scrContext, v5);
}

/*
==============
G_VehicleScriptCmd_GetArray
==============
*/
void G_VehicleScriptCmd_GetArray(scrContext_t *scrContext)
{
  int i; 
  gentity_s *ent; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_6203, scrContext, "Cannot call Vehicle_GetArray() with parameters");
  Scr_MakeArray(scrContext);
  for ( i = 0; i < 128; ++i )
  {
    ent = G_Vehicle_Get(i)->ent;
    if ( ent )
    {
      if ( ent->s.eType != ET_VEHICLE_SPAWNER )
      {
        GScr_AddEntity(ent);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
G_VehicleScriptCmd_GetArrayInRadius
==============
*/
void G_VehicleScriptCmd_GetArrayInRadius(scrContext_t *scrContext)
{
  __int128 v1; 
  double Float; 
  float v5; 
  float v6; 
  int v7; 
  float v9; 
  unsigned int v10; 
  __int64 v11; 
  gentity_s *v12; 
  float v13; 
  bool v14; 
  int *ignoreEnts; 
  PhysicsQuery_Collected<unsigned short> *collectedEnts; 
  PhysicsQuery_Collected<unsigned short> v17; 
  vec3_t vectorValue; 
  vec3_t aabbMax; 
  vec3_t aabbMin; 
  char v21; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  _XMM7 = LODWORD(FLOAT_N1_0);
  v5 = *(float *)&Float;
  v6 = *(float *)&Float * *(float *)&Float;
  if ( (int)Scr_GetNumParam(scrContext) > 2 )
  {
    *(double *)&v1 = Scr_GetFloat(scrContext, 2u);
    _XMM7 = v1;
  }
  v7 = 0;
  __asm { vmaxss  xmm1, xmm7, xmm6 }
  v9 = (float)(*(float *)&_XMM1 * 0.5) + vectorValue.v[2];
  aabbMin.v[0] = vectorValue.v[0] - v5;
  aabbMin.v[1] = vectorValue.v[1] - v5;
  v17.ids = (unsigned __int16 *)&v21;
  v17.count = 0;
  aabbMin.v[2] = v9 - (float)(*(float *)&_XMM1 * 0.5);
  aabbMax.v[0] = vectorValue.v[0] + v5;
  v17.countMax = 128;
  aabbMax.v[1] = vectorValue.v[1] + v5;
  aabbMax.v[2] = v9 + (float)(*(float *)&_XMM1 * 0.5);
  PhysicsQuery_ImmediateAABBBroadphaseQuery(PHYSICS_WORLD_ID_FIRST, &aabbMin, &aabbMax, 0x800000, 0, NULL, &v17, NULL, 1);
  Scr_MakeArray(scrContext);
  if ( v17.count )
  {
    while ( 1 )
    {
      v10 = v17.ids[v7];
      v11 = v17.ids[v7];
      if ( v10 >= 0x800 )
      {
        LODWORD(collectedEnts) = 2048;
        LODWORD(ignoreEnts) = v17.ids[v7];
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", ignoreEnts, collectedEnts) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v11].r.isInUse != g_entityIsInUse[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v11] )
        goto LABEL_21;
      v12 = &g_entities[(unsigned __int16)v10];
      if ( !v12->vehicle )
        goto LABEL_21;
      v13 = vectorValue.v[1] - v12->r.currentOrigin.v[1];
      if ( *(float *)&_XMM7 <= 0.0 )
        break;
      if ( (float)((float)(v13 * v13) + (float)((float)(vectorValue.v[0] - v12->r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - v12->r.currentOrigin.v[0]))) <= v6 )
      {
        v14 = COERCE_FLOAT(COERCE_UNSIGNED_INT(vectorValue.v[2] - v12->r.currentOrigin.v[2]) & _xmm) <= *(float *)&_XMM7;
        goto LABEL_19;
      }
LABEL_21:
      if ( ++v7 >= v17.count )
        return;
    }
    v14 = (float)((float)((float)(v13 * v13) + (float)((float)(vectorValue.v[0] - v12->r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - v12->r.currentOrigin.v[0]))) + (float)((float)(vectorValue.v[2] - v12->r.currentOrigin.v[2]) * (float)(vectorValue.v[2] - v12->r.currentOrigin.v[2]))) <= v6;
LABEL_19:
    if ( v14 )
    {
      GScr_AddEntity(v12);
      Scr_AddArray(scrContext);
    }
    goto LABEL_21;
  }
}

/*
==============
G_VehicleScriptCmd_GetSpawnerArray
==============
*/
void G_VehicleScriptCmd_GetSpawnerArray(scrContext_t *scrContext)
{
  int v1; 
  scr_string_t ConstString; 
  __int64 v4; 
  __int64 v5; 
  gentity_s *v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = 0;
  ConstString = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Scr_Error(COM_ERR_2665, scrContext, "Vehicle_GetSpawnerArray() must provide 0 arguments or a targetname.");
  if ( Scr_GetNumParam(scrContext) == 1 )
    ConstString = Scr_GetConstString(scrContext, 0);
  Scr_MakeArray(scrContext);
  if ( level.num_entities > 0 )
  {
    v4 = 0i64;
    v5 = 0i64;
    do
    {
      v6 = &level.gentities[v5];
      if ( (unsigned int)v1 >= 0x800 )
      {
        LODWORD(v8) = 2048;
        LODWORD(v7) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v4] && v6->s.eType == ET_VEHICLE_SPAWNER && (!ConstString || level.gentities[v5].targetname == ConstString) )
      {
        GScr_AddEntity(v6);
        Scr_AddArray(scrContext);
      }
      ++v1;
      ++v4;
      ++v5;
    }
    while ( v1 < level.num_entities );
  }
}

/*
==============
G_VehicleScriptCmd_PathGetterFloatProperty
==============
*/
void G_VehicleScriptCmd_PathGetterFloatProperty(scrContext_t *scrContext, scr_entref_t entref, float (*const getter)(BgVehicleComponentPathFollower *this))
{
  Vehicle *vehicle; 
  unsigned int physicsVehicle; 
  GVehicles *VehicleSystem; 
  BgVehicleComponentPathFollower *ComponentPathFollower; 
  float v10; 
  double v11; 

  if ( G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    Scr_AddFloat(scrContext, 0.0);
  }
  else
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1552, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    physicsVehicle = vehicle->physicsVehicle;
    if ( !BGVehicles::PhysicsIsValid(physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1555, ASSERT_TYPE_ASSERT, "( BGVehicles::PhysicsIsValid( vehId ) )", "Path getter property only works for physics-vehicles.") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(physicsVehicle) )
    {
      VehicleSystem = GVehicles::GetVehicleSystem();
      ComponentPathFollower = GVehicles::PhysicsGetComponentPathFollower(VehicleSystem, vehicle->physicsVehicle);
      v10 = 0.0;
      if ( ComponentPathFollower )
      {
        v11 = ((double (__fastcall *)(BgVehicleComponentPathFollower *))getter)(ComponentPathFollower);
        v10 = *(float *)&v11;
      }
      else
      {
        Com_PrintError(20, "Path getter property only works for physics-vehicles following a path");
      }
      Scr_AddFloat(scrContext, v10);
    }
  }
}

/*
==============
G_VehicleScriptCmd_Precache
==============
*/
void G_VehicleScriptCmd_Precache(scrContext_t *scrContext)
{
  ;
}

/*
==============
G_VehicleScriptCmd_RCPlaneSetPropertyMPH
==============
*/
void G_VehicleScriptCmd_RCPlaneSetPropertyMPH(scrContext_t *scrContext, scr_entref_t entref, void (*propFunc)(BgVehiclePhysicsRCPlane *this, float))
{
  Vehicle *vehicle; 
  const char *v7; 
  ComErrorCode v8; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v10; 
  BgVehiclePhysics *ObjectById; 

  if ( !G_VehicleScript_CheckVehicleSuspended(scrContext, entref) )
  {
    vehicle = G_VehicleScript_GetVehicleEntity(scrContext, entref)->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 2134, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) )
    {
      if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
      {
        VehicleSystem = GVehicles::GetVehicleSystem();
        v10 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
        ObjectById = BgVehiclePhysicsManager::GetObjectById(v10, vehicle->physicsVehicle);
        if ( ObjectById->m_vehicleGameProfile == VEH_GAMEPROFILE_FIXEDWING_RCPLANE )
        {
          Scr_GetFloat(scrContext, 0);
          ((void (__fastcall *)(BgVehiclePhysics *))propFunc)(ObjectById);
          return;
        }
      }
      v7 = "RCPlane set property must be called on a physics RCPlane vehicle";
      v8 = COM_ERR_5852;
    }
    else
    {
      v7 = "RCPlane set property needs a parameter";
      v8 = COM_ERR_5851;
    }
    Scr_Error(v8, scrContext, v7);
  }
}

/*
==============
G_VehicleScriptCmd_Spawn
==============
*/
void G_VehicleScriptCmd_Spawn(scrContext_t *scrContext)
{
  const char *String; 
  scr_string_t ConstString; 
  scr_string_t v4; 
  const gentity_s *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  double v8; 
  double v9; 
  double v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  vec3_t vectorValue; 
  vec3_t v15; 
  vec3_t v16; 

  String = Scr_GetString(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  Scr_GetVector(scrContext, 3u, &vectorValue);
  Scr_GetVector(scrContext, 4u, &v15);
  v5 = NULL;
  if ( Scr_GetNumParam(scrContext) > 5 )
  {
    if ( Scr_GetType(scrContext, 5u) )
    {
      Entity = GScr_GetEntity(5u);
      v5 = Entity;
      if ( Entity )
      {
        if ( !Entity->client )
          Scr_ParamError(COM_ERR_2662, scrContext, 5u, "Owner entity is not a player");
      }
    }
  }
  v7 = G_Utils_SpawnEntity();
  Scr_SetString(&v7->classname, scr_const.script_vehicle);
  Scr_SetString(&v7->script_classname, scr_const.script_vehicle);
  if ( G_Utils_IsNameCompositeModel(String) )
  {
    G_Utils_SetCompositeModel(v7, ET_VEHICLE, String);
  }
  else
  {
    G_Utils_SetModel(v7, String);
    if ( !v7->model )
    {
      v8 = vectorValue.v[0];
      v9 = vectorValue.v[2];
      v10 = vectorValue.v[1];
      v11 = SL_ConvertToString(v4);
      v12 = j_va("A vehicle of type %s spawned at (%f, %f, %f ) when its model %s was not loaded.", v11, v8, v10, v9, String);
      Scr_Error(COM_ERR_2663, scrContext, v12);
    }
  }
  Scr_SetString(&v7->targetname, ConstString);
  v7->r.currentOrigin = vectorValue;
  v7->r.currentAngles = v15;
  if ( Scr_GetNumParam(scrContext) > 6 )
  {
    Scr_GetVector(scrContext, 6u, &v16);
    v7->s.lerp.pos.trDelta = v16;
  }
  v13 = SL_ConvertToString(v4);
  G_Vehicle_Create(v7, v13, v5, 0);
  GScr_AddEntity(v7);
}

/*
==============
G_VehicleScript_AddFields
==============
*/
void G_VehicleScript_AddFields(scrContext_t *scrContext)
{
  const VehicleScriptField *i; 
  __int64 v3; 

  for ( i = vehicleFields; i->name; ++i )
  {
    v3 = ((char *)&i->canonicalString - (char *)&vehicleFields[0].canonicalString) / 48;
    if ( (v3 & 0xE000) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 631, ASSERT_TYPE_ASSERT, "(!((field - vehicleFields) & ENTFIELD_MASK))", (const char *)&queryFormat, "!((field - vehicleFields) & ENTFIELD_MASK)") )
      __debugbreak();
    if ( v3 != (unsigned __int16)v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 632, ASSERT_TYPE_ASSERT, "((field - vehicleFields) == (unsigned short)( field - vehicleFields ))", (const char *)&queryFormat, "(field - vehicleFields) == (unsigned short)( field - vehicleFields )") )
      __debugbreak();
    Scr_AddClassField(scrContext, ENTITY_CLASS_GENTITY, *i->name, i->canonicalString, (unsigned __int16)v3 | 0x8000);
  }
}

/*
==============
G_VehicleScript_CheckVehicleSuspended
==============
*/
_BOOL8 G_VehicleScript_CheckVehicleSuspended(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *v3; 
  GVehicles *VehicleSystem; 
  bool IsSuspended; 
  const dvar_t *v6; 

  if ( entref.entclass || entref.entnum >= 0x800 )
  {
    IsSuspended = 0;
  }
  else
  {
    v3 = &g_entities[entref.entnum];
    VehicleSystem = GVehicles::GetVehicleSystem();
    IsSuspended = GVehicles::IsSuspended(VehicleSystem, v3);
  }
  v6 = DCONST_DVARBOOL_vehScriptCheckSuspended;
  if ( !DCONST_DVARBOOL_vehScriptCheckSuspended && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "vehScriptCheckSuspended") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled && IsSuspended )
    Scr_ObjectError(COM_ERR_5847, scrContext, "Can call it on a Suspended Vehicle");
  return IsSuspended;
}

/*
==============
G_VehicleScript_GetField
==============
*/
void G_VehicleScript_GetField(scrContext_t *scrContext, Vehicle *veh, int offset)
{
  __int64 v3; 
  const VehicleScriptField *v6; 
  void (__fastcall *getter)(scrContext_t *, Vehicle *, const VehicleScriptField *); 

  v3 = offset;
  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 665, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( (unsigned int)v3 >= 9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 666, ASSERT_TYPE_ASSERT, "(static_cast< unsigned int >( offset ) < ( sizeof( *array_counter( vehicleFields ) ) + 0 ) - 1)", (const char *)&queryFormat, "static_cast< unsigned int >( offset ) < ARRAY_COUNT( vehicleFields ) - 1") )
    __debugbreak();
  if ( (int)v3 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 667, ASSERT_TYPE_ASSERT, "(offset >= 0)", (const char *)&queryFormat, "offset >= 0") )
    __debugbreak();
  v6 = &vehicleFields[v3];
  getter = v6->getter;
  if ( getter )
  {
    getter(scrContext, veh, v6);
  }
  else
  {
    if ( !v6->ofs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 677, ASSERT_TYPE_ASSERT, "(field->ofs)", (const char *)&queryFormat, "field->ofs") )
      __debugbreak();
    Scr_GetGenericField(scrContext, (unsigned __int8 *)veh, v6->type, v6->ofs);
  }
}

/*
==============
G_VehicleScript_GetVehicleEntity
==============
*/
gentity_s *G_VehicleScript_GetVehicleEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  const char *v5; 
  gentity_s *v6; 
  double v7; 
  double v8; 
  double v9; 
  const char *v10; 
  scr_string_t targetname; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  scr_string_t classname; 
  double v16; 
  double v17; 
  double v18; 
  const char *v19; 
  scr_string_t v20; 
  const char *v21; 
  const char *v22; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_5848, scrContext, "not an entity");
    return 0i64;
  }
  else
  {
    if ( (int)entref.entnum >= 2048 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 721, ASSERT_TYPE_ASSERT, "(entNum < ( 2048 ))", (const char *)&queryFormat, "entNum < MAX_GENTITIES") )
      __debugbreak();
    v5 = "<unnamed>";
    v6 = &g_entities[entnum];
    if ( v6->s.eType == ET_VEHICLE_SPAWNER )
    {
      v7 = v6->r.currentOrigin.v[2];
      v8 = v6->r.currentOrigin.v[1];
      v9 = v6->r.currentOrigin.v[0];
      v10 = SL_ConvertToString(v6->classname);
      targetname = v6->targetname;
      v12 = v10;
      if ( targetname )
        v13 = SL_ConvertToString(targetname);
      else
        v13 = "<unnamed>";
      v14 = j_va("Trying to call a vehicle command on a spawner.\nEntity '%s' Classname '%s' at (%.0f %.0f %.0f)\n", v13, v12, v9, v8, v7);
      Scr_Error(COM_ERR_2657, scrContext, v14);
    }
    classname = v6->classname;
    if ( classname != scr_const.script_vehicle )
    {
      v16 = v6->r.currentOrigin.v[2];
      v17 = v6->r.currentOrigin.v[1];
      v18 = v6->r.currentOrigin.v[0];
      v19 = SL_ConvertToString(classname);
      v20 = v6->targetname;
      v21 = v19;
      if ( v20 )
        v5 = SL_ConvertToString(v20);
      v22 = j_va("Trying to call a vehicle command on a non-script_vehicle entity.\nEntity '%s' Classname '%s' at (%.0f %.0f %.0f)\n", v5, v21, v18, v17, v16);
      Scr_Error(COM_ERR_2658, scrContext, v22);
    }
    if ( !v6->vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 738, ASSERT_TYPE_ASSERT, "(ent->vehicle)", (const char *)&queryFormat, "ent->vehicle") )
      __debugbreak();
    return v6;
  }
}

/*
==============
G_VehicleScript_IsVehicleSuspended
==============
*/
bool G_VehicleScript_IsVehicleSuspended(scr_entref_t entref)
{
  const gentity_s *v1; 
  GVehicles *VehicleSystem; 

  if ( entref.entclass || entref.entnum >= 0x800 )
    return 0;
  v1 = &g_entities[entref.entnum];
  VehicleSystem = GVehicles::GetVehicleSystem();
  return GVehicles::IsSuspended(VehicleSystem, v1);
}

/*
==============
G_VehicleScript_SetField
==============
*/
void G_VehicleScript_SetField(scrContext_t *scrContext, Vehicle *veh, int offset)
{
  __int64 v3; 
  const VehicleScriptField *v6; 
  void (__fastcall *setter)(scrContext_t *, Vehicle *, const VehicleScriptField *); 

  v3 = offset;
  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 643, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  if ( (unsigned int)v3 >= 9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 644, ASSERT_TYPE_ASSERT, "(static_cast< unsigned int >( offset ) < ( sizeof( *array_counter( vehicleFields ) ) + 0 ) - 1)", (const char *)&queryFormat, "static_cast< unsigned int >( offset ) < ARRAY_COUNT( vehicleFields ) - 1") )
    __debugbreak();
  if ( (int)v3 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 645, ASSERT_TYPE_ASSERT, "(offset >= 0)", (const char *)&queryFormat, "offset >= 0") )
    __debugbreak();
  v6 = &vehicleFields[v3];
  setter = v6->setter;
  if ( setter )
  {
    setter(scrContext, veh, v6);
  }
  else
  {
    if ( !v6->ofs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 655, ASSERT_TYPE_ASSERT, "(field->ofs)", (const char *)&queryFormat, "field->ofs") )
      __debugbreak();
    Scr_SetGenericField(scrContext, (unsigned __int8 *)veh, v6->type, v6->ofs);
  }
}

/*
==============
G_VehicleScript_SetSpeedInternal
==============
*/
void G_VehicleScript_SetSpeedInternal(scrContext_t *scrContext, gentity_s *ent)
{
  Vehicle *vehicle; 
  const VehicleDef *ServerDef; 
  const VehicleDef *v6; 
  double Float; 
  double v8; 
  float manualAccel; 
  float manualSpeed; 
  double v11; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1951, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  vehicle = ent->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1954, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  ServerDef = G_Vehicle_GetServerDef(vehicle->defIndex);
  vehicle->manualMode = VEH_MANUAL_ON;
  v6 = ServerDef;
  Float = Scr_GetFloat(scrContext, 0);
  vehicle->manualSpeed = *(float *)&Float * 17.6;
  if ( (float)(*(float *)&Float * 17.6) < 0.0 )
  {
    Scr_ParamError(COM_ERR_2673, scrContext, 0, "Cannot set negative speed on vehicle");
    vehicle->manualSpeed = 0.0;
  }
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    manualAccel = vehicle->manualAccel;
    if ( manualAccel <= 0.0 )
    {
      Scr_Error(COM_ERR_2675, scrContext, "Acceleration must be > 0 when setting speed");
      goto LABEL_14;
    }
  }
  else
  {
    v8 = Scr_GetFloat(scrContext, 1u);
    manualAccel = *(float *)&v8 * 17.6;
    vehicle->manualAccel = *(float *)&v8 * 17.6;
    if ( (float)(*(float *)&v8 * 17.6) <= 0.0 )
    {
      Scr_ParamError(COM_ERR_2674, scrContext, 1u, "Acceleration must be > 0");
LABEL_14:
      manualAccel = FLOAT_17_6;
      vehicle->manualAccel = 17.6;
    }
  }
  if ( v6->type == VEH_HELICOPTER )
  {
    manualSpeed = vehicle->manualSpeed;
    if ( manualSpeed > vehicle->speed && manualSpeed < manualAccel )
    {
      Com_PrintWarning(15, "WARNING: capping acceleration to speed / sec for vehicle '%d'\n", (unsigned int)ent->s.number);
      vehicle->manualAccel = vehicle->manualSpeed;
    }
  }
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    vehicle->manualDecel = vehicle->manualAccel * 0.5;
  }
  else
  {
    v11 = Scr_GetFloat(scrContext, 2u);
    vehicle->manualDecel = *(float *)&v11 * 17.6;
    if ( (float)(*(float *)&v11 * 17.6) <= 0.0 )
    {
      Scr_ParamError(COM_ERR_2676, scrContext, 2u, "Deceleration must be > 0");
      vehicle->manualDecel = 17.6;
    }
  }
}

/*
==============
G_VehicleScript_TeleportInternal
==============
*/
void G_VehicleScript_TeleportInternal(Vehicle *veh, const vec3_t *origin, const vec3_t *angles)
{
  const VehicleDef *ServerDef; 
  gentity_s *ent; 
  const VehicleDef *v8; 
  VehicleType type; 
  GVehicles *v10; 
  G_PhysicsObject *v11; 
  unsigned int v12; 
  vec4_t quat; 

  if ( !veh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1073, ASSERT_TYPE_ASSERT, "(veh)", (const char *)&queryFormat, "veh") )
    __debugbreak();
  ServerDef = G_Vehicle_GetServerDef(veh->defIndex);
  ent = veh->ent;
  v8 = ServerDef;
  if ( !veh->ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1079, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  ent->s.lerp.eFlags.m_flags[0] ^= 4u;
  veh->phys.origin.v[0] = origin->v[0];
  veh->phys.origin.v[1] = origin->v[1];
  veh->phys.origin.v[2] = origin->v[2];
  veh->phys.angles.v[0] = angles->v[0];
  veh->phys.angles.v[1] = angles->v[1];
  veh->phys.angles.v[2] = angles->v[2];
  G_Vehicle_SetPosition(ent, origin, &veh->phys.vel, angles, 0);
  veh->phys.prevOrigin.v[0] = origin->v[0];
  veh->phys.prevOrigin.v[1] = origin->v[1];
  veh->phys.prevOrigin.v[2] = origin->v[2];
  veh->phys.prevAngles.v[0] = angles->v[0];
  veh->phys.prevAngles.v[1] = angles->v[1];
  veh->phys.prevAngles.v[2] = angles->v[2];
  G_Vehicle_ResetWheels(ent, &veh->phys);
  type = v8->type;
  if ( type == VEH_WHEELS_4 || type == VEH_TREADED )
    G_Vehicle_GroundPlant(ent, &veh->phys, 0);
  G_Vehicle_SetPosition(ent, &veh->phys.origin, &vec3_origin, &veh->phys.angles, 1);
  veh->phys.prevOrigin.v[0] = veh->phys.origin.v[0];
  veh->phys.prevOrigin.v[1] = veh->phys.origin.v[1];
  veh->phys.prevOrigin.v[2] = veh->phys.origin.v[2];
  veh->phys.prevAngles.v[0] = veh->phys.angles.v[0];
  veh->phys.prevAngles.v[1] = veh->phys.angles.v[1];
  veh->phys.prevAngles.v[2] = veh->phys.angles.v[2];
  if ( BGVehicles::PhysicsIsValid(veh->physicsVehicle) )
  {
    AnglesToQuat(&veh->phys.angles, &quat);
    if ( !GVehicles::ms_gVehiclesSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle.h", 562, ASSERT_TYPE_ASSERT, "( ms_gVehiclesSystem )", (const char *)&queryFormat, "ms_gVehiclesSystem") )
      __debugbreak();
    v10 = GVehicles::ms_gVehiclesSystem;
    GVehicles::PhysicsSetLinearVelocity(GVehicles::ms_gVehiclesSystem, veh->physicsVehicle, &vec3_origin);
    GVehicles::PhysicsSetAngularVelocity(v10, veh->physicsVehicle, &vec3_origin);
  }
  v11 = G_PhysicsObject_Get(ent);
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_vehicle_script.cpp", 1112, ASSERT_TYPE_ASSERT, "( physObj )", (const char *)&queryFormat, "physObj") )
    __debugbreak();
  v12 = v11->physicsInstances[0];
  if ( v12 != -1 )
  {
    AnglesToQuat(angles, &quat);
    Physics_WarpInstanceTo(PHYSICS_WORLD_ID_FIRST, v12, origin, &quat, 0);
  }
}

