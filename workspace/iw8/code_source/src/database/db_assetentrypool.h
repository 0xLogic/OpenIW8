/*
==============
DB_AssetEntryPool::ForEachInBlock<FxWorldTransientZoneFixupValidateFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<FxWorldTransientZoneFixupValidateFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FxWorldTransientZoneFixupValidateFunctor *functor)
{
  ??$ForEachInBlock@UFxWorldTransientZoneFixupValidateFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUFxWorldTransientZoneFixupValidateFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::GetNextStashed
==============
*/

DB_AssetEntry *__fastcall DB_AssetEntryPool::GetNextStashed(DB_AssetEntryPool *this, DB_AssetEntry *assetEntry)
{
  return ?GetNextStashed@DB_AssetEntryPool@@QEAAPEAVDB_AssetEntry@@AEAV2@@Z(this, assetEntry);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ReleaseExternalReferencesFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<ReleaseExternalReferencesFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ReleaseExternalReferencesFunctor *functor)
{
  ??$MutableForEachInBlock@UReleaseExternalReferencesFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUReleaseExternalReferencesFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<AssetDumpFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<AssetDumpFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, AssetDumpFunctor *functor)
{
  ??$ForEachInBlock@UAssetDumpFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUAssetDumpFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<GfxWorldTransientZoneFixupValidateFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<GfxWorldTransientZoneFixupValidateFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, GfxWorldTransientZoneFixupValidateFunctor *functor)
{
  ??$ForEachInBlock@UGfxWorldTransientZoneFixupValidateFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUGfxWorldTransientZoneFixupValidateFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<TransientAssetCheck>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<TransientAssetCheck>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, TransientAssetCheck *functor)
{
  ??$ForEachInBlock@UTransientAssetCheck@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUTransientAssetCheck@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEach<UnloadAssetFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEach<UnloadAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, UnloadAssetFunctor *functor)
{
  ??$MutableForEach@UUnloadAssetFunctor@@@DB_AssetEntryPool@@QEAAXAEBVDB_AssetEntryFlags@@AEAUUnloadAssetFunctor@@@Z(this, flags, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<MarkAssetFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<MarkAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, MarkAssetFunctor *functor)
{
  ??$MutableForEachInBlock@UMarkAssetFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUMarkAssetFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<ValidateAssetTableFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<ValidateAssetTableFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ValidateAssetTableFunctor *functor)
{
  ??$ForEachInBlock@UValidateAssetTableFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUValidateAssetTableFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeTransientCustomizationAssetEntryFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<FreeTransientCustomizationAssetEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeTransientCustomizationAssetEntryFunctor *functor)
{
  ??$MutableForEachInBlock@UFreeTransientCustomizationAssetEntryFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUFreeTransientCustomizationAssetEntryFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckDefaultAssetsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<CheckDefaultAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckDefaultAssetsFunctor *functor)
{
  ??$ForEachInBlock@UCheckDefaultAssetsFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUCheckDefaultAssetsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultAssetFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeAssetEntryValidateDefaultAssetFunctor *functor)
{
  ??$ForEachInBlock@UFreeAssetEntryValidateDefaultAssetFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUFreeAssetEntryValidateDefaultAssetFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ClearInternalInUseFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<ClearInternalInUseFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ClearInternalInUseFunctor *functor)
{
  ??$MutableForEachInBlock@UClearInternalInUseFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUClearInternalInUseFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<AssetNameDumpFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<AssetNameDumpFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, AssetNameDumpFunctor *functor)
{
  ??$MutableForEachInBlock@UAssetNameDumpFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUAssetNameDumpFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<MaterialDumpTotals>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<MaterialDumpTotals>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, MaterialDumpTotals *functor)
{
  ??$MutableForEachInBlock@UMaterialDumpTotals@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUMaterialDumpTotals@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<UnloadAssetFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<UnloadAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, UnloadAssetFunctor *functor)
{
  ??$MutableForEachInBlock@UUnloadAssetFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUUnloadAssetFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<XModelFixupCheckFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<XModelFixupCheckFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, XModelFixupCheckFunctor *functor)
{
  ??$ForEachInBlock@UXModelFixupCheckFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUXModelFixupCheckFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultEntriesFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultEntriesFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeDefaultEntriesFunctor *functor)
{
  ??$MutableForEachInBlock@UFreeDefaultEntriesFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUFreeDefaultEntriesFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckOtherAssetsForUnloadFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<CheckOtherAssetsForUnloadFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckOtherAssetsForUnloadFunctor *functor)
{
  ??$ForEachInBlock@UCheckOtherAssetsForUnloadFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUCheckOtherAssetsForUnloadFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<InvalidateItemFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<InvalidateItemFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, InvalidateItemFunctor *functor)
{
  ??$ForEachInBlock@UInvalidateItemFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUInvalidateItemFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultAssetEntryFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultAssetEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeDefaultAssetEntryFunctor *functor)
{
  ??$MutableForEachInBlock@UFreeDefaultAssetEntryFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUFreeDefaultAssetEntryFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckUnusableDefaultAssetsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<CheckUnusableDefaultAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckUnusableDefaultAssetsFunctor *functor)
{
  ??$ForEachInBlock@UCheckUnusableDefaultAssetsFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUCheckUnusableDefaultAssetsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::GetEntry
==============
*/

DB_AssetEntry *__fastcall DB_AssetEntryPool::GetEntry(DB_AssetEntryPool *this, unsigned int index)
{
  return ?GetEntry@DB_AssetEntryPool@@QEAAAEAVDB_AssetEntry@@I@Z(this, index);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<ValidateEntryFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<ValidateEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ValidateEntryFunctor *functor)
{
  ??$ForEachInBlock@UValidateEntryFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUValidateEntryFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::GetIndex
==============
*/

unsigned int __fastcall DB_AssetEntryPool::GetIndex(DB_AssetEntryPool *this, const DB_AssetEntry *assetEntry)
{
  return ?GetIndex@DB_AssetEntryPool@@QEBAIAEBVDB_AssetEntry@@@Z(this, assetEntry);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ReleaseZoneExternalRefsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<ReleaseZoneExternalRefsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ReleaseZoneExternalRefsFunctor *functor)
{
  ??$MutableForEachInBlock@UReleaseZoneExternalRefsFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUReleaseZoneExternalRefsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<XModelFixupFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<XModelFixupFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, XModelFixupFunctor *functor)
{
  ??$MutableForEachInBlock@UXModelFixupFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUXModelFixupFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<EnumAssetsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<EnumAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, EnumAssetsFunctor *functor)
{
  ??$ForEachInBlock@UEnumAssetsFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUEnumAssetsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, GetAllXAssetFunctor *functor)
{
  ??$MutableForEachInBlock@UGetAllXAssetFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUGetAllXAssetFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<TransferDeferredAssetsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<TransferDeferredAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, TransferDeferredAssetsFunctor *functor)
{
  ??$MutableForEachInBlock@UTransferDeferredAssetsFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUTransferDeferredAssetsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<EnumSafeAssetsFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<EnumSafeAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, EnumSafeAssetsFunctor *functor)
{
  ??$ForEachInBlock@UEnumSafeAssetsFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUEnumSafeAssetsFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<TechniqueSetFixupFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::MutableForEachInBlock<TechniqueSetFixupFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, TechniqueSetFixupFunctor *functor)
{
  ??$MutableForEachInBlock@UTechniqueSetFixupFunctor@@@DB_AssetEntryPool@@AEAAXAEBVDB_AssetEntryFlags@@_KIAEAUTechniqueSetFixupFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultNameFunctor>
==============
*/

void __fastcall DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultNameFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeAssetEntryValidateDefaultNameFunctor *functor)
{
  ??$ForEachInBlock@UFreeAssetEntryValidateDefaultNameFunctor@@@DB_AssetEntryPool@@AEBAXAEBVDB_AssetEntryFlags@@_KIAEAUFreeAssetEntryValidateDefaultNameFunctor@@@Z(this, flags, blockData, blockOffset, functor);
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, GetAllXAssetFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int64 v13; 
  __int64 v14; 
  unsigned __int64 v15; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v15 = blockData;
      v9 = v8 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (unsigned __int8)v12[17] == functor->type )
      {
        if ( functor->assets )
        {
          if ( functor->assetCount >= (unsigned int)functor->maxCount )
          {
            LODWORD(v14) = functor->maxCount;
            LODWORD(v13) = functor->assetCount;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetenum.h", 121, ASSERT_TYPE_ASSERT, "(unsigned)( assetCount ) < (unsigned)( maxCount )", "assetCount doesn't index maxCount\n\t%i not in [0, %i)", v13, v14) )
              __debugbreak();
          }
          functor->assets[functor->assetCount].physicsLibrary = *(PhysicsLibrary **)v12;
        }
        ++functor->assetCount;
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v15 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<ValidateEntryFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<ValidateEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ValidateEntryFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      ValidateEntryFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::GetEntry
==============
*/
DB_AssetEntry *DB_AssetEntryPool::GetEntry(DB_AssetEntryPool *this, unsigned int index)
{
  __int64 v2; 

  v2 = index;
  if ( index >= 0x5DA00ui64 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
      __debugbreak();
  }
  return (DB_AssetEntry *)((char *)this + 20 * v2);
}

/*
==============
DB_AssetEntryPool::GetIndex
==============
*/
__int64 DB_AssetEntryPool::GetIndex(DB_AssetEntryPool *this, const DB_AssetEntry *assetEntry)
{
  unsigned __int64 v4; 
  unsigned __int64 v5; 

  if ( (assetEntry < (const DB_AssetEntry *)this || assetEntry >= (const DB_AssetEntry *)&this->m_pool.m_freelist) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 133, ASSERT_TYPE_ASSERT, "( contains_item( item ) )", (const char *)&queryFormat, "contains_item( item )") )
    __debugbreak();
  v4 = (__int64)((unsigned __int128)(((char *)assetEntry - (char *)this) * (__int128)0x6666666666666667i64) >> 64) >> 3;
  v5 = (v4 >> 63) + v4;
  if ( v5 > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned int __cdecl truncate_cast_impl<unsigned int,unsigned __int64>(unsigned __int64)", "unsigned", (unsigned int)v5, "unsigned", v5) )
    __debugbreak();
  if ( (unsigned int)v5 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
    __debugbreak();
  if ( ((0x8000000000000000ui64 >> (v5 & 0x3F)) & this->m_allocatedFlags.m_flags.m_data[(unsigned __int64)(unsigned int)v5 >> 6]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 207, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetEntryIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetEntryIndex )") )
    __debugbreak();
  return (unsigned int)v5;
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<AssetDumpFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<AssetDumpFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, AssetDumpFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      AssetDumpFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<AssetNameDumpFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<AssetNameDumpFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, AssetNameDumpFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned int v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  char *v13; 
  int v14; 
  unsigned int ZoneFlagsFromIndex; 
  const char *ZoneNameFromIndex; 
  DB_AssetEntry *v17; 
  const char *v18; 
  const char *Name; 
  __int64 v20; 
  const char *v21; 
  __int64 v22; 
  __int64 v23; 
  unsigned __int64 v26; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
    __debugbreak();
  if ( blockData )
  {
    do
    {
      v8 = __lzcnt(blockData);
      v26 = blockData;
      v9 = v8 + blockOffset;
      if ( v8 + blockOffset >= 0x5DA00 )
      {
        LODWORD(v23) = 383488;
        LODWORD(v22) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v22, v23) )
          __debugbreak();
      }
      v10 = v9;
      if ( v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> (v9 & 0x3F);
      v12 = (unsigned __int64)v9 >> 6;
      if ( (v11 & v7->m_allocatedFlags.m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v13 = &v7->m_pool.m_data.m_buffer[20 * v9];
      if ( (unsigned __int8)v13[17] == functor->type )
      {
        v14 = *((_WORD *)v13 + 9) & 0x7FF;
        if ( (*((_WORD *)v13 + 9) & 0x7FF) != 0 )
          ZoneFlagsFromIndex = DB_Zones_GetZoneFlagsFromIndex(*((_WORD *)v13 + 9) & 0x7FF);
        else
          ZoneFlagsFromIndex = 0;
        ZoneNameFromIndex = DB_Zones_GetZoneNameFromIndex(v14);
        v17 = (DB_AssetEntry *)((char *)v7 + 20 * v10);
        v18 = ZoneNameFromIndex;
        Name = DB_AssetEntry::GetName(v17);
        v20 = (unsigned __int8)v13[17];
        v21 = Name;
        if ( (unsigned int)v20 >= 0x71 )
        {
          LODWORD(v23) = 113;
          LODWORD(v22) = (unsigned __int8)v13[17];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v22, v23) )
            __debugbreak();
        }
        LODWORD(v22) = ZoneFlagsFromIndex;
        Com_Printf(0, "%s: %s (%s 0x%x)\n", g_assetNames[v20], v21, v18, v22);
        v7 = this;
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v26 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<MaterialDumpTotals>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<MaterialDumpTotals>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, MaterialDumpTotals *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int64 v13; 
  const char *ZoneNameFromIndex; 
  bool v15; 
  char *fmt; 
  __int64 v17; 
  __int64 v18; 
  unsigned __int64 v19; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v19 = blockData;
      v9 = v8 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v18) = 383488;
        LODWORD(v17) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v17, v18) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( v12[17] == 11 )
      {
        v13 = *(_QWORD *)v12;
        if ( !*(_QWORD *)v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_debug_dump.cpp", 115, ASSERT_TYPE_ASSERT, "(mat)", (const char *)&queryFormat, "mat") )
          __debugbreak();
        if ( !*(_QWORD *)(v13 + 64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_debug_dump.cpp", 116, ASSERT_TYPE_ASSERT, "(mat->techniqueSet)", (const char *)&queryFormat, "mat->techniqueSet") )
          __debugbreak();
        ZoneNameFromIndex = DB_Zones_GetZoneNameFromIndex(*((_WORD *)v12 + 9) & 0x7FF);
        ++functor->count;
        v15 = (*(_BYTE *)(v13 + 26) & 0x10) != 0;
        if ( (*(_BYTE *)(v13 + 26) & 0x10) != 0 )
          ++functor->hasStreamedImages;
        LODWORD(v17) = v15;
        LODWORD(fmt) = *(unsigned __int8 *)(v13 + 25);
        Com_Printf(16, "%60s %20s %14d %14d\n", *(const char **)v13, ZoneNameFromIndex, fmt, v17);
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v19 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<XModelFixupCheckFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<XModelFixupCheckFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, XModelFixupCheckFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      XModelFixupCheckFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<XModelFixupFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<XModelFixupFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  XModel *v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      if ( this->m_pool.m_data.m_buffer[20 * v9 + 17] == 9 )
      {
        v12 = *(XModel **)&this->m_pool.m_data.m_buffer[20 * v9];
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_modelfixup.cpp", 859, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
          __debugbreak();
        DB_ModelFixup_FixXModel(v12);
      }
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckDefaultAssetsFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<CheckDefaultAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckDefaultAssetsFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      CheckDefaultAssetsFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckOtherAssetsForUnloadFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<CheckOtherAssetsForUnloadFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckOtherAssetsForUnloadFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  unsigned int v13; 
  const DB_ZoneBitArray *unloadZones; 
  const char *ZoneNameFromIndex; 
  __int64 v16; 
  const char *v17; 
  const char *XAssetHeaderName; 
  __int64 v19; 
  __int64 v20; 
  unsigned __int64 v21; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v21 = blockData;
      v9 = v8 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v20) = 383488;
        LODWORD(v19) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( !functor->unloadZones && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 9738, ASSERT_TYPE_ASSERT, "(unloadZones)", (const char *)&queryFormat, "unloadZones") )
        __debugbreak();
      v13 = *((_WORD *)v12 + 9) & 0x7FF;
      if ( (*((_WORD *)v12 + 9) & 0x7FF) != 0 )
      {
        unloadZones = functor->unloadZones;
        if ( v13 >= 0x7C0 )
        {
          LODWORD(v20) = 1984;
          LODWORD(v19) = *((_WORD *)v12 + 9) & 0x7FF;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v19, v20) )
            __debugbreak();
        }
        if ( ((0x80000000 >> (v13 & 0x1F)) & unloadZones->zones.array[(unsigned __int64)v13 >> 5]) != 0 )
        {
          ZoneNameFromIndex = DB_Zones_GetZoneNameFromIndex(v13);
          if ( !ZoneNameFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 9747, ASSERT_TYPE_ASSERT, "(zoneName)", (const char *)&queryFormat, "zoneName") )
            __debugbreak();
          v16 = (unsigned __int8)v12[17];
          if ( (unsigned int)v16 >= 0x71 )
          {
            LODWORD(v20) = 113;
            LODWORD(v19) = (unsigned __int8)v12[17];
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v19, v20) )
              __debugbreak();
          }
          v17 = g_assetNames[v16];
          XAssetHeaderName = DB_GetXAssetHeaderName((unsigned __int8)v12[17], *(const XAssetHeader *)v12);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 9750, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Transient asset bitarray is incorrect. Unloading transients and saw asset '%s'(%s) zone='%s' wasn't hit for our transient unload", XAssetHeaderName, v17, ZoneNameFromIndex) )
            __debugbreak();
        }
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v21 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<CheckUnusableDefaultAssetsFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<CheckUnusableDefaultAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, CheckUnusableDefaultAssetsFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      CheckUnusableDefaultAssetsFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<EnumAssetsFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<EnumAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, EnumAssetsFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int64 v13; 
  __int64 v14; 
  unsigned __int64 v15; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v15 = blockData;
      v9 = v8 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (unsigned __int8)v12[17] == functor->type )
        ((void (__fastcall *)(_QWORD, void *))functor->funcCall)(*(_QWORD *)v12, functor->data);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v15 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<EnumSafeAssetsFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<EnumSafeAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, EnumSafeAssetsFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned int v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int16 v13; 
  unsigned __int64 v14; 
  unsigned __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  unsigned __int64 v18; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v18 = blockData;
      v9 = v8 + blockOffset;
      if ( v8 + blockOffset >= 0x5DA00 )
      {
        LODWORD(v17) = 383488;
        LODWORD(v16) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v16, v17) )
          __debugbreak();
      }
      if ( v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> (v9 & 0x3F);
      v11 = (unsigned __int64)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (unsigned __int8)v12[17] == functor->type )
      {
        v13 = *((_WORD *)v12 + 9);
        DB_LockPendingZoneRead();
        v14 = v13 & 0x7FF;
        if ( v14 >= 0x7A4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
          __debugbreak();
        v15 = s_assetManager.deferredZones.m_data[v14 >> 6];
        DB_UnlockPendingZoneRead();
        if ( ((0x8000000000000000ui64 >> (v14 & 0x3F)) & v15) == 0 )
          ((void (__fastcall *)(_QWORD, void *))functor->funcCall)(*(_QWORD *)v12, functor->data);
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v18 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultAssetFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FreeAssetEntryValidateDefaultAssetFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      FreeAssetEntryValidateDefaultAssetFunctor::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultNameFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<FreeAssetEntryValidateDefaultNameFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  const char *XAssetHeaderName; 
  __int64 v14; 
  __int64 v15; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v15) = 383488;
        LODWORD(v14) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v14, v15) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (*((_WORD *)v12 + 9) & 0x7FF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 7274, ASSERT_TYPE_ASSERT, "(assetEntry.GetZoneIndex() == DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "assetEntry.GetZoneIndex() == DEFAULT_ZONE_INDEX") )
        __debugbreak();
      XAssetHeaderName = DB_GetXAssetHeaderName((unsigned __int8)v12[17], *(const XAssetHeader *)v12);
      DB_CheckDefaultAssetName(XAssetHeaderName);
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<FxWorldTransientZoneFixupValidateFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<FxWorldTransientZoneFixupValidateFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, FxWorldTransientZoneFixupValidateFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  const FxWorldTransientZone *v13; 
  __int64 transientZoneIndex; 
  __int64 v15; 
  __int64 v16; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v16) = 383488;
        LODWORD(v15) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      if ( this->m_pool.m_data.m_buffer[20 * v10 + 17] == 110 )
      {
        v13 = *(const FxWorldTransientZone **)&this->m_pool.m_data.m_buffer[20 * v10];
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 3541, ASSERT_TYPE_ASSERT, "(transientZone)", (const char *)&queryFormat, "transientZone") )
          __debugbreak();
        if ( DB_FxWorldTransientZone_IsValidTransientZone(v13) )
        {
          transientZoneIndex = v13->transientZoneIndex;
          if ( (unsigned int)transientZoneIndex >= 0x600 )
          {
            LODWORD(v16) = 1536;
            LODWORD(v15) = v13->transientZoneIndex;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 3551, ASSERT_TYPE_ASSERT, "(unsigned)( transientZoneIndex ) < (unsigned)( ( sizeof( *array_counter( fxTransients ) ) + 0 ) )", "transientZoneIndex doesn't index ARRAY_COUNT( fxTransients )\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          functor->fxTransients[transientZoneIndex] = v13;
        }
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<GfxWorldTransientZoneFixupValidateFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<GfxWorldTransientZoneFixupValidateFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, GfxWorldTransientZoneFixupValidateFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  const GfxWorldTransientZone *v13; 
  __int64 transientZoneIndex; 
  __int64 v15; 
  __int64 v16; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v16) = 383488;
        LODWORD(v15) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      if ( this->m_pool.m_data.m_buffer[20 * v10 + 17] == 28 )
      {
        v13 = *(const GfxWorldTransientZone **)&this->m_pool.m_data.m_buffer[20 * v10];
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 3479, ASSERT_TYPE_ASSERT, "(transientZone)", (const char *)&queryFormat, "transientZone") )
          __debugbreak();
        if ( DB_GfxWorldTransientZone_IsValidTransientZone(v13) )
        {
          transientZoneIndex = v13->transientZoneIndex;
          if ( (unsigned int)transientZoneIndex >= 0x600 )
          {
            LODWORD(v16) = 1536;
            LODWORD(v15) = v13->transientZoneIndex;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 3489, ASSERT_TYPE_ASSERT, "(unsigned)( transientZoneIndex ) < (unsigned)( ( sizeof( *array_counter( gfxTransients ) ) + 0 ) )", "transientZoneIndex doesn't index ARRAY_COUNT( gfxTransients )\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          functor->gfxTransients[transientZoneIndex] = v13;
        }
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<TransientAssetCheck>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<TransientAssetCheck>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, TransientAssetCheck *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      TransientAssetCheck::operator()(functor, (const DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<ValidateAssetTableFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<ValidateAssetTableFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ValidateAssetTableFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  unsigned __int64 v16; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v16 = blockData;
      v9 = v8 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v15) = 383488;
        LODWORD(v14) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v14, v15) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( !DB_Zones_IsDevZoneIndex(*((_WORD *)v12 + 9) & 0x7FF) && !DB_AssetUsage_TestMyChangesDefault((const DB_AssetEntry *const)v12) )
      {
        v13 = (unsigned __int8)v12[17];
        if ( (unsigned int)v13 >= 0x71 )
        {
          LODWORD(v15) = 113;
          LODWORD(v14) = v13;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 5232, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( assetCounts ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( assetCounts )\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        ++functor->assetCounts[v13];
        ++functor->totalEntries;
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v16 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEach<UnloadAssetFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEach<UnloadAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, UnloadAssetFunctor *functor)
{
  unsigned int v3; 
  unsigned int v4; 
  const DB_AssetEntryFlags *v8; 

  v3 = 0;
  v4 = 0;
  v8 = flags;
  do
  {
    DB_AssetEntryPool::MutableForEachInBlock<UnloadAssetFunctor>(this, flags, v8->m_flags.m_data[0], v3, functor);
    v3 += 64;
    ++v4;
    v8 = (const DB_AssetEntryFlags *)((char *)v8 + 8);
  }
  while ( v4 < 0x1768 );
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ClearInternalInUseFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<ClearInternalInUseFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v13) = 383488;
        LODWORD(v12) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      this->m_pool.m_data.m_buffer[20 * v9 + 16] &= ~4u;
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultAssetEntryFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultAssetEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  DB_AssetEntry *v12; 
  const char *TypeName; 
  const char *XAssetHeaderName; 
  __int64 m_type; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  const char *DefaultAssetName; 
  __int64 v20; 
  __int64 v21; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    while ( 1 )
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v21) = 383488;
        LODWORD(v20) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = (DB_AssetEntry *)((char *)this + 20 * v9);
      if ( DB_IsTransientAssetKeepDefaultEntry(v12) || DB_IsPreloadKeepDefaultEntry(v12) || DB_IsForcedStubbedKeepDefaultEntry(v12) || (v12->m_inuse & 5) != 0 )
        goto LABEL_33;
      if ( v12->m_nextStashed )
        break;
      DB_FreeDefaultAssetEntry(v12);
LABEL_43:
      blockData ^= 0x8000000000000000ui64 >> v7;
      if ( 0x8000000000000000ui64 >> v7 == v8 )
        return;
    }
    DB_DumpAssetAndStashes(v12);
    TypeName = DB_AssetEntry::GetTypeName(v12);
    XAssetHeaderName = DB_GetXAssetHeaderName(v12->m_type, v12->m_header);
    Com_Printf(0, "DB: Keeping around default head asset for %s(%s) because we have a stashed asset. Is likely a cancelled or paused fastfile\n", XAssetHeaderName, TypeName);
LABEL_33:
    if ( !DB_AssetTypeHasADefaultAsset((const XAssetType)v12->m_type) )
    {
      m_type = v12->m_type;
      if ( (unsigned int)m_type >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v20) = v12->m_type;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      v16 = g_assetNames[m_type];
      v17 = DB_GetXAssetHeaderName(v12->m_type, v12->m_header);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10487, ASSERT_TYPE_ASSERT, "(DB_AssetTypeHasADefaultAsset( assetEntry.GetType() ))", "%s\n\tUnable to keep around default asset %s(%s) as this asset type isn't allowed to have defaults", "DB_AssetTypeHasADefaultAsset( assetEntry.GetType() )", v17, v16) )
        __debugbreak();
    }
    v18 = DB_GetXAssetHeaderName(v12->m_type, v12->m_header);
    if ( SL_IsString(v18) )
    {
      DB_CheckDefaultAssetName(v18);
    }
    else
    {
      DefaultAssetName = DB_AllocateDefaultAssetName(v18);
      DB_SetXAssetHeaderName(v12->m_type, v12->m_header, DefaultAssetName);
    }
    goto LABEL_43;
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultEntriesFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<FreeDefaultEntriesFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v13) = 383488;
        LODWORD(v12) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      DB_FreeDefaultAssetEntry((DB_AssetEntry *)this + v9);
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<FreeTransientCustomizationAssetEntryFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<FreeTransientCustomizationAssetEntryFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  const char *XAssetHeaderName; 
  __int64 v14; 
  __int64 v15; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v15) = 383488;
        LODWORD(v14) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v14, v15) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (*((_WORD *)v12 + 9) & 0x7FF) == 0 )
      {
        if ( DB_IsTransientAssetKeepDefaultEntry((const DB_AssetEntry *)v12) )
        {
          XAssetHeaderName = DB_GetXAssetHeaderName((unsigned __int8)v12[17], *(const XAssetHeader *)v12);
          DB_CheckDefaultAssetName(XAssetHeaderName);
        }
        else
        {
          if ( *((_DWORD *)v12 + 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10395, ASSERT_TYPE_ASSERT, "(assetEntry.GetNextStashedIndex() == 0)", (const char *)&queryFormat, "assetEntry.GetNextStashedIndex() == 0") )
            __debugbreak();
          if ( (v12[16] & 2) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10396, ASSERT_TYPE_ASSERT, "(!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP ))", (const char *)&queryFormat, "!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP )") )
            __debugbreak();
          DB_FreeDefaultAssetEntry((DB_AssetEntry *)v12);
        }
      }
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<MarkAssetFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<MarkAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  DB_AssetEntry *v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = (DB_AssetEntry *)((char *)this + 20 * v9);
      if ( (*((_WORD *)v12 + 9) & 0x7FF) != 0 )
      {
        if ( !s_assetMarkDatabaseReady && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10516, ASSERT_TYPE_ASSERT, "(s_assetMarkDatabaseReady)", (const char *)&queryFormat, "s_assetMarkDatabaseReady") )
          __debugbreak();
        DB_MarkXAssetEntry(v12, 4u);
      }
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ReleaseExternalReferencesFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<ReleaseExternalReferencesFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (v12[16] & 2) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10088, ASSERT_TYPE_ASSERT, "(!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP ))", (const char *)&queryFormat, "!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP )") )
        __debugbreak();
      v12[16] &= ~1u;
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<ReleaseZoneExternalRefsFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<ReleaseZoneExternalRefsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, ReleaseZoneExternalRefsFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  char *v13; 
  __int64 v14; 
  __int64 v15; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v15) = 383488;
        LODWORD(v14) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v14, v15) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v13 = &this->m_pool.m_data.m_buffer[20 * v10];
      if ( (*((_WORD *)v13 + 9) & 0x7FF) != 0 && (DB_Zones_GetZoneFlagsFromIndex(*((_WORD *)v13 + 9) & 0x7FF) & functor->zoneFlags) != 0 )
      {
        if ( (v13[16] & 2) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 10150, ASSERT_TYPE_ASSERT, "(!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP ))", (const char *)&queryFormat, "!assetEntry.TestInUse( ASSET_MASK_EXTERNAL_REF_TEMP )") )
          __debugbreak();
        v13[16] &= ~1u;
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<TechniqueSetFixupFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<TechniqueSetFixupFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  MaterialTechniqueSet *v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      if ( this->m_pool.m_data.m_buffer[20 * v9 + 17] == 14 )
      {
        v12 = *(MaterialTechniqueSet **)&this->m_pool.m_data.m_buffer[20 * v9];
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 3656, ASSERT_TYPE_ASSERT, "(techniqueSet)", (const char *)&queryFormat, "techniqueSet") )
          __debugbreak();
        Material_FixupPipelineStates(v12);
      }
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<TransferDeferredAssetsFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<TransferDeferredAssetsFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset)
{
  DB_AssetEntryPool *v6; 
  int v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  DB_AssetEntry *NextStashed; 
  unsigned __int64 m_nextStashed; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v6 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v6 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v6->m_allocatedFlags;
    do
    {
      v7 = __lzcnt(blockData);
      v8 = blockData;
      v9 = v7 + blockOffset;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v17) = 383488;
        LODWORD(v16) = v7 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v16, v17) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v7 + blockOffset) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      if ( (*((_WORD *)v12 + 9) & 0x7FF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_registry.cpp", 5803, ASSERT_TYPE_ASSERT, "(assetEntry.GetZoneIndex() == DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "assetEntry.GetZoneIndex() == DEFAULT_ZONE_INDEX") )
        __debugbreak();
      if ( *((_DWORD *)v12 + 3) )
      {
        NextStashed = DB_AssetEntryPool::GetNextStashed(&s_assetManager.table.m_pool, (DB_AssetEntry *)v12);
        if ( NextStashed )
        {
          while ( !DB_ShouldStashedAssetBeTransferred(NextStashed) )
          {
            m_nextStashed = NextStashed->m_nextStashed;
            if ( (_DWORD)m_nextStashed )
            {
              v15 = (unsigned int)m_nextStashed;
              if ( m_nextStashed >= 0x5DA00 )
              {
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
                  __debugbreak();
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
                  __debugbreak();
              }
              NextStashed = (DB_AssetEntry *)((char *)&s_assetManager + 20 * v15);
              if ( NextStashed )
                continue;
            }
            goto LABEL_42;
          }
          DB_ReplaceHeadAssetEntry(NextStashed, (DB_AssetEntry *)v12, 1);
        }
      }
LABEL_42:
      blockData ^= 0x8000000000000000ui64 >> v7;
    }
    while ( 0x8000000000000000ui64 >> v7 != v8 );
  }
}

/*
==============
DB_AssetEntryPool::MutableForEachInBlock<UnloadAssetFunctor>
==============
*/
void DB_AssetEntryPool::MutableForEachInBlock<UnloadAssetFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, UnloadAssetFunctor *functor)
{
  DB_AssetEntryPool *v7; 
  int v8; 
  unsigned __int64 v9; 
  __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 126, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v9 = blockData;
      v10 = v8 + blockOffset;
      if ( (unsigned int)v10 >= 0x5DA00 )
      {
        LODWORD(v14) = 383488;
        LODWORD(v13) = v8 + blockOffset;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 133, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( (unsigned int)v10 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v11 = 0x8000000000000000ui64 >> ((v8 + blockOffset) & 0x3F);
      v12 = (unsigned __int64)(unsigned int)v10 >> 6;
      if ( (v11 & p_m_allocatedFlags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 134, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v11 & flags->m_flags.m_data[v12]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 135, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v10 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      UnloadAssetFunctor::operator()(functor, (DB_AssetEntry *)this + v10);
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v9 );
  }
}

/*
==============
DB_AssetEntryPool::GetNextStashed
==============
*/
DB_AssetEntry *DB_AssetEntryPool::GetNextStashed(DB_AssetEntryPool *this, DB_AssetEntry *assetEntry)
{
  unsigned __int64 m_nextStashed; 
  __int64 v4; 

  m_nextStashed = assetEntry->m_nextStashed;
  if ( !(_DWORD)m_nextStashed )
    return 0i64;
  v4 = (unsigned int)m_nextStashed;
  if ( m_nextStashed >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 358, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 107, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
      __debugbreak();
  }
  return (DB_AssetEntry *)((char *)this + 20 * v4);
}

/*
==============
DB_AssetEntryPool::ForEachInBlock<InvalidateItemFunctor>
==============
*/
void DB_AssetEntryPool::ForEachInBlock<InvalidateItemFunctor>(DB_AssetEntryPool *this, const DB_AssetEntryFlags *flags, unsigned __int64 blockData, const unsigned int blockOffset, InvalidateItemFunctor *functor)
{
  unsigned int v5; 
  DB_AssetEntryPool *v7; 
  int v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  char *v12; 
  char v13; 
  _QWORD *v14; 
  __int64 v15; 
  _QWORD *v16; 
  unsigned int v17; 
  __int64 v18; 
  _QWORD *v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  unsigned __int64 v23; 
  DB_AssetEntryFlags *p_m_allocatedFlags; 

  v5 = blockOffset;
  v7 = this;
  if ( blockOffset >= 0x5DA00 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 75, ASSERT_TYPE_ASSERT, "(unsigned)( blockOffset ) < (unsigned)( assetEntryPool_t::num_elements )", "blockOffset doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", blockOffset, 383488) )
      __debugbreak();
    v7 = this;
  }
  if ( blockData )
  {
    p_m_allocatedFlags = &v7->m_allocatedFlags;
    do
    {
      v8 = __lzcnt(blockData);
      v23 = blockData;
      v9 = v8 + v5;
      if ( (unsigned int)v9 >= 0x5DA00 )
      {
        LODWORD(v22) = 383488;
        LODWORD(v21) = v8 + v5;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( assetEntryPool_t::num_elements )", "assetIndex doesn't index assetEntryPool_t::num_elements\n\t%i not in [0, %i)", v21, v22) )
          __debugbreak();
      }
      if ( (unsigned int)v9 >= 0x5DA00ui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = 0x8000000000000000ui64 >> ((v8 + v5) & 0x3F);
      v11 = (unsigned __int64)(unsigned int)v9 >> 6;
      if ( (v10 & p_m_allocatedFlags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 83, ASSERT_TYPE_ASSERT, "(m_allocatedFlags.Test( assetIndex ))", (const char *)&queryFormat, "m_allocatedFlags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      if ( (v10 & flags->m_flags.m_data[v11]) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetentrypool.h", 84, ASSERT_TYPE_ASSERT, "(flags.Test( assetIndex ))", (const char *)&queryFormat, "flags.Test( assetIndex )") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0x5DA00ui64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 352, ASSERT_TYPE_ASSERT, "( index < m_data.size() )", (const char *)&queryFormat, "index < m_data.size()") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\fixed_memory_block.h", 99, ASSERT_TYPE_ASSERT, "( index < num_elements )", (const char *)&queryFormat, "index < num_elements") )
          __debugbreak();
      }
      v12 = &this->m_pool.m_data.m_buffer[20 * v9];
      v13 = v12[17];
      switch ( v13 )
      {
        case 8:
          v19 = *(_QWORD **)v12;
          v20 = v19[5];
          if ( (v20 & 0x200) != 0 && (unsigned __int8)v20 == (unsigned __int64)functor->xpakIndex )
          {
            v19[3] = 0i64;
            v19[5] = v20 | 0x3FFFFFFFFF0000i64;
            *((_BYTE *)v19 + 40) = 0;
            v19[5] &= 0xFFFFFFFFFFFFFCFFui64;
            v19[4] = 0i64;
          }
          break;
        case 15:
          v16 = *(_QWORD **)v12;
          v17 = 0;
          if ( *(_BYTE *)(*(_QWORD *)v12 + 49i64) )
          {
            do
            {
              v18 = v16[5 * v17 + 10];
              if ( (v18 & 0x200) != 0 && (unsigned __int8)v18 == (unsigned __int64)functor->xpakIndex )
              {
                v16[5 * v17 + 8] = 0i64;
                v16[5 * v17 + 10] = v18 | 0x3FFFFFFFFF0000i64;
                LOBYTE(v16[5 * v17 + 10]) = 0;
                v16[5 * v17 + 10] &= 0xFFFFFFFFFFFFFCFFui64;
                v16[5 * v17 + 9] = 0i64;
              }
              ++v17;
            }
            while ( v17 < *((unsigned __int8 *)v16 + 49) );
            v5 = blockOffset;
          }
          break;
        case 98:
          v14 = *(_QWORD **)v12;
          v15 = *(_QWORD *)(*(_QWORD *)v12 + 32i64);
          if ( (v15 & 0x200) != 0 && (unsigned __int8)v15 == (unsigned __int64)functor->xpakIndex )
          {
            v14[2] = 0i64;
            v14[4] = v15 | 0x3FFFFFFFFF0000i64;
            *((_BYTE *)v14 + 32) = 0;
            v14[4] &= 0xFFFFFFFFFFFFFCFFui64;
            v14[3] = 0i64;
          }
          break;
      }
      blockData ^= 0x8000000000000000ui64 >> v8;
    }
    while ( 0x8000000000000000ui64 >> v8 != v23 );
  }
}

