/*
==============
hkArray<int,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<int,hkContainerHeapAllocator>::reflectValidate(hkArray<int,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@HUhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hkStringPtr,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hkStringPtr,hkContainerHeapAllocator>::reflectValidate(hkArray<hkStringPtr,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhkStringPtr@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hknpMaterial,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hknpMaterial,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpMaterial,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhknpMaterial@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>(hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator> *this)
{
  ??0?$hkArray@UBulletImpact@HavokCloth_PhysicsProxyAction@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::reflectValidate(hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@UXModelCollisionTagData@HavokPhysicsXModelLOD@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hknpBodyQuality,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hknpBodyQuality,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpBodyQuality,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhknpBodyQuality@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::reflectValidate(hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@UShapeTagData@HavokPhysicsShapeList@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>::~hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>
==============
*/

void __fastcall hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>::~hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>(hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator> *this)
{
  ??1?$hkInplaceArray@V?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@$0CA@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<bool,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<bool,hkContainerHeapAllocator>::reflectValidate(hkArray<bool,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@_NUhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator>::operator delete
==============
*/

void __fastcall hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator>::operator delete(void *p, unsigned __int64 nbytes)
{
  ??3?$hkArray@PEAUPhysicsSFXEventAsset@@UhkContainerHeapAllocator@@@@SAXPEAX_K@Z(p, nbytes);
}

/*
==============
hkArray<hknpShape *,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hknpShape *,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpShape *,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@PEAVhknpShape@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hkTransformf,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hkTransformf,hkContainerHeapAllocator>::reflectValidate(hkArray<hkTransformf,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhkTransformf@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hkVector4f,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hkVector4f,hkContainerHeapAllocator>::reflectValidate(hkArray<hkVector4f,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhkVector4f@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkArray<hknpMotionProperties,hkContainerHeapAllocator>::reflectValidate
==============
*/

bool __fastcall hkArray<hknpMotionProperties,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpMotionProperties,hkContainerHeapAllocator> *this)
{
  return ?reflectValidate@?$hkArray@VhknpMotionProperties@@UhkContainerHeapAllocator@@@@QEBA_NXZ(this);
}

/*
==============
hkInplaceArray<char,128,hkContainerTempAllocator>::~hkInplaceArray<char,128,hkContainerTempAllocator>
==============
*/

void __fastcall hkInplaceArray<char,128,hkContainerTempAllocator>::~hkInplaceArray<char,128,hkContainerTempAllocator>(hkInplaceArray<char,128,hkContainerTempAllocator> *this)
{
  ??1?$hkInplaceArray@D$0IA@UhkContainerTempAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator>::operator delete
==============
*/

void __fastcall hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator>::operator delete(void *p, unsigned __int64 nbytes)
{
  ??3?$hkArray@PEAUPhysicsVFXEventAsset@@UhkContainerHeapAllocator@@@@SAXPEAX_K@Z(p, nbytes);
}

/*
==============
hkInplaceArray<char,128,hkContainerTempAllocator>::~hkInplaceArray<char,128,hkContainerTempAllocator>
==============
*/
void hkInplaceArray<char,128,hkContainerTempAllocator>::~hkInplaceArray<char,128,hkContainerTempAllocator>(hkInplaceArray<char,128,hkContainerTempAllocator> *this)
{
  int m_capacityAndFlags; 

  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(&hkContainerTempAllocator::s_alloc, this->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_data = NULL;
  this->m_capacityAndFlags = 0x80000000;
}

/*
==============
hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator>::operator delete
==============
*/
void hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator>::operator delete(void *p, unsigned __int64 nbytes)
{
  int v2; 
  hkMemoryRouter *Value; 

  if ( p )
  {
    v2 = nbytes;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, p, v2);
  }
}

/*
==============
hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator>::operator delete
==============
*/
void hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator>::operator delete(void *p, unsigned __int64 nbytes)
{
  int v2; 
  hkMemoryRouter *Value; 

  if ( p )
  {
    v2 = nbytes;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, p, v2);
  }
}

/*
==============
hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>::~hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>
==============
*/
void hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>::~hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator>(hkInplaceArray<hkArray<hknpBodyId,hkContainerHeapAllocator>,32,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int v3; 
  __int64 v4; 
  int *p_m_capacityAndFlags; 
  hkMemoryAllocator *v6; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  v3 = this->m_size - 1;
  v4 = v3;
  if ( v3 >= 0 )
  {
    p_m_capacityAndFlags = &this->m_data[v3].m_capacityAndFlags;
    do
    {
      v6 = hkMemHeapAllocator();
      *(p_m_capacityAndFlags - 1) = 0;
      if ( *p_m_capacityAndFlags >= 0 )
        hkMemoryAllocator::bufFree2(v6, *(void **)(p_m_capacityAndFlags - 3), 4, *p_m_capacityAndFlags & 0x3FFFFFFF);
      *(_QWORD *)(p_m_capacityAndFlags - 3) = 0i64;
      *p_m_capacityAndFlags = 0x80000000;
      p_m_capacityAndFlags -= 4;
      --v4;
    }
    while ( v4 >= 0 );
  }
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_data = NULL;
  this->m_capacityAndFlags = 0x80000000;
}

/*
==============
hkArray<int,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<int,hkContainerHeapAllocator>::reflectValidate(hkArray<int,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  int *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hknpShape *,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hknpShape *,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpShape *,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hknpShape **m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::reflectValidate(hkArray<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  HavokPhysicsShapeList::ShapeTagData *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::reflectValidate(hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hkStringPtr,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hkStringPtr,hkContainerHeapAllocator>::reflectValidate(hkArray<hkStringPtr,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hkStringPtr *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hkTransformf,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hkTransformf,hkContainerHeapAllocator>::reflectValidate(hkArray<hkTransformf,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hkTransformf *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hkVector4f,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hkVector4f,hkContainerHeapAllocator>::reflectValidate(hkArray<hkVector4f,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hkVector4f *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hknpBodyQuality,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hknpBodyQuality,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpBodyQuality,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hknpBodyQuality *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hknpMaterial,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hknpMaterial,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpMaterial,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hknpMaterial *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<hknpMotionProperties,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<hknpMotionProperties,hkContainerHeapAllocator>::reflectValidate(hkArray<hknpMotionProperties,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  hknpMotionProperties *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<bool,hkContainerHeapAllocator>::reflectValidate
==============
*/
bool hkArray<bool,hkContainerHeapAllocator>::reflectValidate(hkArray<bool,hkContainerHeapAllocator> *this)
{
  int m_size; 
  int v2; 
  bool *m_data; 
  bool result; 

  m_size = this->m_size;
  result = 0;
  if ( m_size >= 0 )
  {
    v2 = this->m_capacityAndFlags & 0x3FFFFFFF;
    if ( v2 >= m_size )
    {
      m_data = this->m_data;
      if ( v2 ? m_data != NULL : m_data == NULL )
        return 1;
    }
  }
  return result;
}

/*
==============
hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>(hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator> *this)
{
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
  this->m_size = 0;
}

