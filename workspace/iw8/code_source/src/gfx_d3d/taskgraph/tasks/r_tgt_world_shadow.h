/*
==============
RBT_SunShadow_BlitCache
==============
*/

void __fastcall RBT_SunShadow_BlitCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_BlitCache@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_GenerateCompressedSunShadow_Compress@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SunShadow_ExtractCssClippingPlanes
==============
*/

void __fastcall RBT_SunShadow_ExtractCssClippingPlanes(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ExtractCssClippingPlanes@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SunShadow_CreateVisibilityIndirectBuffers@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SunShadow_ClearTranslucentAsync
==============
*/

void __fastcall RBT_SunShadow_ClearTranslucentAsync(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ClearTranslucentAsync@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawCascade
==============
*/

void __fastcall RBT_SunShadow_DrawCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawCascade@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityPrepass@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
RBT_SunShadow_CopyDepth
==============
*/

void __fastcall RBT_SunShadow_CopyDepth(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_CopyDepth@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawCache
==============
*/

void __fastcall RBT_SunShadow_DrawCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawCache@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass_Internal
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepass_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsWavePacking)
{
  ?RBT_SunShadow_GenerateVisibilityPrepass_Internal@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@_N@Z(computeState, taskInfo, viewInfo, data, vrsWavePacking);
}

/*
==============
cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_SunShadow_DrawCache@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_SunShadow_ClearCascade@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_SunShadow_DepthReadBarrier@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>)
{
  return ??$cRBT_SunShadow_DownsamplePass1@UR_TG_Handle@@H@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@AEBH@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_GenerateCompressedSunShadow_Compress
==============
*/

void __fastcall RBT_GenerateCompressedSunShadow_Compress(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GenerateCompressedSunShadow_Compress@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawTranslucent
==============
*/

void __fastcall RBT_SunShadow_DrawTranslucent(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawTranslucent@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA
==============
*/

void __fastcall RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TG_CompressSunShadowCascades
==============
*/

void __fastcall R_TG_CompressSunShadowCascades(R_TG_Script *pScript, R_TG_Handle *sunshadowCascades, R_TG_Handle *sunshadowCascadesBackface, R_TG_Handle *compressedCascades, unsigned int cascadesCount, R_TG_Handle nullBuffer)
{
  ?R_TG_CompressSunShadowCascades@@YAXPEAUR_TG_Script@@QEAUR_TG_Handle@@11IU2@@Z(pScript, sunshadowCascades, sunshadowCascadesBackface, compressedCascades, cascadesCount, nullBuffer);
}

/*
==============
cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_SunShadow_DownsamplePass0@UR_TG_Handle@@U1@HU1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1AEBH1@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_SunShadow_DepthReadBarrier
==============
*/

void __fastcall RBT_SunShadow_DepthReadBarrier(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DepthReadBarrier@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_CompressSunShadow_Main
==============
*/

void __fastcall RBT_CompressSunShadow_Main(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CompressSunShadow_Main@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>);
}

/*
==============
RT_SunShadow_DrawCascadeSetup
==============
*/

void __fastcall RT_SunShadow_DrawCascadeSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawCascadeSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityPrepass@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBTD_Shadow_Overlay@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
RT_SunShadow_DrawCacheSetup
==============
*/

void __fastcall RT_SunShadow_DrawCacheSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawCacheSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SunShadow_BlitCache_CS
==============
*/

void __fastcall RBT_SunShadow_BlitCache_CS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_BlitCache_CS@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_CreateVisibilityIndirectBuffers
==============
*/

void __fastcall RBT_SunShadow_CreateVisibilityIndirectBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_CreateVisibilityIndirectBuffers@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DownsamplePass1
==============
*/

void __fastcall RBT_SunShadow_DownsamplePass1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DownsamplePass1@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SunShadow_CopyDepth@UR_TG_Handle@@U1@HU1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1AEBH11@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RT_SunShadow_DrawTranslucentSetup
==============
*/

void __fastcall RT_SunShadow_DrawTranslucentSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawTranslucentSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityPrepassVRS@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
RBT_SunShadow_GenerateVisibilityInlineResolve
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_Shadow_Overlay
==============
*/

void __fastcall RBTD_Shadow_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Shadow_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_SunShadow_Resolve@UR_TG_Handle@@HU1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@AEBH1@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepassVRS
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepassVRS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityPrepassVRS@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_SunShadow_ClearTranslucentAsync@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMask
==============
*/

void __fastcall RBT_Sunshadow_GenerateTransShadowMask(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Sunshadow_GenerateTransShadowMask@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DownsamplePass0
==============
*/

void __fastcall RBT_SunShadow_DownsamplePass0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DownsamplePass0@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_ClearCascade
==============
*/

void __fastcall RBT_SunShadow_ClearCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ClearCascade@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>)
{
  return ??$cRBT_SunShadow_GenerateVisibility@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>);
}

/*
==============
RBT_SunShadow_Resolve
==============
*/

void __fastcall RBT_SunShadow_Resolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_Resolve@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_GenerateVisibility
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibility(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibility@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_Sunshadow_GenerateTransShadowMask@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBTD_Shadow_Overlay.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_GenerateCompressedSunShadow_Compress.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_ClearCascade.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_SunShadow_ClearTranslucentAsync.m_index, &stack);
}

/*
==============
cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  int v12; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  m_index = g_R_TG_Def_RBT_SunShadow_CopyDepth.m_index;
  handleArgCount = arguments.handleArgCount + 1;
  arguments.handleArgs[0] = &<args_0>->index;
  arguments.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = arguments.handleArgCount;
  }
  v12 = *<args_2>;
  arguments.handleArgs[handleArgCount] = &<args_1>->index;
  ++arguments.handleArgCount;
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle>(context, m_index, &arguments, v12, <args_3>, <args_4>);
}

/*
==============
cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_CreateVisibilityIndirectBuffers.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_SunShadow_DepthReadBarrier.m_index, &stack);
}

/*
==============
cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  ++arguments.handleArgCount;
  arguments.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask<int,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_DownsamplePass0.m_index, &arguments, <args_1>, <args_2>, <args_3>);
}

/*
==============
cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>
==============
*/
unsigned int cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>)
{
  int v6; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  v6 = *<args_1>;
  ++arguments.handleArgCount;
  arguments.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask<>(context, g_R_TG_Def_RBT_SunShadow_DownsamplePass1.m_index, &arguments, v6);
}

/*
==============
cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_DrawCache.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibility.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityInlineResolve.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityPrepass.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityPrepassVRS.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>, const R_TG_Handle *<args_2>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<int,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_Resolve.m_index, &arguments, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Sunshadow_GenerateTransShadowMask.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_Shadow_Overlay
==============
*/
void RBTD_Shadow_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v6; 
  unsigned int v10; 
  unsigned __int16 m_surfaceID; 
  R_RT_Handle *v14; 
  bool v22; 
  bool v26; 
  int v32; 
  bool v46; 
  R_RT_Handle v53; 
  int integer; 
  R_RT_DepthHandle v55; 
  R_RT_ColorHandle v56; 
  R_RT_BufferHandle v57; 
  R_RT_ColorHandle v58; 
  R_RT_Handle v59; 
  R_RT_BufferHandle v60[3]; 
  R_RT_Handle v61[3]; 

  v6 = 0;
  _R12 = gfxContext;
  v10 = 0;
  _RBX = 0i64;
  integer = sm_showOverlay->current.integer;
  _RAX = taskInfo->attachments;
  do
  {
    m_surfaceID = _RAX[_RBX].m_surfaceID;
    v14 = &_RAX[_RBX];
    if ( m_surfaceID )
    {
      R_RT_Handle::GetSurface(v14);
    }
    else if ( v14->m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    _RAX = taskInfo->attachments;
    if ( !m_surfaceID )
      break;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+rbx]
      vmovups [rbp+rbx+130h+var_A0], ymm0
    }
    ++_RBX;
    ++v6;
    ++v10;
  }
  while ( v10 < 3 );
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups [rbp+130h+var_1A0], ymm0
    vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rbp+130h+var_1A0] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rbp+130h+var_100], ymm0
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups [rbp+130h+var_1A0], ymm0
    vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v22 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+130h+var_1A0] }
      if ( v22 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rbp+130h+var_E0], ymm0
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups [rbp+130h+var_1A0], ymm0
    vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+130h+var_1A0] }
      if ( v26 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rbp+130h+var_C0], ymm0
    vmovups ymm0, ymmword ptr [rax+120h]
    vmovd   eax, xmm0
    vmovups [rbp+130h+var_160], ymm0
    vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
        vmovups [rbp+130h+var_160], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
        vmovups [rbp+130h+var_160], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  v32 = integer;
  if ( integer )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+140h]
      vmovd   eax, xmm0
      vmovups [rbp+130h+var_180], ymm0
      vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v53);
      if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
          vmovups [rbp+130h+var_180], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
          vmovups [rbp+130h+var_180], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+0A0h]
      vmovd   eax, xmm1
      vmovups [rbp+130h+var_1A0], ymm1
      vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v53);
      if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
          vmovups [rbp+130h+var_1A0], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID]
          vmovups [rbp+130h+var_1A0], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rbp+130h+var_140], ymm0
      vmovups ymmword ptr [rsp+230h+var_1D0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v53);
      if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+230h+var_1D0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v46 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+130h+var_140] }
        if ( v46 )
          __debugbreak();
      }
    }
    __asm { vmovups ymm1, [rbp+130h+var_180] }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm2, [rbp+130h+var_160]
      vmovups [rbp+130h+var_140], ymm1
      vmovups ymm1, [rbp+130h+var_1A0]
      vmovups [rbp+130h+var_180], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups [rbp+130h+var_1A0], ymm1
      vmovups xmm1, xmmword ptr [r12]
      vmovups [rbp+130h+var_160], ymm2
      vmovups [rbp+130h+var_120], ymm0
      vmovups xmmword ptr [rsp+230h+var_1D0.m_surfaceID], xmm1
    }
    R_Shadow_DrawOverlay((GfxCmdBufContext *)&v53, viewInfo, v32, v61, v6, &v59, &v56, &v55, v60, &v57, &v58);
  }
  R_CompressedSunShadow_DrawOverlay(_R12, viewInfo);
}

/*
==============
RBT_CompressSunShadow_Main
==============
*/
void RBT_CompressSunShadow_Main(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v21; 
  bool v25; 
  const unsigned int *pTaskData; 
  __int64 v27; 
  ID3D12Resource **ConstantBuffers; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v30; 
  R_RT_Handle v34; 
  R_RT_Handle v35; 
  R_RT_Handle v36; 
  R_RT_DepthHandle v37; 
  R_RT_Handle v39; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_70], ymm0
    vmovups ymmword ptr [rbp+57h+var_D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v34);
    if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID]
        vmovups [rbp+57h+var_70], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID]
        vmovups [rbp+57h+var_70], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_50], ymm1
    vmovups ymmword ptr [rbp+57h+var_D0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v34);
    if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID]
        vmovups [rbp+57h+var_50], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID]
        vmovups [rbp+57h+var_50], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups ymmword ptr [rbp+57h+var_D0.m_surfaceID], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups ymmword ptr [rbp+57h+var_D0.m_surfaceID], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID] }
      if ( v21 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+57h+var_30.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID] }
      if ( v25 )
        __debugbreak();
    }
  }
  pTaskData = taskInfo->pTaskData;
  __asm { vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0 }
  v27 = *pTaskData;
  ConstantBuffers = R_CompressSunShadow_GetConstantBuffers();
  Surface = R_RT_Handle::GetSurface(&v39);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  R_ClearBuffer_Uint(computeState, (const GfxWrappedRWBuffer *)&Surface->1080, 0, 1, PIPE_FLUSH_PARTIAL);
  v30 = R_RT_Handle::GetSurface(&v36);
  if ( (v30->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 589, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  if ( (v30->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 590, ASSERT_TYPE_ASSERT, "(surface->m_rtFlags & R_RT_Flag_RWView)", (const char *)&queryFormat, "surface->m_rtFlags & R_RT_Flag_RWView") )
    __debugbreak();
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+57h+var_D0.m_surfaceID]
    vmovups ymm1, [rbp+57h+var_50]
    vmovups ymmword ptr [rbp+57h+var_30.m_surfaceID], ymm0
    vmovups ymm0, [rbp+57h+var_70]
    vmovups [rbp+57h+var_70], ymm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm1
  }
  R_CompressSunShadow(computeState, &ConstantBuffers[v27], &v37, (R_RT_DepthHandle *)&v36, (R_RT_BufferHandle *)&v39, &v30->m_buffer.m_wrappedBuffer.rwView);
}

/*
==============
RBT_GenerateCompressedSunShadow_Compress
==============
*/
void RBT_GenerateCompressedSunShadow_Compress(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_BlitCache
==============
*/
void RBT_SunShadow_BlitCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v8; 
  R_RT_Handle v13; 
  R_RT_DepthHandle v14; 

  _RBP = gfxContext;
  v8 = *taskInfo->pTaskData;
  if ( v8 < data->sunShadow.opaqueCascadeCount )
  {
    if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && viewInfo->useCachedSunShadow && data->sunShadow.firstCachedSunShadowPartition <= v8 && v8 <= data->sunShadow.lastCachedSunShadowPartition && R_GetSunShadowPartitionCache(&data->sunShadow, v8)->gfxCachedSunShadowOverlapCount )
    {
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovd   eax, xmm0
        vmovups [rsp+78h+var_28], ymm0
        vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
      }
      if ( (_WORD)_RAX )
      {
        R_RT_Handle::GetSurface(&v13);
        if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
        {
          __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
        }
        else
        {
          __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
          __debugbreak();
        }
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX )
        {
          __asm { vmovups ymm0, [rsp+78h+var_28] }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
            __debugbreak();
        }
      }
      __asm
      {
        vmovups [rsp+78h+var_28], ymm0
        vmovups xmm0, xmmword ptr [rbp+0]
        vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
      }
      R_DrawSunshadow_BlitCache(data, (GfxCmdBufContext *)&v13, v8, &v14);
    }
    else if ( (R_RT_Handle::GetSurface(&taskInfo->rtGroup.m_depthRt)->m_rtFlags & 0x100) == 0 )
    {
      R_ClearScreen(_RBP->state, 0x10u, 0);
    }
  }
}

/*
==============
RBT_SunShadow_BlitCache_CS
==============
*/
void RBT_SunShadow_BlitCache_CS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  ComputeCmdBufState *v11; 
  unsigned int v12; 
  GfxSunShadow *p_sunShadow; 
  const GfxSunShadowPartitionCache *SunShadowPartitionCache; 
  const dvar_t *v23; 
  const GfxSunShadowPartitionCache *v24; 
  __int64 gfxCachedSunShadowOverlapCount; 
  __int64 v29; 
  int MapSize; 
  int v32; 
  signed int v35; 
  int v38; 
  signed int v43; 
  unsigned int v44; 
  signed int v45; 
  int v46; 
  unsigned int v47; 
  unsigned int v48; 
  bool v51; 
  char v54; 
  bool v55; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *BaseSurface; 
  const unsigned __int8 *ResidentPixels; 
  const unsigned __int8 *v62; 
  const R_RT_Surface *v63; 
  __int64 v64; 
  __int64 m_htileSize; 
  unsigned int v70; 
  const R_RT_Surface *v71; 
  const unsigned __int8 *v72; 
  const R_RT_Surface *v73; 
  __int64 v75; 
  __int64 v76; 
  float v77; 
  float v78; 
  bool v79; 
  char v80; 
  int v81; 
  unsigned int v82; 
  unsigned int v83; 
  float outBias; 
  float outScale; 
  unsigned int v86; 
  R_RT_Handle v87; 
  ComputeCmdBufState *v88; 
  __int64 v89; 
  GfxSunShadow *sunShadow; 
  R_RT_DepthHandle v92; 
  ID3D12Resource *m_floatTexture; 
  int v95; 
  unsigned int m_subresourceToTransition; 
  R_RT_Handle v97; 
  R_RT_Handle v98; 
  char v99[56]; 
  char v100[56]; 

  pTaskData = taskInfo->pTaskData;
  v88 = computeState;
  v11 = computeState;
  v12 = *pTaskData;
  if ( *pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+170h+var_1B8], ymm0
      vmovups ymmword ptr [rbp+170h+var_1F0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v87);
      if ( (R_RT_Handle::GetSurface(&v87)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+170h+var_1F0.m_surfaceID]
          vmovups [rbp+170h+var_1B8], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+170h+var_1F0.m_surfaceID]
          vmovups [rbp+170h+var_1B8], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rbp+170h+var_1B8] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymmword ptr [rbp+170h+var_1F0.m_surfaceID], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovd   eax, xmm0
      vmovups [rbp+170h+var_160], ymm0
      vmovups ymmword ptr [rbp+170h+var_110.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v97);
      if ( (R_RT_Handle::GetSurface(&v97)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+170h+var_110.m_surfaceID]
          vmovups [rbp+170h+var_160], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+170h+var_110.m_surfaceID]
          vmovups [rbp+170h+var_160], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v51 = (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) == 0;
    __asm { vmovaps [rsp+270h+var_48+8], xmm6 }
    if ( !v51 && viewInfo->useCachedSunShadow && data->sunShadow.firstCachedSunShadowPartition <= v12 && v12 <= data->sunShadow.lastCachedSunShadowPartition && (p_sunShadow = &data->sunShadow, sunShadow = p_sunShadow, R_GetSunShadowPartitionCache(p_sunShadow, v12)->gfxCachedSunShadowOverlapCount) )
    {
      __asm { vmovaps [rsp+270h+var_58+8], xmm7 }
      SunShadowPartitionCache = R_GetSunShadowPartitionCache(p_sunShadow, v12);
      v23 = DCONST_DVARBOOL_r_resolveSunCacheFinal;
      v24 = SunShadowPartitionCache;
      v80 = 0;
      __asm { vmovss  xmm7, cs:__real@3f800000 }
      gfxCachedSunShadowOverlapCount = SunShadowPartitionCache->gfxCachedSunShadowOverlapCount;
      __asm
      {
        vxorps  xmm6, xmm6, xmm6
        vmovss  [rsp+270h+outBias], xmm6
        vmovss  [rsp+270h+outScale], xmm7
      }
      if ( !DCONST_DVARBOOL_r_resolveSunCacheFinal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resolveSunCacheFinal") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v23);
      v79 = !v23->current.enabled || (R_RT_Handle::GetSurface(&v87)->m_rtFlags & 0x100) == 0 && Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_sm_sunCascadeHtileUseCacheHiZ, "sm_sunCascadeHtileUseCacheHiZ");
      if ( (_DWORD)gfxCachedSunShadowOverlapCount )
      {
        _R14 = &v24->gfxCachedSunShadowOverlap[0].x;
        v89 = gfxCachedSunShadowOverlapCount;
        do
        {
          v29 = *(_QWORD *)(_R14 - 11);
          __asm
          {
            vmovups ymm0, [rbp+170h+var_160]
            vmovups ymmword ptr [rbp+170h+var_110.m_surfaceID], ymm0
          }
          R_SunShadowCache_GetDepthRt((R_RT_DepthHandle *)&v98, *(unsigned __int16 *)(v29 + 502), (R_RT_DepthHandle *)&v97);
          MapSize = R_SunShadow_GetMapSize();
          v32 = MapSize;
          __asm
          {
            vcvttss2si esi, dword ptr [r14]
            vcvttss2si r12d, dword ptr [r14+4]
          }
          if ( MapSize < 0 )
          {
            LODWORD(v76) = MapSize;
            LODWORD(v75) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v75, v76) )
              __debugbreak();
          }
          v35 = _ESI;
          if ( v32 < _ESI )
            v35 = v32;
          if ( v35 < 0 )
            v35 = 0;
          if ( v32 < 0 )
          {
            LODWORD(v76) = v32;
            LODWORD(v75) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v75, v76) )
              __debugbreak();
          }
          __asm
          {
            vmovss  xmm0, dword ptr [r14+8]
            vaddss  xmm1, xmm0, dword ptr [r14]
          }
          v38 = _ER12;
          if ( v32 < _ER12 )
            v38 = v32;
          if ( v38 < 0 )
            v38 = 0;
          v86 = v35 - _ESI;
          v83 = v38;
          v81 = v38 - _ER12;
          __asm { vcvttss2si r12d, xmm1 }
          if ( v32 < 0 )
          {
            LODWORD(v76) = v32;
            LODWORD(v75) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v75, v76) )
              __debugbreak();
          }
          __asm
          {
            vmovss  xmm0, dword ptr [r14+0Ch]
            vaddss  xmm1, xmm0, dword ptr [r14+4]
            vcvttss2si esi, xmm1
          }
          if ( v32 < _ER12 )
            _ER12 = v32;
          if ( _ER12 < 0 )
            _ER12 = 0;
          v43 = _ER12 - v35;
          if ( v32 < 0 )
          {
            LODWORD(v76) = v32;
            LODWORD(v75) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v75, v76) )
              __debugbreak();
          }
          v44 = v83;
          if ( v32 < _ESI )
            _ESI = v32;
          if ( _ESI < 0 )
            _ESI = 0;
          v45 = _ESI - v83;
          v46 = v45;
          if ( v43 < v45 )
            v46 = v43;
          if ( v46 <= 0 )
          {
            v11 = v88;
          }
          else
          {
            v47 = *(_DWORD *)(v29 + 508) + v81;
            v48 = *(_DWORD *)(v29 + 504) + v86;
            v82 = v47;
            if ( rg.useCompressedSunShadowClipPlanes )
            {
              __asm
              {
                vmovss  xmm2, dword ptr [r14+18h]; farClip
                vmovss  xmm1, dword ptr [r14+14h]; nearClip
              }
              R_CompressedSunShadow_GetClipPlanesScaleBias(sunShadow, *(const float *)&_XMM1, *(const float *)&_XMM2, &outScale, &outBias);
              __asm
              {
                vmovss  xmm2, [rsp+270h+outScale]
                vucomiss xmm2, xmm7
                vmovss  xmm1, [rsp+270h+outBias]
              }
              if ( !v51 )
                goto LABEL_68;
              __asm { vucomiss xmm1, xmm6 }
              if ( v51 )
              {
                v47 = v82;
                v54 = 0;
                v44 = v83;
                v80 = 0;
              }
              else
              {
LABEL_68:
                v47 = v82;
                v54 = 1;
                v44 = v83;
                v80 = 1;
              }
            }
            else
            {
              __asm
              {
                vmovss  xmm1, [rsp+270h+outBias]
                vmovss  xmm2, [rsp+270h+outScale]
              }
              v54 = v80;
            }
            v55 = v79 || v54;
            v79 = v55;
            if ( v55 )
            {
              __asm { vmovups ymm0, [rbp+170h+var_1B8] }
              v11 = v88;
              __asm
              {
                vmovss  dword ptr [rsp+270h+var_220], xmm2
                vmovss  [rsp+270h+var_228], xmm1
                vmovups ymmword ptr [rbp+170h+var_110.m_surfaceID], ymm0
                vmovups ymm0, ymmword ptr [rbp+170h+var_F0.m_surfaceID]
                vmovups ymmword ptr [rbp+170h+var_190.baseclass_0.m_surfaceID], ymm0
              }
              R_CopyCompressedDepthRect(v88, &v92, &v97, v48, v47, v35, v44, v43, v45, v77, v78, 0);
            }
            else
            {
              if ( v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 199, ASSERT_TYPE_ASSERT, "( !useScaleBias )", "xbox todo: uncompressed depth copy with scale+bias") )
                __debugbreak();
              *(_DWORD *)&v97.m_surfaceID = v48;
              *(&v97.m_tracking.m_allocCounter + 1) = v43 + v48;
              *((_DWORD *)&v97.m_surfaceID + 1) = v82;
              LODWORD(v97.m_tracking.m_name) = v45 + v82;
              v97.m_tracking.m_allocCounter = 0;
              HIDWORD(v97.m_tracking.m_name) = 1;
              *(_QWORD *)&v92.m_surfaceID = R_RT_Handle::GetSurface(&v98)->m_depth.m_floatTexture;
              v92.m_tracking.m_allocCounter = 0;
              if ( R_RT_Handle::GetSurface(&v98)->m_subresourceToTransition == -1 )
                LODWORD(v92.m_tracking.m_name) = 0;
              else
                LODWORD(v92.m_tracking.m_name) = R_RT_Handle::GetSurface(&v98)->m_subresourceToTransition;
              (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)&v92.m_surfaceID + 80i64))(*(_QWORD *)&v92.m_surfaceID, v99);
              m_floatTexture = R_RT_Handle::GetSurface(&v87)->m_depth.m_floatTexture;
              v95 = 0;
              if ( R_RT_Handle::GetSurface(&v87)->m_subresourceToTransition == -1 )
                m_subresourceToTransition = 0;
              else
                m_subresourceToTransition = R_RT_Handle::GetSurface(&v87)->m_subresourceToTransition;
              ((void (__fastcall *)(ID3D12Resource *, char *))m_floatTexture->m_pFunction[3].AddRef)(m_floatTexture, v100);
              v11 = v88;
              ((void (__fastcall *)(GfxDevice *, ID3D12Resource **, _QWORD, _QWORD, _DWORD, R_RT_DepthHandle *, R_RT_Handle *, _DWORD))v88->device->m_pFunction[27].Release)(v88->device, &m_floatTexture, (unsigned int)v35, v83, 0, &v92, &v97, 0);
            }
          }
          _R14 += 216;
          --v89;
        }
        while ( v89 );
      }
      Surface = R_RT_Handle::GetSurface(&v87);
      __asm { vmovaps xmm7, [rsp+270h+var_58+8] }
      if ( (Surface->m_rtFlags & 0x100) != 0 || v79 )
        goto LABEL_103;
      if ( (R_RT_Handle::GetSurface(&v87)->m_rtFlags & 0x80) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 258, ASSERT_TYPE_ASSERT, "( !sunshadowCascade.HTile_EncodesStencil() )", "need default hiZ value for hiS") )
        __debugbreak();
      BaseSurface = R_RT_Handle::GetBaseSurface(&v87);
      ResidentPixels = R_Image_GetResidentPixels(&BaseSurface->m_image.m_base);
      v62 = &ResidentPixels[R_RT_Handle::GetSurface(&v87)->m_htileOffset];
      v63 = R_RT_Handle::GetSurface(&v87);
      v64 = 4294705167i64;
      m_htileSize = v63->m_htileSize;
    }
    else
    {
      if ( (R_RT_Handle::GetSurface(&v87)->m_rtFlags & 0x100) == 0 )
      {
LABEL_103:
        __asm { vmovaps xmm6, [rsp+270h+var_48+8] }
        return;
      }
      _RBX = R_RT_Handle::GetSurface(&v87);
      if ( (_RBX->m_rtFlagsInternal & 0x10) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 400, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth") )
        __debugbreak();
      __asm
      {
        vmovss  xmm6, dword ptr [rbx+8E0h]
        vmovss  [rsp+270h+anonymous_0], xmm6
      }
      if ( R_RT_Handle::GetSurface(&v87)->m_image.m_base.format == GFX_PF_D16 )
      {
        __asm
        {
          vmulss  xmm0, xmm6, cs:__real@477fff00
          vcvttss2si rax, xmm0
        }
        v70 = 65537 * _RAX;
      }
      else
      {
        v70 = v86;
      }
      v71 = R_RT_Handle::GetBaseSurface(&v87);
      v72 = R_Image_GetResidentPixels(&v71->m_image.m_base);
      v62 = &v72[R_RT_Handle::GetSurface(&v87)->m_textureOffset];
      v73 = R_RT_Handle::GetSurface(&v87);
      v64 = v70;
      m_htileSize = v73->m_textureSize;
    }
    ((void (__fastcall *)(GfxDevice *, const unsigned __int8 *, __int64, __int64, _DWORD))v11->device->m_pFunction[20].AddRef)(v11->device, v62, m_htileSize, v64, 0);
    goto LABEL_103;
  }
}

/*
==============
RBT_SunShadow_ClearCascade
==============
*/
void RBT_SunShadow_ClearCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_ClearTranslucentAsync
==============
*/
void RBT_SunShadow_ClearTranslucentAsync(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v10; 
  R_RT_Handle v11; 

  if ( rg.useTransSunShadow && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && data->transShadowBoundsCountPrevFrame )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups [rsp+78h+var_28], ymm0
    }
    R_RT_ColorHandle::Cast((R_RT_ColorHandle *)&v10, &v11);
    if ( (R_RT_Handle::GetSurface(&v10)->m_rtFlags & 9) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 510, ASSERT_TYPE_ASSERT, "((colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0)", "%s\n\tclear not possible for rts with meta data", "(colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0") )
      __debugbreak();
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID]
      vmovups [rsp+78h+var_28], ymm0
    }
    R_Sunshadow_ClearTranslucent(computeState, viewInfo, data, (R_RT_ColorHandle *)&v11);
  }
}

/*
==============
RBT_SunShadow_CopyDepth
==============
*/
void RBT_SunShadow_CopyDepth(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v6; 
  unsigned int v10; 
  unsigned int MapSize; 
  unsigned int v12; 
  int v13; 
  int v14; 
  int v15; 
  int v16; 
  unsigned int v17; 
  int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  const dvar_t *v28; 
  const dvar_t *v35; 
  R_RT_Handle *ViewInternal; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  unsigned int v40; 
  const GfxTexture *v41; 
  float v42; 
  float v43; 
  unsigned int outX; 
  unsigned int outY; 
  unsigned int outSizeX; 
  unsigned int outSizeY; 
  R_RT_Handle v48; 
  const GfxTaskInfo *v49; 
  R_RT_Handle v50; 
  R_RT_Handle v51; 

  v6 = (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) == 0;
  _RDI = viewInfo;
  v49 = taskInfo;
  if ( !v6 )
  {
    v10 = *taskInfo->pTaskData;
    MapSize = R_SunShadow_GetMapSize();
    v12 = MapSize;
    if ( v10 )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi+964h]
        vmovsd  xmm1, qword ptr [rdi+974h]
        vmovups xmmword ptr [rbp+40h+var_70.m_surfaceID], xmm0
        vmovsd  [rbp+40h+var_70.m_tracking.m_name], xmm1
      }
      Bounds_OverlapProjectionGrid((const Bounds *)&v51, &data->sunShadow.lookupMatrix.m, MapSize >> 3, &outX, &outY, &outSizeX, &outSizeY);
      v13 = 8 * outX;
      v14 = 8 * outY;
      v15 = I_clamp(8 * outX + 8 * outSizeX, 0, v12);
      v16 = I_clamp(v14 + 8 * outSizeY, 0, v12);
      v17 = I_clamp(v13, 0, v12);
      v18 = I_clamp(v14, 0, v12);
      v19 = v15 - v17;
      v20 = v16 - v18;
      outX = v19;
      v21 = v18;
      if ( !v19 || !v20 )
        return;
    }
    else
    {
      v21 = 0;
      outX = MapSize;
      v17 = 0;
      v20 = MapSize;
      v19 = MapSize;
    }
    _RAX = v49->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups [rbp+40h+var_90], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovd   eax, xmm0
      vmovups [rbp+40h+var_C0], ymm0
      vmovups ymmword ptr [rbp+40h+var_70.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v51);
      if ( (R_RT_Handle::GetSurface(&v51)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+40h+var_70.m_surfaceID]
          vmovups [rbp+40h+var_C0], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+40h+var_70.m_surfaceID]
          vmovups [rbp+40h+var_C0], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v28 = DCONST_DVARBOOL_sm_sunCompressedCopy;
    if ( !DCONST_DVARBOOL_sm_sunCompressedCopy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunCompressedCopy") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v28);
    if ( v28->current.enabled )
    {
      __asm
      {
        vmovups ymm0, [rbp+40h+var_90]
        vmovups ymmword ptr [rbp+40h+var_70.m_surfaceID], ymm0
        vmovups ymm0, [rbp+40h+var_C0]
        vmovups [rbp+40h+var_C0], ymm0
        vmovss  xmm0, cs:__real@3f800000
        vmovss  [rsp+140h+var_F0], xmm0
        vxorps  xmm1, xmm1, xmm1
        vmovss  [rsp+140h+var_F8], xmm1
      }
      R_CopyCompressedDepthRect(computeState, (R_RT_DepthHandle *)&v48, &v51, v17, v21, v17, v21, v19, v20, v42, v43, 1);
    }
    else
    {
      __asm
      {
        vmovups ymm0, [rbp+40h+var_C0]
        vmovups [rbp+40h+var_C0], ymm0
        vmovups ymm0, [rbp+40h+var_90]
        vmovups ymmword ptr [rbp+40h+var_70.m_surfaceID], ymm0
      }
      R_CopyTextureRect(computeState, &v51, &v48, v17, v21, 0, 0, v17, v21, 0, 0, v19, v20);
    }
    v35 = DCONST_DVARBOOL_sm_sunSafeCopy;
    if ( !DCONST_DVARBOOL_sm_sunSafeCopy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunSafeCopy") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v35);
    if ( v35->current.enabled )
    {
      __asm
      {
        vmovups ymm0, [rbp+40h+var_90]
        vmovups [rbp+40h+var_90], ymm0
      }
      ViewInternal = R_RT_GetViewInternal(&v48, &v50, 0, 0);
      Surface = R_RT_Handle::GetSurface(ViewInternal);
      Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
      v40 = v21 + v20;
      v41 = Resident;
      if ( v21 )
        R_SetTextureRect(computeState, Resident, &colorBlack, 0, 0, v12, v21);
      if ( v17 )
        R_SetTextureRect(computeState, v41, &colorBlack, 0, v21, v17, v20);
      if ( v17 + outX < v12 )
        R_SetTextureRect(computeState, v41, &colorBlack, v17 + outX, v21, v12 - (v17 + outX), v20);
      if ( v40 < v12 )
        R_SetTextureRect(computeState, v41, &colorBlack, 0, v21 + v20, v12, v12 - v40);
    }
  }
}

/*
==============
RBT_SunShadow_CreateVisibilityIndirectBuffers
==============
*/
void RBT_SunShadow_CreateVisibilityIndirectBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxShaderBufferRWView *p_rwView; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v11; 
  GfxShaderBufferRWView *views; 

  R_SetComputeShader(computeState, rgp.csmPrepassInitIndirectArgs);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v11);
    Surface = R_RT_Handle::GetSurface(&v11);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v11.m_surfaceID) )
      __debugbreak();
    p_rwView = &Surface->m_buffer.m_wrappedBuffer.rwView;
  }
  else
  {
    if ( v11.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v11.m_surfaceID) )
      __debugbreak();
    p_rwView = &gfxBuf.dummyRWBuffer.rwView;
  }
  views = p_rwView;
  R_SetComputeRWViewsWithCounters(computeState, 1, 1, (const GfxShaderBufferRWView *const *)&views, NULL);
  R_Dispatch(computeState, 1u, 1u, 1u);
}

/*
==============
RBT_SunShadow_DepthReadBarrier
==============
*/
void RBT_SunShadow_DepthReadBarrier(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_DownsamplePass0
==============
*/
void RBT_SunShadow_DownsamplePass0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  int width; 
  const R_RT_Surface *Surface; 
  int height; 
  bool v18; 
  const R_RT_Surface *v20; 
  bool v25; 
  const R_RT_Surface *v26; 
  bool v31; 
  const R_RT_Surface *v32; 
  bool v37; 
  const R_RT_Surface *v38; 
  bool v43; 
  const R_RT_Surface *v44; 
  __int64 v52; 
  __int64 v53; 
  GfxShaderTextureRWView *views; 
  _QWORD v55[5]; 
  R_RT_Handle v56; 
  R_RT_Handle v57; 
  R_RT_Handle v58; 
  R_RT_Handle v59; 
  int dataa[4]; 

  if ( *taskInfo->pTaskData >= data->sunShadow.opaqueCascadeCount )
    return;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_B0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+50h+var_70.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v59);
    if ( (R_RT_Handle::GetSurface(&v59)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID]
        vmovups ymmword ptr [rbp+50h+var_B0.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID]
        vmovups ymmword ptr [rbp+50h+var_B0.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
    vmovups ymmword ptr [rbp+50h+var_70.m_surfaceID], ymm0
  }
  width = R_RT_Handle::GetSurface(&v59)->m_image.m_base.width;
  Surface = R_RT_Handle::GetSurface(&v59);
  height = Surface->m_image.m_base.height;
  if ( width != height && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 811, ASSERT_TYPE_ASSERT, "( width ) == ( height )", "%s == %s\n\t%i, %i", "width", "height", width, Surface->m_image.m_base.height) )
    __debugbreak();
  if ( (_BYTE)width )
  {
    LODWORD(v52) = (unsigned __int8)width;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 812, ASSERT_TYPE_ASSERT, "( width % 256 ) == ( 0 )", "%s == %s\n\t%i, %i", "width % 256", "0", v52, 0i64) )
      __debugbreak();
  }
  if ( R_RT_Handle::GetSurface(&v56)->m_image.m_base.levelCount != 8 )
  {
    LODWORD(v53) = 8;
    LODWORD(v52) = R_RT_Handle::GetSurface(&v56)->m_image.m_base.levelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 813, ASSERT_TYPE_ASSERT, "( sunshadowMin.GetMipCount() ) == ( 8 )", "%s == %s\n\t%i, %i", "sunshadowMin.GetMipCount()", "SUN_MIN_DEPTH_MIP_LIMIT", v52, v53) )
      __debugbreak();
  }
  if ( (R_RT_Handle::GetSurface(&v59)->m_rtFlagsInternal & 0x10) == 0 )
  {
    v20 = R_RT_Handle::GetSurface(&v59);
    views = (GfxShaderTextureRWView *)R_Texture_GetResident(v20->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 4, 1, (const GfxTexture *const *)&views);
    goto LABEL_29;
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+150h+var_F8+8]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x10) == 0 )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()");
LABEL_25:
      if ( v18 )
        __debugbreak();
    }
  }
  else if ( v59.m_tracking.m_allocCounter )
  {
    v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_EAX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
    goto LABEL_25;
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+50h+var_D0.m_surfaceID]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
  }
  views = R_RT_GetDepthRWView((GfxShaderTextureRWView *)&v59, (R_RT_DepthHandle *)&v55[1]);
  R_SetComputeTextureRWViews(computeState, 4, 1, (const GfxShaderTextureRWView *const *)&views);
LABEL_29:
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v58, (R_RT_Handle *)&v55[1], 0, 0);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+50h+var_70.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v59);
    if ( (R_RT_Handle::GetSurface(&v59)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_D0.m_surfaceID] }
      if ( v25 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0 }
  v26 = R_RT_Handle::GetSurface((R_RT_Handle *)&v55[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v26->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&views);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v58, (R_RT_Handle *)&v55[1], 0, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+50h+var_70.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v59);
    if ( (R_RT_Handle::GetSurface(&v59)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v31 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_D0.m_surfaceID] }
      if ( v31 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0 }
  v32 = R_RT_Handle::GetSurface((R_RT_Handle *)&v55[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v32->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 1, 1, (const GfxTexture *const *)&views);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v58, (R_RT_Handle *)&v55[1], 0, 2);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+50h+var_70.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v59);
    if ( (R_RT_Handle::GetSurface(&v59)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_70.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v37 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_D0.m_surfaceID] }
      if ( v37 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0 }
  v38 = R_RT_Handle::GetSurface((R_RT_Handle *)&v55[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v38->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 2, 1, (const GfxTexture *const *)&views);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID]
    vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v58, (R_RT_Handle *)&v55[1], 0, 3);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+50h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v57);
    if ( (R_RT_Handle::GetSurface(&v57)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_B0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v43 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+50h+var_D0.m_surfaceID] }
      if ( v43 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+150h+var_F8+8], ymm0 }
  v44 = R_RT_Handle::GetSurface((R_RT_Handle *)&v55[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v44->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 3, 1, (const GfxTexture *const *)&views);
  R_SetComputeShader(computeState, rgp.sunshadowDownsample);
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rbx
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rsi
    vmovss  [rbp+50h+data], xmm0
    vdivss  xmm0, xmm1, xmm0
    vdivss  xmm1, xmm1, xmm2
    vmovss  [rbp+50h+var_44], xmm1
    vmovss  [rbp+50h+var_4C], xmm2
    vmovss  [rbp+50h+var_48], xmm0
  }
  R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
  R_Dispatch(computeState, (unsigned int)(width + 15) >> 4, (unsigned int)(height + 15) >> 4, 1u);
}

/*
==============
RBT_SunShadow_DownsamplePass1
==============
*/
void RBT_SunShadow_DownsamplePass1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  int v10; 
  const R_RT_Surface *Surface; 
  int v13; 
  bool v17; 
  const R_RT_Surface *v18; 
  bool v23; 
  const R_RT_Surface *v24; 
  bool v29; 
  const R_RT_Surface *v30; 
  bool v35; 
  const R_RT_Surface *v36; 
  bool v41; 
  const R_RT_Surface *v42; 
  GfxTexture *textures[2]; 
  R_RT_Handle v51; 
  R_RT_Handle v52; 
  R_RT_Handle v54; 
  int dataa[4]; 

  if ( *taskInfo->pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+57h+var_80], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
          vmovups [rbp+57h+var_80], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
          vmovups [rbp+57h+var_80], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rbp+57h+var_80] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0 }
    v10 = R_RT_Handle::GetSurface(&v52)->m_image.m_base.width >> 3;
    Surface = R_RT_Handle::GetSurface(&v52);
    __asm { vmovups ymm0, [rbp+57h+var_80] }
    v13 = Surface->m_image.m_base.height >> 3;
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    _RAX = R_RT_GetViewInternal(&v54, &v51, 0, 3);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
        if ( v17 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    v18 = R_RT_Handle::GetSurface(&v51);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v18->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 4, 1, (const GfxTexture *const *)textures);
    __asm
    {
      vmovups ymm0, [rbp+57h+var_80]
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
    }
    _RAX = R_RT_GetViewInternal(&v54, &v51, 0, 4);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
        if ( v23 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    v24 = R_RT_Handle::GetSurface(&v51);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v24->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)textures);
    __asm
    {
      vmovups ymm0, [rbp+57h+var_80]
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
    }
    _RAX = R_RT_GetViewInternal(&v54, &v51, 0, 5);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v29 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
        if ( v29 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    v30 = R_RT_Handle::GetSurface(&v51);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v30->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 1, 1, (const GfxTexture *const *)textures);
    __asm
    {
      vmovups ymm0, [rbp+57h+var_80]
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
    }
    _RAX = R_RT_GetViewInternal(&v54, &v51, 0, 6);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v35 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
        if ( v35 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    v36 = R_RT_Handle::GetSurface(&v51);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v36->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 2, 1, (const GfxTexture *const *)textures);
    __asm
    {
      vmovups ymm0, [rbp+57h+var_80]
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
    }
    _RAX = R_RT_GetViewInternal(&v54, &v51, 0, 7);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v52);
      if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
        if ( v41 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0 }
    v42 = R_RT_Handle::GetSurface(&v51);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v42->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 3, 1, (const GfxTexture *const *)textures);
    R_SetComputeShader(computeState, rgp.sunshadowDownsample);
    __asm
    {
      vmovss  xmm1, cs:__real@3f800000
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rax
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, rax
      vmovss  [rbp+57h+data], xmm0
      vdivss  xmm0, xmm1, xmm0
      vdivss  xmm1, xmm1, xmm2
      vmovss  [rbp+57h+var_34], xmm1
      vmovss  [rbp+57h+var_3C], xmm2
      vmovss  [rbp+57h+var_38], xmm0
    }
    R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
    R_Dispatch(computeState, (unsigned int)(v10 + 15) >> 4, (unsigned int)(v13 + 15) >> 4, 1u);
  }
}

/*
==============
RBT_SunShadow_DrawCache
==============
*/
void RBT_SunShadow_DrawCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v18; 
  R_RT_Handle v21; 
  R_RT_DepthHandle v22; 
  R_RT_DepthHandle v23; 

  _RBP = gfxContext;
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rsp+0A8h+var_58], ymm1
      vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v21);
      if ( (R_RT_Handle::GetSurface(&v21)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
          vmovups [rsp+0A8h+var_58], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
          vmovups [rsp+0A8h+var_58], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+0A8h+var_38.baseclass_0.m_surfaceID], ymm0
      vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v21);
      if ( (R_RT_Handle::GetSurface(&v21)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_38.baseclass_0.m_surfaceID] }
        if ( v18 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, [rsp+0A8h+var_58]
      vmovups ymmword ptr [rsp+0A8h+var_38.baseclass_0.m_surfaceID], ymm0
      vmovups xmm0, xmmword ptr [rbp+0]
      vmovups xmmword ptr [rsp+0A8h+var_78.m_surfaceID], xmm0
      vmovups [rsp+0A8h+var_58], ymm1
    }
    R_DrawSunshadow_DrawCacheForAllCascades((GfxCmdBufContext *)&v21, data, viewInfo, &v22, &v23, D3D12XBOX_RESOURCE_STATE_PRESERVE_COMPRESSED_DEPTH|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_DEPTH_READ);
  }
}

/*
==============
RBT_SunShadow_DrawCascade
==============
*/
void RBT_SunShadow_DrawCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  int v8; 
  MaterialTechniqueType v9; 
  R_RT_DepthHandle v11; 
  GfxDrawCallOutput drawOutput; 

  pTaskData = taskInfo->pTaskData;
  _R14 = taskInfo;
  v8 = *pTaskData;
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v9 = pTaskData[1];
    if ( !data->sunShadow.opaqueCascadeCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 458, ASSERT_TYPE_ASSERT, "(data->sunShadow.opaqueCascadeCount > 0)", (const char *)&queryFormat, "data->sunShadow.opaqueCascadeCount > 0") )
      __debugbreak();
    if ( (v8 > 26 || v8 <= data->sunShadow.opaqueCascadeCount + 23) && (viewInfo->useDynamicSunShadows || !viewInfo->useCachedSunShadow) && R_RunDrawListCommandBuffer(data, (const GfxDrawListType)v8) )
    {
      R_GPU_BeginRunDrawListTimer((const GfxDrawListType)v8);
      R_InitDrawCallOutput(data, &drawOutput);
      __asm
      {
        vmovups ymm0, ymmword ptr [r14+0B8h]
        vmovups [rsp+2438h+var_2408], ymm0
      }
      R_DrawSunshadow_DrawCascade(viewInfo, (GfxDrawListType)v8, &v11, v9, &drawOutput);
      R_GPU_EndTimer();
    }
  }
}

/*
==============
RBT_SunShadow_DrawTranslucent
==============
*/
void RBT_SunShadow_DrawTranslucent(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int128 state; 
  GfxDrawCallOutput drawOutput; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+2428h+state], xmm0
  }
  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    if ( (unsigned __int16)(viewInfo->input.data->sunShadow.opaqueCascadeCount - 1) > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 596, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT", state) )
      __debugbreak();
    if ( *taskInfo->pTaskData == viewInfo->input.data->sunShadow.opaqueCascadeCount - 1 )
    {
      if ( (taskInfo->pGraphInfo->taskFlags & 0x200) == 0 )
        R_ClearRtGroup(*((GfxCmdBufState **)&state + 1), &taskInfo->rtGroup, 0xFu, 0, PIPE_FLUSH_FULL);
      if ( R_RunDrawListCommandBuffer(data, DRAWLIST_SUNSHADOW_END) )
      {
        R_GPU_BeginRunDrawListTimer(DRAWLIST_SUNSHADOW_END);
        R_InitDrawCallOutput(data, &drawOutput);
        R_DrawSunshadow_DrawTranslucent(viewInfo, &viewInfo->drawList[27], &taskInfo->rtGroup, &drawOutput);
        R_GPU_EndTimer();
      }
    }
  }
}

/*
==============
RBT_SunShadow_ExtractCssClippingPlanes
==============
*/
void RBT_SunShadow_ExtractCssClippingPlanes(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v9; 
  R_RT_BufferHandle v10; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v9);
    if ( (R_RT_Handle::GetSurface(&v9)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0 }
  R_CompressedSunShadow_ExtractClipPlanes(computeState, &v10);
}

/*
==============
RBT_SunShadow_GenerateVisibility
==============
*/
void RBT_SunShadow_GenerateVisibility(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibility_Internal(computeState, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_SunShadow_GenerateVisibilityInlineResolve
==============
*/
void RBT_SunShadow_GenerateVisibilityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibility_Internal(computeState, taskInfo, viewInfo, data, 1);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibilityPrepass_Internal(computeState, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepassVRS
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepassVRS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibilityPrepass_Internal(computeState, taskInfo, viewInfo, data, 1);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass_Internal
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepass_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsWavePacking)
{
  ComputeShader *csmPrepass; 
  R_RT_Image *blackImage; 
  GfxTexture *Resident; 
  R_RT_Image *p_m_image; 
  GfxTexture *v18; 
  R_RT_Image *v19; 
  GfxTexture *v22; 
  R_RT_Image *v23; 
  GfxTexture *v26; 
  R_RT_Image *v27; 
  GfxTexture *v30; 
  R_RT_Image *v31; 
  GfxTexture *v34; 
  R_RT_Image *v35; 
  ID3D12Resource *p_m_tracking; 
  const R_RT_Surface *Surface; 
  ID3D12Resource *p_rwView; 
  ID3D12Resource *v45; 
  const R_RT_Surface *v46; 
  ID3D12Resource *v49; 
  const R_RT_Surface *v50; 
  const R_RT_Surface *v53; 
  const dvar_t *v56; 
  bool v57; 
  const dvar_t *v58; 
  const dvar_t *v59; 
  ID3D12Resource *buffers[2]; 
  R_RT_Handle v61; 
  int dataa[3]; 
  int v63; 
  GfxTexture *textures[7]; 

  csmPrepass = rgp.csmPrepass;
  if ( vrsWavePacking )
    csmPrepass = rgp.csmPrepassVRS;
  R_SetComputeShader(computeState, csmPrepass);
  buffers[0] = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, buffers);
  _RAX = taskInfo->attachments;
  blackImage = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    blackImage = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  Resident = (GfxTexture *)R_Texture_GetResident(blackImage->m_base.textureId);
  p_m_image = (R_RT_Image *)rgp.blackImage;
  textures[0] = Resident;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    p_m_image = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v18 = (GfxTexture *)R_Texture_GetResident(p_m_image->m_base.textureId);
  v19 = (R_RT_Image *)rgp.blackImage;
  textures[1] = v18;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v19 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v22 = (GfxTexture *)R_Texture_GetResident(v19->m_base.textureId);
  v23 = (R_RT_Image *)rgp.blackImage;
  textures[2] = v22;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v23 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v26 = (GfxTexture *)R_Texture_GetResident(v23->m_base.textureId);
  v27 = (R_RT_Image *)rgp.blackImage;
  textures[3] = v26;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v27 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v30 = (GfxTexture *)R_Texture_GetResident(v27->m_base.textureId);
  v31 = (R_RT_Image *)rgp.blackImage;
  textures[4] = v30;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v31 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v34 = (GfxTexture *)R_Texture_GetResident(v31->m_base.textureId);
  v35 = (R_RT_Image *)rgp.blackImage;
  textures[5] = v34;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+140h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    if ( vrsWavePacking )
      v35 = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  textures[6] = (GfxTexture *)R_Texture_GetResident(v35->m_base.textureId);
  R_SetComputeTextures(computeState, 0, 7, (const GfxTexture *const *)textures);
  buffers[0] = (ID3D12Resource *)&R_CompressedSunShadow_GetBuffer()->view;
  R_SetComputeViews(computeState, 7, 1, (const GfxShaderBufferView *const *)buffers);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    Surface = R_RT_Handle::GetSurface(&v61);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    p_m_tracking = (ID3D12Resource *)&Surface->m_array.m_handles[0].m_tracking;
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    p_m_tracking = (ID3D12Resource *)&gfxBuf.dummyBuffer.view;
  }
  buffers[0] = p_m_tracking;
  R_SetComputeViews(computeState, 8, 1, (const GfxShaderBufferView *const *)buffers);
  _RAX = taskInfo->attachments;
  p_rwView = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v46 = R_RT_Handle::GetSurface(&v61);
    if ( (v46->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v45 = (ID3D12Resource *)&v46->m_array.m_handles[1];
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    v45 = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  }
  buffers[0] = v45;
  R_SetComputeRWViewsWithCounters(computeState, 0, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v50 = R_RT_Handle::GetSurface(&v61);
    if ( (v50->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v49 = (ID3D12Resource *)&v50->m_array.m_handles[1];
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    v49 = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  }
  buffers[0] = v49;
  R_SetComputeRWViewsWithCounters(computeState, 1, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+120h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v61);
    v53 = R_RT_Handle::GetSurface(&v61);
    if ( (v53->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    p_rwView = (ID3D12Resource *)&v53->m_array.m_handles[1];
  }
  else if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  buffers[0] = p_rwView;
  R_SetComputeRWViewsWithCounters(computeState, 2, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  _RBX = DCONST_DVARFLT_sm_sunvisPrepassGlobalTileRangeLimit;
  if ( !DCONST_DVARFLT_sm_sunvisPrepassGlobalTileRangeLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassGlobalTileRangeLimit") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  v56 = DCONST_DVARBOOL_sm_sunvisPrepass;
  dataa[0] = data->sunShadow.opaqueCascadeCount - 1;
  __asm { vmovss  dword ptr [rbp+4Fh+buffers], xmm0 }
  dataa[1] = (int)buffers[0];
  if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v56);
  v57 = !v56->current.enabled;
  v58 = DCONST_DVARBOOL_sm_sunvisPrepass;
  dataa[2] = !v57;
  if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v58);
  if ( !v58->current.enabled )
    goto LABEL_88;
  v59 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
  if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v59);
  v57 = !v59->current.enabled;
  v63 = 1;
  if ( v57 )
LABEL_88:
    v63 = 0;
  R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
  R_Dispatch(computeState, ((((unsigned __int64)viewInfo->sceneViewport.width + 15) >> 4) + 7) >> 3, ((((unsigned __int64)viewInfo->sceneViewport.height + 15) >> 4) + 7) >> 3, 1u);
}

/*
==============
RBT_SunShadow_GenerateVisibility_Internal
==============
*/
void RBT_SunShadow_GenerateVisibility_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsInlineResolve)
{
  int v9; 
  bool IsValid; 
  __int64 v11; 
  __int64 v22; 
  const dvar_t *v31; 
  const dvar_t *v32; 
  R_RT_Image *blackShadowImage; 
  bool v36; 
  GfxTexture *Resident; 
  int v38; 
  R_RT_Image *p_m_image; 
  bool v41; 
  GfxTexture *v44; 
  int v45; 
  R_RT_Image *v46; 
  bool v48; 
  GfxTexture *v51; 
  int v52; 
  R_RT_Image *v53; 
  bool v55; 
  GfxTexture *v58; 
  bool v59; 
  GfxImage *blackImage; 
  GfxTexture *v61; 
  R_RT_Image *v62; 
  bool v63; 
  bool v65; 
  GfxTexture *v68; 
  R_RT_Image *v69; 
  bool v70; 
  bool v72; 
  GfxTexture *v75; 
  R_RT_Image *v76; 
  GfxTexture *v80; 
  R_RT_Image *v81; 
  R_RT_ColorHandle *v87; 
  GfxTextureId textureId; 
  R_RT_Image *v90; 
  GfxShaderBufferView *p_view; 
  GfxShaderBufferView *v96; 
  const R_RT_Surface *Surface; 
  GfxShaderBufferView *v99; 
  GfxShaderBufferView *v101; 
  const R_RT_Surface *v102; 
  GfxShaderBufferView *v106; 
  const R_RT_Surface *v107; 
  const R_RT_Surface *v111; 
  const R_RT_Surface *v115; 
  R_RT_Image *whiteImage; 
  const dvar_t *v120; 
  const dvar_t *v121; 
  const R_RT_Surface *v125; 
  R_RT_Handle buffers_8; 
  GfxConstantBufferDesc cbDesc_8; 
  R_RT_ColorHandle v128; 
  GfxViewParms result; 
  char v130; 
  tmat44_t<vec4_t> in; 
  GfxTexture *textures[10]; 

  _R15 = viewInfo;
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v9 = 0;
    if ( !rg.useTransSunShadow || (IsValid = R_RT_Handle::IsValid(taskInfo->attachments + 4), v11 = 1i64, !IsValid) )
      v11 = 0i64;
    R_SetComputeShader(computeState, rgp.sunvis[v11][vrsInlineResolve]);
    *(_QWORD *)&buffers_8.m_surfaceID = data->globalSceneConstantBuffer->buffer;
    R_SetComputeConstantBuffers(computeState, 7, 1, (ID3D12Resource *const *const)&buffers_8);
    _RAX = R_BeginComputeConstants((GfxConstantBufferDesc *)&buffers_8, computeState, 1, 0xB0u);
    __asm
    {
      vmovss  xmm2, dword ptr [r15+640h]
      vmovss  xmm1, dword ptr [r15+63Ch]
      vmovups xmm0, xmmword ptr [rax]
    }
    *(float *)&_RAX = _R15->screenSpaceShadows.sunSceneScreenSpaceShadowTraceDistance;
    __asm
    {
      vmovq   rdi, xmm0
      vmovups xmmword ptr [rsp+430h+cbDesc.bufferSize], xmm0
      vmovss  xmm0, dword ptr [r15+638h]
    }
    *(_DWORD *)_RDI = (_DWORD)_RAX;
    __asm
    {
      vmovss  dword ptr [rdi+4], xmm0
      vmovss  dword ptr [rdi+8], xmm1
      vmovss  dword ptr [rdi+0Ch], xmm2
    }
    if ( vrsInlineResolve )
    {
      _RAX = R_VRSGetPixelsToSamplesUint((base_vec4_t<unsigned int> *)&buffers_8, _R15->input.data->frameCount, rg.vrsEmissiveOnly);
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rdi+10h], xmm0
      }
    }
    MatrixTranspose44(&_R15->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m, (tmat44_t<vec4_t> *)(_RDI + 32));
    _RAX = R_GetDepthHackViewParms(&result, (const GfxViewParms *)_R15);
    _RCX = &v130;
    v22 = 3i64;
    do
    {
      _RCX += 128;
      __asm { vmovups xmm0, xmmword ptr [rax] }
      _RAX = (GfxViewParms *)((char *)_RAX + 128);
      __asm
      {
        vmovups xmmword ptr [rcx-80h], xmm0
        vmovups xmm1, xmmword ptr [rax-70h]
        vmovups xmmword ptr [rcx-70h], xmm1
        vmovups xmm0, xmmword ptr [rax-60h]
        vmovups xmmword ptr [rcx-60h], xmm0
        vmovups xmm1, xmmword ptr [rax-50h]
        vmovups xmmword ptr [rcx-50h], xmm1
        vmovups xmm0, xmmword ptr [rax-40h]
        vmovups xmmword ptr [rcx-40h], xmm0
        vmovups xmm1, xmmword ptr [rax-30h]
        vmovups xmmword ptr [rcx-30h], xmm1
        vmovups xmm0, xmmword ptr [rax-20h]
        vmovups xmmword ptr [rcx-20h], xmm0
        vmovups xmm1, xmmword ptr [rax-10h]
        vmovups xmmword ptr [rcx-10h], xmm1
      }
      --v22;
    }
    while ( v22 );
    MatrixTranspose44(&in, (tmat44_t<vec4_t> *)(_RDI + 96));
    v31 = DCONST_DVARBOOL_sm_sunvisPrepass;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v31);
    if ( v31->current.enabled )
    {
      v32 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
      if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v32);
      if ( v32->current.enabled )
        v9 = 1;
    }
    *(_DWORD *)(_RDI + 160) = v9;
    R_EndComputeConstants(computeState, &cbDesc_8);
    _RAX = taskInfo->attachments;
    blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
    }
    v36 = (*((_DWORD *)&_R15->viewportFeatures + 11) & 4) != 0;
    __asm { vmovups ymmword ptr [rsp+430h+buffers+8], ymm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v36 )
        blackShadowImage = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    Resident = (GfxTexture *)R_Texture_GetResident(blackShadowImage->m_base.textureId);
    v38 = *((_DWORD *)&_R15->viewportFeatures + 11);
    p_m_image = (R_RT_Image *)rgp.blackShadowImage;
    textures[0] = Resident;
    _RAX = taskInfo->attachments;
    v41 = (v38 & 4) != 0;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v41 )
        p_m_image = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v44 = (GfxTexture *)R_Texture_GetResident(p_m_image->m_base.textureId);
    v45 = *((_DWORD *)&_R15->viewportFeatures + 11);
    v46 = (R_RT_Image *)rgp.blackShadowImage;
    textures[1] = v44;
    _RAX = taskInfo->attachments;
    v48 = (v45 & 4) != 0;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v48 )
        v46 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v51 = (GfxTexture *)R_Texture_GetResident(v46->m_base.textureId);
    v52 = *((_DWORD *)&_R15->viewportFeatures + 11);
    v53 = (R_RT_Image *)rgp.blackShadowImage;
    textures[2] = v51;
    _RAX = taskInfo->attachments;
    v55 = (v52 & 4) != 0;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v55 )
        v53 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v58 = (GfxTexture *)R_Texture_GetResident(v53->m_base.textureId);
    v59 = (*((_BYTE *)&_R15->viewportFeatures + 44) & 4) == 0;
    textures[3] = v58;
    blackImage = rgp.blackImage;
    if ( !v59 )
      blackImage = rgp.cloudNoiseImage;
    v61 = (GfxTexture *)R_Texture_GetResident(blackImage->textureId);
    v62 = (R_RT_Image *)rgp.blackImage;
    textures[4] = v61;
    v63 = R_SunShadow_TranslucentEnabled(_R15);
    _RCX = taskInfo->attachments;
    v65 = v63;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+80h]
      vmovd   ecx, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_ECX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v65 )
        v62 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_ECX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v68 = (GfxTexture *)R_Texture_GetResident(v62->m_base.textureId);
    v69 = (R_RT_Image *)rgp.blackImage;
    textures[5] = v68;
    v70 = R_SunShadow_TranslucentEnabled(_R15);
    _RCX = taskInfo->attachments;
    v72 = v70;
    __asm
    {
      vmovups ymm0, ymmword ptr [rcx+0A0h]
      vmovd   ecx, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_ECX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v72 )
        v69 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_ECX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v75 = (GfxTexture *)R_Texture_GetResident(v69->m_base.textureId);
    v76 = (R_RT_Image *)rgp.blackImage;
    textures[6] = v75;
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0C0h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v76 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v80 = (GfxTexture *)R_Texture_GetResident(v76->m_base.textureId);
    v81 = (R_RT_Image *)rgp.blackImage;
    textures[7] = v80;
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0E0h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v81 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    textures[8] = (GfxTexture *)R_Texture_GetResident(v81->m_base.textureId);
    R_SetComputeTextures(computeState, 0, 9, (const GfxTexture *const *)textures);
    if ( vrsInlineResolve )
    {
      if ( R_RT_Handle::IsValid(taskInfo->attachments + 7) )
      {
        _RAX = taskInfo->attachments;
        __asm
        {
          vmovups ymm0, ymmword ptr [rax+0E0h]
          vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
        }
        v87 = R_RT_ColorHandle::Cast(&v128, &buffers_8);
        textureId = R_RT_Handle::GetSurface(v87)->m_color.m_fmaskImage.m_base.textureId;
      }
      else
      {
        textureId = rgp.blackImage->textureId;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(textureId);
      R_SetComputeTextures(computeState, 14, 1, (const GfxTexture *const *)&buffers_8);
      _RAX = taskInfo->attachments;
      v90 = (R_RT_Image *)rgp.blackImage;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+1E0h]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v90 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
      }
      else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(v90->m_base.textureId);
      R_SetComputeTextures(computeState, 15, 1, (const GfxTexture *const *)&buffers_8);
    }
    _RAX = taskInfo->attachments;
    p_view = &gfxBuf.dummyBuffer.view;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+120h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      Surface = R_RT_Handle::GetSurface(&buffers_8);
      if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
        __debugbreak();
      v96 = &Surface->m_buffer.m_wrappedBuffer.view;
    }
    else
    {
      if ( buffers_8.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      v96 = &gfxBuf.dummyBuffer.view;
    }
    *(_QWORD *)&buffers_8.m_surfaceID = v96;
    R_SetComputeViews(computeState, 12, 1, (const GfxShaderBufferView *const *)&buffers_8);
    if ( rg.useCompressedSunShadow == 3 )
    {
      _RAX = taskInfo->attachments;
      v99 = &gfxBuf.dummyRWBuffer.view;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+180h]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
      }
      if ( (_WORD)_RAX )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v102 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v102->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v101 = &v102->m_buffer.m_wrappedBuffer.view;
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        v101 = &gfxBuf.dummyRWBuffer.view;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v101;
      R_SetComputeViews(computeState, 9, 1, (const GfxShaderBufferView *const *)&buffers_8);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+1A0h]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v107 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v107->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v106 = &v107->m_buffer.m_wrappedBuffer.view;
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        v106 = &gfxBuf.dummyRWBuffer.view;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v106;
      R_SetComputeViews(computeState, 10, 1, (const GfxShaderBufferView *const *)&buffers_8);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+1C0h]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v111 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v111->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v99 = &v111->m_buffer.m_wrappedBuffer.view;
      }
      else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v99;
      R_SetComputeViews(computeState, 11, 1, (const GfxShaderBufferView *const *)&buffers_8);
    }
    else
    {
      *(_QWORD *)&buffers_8.m_surfaceID = &R_CompressedSunShadow_GetBuffer()->view;
      R_SetComputeViews(computeState, 9, 1, (const GfxShaderBufferView *const *)&buffers_8);
      *(_QWORD *)&buffers_8.m_surfaceID = &gfxBuf.dummyBuffer.view;
      R_SetComputeViews(computeState, 10, 1, (const GfxShaderBufferView *const *)&buffers_8);
      *(_QWORD *)&buffers_8.m_surfaceID = &gfxBuf.dummyBuffer.view;
      R_SetComputeViews(computeState, 11, 1, (const GfxShaderBufferView *const *)&buffers_8);
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+160h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v115 = R_RT_Handle::GetSurface(&buffers_8);
      if ( (v115->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
        __debugbreak();
      p_view = &v115->m_buffer.m_wrappedBuffer.view;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    *(_QWORD *)&buffers_8.m_surfaceID = p_view;
    R_SetComputeViews(computeState, 13, 1, (const GfxShaderBufferView *const *)&buffers_8);
    _RAX = taskInfo->attachments;
    whiteImage = (R_RT_Image *)rgp.whiteImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+100h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      whiteImage = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(whiteImage->m_base.textureId);
    R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&buffers_8);
    v120 = DCONST_DVARBOOL_sm_sunvisPrepass;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v120);
    if ( !v120->current.enabled )
      goto LABEL_144;
    v121 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v121);
    if ( v121->current.enabled )
    {
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+140h]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+430h+buffers+8], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v125 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v125->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        R_DispatchIndirect(computeState, v125->m_buffer.m_wrappedBuffer.buffer, 0);
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)_EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        R_DispatchIndirect(computeState, gfxBuf.dummyIndirectBuffer.buffer, 0);
      }
    }
    else
    {
LABEL_144:
      R_Dispatch(computeState, ((unsigned __int64)_R15->sceneViewport.width + 15) >> 4, ((unsigned __int64)_R15->sceneViewport.height + 15) >> 4, 1u);
    }
  }
}

/*
==============
RBT_SunShadow_Resolve
==============
*/
void RBT_SunShadow_Resolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const dvar_t *v7; 
  const dvar_t *v9; 
  GfxCmdBufContext v11; 
  R_RT_DepthHandle v12; 

  _RDI = gfxContext;
  if ( *taskInfo->pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdx+0B8h]
      vmovups xmm1, xmmword ptr [rcx]
      vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
      vmovups [rsp+78h+var_38], xmm1
    }
    R_SetRenderTargetsInternal_DepthOnly(&v11, &v12, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h(658)");
    v7 = DCONST_DVARBOOL_r_resummarizeSunCascadeCustom;
    if ( !DCONST_DVARBOOL_r_resummarizeSunCascadeCustom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resummarizeSunCascadeCustom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.enabled )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovups [rsp+78h+var_38], xmm0
      }
      R_ResummarizeDepth(&v11);
    }
    v9 = DCONST_DVARBOOL_r_resolveSunCascadeCustom;
    if ( !DCONST_DVARBOOL_r_resolveSunCascadeCustom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resolveSunCascadeCustom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    if ( v9->current.enabled )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovups [rsp+78h+var_38], xmm0
      }
      R_ResolveDepth(&v11);
    }
  }
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMask
==============
*/
void RBT_Sunshadow_GenerateTransShadowMask(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v12; 
  R_RT_ColorHandle v13; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rsp+78h+var_28], ymm0
      vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v12);
      if ( (R_RT_Handle::GetSurface(&v12)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rsp+78h+var_28] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    __asm { vmovups [rsp+78h+var_28], ymm0 }
    R_Sunshadow_GenerateTransShadowMask(computeState, viewInfo, data, &v13);
  }
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA
==============
*/
void RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v23; 
  R_RT_Handle v26; 
  R_RT_ColorHandle v27; 
  R_RT_ColorHandle v28; 
  R_RT_ColorHandle v29; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rsp+0C8h+var_78], ymm0
      vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
          vmovups [rsp+0C8h+var_78], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
          vmovups [rsp+0C8h+var_78], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovd   eax, xmm1
      vmovups [rsp+0C8h+var_58], ymm1
      vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
          vmovups [rsp+0C8h+var_58], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
          vmovups [rsp+0C8h+var_58], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+0C8h+var_38.baseclass_0.m_surfaceID], ymm0
      vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_38.baseclass_0.m_surfaceID] }
        if ( v23 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, [rsp+0C8h+var_78]
      vmovups ymmword ptr [rsp+0C8h+var_38.baseclass_0.m_surfaceID], ymm1
      vmovups ymm1, [rsp+0C8h+var_58]
      vmovups [rsp+0C8h+var_58], ymm1
      vmovups [rsp+0C8h+var_78], ymm0
    }
    R_Sunshadow_GenerateTransShadowMaskDilationAndTAA(computeState, viewInfo, data, &v27, &v28, &v29);
  }
}

/*
==============
RT_SunShadow_DrawCacheSetup
==============
*/
void RT_SunShadow_DrawCacheSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  bool v20; 
  R_RT_Handle v22; 
  R_RT_Handle v23; 
  R_RT_DepthHandle v24; 
  R_RT_Group v25; 

  if ( !viewInfo->taskGraphViewInfo.frameCount )
    R_SunShadowCache_Flush();
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    if ( r_sunshadowmap_cmdbuf_worker->current.enabled )
    {
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups [rsp+190h+var_160], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v22);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+20h]
        vmovups [rsp+190h+var_160], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v22);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+40h]
        vmovups [rsp+190h+var_160], ymm0
      }
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v22);
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm1, ymmword ptr [rax+60h]
      vmovd   eax, xmm1
      vmovups [rsp+190h+var_120], ymm1
      vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm1
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v23);
      if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
          vmovups [rsp+190h+var_120], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
          vmovups [rsp+190h+var_120], ymm0
        }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rsp+190h+var_160], ymm0
      vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v23);
      if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID] }
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID] }
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rsp+190h+var_160] }
        if ( v20 )
          __debugbreak();
      }
    }
    __asm { vmovups ymm1, [rsp+190h+var_120] }
    v25.m_colorRtCount = 0;
    v25.m_depthRt.m_surfaceID = 0;
    v25.m_depthRt.m_tracking.m_allocCounter = 0;
    memset(&v25.m_depthRt.m_tracking.m_name, 0, 18);
    v25.m_vrsRt.m_tracking.m_allocCounter = 0;
    v25.m_vrsRt.m_tracking.m_name = NULL;
    v25.m_vrsRt.m_tracking.m_location = NULL;
    __asm
    {
      vmovups [rsp+190h+var_120], ymm1
      vmovups [rsp+190h+var_160], ymm0
    }
    R_GenerateSortedSunShadowCacheSurfs(viewInfo, &v25, &v24, (R_RT_DepthHandle *)&v22, D3D12XBOX_RESOURCE_STATE_PRESERVE_COMPRESSED_DEPTH|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_DEPTH_READ);
  }
}

/*
==============
RT_SunShadow_DrawCascadeSetup
==============
*/
void RT_SunShadow_DrawCascadeSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  signed int v4; 
  R_RT_Handle v11; 

  if ( r_sunshadowmap_cmdbuf_worker->current.enabled && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && rg.useCompressedSunShadow != 3 )
  {
    v4 = *taskInfo->pTaskData;
    if ( !viewInfo->input.data->sunShadow.opaqueCascadeCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 426, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0") )
      __debugbreak();
    if ( v4 > 26 || v4 <= viewInfo->input.data->sunShadow.opaqueCascadeCount + 23 )
    {
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v11);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v11);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+40h]
        vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
      }
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v11);
      if ( viewInfo->useDynamicSunShadows || !viewInfo->useCachedSunShadow )
        R_AddDrawCall(viewInfo, &taskInfo->rtGroup, (GfxDrawListType)v4, 0x5Du);
    }
  }
}

/*
==============
RT_SunShadow_DrawTranslucentSetup
==============
*/
void RT_SunShadow_DrawTranslucentSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Image *blackImage; 
  unsigned int v6; 
  R_RT_Handle v15; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    if ( (unsigned __int16)(viewInfo->input.data->sunShadow.opaqueCascadeCount - 1) > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 571, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT") )
      __debugbreak();
    blackImage = (R_RT_Image *)rgp.blackImage;
    v6 = *taskInfo->pTaskData;
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v15);
      blackImage = &R_RT_Handle::GetSurface(&v15)->m_image;
    }
    else if ( v15.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v15.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codePersistentImages[6] = &blackImage->m_base;
    if ( v6 == viewInfo->input.data->sunShadow.opaqueCascadeCount - 1 )
    {
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v15);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
      }
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v15);
      _RAX = taskInfo->attachments;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+40h]
        vmovups ymmword ptr [rsp+68h+var_38.m_surfaceID], ymm0
      }
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v15);
      R_AddDrawCall(viewInfo, &taskInfo->rtGroup, DRAWLIST_SUNSHADOW_END, 0x5Du);
    }
  }
}

/*
==============
R_TG_CompressSunShadowCascades
==============
*/
void R_TG_CompressSunShadowCascades(R_TG_Script *pScript, R_TG_Handle *sunshadowCascades, R_TG_Handle *sunshadowCascadesBackface, R_TG_Handle *compressedCascades, unsigned int cascadesCount, R_TG_Handle nullBuffer)
{
  R_TG_Handle *v8; 
  unsigned int v9; 
  const GfxCompressedSunShadowSetup *Setup; 
  int v11; 
  unsigned int v12; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  unsigned int v15; 
  R_TG_Script *v16; 
  R_TG_Script *v17; 
  unsigned int v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  R_TG_Handle *v22; 
  __int64 i; 
  int v24; 
  R_TG_Script *pScripta; 
  __int64 v26; 
  __int64 v27; 
  R_TG_Handle *v28; 
  R_TG_AddTaskStack v29; 
  R_TG_AddTaskStack stack; 

  pScripta = pScript;
  v28 = sunshadowCascades;
  v8 = sunshadowCascades;
  if ( !cascadesCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 1078, ASSERT_TYPE_ASSERT, "(cascadesCount > 0)", (const char *)&queryFormat, "cascadesCount > 0") )
    __debugbreak();
  if ( cascadesCount > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 1079, ASSERT_TYPE_ASSERT, "(cascadesCount <= 3)", (const char *)&queryFormat, "cascadesCount <= 3") )
    __debugbreak();
  v9 = 0;
  Setup = R_CompressedSunShadow_GetSetup();
  v11 = Setup->m_layersCount + Setup->m_totalNodesCount;
  if ( cascadesCount )
  {
    v27 = (char *)sunshadowCascadesBackface - (char *)compressedCascades;
    v26 = (char *)v8 - (char *)compressedCascades;
    do
    {
      v12 = Setup->m_compressedShadowMapMaxSize >> 2;
      v24 = -1;
      memset_0(&stack, 0, sizeof(stack));
      m_index = g_R_TG_Def_RBT_CompressSunShadow_CreateBuffers.m_index;
      stack.handleArgs[0] = (unsigned int *)&v24;
      handleArgCount = stack.handleArgCount + 1;
      stack.handleArgCount = handleArgCount;
      if ( (unsigned int)handleArgCount >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        handleArgCount = stack.handleArgCount;
      }
      stack.handleArgs[handleArgCount] = &compressedCascades->index;
      if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      stack.paramArgs[stack.paramArgCount++] = v11;
      if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v15 = m_index;
      v16 = pScripta;
      v17 = pScripta;
      stack.paramArgs[stack.paramArgCount++] = v12;
      R_TG_AddTask(v17, v15, &stack);
      memset_0(&v29, 0, sizeof(v29));
      v18 = g_R_TG_Def_RBT_CompressSunShadow_Main.m_index;
      v29.handleArgs[0] = (unsigned int *)((char *)&compressedCascades->index + v26);
      v19 = v29.handleArgCount + 1;
      v29.handleArgCount = v19;
      if ( (unsigned int)v19 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v19 = v29.handleArgCount;
      }
      v29.handleArgs[v19] = (unsigned int *)((char *)&compressedCascades->index + v27);
      v20 = v29.handleArgCount + 1;
      v29.handleArgCount = v20;
      if ( (unsigned int)v20 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v20 = v29.handleArgCount;
      }
      v29.handleArgs[v20] = (unsigned int *)&v24;
      v21 = v29.handleArgCount + 1;
      v29.handleArgCount = v21;
      if ( (unsigned int)v21 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v21 = v29.handleArgCount;
      }
      v29.handleArgs[v21] = &compressedCascades->index;
      if ( ++v29.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v29.paramArgs[v29.paramArgCount++] = v9;
      R_TG_AddTask(v16, v18, &v29);
      ++v9;
      ++compressedCascades;
    }
    while ( v9 < cascadesCount );
    v8 = v28;
  }
  if ( cascadesCount < 3 )
  {
    v22 = &v8[cascadesCount];
    for ( i = 3 - cascadesCount; i; --i )
    {
      v22->index = nullBuffer.index;
      ++v22;
    }
  }
}

