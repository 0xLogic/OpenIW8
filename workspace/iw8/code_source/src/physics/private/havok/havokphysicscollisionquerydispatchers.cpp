/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compoundVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<0>
==============
*/

void __fastcall unwrapMaskedShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsCompound@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsHeightField@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<2>
==============
*/

void __fastcall unwrapMaskedShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<2>
==============
*/

void __fastcall unwrapLodShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<1>
==============
*/

void __fastcall unwrapScaledConvex<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsExternMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<2>
==============
*/

void __fastcall unwrapScaledConvex<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?externMeshVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(HavokPhysics_CollisionQueryDispatcher *this)
{
  ??0HavokPhysics_CollisionQueryDispatcher@@QEAA@XZ(this);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsParticleSystem@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compressedMeshVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(HavokPhysics_CollisionQueryDispatcher *this, unsigned int shapeMask)
{
  ?initIWGetClosestPointsTable@HavokPhysics_CollisionQueryDispatcher@@AEAAXI@Z(this, shapeMask);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?particlesVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?heightFieldVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<0>
==============
*/

void __fastcall unwrapLodShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?heightFieldVsHeightfield@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<1>
==============
*/

void __fastcall unwrapLodShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsConvex@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<0>
==============
*/

void __fastcall unwrapScaledConvex<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compoundVsCompound@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<1>
==============
*/

void __fastcall unwrapMaskedShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::castShapeConvex
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::castShapeConvex(hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  ?castShapeConvex@HavokPhysics_CollisionQueryDispatcher@@CAXPEAUhknpCollisionQueryContext@@AEBUhknpShapeCastQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@7@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, targetTquery, queryAndTargetSwapped, collector, startCollector);
}

/*
==============
unwrapLodShape<1>
==============
*/
void unwrapLodShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 m_size; 
  unsigned int m_mode; 
  const hknpShape *v17; 
  const hkTransformf *v19; 
  __int64 v21; 
  unsigned int v23; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  __int64 v25; 
  __int64 v27; 
  const hknpCollisionQueryDispatcher *v29; 
  unsigned __int16 v30[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v33; 
  const hknpShape *v34; 
  const hknpShape *v35; 
  unsigned int v36; 
  __int64 v37; 
  __int16 v38[2]; 
  int v39; 
  __int64 v40; 
  const hknpBody *v41; 
  const hknpShape *v42; 
  const hknpShape *v43; 
  unsigned int m_value; 
  __int64 v45; 
  __m256i v46; 
  __m256i v47; 
  __int64 v48[3]; 
  unsigned int v49; 
  int v50; 
  const hkTransformf *v51; 
  __int64 v52; 
  char v53; 
  unsigned int v54; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v62; 
  bool m_isScaled; 
  unsigned int v64; 

  _R10 = targetShapeInfo;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+20h]
    vmovups ymm2, ymmword ptr [rdx]
  }
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  m_shapeKeyPath = queryShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v62 = 0i64;
  v52 = 0i64;
  v64 = m_mode;
  v48[0] = (__int64)targetShapeInfo->m_body;
  v48[1] = (__int64)targetShapeInfo->m_rootShape;
  v17 = targetShapeInfo->m_parentShape;
  __asm
  {
    vmovups [rsp+258h+var_128], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  v48[2] = (__int64)v17;
  v19 = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovups [rsp+258h+var_68], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v21 = *(int *)query->m_levelOfDetail;
  v51 = v19;
  LOBYTE(v19) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovss  [rsp+258h+var_70], xmm0
    vmovups ymm0, ymmword ptr [r10+40h]
  }
  v53 = (char)v19;
  v23 = targetShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((_DWORD)v21 + 1) << (32 - (m_size + 3))) - 1);
  v54 = targetShapeInfo->m_scalingInternals.m_mode;
  m_dispatcher = queryContext->m_dispatcher;
  v25 = *((_BYTE *)&targetShape[2].m_propertyBag.m_bag + v21) & 7;
  __asm
  {
    vmovups [rsp+258h+var_C8], ymm0
    vmovss  xmm0, dword ptr [r10+38h]
    vmovss  [rsp+258h+var_D0], xmm0
    vmovups [rsp+258h+var_148], ymm2
  }
  v49 = v23;
  v50 = m_size + 3;
  v27 = *((_QWORD *)&targetShape[1].__vftable + v25);
  __asm { vpextrq rcx, xmm2, 1 }
  v29 = m_dispatcher;
  if ( !_RCX )
    goto LABEL_3;
  v38[0] = v46.m256i_i16[8];
  v39 = v46.m256i_i32[5];
  v40 = v46.m256i_i64[3];
  v41 = m_body;
  v42 = m_rootShape;
  v43 = m_parentShape;
  m_value = m_shapeKeyPath.m_key.m_value;
  v45 = v47.m256i_i64[1];
  v30[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v33 = targetShapeInfo->m_body;
  v34 = targetShapeInfo->m_rootShape;
  v35 = targetShapeInfo->m_parentShape;
  v36 = v23;
  v37 = v27;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v38, v30) )
LABEL_3:
    v29->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v47.m256i_i64[1] + 26)][*(unsigned __int8 *)(v27 + 26)](queryContext, (const hknpClosestPointsQuery *)&v46, (const hknpShapeQueryInfo *)&m_body, (const hknpShape *)v27, targetShapeFilterData, (const hknpShapeQueryInfo *)v48, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<2>
==============
*/
void unwrapLodShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpClosestPointsQuery *v17; 
  const hknpShapeQueryInfo *v18; 
  __int64 m_size; 
  const hknpBody *v21; 
  __int64 v24; 
  __int64 v27; 
  unsigned int v28; 
  __int64 v30; 
  int v31; 
  __int64 v32; 
  __int64 v33; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  const hknpBody *v36; 
  const hknpShape *v37; 
  const hknpShape *v38; 
  __int64 v39; 
  const hknpShape *v40; 
  const hknpShape *v41; 
  unsigned __int16 v42[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  __int64 v45; 
  const hknpShape *v46; 
  const hknpShape *v47; 
  int v48; 
  __int64 v49; 
  __int16 v50[2]; 
  int v51; 
  __int64 v52; 
  const hknpBody *v53; 
  const hknpShape *v54; 
  const hknpShape *v55; 
  unsigned int v56; 
  __int64 v57; 
  __m256i v58; 
  __m256i v59; 
  _QWORD v60[3]; 
  int v61; 
  int v62; 
  const hkTransformf *v63; 
  __int64 v64; 
  bool v65; 
  int v66; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  unsigned int v72; 
  int v73; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v75; 
  bool m_isScaled; 
  unsigned int m_mode; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovups ymm0, ymmword ptr [r8+40h]
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm3, ymmword ptr [rdx]
  }
  _RCX = targetShapeInfo;
  v17 = query;
  v18 = queryShapeInfo;
  m_size = queryShapeInfo->m_shapeKeyPath.m_size;
  m_body = queryShapeInfo->m_body;
  v36 = m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  v37 = m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v38 = m_parentShape;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v21 = targetShapeInfo->m_body;
  __asm
  {
    vmovups ymmword ptr [r11-68h], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
    vmovss  dword ptr [r11-70h], xmm0
  }
  v75 = 0i64;
  __asm
  {
    vmovups [rsp+278h+var_128], ymm2
    vmovups [rsp+278h+var_148], ymm3
  }
  v39 = (__int64)v21;
  v60[0] = v21;
  v40 = targetShapeInfo->m_rootShape;
  v60[1] = v40;
  v41 = targetShapeInfo->m_parentShape;
  __asm { vmovups ymm0, ymmword ptr [rcx+40h] }
  v24 = targetShapeInfo->m_shapeKeyPath.m_size;
  v60[2] = v41;
  LODWORD(_R11) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v63 = targetShapeInfo->m_shapeToWorld;
  v65 = targetShapeInfo->m_scalingInternals.m_isScaled;
  LODWORD(v21) = targetShapeInfo->m_scalingInternals.m_mode;
  v64 = 0i64;
  v66 = (int)v21;
  __asm
  {
    vmovd   edx, xmm2
    vmovups [rsp+278h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v73 = m_size + 3;
  v27 = *(int *)v17->m_levelOfDetail;
  v61 = (int)_R11;
  v28 = v18->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | (((_EDX + 1) << (32 - (m_size + 3))) - 1);
  __asm { vpextrq rcx, xmm2, 1 }
  v59.m256i_i64[1] = _RCX;
  __asm { vmovss  [rsp+278h+var_D0], xmm0 }
  v72 = v28;
  v30 = *(_QWORD *)(_RCX + 8i64 * (*(_BYTE *)(_EDX + _RCX + 120) & 7) + 56);
  v59.m256i_i64[1] = v30;
  v62 = v24 + 3;
  v31 = (unsigned int)_R11 & hknpShapeKeyPath_usedBitsMaskTable[v24] | ((((_DWORD)v27 + 1) << (32 - (v24 + 3))) - 1);
  v32 = *((_BYTE *)&targetShape[2].m_propertyBag.m_bag + v27) & 7;
  v61 = v31;
  v33 = *((_QWORD *)&targetShape[1].__vftable + v32);
  m_dispatcher = queryContext->m_dispatcher;
  __asm { vpextrq rcx, xmm3, 1 }
  if ( _RCX )
  {
    v50[0] = v58.m256i_i16[8];
    v51 = v58.m256i_i32[5];
    v52 = v58.m256i_i64[3];
    v53 = v36;
    v54 = v37;
    v55 = v38;
    v42[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v45 = v39;
    v46 = v40;
    v57 = v30;
    v47 = v41;
    v56 = v28;
    v48 = v31;
    v49 = v33;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v50, v42) )
      return;
    v30 = v59.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v30 + 26)][*(unsigned __int8 *)(v33 + 26)](queryContext, (const hknpClosestPointsQuery *)&v58, (const hknpShapeQueryInfo *)&m_body, (const hknpShape *)v33, targetShapeFilterData, (const hknpShapeQueryInfo *)v60, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<0>
==============
*/
void unwrapLodShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 m_size; 
  const hknpBody *v19; 
  const hknpShape *v21; 
  const hknpShape *m_parentShape; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  unsigned int v27; 
  __int64 v29; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 
  unsigned __int16 v34[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  unsigned int m_value; 
  const hknpShape *v41; 
  __int16 v42[2]; 
  int v43; 
  __int64 v44; 
  const hknpBody *v45; 
  const hknpShape *v46; 
  const hknpShape *v47; 
  unsigned int v48; 
  __int64 v49; 
  __m256i v50; 
  __m256i v51; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *v54; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v56; 
  __int64 v57; 
  char v58; 
  unsigned int v59; 
  _QWORD v62[3]; 
  unsigned int v63; 
  int v64; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v66; 
  bool m_isScaled; 
  unsigned int m_mode; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovups ymm3, ymmword ptr [rdx]
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  _RCX = targetShapeInfo;
  m_size = queryShapeInfo->m_shapeKeyPath.m_size;
  v62[0] = queryShapeInfo->m_body;
  v62[1] = queryShapeInfo->m_rootShape;
  v62[2] = queryShapeInfo->m_parentShape;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  m_body = targetShapeInfo->m_body;
  v19 = m_body;
  __asm
  {
    vmovups ymmword ptr [r11-68h], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v31 = (__int64)v19;
  m_rootShape = targetShapeInfo->m_rootShape;
  v21 = m_rootShape;
  __asm { vmovss  dword ptr [r11-70h], xmm0 }
  v32 = (__int64)v21;
  m_parentShape = targetShapeInfo->m_parentShape;
  v66 = 0i64;
  __asm
  {
    vmovups [rsp+248h+var_128], ymm2
    vmovups [rsp+248h+var_148], ymm3
  }
  v33 = (__int64)m_parentShape;
  __asm { vmovups ymm0, ymmword ptr [rcx+40h] }
  m_dispatcher = queryContext->m_dispatcher;
  v54 = m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  v56 = targetShapeInfo->m_shapeToWorld;
  LOBYTE(m_parentShape) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v57 = 0i64;
  v58 = (char)m_parentShape;
  v59 = targetShapeInfo->m_scalingInternals.m_mode;
  __asm
  {
    vmovd   edx, xmm2
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v64 = m_size + 3;
  v27 = queryShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | (((_EDX + 1) << (32 - (m_size + 3))) - 1);
  __asm { vpextrq rcx, xmm2, 1 }
  v51.m256i_i64[1] = _RCX;
  __asm { vmovss  [rsp+248h+var_D0], xmm0 }
  v63 = v27;
  v29 = *(_QWORD *)(_RCX + 8i64 * (*(_BYTE *)(_EDX + _RCX + 120) & 7) + 56);
  __asm { vpextrq rcx, xmm3, 1 }
  v51.m256i_i64[1] = v29;
  if ( _RCX )
  {
    v42[0] = v50.m256i_i16[8];
    v43 = v50.m256i_i32[5];
    v44 = v50.m256i_i64[3];
    v45 = queryShapeInfo->m_body;
    v46 = queryShapeInfo->m_rootShape;
    v47 = queryShapeInfo->m_parentShape;
    v34[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v37 = v31;
    v38 = v32;
    v49 = v29;
    v39 = v33;
    m_value = m_shapeKeyPath.m_key.m_value;
    v48 = v27;
    v41 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v42, v34) )
      return;
    v29 = v51.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v29 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v50, (const hknpShapeQueryInfo *)v62, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&m_body, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<1>
==============
*/
void unwrapMaskedShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  hknpShape_vtbl *v17; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  int m_size; 
  const hkTransformf *m_shapeToWorld; 
  unsigned int m_value; 
  const hknpBody *v27; 
  const hknpShape *v28; 
  const hknpShape *v29; 
  unsigned __int16 v30[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v33; 
  const hknpShape *v34; 
  const hknpShape *v35; 
  unsigned int v36; 
  hknpShape_vtbl *v37; 
  __int16 v38[2]; 
  int v39; 
  __int64 v40; 
  const hknpBody *v41; 
  const hknpShape *v42; 
  const hknpShape *v43; 
  unsigned int v44; 
  __int64 v45; 
  __m256i v46; 
  __m256i v47; 
  __int64 v48[3]; 
  unsigned int v49; 
  int v50; 
  const hkTransformf *v51; 
  hkDefaultPropertyBag *m_bag; 
  char v53; 
  int v54; 
  __int64 v57[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 

  _RCX = targetShapeInfo;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+20h]
    vmovups ymm2, ymmword ptr [rdx]
  }
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v17 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  v57[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v57[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v27 = targetShapeInfo->m_body;
  v48[0] = (__int64)targetShapeInfo->m_body;
  v28 = targetShapeInfo->m_rootShape;
  v48[1] = (__int64)v28;
  v29 = targetShapeInfo->m_parentShape;
  v48[2] = (__int64)v29;
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v49 = m_value;
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  __asm
  {
    vmovups [rsp+248h+var_128], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  v50 = m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovups [rsp+248h+var_68], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v51 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovss  [rsp+248h+var_70], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
  }
  v53 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm
  {
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v54 = (int)m_shapeToWorld;
  __asm { vpextrq rcx, xmm2, 1 }
  m_bag = targetShape[1].m_propertyBag.m_bag;
  v57[0] = (__int64)m_body;
  v57[1] = (__int64)m_rootShape;
  v57[2] = (__int64)m_parentShape;
  v57[5] = 0i64;
  __asm
  {
    vmovss  [rsp+248h+var_D0], xmm0
    vmovups [rsp+248h+var_148], ymm2
  }
  if ( !_RCX )
    goto LABEL_3;
  v38[0] = v46.m256i_i16[8];
  v39 = v46.m256i_i32[5];
  v40 = v46.m256i_i64[3];
  v44 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
  v45 = v47.m256i_i64[1];
  v30[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v33 = v27;
  v34 = v28;
  v41 = m_body;
  v35 = v29;
  v36 = m_value;
  v42 = m_rootShape;
  v43 = m_parentShape;
  v37 = v17;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v38, v30) )
LABEL_3:
    m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v47.m256i_i64[1] + 26)][BYTE2(v17->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v46, (const hknpShapeQueryInfo *)v57, (const hknpShape *)v17, targetShapeFilterData, (const hknpShapeQueryInfo *)v48, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<2>
==============
*/
void unwrapMaskedShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  hknpShape_vtbl *v18; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v25; 
  hkDefaultPropertyBag *m_bag; 
  unsigned __int16 v28[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v31; 
  const hknpShape *v32; 
  const hknpShape *v33; 
  unsigned int v34; 
  hknpShape_vtbl *v35; 
  __int16 v36[2]; 
  int v37; 
  __int64 v38; 
  const hknpBody *v39; 
  const hknpShape *v40; 
  const hknpShape *v41; 
  unsigned int m_value; 
  __int64 v43; 
  __m256i v44; 
  __m256i v45; 
  const hknpBody *v46; 
  const hknpShape *v47; 
  const hknpShape *m_parentShape; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v50; 
  hkDefaultPropertyBag *v51; 
  char v52; 
  int v53; 
  __int64 v56[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 

  _RCX = targetShapeInfo;
  __asm
  {
    vmovups ymm0, ymmword ptr [r8+40h]
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm3, ymmword ptr [rdx]
  }
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  v18 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  v56[2] = (__int64)queryShapeInfo->m_parentShape;
  v56[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v56[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v46 = targetShapeInfo->m_body;
  v47 = targetShapeInfo->m_rootShape;
  m_parentShape = targetShapeInfo->m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovups [rsp+248h+var_68], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v50 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovss  [rsp+248h+var_70], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
  }
  v52 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm
  {
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
    vpextrq rcx, xmm2, 1
    vmovups [rsp+248h+var_128], ymm2
  }
  v45.m256i_i64[1] = _RCX;
  v53 = (int)m_shapeToWorld;
  __asm
  {
    vmovss  [rsp+248h+var_D0], xmm0
    vmovups [rsp+248h+var_148], ymm3
  }
  v56[0] = (__int64)m_body;
  v56[1] = (__int64)m_rootShape;
  v56[5] = *(_QWORD *)(_RCX + 64);
  v25 = *(_QWORD *)(_RCX + 56);
  m_bag = targetShape[1].m_propertyBag.m_bag;
  __asm { vpextrq rcx, xmm3, 1 }
  v45.m256i_i64[1] = v25;
  v51 = m_bag;
  if ( _RCX )
  {
    v36[0] = v44.m256i_i16[8];
    v37 = v44.m256i_i32[5];
    v38 = v44.m256i_i64[3];
    v41 = queryShapeInfo->m_parentShape;
    m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v28[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v31 = v46;
    v32 = v47;
    v43 = v25;
    v33 = m_parentShape;
    v34 = m_shapeKeyPath.m_key.m_value;
    v39 = m_body;
    v40 = m_rootShape;
    v35 = v18;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v36, v28) )
      return;
    v25 = v45.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v25 + 26)][BYTE2(v18->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v44, (const hknpShapeQueryInfo *)v56, (const hknpShape *)v18, targetShapeFilterData, (const hknpShapeQueryInfo *)&v46, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<0>
==============
*/
void unwrapMaskedShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v26; 
  unsigned __int16 v28[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v31; 
  const hknpShape *v32; 
  const hknpShape *v33; 
  unsigned int v34; 
  const hknpShape *v35; 
  __int16 v36[2]; 
  int v37; 
  __int64 v38; 
  const hknpBody *v39; 
  const hknpShape *v40; 
  const hknpShape *v41; 
  unsigned int m_value; 
  __int64 v43; 
  __m256i v44; 
  __m256i v45; 
  const hknpBody *v46; 
  const hknpShape *v47; 
  const hknpShape *v48; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v50; 
  __int64 v51; 
  char v52; 
  int v53; 
  __int64 v56[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 

  _RCX = targetShapeInfo;
  __asm
  {
    vmovups ymm0, ymmword ptr [r8+40h]
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm3, ymmword ptr [rdx]
  }
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  m_dispatcher = queryContext->m_dispatcher;
  v56[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v56[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v46 = targetShapeInfo->m_body;
  v47 = targetShapeInfo->m_rootShape;
  v48 = targetShapeInfo->m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovups [rsp+248h+var_68], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v50 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovss  [rsp+248h+var_70], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
  }
  v52 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm
  {
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
    vpextrq rcx, xmm2, 1
    vmovups [rsp+248h+var_128], ymm2
  }
  v45.m256i_i64[1] = _RCX;
  __asm
  {
    vmovss  [rsp+248h+var_D0], xmm0
    vmovups [rsp+248h+var_148], ymm3
  }
  v56[0] = (__int64)m_body;
  v56[1] = (__int64)m_rootShape;
  v56[2] = (__int64)m_parentShape;
  v51 = 0i64;
  v53 = (int)m_shapeToWorld;
  v56[5] = *(_QWORD *)(_RCX + 64);
  v26 = *(_QWORD *)(_RCX + 56);
  __asm { vpextrq rcx, xmm3, 1 }
  v45.m256i_i64[1] = v26;
  if ( _RCX )
  {
    v36[0] = v44.m256i_i16[8];
    v37 = v44.m256i_i32[5];
    v38 = v44.m256i_i64[3];
    m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v28[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v31 = v46;
    v32 = v47;
    v43 = v26;
    v33 = v48;
    v39 = m_body;
    v34 = m_shapeKeyPath.m_key.m_value;
    v40 = m_rootShape;
    v41 = m_parentShape;
    v35 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v36, v28) )
      return;
    v26 = v45.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v26 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v44, (const hknpShapeQueryInfo *)v56, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&v46, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<1>
==============
*/
void unwrapScaledConvex<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  const hknpShape *v17; 
  const hknpShape *v19; 
  const hkTransformf *m_shapeToWorld; 
  hknpShape_vtbl *v36; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  int v38; 
  const hknpBody *v39; 
  __int64 v40; 
  __int64 v41; 
  unsigned __int16 v42[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v45; 
  __int64 v46; 
  __int64 v47; 
  int v48; 
  hknpShape_vtbl *v49; 
  __int16 v50[2]; 
  int v51; 
  __int64 v52; 
  const hknpBody *v53; 
  const hknpShape *v54; 
  const hknpShape *v55; 
  unsigned int m_value; 
  __int64 v57; 
  __m256i v58; 
  __m256i v59; 
  __int64 v60[3]; 
  int v61; 
  int v62; 
  const hkTransformf *v63; 
  __int64 v64; 
  bool v65; 
  unsigned int v66; 
  __int64 v69[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 

  __asm
  {
    vmovups ymm0, ymmword ptr [rdx]
    vmovups ymm1, ymmword ptr [rdx+20h]
    vmovups xmm4, xmmword ptr [r9+40h]
  }
  m_body = queryShapeInfo->m_body;
  _RCX = targetShapeInfo;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v69[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v69[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v39 = targetShapeInfo->m_body;
  v60[0] = (__int64)targetShapeInfo->m_body;
  v17 = targetShapeInfo->m_rootShape;
  __asm
  {
    vmovups [rsp+248h+var_148], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  v40 = (__int64)v17;
  v60[1] = (__int64)v17;
  v19 = targetShapeInfo->m_parentShape;
  __asm
  {
    vmovups [rsp+248h+var_68], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  v41 = (__int64)v19;
  v60[2] = (__int64)v19;
  LODWORD(v19) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  __asm
  {
    vmovss  [rsp+248h+var_70], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
    vmovups [rsp+248h+var_128], ymm1
    vsubps  xmm1, xmm4, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
  }
  v38 = (int)v19;
  v61 = (int)v19;
  LODWORD(v19) = targetShapeInfo->m_shapeKeyPath.m_size;
  __asm
  {
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v62 = (int)v19;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovss  [rsp+248h+var_D0], xmm0
    vmovups xmm0, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
    vandnps xmm1, xmm0, xmm1
    vcmpleps xmm3, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
    vpxor   xmm0, xmm0, xmm0
    vpcmpeqd xmm1, xmm0, xmm0
  }
  v63 = m_shapeToWorld;
  __asm
  {
    vblendps xmm2, xmm0, xmm1, 7
    vpand   xmm1, xmm3, xmm2
    vptest  xmm1, xmm2
  }
  v65 = targetShapeInfo->m_scalingInternals.m_isScaled;
  v66 = targetShapeInfo->m_scalingInternals.m_mode;
  v69[0] = (__int64)m_body;
  v69[1] = (__int64)m_rootShape;
  v69[2] = (__int64)m_parentShape;
  v69[5] = 0i64;
  v64 = 0i64;
  if ( !_CF )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r9+50h]
      vmovss  xmm1, dword ptr [r9+20h]
      vmovss  [rsp+248h+var_D0], xmm1
      vmovups xmmword ptr [rsp+248h+var_C8+10h], xmm0
    }
    v65 = 1;
    __asm { vmovups xmmword ptr [rsp+248h+var_C8], xmm4 }
  }
  v36 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  if ( !v58.m256i_i64[1] )
    goto LABEL_5;
  v50[0] = v58.m256i_i16[8];
  v51 = v58.m256i_i32[5];
  v52 = v58.m256i_i64[3];
  m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
  v57 = v59.m256i_i64[1];
  v42[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v45 = v39;
  v46 = v40;
  v53 = m_body;
  v47 = v41;
  v48 = v38;
  v54 = m_rootShape;
  v55 = m_parentShape;
  v49 = v36;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v58.m256i_i64[1] + 32i64))(v58.m256i_i64[1], 4i64, !queryAndTargetSwapped, v50, v42) )
LABEL_5:
    m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v59.m256i_i64[1] + 26)][BYTE2(v36->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v58, (const hknpShapeQueryInfo *)v69, (const hknpShape *)v36, targetShapeFilterData, (const hknpShapeQueryInfo *)v60, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<2>
==============
*/
void unwrapScaledConvex<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v42; 
  hknpShape_vtbl *v49; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  unsigned __int16 v53[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v56; 
  const hknpShape *v57; 
  const hknpShape *v58; 
  unsigned int v59; 
  hknpShape_vtbl *v60; 
  __int16 v61[2]; 
  int v62; 
  __int64 v63; 
  const hknpBody *v64; 
  const hknpShape *v65; 
  const hknpShape *v66; 
  unsigned int v67; 
  __int64 v68; 
  __m256i v69; 
  __m256i v70; 
  const hknpBody *v71; 
  const hknpShape *v72; 
  const hknpShape *m_parentShape; 
  unsigned int m_value; 
  int m_size; 
  const hkTransformf *v76; 
  __int64 v77; 
  char v78; 
  int v79; 
  __int64 v82[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm0, ymmword ptr [rdx]
  }
  m_body = queryShapeInfo->m_body;
  _RCX = targetShapeInfo;
  m_rootShape = queryShapeInfo->m_rootShape;
  __asm
  {
    vmovups xmm5, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vmovups xmm6, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
    vmovups xmm7, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
  }
  v82[2] = (__int64)queryShapeInfo->m_parentShape;
  v82[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v82[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v71 = targetShapeInfo->m_body;
  v72 = targetShapeInfo->m_rootShape;
  __asm
  {
    vmovups [rsp+268h+var_168], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  m_parentShape = targetShapeInfo->m_parentShape;
  __asm
  {
    vmovups [rsp+268h+var_88], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
  }
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  __asm
  {
    vmovss  [rsp+268h+var_90], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
  }
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovups [rsp+268h+var_E8], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v76 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovups [rsp+268h+var_148], ymm2
    vmovss  [rsp+268h+var_F0], xmm0
  }
  v78 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm { vpextrq rcx, xmm2, 1 }
  v82[0] = (__int64)m_body;
  v82[1] = (__int64)m_rootShape;
  v82[5] = 0i64;
  v77 = 0i64;
  v79 = (int)m_shapeToWorld;
  v70.m256i_i64[1] = _RCX;
  __asm
  {
    vmovups xmm0, xmmword ptr [rcx+40h]
    vsubps  xmm1, xmm0, xmm5
    vpxor   xmm0, xmm0, xmm0
    vandnps xmm2, xmm6, xmm1
    vpcmpeqd xmm1, xmm0, xmm0
    vblendps xmm4, xmm0, xmm1, 7
    vcmpleps xmm3, xmm2, xmm7
    vpand   xmm0, xmm3, xmm4
    vptest  xmm0, xmm4
  }
  if ( !_CF )
  {
    m_isScaled = 1;
    __asm
    {
      vmovups xmm0, xmmword ptr [rcx+40h]
      vmovups xmmword ptr [rsp+268h+var_88], xmm0
      vmovups xmm1, xmmword ptr [rcx+50h]
      vmovups xmmword ptr [rsp+268h+var_88+10h], xmm1
      vmovss  xmm0, dword ptr [rcx+20h]
      vmovss  [rsp+268h+var_90], xmm0
    }
  }
  __asm { vmovups xmm3, xmmword ptr [r9+40h] }
  v42 = *(_QWORD *)(_RCX + 56);
  __asm
  {
    vsubps  xmm0, xmm3, xmm5
    vandnps xmm1, xmm6, xmm0
    vcmpleps xmm2, xmm1, xmm7
    vpand   xmm0, xmm2, xmm4
    vptest  xmm0, xmm4
  }
  v70.m256i_i64[1] = v42;
  if ( !_CF )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r9+50h]
      vmovss  xmm1, dword ptr [r9+20h]
      vmovss  [rsp+268h+var_F0], xmm1
      vmovups xmmword ptr [rsp+268h+var_E8+10h], xmm0
    }
    v78 = 1;
    __asm { vmovups xmmword ptr [rsp+268h+var_E8], xmm3 }
  }
  v49 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  if ( !v69.m256i_i64[1] )
    goto LABEL_8;
  v61[0] = v69.m256i_i16[8];
  v62 = v69.m256i_i32[5];
  v63 = v69.m256i_i64[3];
  v66 = queryShapeInfo->m_parentShape;
  v67 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
  v53[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v56 = v71;
  v57 = v72;
  v68 = v42;
  v58 = m_parentShape;
  v64 = m_body;
  v59 = m_value;
  v65 = m_rootShape;
  v60 = v49;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v69.m256i_i64[1] + 32i64))(v69.m256i_i64[1], 4i64, !queryAndTargetSwapped, v61, v53) )
  {
    v42 = v70.m256i_i64[1];
LABEL_8:
    m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v42 + 26)][BYTE2(v49->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v69, (const hknpShapeQueryInfo *)v82, (const hknpShape *)v49, targetShapeFilterData, (const hknpShapeQueryInfo *)&v71, queryToTarget, queryAndTargetSwapped, collector);
  }
  __asm
  {
    vmovaps xmm6, [rsp+268h+var_48]
    vmovaps xmm7, [rsp+268h+var_58]
  }
}

/*
==============
unwrapScaledConvex<0>
==============
*/
void unwrapScaledConvex<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v38; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  unsigned __int16 v40[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v43; 
  const hknpShape *v44; 
  const hknpShape *v45; 
  unsigned int v46; 
  const hknpShape *v47; 
  __int16 v48[2]; 
  int v49; 
  __int64 v50; 
  const hknpBody *v51; 
  const hknpShape *v52; 
  const hknpShape *v53; 
  unsigned int v54; 
  __int64 v55; 
  __m256i v56; 
  __m256i v57; 
  __int64 v58[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  const hknpBody *v63; 
  const hknpShape *v64; 
  const hknpShape *v65; 
  unsigned int m_value; 
  int m_size; 
  const hkTransformf *v68; 
  __int64 v69; 
  char v70; 
  int v71; 

  __asm
  {
    vmovups ymm2, ymmword ptr [rdx+20h]
    vmovups ymm0, ymmword ptr [rdx]
    vmovups xmm1, cs:?hkSse_signMask@hkMath@@3QBIB; uint const near * const hkMath::hkSse_signMask
  }
  m_body = queryShapeInfo->m_body;
  _RCX = targetShapeInfo;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v58[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v58[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v63 = targetShapeInfo->m_body;
  v64 = targetShapeInfo->m_rootShape;
  v65 = targetShapeInfo->m_parentShape;
  __asm
  {
    vmovups [rsp+248h+var_148], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
  }
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  __asm
  {
    vmovups [rsp+248h+var_C8], ymm0
    vmovss  xmm0, dword ptr [r8+38h]
    vmovups [rsp+248h+var_128], ymm2
  }
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  __asm
  {
    vmovss  [rsp+248h+var_D0], xmm0
    vmovups ymm0, ymmword ptr [rcx+40h]
  }
  v68 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  __asm
  {
    vmovups [rsp+248h+var_68], ymm0
    vmovss  xmm0, dword ptr [rcx+38h]
  }
  v70 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm
  {
    vpextrq rcx, xmm2, 1
    vmovss  [rsp+248h+var_70], xmm0
  }
  v58[0] = (__int64)m_body;
  v58[1] = (__int64)m_rootShape;
  v58[2] = (__int64)m_parentShape;
  v58[5] = 0i64;
  v69 = 0i64;
  v71 = (int)m_shapeToWorld;
  v57.m256i_i64[1] = _RCX;
  __asm
  {
    vmovups xmm0, xmmword ptr [rcx+40h]
    vsubps  xmm2, xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h; __m128 const near * const g_vectorfConstants
    vandnps xmm2, xmm1, xmm2
    vcmpleps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
    vpxor   xmm0, xmm0, xmm0
    vpcmpeqd xmm1, xmm0, xmm0
    vblendps xmm2, xmm0, xmm1, 7
    vpand   xmm1, xmm3, xmm2
    vptest  xmm1, xmm2
  }
  if ( !_CF )
  {
    m_isScaled = 1;
    __asm
    {
      vmovups xmm0, xmmword ptr [rcx+40h]
      vmovups xmmword ptr [rsp+248h+var_C8], xmm0
      vmovups xmm1, xmmword ptr [rcx+50h]
      vmovups xmmword ptr [rsp+248h+var_C8+10h], xmm1
      vmovss  xmm0, dword ptr [rcx+20h]
      vmovss  [rsp+248h+var_D0], xmm0
    }
  }
  v38 = *(_QWORD *)(_RCX + 56);
  m_dispatcher = queryContext->m_dispatcher;
  v57.m256i_i64[1] = v38;
  if ( v56.m256i_i64[1] )
  {
    v48[0] = v56.m256i_i16[8];
    v49 = v56.m256i_i32[5];
    v50 = v56.m256i_i64[3];
    v54 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v40[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v43 = v63;
    v44 = v64;
    v55 = v38;
    v45 = v65;
    v51 = m_body;
    v52 = m_rootShape;
    v46 = m_value;
    v53 = m_parentShape;
    v47 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v56.m256i_i64[1] + 32i64))(v56.m256i_i64[1], 4i64, !queryAndTargetSwapped, v48, v40) )
      return;
    v38 = v57.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v38 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v56, (const hknpShapeQueryInfo *)v58, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&v63, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher
==============
*/
void HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(HavokPhysics_CollisionQueryDispatcher *this)
{
  hknpCollisionQueryDispatcher::DispatchTable<void (__cdecl*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)> *p_m_shapeCastDispatchTable; 
  int v3; 
  int i; 
  int j; 
  int v6; 
  __int64 v7; 
  const hknpShapeType::Enum *m_baseTypeMap; 
  int v9; 
  __int64 v10; 
  const hknpShapeType::Enum *v11; 
  int v12; 
  __int64 v13; 
  const hknpShapeType::Enum *v14; 
  int v15; 
  __int64 v16; 
  const hknpShapeType::Enum *v17; 
  int v18; 
  __int64 v19; 
  const hknpShapeType::Enum *v20; 
  int v21; 
  __int64 v22; 
  const hknpShapeType::Enum *v23; 
  int v24; 
  __int64 v25; 
  int v26; 
  __int64 v27; 
  const hknpShapeType::Enum *v28; 
  __int64 v29; 
  const hknpShapeType::Enum *v30; 

  hknpCollisionQueryDispatcher::hknpCollisionQueryDispatcher(this, INITIALIZE_TABLES);
  this->__vftable = (HavokPhysics_CollisionQueryDispatcher_vtbl *)&HavokPhysics_CollisionQueryDispatcher::`vftable';
  HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(this, 0xFFFFFFFF);
  p_m_shapeCastDispatchTable = &this->m_shapeCastDispatchTable;
  this->m_defaultShapeCastFunc = this->m_shapeCastDispatchTable.m_dispatchTable[1][0];
  v3 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
      hknpCollisionQueryDispatcher::setShapeCastFunction(this, (hknpShapeType::Enum)i, (hknpShapeType::Enum)j, HavokPhysics_CollisionQueryDispatcher::castShapeConvex, "IW castShapeConvex", 0xFFFFFFFF);
  }
  this->m_preScaledCvxClosestPointTable[2][3] = hknpConvexShapeUtil::getClosestPointsGsk;
  v6 = 0;
  v7 = 0i64;
  do
  {
    m_baseTypeMap = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( m_baseTypeMap[v7] == NOP )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v6, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile, "HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile", 0xFFFFFFFF, 1);
      m_baseTypeMap = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( m_baseTypeMap[v7] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, NOP, (hknpShapeType::Enum)v6, HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile, "HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile", 0xFFFFFFFF, 1);
    ++v6;
    ++v7;
  }
  while ( v6 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[0][22] = HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile;
  v9 = 0;
  v10 = 0i64;
  do
  {
    v11 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v11[v10] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v9, NOP, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile>", 0xFFFFFFFF, 1);
      v11 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v11[v10] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v9, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile>", 0xFFFFFFFF, 1);
    ++v9;
    ++v10;
  }
  while ( v9 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][0] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_;
  v12 = 0;
  v13 = 0i64;
  do
  {
    v14 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v14[v13] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v12, SHAPE_KEY_ARRAY, HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape, "HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape", 0xFFFFFFFF, 1);
      v14 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v14[v13] == SHAPE_KEY_ARRAY )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v12, HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape, "HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape", 0xFFFFFFFF, 1);
    ++v12;
    ++v13;
  }
  while ( v12 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][8] = HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape;
  v15 = 0;
  v16 = 0i64;
  do
  {
    v17 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v17[v16] == SHAPE_KEY_ARRAY )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v15, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape>", 0xFFFFFFFF, 1);
      v17 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v17[v16] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, (hknpShapeType::Enum)v15, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape>", 0xFFFFFFFF, 1);
    ++v15;
    ++v16;
  }
  while ( v15 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[8][22] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_;
  v18 = 0;
  v19 = 0i64;
  do
  {
    v20 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v20[v19] == USER_7 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v18, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape, "HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape", 0xFFFFFFFF, 1);
      v20 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v20[v19] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7, (hknpShapeType::Enum)v18, HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape, "HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape", 0xFFFFFFFF, 1);
    ++v18;
    ++v19;
  }
  while ( v18 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[16][22] = HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape;
  v21 = 0;
  v22 = 0i64;
  do
  {
    v23 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v23[v22] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v21, USER_7, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape>", 0xFFFFFFFF, 1);
      v23 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v23[v22] == USER_7 )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v21, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape>", 0xFFFFFFFF, 1);
    ++v21;
    ++v22;
  }
  while ( v21 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][16] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_;
  v24 = 0;
  v25 = 0i64;
  do
  {
    v26 = 0;
    v27 = 0i64;
    do
    {
      v28 = p_m_shapeCastDispatchTable->m_baseTypeMap;
      if ( p_m_shapeCastDispatchTable->m_baseTypeMap[v27] == v24 )
      {
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v26, USER_7|DISTANCE_FIELD, hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>, "castShapeFunc<StaticModels_HavokShape>", 0xFFFFFFFF, 1);
        v28 = p_m_shapeCastDispatchTable->m_baseTypeMap;
      }
      if ( v28[v27] == (USER_7|DISTANCE_FIELD) )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v24, (hknpShapeType::Enum)v26, hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>, "castShapeFunc<StaticModels_HavokShape>", 0xFFFFFFFF, 1);
      ++v26;
      ++v27;
    }
    while ( v26 < 30 );
    p_m_shapeCastDispatchTable->m_dispatchTable[v25][22] = hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>;
    ++v24;
    ++v25;
  }
  while ( v24 < 30 );
  v29 = 0i64;
  do
  {
    v30 = p_m_shapeCastDispatchTable->m_baseTypeMap;
    if ( p_m_shapeCastDispatchTable->m_baseTypeMap[v29] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v3, NOP, hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>, "flip<castShapeFunc<StaticModels_HavokShape> >", 0xFFFFFFFF, 1);
      v30 = p_m_shapeCastDispatchTable->m_baseTypeMap;
    }
    if ( v30[v29] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v3, hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>, "flip<castShapeFunc<StaticModels_HavokShape> >", 0xFFFFFFFF, 1);
    ++v3;
    ++v29;
  }
  while ( v3 < 30 );
  this->m_shapeCastDispatchTable.m_dispatchTable[22][0] = hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>;
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile
==============
*/
void HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  StaticModels_HavokShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const StaticModels_HavokShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape
==============
*/
void HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 v12; 
  __int64 v13; 
  __int64 v16; 
  signed int v17; 
  __int64 v18; 
  signed int v19; 
  int v28; 
  __int64 v31; 
  int v32; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf v37; 
  void (__fastcall *const *v38)(); 
  __int64 v39; 
  hknpSphereShape *v40; 
  int v41; 
  hknpSphereShape v42[2]; 
  hkTransformf v43; 

  _R12 = queryShapeInfo;
  _R13 = query;
  v12 = *(_QWORD *)&query->m_shape[1].m_memSizeAndFlags;
  if ( *(_BYTE *)(v12 + 5504) )
  {
    v13 = 0i64;
    v39 = 0i64;
    v40 = v42;
    v41 = 128;
    v38 = hknpInplaceShapeBuffer<128>::`vftable';
    _R15 = NULL;
    if ( *(_DWORD *)query->m_levelOfDetail == 3 )
    {
      __asm { vxorps  xmm2, xmm2, xmm2; radius }
      hknpSphereShape::hknpSphereShape(v42, (const hkVector4f *)&g_vectorfConstants[5], *(float *)&_XMM2);
      v13 = v16;
      *(_WORD *)(v16 + 16) = 0;
      v39 = v16;
      _R15 = (const hknpShape *)v16;
    }
    v17 = 0;
    v32 = *(_DWORD *)(v12 + 5492);
    if ( v32 )
    {
      v18 = 0i64;
      do
      {
        if ( *(_BYTE *)(v12 + 5696) )
          v19 = *(_DWORD *)(v18 + *(_QWORD *)(v12 + 5728));
        else
          v19 = v17;
        _RAX = *(_QWORD *)(v12 + 304) + 32i64 * v19;
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovups [rsp+2A8h+var_138], xmm0
        }
        if ( *(_BYTE *)(v12 + 5500) )
        {
          hkRotationImpl<float>::set(&v37.m_rotation, (const hkQuaternionf *)(*(_QWORD *)(v12 + 320) + 16i64 * v19));
        }
        else
        {
          __asm
          {
            vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rsp+2A8h+var_168.baseclass_0.m_col0.m_quad], ymm0
            vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
            vmovups xmmword ptr [rsp+2A8h+var_168.baseclass_0.m_col2.m_quad], xmm0
          }
        }
        queryShapeInfoa.m_body = _R12->m_body;
        queryShapeInfoa.m_rootShape = _R12->m_rootShape;
        queryShapeInfoa.m_shapeKeyMask = NULL;
        queryShapeInfoa.m_scalingInternals.m_isScaled = _R12->m_scalingInternals.m_isScaled;
        queryShapeInfoa.m_scalingInternals.m_mode = _R12->m_scalingInternals.m_mode;
        __asm
        {
          vmovups ymm0, ymmword ptr [r12+40h]
          vmovups ymmword ptr [rsp+2A8h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], ymm0
          vmovss  xmm0, dword ptr [r12+38h]
          vmovss  [rsp+2A8h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0
        }
        queryShapeInfoa.m_parentShape = _R13->m_shape;
        queryShapeInfoa.m_shapeToWorld = &v37;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v19;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        hkTransformf::setMul(&v43, queryToTarget, &v37);
        __asm
        {
          vmovups ymm0, ymmword ptr [r13+0]
          vmovups ymmword ptr [rsp+2A8h+query.baseclass_0.m_shapeTagCodec], ymm0
          vmovups ymm1, ymmword ptr [r13+20h]
          vmovups ymmword ptr [rsp+2A8h+query.baseclass_0.m_levelOfDetail], ymm1
        }
        if ( *(_DWORD *)_R13->m_levelOfDetail == 3 )
        {
          if ( *(_DWORD *)(v12 + 48) )
            v28 = *(_DWORD *)(v19 * *(_DWORD *)(v12 + 52) + *(_QWORD *)(v12 + 40));
          else
            v28 = *(_DWORD *)(v12 + 32);
          _RCX = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 24) + 24i64) + 8i64 * v28);
          __asm
          {
            vmovups xmm0, xmmword ptr [rcx+20h]
            vmovss  dword ptr [r15+20h], xmm0
          }
          querya.m_shape = _R15;
        }
        else
        {
          if ( *(_DWORD *)(v12 + 48) )
            v31 = *(int *)(v19 * *(_DWORD *)(v12 + 52) + *(_QWORD *)(v12 + 40));
          else
            v31 = *(int *)(v12 + 32);
          querya.m_shape = *(const hknpShape **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 24) + 24i64) + 8 * v31) + 240i64);
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v43, queryAndTargetSwapped, collector);
        ++v17;
        v18 += 4i64;
      }
      while ( v17 != v32 );
      v13 = v39;
    }
    v38 = hknpShapeBuffer::`vftable';
    if ( v13 )
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 8i64))(v13, 0i64);
  }
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape
==============
*/
void HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpShape *m_shape; 
  int v18; 
  unsigned int v20; 
  __int64 v25; 
  bool m_isScaled; 
  __int64 v28; 
  bool v31; 
  BOOL v32; 
  signed int m_mode; 
  const hknpShape *CollisionTileModelShape; 
  __int64 m_size; 
  const hknpShape *v89; 
  unsigned int v90; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  const hknpShape *m_rootShape; 
  const hknpBody *m_body; 
  void (__fastcall *decode)(hknpShapeTagCodec *, unsigned __int16, hknpCollisionQueryType::Enum, const hknpBody *, const hknpShape *, const hknpShape *, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant>, const hknpShape *, hknpQueryFilterData *); 
  unsigned __int16 CollisionTileModelShapeTag; 
  unsigned int v107; 
  int v108; 
  const hknpShape *v109; 
  const hknpShape *v111; 
  const hknpShapeTagCodec *v112; 
  __int128 v115; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  vec3_t origin; 
  hkTransformf v119; 
  vec4_t orientationAsQuat; 
  hkQuaternionf qi; 
  __int128 v122[4]; 
  hkTransformf v123; 
  void *retaddr; 

  _R11 = &retaddr;
  m_shape = query->m_shape;
  v18 = 0;
  _R14 = queryShapeInfo;
  v20 = *(_DWORD *)&m_shape[1].m_memSizeAndFlags;
  v109 = m_shape;
  if ( SLODWORD(m_shape[1].m_convexRadius) > 0 )
  {
    __asm
    {
      vmovaps xmmword ptr [r11-48h], xmm6
      vmovaps xmmword ptr [r11-58h], xmm7
      vmovaps xmmword ptr [r11-68h], xmm8
      vmovaps xmmword ptr [r11-78h], xmm9
      vmovaps xmmword ptr [r11-88h], xmm10
      vmovss  xmm10, cs:__real@3d000000
      vmovaps xmmword ptr [r11-98h], xmm11
      vmovss  xmm11, cs:__real@3f800000
      vmovaps xmmword ptr [r11-0A8h], xmm12
      vxorps  xmm12, xmm12, xmm12
    }
    while ( 1 )
    {
      __asm { vmovups ymm0, ymmword ptr [r14+40h] }
      v25 = *(_QWORD *)&m_shape[1].m_flags.m_storage;
      queryShapeInfoa.m_body = _R14->m_body;
      queryShapeInfoa.m_rootShape = _R14->m_rootShape;
      queryShapeInfoa.m_parentShape = _R14->m_parentShape;
      queryShapeInfoa.m_shapeKeyPath = _R14->m_shapeKeyPath;
      queryShapeInfoa.m_shapeToWorld = _R14->m_shapeToWorld;
      m_isScaled = _R14->m_scalingInternals.m_isScaled;
      __asm
      {
        vmovups ymmword ptr [rsp+308h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], ymm0
        vmovss  xmm0, dword ptr [r14+38h]
      }
      queryShapeInfoa.m_scalingInternals.m_isScaled = m_isScaled;
      queryShapeInfoa.m_scalingInternals.m_mode = _R14->m_scalingInternals.m_mode;
      __asm { vmovss  [rsp+308h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0 }
      queryShapeInfoa.m_shapeKeyMask = NULL;
      v28 = (unsigned __int16)v18;
      *(double *)&_XMM0 = StaticModels_GetCollisionTileModelInstanceScale(v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF, *(unsigned __int16 *)(v25 + 4i64 * (unsigned __int16)v18 + 2));
      __asm
      {
        vmovaps xmm6, xmm0
        vshufps xmm6, xmm6, xmm6, 0
      }
      *(double *)&_XMM0 = StaticModels_GetCollisionTileModelInstanceScale(v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF, *(unsigned __int16 *)(v25 + 4i64 * (unsigned __int16)v18 + 2));
      __asm { vucomiss xmm0, xmm11 }
      v32 = !v31;
      StaticModels_GetCollisionTileModelInstanceTransform(v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF, *(unsigned __int16 *)(v25 + 4i64 * (unsigned __int16)v18 + 2), &origin, &orientationAsQuat);
      __asm
      {
        vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
        vmovups xmm0, xmmword ptr [rsp+308h+var_158]
        vmovups ymmword ptr [rsp+308h+var_198], ymm1
        vmovups ymm1, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
        vmovups ymmword ptr [rsp+308h+var_198+20h], ymm1
        vmovups xmmword ptr [rsp+308h+qi.m_vec.m_quad], xmm0
      }
      hkRotationImpl<float>::set(&v119.m_rotation, &qi);
      v31 = !_R14->m_scalingInternals.m_isScaled;
      __asm
      {
        vmulss  xmm1, xmm10, dword ptr [rsp+308h+origin]
        vmulss  xmm0, xmm10, dword ptr [rsp+308h+origin+4]
        vmulss  xmm2, xmm10, dword ptr [rsp+308h+origin+8]
        vmovss  dword ptr [rsp+308h+var_198+30h], xmm1
        vmovss  dword ptr [rsp+308h+var_198+34h], xmm0
        vmovss  dword ptr [rsp+308h+var_198+38h], xmm2
        vmovss  dword ptr [rsp+308h+var_198+3Ch], xmm12
      }
      if ( !v31 )
        break;
      if ( v32 )
        goto LABEL_9;
LABEL_14:
      hkTransformf::setMul(&v123, queryToTarget, &v119);
      _RAX = _R14->m_shapeToWorld;
      __asm
      {
        vmovups xmm4, xmmword ptr [rsp+308h+var_198+30h]
        vmovups xmm5, xmmword ptr [rsp+308h+var_198+20h]
        vshufps xmm0, xmm4, xmm4, 55h ; 'U'
        vmovups ymm8, ymmword ptr [rax]
        vmovups xmm9, xmmword ptr [rax+20h]
        vshufps xmm1, xmm4, xmm4, 0
        vextractf128 xmm7, ymm8, 1
        vmulps  xmm2, xmm0, xmm7
        vmulps  xmm0, xmm1, xmm8
        vaddps  xmm3, xmm2, xmm0
        vshufps xmm1, xmm4, xmm4, 0AAh ; ''
        vmulps  xmm2, xmm1, xmm9
        vaddps  xmm6, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vaddps  xmm4, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmovups xmm5, xmmword ptr [rsp+308h+var_198+10h]
        vmulps  xmm1, xmm0, xmm9
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+308h+var_118], xmm2
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vaddps  xmm4, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmovups xmm5, xmmword ptr [rsp+308h+var_198]
        vmulps  xmm1, xmm0, xmm9
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+308h+var_128], xmm2
        vmovups [rsp+308h+var_108], xmm6
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmulps  xmm1, xmm0, xmm9
        vaddps  xmm4, xmm3, xmm2
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+308h+var_138], xmm2
        vaddps  xmm0, xmm6, xmmword ptr [rax+30h]
        vmovups [rsp+308h+var_108], xmm0
      }
      CollisionTileModelShape = (const hknpShape *)StaticModels_GetCollisionTileModelShape((*(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x4000) != 0, v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF);
      m_size = queryShapeInfoa.m_shapeKeyPath.m_size;
      v89 = CollisionTileModelShape;
      v111 = CollisionTileModelShape;
      ++v18;
      queryShapeInfoa.m_shapeKeyPath.m_size += m_shape->m_numShapeKeyBits;
      v108 = v18;
      v90 = queryShapeInfoa.m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((v18 << (32 - LOBYTE(queryShapeInfoa.m_shapeKeyPath.m_size))) - 1);
      queryShapeInfoa.m_shapeToWorld = (const hkTransformf *)v122;
      _RAX = query;
      v107 = v90;
      queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v90;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymm1, ymmword ptr [rax+20h]
      }
      m_shapeTagCodec = query->m_shapeTagCodec;
      v112 = m_shapeTagCodec;
      __asm { vmovups ymmword ptr [rsp+308h+query.baseclass_0.m_levelOfDetail], ymm1 }
      querya.m_shape = v89;
      __asm { vmovups ymmword ptr [rsp+308h+query.baseclass_0.m_shapeTagCodec], ymm0 }
      if ( m_shapeTagCodec )
      {
        __asm { vmovups xmm0, xmmword ptr [rsp+308h+query.baseclass_0.m_filterData.m_materialId.baseclass_0.m_value] }
        m_rootShape = _R14->m_rootShape;
        m_body = _R14->m_body;
        __asm { vmovups [rsp+308h+var_260], xmm0 }
        decode = m_shapeTagCodec->decode;
        CollisionTileModelShapeTag = StaticModels_GetCollisionTileModelShapeTag((*(_WORD *)(v25 + 4 * v28) & 0x4000) != 0, v20, *(_WORD *)(v25 + 4 * v28) & 0x3FFF);
        ((void (__fastcall *)(const hknpShapeTagCodec *, _QWORD, __int64, const hknpBody *, const hknpShape *, const hknpShape *, unsigned int, const hknpShape *, __int128 *))decode)(v112, CollisionTileModelShapeTag, 4i64, m_body, m_rootShape, v109, v107, v111, &v115);
        m_shape = v109;
        v18 = v108;
        querya.m_filterData.m_collisionFilterInfo = DWORD1(v115);
        querya.m_filterData.m_materialId.m_value = v115;
      }
      hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v123, queryAndTargetSwapped, collector);
      if ( v18 >= SLODWORD(m_shape[1].m_convexRadius) )
      {
        __asm
        {
          vmovaps xmm12, [rsp+308h+var_A8]
          vmovaps xmm11, [rsp+308h+var_98]
          vmovaps xmm10, [rsp+308h+var_88]
          vmovaps xmm9, [rsp+308h+var_78]
          vmovaps xmm8, [rsp+308h+var_68]
          vmovaps xmm7, [rsp+308h+var_58]
          vmovaps xmm6, [rsp+308h+var_48]
        }
        return;
      }
    }
    __asm
    {
      vmovups xmm1, xmmword ptr [r14+40h]
      vmulps  xmm6, xmm6, xmm1
      vmulps  xmm1, xmm1, xmmword ptr [rsp+308h+var_198+30h]
      vmovups xmmword ptr [rsp+308h+var_198+30h], xmm1
    }
LABEL_9:
    queryShapeInfoa.m_scalingInternals.m_isScaled = 1;
    __asm
    {
      vmovups xmmword ptr [rsp+308h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], xmm6
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rsp+308h+queryShapeInfo.m_scalingInternals.m_offset.m_quad], xmm0
    }
    *(double *)&_XMM0 = StaticModels_GetCollisionTileModelInstanceScale(v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF, *(unsigned __int16 *)(v25 + 4i64 * (unsigned __int16)v18 + 2));
    __asm { vucomiss xmm0, xmm11 }
    if ( v31 )
      m_mode = _R14->m_scalingInternals.m_mode;
    else
      m_mode = 0;
    queryShapeInfoa.m_scalingInternals.m_mode = m_mode;
    _RAX = StaticModels_GetCollisionTileModelShape((*(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x4000) != 0, v20, *(_WORD *)(v25 + 4i64 * (unsigned __int16)v18) & 0x3FFF);
    __asm
    {
      vmovss  xmm0, dword ptr [rax+20h]
      vmovss  [rsp+308h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0
    }
    if ( (_RAX[24] & 1) != 0 )
      hknpShapeUtil::calcScalingParameters((hknpShapeType::Enum)(unsigned __int8)_RAX[26], (const hkcdVertex *)&_RAX[*((unsigned __int16 *)_RAX + 30) + 58], *((unsigned __int16 *)_RAX + 29), (hknpShape::ScaleMode)m_mode, &queryShapeInfoa.m_scalingInternals.m_scale, &queryShapeInfoa.m_scalingInternals.m_convexRadius, &queryShapeInfoa.m_scalingInternals.m_offset);
    goto LABEL_14;
  }
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::castShapeConvex
==============
*/
void HavokPhysics_CollisionQueryDispatcher::castShapeConvex(hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  const hknpCollisionFilter *m_filter; 
  char v26; 
  void *v29; 
  hkMemoryRouter *Value; 
  __int64 v31; 
  char *m_cur; 
  char *v33; 
  __int64 v37; 
  const hkcdVertex *v44; 
  int v45; 
  hkMemoryRouter *v46; 
  __int64 v47; 
  const hkcdVertex *v48; 
  char *v49; 
  __int64 v52; 
  int Ref; 
  bool RefDetailFlag; 
  bool v61; 
  unsigned __int8 v67; 
  int m_numVertices; 
  hkcdVertex *m_vertices; 
  hkMemoryRouter *v103; 
  signed int v104; 
  int v105; 
  int v106; 
  char *v107; 
  hkMemoryRouter *v108; 
  signed int v109; 
  int v110; 
  bool v122; 
  int v123; 
  int v124; 
  hknpConvexShape *queryShape; 
  int m_storage; 
  void *p; 
  int v131; 
  __int64 v133; 
  char v134; 
  hknpScaledConvexVertexShape targetVerts; 
  __int128 v136[2]; 
  __m256i v138; 
  __int128 v139; 
  char v141; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  _RDI = query;
  _R14 = targetShapeInfo;
  _RBX = 0i64;
  m_filter = query->m_filter;
  if ( m_filter && m_filter->m_type.m_storage == 6 && (_RBX = query->m_filterData.m_userData) != 0 && *(_QWORD *)(_RBX + 24) && !Physics_GetBrushBasisFromUserData(targetShapeFilterData->m_userData) )
  {
    v26 = 1;
  }
  else
  {
    v26 = 0;
    if ( _RBX && *(_QWORD *)(_RBX + 32) )
    {
      queryShape = (hknpConvexShape *)_RDI->m_shape;
      goto LABEL_8;
    }
  }
  queryShape = NULL;
LABEL_8:
  if ( !_RBX || (_R15 = *(_QWORD *)(_RBX + 32)) == 0 )
    _R15 = (__int64)_RDI->m_shape;
  if ( v26 )
    _R15 = *(_QWORD *)(_RBX + 24);
  m_storage = hknpConvexDispatch::s_shapeTypeToCvxDispatch[*(unsigned __int8 *)(_R15 + 26)].m_disptach.m_storage;
  __asm
  {
    vmovss  xmm0, dword ptr [r15+20h]
    vmovss  [rsp+2E8h+var_1C4], xmm0
  }
  v133 = _R15;
  v134 = 0;
  v29 = (void *)(_R15 + 58 + *(unsigned __int16 *)(_R15 + 60));
  v123 = *(unsigned __int16 *)(_R15 + 58);
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v31 = (16 * v123 + 127) & 0xFFFFFF80;
    m_cur = (char *)Value->m_stack.m_cur;
    v33 = &m_cur[v31];
    if ( (int)v31 > Value->m_stack.m_slabSize || v33 > Value->m_stack.m_end )
      m_cur = (char *)hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v31);
    else
      Value->m_stack.m_cur = v33;
    _R8 = queryShapeInfo;
    __asm
    {
      vmovups xmm3, xmmword ptr [r8+50h]
      vmovups xmm4, xmmword ptr [r8+40h]
    }
    v37 = v123;
    if ( v123 )
    {
      _RCX = m_cur;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm4, xmmword ptr [rsi+rcx]
          vaddps  xmm1, xmm0, xmm3
          vblendps xmm0, xmm1, xmmword ptr [rsi+rcx], 8
          vmovups xmmword ptr [rcx], xmm0
        }
        _RCX += 16;
        --v37;
      }
      while ( v37 );
    }
    v29 = m_cur;
    __asm
    {
      vmovss  xmm0, dword ptr [r8+38h]
      vmovss  [rsp+2E8h+var_1C4], xmm0
    }
    v134 = 1;
  }
  p = v29;
  v131 = v123;
  _RCX = targetShape;
  targetVerts.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[targetShape->m_type.m_storage].m_disptach.m_storage;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+20h]
    vmovss  [rsp+2E8h+var_198.baseclass_0.m_convexRadius], xmm0
  }
  targetVerts.m_shape = (const hknpConvexShape *)targetShape;
  targetVerts.m_isScaled = 0;
  v44 = (const hkcdVertex *)((char *)&targetShape[1].__vftable + WORD2(targetShape[1].__vftable) + 2);
  v45 = WORD1(targetShape[1].__vftable);
  v124 = v45;
  if ( targetShapeInfo->m_scalingInternals.m_isScaled )
  {
    v46 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v46 )
      v46 = hkMemoryRouter::s_fallbackRouter;
    v47 = (16 * v124 + 127) & 0xFFFFFF80;
    v48 = (const hkcdVertex *)v46->m_stack.m_cur;
    v49 = (char *)v48 + v47;
    if ( (int)v47 > v46->m_stack.m_slabSize || v49 > v46->m_stack.m_end )
      v48 = (const hkcdVertex *)hkLifoAllocator::allocateFromNewSlab(&v46->m_stack, v47);
    else
      v46->m_stack.m_cur = v49;
    __asm
    {
      vmovups xmm3, xmmword ptr [r14+50h]
      vmovups xmm4, xmmword ptr [r14+40h]
    }
    v52 = v124;
    if ( v124 )
    {
      _RCX = v48;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm4, xmmword ptr [rsi+rcx]
          vaddps  xmm1, xmm0, xmm3
          vblendps xmm0, xmm1, xmmword ptr [rsi+rcx], 8
          vmovups xmmword ptr [rcx], xmm0
        }
        ++_RCX;
        --v52;
      }
      while ( v52 );
    }
    v44 = v48;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  [rsp+2E8h+var_198.baseclass_0.m_convexRadius], xmm0
    }
    targetVerts.m_isScaled = 1;
    v45 = v124;
  }
  targetVerts.m_vertices = v44;
  targetVerts.m_numVertices = v45;
  if ( targetShapeInfo->m_body )
    Ref = HavokPhysics_GetRef(targetShapeInfo->m_body);
  else
    Ref = 0;
  RefDetailFlag = Physics_GetRefDetailFlag(Ref);
  __asm { vxorps  xmm1, xmm1, xmm1 }
  if ( _RBX )
  {
    __asm { vmovss  xmm10, dword ptr [rbx] }
    if ( *(_BYTE *)(_RBX + 44) && !RefDetailFlag )
    {
      v61 = 1;
      goto LABEL_47;
    }
  }
  else
  {
    __asm { vxorps  xmm10, xmm10, xmm10 }
  }
  v61 = 0;
LABEL_47:
  v122 = v61;
  __asm
  {
    vcmpltss xmm0, xmm1, dword ptr [r15+20h]
    vblendvps xmm2, xmm1, xmm10, xmm0
    vaddss  xmm0, xmm2, [rsp+2E8h+var_1C4]
    vmovss  [rsp+2E8h+var_1C4], xmm0
  }
  _R8 = queryContext;
  if ( startCollector )
    __asm { vxorps  xmm9, xmm9, xmm9 }
  else
    __asm { vbroadcastss xmm9, dword ptr [r8+18h] }
  v67 = collector->m_hints.m_storage;
  __asm
  {
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+240h; __m128 const near * const g_vectorfConstants
    vmovups [rsp+2E8h+var_138], xmm0
    vbroadcastss xmm13, dword ptr [rdi+60h]
    vbroadcastss xmm14, dword ptr [rdi+68h]
  }
  _RDX = targetTquery;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx]
    vmovups [rsp+2E8h+var_128], ymm0
    vmovups ymm1, ymmword ptr [rdx+20h]
    vmovups [rsp+2E8h+var_108], ymm1
  }
  v139 = *(_OWORD *)_RT0.m256i_i8;
  __asm
  {
    vmulps  xmm0, xmm9, xmmword ptr [rdi+40h]
    vaddps  xmm0, xmm0, xmmword ptr [rdx+30h]
    vmovups xmmword ptr [rsp+2E8h+var_108+10h], xmm0
  }
  if ( !queryShape || castShapeConvexFirstPass(v61, queryShape, queryContext, _RDI, queryShapeInfo, &targetVerts, targetShapeFilterData, targetShapeInfo, targetTquery, queryAndTargetSwapped, collector, startCollector) )
  {
    __asm
    {
      vmovss  xmm12, dword ptr cs:__xmm@80000000800000008000000080000000
      vmovss  xmm15, cs:__real@7f7fffee
    }
    if ( ((unsigned __int8 (__fastcall *)(int *, hknpScaledConvexVertexShape *, __m256i *, _QWORD, __int128 *))queryContext->m_dispatcher->m_preScaledCvxClosestPointTable[m_storage][targetVerts.m_type])(&m_storage, &targetVerts, &v138, v67, v136) )
    {
      __asm
      {
        vbroadcastss xmm3, dword ptr [rdi+64h]
        vmovups xmm0, [rsp+2E8h+var_138]
        vsubps  xmm8, xmm0, xmm3
        vmovups xmm4, xmmword ptr [rdi+40h]
        vdpps   xmm0, xmm4, xmm4, 7Fh
        vxorps  xmm11, xmm11, xmm11
        vcmpleps xmm3, xmm0, xmm11
        vrsqrtps xmm1, xmm0
        vmulps  xmm2, xmm1, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
        vmulps  xmm0, xmm1, xmm0
        vmulps  xmm1, xmm1, xmm0
        vmovups xmm0, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
        vsubps  xmm1, xmm0, xmm1
        vmulps  xmm2, xmm1, xmm2
        vandnps xmm0, xmm3, xmm2
        vmulps  xmm1, xmm4, xmm0
        vmovups xmm7, [rsp+2E8h+var_148]
        vdpps   xmm2, xmm1, xmm7, 7Fh
      }
      if ( !v122 )
      {
        __asm
        {
          vxorps  xmm0, xmm10, xmm12
          vmovaps xmm1, xmm0
          vshufps xmm1, xmm1, xmm1, 0
          vucomiss xmm8, xmm1
        }
      }
      __asm
      {
        vmovups xmm0, cs:__xmm@b58637bdb58637bdb58637bdb58637bd
        vucomiss xmm2, xmm0
      }
    }
  }
  if ( targetVerts.m_isScaled )
  {
    m_numVertices = targetVerts.m_numVertices;
    m_vertices = (hkcdVertex *)targetVerts.m_vertices;
    v103 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v103 )
      v103 = hkMemoryRouter::s_fallbackRouter;
    v104 = (16 * m_numVertices + 127) & 0xFFFFFF80;
    v105 = (v104 + 15) & 0xFFFFFFF0;
    if ( v104 > v103->m_stack.m_slabSize || (char *)m_vertices + v105 != v103->m_stack.m_cur || v103->m_stack.m_firstNonLifoEnd == m_vertices )
      hkLifoAllocator::slowBlockFree(&v103->m_stack, m_vertices, v105);
    else
      v103->m_stack.m_cur = m_vertices;
  }
  if ( v134 )
  {
    v106 = v131;
    v107 = (char *)p;
    v108 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v108 )
      v108 = hkMemoryRouter::s_fallbackRouter;
    v109 = (16 * v106 + 127) & 0xFFFFFF80;
    v110 = (v109 + 15) & 0xFFFFFFF0;
    if ( v109 > v108->m_stack.m_slabSize || &v107[v110] != v108->m_stack.m_cur || v108->m_stack.m_firstNonLifoEnd == v107 )
      hkLifoAllocator::slowBlockFree(&v108->m_stack, v107, v110);
    else
      v108->m_stack.m_cur = v107;
  }
  _R11 = &v141;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
castShapeConvexFirstPass
==============
*/
__int64 castShapeConvexFirstPass(const bool permitOutwardTrace, const hknpConvexShape *queryShape, hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpScaledConvexVertexShape *targetVerts, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  const hknpScaledConvexVertexShape *v24; 
  hknpCollisionQueryCollector *v26; 
  const hknpCollisionFilter *m_filter; 
  char *v30; 
  __int64 m_size; 
  hkMemoryRouter *Value; 
  __int64 v34; 
  char *m_cur; 
  char *v36; 
  __int64 v39; 
  unsigned __int8 v47; 
  int v80; 
  char *v81; 
  hkMemoryRouter *v82; 
  signed int v83; 
  int v84; 
  __int64 result; 
  hknpCollisionQueryContext *v99; 
  int m_storage; 
  void *p; 
  int v102; 
  const hknpConvexShape *v104; 
  char v105; 
  __int128 v106[2]; 
  __m256i v108; 
  __int128 v109; 
  char v111; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  _RDI = query;
  v99 = queryContext;
  v24 = targetVerts;
  _RCX = targetTquery;
  v26 = collector;
  _R15 = 0i64;
  m_filter = _RDI->m_filter;
  if ( m_filter && m_filter->m_type.m_storage == 6 )
    _R15 = _RDI->m_filterData.m_userData;
  m_storage = hknpConvexDispatch::s_shapeTypeToCvxDispatch[queryShape->m_type.m_storage].m_disptach.m_storage;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+20h]
    vmovss  [rsp+268h+var_184], xmm0
  }
  v104 = queryShape;
  v105 = 0;
  v30 = (char *)&queryShape->m_vertices + queryShape->m_vertices.m_offset;
  m_size = queryShape->m_vertices.m_size;
  _R12 = queryShapeInfo;
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v34 = (16 * (_DWORD)m_size + 127) & 0xFFFFFF80;
    m_cur = (char *)Value->m_stack.m_cur;
    v36 = &m_cur[v34];
    if ( (int)v34 > Value->m_stack.m_slabSize || v36 > Value->m_stack.m_end )
      m_cur = (char *)hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v34);
    else
      Value->m_stack.m_cur = v36;
    __asm
    {
      vmovups xmm3, xmmword ptr [r12+50h]
      vmovups xmm4, xmmword ptr [r12+40h]
    }
    v39 = m_size;
    if ( (_DWORD)m_size )
    {
      _RCX = m_cur;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm4, xmmword ptr [rbx+rcx]
          vaddps  xmm1, xmm3, xmm0
          vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8
          vmovups xmmword ptr [rcx], xmm0
        }
        _RCX += 16;
        --v39;
      }
      while ( v39 );
    }
    v30 = m_cur;
    __asm
    {
      vmovss  xmm0, dword ptr [r12+38h]
      vmovss  [rsp+268h+var_184], xmm0
    }
    v105 = 1;
    v24 = targetVerts;
    _RCX = targetTquery;
    queryContext = v99;
    v26 = collector;
  }
  p = v30;
  v102 = m_size;
  __asm
  {
    vmovss  xmm10, dword ptr [r15]
    vmovss  [rsp+268h+var_234], xmm10
  }
  if ( startCollector )
    __asm { vxorps  xmm9, xmm9, xmm9 }
  else
    __asm { vbroadcastss xmm9, dword ptr [r8+18h] }
  v47 = v26->m_hints.m_storage;
  __asm
  {
    vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+240h; __m128 const near * const g_vectorfConstants
    vmovups [rsp+268h+var_138], xmm0
    vbroadcastss xmm12, dword ptr [rdi+60h]
    vbroadcastss xmm13, dword ptr [rdi+68h]
    vmovups ymm0, ymmword ptr [rcx]
    vmovups [rsp+268h+var_128], ymm0
    vmovups ymm1, ymmword ptr [rcx+20h]
    vmovups [rsp+268h+var_108], ymm1
  }
  v109 = *(_OWORD *)_RT0.m256i_i8;
  __asm
  {
    vmulps  xmm0, xmm9, xmmword ptr [rdi+40h]
    vaddps  xmm0, xmm0, xmmword ptr [rcx+30h]
    vmovups xmmword ptr [rsp+268h+var_108+10h], xmm0
    vmovss  xmm15, [rsp+268h+var_234]
    vmovss  xmm14, dword ptr cs:__xmm@80000000800000008000000080000000
  }
  if ( ((unsigned __int8 (__fastcall *)(int *, const hknpScaledConvexVertexShape *, __m256i *, _QWORD, __int128 *))queryContext->m_dispatcher->m_preScaledCvxClosestPointTable[m_storage][v24->m_type])(&m_storage, v24, &v108, v47, v106) )
  {
    __asm
    {
      vbroadcastss xmm3, dword ptr [rdi+64h]
      vmovups xmm0, [rsp+268h+var_138]
      vsubps  xmm7, xmm0, xmm3
      vmovups xmm4, xmmword ptr [rdi+40h]
      vdpps   xmm0, xmm4, xmm4, 7Fh
      vxorps  xmm11, xmm11, xmm11
      vcmpleps xmm3, xmm0, xmm11
      vrsqrtps xmm1, xmm0
      vmulps  xmm2, xmm1, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
      vmulps  xmm0, xmm1, xmm0
      vmulps  xmm1, xmm0, xmm1
      vmovups xmm0, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
      vsubps  xmm1, xmm0, xmm1
      vmulps  xmm2, xmm1, xmm2
      vandnps xmm0, xmm3, xmm2
      vmulps  xmm1, xmm4, xmm0
      vmovups xmm8, [rsp+268h+var_148]
      vdpps   xmm2, xmm1, xmm8, 7Fh
    }
    if ( !permitOutwardTrace )
    {
      __asm
      {
        vxorps  xmm0, xmm10, xmm14
        vmovaps xmm1, xmm0
        vshufps xmm1, xmm1, xmm1, 0
        vucomiss xmm7, xmm1
      }
    }
    __asm
    {
      vmovups xmm0, cs:__xmm@b58637bdb58637bdb58637bdb58637bd
      vucomiss xmm2, xmm0
    }
  }
  if ( v105 )
  {
    v80 = v102;
    v81 = (char *)p;
    v82 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v82 )
      v82 = hkMemoryRouter::s_fallbackRouter;
    v83 = (16 * v80 + 127) & 0xFFFFFF80;
    v84 = (v83 + 15) & 0xFFFFFFF0;
    if ( v83 > v82->m_stack.m_slabSize || &v81[v84] != v82->m_stack.m_cur || v82->m_stack.m_firstNonLifoEnd == v81 )
      hkLifoAllocator::slowBlockFree(&v82->m_stack, v81, v84);
    else
      v82->m_stack.m_cur = v81;
  }
  result = 0i64;
  _R11 = &v111;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
  return result;
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  if ( query->m_shape->m_numShapeKeyBits <= targetShape->m_numShapeKeyBits )
    HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
  else
    HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  int v13; 
  const hknpShape *m_shape; 
  int v17; 
  unsigned __int16 v18; 
  unsigned int m_mode; 
  int v25; 
  int v30; 
  BOOL v32; 
  int m_numShapeKeyBits; 
  int v74; 
  unsigned int v76; 
  const hknpShape *v80; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  __int64 v86; 
  const hknpShape *m_rootShape; 
  const hknpBody *m_body; 
  int v89; 
  unsigned int offsetOut; 
  unsigned __int16 v95; 
  unsigned __int16 v96; 
  __int128 v99; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf bTc; 
  __int128 v103[4]; 
  hkTransformf v104; 

  v13 = 0;
  m_shape = query->m_shape;
  _R14 = queryShapeInfo;
  v17 = *(_DWORD *)&m_shape[1].m_flags.m_storage;
  v95 = 0;
  if ( v17 > 0 )
  {
    while ( 1 )
    {
      v18 = v95;
      if ( !*(_BYTE *)(112i64 * v95 + *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 92) )
        break;
      v95 = ++v13;
      if ( v13 >= v17 )
        return;
    }
    if ( v13 == -1 )
      return;
    __asm
    {
      vmovaps [rsp+288h+var_48], xmm6
      vmovaps [rsp+288h+var_58], xmm7
      vmovaps [rsp+288h+var_68], xmm8
      vmovaps [rsp+288h+var_78], xmm9
    }
    while ( 1 )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [r14+50h]
        vmovss  xmm1, dword ptr [r14+38h]
        vmovups xmm3, xmmword ptr [r14+40h]
      }
      m_mode = _R14->m_scalingInternals.m_mode;
      __asm { vmovss  [rsp+288h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm1 }
      queryShapeInfoa.m_shapeKeyMask = NULL;
      queryShapeInfoa.m_scalingInternals.m_mode = m_mode;
      __asm
      {
        vmovups xmmword ptr [rsp+288h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], xmm3
        vmovups xmmword ptr [rsp+288h+queryShapeInfo.m_scalingInternals.m_offset.m_quad], xmm0
      }
      _RSI = *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 112i64 * v18;
      queryShapeInfoa.m_body = _R14->m_body;
      queryShapeInfoa.m_rootShape = _R14->m_rootShape;
      queryShapeInfoa.m_parentShape = _R14->m_parentShape;
      queryShapeInfoa.m_shapeKeyPath = _R14->m_shapeKeyPath;
      queryShapeInfoa.m_shapeToWorld = _R14->m_shapeToWorld;
      queryShapeInfoa.m_scalingInternals.m_isScaled = _R14->m_scalingInternals.m_isScaled;
      __asm { vmovups xmm0, xmmword ptr [rsi] }
      v25 = *(_DWORD *)(_RSI + 12);
      __asm
      {
        vmovups xmm2, xmmword ptr [rsi+40h]
        vmovups xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col0.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rsi+10h]
        vmovups xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col1.m_quad], xmm1
        vmovups xmm0, xmmword ptr [rsi+20h]
        vmovups xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col2.m_quad], xmm0
        vmovups xmm1, xmmword ptr [rsi+30h]
      }
      v30 = v25 & 8;
      __asm { vmovups xmmword ptr [rsp+288h+bTc.m_translation.m_quad], xmm1 }
      if ( queryShapeInfoa.m_scalingInternals.m_isScaled )
        break;
      if ( v30 )
        goto LABEL_10;
LABEL_15:
      hkTransformf::setMul(&v104, queryToTarget, &bTc);
      _RAX = _R14->m_shapeToWorld;
      __asm
      {
        vmovups xmm4, xmmword ptr [rsp+288h+bTc.m_translation.m_quad]
        vmovups xmm5, xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col2.m_quad]
        vmovups ymm8, ymmword ptr [rax]
        vmovups xmm9, xmmword ptr [rax+20h]
      }
      m_numShapeKeyBits = m_shape->m_numShapeKeyBits;
      __asm
      {
        vshufps xmm0, xmm4, xmm4, 55h ; 'U'
        vshufps xmm1, xmm4, xmm4, 0
        vextractf128 xmm7, ymm8, 1
        vmulps  xmm2, xmm0, xmm7
        vmulps  xmm0, xmm1, xmm8
        vaddps  xmm3, xmm2, xmm0
        vshufps xmm1, xmm4, xmm4, 0AAh ; ''
        vmulps  xmm2, xmm1, xmm9
        vaddps  xmm6, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vaddps  xmm4, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmovups xmm5, xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col1.m_quad]
        vmulps  xmm1, xmm0, xmm9
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+288h+var_E8], xmm2
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vaddps  xmm4, xmm3, xmm2
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmovups xmm5, xmmword ptr [rsp+288h+bTc.m_rotation.baseclass_0.m_col0.m_quad]
        vmulps  xmm1, xmm0, xmm9
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+288h+var_F8], xmm2
        vshufps xmm0, xmm5, xmm5, 55h ; 'U'
        vmulps  xmm3, xmm0, xmm7
        vshufps xmm1, xmm5, xmm5, 0
        vmulps  xmm2, xmm1, xmm8
        vshufps xmm0, xmm5, xmm5, 0AAh ; ''
        vmulps  xmm1, xmm0, xmm9
      }
      v74 = queryShapeInfoa.m_shapeKeyPath.m_size + m_numShapeKeyBits;
      __asm { vmovups [rsp+288h+var_D8], xmm6 }
      v76 = queryShapeInfoa.m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[queryShapeInfoa.m_shapeKeyPath.m_size] | (((v18 + 1) << (32 - v74)) - 1);
      __asm
      {
        vaddps  xmm4, xmm3, xmm2
        vaddps  xmm2, xmm4, xmm1
        vmovups [rsp+288h+var_108], xmm2
        vaddps  xmm0, xmm6, xmmword ptr [rax+30h]
        vmovups [rsp+288h+var_D8], xmm0
      }
      v80 = *(const hknpShape **)(_RSI + 80);
      queryShapeInfoa.m_shapeToWorld = (const hkTransformf *)v103;
      _RAX = query;
      queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v76;
      queryShapeInfoa.m_shapeKeyPath.m_size = v74;
      __asm { vmovups ymm1, ymmword ptr [rax+20h] }
      m_shapeTagCodec = query->m_shapeTagCodec;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+288h+query.baseclass_0.m_levelOfDetail], ymm1
      }
      querya.m_shape = v80;
      __asm { vmovups ymmword ptr [rsp+288h+query.baseclass_0.m_shapeTagCodec], ymm0 }
      if ( m_shapeTagCodec )
      {
        __asm { vmovups xmm0, xmmword ptr [rsp+288h+query.baseclass_0.m_filterData.m_materialId.baseclass_0.m_value] }
        v86 = *(unsigned __int16 *)(_RSI + 88);
        m_rootShape = _R14->m_rootShape;
        offsetOut = v76;
        m_body = _R14->m_body;
        __asm { vmovups [rsp+288h+var_1F8], xmm0 }
        ((void (__fastcall *)(const hknpShapeTagCodec *, __int64, __int64, const hknpBody *, const hknpShape *, const hknpShape *, unsigned int, const hknpShape *, __int128 *))m_shapeTagCodec->decode)(m_shapeTagCodec, v86, 4i64, m_body, m_rootShape, m_shape, offsetOut, v80, &v99);
        querya.m_filterData.m_collisionFilterInfo = DWORD1(v99);
        querya.m_filterData.m_materialId.m_value = v99;
      }
      hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v104, queryAndTargetSwapped, collector);
      v89 = *(_DWORD *)&m_shape[1].m_flags.m_storage;
      v96 = ++v13;
      if ( v13 >= v89 )
      {
LABEL_20:
        v13 = -1;
        v18 = -1;
      }
      else
      {
        while ( 1 )
        {
          v18 = v96;
          if ( !*(_BYTE *)(112i64 * v96 + *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 92) )
            break;
          v96 = ++v13;
          if ( v13 >= v89 )
            goto LABEL_20;
        }
      }
      if ( v13 == -1 )
      {
        __asm
        {
          vmovaps xmm9, [rsp+288h+var_78]
          vmovaps xmm8, [rsp+288h+var_68]
          vmovaps xmm7, [rsp+288h+var_58]
          vmovaps xmm6, [rsp+288h+var_48]
        }
        return;
      }
    }
    __asm
    {
      vmulps  xmm0, xmm3, xmm1
      vmovups xmmword ptr [rsp+288h+bTc.m_translation.m_quad], xmm0
      vmulps  xmm2, xmm3, xmm2
    }
LABEL_10:
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rsp+288h+queryShapeInfo.m_scalingInternals.m_offset.m_quad], xmm0
    }
    queryShapeInfoa.m_scalingInternals.m_isScaled = 1;
    __asm { vmovups xmmword ptr [rsp+288h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], xmm2 }
    if ( (*(_DWORD *)(_RSI + 12) & 8) != 0 )
      v32 = (*(_DWORD *)(_RSI + 12) & 0x20) == 0;
    else
      v32 = m_mode;
    queryShapeInfoa.m_scalingInternals.m_mode = v32;
    _RCX = *(_QWORD *)(_RSI + 80);
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+20h]
      vmovss  [rsp+288h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0
    }
    if ( (*(_BYTE *)(_RCX + 24) & 1) != 0 )
      hknpShapeUtil::calcScalingParameters((hknpShapeType::Enum)*(unsigned __int8 *)(_RCX + 26), (const hkcdVertex *)(_RCX + 58 + *(unsigned __int16 *)(_RCX + 60)), *(unsigned __int16 *)(_RCX + 58), (hknpShape::ScaleMode)v32, &queryShapeInfoa.m_scalingInternals.m_scale, &queryShapeInfoa.m_scalingInternals.m_convexRadius, &queryShapeInfoa.m_scalingInternals.m_offset);
    goto LABEL_15;
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToCompressedMesh(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompoundShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const hknpCompoundShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToConvex(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpShapeQueryInfo *queryInfo; 
  const hkcdVertex *v15; 
  __int64 v16; 
  hkMemoryRouter *Value; 
  __int64 v18; 
  const hkcdVertex *m_cur; 
  char *v20; 
  __int64 v23; 
  const hkcdVertex *v30; 
  __int64 m_size; 
  hkMemoryRouter *v32; 
  __int64 v33; 
  const hkcdVertex *v34; 
  char *v35; 
  __int64 v38; 
  hknpCollisionQueryDispatcher *m_dispatcher; 
  int m_numVertices; 
  hkcdVertex *m_vertices; 
  hkMemoryRouter *v47; 
  signed int v48; 
  int v49; 
  int v50; 
  hkcdVertex *v51; 
  hkMemoryRouter *v52; 
  signed int v53; 
  int v54; 
  hknpConvexVertexShape target; 
  char v57; 
  hknpConvexVertexShape querya; 
  char v59; 

  _R14 = (const hknpConvexShape *)targetShape;
  queryInfo = queryShapeInfo;
  _RDI = targetShapeInfo;
  _RCX = query->m_shape;
  if ( (_RCX->m_flags.m_storage & 1) == 0 )
    _RCX = NULL;
  if ( (targetShape->m_flags.m_storage & 1) == 0 )
    _R14 = NULL;
  querya.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[_RCX->m_type.m_storage].m_disptach.m_storage;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+20h]
    vmovss  [rbp+40h+query.m_convexRadius], xmm0
  }
  querya.m_shape = (const hknpConvexShape *)_RCX;
  v59 = 0;
  v15 = (const hkcdVertex *)((char *)&_RCX[1].__vftable + WORD2(_RCX[1].__vftable) + 2);
  v16 = WORD1(_RCX[1].__vftable);
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v18 = (16 * (_DWORD)v16 + 127) & 0xFFFFFF80;
    m_cur = (const hkcdVertex *)Value->m_stack.m_cur;
    v20 = (char *)m_cur + v18;
    if ( (int)v18 > Value->m_stack.m_slabSize || v20 > Value->m_stack.m_end )
      m_cur = (const hkcdVertex *)hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v18);
    else
      Value->m_stack.m_cur = v20;
    __asm
    {
      vmovups xmm3, xmmword ptr [rsi+50h]
      vmovups xmm4, xmmword ptr [rsi+40h]
    }
    v23 = v16;
    if ( (_DWORD)v16 )
    {
      _RCX = m_cur;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm4, xmmword ptr [rbx+rcx]
          vaddps  xmm1, xmm3, xmm0
          vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8
          vmovups xmmword ptr [rcx], xmm0
        }
        ++_RCX;
        --v23;
      }
      while ( v23 );
    }
    v15 = m_cur;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+38h]
      vmovss  [rbp+40h+query.m_convexRadius], xmm0
    }
    v59 = 1;
  }
  querya.m_vertices = v15;
  querya.m_numVertices = v16;
  target.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[_R14->m_type.m_storage].m_disptach.m_storage;
  __asm
  {
    vmovss  xmm0, dword ptr [r14+20h]
    vmovss  [rbp+40h+var_D0.m_convexRadius], xmm0
  }
  target.m_shape = _R14;
  v57 = 0;
  v30 = (const hkcdVertex *)((char *)&_R14->m_vertices + _R14->m_vertices.m_offset);
  m_size = _R14->m_vertices.m_size;
  if ( targetShapeInfo->m_scalingInternals.m_isScaled )
  {
    v32 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v32 )
      v32 = hkMemoryRouter::s_fallbackRouter;
    v33 = (16 * (_DWORD)m_size + 127) & 0xFFFFFF80;
    v34 = (const hkcdVertex *)v32->m_stack.m_cur;
    v35 = (char *)v34 + v33;
    if ( (int)v33 > v32->m_stack.m_slabSize || v35 > v32->m_stack.m_end )
      v34 = (const hkcdVertex *)hkLifoAllocator::allocateFromNewSlab(&v32->m_stack, v33);
    else
      v32->m_stack.m_cur = v35;
    __asm
    {
      vmovups xmm3, xmmword ptr [rdi+50h]
      vmovups xmm4, xmmword ptr [rdi+40h]
    }
    v38 = m_size;
    if ( (_DWORD)m_size )
    {
      _RCX = v34;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm4, xmmword ptr [rbx+rcx]
          vaddps  xmm1, xmm3, xmm0
          vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8
          vmovups xmmword ptr [rcx], xmm0
        }
        ++_RCX;
        --v38;
      }
      while ( v38 );
    }
    v30 = v34;
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+38h]
      vmovss  [rbp+40h+var_D0.m_convexRadius], xmm0
    }
    v57 = 1;
  }
  target.m_vertices = v30;
  target.m_numVertices = m_size;
  m_dispatcher = (hknpCollisionQueryDispatcher *)queryContext->m_dispatcher;
  if ( (collector->m_hints.m_storage & 2) != 0 )
    collector->processClosestPointsCvxCvx(collector, m_dispatcher, query, &querya, &query->m_filterData, queryInfo, &target, targetShapeFilterData, targetShapeInfo, queryToTarget);
  else
    hknpCollisionQueryDispatcher::_getClosestPointsCvxCvxPreScaledImpl<hknpCollisionQueryCollector,hknpClosestPointsQuery,hknpCollisionResult>(m_dispatcher, query, &querya, &query->m_filterData, queryInfo, &target, targetShapeFilterData, targetShapeInfo, queryToTarget, collector);
  if ( v57 )
  {
    m_numVertices = target.m_numVertices;
    m_vertices = (hkcdVertex *)target.m_vertices;
    v47 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v47 )
      v47 = hkMemoryRouter::s_fallbackRouter;
    v48 = (16 * m_numVertices + 127) & 0xFFFFFF80;
    v49 = (v48 + 15) & 0xFFFFFFF0;
    if ( v48 > v47->m_stack.m_slabSize || (char *)m_vertices + v49 != v47->m_stack.m_cur || v47->m_stack.m_firstNonLifoEnd == m_vertices )
      hkLifoAllocator::slowBlockFree(&v47->m_stack, m_vertices, v49);
    else
      v47->m_stack.m_cur = m_vertices;
  }
  if ( v59 )
  {
    v50 = querya.m_numVertices;
    v51 = (hkcdVertex *)querya.m_vertices;
    v52 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v52 )
      v52 = hkMemoryRouter::s_fallbackRouter;
    v53 = (16 * v50 + 127) & 0xFFFFFF80;
    v54 = (v53 + 15) & 0xFFFFFFF0;
    if ( v53 > v52->m_stack.m_slabSize || (char *)v51 + v54 != v52->m_stack.m_cur || v52->m_stack.m_firstNonLifoEnd == v51 )
      hkLifoAllocator::slowBlockFree(&v52->m_stack, v51, v54);
    else
      v52->m_stack.m_cur = v51;
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpExternMeshShapeUtil::getClosestPointsToConvex(queryContext, query, queryShapeInfo, (const hknpExternMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpHeightFieldShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const hknpHeightFieldShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpParticlesColliderShape::getClosestPointsFromConvex(queryContext, query, queryShapeInfo, (const hknpParticlesColliderShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCollisionQueryContext *v16; 
  __int64 v19; 
  unsigned int v20; 
  bool v25; 
  __int64 v26; 
  int v27; 
  const hknpShape *v28; 
  int v31; 
  unsigned __int16 v32; 
  int v33; 
  bool m_isScaled; 
  __int64 m_size; 
  char v39; 
  __int64 m_offset; 
  __int64 v96; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  unsigned __int16 v101; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  bool v110; 
  unsigned __int16 v111; 
  signed int v112; 
  int v113; 
  const hknpShape *m_shape; 
  __int128 *v115; 
  __int128 v118; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  __int128 v121; 
  __int128 v123[2]; 

  v16 = queryContext;
  _RDI = queryShapeInfo;
  _R14 = query;
  m_shape = query->m_shape;
  v19 = *(_QWORD *)&m_shape[1].m_flags.m_storage;
  v113 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 88i64))(v19);
  v20 = 0;
  v112 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 24i64))(v19);
  if ( v113 > 0 )
  {
    __asm
    {
      vmovaps [rsp+228h+var_48], xmm6
      vmovaps [rsp+228h+var_58], xmm7
      vmovaps [rsp+228h+var_68], xmm8
      vmovaps [rsp+228h+var_78], xmm9
      vpxor   xmm0, xmm0, xmm0
      vpinsrw xmm0, xmm0, eax, 1
      vmovaps [rsp+228h+var_88], xmm10
      vpshufd xmm10, xmm0, 0
      vxorps  xmm9, xmm9, xmm9
    }
    do
    {
      (*(void (__fastcall **)(__int64, _QWORD, __int128 *))(*(_QWORD *)v19 + 96i64))(v19, v20, &v121);
      v25 = 0;
      v26 = 1i64;
      v110 = 0;
      if ( (int)v20 >= v112 )
      {
        v27 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 112i64))(v19, v20) & 7;
        v25 = v27 == 7;
        if ( v27 != 7 )
          v26 = 2i64;
        v110 = v27 == 7;
      }
      v28 = m_shape;
      _R9 = v123;
      _RBX = v16->m_targetTriangle;
      v31 = 2 * v20;
      v115 = v123;
      v32 = 0;
      v111 = 0;
      v33 = 0;
      _RBX->m_convexRadius = m_shape->m_convexRadius;
      __asm { vmovups ymm0, ymmword ptr [rdi+40h] }
      queryShapeInfoa.m_body = _RDI->m_body;
      queryShapeInfoa.m_rootShape = _RDI->m_rootShape;
      queryShapeInfoa.m_parentShape = _RDI->m_parentShape;
      queryShapeInfoa.m_shapeToWorld = _RDI->m_shapeToWorld;
      m_isScaled = _RDI->m_scalingInternals.m_isScaled;
      __asm
      {
        vmovups ymmword ptr [rsp+228h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], ymm0
        vmovss  xmm0, dword ptr [rdi+38h]
      }
      queryShapeInfoa.m_scalingInternals.m_isScaled = m_isScaled;
      queryShapeInfoa.m_scalingInternals.m_mode = _RDI->m_scalingInternals.m_mode;
      __asm { vmovss  [rsp+228h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0 }
      queryShapeInfoa.m_shapeKeyMask = NULL;
      do
      {
        m_size = _RDI->m_shapeKeyPath.m_size;
        __asm { vmovups xmm8, [rsp+228h+var_D8] }
        v39 = m_size + v28->m_numShapeKeyBits;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = _RDI->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((v33 | v31) + 1) << (32 - v39)) - 1);
        _RAX = _RBX->m_vertices.m_offset;
        _RCX = _RBX->m_planes.m_offset;
        if ( v25 )
        {
          __asm
          {
            vmovups xmm0, [rsp+228h+var_C8]
            vmovups xmm1, [rsp+228h+var_B8]
            vsubps  xmm4, xmm0, xmm8
            vsubps  xmm2, xmm1, xmm8
            vshufps xmm0, xmm2, xmm2, 0C9h ; ''
            vmulps  xmm3, xmm0, xmm4
            vshufps xmm1, xmm4, xmm4, 0C9h ; ''
            vmulps  xmm2, xmm1, xmm2
            vsubps  xmm0, xmm3, xmm2
            vshufps xmm7, xmm0, xmm0, 0C9h ; ''
            vdpps   xmm1, xmm7, xmm7, 7Fh
            vrsqrtps xmm5, xmm1
            vmulps  xmm0, xmm5, xmm1
            vmulps  xmm2, xmm0, xmm5
            vmulps  xmm0, xmm5, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
            vcmpleps xmm4, xmm1, xmm9
            vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
            vmovups xmmword ptr [rax+rbx+3Ah], xmm8
            vsubps  xmm3, xmm1, xmm2
            vmulps  xmm2, xmm3, xmm0
            vdpps   xmm6, xmm7, xmm8, 7Fh
            vsubps  xmm1, xmm9, xmm6
            vblendps xmm0, xmm7, xmm1, 8
            vandnps xmm4, xmm4, xmm2
            vmulps  xmm2, xmm4, xmm0
            vmovups xmm0, [rsp+228h+var_C8]
            vmovups xmmword ptr [rax+rbx+4Ah], xmm0
            vmovups xmm1, [rsp+228h+var_B8]
            vmovups xmmword ptr [rax+rbx+5Ah], xmm1
            vmovups xmm0, [rsp+228h+var_A8]
            vmovups xmmword ptr [rax+rbx+6Ah], xmm0
          }
          *(_DWORD *)((char *)&_RBX->m_faces.m_offset + _RAX) = 1056964608;
          *(_DWORD *)((char *)&_RBX->m_connectivity.m_ptr + _RAX + 6) = 1056964609;
          *(_DWORD *)((char *)&_RBX[1].m_propertyBag.m_bag + _RAX + 6) = 1056964610;
          *(_DWORD *)(&_RBX[1].m_dispatchType + _RAX + 2) = 1056964611;
          _RBX->m_vertices.m_size = 4;
          m_offset = _RBX->m_indices.m_offset;
          *((_BYTE *)&_RBX->m_indices.m_offset + m_offset + 1) = 3;
          *((_BYTE *)&_RBX->m_indices + m_offset + 7) = 3;
        }
        else
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [r9-10h]
            vsubps  xmm4, xmm0, xmm8
            vmovups xmm0, xmmword ptr [r9]
            vsubps  xmm2, xmm0, xmm8
            vshufps xmm1, xmm2, xmm2, 0C9h ; ''
            vmulps  xmm3, xmm1, xmm4
            vshufps xmm0, xmm4, xmm4, 0C9h ; ''
            vmulps  xmm2, xmm0, xmm2
            vsubps  xmm1, xmm3, xmm2
            vshufps xmm7, xmm1, xmm1, 0C9h ; ''
            vmovups xmm1, cs:?hkSse_floatThree@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatThree
            vdpps   xmm0, xmm7, xmm7, 7Fh
            vrsqrtps xmm5, xmm0
            vcmpleps xmm4, xmm0, xmm9
            vmulps  xmm0, xmm5, xmm0
            vmulps  xmm2, xmm0, xmm5
            vmulps  xmm0, xmm5, cs:?hkSse_floatHalf@hkMath@@3QBIB; uint const near * const hkMath::hkSse_floatHalf
            vmovups xmmword ptr [rax+rbx+3Ah], xmm8
            vsubps  xmm3, xmm1, xmm2
            vmulps  xmm2, xmm3, xmm0
            vdpps   xmm6, xmm7, xmm8, 7Fh
            vsubps  xmm1, xmm9, xmm6
            vblendps xmm0, xmm7, xmm1, 8
            vandnps xmm4, xmm4, xmm2
            vmulps  xmm2, xmm4, xmm0
            vmovups xmm0, xmmword ptr [r9-10h]
            vmovups xmmword ptr [rax+rbx+4Ah], xmm0
            vmovups xmm1, xmmword ptr [r9]
            vmovups xmmword ptr [rax+rbx+5Ah], xmm1
            vmovups xmm0, xmmword ptr [r9]
            vmovups xmmword ptr [rax+rbx+6Ah], xmm0
          }
          *(_DWORD *)((char *)&_RBX->m_faces.m_offset + _RAX) = 1056964608;
          *(_DWORD *)((char *)&_RBX->m_connectivity.m_ptr + _RAX + 6) = 1056964609;
          *(_DWORD *)((char *)&_RBX[1].m_propertyBag.m_bag + _RAX + 6) = 1056964610;
          *(_DWORD *)(&_RBX[1].m_dispatchType + _RAX + 2) = 1056964610;
          _RBX->m_vertices.m_size = 3;
          v96 = _RBX->m_indices.m_offset;
          *((_BYTE *)&_RBX->m_indices.m_offset + v96 + 1) = 0;
          *((_BYTE *)&_RBX->m_indices + v96 + 7) = 0;
        }
        __asm
        {
          vinsertf128 ymm2, ymm2, xmm2, 1
          vmovups xmmword ptr [rcx+rbx+40h], xmm2
          vxorps  xmm0, xmm2, xmm10
          vmovups xmmword ptr [rcx+rbx+50h], xmm0
          vmovups ymmword ptr [rcx+rbx+60h], ymm2
          vmovups ymm1, ymmword ptr [r14+20h]
        }
        m_shapeTagCodec = _R14->m_shapeTagCodec;
        __asm
        {
          vmovups ymm0, ymmword ptr [r14]
          vmovups ymmword ptr [rsp+228h+query.baseclass_0.m_levelOfDetail], ymm1
        }
        querya.m_shape = _RBX;
        __asm { vmovups ymmword ptr [rsp+228h+query.baseclass_0.m_shapeTagCodec], ymm0 }
        if ( m_shapeTagCodec )
        {
          if ( !v33 )
          {
            v101 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 104i64))(v19, v20);
            m_shapeTagCodec = _R14->m_shapeTagCodec;
            v32 = v101;
            v111 = v101;
          }
          __asm { vmovups xmm0, xmmword ptr [rsp+228h+query.baseclass_0.m_filterData.m_materialId.baseclass_0.m_value] }
          m_body = _RDI->m_body;
          m_rootShape = _RDI->m_rootShape;
          __asm { vmovups [rsp+228h+var_188], xmm0 }
          ((void (__fastcall *)(const hknpShapeTagCodec *, _QWORD, __int64, const hknpBody *, const hknpShape *, const hknpShape *, unsigned int, hknpTriangleShape *, __int128 *))m_shapeTagCodec->decode)(m_shapeTagCodec, v32, 4i64, m_body, m_rootShape, m_shape, queryShapeInfoa.m_shapeKeyPath.m_key.m_value, _RBX, &v118);
          querya.m_filterData.m_collisionFilterInfo = DWORD1(v118);
          querya.m_filterData.m_materialId.m_value = v118;
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
        v31 = 2 * v20;
        v32 = v111;
        _R9 = v115 + 1;
        v28 = m_shape;
        ++v33;
        v25 = v110;
        ++v115;
        --v26;
      }
      while ( v26 );
      v16 = queryContext;
      ++v20;
    }
    while ( (int)v20 < v113 );
    __asm
    {
      vmovaps xmm10, [rsp+228h+var_88]
      vmovaps xmm9, [rsp+228h+var_78]
      vmovaps xmm8, [rsp+228h+var_68]
      vmovaps xmm7, [rsp+228h+var_58]
      vmovaps xmm6, [rsp+228h+var_48]
    }
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToHeightfield(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpHeightFieldShape::getClosestPointsToHeightfieldImpl(queryContext, query, queryShapeInfo, (const hknpHeightFieldShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable
==============
*/
void HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(HavokPhysics_CollisionQueryDispatcher *this, unsigned int shapeMask)
{
  int v2; 
  hknpCollisionQueryDispatcher::DispatchTable<void (__cdecl*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)> *p_m_closestPointsDispatchTable; 
  int v5; 
  int v6; 
  int v7; 

  v2 = 0;
  p_m_closestPointsDispatchTable = &this->m_closestPointsDispatchTable;
  if ( (shapeMask & 1) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, NOP, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex, "convexVsConvex", shapeMask, 0);
  if ( (shapeMask & 0x201) == 513 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh, "convexVsCompressedMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsCompressedMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x401) == 1025 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh, "convexVsExternMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsExternMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1001) == 4097 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound, "convexVsCompound", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsCompound>", shapeMask, 0);
  }
  if ( (shapeMask & 0x4001) == 16385 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField, "convexVsHeightField", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsHeightField>", shapeMask, 0);
  }
  if ( (shapeMask & 0x10001) == 65537 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem, "convexVsParticleSystem", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsParticleSystem>", shapeMask, 0);
  }
  if ( (shapeMask & 0x500) == 1280 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape, "externMeshVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<externMeshVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x8400) == 33792 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, USER_6, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape, "externMeshVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_6, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<externMeshVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x200) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh, "compressedMeshVsCompressedMesh", shapeMask, 0);
  if ( (shapeMask & 0x4000) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield, "heightFieldVsHeightfield", shapeMask, 0);
  if ( (shapeMask & 0x4200) == 16896 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh, "heightFieldVsCompressedMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<heightFieldVsCompressedMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1100) == 4352 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape, "compoundVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<compoundVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1000) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound, "compoundVsCompound", shapeMask, 0);
  if ( (shapeMask & 0x10100) == 65792 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape, "particlesVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<particlesVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x11000) == 69632 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape, "particlesVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<particlesVsShape>", shapeMask, 0);
  }
  do
  {
    v5 = (1 << v2) | 0x20000;
    if ( (shapeMask & v5) == v5 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NUM_TYPES, (hknpShapeType::Enum)v2, unwrapScaledConvex<0>, "ScaledQuery", shapeMask, 0);
      if ( (shapeMask & v5) == v5 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, NUM_TYPES, unwrapScaledConvex<1>, "ScaledTarget", shapeMask, 0);
    }
    v6 = (1 << v2) | 0x40000;
    if ( (shapeMask & v6) == v6 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|GSK, (hknpShapeType::Enum)v2, unwrapMaskedShape<0>, "UnwrapMaskedQuery", shapeMask, 0);
      if ( (shapeMask & v6) == v6 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, USER_7|GSK, unwrapMaskedShape<1>, "UnwrapMaskedTarget", shapeMask, 0);
    }
    v7 = (1 << v2) | 0x100000;
    if ( (shapeMask & v7) == v7 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|CONVEX_COMPOSITE, (hknpShapeType::Enum)v2, unwrapLodShape<0>, "LodQuery", shapeMask, 0);
      if ( (shapeMask & v7) == v7 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, USER_7|CONVEX_COMPOSITE, unwrapLodShape<1>, "LodTarget", shapeMask, 0);
    }
    ++v2;
  }
  while ( v2 < 30 );
  if ( (shapeMask & 0x40000) == 0x40000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|GSK, USER_7|GSK, unwrapMaskedShape<2>, "UnwrapQueryAndTarget", shapeMask, 0);
  if ( (shapeMask & 0x100000) == 0x100000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|CONVEX_COMPOSITE, USER_7|CONVEX_COMPOSITE, unwrapLodShape<2>, "LodQueryAndTarget", shapeMask, 0);
  if ( (shapeMask & 0x20000) == 0x20000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NUM_TYPES, NUM_TYPES, unwrapScaledConvex<2>, "ScaleQueryAndTarget", shapeMask, 0);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 v12; 
  __int64 v13; 
  __int64 v16; 
  signed int v17; 
  __int64 v18; 
  signed int v19; 
  int v28; 
  __int64 v31; 
  int v32; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf v37; 
  void (__fastcall *const *v38)(); 
  __int64 v39; 
  hknpSphereShape *v40; 
  int v41; 
  hknpSphereShape v42[2]; 
  hkTransformf v43; 

  _R12 = queryShapeInfo;
  _R13 = query;
  v12 = *(_QWORD *)&query->m_shape[1].m_memSizeAndFlags;
  if ( *(_BYTE *)(v12 + 5504) )
  {
    v13 = 0i64;
    v39 = 0i64;
    v40 = v42;
    v41 = 128;
    v38 = hknpInplaceShapeBuffer<128>::`vftable';
    _R15 = NULL;
    if ( *(_DWORD *)query->m_levelOfDetail == 3 )
    {
      __asm { vxorps  xmm2, xmm2, xmm2; radius }
      hknpSphereShape::hknpSphereShape(v42, (const hkVector4f *)&g_vectorfConstants[5], *(float *)&_XMM2);
      v13 = v16;
      *(_WORD *)(v16 + 16) = 0;
      v39 = v16;
      _R15 = (const hknpShape *)v16;
    }
    v17 = 0;
    v32 = *(_DWORD *)(v12 + 5492);
    if ( v32 )
    {
      v18 = 0i64;
      do
      {
        if ( *(_BYTE *)(v12 + 5696) )
          v19 = *(_DWORD *)(v18 + *(_QWORD *)(v12 + 5728));
        else
          v19 = v17;
        _RAX = *(_QWORD *)(v12 + 304) + 32i64 * v19;
        __asm
        {
          vmovups xmm0, xmmword ptr [rax]
          vmovups [rsp+2A8h+var_138], xmm0
        }
        if ( *(_BYTE *)(v12 + 5500) )
        {
          hkRotationImpl<float>::set(&v37.m_rotation, (const hkQuaternionf *)(*(_QWORD *)(v12 + 320) + 16i64 * v19));
        }
        else
        {
          __asm
          {
            vmovups ymm0, ymmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+200h; __m128 const near * const g_vectorfConstants
            vmovups ymmword ptr [rsp+2A8h+var_168.baseclass_0.m_col0.m_quad], ymm0
            vmovups xmm0, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+220h; __m128 const near * const g_vectorfConstants
            vmovups xmmword ptr [rsp+2A8h+var_168.baseclass_0.m_col2.m_quad], xmm0
          }
        }
        queryShapeInfoa.m_body = _R12->m_body;
        queryShapeInfoa.m_rootShape = _R12->m_rootShape;
        queryShapeInfoa.m_shapeKeyMask = NULL;
        queryShapeInfoa.m_scalingInternals.m_isScaled = _R12->m_scalingInternals.m_isScaled;
        queryShapeInfoa.m_scalingInternals.m_mode = _R12->m_scalingInternals.m_mode;
        __asm
        {
          vmovups ymm0, ymmword ptr [r12+40h]
          vmovups ymmword ptr [rsp+2A8h+queryShapeInfo.m_scalingInternals.m_scale.m_quad], ymm0
          vmovss  xmm0, dword ptr [r12+38h]
          vmovss  [rsp+2A8h+queryShapeInfo.m_scalingInternals.m_convexRadius], xmm0
        }
        queryShapeInfoa.m_parentShape = _R13->m_shape;
        queryShapeInfoa.m_shapeToWorld = &v37;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v19;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        hkTransformf::setMul(&v43, queryToTarget, &v37);
        __asm
        {
          vmovups ymm0, ymmword ptr [r13+0]
          vmovups ymmword ptr [rsp+2A8h+query.baseclass_0.m_shapeTagCodec], ymm0
          vmovups ymm1, ymmword ptr [r13+20h]
          vmovups ymmword ptr [rsp+2A8h+query.baseclass_0.m_levelOfDetail], ymm1
        }
        if ( *(_DWORD *)_R13->m_levelOfDetail == 3 )
        {
          if ( *(_DWORD *)(v12 + 48) )
            v28 = *(_DWORD *)(v19 * *(_DWORD *)(v12 + 52) + *(_QWORD *)(v12 + 40));
          else
            v28 = *(_DWORD *)(v12 + 32);
          _RCX = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 24) + 24i64) + 8i64 * v28);
          __asm
          {
            vmovups xmm0, xmmword ptr [rcx+20h]
            vmovss  dword ptr [r15+20h], xmm0
          }
          querya.m_shape = _R15;
        }
        else
        {
          if ( *(_DWORD *)(v12 + 48) )
            v31 = *(int *)(v19 * *(_DWORD *)(v12 + 52) + *(_QWORD *)(v12 + 40));
          else
            v31 = *(int *)(v12 + 32);
          querya.m_shape = *(const hknpShape **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 24) + 24i64) + 8 * v31) + 240i64);
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v43, queryAndTargetSwapped, collector);
        ++v17;
        v18 += 4i64;
      }
      while ( v17 != v32 );
      v13 = v39;
    }
    v38 = hknpShapeBuffer::`vftable';
    if ( v13 )
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 8i64))(v13, 0i64);
  }
}

