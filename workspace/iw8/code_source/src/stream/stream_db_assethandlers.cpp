/*
==============
Stream_DBAllocMaterial
==============
*/

void __fastcall Stream_DBAllocMaterial(Material *material)
{
  ?Stream_DBAllocMaterial@@YAXPEAUMaterial@@@Z(material);
}

/*
==============
Stream_DBPreMoveMesh
==============
*/

void __fastcall Stream_DBPreMoveMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh, bool toMeshOwnsResources)
{
  ?Stream_DBPreMoveMesh@@YAXPEAUXModelSurfs@@0_N@Z(fromMesh, toMesh, toMeshOwnsResources);
}

/*
==============
Stream_DBPreReleaseMesh
==============
*/

void __fastcall Stream_DBPreReleaseMesh(XModelSurfs *mesh)
{
  ?Stream_DBPreReleaseMesh@@YAXPEAUXModelSurfs@@@Z(mesh);
}

/*
==============
Stream_DBPreMoveImage
==============
*/

bool __fastcall Stream_DBPreMoveImage(GfxImage *fromImage, GfxImage *toImage, bool toImageOwnsResources)
{
  return ?Stream_DBPreMoveImage@@YA_NPEAUGfxImage@@0_N@Z(fromImage, toImage, toImageOwnsResources);
}

/*
==============
Stream_DBPreMoveStreamKey
==============
*/

void __fastcall Stream_DBPreMoveStreamKey(StreamKey *fromKey, StreamKey *toKey, bool toStreamKeyOwnsResources)
{
  ?Stream_DBPreMoveStreamKey@@YAXPEAUStreamKey@@0_N@Z(fromKey, toKey, toStreamKeyOwnsResources);
}

/*
==============
Stream_DBCreateXModel
==============
*/

void __fastcall Stream_DBCreateXModel(XModel *model)
{
  ?Stream_DBCreateXModel@@YAXPEAUXModel@@@Z(model);
}

/*
==============
Stream_DBFreeMaterial
==============
*/

void __fastcall Stream_DBFreeMaterial(Material *material)
{
  ?Stream_DBFreeMaterial@@YAXPEAUMaterial@@@Z(material);
}

/*
==============
Stream_DBPreReleaseImage
==============
*/

void __fastcall Stream_DBPreReleaseImage(GfxImage *image)
{
  ?Stream_DBPreReleaseImage@@YAXPEAUGfxImage@@@Z(image);
}

/*
==============
Stream_DBPreSwapImage
==============
*/

void __fastcall Stream_DBPreSwapImage(GfxImage *fromImage, GfxImage *toImage)
{
  ?Stream_DBPreSwapImage@@YAXPEAUGfxImage@@0@Z(fromImage, toImage);
}

/*
==============
Stream_DBPostCopyMaterial
==============
*/

void __fastcall Stream_DBPostCopyMaterial(Material *fromMaterial, Material *toMaterial)
{
  ?Stream_DBPostCopyMaterial@@YAXPEAUMaterial@@0@Z(fromMaterial, toMaterial);
}

/*
==============
Stream_DBCreateMaterial
==============
*/

void __fastcall Stream_DBCreateMaterial(Material *material)
{
  ?Stream_DBCreateMaterial@@YAXPEAUMaterial@@@Z(material);
}

/*
==============
Stream_DBCreateImage
==============
*/

void __fastcall Stream_DBCreateImage(GfxImage *image)
{
  ?Stream_DBCreateImage@@YAXPEAUGfxImage@@@Z(image);
}

/*
==============
Stream_DBPreSwapStreamKey
==============
*/

void __fastcall Stream_DBPreSwapStreamKey(StreamKey *fromKey, StreamKey *toKey)
{
  ?Stream_DBPreSwapStreamKey@@YAXPEAUStreamKey@@0@Z(fromKey, toKey);
}

/*
==============
Stream_DBPreReleaseStreamKey
==============
*/

void __fastcall Stream_DBPreReleaseStreamKey(StreamKey *key)
{
  ?Stream_DBPreReleaseStreamKey@@YAXPEAUStreamKey@@@Z(key);
}

/*
==============
Stream_DBPreSwapXModel
==============
*/

void __fastcall Stream_DBPreSwapXModel(XModel *fromModel, XModel *toModel)
{
  ?Stream_DBPreSwapXModel@@YAXPEAUXModel@@0@Z(fromModel, toModel);
}

/*
==============
Stream_DBCreateStreamKey
==============
*/

void __fastcall Stream_DBCreateStreamKey(StreamKey *key)
{
  ?Stream_DBCreateStreamKey@@YAXPEAUStreamKey@@@Z(key);
}

/*
==============
Stream_DBPreReleaseMaterial
==============
*/

void __fastcall Stream_DBPreReleaseMaterial(Material *material)
{
  ?Stream_DBPreReleaseMaterial@@YAXPEAUMaterial@@@Z(material);
}

/*
==============
Stream_DBPreMoveMaterial
==============
*/

void __fastcall Stream_DBPreMoveMaterial(Material *fromMaterial, Material *toMaterial)
{
  ?Stream_DBPreMoveMaterial@@YAXPEAUMaterial@@0@Z(fromMaterial, toMaterial);
}

/*
==============
Stream_DBPreMoveXModel
==============
*/

void __fastcall Stream_DBPreMoveXModel(XModel *fromModel, XModel *toModel)
{
  ?Stream_DBPreMoveXModel@@YAXPEAUXModel@@0@Z(fromModel, toModel);
}

/*
==============
Stream_DBCreateMesh
==============
*/

void __fastcall Stream_DBCreateMesh(XModelSurfs *mesh)
{
  ?Stream_DBCreateMesh@@YAXPEAUXModelSurfs@@@Z(mesh);
}

/*
==============
Stream_DBPreSwapMaterial
==============
*/

void __fastcall Stream_DBPreSwapMaterial(Material *fromMaterial, Material *toMaterial)
{
  ?Stream_DBPreSwapMaterial@@YAXPEAUMaterial@@0@Z(fromMaterial, toMaterial);
}

/*
==============
Stream_DBPostCopyXModel
==============
*/

void __fastcall Stream_DBPostCopyXModel(XModel *fromModel, XModel *toModel)
{
  ?Stream_DBPostCopyXModel@@YAXPEAUXModel@@0@Z(fromModel, toModel);
}

/*
==============
Stream_DBFreeModel
==============
*/

void __fastcall Stream_DBFreeModel(XModel *model)
{
  ?Stream_DBFreeModel@@YAXPEAUXModel@@@Z(model);
}

/*
==============
Stream_DBPostCopyMesh
==============
*/

void __fastcall Stream_DBPostCopyMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh)
{
  ?Stream_DBPostCopyMesh@@YAXPEAUXModelSurfs@@0@Z(fromMesh, toMesh);
}

/*
==============
Stream_DBPreReleaseXModel
==============
*/

void __fastcall Stream_DBPreReleaseXModel(XModel *model)
{
  ?Stream_DBPreReleaseXModel@@YAXPEAUXModel@@@Z(model);
}

/*
==============
Stream_DBPostCopyStreamKey
==============
*/

void __fastcall Stream_DBPostCopyStreamKey(StreamKey *fromKey, StreamKey *toKey)
{
  ?Stream_DBPostCopyStreamKey@@YAXPEAUStreamKey@@0@Z(fromKey, toKey);
}

/*
==============
Stream_DBPostCopyImage
==============
*/

void __fastcall Stream_DBPostCopyImage(GfxImage *fromImage, GfxImage *toImage)
{
  ?Stream_DBPostCopyImage@@YAXPEAUGfxImage@@0@Z(fromImage, toImage);
}

/*
==============
Stream_DBAllocModel
==============
*/

void __fastcall Stream_DBAllocModel(XModel *model)
{
  ?Stream_DBAllocModel@@YAXPEAUXModel@@@Z(model);
}

/*
==============
Stream_DBPreSwapMesh
==============
*/

void __fastcall Stream_DBPreSwapMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh)
{
  ?Stream_DBPreSwapMesh@@YAXPEAUXModelSurfs@@0@Z(fromMesh, toMesh);
}

/*
==============
Stream_DBAllocMaterial
==============
*/
void Stream_DBAllocMaterial(Material *material)
{
  const char *CurrentThreadContextName; 
  unsigned int MaterialIndex; 

  if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 769, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && !Sys_IsServerThread() )
  {
    CurrentThreadContextName = Sys_GetCurrentThreadContextName();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 745, ASSERT_TYPE_ASSERT, "( ( Sys_IsMainThread() || Sys_IsDatabaseThread() || Sys_IsServerThread() ) )", "( Sys_GetCurrentThreadContextName() ) = %s", CurrentThreadContextName) )
      __debugbreak();
  }
  MaterialIndex = DB_GetMaterialIndex(material);
  Stream_CombineTables_MaterialAdded(MaterialIndex);
}

/*
==============
Stream_DBAllocModel
==============
*/
void Stream_DBAllocModel(XModel *model)
{
  const char *CurrentThreadContextName; 
  unsigned int XModelIndex; 

  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 751, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && !Sys_IsServerThread() )
  {
    CurrentThreadContextName = Sys_GetCurrentThreadContextName();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 745, ASSERT_TYPE_ASSERT, "( ( Sys_IsMainThread() || Sys_IsDatabaseThread() || Sys_IsServerThread() ) )", "( Sys_GetCurrentThreadContextName() ) = %s", CurrentThreadContextName) )
      __debugbreak();
  }
  XModelIndex = DB_GetXModelIndex(model);
  Stream_CombineTables_ModelAdded(XModelIndex);
}

/*
==============
Stream_DBCreateImage
==============
*/
void Stream_DBCreateImage(GfxImage *image)
{
  unsigned int GfxImageIndex; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 34, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !image && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 35, ASSERT_TYPE_ASSERT, "(image)", (const char *)&queryFormat, "image") )
    __debugbreak();
  GfxImageIndex = DB_GetGfxImageIndex(image);
  Stream_ImageRecord_RegisterTracking(GfxImageIndex, image);
  if ( (image->flags & 0x40) != 0 )
  {
    if ( DB_IsDoingStreamOnlyWork() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 44, ASSERT_TYPE_ASSERT, "( !DB_IsDoingStreamOnlyWork() )", "transients shouldn't contain streamed images as that's not supported by the streamer!") )
      __debugbreak();
    XPak_MarkEntryInfoAsStale();
  }
  else
  {
    Stream_ImageRecord_SetImageDistanceNotStreamed(GfxImageIndex);
  }
}

/*
==============
Stream_DBCreateMaterial
==============
*/
void Stream_DBCreateMaterial(Material *material)
{
  unsigned int MaterialIndex; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 857, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !material )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 858, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
      __debugbreak();
  }
  if ( (material->runtimeFlags & 0x10) != 0 )
  {
    if ( DB_IsDoingStreamOnlyWork() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 862, ASSERT_TYPE_ASSERT, "( !DB_IsDoingStreamOnlyWork() )", "transients shouldn't contain streamed materials as that's not supported by the streamer!") )
      __debugbreak();
    MaterialIndex = DB_GetMaterialIndex(material);
    Stream_CombineTables_MarkMaterialImageTableAsStale(MaterialIndex);
  }
}

/*
==============
Stream_DBCreateMesh
==============
*/
void Stream_DBCreateMesh(XModelSurfs *mesh)
{
  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 366, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !mesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 367, ASSERT_TYPE_ASSERT, "(mesh)", (const char *)&queryFormat, "mesh") )
    __debugbreak();
  if ( !mesh->shared && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 368, ASSERT_TYPE_ASSERT, "(mesh->shared)", (const char *)&queryFormat, "mesh->shared") )
    __debugbreak();
  if ( XModelSurfs_IsStreamed(mesh) )
  {
    if ( DB_IsDoingStreamOnlyWork() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 372, ASSERT_TYPE_ASSERT, "( !DB_IsDoingStreamOnlyWork() )", "transients shouldn't contain streamed meshes as that's not supported by the streamer!") )
      __debugbreak();
    if ( mesh->shared->data.streamedDataHandle.data )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 373, ASSERT_TYPE_ASSERT, "(mesh->shared->data.streamedDataHandle.data == 0)", (const char *)&queryFormat, "mesh->shared->data.streamedDataHandle.data == 0") )
        __debugbreak();
    }
    XPak_MarkEntryInfoAsStale();
  }
}

/*
==============
Stream_DBCreateStreamKey
==============
*/
void Stream_DBCreateStreamKey(StreamKey *key)
{
  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 566, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 567, ASSERT_TYPE_ASSERT, "(key)", (const char *)&queryFormat, "key") )
    __debugbreak();
  if ( key->dataSize && (key->flags & 2) == 0 )
  {
    if ( DB_IsDoingStreamOnlyWork() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 571, ASSERT_TYPE_ASSERT, "( !DB_IsDoingStreamOnlyWork() )", "transients shouldn't contain streamed streamkey assets as that's not supported by the streamer!") )
      __debugbreak();
    if ( key->data.dataHandle.data )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 572, ASSERT_TYPE_ASSERT, "(key->data.dataHandle.data == 0)", (const char *)&queryFormat, "key->data.dataHandle.data == 0") )
        __debugbreak();
    }
    XPak_MarkEntryInfoAsStale();
  }
}

/*
==============
Stream_DBCreateXModel
==============
*/
void Stream_DBCreateXModel(XModel *model)
{
  unsigned int XModelIndex; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 787, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 788, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  if ( XModelHasMaterialsWithStreamedImages(model) )
  {
    XModelIndex = DB_GetXModelIndex(model);
    Stream_CombineTables_MarkModelMaterialTableAsStale(XModelIndex);
  }
}

/*
==============
Stream_DBFreeMaterial
==============
*/
void Stream_DBFreeMaterial(Material *material)
{
  unsigned int MaterialIndex; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 778, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 779, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  MaterialIndex = DB_GetMaterialIndex(material);
  Stream_CombineTables_MaterialRemoved(MaterialIndex);
}

/*
==============
Stream_DBFreeModel
==============
*/
void Stream_DBFreeModel(XModel *model)
{
  unsigned int XModelIndex; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 760, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 761, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  XModelIndex = DB_GetXModelIndex(model);
  Stream_CombineTables_ModelRemoved(XModelIndex);
}

/*
==============
Stream_DBPostCopyImage
==============
*/
void Stream_DBPostCopyImage(GfxImage *fromImage, GfxImage *toImage)
{
  unsigned int GfxImageIndex; 
  unsigned int v5; 

  if ( !fromImage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 332, ASSERT_TYPE_ASSERT, "(fromImage)", (const char *)&queryFormat, "fromImage") )
    __debugbreak();
  if ( !toImage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 333, ASSERT_TYPE_ASSERT, "(toImage)", (const char *)&queryFormat, "toImage") )
    __debugbreak();
  GfxImageIndex = DB_GetGfxImageIndex(fromImage);
  Stream_ImageRecord_CopyCheck(GfxImageIndex);
  v5 = DB_GetGfxImageIndex(toImage);
  Stream_ImageRecord_RegisterTracking(v5, fromImage);
  if ( (fromImage->flags & 0x40) != 0 )
  {
    if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 345, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
      __debugbreak();
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 346, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    fromImage->pixels.streamedDataHandle.data = 0i64;
    XPak_MarkEntryInfoAsStale();
  }
  else
  {
    Stream_ImageRecord_SetImageDistanceNotStreamed(v5);
  }
  Stream_ImageRecord_CopyCheck(v5);
}

/*
==============
Stream_DBPostCopyMaterial
==============
*/
void Stream_DBPostCopyMaterial(Material *fromMaterial, Material *toMaterial)
{
  unsigned int MaterialIndex; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 916, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 917, ASSERT_TYPE_ASSERT, "(fromMaterial)", (const char *)&queryFormat, "fromMaterial") )
    __debugbreak();
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 918, ASSERT_TYPE_ASSERT, "(toMaterial)", (const char *)&queryFormat, "toMaterial") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (fromMaterial->runtimeFlags & 0x10) != 0 )
    goto LABEL_19;
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (toMaterial->runtimeFlags & 0x10) != 0 )
  {
LABEL_19:
    MaterialIndex = DB_GetMaterialIndex(toMaterial);
    Stream_CombineTables_MarkMaterialImageTableAsStale(MaterialIndex);
  }
}

/*
==============
Stream_DBPostCopyMesh
==============
*/
void Stream_DBPostCopyMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh)
{
  if ( !fromMesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 550, ASSERT_TYPE_ASSERT, "(fromMesh)", (const char *)&queryFormat, "fromMesh") )
    __debugbreak();
  if ( !toMesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 551, ASSERT_TYPE_ASSERT, "(toMesh)", (const char *)&queryFormat, "toMesh") )
    __debugbreak();
  if ( XModelSurfs_IsStreamed(fromMesh) )
  {
    if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 555, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
      __debugbreak();
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 556, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    fromMesh->shared->data.streamedDataHandle.data = 0i64;
    XPak_MarkEntryInfoAsStale();
  }
}

/*
==============
Stream_DBPostCopyStreamKey
==============
*/
void Stream_DBPostCopyStreamKey(StreamKey *fromKey, StreamKey *toKey)
{
  if ( !fromKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 727, ASSERT_TYPE_ASSERT, "(fromKey)", (const char *)&queryFormat, "fromKey") )
    __debugbreak();
  if ( !toKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 728, ASSERT_TYPE_ASSERT, "(toKey)", (const char *)&queryFormat, "toKey") )
    __debugbreak();
  if ( fromKey->dataSize && (fromKey->flags & 2) == 0 )
  {
    if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 732, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
      __debugbreak();
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 733, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    fromKey->data.dataHandle.data = 0i64;
    XPak_MarkEntryInfoAsStale();
  }
}

/*
==============
Stream_DBPostCopyXModel
==============
*/
void Stream_DBPostCopyXModel(XModel *fromModel, XModel *toModel)
{
  const char *CurrentThreadContextName; 
  unsigned int XModelIndex; 

  if ( !fromModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 844, ASSERT_TYPE_ASSERT, "(fromModel)", (const char *)&queryFormat, "fromModel") )
    __debugbreak();
  if ( !toModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 845, ASSERT_TYPE_ASSERT, "(toModel)", (const char *)&queryFormat, "toModel") )
    __debugbreak();
  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && !Sys_IsServerThread() )
  {
    CurrentThreadContextName = Sys_GetCurrentThreadContextName();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 745, ASSERT_TYPE_ASSERT, "( ( Sys_IsMainThread() || Sys_IsDatabaseThread() || Sys_IsServerThread() ) )", "( Sys_GetCurrentThreadContextName() ) = %s", CurrentThreadContextName) )
      __debugbreak();
  }
  if ( XModelHasMaterialsWithStreamedImages(fromModel) || XModelHasMaterialsWithStreamedImages(toModel) )
  {
    XModelIndex = DB_GetXModelIndex(toModel);
    Stream_CombineTables_MarkModelMaterialTableAsStale(XModelIndex);
  }
}

/*
==============
Stream_DBPreMoveImage
==============
*/
char Stream_DBPreMoveImage(GfxImage *fromImage, GfxImage *toImage, bool toImageOwnsResources)
{
  char v3; 
  unsigned int GfxImageIndex; 
  unsigned int v7; 
  __int64 v8; 
  unsigned __int8 streamedPartCount; 
  unsigned __int8 v10; 
  int v11; 
  _BYTE *v12; 
  signed __int64 v13; 
  GfxImageFallback *fallback; 
  GfxImageFallback *v15; 
  unsigned __int64 data; 
  __int64 v28; 
  unsigned int *v29; 
  unsigned int *v30; 
  unsigned int v31; 
  __int64 v32; 
  __int64 v33; 
  StreamFrontendGlob *v34; 
  StreamFrontendGlob *v35; 
  unsigned int v36; 
  __int64 v37; 
  __int64 v38; 
  StreamableBits::BitSwap::__l2::<lambda_0cfe52a449506a58f3f65a204b9daded> v39; 
  ScopedCriticalSection v40; 
  unsigned int v41; 
  unsigned int v42; 
  bool v43; 
  unsigned int v44; 

  v43 = toImageOwnsResources;
  v3 = toImageOwnsResources;
  _RDI = toImage;
  _RBX = fromImage;
  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 186, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 187, ASSERT_TYPE_ASSERT, "(fromImage)", (const char *)&queryFormat, "fromImage") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 188, ASSERT_TYPE_ASSERT, "(toImage)", (const char *)&queryFormat, "toImage") )
    __debugbreak();
  XPak_CheckAdjacencyInfo(_RBX);
  XPak_CheckAdjacencyInfo(_RDI);
  GfxImageIndex = DB_GetGfxImageIndex(_RBX);
  v41 = GfxImageIndex;
  v7 = DB_GetGfxImageIndex(_RDI);
  v8 = v7;
  Stream_ImageRecord_MoveTracking(GfxImageIndex, v7);
  if ( !g_usedDebugZone && (_RDI->flags & 0x40) != 0 && (_RBX->flags & 0x40) != 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 205, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 206, ASSERT_TYPE_ASSERT, "(toImageOwnsResources)", (const char *)&queryFormat, "toImageOwnsResources") )
      __debugbreak();
    streamedPartCount = _RDI->streamedPartCount;
    v10 = _RBX->streamedPartCount;
    if ( streamedPartCount == v10 )
    {
      v11 = 0;
      if ( streamedPartCount )
      {
        v12 = (char *)&_RBX->streams[0].xpakEntry + 24;
        v13 = (char *)_RDI - (char *)_RBX;
        while ( *((_QWORD *)v12 - 3) == *(_QWORD *)&v12[v13 - 24] )
        {
          if ( *v12 != v12[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 227, ASSERT_TYPE_ASSERT, "(fromXPakEntry.xpakIndex == toXPakEntry.xpakIndex)", (const char *)&queryFormat, "fromXPakEntry.xpakIndex == toXPakEntry.xpakIndex") )
            __debugbreak();
          if ( *((_QWORD *)v12 - 2) != *(_QWORD *)&v12[v13 - 16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 228, ASSERT_TYPE_ASSERT, "(fromXPakEntry.offset == toXPakEntry.offset)", (const char *)&queryFormat, "fromXPakEntry.offset == toXPakEntry.offset") )
            __debugbreak();
          if ( *((_QWORD *)v12 - 1) != *(_QWORD *)&v12[v13 - 8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 229, ASSERT_TYPE_ASSERT, "(fromXPakEntry.size == toXPakEntry.size)", (const char *)&queryFormat, "fromXPakEntry.size == toXPakEntry.size") )
            __debugbreak();
          if ( streamFrontendGlob->imageXPakPosition[4 * v41 + v11] != streamFrontendGlob->imageXPakPosition[(unsigned int)(v11 + 4 * v8)] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 234, ASSERT_TYPE_ASSERT, "(streamFrontendGlob->imageXPakPosition[fromPartIndex] == streamFrontendGlob->imageXPakPosition[toPartIndex])", (const char *)&queryFormat, "streamFrontendGlob->imageXPakPosition[fromPartIndex] == streamFrontendGlob->imageXPakPosition[toPartIndex]") )
            __debugbreak();
          ++v11;
          v12 += 40;
          if ( v11 >= _RDI->streamedPartCount )
            goto LABEL_37;
        }
      }
      else
      {
LABEL_37:
        if ( streamedPartCount == v10 )
        {
          if ( _RDI->flags != _RBX->flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 241, ASSERT_TYPE_ASSERT, "( toImage->flags ) == ( fromImage->flags )", "%s == %s\n\t%u, %u", "toImage->flags", "fromImage->flags", _RDI->flags, _RBX->flags) )
            __debugbreak();
          if ( _RDI->fallback )
          {
            if ( !_RBX->fallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 256, ASSERT_TYPE_ASSERT, "(fromImage->fallback)", (const char *)&queryFormat, "fromImage->fallback") )
              __debugbreak();
            fallback = _RDI->fallback;
            v15 = _RBX->fallback;
            if ( fallback->pixels == v15->pixels && *(_QWORD *)&fallback->size == *(_QWORD *)&v15->size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 257, ASSERT_TYPE_ASSERT, "(memcmp( toImage->fallback, fromImage->fallback, sizeof( GfxImageFallback ) ))", (const char *)&queryFormat, "memcmp( toImage->fallback, fromImage->fallback, sizeof( GfxImageFallback ) )") )
              __debugbreak();
            R_Texture_ResetFallback(_RDI, _RBX->fallback);
          }
          else if ( _RBX->fallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 267, ASSERT_TYPE_ASSERT, "(nullptr == fromImage->fallback)", (const char *)&queryFormat, "nullptr == fromImage->fallback") )
          {
            __debugbreak();
          }
          Stream_DBPreReleaseImage(_RBX);
          __asm
          {
            vmovups xmm0, xmmword ptr [rdi+38h]
            vmovups xmmword ptr [rbx+38h], xmm0
            vmovups xmm1, xmmword ptr [rdi+48h]
            vmovups xmmword ptr [rbx+48h], xmm1
            vmovups xmm0, xmmword ptr [rdi+58h]
            vmovups xmmword ptr [rbx+58h], xmm0
            vmovups xmm1, xmmword ptr [rdi+68h]
            vmovups xmmword ptr [rbx+68h], xmm1
            vmovups xmm0, xmmword ptr [rdi+78h]
            vmovups xmmword ptr [rbx+78h], xmm0
            vmovups xmm1, xmmword ptr [rdi+88h]
            vmovups xmmword ptr [rbx+88h], xmm1
            vmovups xmm0, xmmword ptr [rdi+98h]
            vmovups xmmword ptr [rbx+98h], xmm0
            vmovups xmm0, xmmword ptr [rdi+0A8h]
            vmovups xmmword ptr [rbx+0A8h], xmm0
            vmovups xmm1, xmmword ptr [rdi+0B8h]
            vmovups xmmword ptr [rbx+0B8h], xmm1
            vmovups xmm0, xmmword ptr [rdi+0C8h]
            vmovups xmmword ptr [rbx+0C8h], xmm0
          }
          if ( _RBX->pixels.streamedDataHandle.data )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 281, ASSERT_TYPE_ASSERT, "(fromImage->pixels.streamedDataHandle.data == 0)", (const char *)&queryFormat, "fromImage->pixels.streamedDataHandle.data == 0") )
              __debugbreak();
          }
          data = _RBX->pixels.streamedDataHandle.data;
          _RBX->pixels.streamedDataHandle.data = _RDI->pixels.streamedDataHandle.data;
          _RDI->pixels.streamedDataHandle.data = data;
          return 0;
        }
      }
    }
    GfxImageIndex = v41;
    v3 = v43;
  }
  if ( (_RDI->flags & 0x40) != 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 292, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 293, ASSERT_TYPE_ASSERT, "(toImageOwnsResources)", (const char *)&queryFormat, "toImageOwnsResources") )
      __debugbreak();
    Stream_DBPreReleaseImage(_RDI);
  }
  if ( (_RBX->flags & 0x40) != 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 299, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v40, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    Stream_Defrag_DBPatchImage(_RBX, v8);
    v28 = (unsigned int)(4 * v8);
    XPak_PatchAdjacencyInfo(_RBX, v8);
    v29 = &streamFrontendGlob->imageUsedFrame[v8];
    v30 = &streamFrontendGlob->imageUsedFrame[GfxImageIndex];
    v31 = *v30;
    *v30 = *v29;
    *v29 = v31;
    v32 = (unsigned int)v28 + 4 * (GfxImageIndex - (_DWORD)v8);
    v33 = 4i64;
    do
    {
      v34 = streamFrontendGlob;
      v44 = v28;
      v42 = v32;
      if ( !Sys_InCriticalSection(CRITSECT_STREAM_ALLOC) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 603, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_STREAM_ALLOC ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_STREAM_ALLOC )") )
        __debugbreak();
      if ( v42 >= v34->imageBits.mBitCount )
      {
        LODWORD(v38) = v34->imageBits.mBitCount;
        LODWORD(v37) = v42;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 604, ASSERT_TYPE_ASSERT, "(unsigned)( lhs ) < (unsigned)( mBitCount )", "lhs doesn't index mBitCount\n\t%i not in [0, %i)", v37, v38) )
          __debugbreak();
      }
      if ( v44 >= v34->imageBits.mBitCount )
      {
        LODWORD(v38) = v34->imageBits.mBitCount;
        LODWORD(v37) = v44;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 605, ASSERT_TYPE_ASSERT, "(unsigned)( rhs ) < (unsigned)( mBitCount )", "rhs doesn't index mBitCount\n\t%i not in [0, %i)", v37, v38) )
          __debugbreak();
      }
      v39.lhs = (int *)&v42;
      v39.rhs = (int *)&v44;
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mAlloc);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mLoading);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mPriming);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mUse);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mLoaded);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mStaticForced);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v39, v34->imageBits.mValid);
      v35 = streamFrontendGlob;
      v36 = streamFrontendGlob->imageXPakPosition[v32];
      streamFrontendGlob->imageXPakPosition[v32] = streamFrontendGlob->imageXPakPosition[v28];
      v35->imageXPakPosition[v28] = v36;
      v28 = (unsigned int)(v28 + 1);
      v32 = (unsigned int)(v32 + 1);
      --v33;
    }
    while ( v33 );
    ScopedCriticalSection::~ScopedCriticalSection(&v40);
    GfxImageIndex = v41;
  }
  Stream_ImageRecord_ValidateOnRelease(GfxImageIndex);
  return 1;
}

/*
==============
Stream_DBPreMoveMaterial
==============
*/
void Stream_DBPreMoveMaterial(Material *fromMaterial, Material *toMaterial)
{
  unsigned int MaterialIndex; 
  unsigned int v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 902, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 903, ASSERT_TYPE_ASSERT, "(fromMaterial)", (const char *)&queryFormat, "fromMaterial") )
    __debugbreak();
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 904, ASSERT_TYPE_ASSERT, "(toMaterial)", (const char *)&queryFormat, "toMaterial") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (fromMaterial->runtimeFlags & 0x10) != 0 )
    goto LABEL_19;
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (toMaterial->runtimeFlags & 0x10) != 0 )
  {
LABEL_19:
    MaterialIndex = DB_GetMaterialIndex(fromMaterial);
    Stream_CombineTables_MarkMaterialImageTableAsStale(MaterialIndex);
    v5 = DB_GetMaterialIndex(toMaterial);
    Stream_CombineTables_MarkMaterialImageTableAsStale(v5);
  }
}

/*
==============
Stream_DBPreMoveMesh
==============
*/
void Stream_DBPreMoveMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh, bool toMeshOwnsResources)
{
  __int64 XModelSurfsIndex; 
  const char *name; 
  int v8; 
  int v9; 
  unsigned __int16 numsurfs; 
  unsigned __int16 v11; 
  XSurfaceShared *shared; 
  XSurfaceShared *v13; 
  unsigned __int64 data; 
  __int64 v21; 
  unsigned int v22; 
  __int64 v23; 
  unsigned int *v24; 
  unsigned int *v25; 
  unsigned int v26; 
  __int64 v27; 
  __int64 v28; 
  ScopedCriticalSection v29; 

  _RSI = toMesh;
  _R14 = fromMesh;
  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 458, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 459, ASSERT_TYPE_ASSERT, "(fromMesh)", (const char *)&queryFormat, "fromMesh") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 460, ASSERT_TYPE_ASSERT, "(toMesh)", (const char *)&queryFormat, "toMesh") )
    __debugbreak();
  if ( g_usedDebugZone || !XModelSurfs_IsStreamed(_RSI) || !XModelSurfs_IsStreamed(_R14) )
    goto LABEL_67;
  if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 469, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
    __debugbreak();
  if ( !toMeshOwnsResources && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 470, ASSERT_TYPE_ASSERT, "(toMeshOwnsResources)", (const char *)&queryFormat, "toMeshOwnsResources") )
    __debugbreak();
  if ( _R14->xpakEntry.key == _RSI->xpakEntry.key )
  {
    if ( *((_BYTE *)&_R14->xpakEntry + 24) != *((_BYTE *)&_RSI->xpakEntry + 24) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 478, ASSERT_TYPE_ASSERT, "(fromXPakEntry.xpakIndex == toXPakEntry.xpakIndex)", (const char *)&queryFormat, "fromXPakEntry.xpakIndex == toXPakEntry.xpakIndex") )
      __debugbreak();
    if ( _R14->xpakEntry.offset != _RSI->xpakEntry.offset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 479, ASSERT_TYPE_ASSERT, "(fromXPakEntry.offset == toXPakEntry.offset)", (const char *)&queryFormat, "fromXPakEntry.offset == toXPakEntry.offset") )
      __debugbreak();
    if ( _R14->xpakEntry.size != _RSI->xpakEntry.size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 480, ASSERT_TYPE_ASSERT, "(fromXPakEntry.size == toXPakEntry.size)", (const char *)&queryFormat, "fromXPakEntry.size == toXPakEntry.size") )
      __debugbreak();
    XModelSurfsIndex = DB_GetXModelSurfsIndex(_R14);
    if ( streamFrontendGlob->meshXPakPosition[XModelSurfsIndex] != streamFrontendGlob->meshXPakPosition[DB_GetXModelSurfsIndex(_RSI)] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 485, ASSERT_TYPE_ASSERT, "(streamFrontendGlob->meshXPakPosition[fromIndex] == streamFrontendGlob->meshXPakPosition[toIndex])", (const char *)&queryFormat, "streamFrontendGlob->meshXPakPosition[fromIndex] == streamFrontendGlob->meshXPakPosition[toIndex]") )
      __debugbreak();
    name = _RSI->name;
    do
    {
      v8 = (unsigned __int8)name[(unsigned __int64)(_R14->name - _RSI->name)];
      v9 = *(unsigned __int8 *)name - v8;
      if ( v9 )
        break;
      ++name;
    }
    while ( v8 );
    if ( v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 489, ASSERT_TYPE_ASSERT, "( ( 0 == strcmp( toMesh->name, fromMesh->name ) ) )", "( toMesh->name ) = %s", _RSI->name) )
      __debugbreak();
    _RSI->name = _R14->name;
    numsurfs = _RSI->numsurfs;
    v11 = _R14->numsurfs;
    if ( numsurfs != v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 492, ASSERT_TYPE_ASSERT, "( toMesh->numsurfs ) == ( fromMesh->numsurfs )", "%s == %s\n\t%u, %u", "toMesh->numsurfs", "fromMesh->numsurfs", numsurfs, v11) )
      __debugbreak();
    _RSI->surfs = _R14->surfs;
    _RSI->ugbState = _R14->ugbState;
    if ( memcmp_0(&_RSI->partBits, &_R14->partBits, 0x20ui64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 500, ASSERT_TYPE_ASSERT, "( ( 0 == memcmp( &toMesh->partBits, &fromMesh->partBits, sizeof( toMesh->partBits ) ) ) )", "( toMesh->name ) = %s", _RSI->name) )
      __debugbreak();
    if ( _RSI->shared->dataSize != _R14->shared->dataSize )
    {
      LODWORD(v28) = _R14->shared->dataSize;
      LODWORD(v27) = _RSI->shared->dataSize;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 505, ASSERT_TYPE_ASSERT, "( toMesh->shared->dataSize ) == ( fromMesh->shared->dataSize )", "%s == %s\n\t%u, %u", "toMesh->shared->dataSize", "fromMesh->shared->dataSize", v27, v28) )
        __debugbreak();
    }
    if ( _RSI->shared->flags != _R14->shared->flags )
    {
      LODWORD(v28) = _R14->shared->flags;
      LODWORD(v27) = _RSI->shared->flags;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 506, ASSERT_TYPE_ASSERT, "( toMesh->shared->flags ) == ( fromMesh->shared->flags )", "%s == %s\n\t%u, %u", "toMesh->shared->flags", "fromMesh->shared->flags", v27, v28) )
        __debugbreak();
    }
    shared = _RSI->shared;
    _RSI->shared = _R14->shared;
    _R14->shared = shared;
    v13 = _RSI->shared;
    data = v13->data.streamedDataHandle.data;
    v13->data.streamedDataHandle.data = shared->data.streamedDataHandle.data;
    shared->data.streamedDataHandle.data = data;
    Stream_DBPreReleaseMesh(_R14);
    __asm
    {
      vmovups ymm2, ymmword ptr [r14]
      vmovups ymm3, ymmword ptr [r14+20h]
      vmovups ymm4, ymmword ptr [r14+40h]
      vmovups ymm0, ymmword ptr [rsi]
      vmovups ymmword ptr [r14], ymm0
      vmovups ymm1, ymmword ptr [rsi+20h]
      vmovups ymmword ptr [r14+20h], ymm1
      vmovups ymm0, ymmword ptr [rsi+40h]
      vmovups ymmword ptr [r14+40h], ymm0
      vmovups ymmword ptr [rsi], ymm2
      vmovups ymmword ptr [rsi+20h], ymm3
      vmovups ymmword ptr [rsi+40h], ymm4
    }
  }
  else
  {
LABEL_67:
    if ( XModelSurfs_IsStreamed(_RSI) )
    {
      if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 521, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
        __debugbreak();
      if ( !toMeshOwnsResources && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 522, ASSERT_TYPE_ASSERT, "(toMeshOwnsResources)", (const char *)&queryFormat, "toMeshOwnsResources") )
        __debugbreak();
      Stream_DBPreReleaseMesh(_RSI);
    }
    if ( XModelSurfs_IsStreamed(_R14) )
    {
      if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 528, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
        __debugbreak();
      v21 = DB_GetXModelSurfsIndex(_R14);
      v22 = DB_GetXModelSurfsIndex(_RSI);
      v23 = v22;
      Stream_Defrag_DBPatchMesh(_R14, v22);
      Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
      ScopedCriticalSection::ScopedCriticalSection(&v29, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
      Sys_ProfEndNamedEvent();
      StreamableBits::BitSwap(&streamFrontendGlob->meshBits, v21, v23);
      RequestBits::BitSwap(&streamFrontendGlob->meshRequest, v21, v23);
      XPak_PatchAdjacencyInfo(_R14, v23);
      v24 = &streamFrontendGlob->meshXPakPosition[v23];
      v25 = &streamFrontendGlob->meshXPakPosition[v21];
      v26 = *v25;
      *v25 = *v24;
      *v24 = v26;
      ScopedCriticalSection::~ScopedCriticalSection(&v29);
    }
  }
}

/*
==============
Stream_DBPreMoveStreamKey
==============
*/
void Stream_DBPreMoveStreamKey(StreamKey *fromKey, StreamKey *toKey, bool toStreamKeyOwnsResources)
{
  __int64 StreamKeyIndex; 
  unsigned int v7; 
  __int64 v8; 
  unsigned int *v9; 
  unsigned int *v10; 
  unsigned int v11; 
  ScopedCriticalSection v12; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 692, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()", -2i64) )
    __debugbreak();
  if ( !fromKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 693, ASSERT_TYPE_ASSERT, "(fromKey)", (const char *)&queryFormat, "fromKey") )
    __debugbreak();
  if ( !toKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 694, ASSERT_TYPE_ASSERT, "(toKey)", (const char *)&queryFormat, "toKey") )
    __debugbreak();
  if ( toKey->dataSize && (toKey->flags & 2) == 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 698, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    if ( !toStreamKeyOwnsResources && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 699, ASSERT_TYPE_ASSERT, "(toStreamKeyOwnsResources)", (const char *)&queryFormat, "toStreamKeyOwnsResources") )
      __debugbreak();
    Stream_DBPreReleaseStreamKey(toKey);
  }
  if ( fromKey->dataSize && (fromKey->flags & 2) == 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 705, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    StreamKeyIndex = DB_GetStreamKeyIndex(fromKey);
    v7 = DB_GetStreamKeyIndex(toKey);
    v8 = v7;
    Stream_Defrag_DBPatchStreamKey(fromKey, v7);
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v12, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    StreamableBits::BitSwap(&streamFrontendGlob->genericBits, StreamKeyIndex, v8);
    RequestBits::BitSwap(&streamFrontendGlob->genericRequest, StreamKeyIndex, v8);
    XPak_PatchAdjacencyInfo(fromKey, v8);
    v9 = &streamFrontendGlob->genericXPakPosition[v8];
    v10 = &streamFrontendGlob->genericXPakPosition[StreamKeyIndex];
    v11 = *v10;
    *v10 = *v9;
    *v9 = v11;
    ScopedCriticalSection::~ScopedCriticalSection(&v12);
  }
}

/*
==============
Stream_DBPreMoveXModel
==============
*/
void Stream_DBPreMoveXModel(XModel *fromModel, XModel *toModel)
{
  unsigned int XModelIndex; 
  unsigned int v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 830, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 831, ASSERT_TYPE_ASSERT, "(fromModel)", (const char *)&queryFormat, "fromModel") )
    __debugbreak();
  if ( !toModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 832, ASSERT_TYPE_ASSERT, "(toModel)", (const char *)&queryFormat, "toModel") )
    __debugbreak();
  if ( XModelHasMaterialsWithStreamedImages(fromModel) || XModelHasMaterialsWithStreamedImages(toModel) )
  {
    XModelIndex = DB_GetXModelIndex(fromModel);
    Stream_CombineTables_MarkModelMaterialTableAsStale(XModelIndex);
    v5 = DB_GetXModelIndex(toModel);
    Stream_CombineTables_MarkModelMaterialTableAsStale(v5);
  }
}

/*
==============
Stream_DBPreReleaseImage
==============
*/
void Stream_DBPreReleaseImage(GfxImage *image)
{
  unsigned int GfxImageIndex; 
  unsigned __int64 v3; 
  signed int v4; 
  const dvar_t *v5; 
  unsigned int flags; 
  bool enabled; 
  StreamFrontendGlob *v8; 
  StreamFrontendGlob *v9; 
  unsigned int v10; 
  StreamFrontendGlob *v11; 
  unsigned int *mUse; 
  int v13; 
  __int64 v14; 
  StreamFrontendGlob *v15; 
  unsigned int *mStaticForced; 
  signed int v17; 
  StreamFrontendGlob *v18; 
  unsigned int *mLoading; 
  int v20; 
  __int64 v21; 
  StreamFrontendGlob *v22; 
  unsigned int *mAlloc; 
  volatile int (*imageTouchBits)[10240]; 
  volatile signed __int32 *v25; 
  int v26; 
  StreamFrontendGlob *v27; 
  StreamFrontendGlob *v28; 
  unsigned int *mValid; 
  __int64 v30; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 
  ScopedCriticalSection v34; 
  signed int v35; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 58, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !image && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 59, ASSERT_TYPE_ASSERT, "(image)", (const char *)&queryFormat, "image") )
    __debugbreak();
  GfxImageIndex = DB_GetGfxImageIndex(image);
  v3 = GfxImageIndex;
  if ( (image->flags & 0x40) != 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 71, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    XPak_CheckAdjacencyInfo(image);
    XPak_ClearAdjacencyInfo(image);
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v34, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    Stream_BackendQueue_DBPreReleaseImage(image);
    v4 = 4 * v3;
    v35 = 4 * v3;
    v5 = DCONST_DVARBOOL_stream_concurrentImagePartLoading;
    if ( !DCONST_DVARBOOL_stream_concurrentImagePartLoading && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "stream_concurrentImagePartLoading") )
      __debugbreak();
    if ( g_checkServerThread && Sys_IsAnyServerThreadWork() )
    {
      flags = v5->flags;
      if ( (flags & 0x81488) != 0 && (flags & 0x40000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 612, ASSERT_TYPE_ASSERT, "(!g_checkServerThread || !Sys_IsAnyServerThreadWork() || !( dvar->flags & (((1 << 10) | (1 << 3) | (1 << 7) | ( 1 << 19 )) | (1 << 12)) ) || ( dvar->flags & ( 1 << 18 ) ))", "%s\n\tAccessing dvar '%s' from server context when we were not expected to, this can cause performance issues all the way to complete deadlocks.", "!g_checkServerThread || !Sys_IsAnyServerThreadWork() || !( dvar->flags & SV_DVAR_LOAD_MODIFIED_MASK ) || ( dvar->flags & DVAR_DCONST )", v5->name) )
        __debugbreak();
    }
    enabled = v5->current.enabled;
    streamFrontendGlob->imageUsedFrame[v3] = 0;
    v8 = streamFrontendGlob;
    if ( (unsigned int)v3 >= 0x14000 )
    {
      LODWORD(v32) = 81920;
      LODWORD(v30) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_sortlist.h", 342, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( ( sizeof( *array_counter( mDistances ) ) + 0 ) )", "assetIndex doesn't index ARRAY_COUNT( mDistances )\n\t%i not in [0, %i)", v30, v32) )
        __debugbreak();
    }
    v8->imageDistance.mDistances[v3].mValue = -1;
    Com_BitClearAssert(v8->imageDistance.mValueSet, v3, 10240);
    v9 = streamFrontendGlob;
    if ( (unsigned int)v3 >= 0x14000 )
    {
      LODWORD(v32) = 81920;
      LODWORD(v30) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_hint.h", 23, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( sizeof( *array_counter( mDistances ) ) + 0 ) )", "index doesn't index mDistances\n\t%i not in [0, %i)", v30, v32) )
        __debugbreak();
      LODWORD(v33) = 81920;
      LODWORD(v31) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_hint.h", 24, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mValueSet.BIT_COUNT )", "index doesn't index mValueSet.BIT_COUNT\n\t%i not in [0, %i)", v31, v33) )
        __debugbreak();
    }
    v9->imageDistanceHint.mDistances[v3].mValue = -1;
    if ( (unsigned int)v3 >= 0x14000 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v3, 81920) )
      __debugbreak();
    v9->imageDistanceHint.mValueSet.array[v3 >> 5] &= ~(0x80000000 >> (v3 & 0x1F));
    Stream_ImageRecord_ClearTracking(v3);
    Stream_ImageRecord_ValidateOnRelease(v3);
    if ( image->streamedPartCount )
    {
      v10 = 4 * v3;
      do
      {
        v11 = streamFrontendGlob;
        if ( !Sys_InCriticalSection(CRITSECT_STREAM_ALLOC) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 355, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_STREAM_ALLOC ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_STREAM_ALLOC )") )
          __debugbreak();
        if ( v10 >= v11->imageBits.mBitCount )
        {
          LODWORD(v32) = v11->imageBits.mBitCount;
          LODWORD(v30) = v10;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 356, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        mUse = v11->imageBits.mUse;
        if ( !mUse && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 28, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
          __debugbreak();
        v13 = ~(1 << (v10 & 0x1F));
        v14 = (__int64)(int)v10 >> 5;
        mUse[v14] &= v13;
        StreamableBitArray_InterlockedClearArray(streamFrontendGlob->imageBits.mLoaded, v10);
        v15 = streamFrontendGlob;
        if ( v10 >= streamFrontendGlob->imageBits.mBitCount )
        {
          LODWORD(v32) = streamFrontendGlob->imageBits.mBitCount;
          LODWORD(v30) = v10;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 575, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        mStaticForced = v15->imageBits.mStaticForced;
        if ( !mStaticForced && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 28, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
          __debugbreak();
        mStaticForced[v14] &= v13;
        if ( enabled && v10 != v4 )
          Stream_Alloc_FreeImagePart(image, v10 - v4, (StreamUpdateId)0i64);
        ++v10;
      }
      while ( v10 - v4 < image->streamedPartCount );
      v4 = v35;
    }
    Stream_Alloc_FreeImage(image, 0);
    Stream_AddressSpace_FreeImageHandle(image);
    if ( image->streamedPartCount )
    {
      v17 = v4;
      do
      {
        v18 = streamFrontendGlob;
        if ( v17 >= streamFrontendGlob->imageBits.mBitCount )
        {
          LODWORD(v32) = streamFrontendGlob->imageBits.mBitCount;
          LODWORD(v30) = v17;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 288, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        mLoading = v18->imageBits.mLoading;
        if ( !mLoading && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 12, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
          __debugbreak();
        v20 = 1 << (v17 & 0x1F);
        v21 = (__int64)v17 >> 5;
        if ( (v20 & mLoading[v21]) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 115, ASSERT_TYPE_ASSERT, "(!streamFrontendGlob->imageBits.CheckLoading( part + imagePartIndex ))", (const char *)&queryFormat, "!streamFrontendGlob->imageBits.CheckLoading( part + imagePartIndex )") )
          __debugbreak();
        v22 = streamFrontendGlob;
        if ( v17 >= streamFrontendGlob->imageBits.mBitCount )
        {
          LODWORD(v32) = streamFrontendGlob->imageBits.mBitCount;
          LODWORD(v30) = v17;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 323, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        mAlloc = v22->imageBits.mAlloc;
        if ( !mAlloc && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 12, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
          __debugbreak();
        if ( (v20 & mAlloc[v21]) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 116, ASSERT_TYPE_ASSERT, "(!streamFrontendGlob->imageBits.CheckAlloc( part + imagePartIndex ))", (const char *)&queryFormat, "!streamFrontendGlob->imageBits.CheckAlloc( part + imagePartIndex )") )
          __debugbreak();
        imageTouchBits = streamFrontendGlob->imageTouchBits;
        if ( (unsigned int)(v17 >> 5) >= 0x2800 )
        {
          LODWORD(v32) = 10240;
          LODWORD(v30) = v17 >> 5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 39, ASSERT_TYPE_ASSERT, "(unsigned)( ( index >> 5 ) ) < (unsigned)( ( sizeof( *array_counter( bitArray ) ) + 0 ) )", "( index >> 5 ) doesn't index ARRAY_COUNT( bitArray )\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        v25 = &(*imageTouchBits)[v21];
        if ( ((unsigned __int8)v25 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 51, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)v25) )
          __debugbreak();
        v26 = ~v20;
        _InterlockedAnd(v25, v26);
        v27 = streamFrontendGlob;
        if ( (unsigned int)(v17 >> 5) >= 0x2800 )
        {
          LODWORD(v32) = 10240;
          LODWORD(v30) = v17 >> 5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 39, ASSERT_TYPE_ASSERT, "(unsigned)( ( index >> 5 ) ) < (unsigned)( ( sizeof( *array_counter( bitArray ) ) + 0 ) )", "( index >> 5 ) doesn't index ARRAY_COUNT( bitArray )\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        if ( (((_BYTE)(v21 * 4) + (_BYTE)v27 - 64) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 51, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &v27->imageTouchBits[1][v21]) )
          __debugbreak();
        _InterlockedAnd(&v27->imageTouchBits[1][v21], v26);
        v28 = streamFrontendGlob;
        if ( v17 >= streamFrontendGlob->imageBits.mBitCount )
        {
          LODWORD(v32) = streamFrontendGlob->imageBits.mBitCount;
          LODWORD(v30) = v17;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 421, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v30, v32) )
            __debugbreak();
        }
        mValid = v28->imageBits.mValid;
        if ( !mValid && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 28, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
          __debugbreak();
        mValid[v21] &= v26;
        streamFrontendGlob->imageXPakPosition[v17++] = 0;
      }
      while ( v17 - v4 < (unsigned int)image->streamedPartCount );
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v34);
  }
  else
  {
    Stream_ImageRecord_ValidateOnRelease(GfxImageIndex);
  }
}

/*
==============
Stream_DBPreReleaseMaterial
==============
*/
void Stream_DBPreReleaseMaterial(Material *material)
{
  unsigned int MaterialIndex; 
  __int64 v3; 
  StreamFrontendGlob *v4; 
  __int64 v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 870, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !material )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 871, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
      __debugbreak();
  }
  if ( (material->runtimeFlags & 0x10) != 0 )
  {
    Stream_ClearMaterialTouchedUntilLoaded(material);
    MaterialIndex = DB_GetMaterialIndex(material);
    v3 = MaterialIndex;
    Stream_CombineTables_MarkMaterialImageTableAsStale(MaterialIndex);
    v4 = streamFrontendGlob;
    if ( (unsigned int)v3 >= 0xB400 )
    {
      LODWORD(v5) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_sortlist.h", 342, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( ( sizeof( *array_counter( mDistances ) ) + 0 ) )", "assetIndex doesn't index ARRAY_COUNT( mDistances )\n\t%i not in [0, %i)", v5, 46080) )
        __debugbreak();
    }
    v4->materialDistance.mDistances[v3].mValue = -1;
    Com_BitClearAssert(v4->materialDistance.mValueSet, v3, 5760);
  }
}

/*
==============
Stream_DBPreReleaseMesh
==============
*/
void Stream_DBPreReleaseMesh(XModelSurfs *mesh)
{
  unsigned int XModelSurfsIndex; 
  __int64 v3; 
  ScopedCriticalSection v4; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 381, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()", -2i64) )
    __debugbreak();
  if ( !mesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 382, ASSERT_TYPE_ASSERT, "(mesh)", (const char *)&queryFormat, "mesh") )
    __debugbreak();
  if ( !mesh->shared && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 383, ASSERT_TYPE_ASSERT, "(mesh->shared)", (const char *)&queryFormat, "mesh->shared") )
    __debugbreak();
  if ( XModelSurfs_IsStreamed(mesh) )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 390, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v4, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    XModelSurfsIndex = DB_GetXModelSurfsIndex(mesh);
    v3 = XModelSurfsIndex;
    StreamableBits::ClearInUse(&streamFrontendGlob->meshBits, XModelSurfsIndex);
    StreamableBits::ClearStaticForced(&streamFrontendGlob->meshBits, v3);
    Stream_Alloc_FreeMesh(mesh);
    Stream_AddressSpace_FreeMeshHandle(mesh);
    StreamableBitArray_InterlockedClearArray(streamFrontendGlob->meshBits.mLoaded, v3);
    StreamableBitArray_InterlockedClearArray(streamFrontendGlob->meshRequest.mFreeable, v3);
    StreamableBitArray_InterlockedClearArray(streamFrontendGlob->meshRequest.mDanger, v3);
    XPak_ClearAdjacencyInfo(mesh);
    StreamableBits::ClearValid(&streamFrontendGlob->meshBits, v3);
    streamFrontendGlob->meshXPakPosition[v3] = 0;
    ScopedCriticalSection::~ScopedCriticalSection(&v4);
  }
}

/*
==============
Stream_DBPreReleaseStreamKey
==============
*/
void Stream_DBPreReleaseStreamKey(StreamKey *key)
{
  __int64 StreamKeyIndex; 
  StreamFrontendGlob *v3; 
  unsigned int *mUse; 
  int v5; 
  __int64 v6; 
  ScopedCriticalSection v7; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 580, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 581, ASSERT_TYPE_ASSERT, "(key)", (const char *)&queryFormat, "key") )
    __debugbreak();
  if ( key->dataSize )
  {
    if ( (key->flags & 2) != 0 )
    {
      StreamKey_UserDBPreRelease(key);
    }
    else
    {
      if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 594, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
        __debugbreak();
      Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
      ScopedCriticalSection::ScopedCriticalSection(&v7, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
      Sys_ProfEndNamedEvent();
      StreamKeyIndex = DB_GetStreamKeyIndex(key);
      v3 = streamFrontendGlob;
      if ( (unsigned int)StreamKeyIndex >= streamFrontendGlob->genericBits.mBitCount )
      {
        LODWORD(v6) = StreamKeyIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 371, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( mBitCount )", "index doesn't index mBitCount\n\t%i not in [0, %i)", v6, streamFrontendGlob->genericBits.mBitCount) )
          __debugbreak();
      }
      mUse = v3->genericBits.mUse;
      if ( !mUse && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 12, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
        __debugbreak();
      v5 = mUse[(__int64)(int)StreamKeyIndex >> 5] & (1 << (StreamKeyIndex & 0x1F));
      StreamableBits::ClearInUse(&streamFrontendGlob->genericBits, StreamKeyIndex);
      StreamableBits::ClearStaticForced(&streamFrontendGlob->genericBits, StreamKeyIndex);
      if ( v5 )
        StreamKey_UserUnloadedFrontend(key);
      Stream_Alloc_FreeGeneric(key);
      if ( v5 )
        StreamKey_UserUnloadedBackend(key);
      StreamKey_UserDBPreRelease(key);
      if ( key->behaviorIndex )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 626, ASSERT_TYPE_ASSERT, "(key->behaviorIndex == SKBI_NONE)", (const char *)&queryFormat, "key->behaviorIndex == SKBI_NONE") )
          __debugbreak();
      }
      Stream_AddressSpace_FreeGenericHandle(key);
      StreamableBitArray_InterlockedClearArray(streamFrontendGlob->genericBits.mLoaded, StreamKeyIndex);
      StreamableBitArray_InterlockedClearArray(streamFrontendGlob->genericRequest.mFreeable, StreamKeyIndex);
      StreamableBitArray_InterlockedClearArray(streamFrontendGlob->genericRequest.mDanger, StreamKeyIndex);
      XPak_ClearAdjacencyInfo(key);
      StreamableBits::ClearValid(&streamFrontendGlob->genericBits, StreamKeyIndex);
      streamFrontendGlob->genericXPakPosition[StreamKeyIndex] = 0;
      ScopedCriticalSection::~ScopedCriticalSection(&v7);
    }
  }
}

/*
==============
Stream_DBPreReleaseXModel
==============
*/
void Stream_DBPreReleaseXModel(XModel *model)
{
  unsigned int XModelIndex; 
  __int64 v3; 
  StreamFrontendGlob *v4; 
  __int64 v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 799, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 800, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  if ( XModelHasMaterialsWithStreamedImages(model) )
  {
    XModelIndex = DB_GetXModelIndex(model);
    v3 = XModelIndex;
    Stream_CombineTables_MarkModelMaterialTableAsStale(XModelIndex);
    v4 = streamFrontendGlob;
    if ( (unsigned int)v3 >= 0x6000 )
    {
      LODWORD(v5) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_sortlist.h", 342, ASSERT_TYPE_ASSERT, "(unsigned)( assetIndex ) < (unsigned)( ( sizeof( *array_counter( mDistances ) ) + 0 ) )", "assetIndex doesn't index ARRAY_COUNT( mDistances )\n\t%i not in [0, %i)", v5, 24576) )
        __debugbreak();
    }
    v4->modelDistance.mDistances[v3].mValue = -1;
    Com_BitClearAssert(v4->modelDistance.mValueSet, v3, 3072);
  }
}

/*
==============
Stream_DBPreSwapImage
==============
*/
void Stream_DBPreSwapImage(GfxImage *fromImage, GfxImage *toImage)
{
  __int64 GfxImageIndex; 
  unsigned int v5; 
  __int64 v6; 
  unsigned int *v7; 
  unsigned int *v8; 
  unsigned int v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  StreamFrontendGlob *v13; 
  StreamFrontendGlob *v14; 
  unsigned int v15; 
  __int64 v16; 
  __int64 v17; 
  StreamableBits::BitSwap::__l2::<lambda_0cfe52a449506a58f3f65a204b9daded> v18; 
  ScopedCriticalSection v19; 
  unsigned int v20; 
  unsigned int v21; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 128, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromImage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 129, ASSERT_TYPE_ASSERT, "(fromImage)", (const char *)&queryFormat, "fromImage") )
    __debugbreak();
  if ( !toImage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 130, ASSERT_TYPE_ASSERT, "(toImage)", (const char *)&queryFormat, "toImage") )
    __debugbreak();
  XPak_CheckAdjacencyInfo(fromImage);
  XPak_CheckAdjacencyInfo(toImage);
  GfxImageIndex = DB_GetGfxImageIndex(fromImage);
  v5 = DB_GetGfxImageIndex(toImage);
  v6 = v5;
  Stream_ImageRecord_SwapTracking(GfxImageIndex, v5);
  if ( (fromImage->flags & 0x40) != 0 )
  {
    Stream_Defrag_DBPatchImage(fromImage, v6);
    XPak_PatchAdjacencyInfo(fromImage, v6);
  }
  if ( (toImage->flags & 0x40) != 0 )
  {
    Stream_Defrag_DBPatchImage(toImage, GfxImageIndex);
    XPak_PatchAdjacencyInfo(toImage, GfxImageIndex);
  }
  if ( (fromImage->flags & 0x40) != 0 || (toImage->flags & 0x40) != 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 161, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v19, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    v7 = &streamFrontendGlob->imageUsedFrame[v6];
    v8 = &streamFrontendGlob->imageUsedFrame[GfxImageIndex];
    v9 = *v8;
    *v8 = *v7;
    *v7 = v9;
    v10 = (unsigned int)(4 * v6);
    v11 = (unsigned int)(v10 + 4 * (GfxImageIndex - v6));
    v12 = 4i64;
    do
    {
      v13 = streamFrontendGlob;
      v21 = v10;
      v20 = v11;
      if ( !Sys_InCriticalSection(CRITSECT_STREAM_ALLOC) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 603, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_STREAM_ALLOC ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_STREAM_ALLOC )") )
        __debugbreak();
      if ( v20 >= v13->imageBits.mBitCount )
      {
        LODWORD(v17) = v13->imageBits.mBitCount;
        LODWORD(v16) = v20;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 604, ASSERT_TYPE_ASSERT, "(unsigned)( lhs ) < (unsigned)( mBitCount )", "lhs doesn't index mBitCount\n\t%i not in [0, %i)", v16, v17) )
          __debugbreak();
      }
      if ( v21 >= v13->imageBits.mBitCount )
      {
        LODWORD(v17) = v13->imageBits.mBitCount;
        LODWORD(v16) = v21;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_bits.h", 605, ASSERT_TYPE_ASSERT, "(unsigned)( rhs ) < (unsigned)( mBitCount )", "rhs doesn't index mBitCount\n\t%i not in [0, %i)", v16, v17) )
          __debugbreak();
      }
      v18.lhs = (int *)&v20;
      v18.rhs = (int *)&v21;
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mAlloc);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mLoading);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mPriming);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mUse);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mLoaded);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mStaticForced);
      _lambda_0cfe52a449506a58f3f65a204b9daded_::operator()(&v18, v13->imageBits.mValid);
      v14 = streamFrontendGlob;
      v15 = streamFrontendGlob->imageXPakPosition[v11];
      streamFrontendGlob->imageXPakPosition[v11] = streamFrontendGlob->imageXPakPosition[v10];
      v14->imageXPakPosition[v10] = v15;
      v10 = (unsigned int)(v10 + 1);
      v11 = (unsigned int)(v11 + 1);
      --v12;
    }
    while ( v12 );
    ScopedCriticalSection::~ScopedCriticalSection(&v19);
  }
}

/*
==============
Stream_DBPreSwapMaterial
==============
*/
void Stream_DBPreSwapMaterial(Material *fromMaterial, Material *toMaterial)
{
  unsigned int MaterialIndex; 
  unsigned int v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 887, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 888, ASSERT_TYPE_ASSERT, "(fromMaterial)", (const char *)&queryFormat, "fromMaterial") )
    __debugbreak();
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 889, ASSERT_TYPE_ASSERT, "(toMaterial)", (const char *)&queryFormat, "toMaterial") )
    __debugbreak();
  if ( !fromMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (fromMaterial->runtimeFlags & 0x10) != 0 )
    goto LABEL_19;
  if ( !toMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_material_inline.h", 938, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( (toMaterial->runtimeFlags & 0x10) != 0 )
  {
LABEL_19:
    MaterialIndex = DB_GetMaterialIndex(fromMaterial);
    Stream_CombineTables_MarkMaterialImageTableAsStale(MaterialIndex);
    v5 = DB_GetMaterialIndex(toMaterial);
    Stream_CombineTables_MarkMaterialImageTableAsStale(v5);
  }
}

/*
==============
Stream_DBPreSwapMesh
==============
*/
void Stream_DBPreSwapMesh(XModelSurfs *fromMesh, XModelSurfs *toMesh)
{
  __int64 XModelSurfsIndex; 
  __int64 v5; 
  unsigned int *v6; 
  unsigned int *v7; 
  unsigned int v8; 
  ScopedCriticalSection v9; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 422, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()", -2i64) )
    __debugbreak();
  if ( !fromMesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 423, ASSERT_TYPE_ASSERT, "(fromMesh)", (const char *)&queryFormat, "fromMesh") )
    __debugbreak();
  if ( !toMesh && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 424, ASSERT_TYPE_ASSERT, "(toMesh)", (const char *)&queryFormat, "toMesh") )
    __debugbreak();
  XModelSurfsIndex = DB_GetXModelSurfsIndex(fromMesh);
  v5 = DB_GetXModelSurfsIndex(toMesh);
  if ( XModelSurfs_IsStreamed(fromMesh) )
    Stream_Defrag_DBPatchMesh(fromMesh, v5);
  if ( XModelSurfs_IsStreamed(toMesh) )
    Stream_Defrag_DBPatchMesh(toMesh, XModelSurfsIndex);
  if ( XModelSurfs_IsStreamed(fromMesh) || XModelSurfs_IsStreamed(toMesh) )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 442, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v9, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    StreamableBits::BitSwap(&streamFrontendGlob->meshBits, XModelSurfsIndex, v5);
    RequestBits::BitSwap(&streamFrontendGlob->meshRequest, XModelSurfsIndex, v5);
    XPak_PatchAdjacencyInfo(fromMesh, v5);
    XPak_PatchAdjacencyInfo(toMesh, XModelSurfsIndex);
    v6 = &streamFrontendGlob->meshXPakPosition[v5];
    v7 = &streamFrontendGlob->meshXPakPosition[XModelSurfsIndex];
    v8 = *v7;
    *v7 = *v6;
    *v6 = v8;
    ScopedCriticalSection::~ScopedCriticalSection(&v9);
  }
}

/*
==============
Stream_DBPreSwapStreamKey
==============
*/
void Stream_DBPreSwapStreamKey(StreamKey *fromKey, StreamKey *toKey)
{
  __int64 StreamKeyIndex; 
  unsigned int v5; 
  __int64 v6; 
  unsigned int *v7; 
  unsigned int *v8; 
  unsigned int v9; 
  void *behaviorUserPtr; 
  ScopedCriticalSection v11; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 644, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()", -2i64) )
    __debugbreak();
  if ( !fromKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 645, ASSERT_TYPE_ASSERT, "(fromKey)", (const char *)&queryFormat, "fromKey") )
    __debugbreak();
  if ( !toKey && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 646, ASSERT_TYPE_ASSERT, "(toKey)", (const char *)&queryFormat, "toKey") )
    __debugbreak();
  StreamKeyIndex = DB_GetStreamKeyIndex(fromKey);
  v5 = DB_GetStreamKeyIndex(toKey);
  v6 = v5;
  if ( fromKey->dataSize && (fromKey->flags & 2) == 0 )
    Stream_Defrag_DBPatchStreamKey(fromKey, v5);
  if ( toKey->dataSize && (toKey->flags & 2) == 0 )
    Stream_Defrag_DBPatchStreamKey(toKey, StreamKeyIndex);
  if ( fromKey->dataSize && (fromKey->flags & 2) == 0 || toKey->dataSize && (toKey->flags & 2) == 0 )
  {
    if ( Stream_IsEnabled() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 664, ASSERT_TYPE_ASSERT, "(!Stream_IsEnabled())", (const char *)&queryFormat, "!Stream_IsEnabled()") )
      __debugbreak();
    Sys_ProfBeginNamedEvent(0xFF00FFFF, "StreamAlloc_Lock");
    ScopedCriticalSection::ScopedCriticalSection(&v11, CRITSECT_STREAM_ALLOC, SCOPED_CRITSECT_NORMAL);
    Sys_ProfEndNamedEvent();
    StreamableBits::BitSwap(&streamFrontendGlob->genericBits, StreamKeyIndex, v6);
    RequestBits::BitSwap(&streamFrontendGlob->genericRequest, StreamKeyIndex, v6);
    XPak_PatchAdjacencyInfo(fromKey, v6);
    XPak_PatchAdjacencyInfo(toKey, StreamKeyIndex);
    v7 = &streamFrontendGlob->genericXPakPosition[v6];
    v8 = &streamFrontendGlob->genericXPakPosition[StreamKeyIndex];
    v9 = *v8;
    *v8 = *v7;
    *v7 = v9;
    ScopedCriticalSection::~ScopedCriticalSection(&v11);
  }
  if ( toKey->behaviorIndex == SKBI_SOUND )
  {
    behaviorUserPtr = fromKey->behaviorUserPtr;
    fromKey->assetHash = toKey->assetHash;
    toKey->assetHash = (unsigned __int64)behaviorUserPtr;
  }
}

/*
==============
Stream_DBPreSwapXModel
==============
*/
void Stream_DBPreSwapXModel(XModel *fromModel, XModel *toModel)
{
  unsigned int XModelIndex; 
  unsigned int v5; 

  if ( !Sys_IsMainThread() && !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 815, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !fromModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 816, ASSERT_TYPE_ASSERT, "(fromModel)", (const char *)&queryFormat, "fromModel") )
    __debugbreak();
  if ( !toModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\stream\\stream_db_assethandlers.cpp", 817, ASSERT_TYPE_ASSERT, "(toModel)", (const char *)&queryFormat, "toModel") )
    __debugbreak();
  if ( XModelHasMaterialsWithStreamedImages(fromModel) || XModelHasMaterialsWithStreamedImages(toModel) )
  {
    XModelIndex = DB_GetXModelIndex(fromModel);
    Stream_CombineTables_MarkModelMaterialTableAsStale(XModelIndex);
    v5 = DB_GetXModelIndex(toModel);
    Stream_CombineTables_MarkModelMaterialTableAsStale(v5);
  }
}

