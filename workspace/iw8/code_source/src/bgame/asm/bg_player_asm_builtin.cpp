/*
==============
PlayerASM_Transition_ReturnTrue
==============
*/

int __fastcall PlayerASM_Transition_ReturnTrue(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_Transition_ReturnTrue@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsWalking
==============
*/

int __fastcall PlayerASM_IsWalking(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsWalking@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingBackwardMoveType
==============
*/

int __fastcall PlayerASM_IsMovingBackwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingBackwardMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_SkipHipFlipBackwardToForwardCrouch
==============
*/

int __fastcall PlayerASM_SkipHipFlipBackwardToForwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_SkipHipFlipBackwardToForwardCrouch@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionFromNoUpdate
==============
*/

int __fastcall PlayerASM_IsTransitionFromNoUpdate(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionFromNoUpdate@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ClearAnimState
==============
*/

int __fastcall PlayerASM_ClearAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ClearAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerBiggerThan
==============
*/

int __fastcall PlayerASM_IsAnimationTimerBiggerThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsAnimationTimerBiggerThan@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopBackwardTransition
==============
*/

int __fastcall PlayerASM_IsStopBackwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopBackwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ChooseAnim
==============
*/

int __fastcall PlayerASM_ChooseAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ChooseAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerLessThan
==============
*/

int __fastcall PlayerASM_IsAnimationTimerLessThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsAnimationTimerLessThan@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_PlayAnimState
==============
*/

int __fastcall PlayerASM_PlayAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_PlayAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_Transition_ReturnFalse
==============
*/

int __fastcall PlayerASM_Transition_ReturnFalse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_Transition_ReturnFalse@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStickMovingBackward
==============
*/

int __fastcall PlayerASM_IsStickMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStickMovingBackward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurningRight
==============
*/

int __fastcall PlayerASM_IsTurningRight(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurningRight@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionReverse
==============
*/

int __fastcall PlayerASM_IsTransitionReverse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionReverse@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopForwardTransition
==============
*/

int __fastcall PlayerASM_IsStopForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopForwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionFrom
==============
*/

int __fastcall PlayerASM_IsTransitionFrom(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionFrom@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingMoveType
==============
*/

int __fastcall PlayerASM_IsMovingMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMoving
==============
*/

int __fastcall PlayerASM_IsMoving(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMoving@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_GetBuiltinFunc
==============
*/

int (__fastcall *__fastcall PlayerASM_GetBuiltinFunc(int i))(const PlayerASM_Context *, const PlayerASM_Parameters *)
{
  return ?PlayerASM_GetBuiltinFunc@@YAP6AHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@ZH@Z(i);
}

/*
==============
PlayerASM_ChooseRandomAnimInternal
==============
*/

unsigned int __fastcall PlayerASM_ChooseRandomAnimInternal(const PlayerASM_Context *context, BgPlayer_Asm *pAsm, int entNum, const scr_string_t asmName, const scr_string_t stateName)
{
  return ?PlayerASM_ChooseRandomAnimInternal@@YAIPEBUPlayerASM_Context@@PEAVBgPlayer_Asm@@HW4scr_string_t@@2@Z(context, pAsm, entNum, asmName, stateName);
}

/*
==============
PlayerASM_UpdateAnimChoice
==============
*/

int __fastcall PlayerASM_UpdateAnimChoice(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_UpdateAnimChoice@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingForward
==============
*/

int __fastcall PlayerASM_IsMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingForward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_PlayPredictedAnim
==============
*/

int __fastcall PlayerASM_PlayPredictedAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_PlayPredictedAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_EventFired
==============
*/

int __fastcall PlayerASM_EventFired(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_EventFired@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsRunning
==============
*/

int __fastcall PlayerASM_IsRunning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsRunning@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopSpeedGreaterThanThreshold
==============
*/

int __fastcall PlayerASM_IsStopSpeedGreaterThanThreshold(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopSpeedGreaterThanThreshold@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingForwardMoveType
==============
*/

int __fastcall PlayerASM_IsMovingForwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingForwardMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopping
==============
*/

int __fastcall PlayerASM_IsStopping(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopping@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_SkipHipFlipForwardToBackwardCrouch
==============
*/

int __fastcall PlayerASM_SkipHipFlipForwardToBackwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_SkipHipFlipForwardToBackwardCrouch@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsInAir
==============
*/

int __fastcall PlayerASM_IsInAir(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsInAir@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_AnimationFinished
==============
*/

int __fastcall PlayerASM_AnimationFinished(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_AnimationFinished@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingBackward
==============
*/

int __fastcall PlayerASM_IsMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingBackward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_GetAnim
==============
*/

int __fastcall PlayerASM_GetAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_GetAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ChooseRandomAnim
==============
*/

int __fastcall PlayerASM_ChooseRandomAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ChooseRandomAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsForwardToBackTransition
==============
*/

int __fastcall PlayerASM_IsForwardToBackTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsForwardToBackTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurning
==============
*/

int __fastcall PlayerASM_IsTurning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurning@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStickMovingForward
==============
*/

int __fastcall PlayerASM_IsStickMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStickMovingForward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurningLeft
==============
*/

int __fastcall PlayerASM_IsTurningLeft(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurningLeft@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_LoopAnimState
==============
*/

int __fastcall PlayerASM_LoopAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_LoopAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsBackToForwardTransition
==============
*/

int __fastcall PlayerASM_IsBackToForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsBackToForwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_Transition_ReturnTrue
==============
*/
__int64 PlayerASM_Transition_ReturnTrue(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return 1i64;
}

/*
==============
PlayerASM_Transition_ReturnFalse
==============
*/
__int64 PlayerASM_Transition_ReturnFalse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return 0i64;
}

/*
==============
PlayerASM_IsInAir
==============
*/
int PlayerASM_IsInAir(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  const playerState_s *PlayerState; 
  bool v5; 
  entityState_t *EntityState; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
  {
    v5 = BG_IsInAir(PlayerState, 0);
  }
  else
  {
    EntityState = BG_PlayerASM_GetEntityState(context);
    if ( !EntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 67, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    v5 = EntityState->groundEntityNum == 2047;
  }
  return PlayerASM_TestBool(v5, context, parameters);
}

/*
==============
PlayerASM_IsWalking
==============
*/
int PlayerASM_IsWalking(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 82, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 1008i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsRunning
==============
*/
int PlayerASM_IsRunning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 104, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 15360i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMoving
==============
*/
_BOOL8 PlayerASM_IsMoving(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->speed > 0;
}

/*
==============
PlayerASM_IsMovingForward
==============
*/
_BOOL8 PlayerASM_IsMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  _RDI = parameters->ci;
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 674, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( ci->speed <= 0 )
    return 0i64;
  __asm { vmovss  xmm0, dword ptr [rdi+0A14h]; angle }
  return PlayerASM_IsForwardAngle(*(const float *)&_XMM0);
}

/*
==============
PlayerASM_IsMovingBackward
==============
*/
_BOOL8 PlayerASM_IsMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  _RDI = parameters->ci;
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 689, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( ci->speed <= 0 )
    return 0i64;
  __asm { vmovss  xmm0, dword ptr [rdi+0A14h]; angle }
  return PlayerASM_IsBackwardAngle(*(const float *)&_XMM0);
}

/*
==============
PlayerASM_IsStopping
==============
*/
_BOOL8 PlayerASM_IsStopping(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 131, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !ci->speed )
    return 1i64;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
  }
  if ( ci->speed )
    return 0i64;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vucomiss xmm0, xmm1
  }
  return !ci->speed;
}

/*
==============
PlayerASM_IsTurning
==============
*/
__int64 PlayerASM_IsTurning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 
  characterInfo_t *ci; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return (unsigned int)PlayerState->turnRemaining;
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 149, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->legs.yawing != 0;
}

/*
==============
PlayerASM_IsTurningLeft
==============
*/
_BOOL8 PlayerASM_IsTurningLeft(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 
  _BOOL8 result; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return PlayerState->turnRemaining && PlayerState->turnDirection;
  _RBX = parameters->ci;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 169, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  __asm { vmovss  xmm0, cs:__real@3a83126f }
  result = 0i64;
  __asm { vcomiss xmm0, dword ptr [rbx+8C0h] }
  return result;
}

/*
==============
PlayerASM_IsTurningRight
==============
*/
_BOOL8 PlayerASM_IsTurningRight(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return PlayerState->turnRemaining && !PlayerState->turnDirection;
  _RBX = parameters->ci;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 189, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:__real@ba83126f
    vcomiss xmm0, dword ptr [rbx+8C0h]
  }
  return 0i64;
}

/*
==============
PlayerASM_IsTransitionFrom
==============
*/
int PlayerASM_IsTransitionFrom(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_IsTransitionFromInternal(context, parameters, 1);
}

/*
==============
PlayerASM_IsTransitionFromNoUpdate
==============
*/
int PlayerASM_IsTransitionFromNoUpdate(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_IsTransitionFromInternal(context, parameters, 0);
}

/*
==============
PlayerASM_EventFired
==============
*/
_BOOL8 PlayerASM_EventFired(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  scr_string_t StringParam; 
  unsigned __int8 m_NumEvents; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 201, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 204, ASSERT_TYPE_ASSERT, "(eventName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "eventName != NULL_SCR_STRING") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  return m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, StringParam);
}

/*
==============
PlayerASM_ChooseAnim
==============
*/
int PlayerASM_ChooseAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int numParams; 
  scr_string_t StringParam; 

  numParams = parameters->numParams;
  if ( !numParams )
    return PlayerASM_ChooseRandomAnimInternal(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, (const scr_string_t)parameters->stateName);
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, numParams);
  return BG_PlayerASM_LookupAnimFromAlias(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->stateName, StringParam);
}

/*
==============
PlayerASM_UpdateAnimChoice
==============
*/
__int64 PlayerASM_UpdateAnimChoice(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  float v9; 
  PlayerASM_AnimSlot slot; 

  if ( PlayerASM_IsAnimChoiceUpdateNeeded(context, parameters->asmName, parameters->entNum, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]) )
  {
    entryIndex = PlayerASM_GetAnim(context, parameters);
    v5 = parameters->slot[0];
    gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
    __asm { vmovss  xmm0, cs:__real@3f800000 }
    LOBYTE(slot) = v5;
    __asm { vmovss  [rsp+58h+var_20], xmm0 }
    BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, v9, slot);
  }
  return 0i64;
}

/*
==============
PlayerASM_PlayAnimState
==============
*/
__int64 PlayerASM_PlayAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  float v9; 
  PlayerASM_AnimSlot slot; 

  entryIndex = PlayerASM_GetAnim(context, parameters);
  v5 = parameters->slot[0];
  gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
  __asm { vmovss  xmm0, cs:__real@3f800000 }
  LOBYTE(slot) = v5;
  __asm { vmovss  [rsp+58h+var_20], xmm0 }
  BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, v9, slot);
  return 0i64;
}

/*
==============
PlayerASM_LoopAnimState
==============
*/
__int64 PlayerASM_LoopAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  scr_string_t StringParam; 
  unsigned __int8 m_NumEvents; 
  BgStatic *ActiveStatics; 
  characterInfo_t *CharacterInfo; 
  int entryIndex; 
  char v10; 
  int gameTime; 
  float v14; 
  PlayerASM_AnimSlot slot; 
  PlayerASM_Parameters parametersa; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 201, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 204, ASSERT_TYPE_ASSERT, "(eventName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "eventName != NULL_SCR_STRING") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  if ( m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, StringParam) )
  {
    ActiveStatics = BgStatic::GetActiveStatics();
    CharacterInfo = BG_GetCharacterInfo(ActiveStatics, parameters->entNum);
    if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 530, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    parametersa.pAsm = parameters->pAsm;
    parametersa.entNum = parameters->entNum;
    parametersa.asmName = parameters->asmName;
    *(_QWORD *)&parametersa.noteName = 0i64;
    parametersa.pParams = NULL;
    parametersa.slot[0] = parameters->slot[0];
    parametersa.stateName = parameters->stateName;
    parametersa.ci = CharacterInfo;
    entryIndex = PlayerASM_GetAnim(context, &parametersa);
    v10 = parameters->slot[0];
    gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
    __asm { vmovss  xmm0, cs:__real@3f800000 }
    LOBYTE(slot) = v10;
    __asm { vmovss  [rsp+98h+var_60], xmm0 }
    BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, v14, slot);
  }
  return 0i64;
}

/*
==============
PlayerASM_AnimationFinished
==============
*/
_BOOL8 PlayerASM_AnimationFinished(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  unsigned __int8 m_NumEvents; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 301, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  return m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, (const scr_string_t)scr_const.end);
}

/*
==============
PlayerASM_ClearAnimState
==============
*/
__int64 PlayerASM_ClearAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  BG_PlayerASM_ClearState(context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  return 0i64;
}

/*
==============
PlayerASM_IsForwardToBackTransition
==============
*/

__int64 __fastcall PlayerASM_IsForwardToBackTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters, __int64 a3, double _XMM3_8)
{
  char v12; 
  char v13; 
  __int64 result; 

  _RDI = parameters->ci;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 705, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm1, dword ptr [rdi+0A14h]
    vmovss  xmm2, dword ptr [rbx+28h]
    vxorps  xmm3, xmm3, xmm3
    vcomiss xmm1, xmm3
  }
  if ( v12 )
  {
    __asm
    {
      vsubss  xmm0, xmm6, xmm2
      vcomiss xmm1, xmm0
    }
    if ( v12 )
      goto LABEL_17;
    __asm { vcomiss xmm1, xmm3 }
  }
  __asm
  {
    vaddss  xmm0, xmm2, xmm7
    vcomiss xmm1, xmm0
  }
  if ( v12 | v13 )
  {
    result = 0i64;
    goto LABEL_19;
  }
LABEL_17:
  result = 1i64;
LABEL_19:
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_IsBackToForwardTransition
==============
*/

__int64 __fastcall PlayerASM_IsBackToForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters, __int64 a3, double _XMM3_8)
{
  char v12; 
  char v13; 
  __int64 result; 

  _RDI = parameters->ci;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 728, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm1, dword ptr [rdi+0A14h]
    vmovss  xmm2, dword ptr [rbx+28h]
    vxorps  xmm3, xmm3, xmm3
    vcomiss xmm1, xmm3
  }
  if ( !v12 )
  {
LABEL_16:
    __asm
    {
      vsubss  xmm0, xmm7, xmm2
      vcomiss xmm1, xmm0
    }
    if ( v12 )
      goto LABEL_17;
LABEL_18:
    result = 0i64;
    goto LABEL_19;
  }
  __asm
  {
    vaddss  xmm0, xmm2, xmm6
    vcomiss xmm1, xmm0
  }
  if ( v12 | v13 )
  {
    __asm { vcomiss xmm1, xmm3 }
    if ( v12 )
      goto LABEL_18;
    goto LABEL_16;
  }
LABEL_17:
  result = 1i64;
LABEL_19:
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_IsTransitionReverse
==============
*/
__int64 PlayerASM_IsTransitionReverse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  int v10; 
  const char *v12; 
  __int64 v17; 
  int time; 
  char v25; 
  char v26; 
  __int64 result; 

  ci = parameters->ci;
  __asm { vmovaps [rsp+88h+var_38], xmm7 }
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 895, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  v10 = context->const_ps->serverTime - 250;
  if ( v10 < 0 )
    v10 = 0;
  if ( ci->clientConditions[4][0] == 1 )
  {
    _RDI = DCONST_DVARFLT_playerasm_loco_reverse_min_strength_crouch;
    if ( DCONST_DVARFLT_playerasm_loco_reverse_min_strength_crouch )
      goto LABEL_13;
    v12 = "playerasm_loco_reverse_min_strength_crouch";
  }
  else
  {
    _RDI = DCONST_DVARFLT_playerasm_loco_reverse_min_strength;
    if ( DCONST_DVARFLT_playerasm_loco_reverse_min_strength )
      goto LABEL_13;
    v12 = "playerasm_loco_reverse_min_strength";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v12) )
    __debugbreak();
LABEL_13:
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm6, dword ptr [rdi+28h] }
  _RDI = DCONST_DVARFLT_playerasm_loco_reverse_angle_delta;
  if ( !DCONST_DVARFLT_playerasm_loco_reverse_angle_delta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_reverse_angle_delta") )
    __debugbreak();
  __asm { vmovaps [rsp+88h+var_48], xmm8 }
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm7, dword ptr [rdi+28h] }
  if ( ci->playerASMLocomotion.cmdBuffer[0].time )
  {
    if ( ci->playerASMLocomotion.cmdBuffer[1].time > 0 )
    {
      __asm { vmovss  xmm8, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff }
      v17 = 1i64;
      time = ci->playerASMLocomotion.cmdBuffer[1].time;
      while ( time >= v10 && v17 < 6 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vcomiss xmm0, xmm6
        }
        if ( (unsigned __int64)v17 >= 6 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vcomiss xmm0, xmm6
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, eax; angle2
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax; angle1
          }
          *(double *)&_XMM0 = AngleDelta(*(const float *)&_XMM0, *(const float *)&_XMM1);
          __asm
          {
            vandps  xmm0, xmm0, xmm8
            vcomiss xmm0, xmm7
          }
          if ( !(v25 | v26) )
          {
            if ( !PlayerASM_ET_IsAnyStanceTransition(context, parameters) )
              goto LABEL_28;
            break;
          }
        }
        time = ci->playerASMLocomotion.cmdBuffer[++v17].time;
        if ( time <= 0 )
        {
          result = 0i64;
          goto LABEL_29;
        }
      }
    }
    result = 0i64;
  }
  else
  {
LABEL_28:
    result = 1i64;
  }
LABEL_29:
  __asm
  {
    vmovaps xmm8, [rsp+88h+var_48]
    vmovaps xmm6, [rsp+88h+var_28]
    vmovaps xmm7, [rsp+88h+var_38]
  }
  return result;
}

/*
==============
PlayerASM_IsStickMovingForward
==============
*/
_BOOL8 PlayerASM_IsStickMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 816, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  LOWORD(_EAX) = ci->playerASMLocomotion.cmdBuffer[0].angle;
  if ( !(_WORD)_EAX )
    return 0i64;
  if ( !ci->playerASMLocomotion.cmdBuffer[0].length )
    return 0i64;
  _EAX = (unsigned __int16)_EAX;
  __asm
  {
    vmovd   xmm0, eax
    vcvtdq2ps xmm0, xmm0
    vmulss  xmm5, xmm0, cs:__real@3b360b61
    vaddss  xmm2, xmm5, cs:__real@3f000000
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm2, 1
    vsubss  xmm1, xmm5, xmm4
    vmulss  xmm0, xmm1, cs:__real@43b40000
    vsubss  xmm0, xmm0, cs:__real@42b40000; angle
  }
  return PlayerASM_IsForwardAngle(*(const float *)&_XMM0);
}

/*
==============
PlayerASM_IsStickMovingBackward
==============
*/
_BOOL8 PlayerASM_IsStickMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 796, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  LOWORD(_EAX) = ci->playerASMLocomotion.cmdBuffer[0].angle;
  if ( !(_WORD)_EAX )
    return 0i64;
  if ( !ci->playerASMLocomotion.cmdBuffer[0].length )
    return 0i64;
  _EAX = (unsigned __int16)_EAX;
  __asm
  {
    vmovd   xmm0, eax
    vcvtdq2ps xmm0, xmm0
    vmulss  xmm5, xmm0, cs:__real@3b360b61
    vaddss  xmm2, xmm5, cs:__real@3f000000
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm2, 1
    vsubss  xmm1, xmm5, xmm4
    vmulss  xmm0, xmm1, cs:__real@43b40000
    vsubss  xmm0, xmm0, cs:__real@42b40000; angle
  }
  return PlayerASM_IsBackwardAngle(*(const float *)&_XMM0);
}

/*
==============
PlayerASM_IsStopForwardTransition
==============
*/
__int64 PlayerASM_IsStopForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  _RBX = parameters->ci;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 946, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( _RBX->speed > 0 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+0A14h]
      vcomiss xmm0, cs:__real@43070000
    }
  }
  return 0i64;
}

/*
==============
PlayerASM_IsStopBackwardTransition
==============
*/
__int64 PlayerASM_IsStopBackwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  _RBX = parameters->ci;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 962, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( _RBX->speed <= 0 )
    return 0i64;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0A14h]
    vcomiss xmm0, cs:__real@43070000
  }
  return 1i64;
}

/*
==============
PlayerASM_SkipHipFlipForwardToBackwardCrouch
==============
*/
int PlayerASM_SkipHipFlipForwardToBackwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int result; 

  _RBX = parameters->ci;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 751, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  _RDI = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm7, dword ptr [rdi+28h] }
  _RDI = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm6, dword ptr [rdi+28h] }
  if ( BG_GetConditionValue(_RBX, 4) == 1 )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+0A14h]
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm1, xmm0
      vaddss  xmm0, xmm6, xmm7
      vcomiss xmm1, xmm0
    }
  }
  result = 0;
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_SkipHipFlipBackwardToForwardCrouch
==============
*/
int PlayerASM_SkipHipFlipBackwardToForwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int result; 

  _RBX = parameters->ci;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 773, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  _RDI = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm7, dword ptr [rdi+28h] }
  _RDI = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm6, dword ptr [rdi+28h] }
  if ( BG_GetConditionValue(_RBX, 4) == 1 )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+0A14h]
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm1, xmm0
      vsubss  xmm0, xmm7, xmm6
      vcomiss xmm1, xmm0
    }
  }
  result = 0;
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_IsStopSpeedGreaterThanThreshold
==============
*/
__int64 PlayerASM_IsStopSpeedGreaterThanThreshold(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  __int64 result; 

  _RDI = parameters->ci;
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 983, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_playerasm_loco_stop_speed_threshold;
  if ( !DCONST_DVARFLT_playerasm_loco_stop_speed_threshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_stop_speed_threshold") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  result = 0i64;
  __asm { vcomiss xmm0, dword ptr [rdi+0A1Ch] }
  return result;
}

/*
==============
PlayerASM_IsMovingForwardMoveType
==============
*/
int PlayerASM_IsMovingForwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 562, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 922960i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMovingBackwardMoveType
==============
*/
int PlayerASM_IsMovingBackwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 586, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 10912i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMovingMoveType
==============
*/
int PlayerASM_IsMovingMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 607, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 933872i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerBiggerThan
==============
*/
__int64 PlayerASM_IsAnimationTimerBiggerThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  unsigned __int8 v5; 
  __int64 result; 
  __int64 v11; 
  int v12; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  if ( context->useEntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 854, ASSERT_TYPE_ASSERT, "(!context->useEntityState)", "%s\n\tPlayerASM_IsAnimationTimerBiggerThan() can be used only inside pmove execution path.", "!context->useEntityState") )
    __debugbreak();
  *(float *)&_XMM0 = PlayerASM_GetTimerThreshold(parameters);
  v5 = parameters->slot[0];
  __asm { vmovaps xmm6, xmm0 }
  if ( v5 >= 2u )
  {
    v12 = 2;
    LODWORD(v11) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 858, ASSERT_TYPE_ASSERT, "(unsigned)( parameters->slot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "parameters->slot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( !parameters->ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 859, ASSERT_TYPE_ASSERT, "(parameters->ci)", (const char *)&queryFormat, "parameters->ci") )
    __debugbreak();
  _RCX = parameters->ci;
  _RDX = 5i64 * (unsigned __int8)parameters->slot[0];
  result = 0i64;
  __asm
  {
    vcomiss xmm6, dword ptr [rcx+rdx*8+0A94h]
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return result;
}

/*
==============
PlayerASM_IsAnimationTimerLessThan
==============
*/
__int64 PlayerASM_IsAnimationTimerLessThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  unsigned __int8 v5; 
  __int64 v11; 
  int v12; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  if ( context->useEntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 874, ASSERT_TYPE_ASSERT, "(!context->useEntityState)", "%s\n\tPlayerASM_IsAnimationTimerLessThan() can be used only inside pmove execution path.", "!context->useEntityState") )
    __debugbreak();
  *(float *)&_XMM0 = PlayerASM_GetTimerThreshold(parameters);
  v5 = parameters->slot[0];
  __asm { vmovaps xmm6, xmm0 }
  if ( v5 >= 2u )
  {
    v12 = 2;
    LODWORD(v11) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 878, ASSERT_TYPE_ASSERT, "(unsigned)( parameters->slot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "parameters->slot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( !parameters->ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 879, ASSERT_TYPE_ASSERT, "(parameters->ci)", (const char *)&queryFormat, "parameters->ci") )
    __debugbreak();
  _RCX = parameters->ci;
  _RDX = 5i64 * (unsigned __int8)parameters->slot[0];
  __asm
  {
    vcomiss xmm6, dword ptr [rcx+rdx*8+0A94h]
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return 0i64;
}

/*
==============
PlayerASM_ChooseRandomAnim
==============
*/
unsigned int PlayerASM_ChooseRandomAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_ChooseRandomAnimInternal(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, (const scr_string_t)parameters->stateName);
}

/*
==============
PlayerASM_ChooseRandomAnimInternal
==============
*/
__int64 PlayerASM_ChooseRandomAnimInternal(const PlayerASM_Context *context, BgPlayer_Asm *pAsm, int entNum, const scr_string_t asmName, const scr_string_t stateName)
{
  unsigned int AnimEntryCount; 
  unsigned int *holdrand; 
  BgPlayer_Asm_vtbl *v11; 
  ASM_Instance *v12; 

  AnimEntryCount = BG_PlayerASM_GetAnimEntryCount(context, stateName);
  if ( AnimEntryCount == 1 )
    return 0i64;
  holdrand = context->holdrand;
  v11 = pAsm->__vftable;
  v12 = pAsm->GetInstance(pAsm, context, (unsigned int)entNum);
  return ((__int64 (__fastcall *)(BgPlayer_Asm *, ASM_Instance *, _QWORD, _QWORD, unsigned int *))v11->irand)(pAsm, v12, 0i64, AnimEntryCount, holdrand);
}

/*
==============
PlayerASM_GetAnim
==============
*/
__int64 PlayerASM_GetAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int numParamsOverride; 
  BgPlayer_Asm *pAsm; 
  scr_string_t asmName; 
  int entNum; 
  ASM_Error v7; 
  const char *v9; 
  const char *v10; 
  int v11; 
  const char *v12; 
  __int64 stateName; 
  int outEntryIndex; 

  numParamsOverride = parameters->numParams;
  pAsm = parameters->pAsm;
  asmName = parameters->asmName;
  entNum = parameters->entNum;
  if ( numParamsOverride <= 0 )
    v7 = Common_Asm::ChooseAnim(pAsm, context, entNum, asmName, (const scr_string_t)parameters->stateName, &outEntryIndex);
  else
    v7 = Common_Asm::ChooseAnimWithParamOverride(pAsm, context, entNum, asmName, (const scr_string_t)parameters->stateName, numParamsOverride, parameters->pParams, &outEntryIndex);
  if ( v7 == ASM_ERR_NO_INST )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB26F8, 1076i64, (unsigned int)parameters->entNum);
    return (unsigned int)outEntryIndex;
  }
  else if ( v7 == ASM_ERR_NO_SUBTREE )
  {
    v9 = SL_ConvertToString(parameters->asmName);
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2730, 1077i64, (unsigned int)parameters->entNum, v9);
    return (unsigned int)outEntryIndex;
  }
  else
  {
    if ( v7 == ASM_ERR_NO_STATE )
    {
      v10 = SL_ConvertToString(parameters->asmName);
      v11 = parameters->entNum;
      v12 = SL_ConvertToString(parameters->stateName);
      LODWORD(stateName) = v11;
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2778, 1078i64, v12, stateName, v10);
    }
    return (unsigned int)outEntryIndex;
  }
}

/*
==============
PlayerASM_GetBuiltinFunc
==============
*/
int (*PlayerASM_GetBuiltinFunc(int i))(const PlayerASM_Context *, const PlayerASM_Parameters *)
{
  __int64 v1; 
  int v4; 

  v1 = i;
  if ( (unsigned int)i >= 0xC7 )
  {
    v4 = 199;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 315, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( numFuncs )", "i doesn't index numFuncs\n\t%i not in [0, %i)", i, v4) )
      __debugbreak();
  }
  return s_PlayerASMBuiltinFuncs_7[v1].m_Func;
}

/*
==============
PlayerASM_GetStateNameTransitionFrom
==============
*/
__int64 PlayerASM_GetStateNameTransitionFrom(const PlayerASM_Context *context, const PlayerASM_AnimSlot slot)
{
  bool v2; 
  const playerState_s *const_ps; 
  unsigned int v4; 
  unsigned int v5; 
  const Animset *AnimsetByIndex; 
  AnimsetAlias *v7; 
  unsigned int v8; 
  __int64 m_FuncID; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  AnimsetAlias *ppOutAlias; 
  AnimsetAnim *ppOutAnim; 
  unsigned int animsetIndex; 
  int entryIndex; 
  int stateIndex; 

  v2 = !context->useEntityState;
  const_ps = context->const_ps;
  if ( v2 )
    v4 = BG_PlayerASM_UnpackAnimFromPs(const_ps, slot, &animsetIndex, (unsigned int *)&stateIndex, (unsigned int *)&entryIndex);
  else
    v4 = BG_PlayerASM_UnpackAnimFromEntity((const entityState_t *)const_ps, slot, &animsetIndex, (unsigned int *)&stateIndex, (unsigned int *)&entryIndex);
  if ( !v4 )
    return 0i64;
  v5 = animsetIndex;
  if ( animsetIndex >= 4 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 232, ASSERT_TYPE_ASSERT, "(unsigned)( animsetIndex ) < (unsigned)( (1 << 2) )", "animsetIndex doesn't index MAX_PLAYERANIM_ANIMSET_COUNT\n\t%i not in [0, %i)", animsetIndex, 4) )
      __debugbreak();
    v5 = animsetIndex;
  }
  AnimsetByIndex = BG_PlayerASM_GetAnimsetByIndex(v5);
  if ( !AnimsetByIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 235, ASSERT_TYPE_ASSERT, "(pAnimset)", (const char *)&queryFormat, "pAnimset") )
    __debugbreak();
  BG_Animset_GetAliasAndAnimFromStateIndexAndEntry(AnimsetByIndex, stateIndex, entryIndex, (const AnimsetAlias **)&ppOutAlias, (const AnimsetAnim **)&ppOutAnim);
  v7 = ppOutAlias;
  v8 = 0;
  if ( !ppOutAlias->numFuncs )
    return 0i64;
  while ( 1 )
  {
    m_FuncID = v7->funcs[v8].m_FuncID;
    if ( (unsigned int)m_FuncID >= 0xC7 )
    {
      LODWORD(v13) = 199;
      LODWORD(v12) = v7->funcs[v8].m_FuncID;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 315, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( numFuncs )", "i doesn't index numFuncs\n\t%i not in [0, %i)", v12, v13) )
        __debugbreak();
      v7 = ppOutAlias;
    }
    if ( s_PlayerASMBuiltinFuncs_7[m_FuncID].m_Func == PlayerASM_IsTransitionFrom )
      break;
    if ( ++v8 >= v7->numFuncs )
      return 0i64;
  }
  v11 = v8;
  if ( v7->funcs[v11].m_NumParams <= 0 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 244, ASSERT_TYPE_ASSERT, "(animsetAlias->funcs[funcIndex].m_NumParams > 0)", (const char *)&queryFormat, "animsetAlias->funcs[funcIndex].m_NumParams > 0") )
      __debugbreak();
    v7 = ppOutAlias;
  }
  return *(_DWORD *)v7->funcs[v11].m_Params;
}

/*
==============
PlayerASM_GetTimerThreshold
==============
*/

float __fastcall PlayerASM_GetTimerThreshold(const PlayerASM_Parameters *parameters, double _XMM1_8)
{
  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( !parameters && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 834, ASSERT_TYPE_ASSERT, "(parameters)", (const char *)&queryFormat, "parameters") )
    __debugbreak();
  if ( parameters->numParams != 1 || (unsigned int)(parameters->pParams->m_Type - 3) > 1 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2850, 6010i64);
  _RAX = parameters->pParams;
  if ( _RAX->m_Type == ParamType_Float )
  {
    __asm { vmovss  xmm6, dword ptr [rax] }
  }
  else
  {
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vcvtsi2ss xmm6, xmm6, dword ptr [rax]
    }
  }
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm6, xmm1
  }
  if ( _RAX->m_Type < (unsigned int)ParamType_Float )
    goto LABEL_12;
  __asm { vcomiss xmm6, cs:__real@3f800000 }
  if ( _RAX->m_Type > (unsigned int)ParamType_Float )
LABEL_12:
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB28B0, 6011i64);
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+48h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
PlayerASM_IsAnimChoiceUpdateNeeded
==============
*/
char PlayerASM_IsAnimChoiceUpdateNeeded(const PlayerASM_Context *context, scr_string_t asmName, int entNum, const PlayerASM_AnimSlot animSlot)
{
  unsigned __int8 v4; 
  const dvar_t *v7; 
  BgStatic *ActiveStatics; 
  characterInfo_t *CharacterInfo; 
  const Animset *AnimsetByIndex; 
  PlayerASM_Instance *InstanceBySlot; 
  const char *v12; 
  const char *v13; 
  AnimsetAlias *v14; 
  AnimsetState *v15; 
  bool v16; 
  const char *v17; 
  const char *v18; 
  unsigned __int8 m_NumEvents; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  const char *v24; 
  unsigned int outAnimSetIndex; 
  unsigned int outAnimEntry; 
  AnimsetState *outState; 
  AnimsetAlias *ppOutAlias; 
  AnimsetAnim *ppOutAnim; 
  unsigned int outAnimState; 

  v4 = animSlot;
  if ( (unsigned __int8)animSlot >= (unsigned int)COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 361, ASSERT_TYPE_ASSERT, "(unsigned)( animSlot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "animSlot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", (unsigned __int8)animSlot, 2) )
    __debugbreak();
  v7 = DCONST_DVARBOOL_playerasm_enableConditionMask;
  if ( !DCONST_DVARBOOL_playerasm_enableConditionMask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_enableConditionMask") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled || context->disableCache )
    return 1;
  ActiveStatics = BgStatic::GetActiveStatics();
  CharacterInfo = BG_GetCharacterInfo(ActiveStatics, entNum);
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 375, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !BG_PlayerASM_UnpackAnimFromPs(context->ps, (const PlayerASM_AnimSlot)v4, &outAnimSetIndex, &outAnimState, &outAnimEntry) )
    return 1;
  AnimsetByIndex = BG_PlayerASM_GetAnimsetByIndex(outAnimSetIndex);
  if ( !AnimsetByIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 386, ASSERT_TYPE_ASSERT, "(pAnimset)", (const char *)&queryFormat, "pAnimset") )
    __debugbreak();
  if ( !BG_PlayerASM_IsAnimEntryValid(AnimsetByIndex, outAnimState, outAnimEntry) )
    return 1;
  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(context->playerAsm, context, (const PlayerASM_AnimSlot)v4);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 395, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  BG_PlayerASM_GetStateInfoByIndex(outAnimSetIndex, outAnimState, &outState);
  if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 398, ASSERT_TYPE_ASSERT, "(animsetState)", (const char *)&queryFormat, "animsetState") )
    __debugbreak();
  if ( *outState->u.m_AIAnimsetState )
  {
    if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
    {
      v12 = "Server";
      if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
        v12 = "Client";
      v13 = SL_ConvertToString(outState->name);
      Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s' - invalid mask found. \n", v13, v12);
    }
    return 1;
  }
  BG_Animset_GetAliasAndAnimFromStateIndexAndEntry(AnimsetByIndex, outAnimState, outAnimEntry, (const AnimsetAlias **)&ppOutAlias, (const AnimsetAnim **)&ppOutAnim);
  v14 = ppOutAlias;
  if ( !ppOutAlias )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 413, ASSERT_TYPE_ASSERT, "(animsetAlias)", (const char *)&queryFormat, "animsetAlias") )
      __debugbreak();
    v14 = ppOutAlias;
  }
  v15 = outState;
  if ( outState->numAnimAliases != 1 )
  {
    v16 = v14->numAnims <= 1;
LABEL_39:
    if ( !v16 )
    {
      m_NumEvents = InstanceBySlot->m_NumEvents;
      if ( m_NumEvents )
      {
        if ( Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, (const scr_string_t)scr_const.end) )
        {
          if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
          {
            v21 = "Server";
            if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
              v21 = "Client";
            v22 = SL_ConvertToString(outState->name);
            Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s' - notetrack event found. \n", v22, v21);
          }
          return 1;
        }
        v15 = outState;
      }
    }
    if ( !BG_PlayerASM_EvalConditionMasks(CharacterInfo, InstanceBySlot, (const PlayerASM_ConditionMask *)v15->u.m_AIAnimsetState, v15->name) )
    {
      if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
      {
        v23 = "Server";
        if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
          v23 = "Client";
        v24 = SL_ConvertToString(outState->name);
        Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s'.\n", v24, v23);
      }
      return 1;
    }
    return 0;
  }
  v16 = v14->numAnims <= 1;
  if ( v14->numAnims != 1 )
    goto LABEL_39;
  if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") != 1 )
    return 0;
  v17 = "Server";
  if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
    v17 = "Client";
  v18 = SL_ConvertToString(outState->name);
  Com_PrintWarning(19, "PlayerASM: Skipped update alias: '%s' on '%s' - single animation found. \n", v18, v17);
  return 0;
}

/*
==============
PlayerASM_IsBackwardAngle
==============
*/

bool __fastcall PlayerASM_IsBackwardAngle(double angle)
{
  char v7; 
  char v8; 
  bool result; 

  _RBX = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps xmm6, xmm0
  }
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vcomiss xmm6, xmm7 }
  if ( !(v7 | v8) )
    goto LABEL_10;
  __asm { vcomiss xmm6, dword ptr [rbx+28h] }
  if ( v7 )
LABEL_10:
    result = 1;
  else
    result = 0;
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_IsForwardAngle
==============
*/

bool __fastcall PlayerASM_IsForwardAngle(double angle)
{
  char v7; 
  char v8; 
  bool result; 

  _RBX = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps xmm6, xmm0
  }
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( !v7 )
  {
LABEL_10:
    __asm { vcomiss xmm6, xmm7 }
    if ( v7 )
      goto LABEL_11;
LABEL_12:
    result = 0;
    goto LABEL_13;
  }
  __asm { vcomiss xmm6, dword ptr [rbx+28h] }
  if ( v7 | v8 )
  {
    __asm { vcomiss xmm6, xmm0 }
    if ( v7 )
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_11:
  result = 1;
LABEL_13:
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
PlayerASM_IsTransitionFromInternal
==============
*/
_BOOL8 PlayerASM_IsTransitionFromInternal(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters, const bool update)
{
  ASM_Instance *Subtree; 
  scr_string_t asmName; 
  scr_string_t StringParam; 
  int m_PrevState; 
  const ASM_State *State; 

  Subtree = parameters->pAsm->GetInstance(parameters->pAsm, context, (unsigned int)parameters->entNum);
  if ( !Subtree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 257, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  asmName = parameters->asmName;
  if ( Subtree->m_pASM->m_Name != asmName )
  {
    Subtree = Common_Asm::Utils::GetSubtree(Subtree, asmName);
    if ( !Subtree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 262, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
      __debugbreak();
  }
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 266, ASSERT_TYPE_ASSERT, "(stateName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "stateName != NULL_SCR_STRING") )
    __debugbreak();
  m_PrevState = Subtree->m_PrevState;
  if ( m_PrevState == -1 )
  {
    return update && (unsigned int)PlayerASM_GetStateNameTransitionFrom(context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]) == StringParam;
  }
  else
  {
    State = Common_Asm::Utils::GetState(Subtree->m_pASM, m_PrevState);
    if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 271, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
    return State->m_Name == StringParam;
  }
}

/*
==============
PlayerASM_PlayPredictedAnim
==============
*/
__int64 PlayerASM_PlayPredictedAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  float v9; 
  PlayerASM_AnimSlot slot; 

  entryIndex = PlayerASM_ChooseAnimByConditions<1>(context, parameters);
  if ( !entryIndex )
    return 0i64;
  v5 = parameters->slot[0];
  gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
  __asm { vmovss  xmm0, cs:__real@3f800000 }
  LOBYTE(slot) = v5;
  __asm { vmovss  [rsp+58h+var_20], xmm0 }
  BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, v9, slot);
  return 1i64;
}

/*
==============
PlayerASM_TestBool
==============
*/
_BOOL8 PlayerASM_TestBool(bool b, const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  if ( parameters->numParams != 1 )
    return b;
  if ( parameters->pParams->m_Type != ParamType_Bool && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 45, ASSERT_TYPE_ASSERT, "(parameters->pParams[0].m_Type == ParamType_Bool)", (const char *)&queryFormat, "parameters->pParams[0].m_Type == ParamType_Bool") )
    __debugbreak();
  return parameters->pParams->u.m_Bool == b;
}

