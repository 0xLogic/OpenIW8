/*
==============
hkArray<XModel const *,hkContainerHeapAllocator>::~hkArray<XModel const *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<XModel const *,hkContainerHeapAllocator>::~hkArray<XModel const *,hkContainerHeapAllocator>(hkArray<XModel const *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEBUXModel@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hk3PointDisplayMaterial>::copy<hk3PointDisplayMaterial>
==============
*/

void __fastcall hkArrayBase<hk3PointDisplayMaterial>::copy<hk3PointDisplayMaterial>(hk3PointDisplayMaterial *dst, const hk3PointDisplayMaterial *src, int n)
{
  ??$copy@Uhk3PointDisplayMaterial@@@?$hkArrayBase@Uhk3PointDisplayMaterial@@@@SAXPEAUhk3PointDisplayMaterial@@PEBU1@H@Z(dst, src, n);
}

/*
==============
hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::~hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::~hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>(hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@U?$MapTuple@_KH@hkHashMapDetail@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>::~hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>::~hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>(hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UHavokPhysicsFX_ScaledShapeAsset@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkVector4f,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkVector4f,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhkVector4f@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>::~hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>::~hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>(hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUhknpShapeKeyMask@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hkGeometryDecorations::Text>::copy<hkGeometryDecorations::Text>
==============
*/

void __fastcall hkArrayBase<hkGeometryDecorations::Text>::copy<hkGeometryDecorations::Text>(hkGeometryDecorations::Text *dst, const hkGeometryDecorations::Text *src, int n)
{
  ??$copy@UText@hkGeometryDecorations@@@?$hkArrayBase@UText@hkGeometryDecorations@@@@SAXPEAUText@hkGeometryDecorations@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<Physics_DetailHitData,hkContainerHeapAllocator>::~hkArray<Physics_DetailHitData,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<Physics_DetailHitData,hkContainerHeapAllocator>::~hkArray<Physics_DetailHitData,hkContainerHeapAllocator>(hkArray<Physics_DetailHitData,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UPhysics_DetailHitData@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>::~hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>::~hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>(hkArray<hkGeometry::Triangle,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UTriangle@hkGeometry@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpMotionProperties,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hknpMotionProperties,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhknpMotionProperties@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArrayBase<hk3dTextDisplayMaterial>::copy<hk3dTextDisplayMaterial>
==============
*/

void __fastcall hkArrayBase<hk3dTextDisplayMaterial>::copy<hk3dTextDisplayMaterial>(hk3dTextDisplayMaterial *dst, const hk3dTextDisplayMaterial *src, int n)
{
  ??$copy@Uhk3dTextDisplayMaterial@@@?$hkArrayBase@Uhk3dTextDisplayMaterial@@@@SAXPEAUhk3dTextDisplayMaterial@@PEBU1@H@Z(dst, src, n);
}

/*
==============
hkArrayBase<hk1PointDisplayMaterial>::copy<hk1PointDisplayMaterial>
==============
*/

void __fastcall hkArrayBase<hk1PointDisplayMaterial>::copy<hk1PointDisplayMaterial>(hk1PointDisplayMaterial *dst, const hk1PointDisplayMaterial *src, int n)
{
  ??$copy@Uhk1PointDisplayMaterial@@@?$hkArrayBase@Uhk1PointDisplayMaterial@@@@SAXPEAUhk1PointDisplayMaterial@@PEBU1@H@Z(dst, src, n);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkStringPtr,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkStringPtr,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhkStringPtr@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<hknpCollisionResult,hkContainerHeapAllocator>::~hkArray<hknpCollisionResult,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpCollisionResult,hkContainerHeapAllocator>::~hkArray<hknpCollisionResult,hkContainerHeapAllocator>(hkArray<hknpCollisionResult,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhknpCollisionResult@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@UXModelCollisionTagData@HavokPhysicsXModelLOD@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArrayBase<hkGeometryDecorations::ConvexFace>::copy<hkGeometryDecorations::ConvexFace>
==============
*/

void __fastcall hkArrayBase<hkGeometryDecorations::ConvexFace>::copy<hkGeometryDecorations::ConvexFace>(hkGeometryDecorations::ConvexFace *dst, const hkGeometryDecorations::ConvexFace *src, int n)
{
  ??$copy@UConvexFace@hkGeometryDecorations@@@?$hkArrayBase@UConvexFace@hkGeometryDecorations@@@@SAXPEAUConvexFace@hkGeometryDecorations@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<hkProcess *,hkContainerHeapAllocator>::~hkArray<hkProcess *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkProcess *,hkContainerHeapAllocator>::~hkArray<hkProcess *,hkContainerHeapAllocator>(hkArray<hkProcess *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAVhkProcess@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<char,hkContainerHeapAllocator>::~hkArray<char,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<char,hkContainerHeapAllocator>::~hkArray<char,hkContainerHeapAllocator>(hkArray<char,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@DUhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUDisplayGeoList@HavokPhysicsDisplayHandler@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@UShapeTagData@HavokPhysicsShapeList@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<hkMassElement,hkContainerHeapAllocator>::~hkArray<hkMassElement,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkMassElement,hkContainerHeapAllocator>::~hkArray<hkMassElement,hkContainerHeapAllocator>(hkArray<hkMassElement,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhkMassElement@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>::~hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>::~hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>(hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UHavokPhysicsSVFX_DrawSVFX_AssetData@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<float,hkContainerHeapAllocator>::~hkArray<float,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<float,hkContainerHeapAllocator>::~hkArray<float,hkContainerHeapAllocator>(hkArray<float,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@MUhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UDisplayLine@HavokPhysicsDisplayHandler@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>::~hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>::~hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>(hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAVhknpCollisionQueryCollector@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkProcessContext *,hkContainerHeapAllocator>::~hkArray<hkProcessContext *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkProcessContext *,hkContainerHeapAllocator>::~hkArray<hkProcessContext *,hkContainerHeapAllocator>(hkArray<hkProcessContext *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAVhkProcessContext@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>::~hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>::~hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>(hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UIgnoreEntity@HavokPhysics_IgnoreBodies@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hknpBodyId,hkContainerHeapAllocator>::~hkArray<hknpBodyId,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpBodyId,hkContainerHeapAllocator>::~hkArray<hknpBodyId,hkContainerHeapAllocator>(hkArray<hknpBodyId,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<hkReflect::Typedef::hkUlong_Tag,int>,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<hkReflect::Typedef::hkUlong_Tag,int>,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@U?$MapTuple@UhkUlong_Tag@Typedef@hkReflect@@H@hkHashMapDetail@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@U?$MapTuple@_KH@hkHashMapDetail@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>(hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UStaticModels_HavokShapeInstance@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hkGeometryDecorations::Point>::copy<hkGeometryDecorations::Point>
==============
*/

void __fastcall hkArrayBase<hkGeometryDecorations::Point>::copy<hkGeometryDecorations::Point>(hkGeometryDecorations::Point *dst, const hkGeometryDecorations::Point *src, int n)
{
  ??$copy@UPoint@hkGeometryDecorations@@@?$hkArrayBase@UPoint@hkGeometryDecorations@@@@SAXPEAUPoint@hkGeometryDecorations@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>::~hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>::~hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>(hkArray<hkDisplayGeometry *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAVhkDisplayGeometry@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<bool,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<bool,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@_NUhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>(hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUWorldData@HavokPhysicsShapeViewer@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hknpBodyId>::copy<hknpBodyId>
==============
*/

void __fastcall hkArrayBase<hknpBodyId>::copy<hknpBodyId>(hknpBodyId *dst, const hknpBodyId *src, int n)
{
  ??$copy@UhknpBodyId@@@?$hkArrayBase@UhknpBodyId@@@@SAXPEAUhknpBodyId@@PEBU1@H@Z(dst, src, n);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkVector4_Tag,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkVector4_Tag,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@UhkVector4_Tag@Typedef@hkReflect@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<int,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<int,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@HUhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>::~hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>::~hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>(hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUPhysicsFXPipeline@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<int,hkContainerHeapAllocator>::~hkArray<int,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<int,hkContainerHeapAllocator>::~hkArray<int,hkContainerHeapAllocator>(hkArray<int,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@HUhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>(hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UVelocityInfo@StaticModels_HavokShape@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkQuaternionf,hkContainerHeapAllocator>::~hkArray<hkQuaternionf,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkQuaternionf,hkContainerHeapAllocator>::~hkArray<hkQuaternionf,hkContainerHeapAllocator>(hkArray<hkQuaternionf,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@VhkQuaternionf@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<float,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<float,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@MUhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpShape *,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hknpShape *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@PEAVhknpShape@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>::~hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>::~hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>(hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UNode@hkcdSimdTree@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<char,hkContainerTempAllocator>::~hkArray<char,hkContainerTempAllocator>
==============
*/

void __fastcall hkArray<char,hkContainerTempAllocator>::~hkArray<char,hkContainerTempAllocator>(hkArray<char,hkContainerTempAllocator> *this)
{
  ??1?$hkArray@DUhkContainerTempAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkTransform_Tag,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkTransform_Tag,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@UhkTransform_Tag@Typedef@hkReflect@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArrayBase<HavokPhysicsXModelLOD::XModelCollisionTagData>::copy<HavokPhysicsXModelLOD::XModelCollisionTagData>
==============
*/

void __fastcall hkArrayBase<HavokPhysicsXModelLOD::XModelCollisionTagData>::copy<HavokPhysicsXModelLOD::XModelCollisionTagData>(HavokPhysicsXModelLOD::XModelCollisionTagData *dst, const HavokPhysicsXModelLOD::XModelCollisionTagData *src, int n)
{
  ??$copy@UXModelCollisionTagData@HavokPhysicsXModelLOD@@@?$hkArrayBase@UXModelCollisionTagData@HavokPhysicsXModelLOD@@@@SAXPEAUXModelCollisionTagData@HavokPhysicsXModelLOD@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::~hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::~hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>(hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UBulletImpact@HavokCloth_PhysicsProxyAction@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<bool,hkContainerHeapAllocator>::~hkArray<bool,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<bool,hkContainerHeapAllocator>::~hkArray<bool,hkContainerHeapAllocator>(hkArray<bool,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@_NUhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<PhysicsAsset *,hkContainerHeapAllocator>::~hkArray<PhysicsAsset *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<PhysicsAsset *,hkContainerHeapAllocator>::~hkArray<PhysicsAsset *,hkContainerHeapAllocator>(hkArray<PhysicsAsset *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUPhysicsAsset@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hkGeometry::Triangle>::copy<hkGeometry::Triangle>
==============
*/

void __fastcall hkArrayBase<hkGeometry::Triangle>::copy<hkGeometry::Triangle>(hkGeometry::Triangle *dst, const hkGeometry::Triangle *src, int n)
{
  ??$copy@UTriangle@hkGeometry@@@?$hkArrayBase@UTriangle@hkGeometry@@@@SAXPEAUTriangle@hkGeometry@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<hclClothInstance *,hkContainerHeapAllocator>::~hkArray<hclClothInstance *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hclClothInstance *,hkContainerHeapAllocator>::~hkArray<hclClothInstance *,hkContainerHeapAllocator>(hkArray<hclClothInstance *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAVhclClothInstance@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hk2PointDisplayMaterial>::copy<hk2PointDisplayMaterial>
==============
*/

void __fastcall hkArrayBase<hk2PointDisplayMaterial>::copy<hk2PointDisplayMaterial>(hk2PointDisplayMaterial *dst, const hk2PointDisplayMaterial *src, int n)
{
  ??$copy@Uhk2PointDisplayMaterial@@@?$hkArrayBase@Uhk2PointDisplayMaterial@@@@SAXPEAUhk2PointDisplayMaterial@@PEBU1@H@Z(dst, src, n);
}

/*
==============
hkArray<char const *,hkContainerHeapAllocator>::~hkArray<char const *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<char const *,hkContainerHeapAllocator>::~hkArray<char const *,hkContainerHeapAllocator>(hkArray<char const *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEBDUhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<Particle_OnImpactData,hkContainerHeapAllocator>::~hkArray<Particle_OnImpactData,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<Particle_OnImpactData,hkContainerHeapAllocator>::~hkArray<Particle_OnImpactData,hkContainerHeapAllocator>(hkArray<Particle_OnImpactData,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UParticle_OnImpactData@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<hkGeometryDecorations::Edge>::copy<hkGeometryDecorations::Edge>
==============
*/

void __fastcall hkArrayBase<hkGeometryDecorations::Edge>::copy<hkGeometryDecorations::Edge>(hkGeometryDecorations::Edge *dst, const hkGeometryDecorations::Edge *src, int n)
{
  ??$copy@UEdge@hkGeometryDecorations@@@?$hkArrayBase@UEdge@hkGeometryDecorations@@@@SAXPEAUEdge@hkGeometryDecorations@@PEBU12@H@Z(dst, src, n);
}

/*
==============
hkArray<hkStringPtr,hkContainerHeapAllocator>::~hkArray<hkStringPtr,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkStringPtr,hkContainerHeapAllocator>::~hkArray<hkStringPtr,hkContainerHeapAllocator>(hkArray<hkStringPtr,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@VhkStringPtr@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkTransformf,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkTransformf,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhkTransformf@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpMaterial,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hknpMaterial,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhknpMaterial@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpConvexShape *,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hknpConvexShape *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@PEAVhknpConvexShape@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<PhysicsFXShape *,hkContainerHeapAllocator>::~hkArray<PhysicsFXShape *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<PhysicsFXShape *,hkContainerHeapAllocator>::~hkArray<PhysicsFXShape *,hkContainerHeapAllocator>(hkArray<PhysicsFXShape *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEAUPhysicsFXShape@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkReflect::Type const *,hkContainerHeapAllocator>::~hkArray<hkReflect::Type const *,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkReflect::Type const *,hkContainerHeapAllocator>::~hkArray<hkReflect::Type const *,hkContainerHeapAllocator>(hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@PEBVType@hkReflect@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkVector4f,hkContainerHeapAllocator>::~hkArray<hkVector4f,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkVector4f,hkContainerHeapAllocator>::~hkArray<hkVector4f,hkContainerHeapAllocator>(hkArray<hkVector4f,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@VhkVector4f@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkcdRay,hkContainerHeapAllocator>::~hkArray<hkcdRay,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkcdRay,hkContainerHeapAllocator>::~hkArray<hkcdRay,hkContainerHeapAllocator>(hkArray<hkcdRay,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhkcdRay@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hknpMotionProperties,hkContainerHeapAllocator>::~hkArray<hknpMotionProperties,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpMotionProperties,hkContainerHeapAllocator>::~hkArray<hknpMotionProperties,hkContainerHeapAllocator>(hkArray<hknpMotionProperties,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@VhknpMotionProperties@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArrayBase<int>::copy<int>
==============
*/

void __fastcall hkArrayBase<int>::copy<int>(int *dst, const int *src, int n)
{
  ??$copy@H@?$hkArrayBase@H@@SAXPEAHPEBHH@Z(dst, src, n);
}

/*
==============
hkArrayBase<hkVector4f>::copy<hkVector4f>
==============
*/

void __fastcall hkArrayBase<hkVector4f>::copy<hkVector4f>(hkVector4f *dst, const hkVector4f *src, int n)
{
  ??$copy@VhkVector4f@@@?$hkArrayBase@VhkVector4f@@@@SAXPEAVhkVector4f@@PEBV1@H@Z(dst, src, n);
}

/*
==============
hkArray<hknpShapeInstance,hkContainerHeapAllocator>::~hkArray<hknpShapeInstance,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hknpShapeInstance,hkContainerHeapAllocator>::~hkArray<hknpShapeInstance,hkContainerHeapAllocator>(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UDisplay3DText@HavokPhysicsDisplayHandler@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hkAabb,hkContainerHeapAllocator>::~hkArray<hkAabb,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkAabb,hkContainerHeapAllocator>::~hkArray<hkAabb,hkContainerHeapAllocator>(hkArray<hkAabb,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@VhkAabb@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UDisplayPoint@HavokPhysicsDisplayHandler@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Type const *,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hkReflect::Type const *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@PEBVType@hkReflect@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpBodyQuality,hkContainerHeapAllocator>::func
==============
*/

void __fastcall hkReflect::Tracker::hkArrayHandler<hknpBodyQuality,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ?func@?$hkArrayHandler@VhknpBodyQuality@@UhkContainerHeapAllocator@@@Tracker@hkReflect@@SAXAEBUVar@3@AEAVhkMemoryTrackerSnapshot@@@Z(var, snapshot);
}

/*
==============
hkArray<hkTimerData,hkContainerHeapAllocator>::~hkArray<hkTimerData,hkContainerHeapAllocator>
==============
*/

void __fastcall hkArray<hkTimerData,hkContainerHeapAllocator>::~hkArray<hkTimerData,hkContainerHeapAllocator>(hkArray<hkTimerData,hkContainerHeapAllocator> *this)
{
  ??1?$hkArray@UhkTimerData@@UhkContainerHeapAllocator@@@@QEAA@XZ(this);
}

/*
==============
hkArray<hknpShapeInstance,hkContainerHeapAllocator>::~hkArray<hknpShapeInstance,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpShapeInstance,hkContainerHeapAllocator>::~hkArray<hknpShapeInstance,hkContainerHeapAllocator>(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int v3; 
  __int64 v4; 
  hkRefPtr<hknpShape const > *p_m_shape; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  v3 = this->m_size - 1;
  v4 = v3;
  if ( v3 >= 0 )
  {
    p_m_shape = &this->m_data[v3].m_shape;
    do
    {
      if ( p_m_shape->m_ptr )
        hkReferencedObject::removeReference(&p_m_shape->m_ptr->hkReferencedObject);
      p_m_shape -= 14;
      --v4;
    }
    while ( v4 >= 0 );
  }
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 112, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hknpBodyId,hkContainerHeapAllocator>::~hkArray<hknpBodyId,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpBodyId,hkContainerHeapAllocator>::~hkArray<hknpBodyId,hkContainerHeapAllocator>(hkArray<hknpBodyId,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkVector4f,hkContainerHeapAllocator>::~hkArray<hkVector4f,hkContainerHeapAllocator>
==============
*/
void hkArray<hkVector4f,hkContainerHeapAllocator>::~hkArray<hkVector4f,hkContainerHeapAllocator>(hkArray<hkVector4f,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Type const *,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkReflect::Type const *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkArray<char,hkContainerTempAllocator>::~hkArray<char,hkContainerTempAllocator>
==============
*/
void hkArray<char,hkContainerTempAllocator>::~hkArray<char,hkContainerTempAllocator>(hkArray<char,hkContainerTempAllocator> *this)
{
  int m_capacityAndFlags; 

  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags < 0 )
  {
    this->m_data = NULL;
    this->m_capacityAndFlags = 0x80000000;
  }
  else
  {
    hkMemoryAllocator::bufFree2(&hkContainerTempAllocator::s_alloc, this->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
    this->m_data = NULL;
    this->m_capacityAndFlags = 0x80000000;
  }
}

/*
==============
hkArray<hkReflect::Type const *,hkContainerHeapAllocator>::~hkArray<hkReflect::Type const *,hkContainerHeapAllocator>
==============
*/
void hkArray<hkReflect::Type const *,hkContainerHeapAllocator>::~hkArray<hkReflect::Type const *,hkContainerHeapAllocator>(hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>
==============
*/
void hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator>(hkArray<StaticModels_HavokShapeInstance,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArrayBase<HavokPhysicsXModelLOD::XModelCollisionTagData>::copy<HavokPhysicsXModelLOD::XModelCollisionTagData>
==============
*/
void hkArrayBase<HavokPhysicsXModelLOD::XModelCollisionTagData>::copy<HavokPhysicsXModelLOD::XModelCollisionTagData>(HavokPhysicsXModelLOD::XModelCollisionTagData *dst, const HavokPhysicsXModelLOD::XModelCollisionTagData *src, int n)
{
  __int64 v3; 
  signed __int64 v4; 

  v3 = n;
  if ( n > 0 )
  {
    v4 = (char *)src - (char *)dst;
    do
    {
      *dst = *(HavokPhysicsXModelLOD::XModelCollisionTagData *)((char *)dst + v4);
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArray<char,hkContainerHeapAllocator>::~hkArray<char,hkContainerHeapAllocator>
==============
*/
void hkArray<char,hkContainerHeapAllocator>::~hkArray<char,hkContainerHeapAllocator>(hkArray<char,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<int,hkContainerHeapAllocator>::~hkArray<int,hkContainerHeapAllocator>
==============
*/
void hkArray<int,hkContainerHeapAllocator>::~hkArray<int,hkContainerHeapAllocator>(hkArray<int,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<PhysicsAsset *,hkContainerHeapAllocator>::~hkArray<PhysicsAsset *,hkContainerHeapAllocator>
==============
*/
void hkArray<PhysicsAsset *,hkContainerHeapAllocator>::~hkArray<PhysicsAsset *,hkContainerHeapAllocator>(hkArray<PhysicsAsset *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>::~hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>
==============
*/
void hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>::~hkArray<hkDisplayGeometry *,hkContainerHeapAllocator>(hkArray<hkDisplayGeometry *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkProcess *,hkContainerHeapAllocator>::~hkArray<hkProcess *,hkContainerHeapAllocator>
==============
*/
void hkArray<hkProcess *,hkContainerHeapAllocator>::~hkArray<hkProcess *,hkContainerHeapAllocator>(hkArray<hkProcess *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkProcessContext *,hkContainerHeapAllocator>::~hkArray<hkProcessContext *,hkContainerHeapAllocator>
==============
*/
void hkArray<hkProcessContext *,hkContainerHeapAllocator>::~hkArray<hkProcessContext *,hkContainerHeapAllocator>(hkArray<hkProcessContext *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>::~hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>::~hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator>(hkArray<hknpCollisionQueryCollector *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<char const *,hkContainerHeapAllocator>::~hkArray<char const *,hkContainerHeapAllocator>
==============
*/
void hkArray<char const *,hkContainerHeapAllocator>::~hkArray<char const *,hkContainerHeapAllocator>(hkArray<char const *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<XModel const *,hkContainerHeapAllocator>::~hkArray<XModel const *,hkContainerHeapAllocator>
==============
*/
void hkArray<XModel const *,hkContainerHeapAllocator>::~hkArray<XModel const *,hkContainerHeapAllocator>(hkArray<XModel const *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>::~hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>::~hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator>(hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkTimerData,hkContainerHeapAllocator>::~hkArray<hkTimerData,hkContainerHeapAllocator>
==============
*/
void hkArray<hkTimerData,hkContainerHeapAllocator>::~hkArray<hkTimerData,hkContainerHeapAllocator>(hkArray<hkTimerData,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkcdRay,hkContainerHeapAllocator>::~hkArray<hkcdRay,hkContainerHeapAllocator>
==============
*/
void hkArray<hkcdRay,hkContainerHeapAllocator>::~hkArray<hkcdRay,hkContainerHeapAllocator>(hkArray<hkcdRay,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hknpCollisionResult,hkContainerHeapAllocator>::~hkArray<hknpCollisionResult,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpCollisionResult,hkContainerHeapAllocator>::~hkArray<hknpCollisionResult,hkContainerHeapAllocator>(hkArray<hknpCollisionResult,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 112, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hknpMotionProperties,hkContainerHeapAllocator>::~hkArray<hknpMotionProperties,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpMotionProperties,hkContainerHeapAllocator>::~hkArray<hknpMotionProperties,hkContainerHeapAllocator>(hkArray<hknpMotionProperties,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 112, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<Physics_DetailHitData,hkContainerHeapAllocator>::~hkArray<Physics_DetailHitData,hkContainerHeapAllocator>
==============
*/
void hkArray<Physics_DetailHitData,hkContainerHeapAllocator>::~hkArray<Physics_DetailHitData,hkContainerHeapAllocator>(hkArray<Physics_DetailHitData,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 20, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArrayBase<int>::copy<int>
==============
*/
void hkArrayBase<int>::copy<int>(int *dst, const int *src, int n)
{
  __int64 v3; 
  signed __int64 v4; 

  v3 = n;
  if ( n > 0 )
  {
    v4 = (char *)src - (char *)dst;
    do
    {
      *dst = *(int *)((char *)dst + v4);
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hkGeometryDecorations::ConvexFace>::copy<hkGeometryDecorations::ConvexFace>
==============
*/
void hkArrayBase<hkGeometryDecorations::ConvexFace>::copy<hkGeometryDecorations::ConvexFace>(hkGeometryDecorations::ConvexFace *dst, const hkGeometryDecorations::ConvexFace *src, int n)
{
  int *p_m_size; 
  signed __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  hkMemoryAllocator *v8; 
  _DWORD *v9; 
  __int64 v10; 
  __int64 v11; 

  if ( n > 0 )
  {
    p_m_size = &src->m_indices.m_size;
    v4 = (char *)dst - (char *)src;
    v5 = n;
    do
    {
      *(_QWORD *)((char *)p_m_size + v4 - 16) = *((_QWORD *)p_m_size - 2);
      v6 = *p_m_size;
      v7 = *((_QWORD *)p_m_size - 1);
      v8 = hkMemHeapAllocator();
      if ( (*(int *)((char *)p_m_size + v4 + 4) & 0x3FFFFFFF) < (int)v6 )
        hkArrayUtil::_reserve(v8, (char *)p_m_size + v4 - 8, v6, 4);
      v9 = *(_DWORD **)((char *)p_m_size + v4 - 8);
      v10 = v6;
      if ( (int)v6 > 0 )
      {
        v11 = v7 - (_QWORD)v9;
        do
        {
          *v9 = *(_DWORD *)((char *)v9 + v11);
          ++v9;
          --v10;
        }
        while ( v10 );
      }
      *(int *)((char *)p_m_size + v4) = v6;
      *(_WORD *)((char *)p_m_size + v4 + 8) = *((_WORD *)p_m_size + 4);
      p_m_size += 8;
      --v5;
    }
    while ( v5 );
  }
}

/*
==============
hkArrayBase<hkGeometryDecorations::Edge>::copy<hkGeometryDecorations::Edge>
==============
*/
void hkArrayBase<hkGeometryDecorations::Edge>::copy<hkGeometryDecorations::Edge>(hkGeometryDecorations::Edge *dst, const hkGeometryDecorations::Edge *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
        vmovsd  xmm1, qword ptr [rdx+rcx+10h]
        vmovsd  qword ptr [rcx+10h], xmm1
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hkGeometryDecorations::Point>::copy<hkGeometryDecorations::Point>
==============
*/
void hkArrayBase<hkGeometryDecorations::Point>::copy<hkGeometryDecorations::Point>(hkGeometryDecorations::Point *dst, const hkGeometryDecorations::Point *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
        vmovsd  xmm1, qword ptr [rdx+rcx+10h]
        vmovsd  qword ptr [rcx+10h], xmm1
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hkGeometryDecorations::Text>::copy<hkGeometryDecorations::Text>
==============
*/
void hkArrayBase<hkGeometryDecorations::Text>::copy<hkGeometryDecorations::Text>(hkGeometryDecorations::Text *dst, const hkGeometryDecorations::Text *src, int n)
{
  signed __int64 v3; 
  __int64 v4; 
  int *p_m_a; 

  if ( n > 0 )
  {
    v3 = (char *)src - (char *)dst;
    v4 = n;
    p_m_a = &dst->m_a;
    do
    {
      *((_QWORD *)p_m_a - 1) = *(_QWORD *)((char *)p_m_a + v3 - 8);
      *p_m_a = *(int *)((char *)p_m_a + v3);
      hkStringPtr::operator=((hkStringPtr *)p_m_a + 1, (const hkStringPtr *)((char *)p_m_a + v3 + 8));
      *((_WORD *)p_m_a + 8) = *(_WORD *)((char *)p_m_a + v3 + 16);
      p_m_a += 8;
      --v4;
    }
    while ( v4 );
  }
}

/*
==============
hkArrayBase<hk1PointDisplayMaterial>::copy<hk1PointDisplayMaterial>
==============
*/
void hkArrayBase<hk1PointDisplayMaterial>::copy<hk1PointDisplayMaterial>(hk1PointDisplayMaterial *dst, const hk1PointDisplayMaterial *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hk2PointDisplayMaterial>::copy<hk2PointDisplayMaterial>
==============
*/
void hkArrayBase<hk2PointDisplayMaterial>::copy<hk2PointDisplayMaterial>(hk2PointDisplayMaterial *dst, const hk2PointDisplayMaterial *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hk3PointDisplayMaterial>::copy<hk3PointDisplayMaterial>
==============
*/
void hkArrayBase<hk3PointDisplayMaterial>::copy<hk3PointDisplayMaterial>(hk3PointDisplayMaterial *dst, const hk3PointDisplayMaterial *src, int n)
{
  __int64 v3; 
  signed __int64 v4; 

  v3 = n;
  if ( n > 0 )
  {
    v4 = (char *)src - (char *)dst;
    do
    {
      *dst = *(hk3PointDisplayMaterial *)((char *)dst + v4);
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArrayBase<hk3dTextDisplayMaterial>::copy<hk3dTextDisplayMaterial>
==============
*/
void hkArrayBase<hk3dTextDisplayMaterial>::copy<hk3dTextDisplayMaterial>(hk3dTextDisplayMaterial *dst, const hk3dTextDisplayMaterial *src, int n)
{
  signed __int64 v3; 
  __int64 v4; 
  unsigned int *p_m_color; 

  if ( n > 0 )
  {
    v3 = (char *)src - (char *)dst;
    v4 = n;
    p_m_color = &dst->m_color;
    do
    {
      *((_BYTE *)p_m_color - 4) = *((_BYTE *)p_m_color + v3 - 4);
      *p_m_color = *(unsigned int *)((char *)p_m_color + v3);
      hkStringPtr::operator=((hkStringPtr *)(p_m_color + 1), (const hkStringPtr *)((char *)p_m_color + v3 + 4));
      *((_WORD *)p_m_color + 6) = *(_WORD *)((char *)p_m_color + v3 + 12);
      *((_BYTE *)p_m_color + 14) = *((_BYTE *)p_m_color + v3 + 14);
      p_m_color += 6;
      --v4;
    }
    while ( v4 );
  }
}

/*
==============
hkArrayBase<hkVector4f>::copy<hkVector4f>
==============
*/
void hkArrayBase<hkVector4f>::copy<hkVector4f>(hkVector4f *dst, const hkVector4f *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayGeoList *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::Display3DText,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 288, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayLine,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>::~hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator>(hkArray<HavokPhysicsDisplayHandler::DisplayPoint,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 32, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>::~hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>
==============
*/
void hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>::~hkArray<hkGeometry::Triangle,hkContainerHeapAllocator>(hkArray<hkGeometry::Triangle,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpConvexShape *,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hknpConvexShape *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<float,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<float,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>::~hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>
==============
*/
void hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>::~hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator>(hkArray<PhysicsFXPipeline *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<PhysicsFXShape *,hkContainerHeapAllocator>::~hkArray<PhysicsFXShape *,hkContainerHeapAllocator>
==============
*/
void hkArray<PhysicsFXShape *,hkContainerHeapAllocator>::~hkArray<PhysicsFXShape *,hkContainerHeapAllocator>(hkArray<PhysicsFXShape *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArrayBase<hknpBodyId>::copy<hknpBodyId>
==============
*/
void hkArrayBase<hknpBodyId>::copy<hknpBodyId>(hknpBodyId *dst, const hknpBodyId *src, int n)
{
  __int64 v3; 
  signed __int64 v4; 

  v3 = n;
  if ( n > 0 )
  {
    v4 = (char *)src - (char *)dst;
    do
    {
      dst->m_serialAndIndex = *(unsigned int *)((char *)dst + v4);
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>::~hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator>(hkArray<HavokPhysicsShapeViewer::WorldData *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>::~hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>
==============
*/
void hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>::~hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator>(hkArray<hkcdSimdTree::Node,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 128, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>
==============
*/
void hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>::~hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator>(hkArray<StaticModels_HavokShape::VelocityInfo,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 32, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkMassElement,hkContainerHeapAllocator>::~hkArray<hkMassElement,hkContainerHeapAllocator>
==============
*/
void hkArray<hkMassElement,hkContainerHeapAllocator>::~hkArray<hkMassElement,hkContainerHeapAllocator>(hkArray<hkMassElement,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 144, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkAabb,hkContainerHeapAllocator>::~hkArray<hkAabb,hkContainerHeapAllocator>
==============
*/
void hkArray<hkAabb,hkContainerHeapAllocator>::~hkArray<hkAabb,hkContainerHeapAllocator>(hkArray<hkAabb,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 32, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>::~hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>
==============
*/
void hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>::~hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator>(hkArray<hknpShapeKeyMask *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpMotionProperties,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hknpMotionProperties,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpShape *,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hknpShape *,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkVector4_Tag,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkVector4_Tag,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<HavokPhysicsShapeList::ShapeTagData,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkTransform_Tag,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkReflect::Typedef::hkTransform_Tag,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkVector4f,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkVector4f,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkTransformf,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkTransformf,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<int,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<int,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkStringPtr,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkStringPtr,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<hkReflect::Typedef::hkUlong_Tag,int>,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hkHashMapDetail::MapTuple<hkReflect::Typedef::hkUlong_Tag,int>,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<bool,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<bool,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpBodyQuality,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hknpBodyQuality,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkReflect::Tracker::hkArrayHandler<hknpMaterial,hkContainerHeapAllocator>::func
==============
*/
void hkReflect::Tracker::hkArrayHandler<hknpMaterial,hkContainerHeapAllocator>::func(const hkReflect::Var *var, hkMemoryTrackerSnapshot *snapshot)
{
  ;
}

/*
==============
hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::~hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>
==============
*/
void hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>::~hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator>(hkArray<hkHashMapDetail::MapTuple<unsigned __int64,int>,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkStringPtr,hkContainerHeapAllocator>::~hkArray<hkStringPtr,hkContainerHeapAllocator>
==============
*/
void hkArray<hkStringPtr,hkContainerHeapAllocator>::~hkArray<hkStringPtr,hkContainerHeapAllocator>(hkArray<hkStringPtr,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int v3; 
  hkStringPtr *v4; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  v3 = this->m_size - 1;
  if ( v3 >= 0 )
  {
    v4 = &this->m_data[v3];
    do
    {
      hkStringPtr::~hkStringPtr(v4--);
      --v3;
    }
    while ( v3 >= 0 );
  }
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<bool,hkContainerHeapAllocator>::~hkArray<bool,hkContainerHeapAllocator>
==============
*/
void hkArray<bool,hkContainerHeapAllocator>::~hkArray<bool,hkContainerHeapAllocator>(hkArray<bool,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::~hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>::~hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator>(hkArray<HavokCloth_PhysicsProxyAction::BulletImpact,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 32, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArrayBase<hkGeometry::Triangle>::copy<hkGeometry::Triangle>
==============
*/
void hkArrayBase<hkGeometry::Triangle>::copy<hkGeometry::Triangle>(hkGeometry::Triangle *dst, const hkGeometry::Triangle *src, int n)
{
  __int64 v3; 

  v3 = n;
  if ( n > 0 )
  {
    _RDX = (char *)src - (char *)dst;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx+rcx]
        vmovups xmmword ptr [rcx], xmm0
      }
      ++dst;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
hkArray<hclClothInstance *,hkContainerHeapAllocator>::~hkArray<hclClothInstance *,hkContainerHeapAllocator>
==============
*/
void hkArray<hclClothInstance *,hkContainerHeapAllocator>::~hkArray<hclClothInstance *,hkContainerHeapAllocator>(hkArray<hclClothInstance *,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<float,hkContainerHeapAllocator>::~hkArray<float,hkContainerHeapAllocator>
==============
*/
void hkArray<float,hkContainerHeapAllocator>::~hkArray<float,hkContainerHeapAllocator>(hkArray<float,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>::~hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>::~hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator>(hkArray<HavokPhysicsFX_ScaledShapeAsset,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<Particle_OnImpactData,hkContainerHeapAllocator>::~hkArray<Particle_OnImpactData,hkContainerHeapAllocator>
==============
*/
void hkArray<Particle_OnImpactData,hkContainerHeapAllocator>::~hkArray<Particle_OnImpactData,hkContainerHeapAllocator>(hkArray<Particle_OnImpactData,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 80, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<hkQuaternionf,hkContainerHeapAllocator>::~hkArray<hkQuaternionf,hkContainerHeapAllocator>
==============
*/
void hkArray<hkQuaternionf,hkContainerHeapAllocator>::~hkArray<hkQuaternionf,hkContainerHeapAllocator>(hkArray<hkQuaternionf,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

/*
==============
hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>::~hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>
==============
*/
void hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>::~hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator>(hkArray<HavokPhysicsSVFX_DrawSVFX_AssetData,hkContainerHeapAllocator> *this)
{
  hkMemoryAllocator *v2; 
  int m_capacityAndFlags; 

  v2 = hkMemHeapAllocator();
  this->m_size = 0;
  m_capacityAndFlags = this->m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v2, this->m_data, 16, m_capacityAndFlags & 0x3FFFFFFF);
  this->m_capacityAndFlags = 0x80000000;
  this->m_data = NULL;
}

