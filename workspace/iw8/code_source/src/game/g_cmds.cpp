/*
==============
G_Cmd_EntitymarkBaseline_f
==============
*/

void G_Cmd_EntitymarkBaseline_f(void)
{
  ?G_Cmd_EntitymarkBaseline_f@@YAXXZ();
}

/*
==============
G_Cmds_AreCheatsOk_NoHealthCheck
==============
*/

int __fastcall G_Cmds_AreCheatsOk_NoHealthCheck(gentity_s *ent)
{
  return ?G_Cmds_AreCheatsOk_NoHealthCheck@@YAHPEAUgentity_s@@@Z(ent);
}

/*
==============
G_Cmd_EntityList_f
==============
*/

void G_Cmd_EntityList_f(void)
{
  ?G_Cmd_EntityList_f@@YAXXZ();
}

/*
==============
G_Cmds_LuiNotifyServer_StrChannel_f
==============
*/

void __fastcall G_Cmds_LuiNotifyServer_StrChannel_f(gentity_s *pEnt)
{
  ?G_Cmds_LuiNotifyServer_StrChannel_f@@YAXPEAUgentity_s@@@Z(pEnt);
}

/*
==============
Cmd_UFO_Viewmodel_f
==============
*/

void __fastcall Cmd_UFO_Viewmodel_f(gentity_s *ent)
{
  ?Cmd_UFO_Viewmodel_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
G_Cmds_GiveInternal
==============
*/

void __fastcall G_Cmds_GiveInternal(gentity_s *ent, const char *name, int amount, int forceGive)
{
  ?G_Cmds_GiveInternal@@YAXPEAUgentity_s@@PEBDHH@Z(ent, name, amount, forceGive);
}

/*
==============
Cmd_UmbraPortalToggle_f
==============
*/

void Cmd_UmbraPortalToggle_f(void)
{
  ?Cmd_UmbraPortalToggle_f@@YAXXZ();
}

/*
==============
Cmd_Give_f
==============
*/

void __fastcall Cmd_Give_f(gentity_s *ent)
{
  ?Cmd_Give_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
G_Cmds_InvokeLuiCallback
==============
*/

void __fastcall G_Cmds_InvokeLuiCallback(gentity_s *ent, unsigned int numParams)
{
  ?G_Cmds_InvokeLuiCallback@@YAXPEAUgentity_s@@I@Z(ent, numParams);
}

/*
==============
Cmd_Noclip_f
==============
*/

void __fastcall Cmd_Noclip_f(gentity_s *ent)
{
  ?Cmd_Noclip_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_SetExtraGameRevenueRate
==============
*/

void __fastcall Cmd_SetExtraGameRevenueRate(gentity_s *pEnt)
{
  ?Cmd_SetExtraGameRevenueRate@@YAXPEAUgentity_s@@@Z(pEnt);
}

/*
==============
G_Cmds_TestCmd_f
==============
*/

void __fastcall G_Cmds_TestCmd_f(gentity_s *ent)
{
  ?G_Cmds_TestCmd_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_ModelPreviewer_f
==============
*/

void __fastcall Cmd_ModelPreviewer_f(gentity_s *ent, int active)
{
  ?Cmd_ModelPreviewer_f@@YAXPEAUgentity_s@@H@Z(ent, active);
}

/*
==============
Cmd_Where_f
==============
*/

void __fastcall Cmd_Where_f(gentity_s *ent)
{
  ?Cmd_Where_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_Dvar_SetSv
==============
*/

void __fastcall Cmd_Dvar_SetSv(gentity_s *ent)
{
  ?Cmd_Dvar_SetSv@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
G_Cmds_AreCheatsOk
==============
*/

int __fastcall G_Cmds_AreCheatsOk(gentity_s *ent)
{
  return ?G_Cmds_AreCheatsOk@@YAHPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_DemiGod_f
==============
*/

void __fastcall Cmd_DemiGod_f(gentity_s *ent)
{
  ?Cmd_DemiGod_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_Take_f
==============
*/

void __fastcall Cmd_Take_f(gentity_s *ent)
{
  ?Cmd_Take_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
SanitizeString
==============
*/

void __fastcall SanitizeString(char *in, char *out)
{
  ?SanitizeString@@YAXPEAD0@Z(in, out);
}

/*
==============
ConcatArgs
==============
*/

char *__fastcall ConcatArgs(int start)
{
  return ?ConcatArgs@@YAPEADH@Z(start);
}

/*
==============
Cmd_UmbraPortalList_f
==============
*/

void Cmd_UmbraPortalList_f(void)
{
  ?Cmd_UmbraPortalList_f@@YAXXZ();
}

/*
==============
Cmd_SetViewpos_f
==============
*/

void __fastcall Cmd_SetViewpos_f(gentity_s *ent)
{
  ?Cmd_SetViewpos_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_UFO_f
==============
*/

void __fastcall Cmd_UFO_f(gentity_s *ent, bool fromScript)
{
  ?Cmd_UFO_f@@YAXPEAUgentity_s@@_N@Z(ent, fromScript);
}

/*
==============
Cmd_Notarget_f
==============
*/

void __fastcall Cmd_Notarget_f(gentity_s *ent)
{
  ?Cmd_Notarget_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_CreateFx_Exploder_f
==============
*/

void __fastcall Cmd_CreateFx_Exploder_f(gentity_s *ent)
{
  ?Cmd_CreateFx_Exploder_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
SV_SendPrintDebugCommand
==============
*/

void __fastcall SV_SendPrintDebugCommand(int clientNum, const char *msg)
{
  ?SV_SendPrintDebugCommand@@YAXHPEBD@Z(clientNum, msg);
}

/*
==============
Cmd_God_f
==============
*/

void __fastcall Cmd_God_f(gentity_s *ent)
{
  ?Cmd_God_f@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
Cmd_CreateFx_Exploder_f
==============
*/
void Cmd_CreateFx_Exploder_f(gentity_s *ent)
{
  int CheatsOk; 
  unsigned int EntityIndex; 
  const char *v8; 
  const char *v9; 
  SvClient *CommonClient; 
  unsigned int v12; 
  int v13; 
  const char *v14; 
  const char *v16; 
  const char *v18; 
  const char *v20; 
  const char *v22; 
  bool v23; 
  const char *v24; 
  bool v25; 
  const char *v26; 
  int v27; 
  const char *v28; 
  int v29; 
  const char *v30; 
  scrContext_t *v31; 
  const char *v32; 
  __int64 v39; 
  __int64 v40; 
  float value[4]; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 818, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !ent->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 819, ASSERT_TYPE_ASSERT, "(ent->client)", (const char *)&queryFormat, "ent->client") )
    __debugbreak();
  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( !CheatsOk && !com_cheats->current.enabled )
  {
    EntityIndex = G_GetEntityIndex(ent);
    v8 = j_va("%c \"%s\"", 101i64, "GAME/CHEATSNOTENABLED");
    v9 = v8;
    if ( EntityIndex == -1 )
    {
LABEL_13:
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v8);
      return;
    }
    goto LABEL_14;
  }
  if ( SV_Cmd_Argc() < 11 )
  {
    EntityIndex = G_GetEntityIndex(ent);
    v8 = j_va("%c \"%s\"", 101i64, aPrintGameUsage_1);
    v9 = v8;
    if ( EntityIndex == -1 )
      goto LABEL_13;
LABEL_14:
    CommonClient = SvClient::GetCommonClient(EntityIndex);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v9);
    return;
  }
  _RDI = value;
  v12 = 0;
  __asm
  {
    vmovaps [rsp+0A8h+var_28], xmm6
    vmovaps [rsp+0A8h+var_38], xmm7
    vmovaps [rsp+0A8h+var_48], xmm8
  }
  do
  {
    v13 = v12 + 1;
    v14 = SV_Cmd_Argv(v12 + 1);
    if ( *v14 == 40 )
      ++v14;
    *(double *)&_XMM0 = atof(v14);
    __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
    if ( v12 >= 3 )
    {
      LODWORD(v40) = 3;
      LODWORD(v39) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v39, v40) )
        __debugbreak();
    }
    __asm { vmovss  dword ptr [rdi], xmm6 }
    ++_RDI;
    ++v12;
  }
  while ( v13 < 3 );
  v16 = SV_Cmd_Argv(4);
  *(double *)&_XMM0 = atof(v16);
  __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
  v18 = SV_Cmd_Argv(5);
  *(double *)&_XMM0 = atof(v18);
  __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
  v20 = SV_Cmd_Argv(6);
  *(double *)&_XMM0 = atof(v20);
  __asm { vcvtsd2ss xmm8, xmm0, xmm0 }
  v22 = SV_Cmd_Argv(7);
  v23 = atoi(v22) > 0;
  v24 = SV_Cmd_Argv(8);
  v25 = atoi(v24) > 0;
  v26 = SV_Cmd_Argv(9);
  v27 = atoi(v26);
  v28 = SV_Cmd_Argv(10);
  v29 = atoi(v28);
  v30 = (char *)&queryFormat.fmt + 3;
  v31 = ScriptContext_Server();
  if ( v29 )
    v32 = SL_ConvertToString((scr_string_t)v29);
  else
    v32 = (char *)&queryFormat.fmt + 3;
  Scr_AddString(v31, v32);
  if ( v27 )
    v30 = SL_ConvertToString((scr_string_t)v27);
  Scr_AddString(v31, v30);
  Scr_AddBool(v31, v25);
  Scr_AddBool(v31, v23);
  __asm { vmovaps xmm1, xmm8; value }
  Scr_AddFloat(v31, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; value }
  Scr_AddFloat(v31, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm6; value }
  Scr_AddFloat(v31, *(float *)&_XMM1);
  Scr_AddVector(v31, value);
  Scr_NotifyLevel(v31, scr_const.cfx_exploder, 8u);
  __asm
  {
    vmovaps xmm8, [rsp+0A8h+var_48]
    vmovaps xmm7, [rsp+0A8h+var_38]
    vmovaps xmm6, [rsp+0A8h+var_28]
  }
}

/*
==============
Cmd_DemiGod_f
==============
*/
void Cmd_DemiGod_f(gentity_s *ent)
{
  int CheatsOk; 
  unsigned int EntityIndex; 
  const char *v4; 
  const char *v5; 
  SvClient *CommonClient; 
  unsigned int v7; 
  unsigned int v8; 
  bool v9; 
  const char *v10; 
  __int16 v11; 

  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    if ( com_disableGodMode->current.enabled )
    {
      EntityIndex = G_GetEntityIndex(ent);
      v4 = j_va("%c \"%s\"", 101i64, "GAME/CHEATSNOTENABLED");
      v5 = v4;
      if ( EntityIndex == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(EntityIndex);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
      }
      Com_Printf(15, "Player %d attempted to toggle demigod mode but was denied.\n", (unsigned int)ent->s.number);
    }
    else
    {
      v7 = ent->flags.m_flags[0];
      if ( (v7 & 2) != 0 )
        v8 = v7 & 0xFFFFFFFD;
      else
        v8 = v7 | 2;
      v9 = (ent->flags.m_flags[0] & 2) == 0;
      ent->flags.m_flags[0] = v8;
      v10 = "GAME/DEMI_GODMODE_OFF";
      if ( v9 )
        v10 = "GAME/DEMI_GODMODE_ON";
      v11 = G_GetEntityIndex(ent);
      SV_SendPrintDebugCommand(v11, v10);
    }
  }
}

/*
==============
Cmd_Dvar_SetSv
==============
*/
void Cmd_Dvar_SetSv(gentity_s *ent)
{
  unsigned int v1; 
  const char *v2; 
  const char *v3; 

  if ( SV_Cmd_Argc() == 3 )
  {
    v2 = SV_Cmd_Argv(2);
    v3 = SV_Cmd_Argv(1);
    Dvar_SetCommandByName(v3, v2, 1);
  }
  else
  {
    v1 = SV_Cmd_Argc();
    Com_PrintError(15, "Missing arguments for setsv command, expected 3 but got %i\n", v1);
  }
}

/*
==============
Cmd_Give_f
==============
*/
void Cmd_Give_f(gentity_s *ent)
{
  int CheatsOk; 
  const char *v3; 
  int v4; 
  const char *v5; 

  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    v3 = ConcatArgs(2);
    v4 = atoi(v3);
    v5 = ConcatArgs(1);
    if ( v5 )
    {
      if ( *v5 )
        G_Cmds_GiveInternal(ent, v5, v4, 0);
    }
  }
}

/*
==============
Cmd_God_f
==============
*/
void Cmd_God_f(gentity_s *ent)
{
  int CheatsOk; 
  unsigned int EntityIndex; 
  const char *v4; 
  const char *v5; 
  SvClient *CommonClient; 
  bool v7; 
  char v8; 
  const char *v9; 
  __int16 v10; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 662, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    if ( com_disableGodMode->current.enabled )
    {
      EntityIndex = G_GetEntityIndex(ent);
      v4 = j_va("%c \"%s\"", 101i64, "GAME/CHEATSNOTENABLED");
      v5 = v4;
      if ( EntityIndex == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(EntityIndex);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
      }
      Com_Printf(15, "Player %d attempted to toggle god mode but was denied.\n", (unsigned int)ent->s.number);
      return;
    }
    v7 = (ent->flags.m_flags[0] & 1) == 0;
    if ( SV_Cmd_Argc() <= 1 )
    {
      if ( v7 )
      {
LABEL_18:
        ent->flags.m_flags[0] |= 1u;
        v9 = "GAME/GODMODE_ON";
LABEL_20:
        v10 = G_GetEntityIndex(ent);
        SV_SendPrintDebugCommand(v10, v9);
        g_godModeRemoteInputValid = ent->flags.m_flags[0] & 1;
        return;
      }
    }
    else
    {
      v8 = *SV_Cmd_Argv(1);
      if ( v8 != 48 )
      {
        if ( v8 != 49 )
        {
          Com_Printf(0, "USAGE: god [0/1]\n");
          return;
        }
        goto LABEL_18;
      }
    }
    ent->flags.m_flags[0] &= ~1u;
    v9 = "GAME/GODMODE_OFF";
    goto LABEL_20;
  }
}

/*
==============
Cmd_ModelPreviewer_f
==============
*/
void Cmd_ModelPreviewer_f(gentity_s *ent, int active)
{
  const char *v4; 
  const char *v5; 
  unsigned int EntityIndex; 
  SvClient *CommonClient; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 802, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Stream_ImageRecord_Disable("mpviewer");
  v4 = "GAME/MPOFF";
  ent->client->mpviewer = active;
  if ( active )
    v4 = "GAME/MPON";
  v5 = j_va("%c \"%s\"", 101i64, v4);
  EntityIndex = G_GetEntityIndex(ent);
  if ( EntityIndex == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(EntityIndex);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
  }
}

/*
==============
Cmd_Noclip_f
==============
*/
void Cmd_Noclip_f(gentity_s *ent)
{
  int CheatsOk; 
  gclient_s *client; 
  int flags; 
  int v5; 
  unsigned int v6; 
  const char *v7; 
  __int16 EntityIndex; 

  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    Stream_ImageRecord_Disable("noclip");
    client = ent->client;
    flags = client->flags;
    v5 = flags & 1;
    if ( (flags & 1) != 0 )
      v6 = flags & 0xFFFFFFFE;
    else
      v6 = flags | 1;
    client->flags = v6;
    v7 = "GAME/NOCLIPOFF";
    if ( !v5 )
      v7 = "GAME/NOCLIPON";
    EntityIndex = G_GetEntityIndex(ent);
    SV_SendPrintDebugCommand(EntityIndex, v7);
  }
}

/*
==============
Cmd_Notarget_f
==============
*/
void Cmd_Notarget_f(gentity_s *ent)
{
  int CheatsOk; 
  unsigned int v3; 
  unsigned int v4; 
  bool v5; 
  const char *v6; 
  __int16 EntityIndex; 

  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    v3 = ent->flags.m_flags[0];
    if ( (v3 & 4) != 0 )
      v4 = v3 & 0xFFFFFFFB;
    else
      v4 = v3 | 4;
    v5 = (ent->flags.m_flags[0] & 4) == 0;
    ent->flags.m_flags[0] = v4;
    v6 = "GAME/NOTARGETOFF";
    if ( v5 )
      v6 = "GAME/NOTARGETON";
    EntityIndex = G_GetEntityIndex(ent);
    SV_SendPrintDebugCommand(EntityIndex, v6);
  }
}

/*
==============
Cmd_SetExtraGameRevenueRate
==============
*/
void Cmd_SetExtraGameRevenueRate(gentity_s *pEnt)
{
  char buffer[1024]; 

  if ( !pEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1211, ASSERT_TYPE_ASSERT, "(pEnt)", (const char *)&queryFormat, "pEnt") )
    __debugbreak();
  if ( !pEnt->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1212, ASSERT_TYPE_ASSERT, "(pEnt->client)", (const char *)&queryFormat, "pEnt->client") )
    __debugbreak();
  if ( SV_Cmd_Argc() == 2 )
  {
    SV_Cmd_ArgvBuffer(1, buffer, 0x400ui64);
    *(double *)&_XMM0 = atof(buffer);
    _RAX = pEnt->client;
    __asm
    {
      vcvtsd2ss xmm1, xmm0, xmm0
      vmovss  dword ptr [rax+5D2Ch], xmm1
    }
  }
}

/*
==============
Cmd_SetViewpos_f
==============
*/

void __fastcall Cmd_SetViewpos_f(gentity_s *ent, __int64 a2, double _XMM2_8)
{
  int v5; 
  int CheatsOk; 
  __int16 EntityIndex; 
  const char *v9; 
  unsigned int v10; 
  int v12; 
  const char *v13; 
  int v18; 
  int v20; 
  int v21; 
  const char *v22; 
  const char *v24; 
  unsigned int v26; 
  const char *v27; 
  const char *v28; 
  SvClient *CommonClient; 
  __int64 v30; 
  __int64 v31; 
  int v32; 
  char v35[8]; 

  v5 = 0;
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1035, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !ent->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1036, ASSERT_TYPE_ASSERT, "(ent->client)", (const char *)&queryFormat, "ent->client") )
    __debugbreak();
  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( !CheatsOk && !com_cheats->current.enabled )
  {
    EntityIndex = G_GetEntityIndex(ent);
    v9 = "GAME/CHEATSNOTENABLED";
    goto LABEL_33;
  }
  if ( SV_Cmd_Argc() < 4 || SV_Cmd_Argc() > 7 )
  {
    EntityIndex = G_GetEntityIndex(ent);
    v9 = aPrintGameUsage;
LABEL_33:
    v26 = EntityIndex;
    v27 = j_va("%c \"%s\"", 101i64, v9);
    v28 = v27;
    if ( v26 == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v27);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(v26);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v28);
    }
    return;
  }
  __asm { vmovaps [rsp+0A8h+var_38], xmm6 }
  Stream_ImageRecord_Disable("setviewpos");
  v10 = 0;
  _RDI = v35;
  do
  {
    v12 = v10 + 1;
    v13 = SV_Cmd_Argv(v10 + 1);
    if ( *v13 == 40 )
      ++v13;
    *(double *)&_XMM0 = atof(v13);
    __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
    if ( v10 >= 3 )
    {
      LODWORD(v31) = 3;
      LODWORD(v30) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v30, v31) )
        __debugbreak();
    }
    __asm { vmovss  dword ptr [rdi], xmm6 }
    _RDI += 4;
    ++v10;
  }
  while ( v12 < 3 );
  __asm
  {
    vmovss  xmm0, [rsp+0A8h+var_50]
    vxorps  xmm2, xmm2, xmm2
    vsubss  xmm1, xmm0, dword ptr [rax+1E8h]
    vmovss  [rsp+0A8h+var_50], xmm1
    vmovss  [rsp+0A8h+var_68], xmm2
    vmovss  [rsp+0A8h+var_64], xmm2
    vmovss  [rsp+0A8h+var_60], xmm2
  }
  v18 = SV_Cmd_Argc();
  __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
  v20 = v18 - 5;
  if ( v20 )
  {
    v21 = v20 - 1;
    if ( v21 )
    {
      if ( v21 != 1 )
        goto LABEL_28;
      v5 = 1;
    }
    v22 = SV_Cmd_Argv(v5 + 5);
    *(double *)&_XMM0 = atof(v22);
    __asm
    {
      vcvtsd2ss xmm1, xmm0, xmm0
      vmovss  [rsp+0A8h+var_68], xmm1
    }
  }
  v24 = SV_Cmd_Argv(v5 + 4);
  *(double *)&_XMM0 = atof(v24);
  __asm
  {
    vcvtsd2ss xmm1, xmm0, xmm0
    vmovss  [rsp+0A8h+var_64], xmm1
  }
LABEL_28:
  if ( !GClientSystem::ms_gClientSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_client.h", 423, ASSERT_TYPE_ASSERT, "( ms_gClientSystem )", (const char *)&queryFormat, "ms_gClientSystem") )
    __debugbreak();
  GClientSystem::ms_gClientSystem->TeleportPlayer(GClientSystem::ms_gClientSystem, ent, (const vec3_t *)v35, (const vec3_t *)&v32);
}

/*
==============
Cmd_Take_f
==============
*/

void __fastcall Cmd_Take_f(gentity_s *ent, __int64 a2, double _XMM2_8)
{
  int CheatsOk; 
  const char *v5; 
  int v6; 
  char *v7; 
  const char *v8; 
  const char *v9; 
  __int64 v10; 
  __int64 v11; 
  signed __int64 v12; 
  int v13; 
  __int64 v14; 
  int v15; 
  int v16; 
  int v17; 
  int v18; 
  int v19; 
  int v20; 
  BgWeaponMap *v21; 
  const char *v22; 
  __int64 v23; 
  int v24; 
  __int64 v25; 
  int v26; 
  int v27; 
  int v28; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v30; 
  const char *v31; 
  __int64 v32; 
  int v33; 
  __int64 v34; 
  int v35; 
  int v36; 
  int v37; 
  int i; 
  const Weapon *EquippedWeaponForPlayer; 
  gclient_s *client; 
  const char *v47; 
  __int64 v48; 
  int v49; 
  __int64 v50; 
  int v51; 
  int v52; 
  int v53; 
  int j; 
  const Weapon *v55; 
  const char *v56; 
  int v57; 
  __int64 v58; 
  int v59; 
  int v60; 
  int v61; 
  __int64 v62; 
  gclient_s *v63; 
  bool v69; 
  WeaponDef **v70; 
  GHandler *Handler; 
  __int16 EntityIndex; 
  __int64 amount; 
  __int64 v78; 
  int v79; 
  int v80; 
  GWeaponMap *Instance; 
  char *v82; 
  AmmoStore result; 
  AmmoStore r_clipIndex; 
  Weapon weapon; 
  Weapon v86; 

  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    v5 = ConcatArgs(2);
    v80 = atoi(v5);
    v6 = v80;
    v7 = ConcatArgs(1);
    v82 = v7;
    v8 = v7;
    if ( v7 )
    {
      if ( *v7 )
      {
        v9 = "all";
        v10 = 0x7FFFFFFFi64;
        v11 = 0x7FFFFFFFi64;
        v12 = v7 - "all";
        while ( 1 )
        {
          v13 = (unsigned __int8)v9[v12];
          v14 = v11;
          v15 = *(unsigned __int8 *)v9++;
          --v11;
          v16 = 0;
          if ( !v14 )
          {
LABEL_16:
            Dvar_SetBool_Internal(DVARBOOL_bg_giveAll, 0);
            v19 = 1;
            v79 = 1;
            goto LABEL_17;
          }
          if ( v13 != v15 )
          {
            v17 = v13 + 32;
            if ( (unsigned int)(v13 - 65) > 0x19 )
              v17 = v13;
            v13 = v17;
            v18 = v15 + 32;
            if ( (unsigned int)(v15 - 65) > 0x19 )
              v18 = v15;
            if ( v13 != v18 )
              break;
          }
          if ( !v13 )
            goto LABEL_16;
        }
        v31 = "health";
        v79 = 0;
        v19 = 0;
        v32 = 6i64;
        do
        {
          v33 = (unsigned __int8)v31[v8 - "health"];
          v34 = v32;
          v35 = *(unsigned __int8 *)v31++;
          --v32;
          if ( !v34 )
            break;
          if ( v33 != v35 )
          {
            v36 = v33 + 32;
            if ( (unsigned int)(v33 - 65) > 0x19 )
              v36 = v33;
            v33 = v36;
            v37 = v35 + 32;
            if ( (unsigned int)(v35 - 65) > 0x19 )
              v37 = v35;
            if ( v33 != v37 )
              goto LABEL_21;
          }
        }
        while ( v33 );
LABEL_17:
        if ( !v80 || (v20 = ent->health - v80, ent->health = v20, v20 < 1) )
          ent->health = 1;
        if ( v19 )
        {
LABEL_21:
          Instance = GWeaponMap::GetInstance();
          v21 = Instance;
          if ( !v19 )
          {
            v22 = "ammo";
            v23 = 4i64;
            do
            {
              v24 = (unsigned __int8)v22[v8 - "ammo"];
              v25 = v23;
              v26 = *(unsigned __int8 *)v22++;
              --v23;
              if ( !v25 )
                break;
              if ( v24 != v26 )
              {
                v27 = v24 + 32;
                if ( (unsigned int)(v24 - 65) > 0x19 )
                  v27 = v24;
                v24 = v27;
                v28 = v26 + 32;
                if ( (unsigned int)(v26 - 65) > 0x19 )
                  v28 = v26;
                if ( v24 != v28 )
                  goto LABEL_56;
              }
            }
            while ( v24 );
          }
          if ( v80 )
          {
            CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &ent->client->ps);
            if ( CurrentWeaponForPlayer->weaponIdx )
            {
              v30 = BG_UsingAlternate(&ent->client->ps);
              TakeAwayAmmo(&ent->client->ps, CurrentWeaponForPlayer, v30, v80);
            }
          }
          else
          {
            for ( i = 0; i < 15; ++i )
            {
              EquippedWeaponForPlayer = BG_GetEquippedWeaponForPlayer(v21, &ent->client->ps, i);
              if ( EquippedWeaponForPlayer->weaponIdx )
              {
                client = ent->client;
                if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 512, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
                  __debugbreak();
                _RAX = BG_AmmoStoreForWeapon(&result, EquippedWeaponForPlayer, 0);
                __asm
                {
                  vmovups ymm0, ymmword ptr [rax]
                  vmovups ymmword ptr [rbp+90h+r_clipIndex.weapon.weaponIdx], ymm0
                  vmovups ymm1, ymmword ptr [rax+20h]
                  vmovups ymmword ptr [rbp+90h+r_clipIndex.weapon.attachmentVariationIndices+5], ymm1
                }
                BG_SetGlobalAmmo(&client->ps, EquippedWeaponForPlayer, 0, 0);
                BG_SetClipAmmo(&client->ps, &r_clipIndex, EquippedWeaponForPlayer, 0, WEAPON_HAND_DEFAULT, 0);
                BG_SetClipAmmo(&client->ps, &r_clipIndex, EquippedWeaponForPlayer, 0, WEAPON_HAND_LEFT, 0);
                if ( BG_HasUnderbarrelAmmo(EquippedWeaponForPlayer) )
                {
                  BG_SetGlobalAmmo(&client->ps, EquippedWeaponForPlayer, 1, 0);
                  _RAX = BG_AmmoStoreForWeapon(&result, EquippedWeaponForPlayer, 1);
                  __asm
                  {
                    vmovups ymm0, ymmword ptr [rax]
                    vmovups ymmword ptr [rbp+90h+r_clipIndex.weapon.weaponIdx], ymm0
                    vmovups ymm1, ymmword ptr [rax+20h]
                    vmovups ymmword ptr [rbp+90h+r_clipIndex.weapon.attachmentVariationIndices+5], ymm1
                  }
                  BG_SetClipAmmo(&client->ps, &r_clipIndex, EquippedWeaponForPlayer, 1, WEAPON_HAND_DEFAULT, 0);
                  BG_SetClipAmmo(&client->ps, &r_clipIndex, EquippedWeaponForPlayer, 1, WEAPON_HAND_LEFT, 0);
                }
                v21 = Instance;
              }
            }
            v6 = v80;
            v10 = 0x7FFFFFFFi64;
            v19 = v79;
          }
          if ( v19 )
          {
            v8 = v82;
LABEL_56:
            v47 = "allammo";
            v48 = 7i64;
            do
            {
              v49 = (unsigned __int8)v47[v8 - "allammo"];
              v50 = v48;
              v51 = *(unsigned __int8 *)v47++;
              --v48;
              if ( !v50 )
                break;
              if ( v49 != v51 )
              {
                v52 = v49 + 32;
                if ( (unsigned int)(v49 - 65) > 0x19 )
                  v52 = v49;
                v49 = v52;
                v53 = v51 + 32;
                if ( (unsigned int)(v51 - 65) > 0x19 )
                  v53 = v51;
                if ( v49 != v53 )
                  goto LABEL_72;
              }
            }
            while ( v49 );
            if ( !v6 )
            {
LABEL_72:
              if ( !v19 )
              {
                v56 = "weapons";
                while ( 1 )
                {
                  v57 = (unsigned __int8)v56[v8 - "weapons"];
                  v58 = v10;
                  v59 = *(unsigned __int8 *)v56++;
                  --v10;
                  if ( !v58 )
                    break;
                  if ( v57 != v59 )
                  {
                    v60 = v57 + 32;
                    if ( (unsigned int)(v57 - 65) > 0x19 )
                      v60 = v57;
                    v57 = v60;
                    v61 = v59 + 32;
                    if ( (unsigned int)(v59 - 65) > 0x19 )
                      v61 = v59;
                    if ( v57 != v61 )
                      goto LABEL_108;
                  }
                  if ( !v57 )
                    goto LABEL_82;
                }
              }
              goto LABEL_82;
            }
            for ( j = 0; j < 15; ++j )
            {
              v55 = BG_GetEquippedWeaponForPlayer(v21, &ent->client->ps, j);
              if ( v55->weaponIdx )
                TakeAwayAmmo(&ent->client->ps, v55, 0, v6);
            }
            if ( !v19 )
              return;
LABEL_82:
            v62 = 1480i64;
            do
            {
              v63 = ent->client;
              if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
                __debugbreak();
              if ( !v63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
                __debugbreak();
              if ( (unsigned int)v16 >= 0xF )
              {
                LODWORD(v78) = 15;
                LODWORD(amount) = v16;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", amount, v78) )
                  __debugbreak();
              }
              _RAX = BgWeaponMap::GetWeapon(v21, *(BgWeaponHandle *)((char *)&v63->ps.commandTime + v62));
              __asm
              {
                vmovups ymm2, ymmword ptr [rax]
                vmovups ymmword ptr [rbp+90h+weapon.weaponIdx], ymm2
                vmovups xmm0, xmmword ptr [rax+20h]
                vmovups xmmword ptr [rbp+90h+weapon.attachmentVariationIndices+5], xmm0
                vmovsd  xmm1, qword ptr [rax+30h]
                vmovd   ebx, xmm2
                vmovsd  qword ptr [rbp+90h+weapon.attachmentVariationIndices+15h], xmm1
              }
              *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
              if ( (_WORD)_EBX )
              {
                if ( (unsigned __int16)_EBX > bg_lastParsedWeaponIndex )
                {
                  LODWORD(v78) = bg_lastParsedWeaponIndex;
                  LODWORD(amount) = (unsigned __int16)_EBX;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", amount, v78) )
                    __debugbreak();
                }
                v69 = bg_weaponDefs[(unsigned __int16)_EBX] == NULL;
                v70 = &bg_weaponDefs[(unsigned __int16)_EBX];
                if ( v69 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
                  __debugbreak();
                if ( (*v70)->inventoryType == WEAPINVENTORY_ALTMODE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 628, ASSERT_TYPE_ASSERT, "(BG_WeaponDef( weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE)", (const char *)&queryFormat, "BG_WeaponDef( weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE") )
                  __debugbreak();
                G_Weapon_TakePlayerWeapon(&ent->client->ps, &weapon);
              }
              ++v16;
              v62 += 4i64;
            }
            while ( v16 < 15 );
            if ( BG_GetCurrentWeaponForPlayer(v21, &ent->client->ps)->weaponIdx )
            {
              Handler = GHandler::getHandler();
              BG_SetCurrentWeaponForPlayer(v21, &ent->client->ps, &NULL_WEAPON, Handler);
              EntityIndex = G_GetEntityIndex(ent);
              G_Weapon_SelectWeapon(EntityIndex, &NULL_WEAPON);
            }
            if ( v79 )
            {
              v8 = v82;
LABEL_108:
              _RAX = G_Weapon_GetWeaponForName(&r_clipIndex.weapon, v8);
              __asm
              {
                vmovups ymm2, ymmword ptr [rax]
                vmovups ymmword ptr [rbp+90h+var_70.weaponIdx], ymm2
                vmovups xmm0, xmmword ptr [rax+20h]
                vmovups xmmword ptr [rbp+90h+var_70.attachmentVariationIndices+5], xmm0
                vmovsd  xmm1, qword ptr [rax+30h]
                vmovsd  qword ptr [rbp+90h+var_70.attachmentVariationIndices+15h], xmm1
              }
              *(_DWORD *)&v86.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
              __asm { vmovd   eax, xmm2 }
              if ( (_WORD)_RAX )
                G_Weapon_TakePlayerWeapon(&ent->client->ps, &v86);
            }
          }
        }
      }
    }
  }
}

/*
==============
Cmd_UFO_Viewmodel_f
==============
*/
void Cmd_UFO_Viewmodel_f(gentity_s *ent)
{
  gclient_s *client; 
  int *p_flags; 
  int v4; 
  int v5; 
  gagent_s *agent; 
  int v7; 

  if ( !ent->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 963, ASSERT_TYPE_ASSERT, "( ent->client )", (const char *)&queryFormat, "ent->client") )
    __debugbreak();
  Stream_ImageRecord_Disable("ufo_viewmodel");
  Cmd_UFO_f(ent, 0);
  client = ent->client;
  p_flags = NULL;
  v4 = 0;
  v5 = 0;
  if ( client )
  {
    v5 = 16;
    p_flags = &client->flags;
    v4 = 2;
  }
  else
  {
    agent = ent->agent;
    if ( agent )
    {
      p_flags = &agent->flags;
      v5 = 128;
      v4 = 64;
    }
  }
  v7 = *p_flags;
  if ( (*p_flags & v4) != 0 )
    *p_flags = v5 | v7;
  else
    *p_flags = v7 & ~v5;
}

/*
==============
Cmd_UFO_f
==============
*/
void Cmd_UFO_f(gentity_s *ent, bool fromScript)
{
  __int64 v4; 
  int CheatsOk; 
  unsigned int EntityIndex; 
  const char *v7; 
  const char *v8; 
  SvClient *CommonClient; 
  gclient_s *client; 
  int *p_flags; 
  int v12; 
  gagent_s *agent; 
  bool v14; 
  char v15; 
  int v16; 
  playerState_s *EntityPlayerState; 
  const char *v18; 
  __int16 v19; 
  char buffer[1024]; 

  v4 = 0i64;
  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 36, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( com_cheats->current.enabled )
    {
      CheatsOk = 1;
    }
    else
    {
      EntityIndex = G_GetEntityIndex(ent);
      v7 = j_va("%c \"%s\"", 101i64, "GAME/CHEATSNOTENABLED");
      v8 = v7;
      if ( EntityIndex == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v7);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(EntityIndex);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v8);
      }
      CheatsOk = 0;
    }
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    if ( !ent->client && !ent->agent )
    {
      Com_PrintError(15, "Ufo: No client or agent for ent %i\n", (unsigned int)ent->s.number);
      return;
    }
    Stream_ImageRecord_Disable("ufo");
    client = ent->client;
    p_flags = NULL;
    v12 = 0;
    if ( client )
    {
      p_flags = &client->flags;
      v12 = 2;
    }
    else
    {
      agent = ent->agent;
      if ( agent )
      {
        p_flags = &agent->flags;
        v12 = 64;
      }
    }
    v14 = (v12 & *p_flags) == 0;
    if ( !fromScript && SV_Cmd_Argc() > 1 )
    {
      SV_Cmd_ArgvBuffer(1, buffer, 0x400ui64);
      while ( 1 )
      {
        v15 = buffer[v4++];
        if ( v15 != aOff[v4 - 1] )
          break;
        if ( v4 == 4 )
        {
          v14 = 0;
          goto LABEL_27;
        }
      }
      if ( buffer[0] != aOn[0] || buffer[1] != aOn[1] || buffer[2] != aOn[2] )
      {
        Com_Printf(0, "USAGE: ufo [off/on]\n");
        return;
      }
      v14 = 1;
    }
LABEL_27:
    v16 = *p_flags;
    if ( v14 )
    {
      *p_flags = v12 | v16;
      EntityPlayerState = G_GetEntityPlayerState(ent);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 938, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( BGVehicles::IsRemoteDrivingVehicle(EntityPlayerState) )
      {
        EntityPlayerState->origin.v[0] = EntityPlayerState->vehicleState.origin.v[0];
        EntityPlayerState->origin.v[1] = EntityPlayerState->vehicleState.origin.v[1];
        EntityPlayerState->origin.v[2] = EntityPlayerState->vehicleState.origin.v[2];
      }
      v18 = "GAME/UFOON";
    }
    else
    {
      v18 = "GAME/UFOOFF";
      *p_flags = v16 & ~v12;
    }
    if ( ent->client )
    {
      v19 = G_GetEntityIndex(ent);
      SV_SendPrintDebugCommand(v19, v18);
    }
  }
}

/*
==============
Cmd_UmbraPortalList_f
==============
*/
void Cmd_UmbraPortalList_f(void)
{
  unsigned int numUmbraGates; 
  unsigned int v1; 
  unsigned __int64 v2; 
  __int64 v3; 
  const char *v4; 
  __int64 v5; 
  __int64 v6; 

  Com_Printf(0, "Umbra portals:  name  open/closed\n");
  if ( !comWorld.isInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 141, ASSERT_TYPE_ASSERT, "(Com_IsWorldLoaded())", (const char *)&queryFormat, "Com_IsWorldLoaded()") )
    __debugbreak();
  numUmbraGates = comWorld.numUmbraGates;
  v1 = 0;
  if ( comWorld.numUmbraGates )
  {
    v2 = 0i64;
    v3 = 0i64;
    do
    {
      if ( v1 >= 0x180 )
      {
        LODWORD(v6) = 384;
        LODWORD(v5) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v5, v6) )
          __debugbreak();
      }
      v4 = "closed";
      if ( ((0x80000000 >> (v1 & 0x1F)) & level.umbraGateStates.array[v2 >> 5]) != 0 )
        v4 = "open";
      Com_Printf(0, "\t%s\t\t%s\n", comWorld.umbraGateNames[v3], v4);
      ++v1;
      ++v2;
      ++v3;
    }
    while ( v1 < numUmbraGates );
  }
}

/*
==============
Cmd_UmbraPortalToggle_f
==============
*/
void Cmd_UmbraPortalToggle_f(void)
{
  bool v0; 
  unsigned __int64 v1; 
  unsigned int gateIndexOut[4]; 
  char buffer[1024]; 

  if ( SV_Cmd_Argc() == 2 )
  {
    SV_Cmd_ArgvBuffer(1, buffer, 0x400ui64);
    gateIndexOut[0] = 0;
    if ( Com_GetUmbraGateIndex(buffer, gateIndexOut) )
    {
      v0 = bitarray_base<bitarray<384>>::testBit(&level.umbraGateStates, gateIndexOut[0]);
      v1 = gateIndexOut[0];
      if ( v0 )
      {
        if ( gateIndexOut[0] >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut[0], 384) )
          __debugbreak();
        level.umbraGateStates.array[v1 >> 5] &= ~(0x80000000 >> (v1 & 0x1F));
      }
      else
      {
        if ( gateIndexOut[0] >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut[0], 384) )
          __debugbreak();
        level.umbraGateStates.array[v1 >> 5] |= 0x80000000 >> (v1 & 0x1F);
      }
    }
    else
    {
      Com_Printf(0, "UmbraPortalToggle:  Unknown portal %s\n", buffer);
    }
  }
  else
  {
    Com_Printf(0, "USAGE: UmbraPortalToggle name_of_portal\n");
  }
}

/*
==============
Cmd_Where_f
==============
*/
void Cmd_Where_f(gentity_s *ent)
{
  const char *v2; 
  unsigned int EntityIndex; 
  const char *v4; 
  const char *v5; 
  SvClient *CommonClient; 

  v2 = vtos(&ent->r.currentOrigin);
  EntityIndex = G_GetEntityIndex(ent);
  v4 = j_va("%c \"%s\"", 101i64, v2);
  v5 = v4;
  if ( EntityIndex == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(EntityIndex);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
  }
}

/*
==============
ConcatArgs
==============
*/
char *ConcatArgs(int start)
{
  int v2; 
  int i; 
  unsigned __int64 v4; 
  size_t v5; 
  int v6; 
  char buffer[1024]; 

  v2 = 0;
  for ( i = SV_Cmd_Argc(); start < i; ++start )
  {
    SV_Cmd_ArgvBuffer(start, buffer, 0x400ui64);
    v4 = -1i64;
    do
      ++v4;
    while ( buffer[v4] );
    if ( v4 > 0x7FFFFFFFFFFFFFFFi64 || v4 + 0x80000000 > 0xFFFFFFFF )
    {
      v5 = (int)v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v4, "unsigned", v4) )
        __debugbreak();
    }
    else
    {
      v5 = (int)v4;
    }
    v6 = v2 + v4;
    if ( v6 >= 1023 )
      break;
    memcpy_0(&line[v2], buffer, v5);
    v2 = v6;
    if ( start != i - 1 )
    {
      line[v6] = 32;
      v2 = v6 + 1;
    }
  }
  if ( (unsigned __int64)v2 >= 0x400 )
  {
    j___report_rangecheckfailure(v2);
    JUMPOUT(0x14127DA63i64);
  }
  line[v2] = 0;
  return line;
}

/*
==============
G_Cmd_EntityList_f
==============
*/
void G_Cmd_EntityList_f(void)
{
  unsigned int v0; 
  __int64 v1; 
  __int64 v2; 
  scr_string_t *p_classname; 
  const char *EntityTypeName; 
  const char *v5; 
  __int64 v6; 
  __int64 v7; 

  v0 = 1;
  if ( level.num_entities > 1 )
  {
    v1 = 1i64;
    v2 = 1i64;
    p_classname = &g_entities[1].classname;
    do
    {
      if ( v0 >= 0x800 )
      {
        LODWORD(v7) = 2048;
        LODWORD(v6) = v0;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v1].r.isInUse != g_entityIsInUse[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v2] )
      {
        Com_Printf(0, "%3i: ", v0);
        EntityTypeName = BG_GetEntityTypeName((const entityType_s)*((_WORD *)p_classname - 186));
        Com_Printf(0, "'%s'", EntityTypeName);
        if ( *p_classname )
        {
          v5 = SL_ConvertToString(*p_classname);
          Com_Printf(0, ", '%s'", v5);
        }
        Com_Printf(0, "\n");
      }
      ++v0;
      ++v2;
      ++v1;
      p_classname += 364;
    }
    while ( (int)v0 < level.num_entities );
  }
}

/*
==============
G_Cmd_EntitymarkBaseline_f
==============
*/
void G_Cmd_EntitymarkBaseline_f(void)
{
  int v0; 
  __int64 v1; 
  __int64 v2; 
  __int64 v3; 
  __int64 v4; 

  v0 = 0;
  if ( level.num_entities > 0 )
  {
    v1 = 0i64;
    v2 = 0i64;
    do
    {
      if ( (unsigned int)v0 >= 0x800 )
      {
        LODWORD(v4) = 2048;
        LODWORD(v3) = v0;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v3, v4) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v1].r.isInUse != g_entityIsInUse[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v2] )
        g_entities[v1].flags.m_flags[0] |= 0x40000000u;
      ++v0;
      ++v2;
      ++v1;
    }
    while ( v0 < level.num_entities );
  }
}

/*
==============
G_Cmds_AreCheatsOk
==============
*/
int G_Cmds_AreCheatsOk(gentity_s *ent)
{
  int ok; 

  if ( SV_IsDemoPlaying() )
    return SV_Demo_GetCheatsOk();
  ok = G_Cmds_CheatsOkInternal(ent, 1);
  SV_Demo_RecordCheatsOk(ok);
  return ok;
}

/*
==============
G_Cmds_AreCheatsOk_NoHealthCheck
==============
*/
int G_Cmds_AreCheatsOk_NoHealthCheck(gentity_s *ent)
{
  unsigned int EntityIndex; 
  const char *v4; 
  const char *v5; 
  SvClient *CommonClient; 

  if ( SV_IsDemoPlaying() )
    return SV_Demo_GetCheatsOk();
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 36, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( com_cheats->current.enabled )
  {
    SV_Demo_RecordCheatsOk(1);
    return 1;
  }
  else
  {
    EntityIndex = G_GetEntityIndex(ent);
    v4 = j_va("%c \"%s\"", 101i64, "GAME/CHEATSNOTENABLED");
    v5 = v4;
    if ( EntityIndex == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(EntityIndex);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
    }
    SV_Demo_RecordCheatsOk(0);
    return 0;
  }
}

/*
==============
G_Cmds_CheatsOkInternal
==============
*/
char G_Cmds_CheatsOkInternal(gentity_s *ent, bool doHealthCheck)
{
  __int16 EntityIndex; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  const char *v8; 
  SvClient *CommonClient; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 36, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( com_cheats->current.enabled )
  {
    if ( !doHealthCheck || ent->health > 0 )
      return 1;
    EntityIndex = G_GetEntityIndex(ent);
    v5 = "GAME/MUSTBEALIVECOMMAND";
  }
  else
  {
    EntityIndex = G_GetEntityIndex(ent);
    v5 = "GAME/CHEATSNOTENABLED";
  }
  v6 = EntityIndex;
  v7 = j_va("%c \"%s\"", 101i64, v5);
  v8 = v7;
  if ( v6 == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v7);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(v6);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v8);
  }
  return 0;
}

/*
==============
G_Cmds_GiveInternal
==============
*/
void G_Cmds_GiveInternal(gentity_s *ent, const char *name, int amount, int forceGive)
{
  int CheatsOk; 
  const playerState_s *EntityPlayerState; 
  playerState_s *v9; 
  const char *v10; 
  __int64 v11; 
  __int64 v12; 
  int v13; 
  __int64 v14; 
  int v15; 
  unsigned int v16; 
  int v17; 
  int v18; 
  unsigned int v19; 
  int v20; 
  const char *v21; 
  __int64 v22; 
  int v23; 
  __int64 v24; 
  int v25; 
  int v26; 
  int v27; 
  const char *v28; 
  int v29; 
  __int64 v30; 
  int v31; 
  int v32; 
  int v33; 
  GWeaponMap *Instance; 
  __int64 v35; 
  const char *v36; 
  __int64 v37; 
  int v38; 
  __int64 v39; 
  int v40; 
  int v41; 
  int v42; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned int i; 
  const Weapon *EquippedWeaponForPlayer; 
  const Weapon *v46; 
  scrContext_t *v47; 
  const char *v48; 
  __int64 v49; 
  int v50; 
  __int64 v51; 
  int v52; 
  int v53; 
  int v54; 
  const Weapon *v55; 
  const Weapon *v56; 
  const char *v57; 
  const ExecutionDef *Def; 
  const char *v59; 
  const char *v61; 
  __int64 v64; 
  const Weapon *FirstEquippedWeaponBySlot; 
  PlayerEquippedWeaponState *EquippedWeaponStateNonConst; 
  const char *v71; 
  const char *v72; 
  const char *v74; 
  __int64 v77; 
  const Weapon *v82; 
  PlayerEquippedWeaponState *v83; 
  const char *v85; 
  char v89; 
  __int64 v90; 
  char v91; 
  char v92; 
  unsigned __int64 v93; 
  gentity_s *v94; 
  gentity_s *v95; 
  gentity_s *v96; 
  OffhandClass offhandClass; 
  __int16 EntityIndex; 
  PlayerEquippedWeaponState *v99; 
  GHandler *Handler; 
  bool v101; 
  int count; 
  unsigned int outAccessoryIndex; 
  int v104; 
  gentity_s *enta; 
  Weapon result; 
  Weapon Buf1; 
  Weapon r_weapon; 

  v104 = forceGive;
  count = amount;
  enta = ent;
  if ( SV_IsDemoPlaying() )
  {
    CheatsOk = SV_Demo_GetCheatsOk();
  }
  else
  {
    CheatsOk = (unsigned __int8)G_Cmds_CheatsOkInternal(ent, 1);
    SV_Demo_RecordCheatsOk(CheatsOk);
  }
  if ( CheatsOk )
  {
    EntityPlayerState = G_GetEntityPlayerState(ent);
    v9 = (playerState_s *)EntityPlayerState;
    if ( EntityPlayerState )
    {
      v101 = BG_UsingAlternate(EntityPlayerState);
      if ( name )
      {
        if ( *name )
        {
          v10 = "all";
          v11 = 0x7FFFFFFFi64;
          v12 = 0x7FFFFFFFi64;
          while ( 1 )
          {
            v13 = (unsigned __int8)v10[name - "all"];
            v14 = v12;
            v15 = *(unsigned __int8 *)v10++;
            --v12;
            v16 = 0;
            if ( !v14 )
            {
LABEL_17:
              Dvar_SetBool_Internal(DVARBOOL_bg_giveAll, 1);
              v19 = 1;
              outAccessoryIndex = 1;
              goto LABEL_18;
            }
            if ( v13 != v15 )
            {
              v17 = v13 + 32;
              if ( (unsigned int)(v13 - 65) > 0x19 )
                v17 = v13;
              v13 = v17;
              v18 = v15 + 32;
              if ( (unsigned int)(v15 - 65) > 0x19 )
                v18 = v15;
              if ( v13 != v18 )
                break;
            }
            if ( !v13 )
              goto LABEL_17;
          }
          v21 = "health";
          outAccessoryIndex = 0;
          v19 = 0;
          v22 = 6i64;
          do
          {
            v23 = (unsigned __int8)v21[name - "health"];
            v24 = v22;
            v25 = *(unsigned __int8 *)v21++;
            --v22;
            if ( !v24 )
              break;
            if ( v23 != v25 )
            {
              v26 = v23 + 32;
              if ( (unsigned int)(v23 - 65) > 0x19 )
                v26 = v23;
              v23 = v26;
              v27 = v25 + 32;
              if ( (unsigned int)(v25 - 65) > 0x19 )
                v27 = v25;
              if ( v23 != v27 )
              {
                v28 = "weapons";
                while ( 1 )
                {
                  v29 = (unsigned __int8)v28[name - "weapons"];
                  v30 = v11;
                  v31 = *(unsigned __int8 *)v28++;
                  --v11;
                  if ( !v30 )
                  {
LABEL_39:
                    Dvar_SetBool_Internal(DVARBOOL_bg_giveAll, 1);
                    return;
                  }
                  if ( v29 != v31 )
                  {
                    v32 = v29 + 32;
                    if ( (unsigned int)(v29 - 65) > 0x19 )
                      v32 = v29;
                    v29 = v32;
                    v33 = v31 + 32;
                    if ( (unsigned int)(v31 - 65) > 0x19 )
                      v33 = v31;
                    if ( v29 != v33 )
                      break;
                  }
                  if ( !v29 )
                    goto LABEL_39;
                }
                v20 = count;
                goto LABEL_44;
              }
            }
          }
          while ( v23 );
LABEL_18:
          v20 = count;
          if ( count )
            ent->health += count;
          else
            ent->health = v9->stats[2];
          if ( v19 )
          {
LABEL_44:
            Instance = GWeaponMap::GetInstance();
            v35 = 4i64;
            if ( !v19 )
            {
              v36 = "ammo";
              v37 = 4i64;
              do
              {
                v38 = (unsigned __int8)v36[name - "ammo"];
                v39 = v37;
                v40 = *(unsigned __int8 *)v36++;
                --v37;
                if ( !v39 )
                  break;
                if ( v38 != v40 )
                {
                  v41 = v38 + 32;
                  if ( (unsigned int)(v38 - 65) > 0x19 )
                    v41 = v38;
                  v38 = v41;
                  v42 = v40 + 32;
                  if ( (unsigned int)(v40 - 65) > 0x19 )
                    v42 = v40;
                  if ( v38 != v42 )
                    goto LABEL_64;
                }
              }
              while ( v38 );
            }
            if ( v20 )
            {
              CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, v9);
              if ( CurrentWeaponForPlayer->weaponIdx )
                G_Items_AddAmmo(v9, CurrentWeaponForPlayer, v101, v20, 1);
            }
            else
            {
              for ( i = 0; i < 0xF; ++i )
              {
                EquippedWeaponForPlayer = BG_GetEquippedWeaponForPlayer(Instance, v9, i);
                v46 = EquippedWeaponForPlayer;
                if ( EquippedWeaponForPlayer->weaponIdx )
                {
                  G_Items_AddAmmo(v9, EquippedWeaponForPlayer, 0, 998, 1);
                  if ( BG_HasUnderbarrelAmmo(v46) )
                    G_Items_AddAmmo(v9, v46, 1, 998, 1);
                }
              }
              v19 = outAccessoryIndex;
              v20 = count;
            }
            v47 = ScriptContext_Server();
            Scr_AddInt(v47, v20);
            GScr_Notify(enta, scr_const.give_ammo, 1u);
            if ( v19 )
            {
LABEL_64:
              v48 = "allammo";
              v49 = 7i64;
              do
              {
                v50 = (unsigned __int8)v48[name - "allammo"];
                v51 = v49;
                v52 = *(unsigned __int8 *)v48++;
                --v49;
                if ( !v51 )
                  break;
                if ( v50 != v52 )
                {
                  v53 = v50 + 32;
                  if ( (unsigned int)(v50 - 65) > 0x19 )
                    v53 = v50;
                  v50 = v53;
                  v54 = v52 + 32;
                  if ( (unsigned int)(v52 - 65) > 0x19 )
                    v54 = v52;
                  if ( v50 != v54 )
                    goto LABEL_79;
                }
              }
              while ( v50 );
              if ( v20 )
              {
                do
                {
                  v55 = BG_GetEquippedWeaponForPlayer(Instance, v9, v16);
                  v56 = v55;
                  if ( v55->weaponIdx )
                  {
                    G_Items_AddAmmo(v9, v55, 0, 998, 1);
                    if ( BG_HasUnderbarrelAmmo(v56) )
                      G_Items_AddAmmo(v9, v56, 1, 998, 1);
                  }
                  ++v16;
                }
                while ( v16 < 0xF );
                return;
              }
LABEL_79:
              if ( !v19 )
              {
                level.initializing = 1;
                v57 = SV_Cmd_Argv(1);
                count = 255;
                if ( NetConstStrings_GetExecutionIndex(v57, (unsigned int *)&count) )
                {
                  Def = BG_Execution_GetDef(count);
                  if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 271, ASSERT_TYPE_ASSERT, "( execDef ) != ( nullptr )", "%s != %s\n\t%p, %p", "execDef", "nullptr", NULL, NULL) )
                    __debugbreak();
                  v59 = SV_Cmd_Argv(2);
                  __asm { vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON }
                  v61 = v59;
                  __asm
                  {
                    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
                    vmovups [rbp+60h+Buf1], ymm0
                    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
                  }
                  *(_DWORD *)&Buf1.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
                  v64 = -1i64;
                  __asm
                  {
                    vmovsd  [rbp+60h+var_88], xmm0
                    vmovups [rbp+60h+var_98], xmm1
                  }
                  do
                    ++v64;
                  while ( v59[v64] );
                  if ( v64 )
                  {
                    _RAX = G_Weapon_GetWeaponForName(&result, v59);
                    __asm
                    {
                      vmovups ymm0, ymmword ptr [rax]
                      vmovups [rbp+60h+Buf1], ymm0
                      vmovups xmm1, xmmword ptr [rax+20h]
                      vmovups [rbp+60h+var_98], xmm1
                      vmovsd  xmm0, qword ptr [rax+30h]
                      vmovsd  [rbp+60h+var_88], xmm0
                    }
                    *(_DWORD *)&Buf1.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
                  }
                  if ( Def->usePropWeapon && !memcmp_0(&Buf1, &NULL_WEAPON, 0x3Cui64) )
                  {
                    Com_PrintError(1, "Execution %s requires that a valid prop weapon is specified as a second argument to 'give'.  Try \"give <execution> <propWeapon>\".\n", name);
                  }
                  else if ( BG_GetWeaponType(&Buf1, v101) == WEAPTYPE_MODEL_ONLY )
                  {
                    if ( BG_WeaponDef(&Buf1, v101)->inventoryType == WEAPINVENTORY_MODEL_ONLY )
                    {
                      FirstEquippedWeaponBySlot = BG_GetFirstEquippedWeaponBySlot(Instance, v9, WEAPON_SLOT_EXECUTION);
                      if ( memcmp_0(FirstEquippedWeaponBySlot, &NULL_WEAPON, 0x3Cui64) )
                        G_Weapon_TakePlayerWeapon(v9, FirstEquippedWeaponBySlot);
                      if ( memcmp_0(&Buf1, &NULL_WEAPON, 0x3Cui64) )
                      {
                        G_Weapon_GivePlayerWeapon(v9, NULL, &Buf1, 0, 0, 0);
                        EquippedWeaponStateNonConst = BG_GetEquippedWeaponStateNonConst(Instance, v9, &Buf1);
                        if ( !EquippedWeaponStateNonConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 314, ASSERT_TYPE_ASSERT, "(equippedData)", (const char *)&queryFormat, "equippedData") )
                          __debugbreak();
                        EquippedWeaponStateNonConst->slot = WEAPON_SLOT_EXECUTION;
                      }
                      v9->equippedExecution = count;
                    }
                    else
                    {
                      Com_PrintError(1, "Execution Weapon asset '%s' must be of inventory type 'model only'.", v61);
                    }
                  }
                  else
                  {
                    Com_PrintError(1, "Execution Weapon asset '%s' must be of weapon type 'model only'.", v61);
                  }
                }
                else
                {
                  v71 = SV_Cmd_Argv(1);
                  outAccessoryIndex = 127;
                  if ( NetConstStrings_GetAccessoryIndex(v71, &outAccessoryIndex) )
                  {
                    v72 = SV_Cmd_Argv(2);
                    __asm { vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON }
                    v74 = v72;
                    __asm
                    {
                      vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
                      vmovups [rbp+60h+Buf1], ymm0
                      vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
                    }
                    *(_DWORD *)&Buf1.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
                    v77 = -1i64;
                    __asm
                    {
                      vmovsd  [rbp+60h+var_88], xmm0
                      vmovups [rbp+60h+var_98], xmm1
                    }
                    do
                      ++v77;
                    while ( v72[v77] );
                    if ( v77 )
                    {
                      _RAX = G_Weapon_GetWeaponForName(&result, v72);
                      __asm
                      {
                        vmovups ymm2, ymmword ptr [rax]
                        vmovups [rbp+60h+Buf1], ymm2
                        vmovups xmm0, xmmword ptr [rax+20h]
                        vmovups [rbp+60h+var_98], xmm0
                        vmovsd  xmm1, qword ptr [rax+30h]
                        vmovsd  [rbp+60h+var_88], xmm1
                      }
                      *(_DWORD *)&Buf1.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
                      __asm { vmovd   eax, xmm2 }
                      if ( !(_WORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 338, ASSERT_TYPE_ASSERT, "( newAccessoryWeapon.weaponIdx ) != ( 0 )", "%s != %s\n\t%i, %i", "newAccessoryWeapon.weaponIdx", "WP_NONE", 0, 0i64) )
                        __debugbreak();
                      if ( !memcmp_0(&Buf1, &NULL_WEAPON, 0x3Cui64) )
                      {
                        Com_PrintError(1, "Accessory Weapon asset '%s' must not be a NULL weapon.", v74);
                      }
                      else if ( BG_GetWeaponType(&Buf1, v101) == WEAPTYPE_MODEL_ONLY )
                      {
                        if ( BG_WeaponDef(&Buf1, v101)->inventoryType == WEAPINVENTORY_MODEL_ONLY )
                        {
                          v82 = BG_GetFirstEquippedWeaponBySlot(Instance, v9, WEAPON_SLOT_ACCESSORY);
                          if ( memcmp_0(v82, &NULL_WEAPON, 0x3Cui64) )
                            G_Weapon_TakePlayerWeapon(v9, v82);
                          G_Weapon_GivePlayerWeapon(v9, NULL, &Buf1, 0, 0, 0);
                          v83 = BG_GetEquippedWeaponStateNonConst(Instance, v9, &Buf1);
                          if ( !v83 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 370, ASSERT_TYPE_ASSERT, "(equippedData)", (const char *)&queryFormat, "equippedData") )
                            __debugbreak();
                          v83->slot = WEAPON_SLOT_ACCESSORY;
                          v9->accessoryIndex = outAccessoryIndex;
                        }
                        else
                        {
                          Com_PrintError(1, "Accessory Weapon asset '%s' must be of inventory type 'model only'.", v74);
                        }
                      }
                      else
                      {
                        Com_PrintError(1, "Accessory Weapon asset '%s' must be of weapon type 'model only'.", v74);
                      }
                    }
                    else
                    {
                      Com_PrintError(1, "Accessory %s requires that a valid accessory weapon is specified as a second argument to 'give'.  Try \"give <accessory> <accessoryWeapon>\".\n", name);
                    }
                  }
                  else
                  {
                    _RAX = G_Weapon_GetWeaponForName(&result, name);
                    v85 = "none";
                    __asm
                    {
                      vmovups ymm0, ymmword ptr [rax]
                      vmovups ymmword ptr [rbp+60h+r_weapon.weaponIdx], ymm0
                      vmovups xmm1, xmmword ptr [rax+20h]
                      vmovups xmmword ptr [rbp+60h+r_weapon.attachmentVariationIndices+5], xmm1
                      vmovsd  xmm0, qword ptr [rax+30h]
                      vmovsd  qword ptr [rbp+60h+r_weapon.attachmentVariationIndices+15h], xmm0
                    }
                    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
                    while ( 1 )
                    {
                      v89 = v85[name - "none"];
                      v90 = v35;
                      v91 = *v85++;
                      --v35;
                      if ( !v90 )
                        goto LABEL_127;
                      if ( v89 != v91 )
                        break;
                      if ( !v89 )
                        goto LABEL_127;
                    }
                    v93 = -1i64;
                    do
                      ++v93;
                    while ( name[v93] );
                    if ( v93 <= 4 || *name != 97 || name[1] != 108 || name[2] != 116 || name[3] != 95 )
                    {
LABEL_127:
                      v92 = 0;
                      goto LABEL_128;
                    }
                    v92 = 1;
LABEL_128:
                    if ( r_weapon.weaponIdx )
                    {
                      if ( BG_WeaponDef(&r_weapon, 0)->inventoryType == WEAPINVENTORY_ALTMODE )
                      {
                        Com_PrintError(1, "You can't directly spawn the altfire weapon '%s'.  Spawn a weapon that has this altmode instead.\n", name);
                      }
                      else
                      {
                        v94 = G_Utils_SpawnEntity();
                        v95 = enta;
                        v96 = v94;
                        v94->r.currentOrigin = enta->r.currentOrigin;
                        G_Items_GetClassname(&r_weapon, v94);
                        G_Items_Spawn(v96, &r_weapon);
                        v96->active = 1;
                        offhandClass = BG_WeaponDef(&v96->c.item[0].weapon, 0)->offhandClass;
                        if ( offhandClass && v9->weapCommon.offhandPrimary != offhandClass && v9->weapCommon.offhandSecondary != offhandClass )
                        {
                          if ( ((offhandClass - 1) & 0xFFFFFFF9) != 0 || offhandClass == OFFHAND_CLASS_FLASH_GRENADE )
                            v9->weapCommon.offhandSecondary = offhandClass;
                          else
                            v9->weapCommon.offhandPrimary = offhandClass;
                        }
                        G_Items_Touch(v96, v95, 0, 0);
                        v96->active = 0;
                        EntityIndex = G_GetEntityIndex(v96);
                        if ( G_IsEntityInUse(EntityIndex) )
                        {
                          if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
                            __debugbreak();
                          GUtils::ms_gUtils->FreeEntity(GUtils::ms_gUtils, v96);
                        }
                        if ( v92 )
                        {
                          v99 = BG_GetEquippedWeaponStateNonConst(Instance, v9, &r_weapon);
                          if ( v99 )
                            v99->inAltMode = 1;
                        }
                        if ( v104 )
                        {
                          Handler = GHandler::getHandler();
                          BG_SetCurrentWeaponForPlayer(Instance, v9, &r_weapon, Handler);
                        }
                      }
                    }
                    level.initializing = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
G_Cmds_InvokeLuiCallback
==============
*/
void G_Cmds_InvokeLuiCallback(gentity_s *ent, unsigned int numParams)
{
  scrContext_t *v4; 
  unsigned int v5; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1138, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  v4 = ScriptContext_Server();
  if ( !GameScriptData::ms_gScriptData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 78, ASSERT_TYPE_ASSERT, "(ms_gScriptData)", "%s\n\tAttempting to access game data outside of an active game context", "ms_gScriptData") )
    __debugbreak();
  if ( !(_BYTE)GameScriptData::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 79, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tAttempting to access game data outside of an active game context", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  v5 = GScr_ExecEntThread(ent, GameScriptData::ms_gScriptData->lui_callback, numParams);
  Scr_FreeThread(v4, v5);
}

/*
==============
G_Cmds_LuiNotifyServer_StrChannel_f
==============
*/
void G_Cmds_LuiNotifyServer_StrChannel_f(gentity_s *pEnt)
{
  scrContext_t *v2; 
  const char *v3; 
  int v4; 

  v2 = ScriptContext_Server();
  if ( SV_Cmd_Argc() == 3 )
  {
    v3 = SV_Cmd_Argv(1);
    v4 = SV_Cmd_ArgInt(2);
  }
  else
  {
    v3 = "bad";
    v4 = -1;
  }
  Scr_AddInt(v2, v4);
  Scr_AddString(v2, v3);
  G_Cmds_InvokeLuiCallback(pEnt, 2u);
}

/*
==============
G_Cmds_TestCmd_f
==============
*/
void G_Cmds_TestCmd_f(gentity_s *ent)
{
  unsigned int NumWeapons; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1085, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !ent->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 1086, ASSERT_TYPE_ASSERT, "(ent->client)", (const char *)&queryFormat, "ent->client") )
    __debugbreak();
  NumWeapons = BG_GetNumWeapons();
  Com_Printf(0, "\n%i - Total Weapons\n", NumWeapons);
}

/*
==============
SV_SendPrintDebugCommand
==============
*/
void SV_SendPrintDebugCommand(int clientNum, const char *msg)
{
  const char *v3; 
  const char *v4; 
  SvClient *CommonClient; 

  v3 = j_va("%c \"%s\"", 101i64, msg);
  v4 = v3;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v3);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v4);
  }
}

/*
==============
SanitizeString
==============
*/
void SanitizeString(char *in, char *out)
{
  char v2; 
  char *v3; 
  char *v4; 
  __int64 v5; 

  v2 = *in;
  v3 = out;
  v4 = in;
  if ( *in )
  {
    do
    {
      if ( v2 == 27 )
      {
        v5 = 2i64;
      }
      else
      {
        if ( v2 >= 32 )
          *v3++ = tolower(v2);
        v5 = 1i64;
      }
      v4 += v5;
      v2 = *v4;
    }
    while ( *v4 );
    *v3 = 0;
  }
  else
  {
    *out = 0;
  }
}

/*
==============
TakeAwayAmmo
==============
*/
void TakeAwayAmmo(playerState_s *ps, const Weapon *weapon, bool isAlternate, int amount)
{
  bool v5; 
  int v11; 
  int ammoCount; 
  GWeaponMap *Instance; 
  int EquippedWeaponIndex; 
  int v15; 
  unsigned int v17; 
  ClipAmmo *ammoInClip; 
  int v19; 
  __int64 v20; 
  __int64 v24; 
  int v27; 
  AmmoStore result; 
  AmmoStore r_ammo2; 
  AmmoStore r_clipIndex; 

  v5 = isAlternate;
  if ( !ps )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 473, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1322, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  _RAX = BG_AmmoStoreForWeapon(&result, weapon, v5);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1304, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v11 = 0;
  while ( !BG_IsAmmoCompatible(&ps->weapCommon.ammoNotInClip[v11].ammoType, &r_ammo2) )
  {
    if ( (unsigned int)++v11 >= 0xF )
      goto LABEL_12;
  }
  if ( (playerState_s *)((char *)ps + 68 * v11) == (playerState_s *)-1912i64 )
  {
LABEL_12:
    ammoCount = 0;
    goto LABEL_13;
  }
  ammoCount = ps->weapCommon.ammoNotInClip[v11].ammoCount;
LABEL_13:
  Instance = GWeaponMap::GetInstance();
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1063, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1064, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  EquippedWeaponIndex = BG_GetEquippedWeaponIndex(Instance, ps, weapon);
  if ( EquippedWeaponIndex < 0 || (playerState_s *)((char *)ps + 16 * EquippedWeaponIndex) == (playerState_s *)-1540i64 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_cmds.cpp", 477, ASSERT_TYPE_ASSERT, "(equippedWeapon)", (const char *)&queryFormat, "equippedWeapon") )
      __debugbreak();
  }
  else if ( ammoCount <= amount )
  {
    v15 = amount - ammoCount;
    BG_SetGlobalAmmo(ps, weapon, v5, 0);
    _RAX = BG_AmmoStoreForWeapon(&result, weapon, v5);
    v17 = 0;
    ammoInClip = ps->weapCommon.ammoInClip;
    v19 = 0;
    v20 = 0i64;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+158h+r_clipIndex.weapon.weaponIdx], ymm0
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rsp+158h+r_clipIndex.weapon.attachmentVariationIndices+5], ymm1
    }
    do
    {
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1248, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      _RAX = BG_AmmoStoreForWeapon(&result, weapon, v5);
      v24 = v20;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.weaponIdx], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
      }
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1229, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( BG_HasLadderHand(ps) && v20 == 1 )
        v24 = 0i64;
      while ( !BG_IsClipCompatible(&ammoInClip->clipIndex, &r_ammo2) )
      {
        ++v17;
        ++ammoInClip;
        if ( v17 >= 0xF )
        {
          v17 = 0;
          v27 = 0;
          goto LABEL_39;
        }
      }
      v27 = ammoInClip->ammoCount[v24];
      v17 = 0;
LABEL_39:
      if ( v27 <= v15 )
      {
        v5 = isAlternate;
        v15 -= v27;
        BG_SetClipAmmo(ps, &r_clipIndex, weapon, isAlternate, (PlayerHandIndex)v19, 0);
      }
      else
      {
        BG_AddClipAmmo(ps, &r_clipIndex, (PlayerHandIndex)v19, -v15);
        v5 = isAlternate;
      }
      ++v19;
      ammoInClip = ps->weapCommon.ammoInClip;
      ++v20;
    }
    while ( v19 < 2 );
  }
  else
  {
    BG_SetGlobalAmmo(ps, weapon, v5, ammoCount - amount);
  }
}

