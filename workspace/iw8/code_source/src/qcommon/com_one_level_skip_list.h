/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 0x21u )
  {
    v6 = 33;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 6u )
  {
    v6 = 6;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  __int64 v5; 
  unsigned __int16 v9; 
  bool v11; 
  bool v12; 
  bool v13; 
  unsigned __int16 nextPageIndex; 
  __int64 v18; 
  unsigned __int8 keyCount; 
  signed __int32 lock; 
  unsigned __int8 v24; 
  signed __int32 v28; 
  signed __int32 v29; 
  signed __int32 v30; 
  signed __int32 v31; 
  signed __int32 v32; 
  unsigned __int16 v33; 
  __int64 v34; 
  __int64 v36; 
  unsigned __int16 v40; 
  unsigned __int16 v41; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v45; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v47; 
  __int64 v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  unsigned __int16 outNextPageIndex; 
  __int64 v54; 
  __int64 v55; 

  _R9 = this->m_linkKeys;
  _R14 = key;
  _R15 = this;
  v5 = 5i64;
  __asm { vmovss  xmm1, dword ptr [rdx+4] }
  do
  {
    _RCX = v5 >> 1;
    __asm
    {
      vmovss  xmm0, dword ptr [r9+rcx*8+4]
      vcomiss xmm0, xmm1
    }
    if ( v5 & 1 )
      goto LABEL_6;
    __asm { vucomiss xmm0, xmm1 }
    if ( v5 >> 1 )
      goto LABEL_5;
    if ( _R9[_RCX].index < key->index )
    {
LABEL_6:
      _R9 += _RCX + 1;
      v5 += -1 - _RCX;
    }
    else
    {
LABEL_5:
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)_R9 - (char *)_R15 - 364) >> 3);
  LOWORD(_RBX) = v9;
  if ( v9 == 5 )
    return 0;
  v11 = v9 < 5u;
  v12 = v9 == 5;
  if ( v9 >= 5u )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5);
    v11 = 0;
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm { vmovss  xmm0, dword ptr [r14+4] }
  _RBX = (unsigned __int16)_RBX;
  __asm
  {
    vmovss  xmm1, dword ptr [r15+rbx*8+170h]
    vcomiss xmm0, xmm1
  }
  if ( !v11 )
  {
    __asm { vucomiss xmm0, xmm1 }
    if ( (!v12 || _R14->index >= _R15->m_linkKeys[_RBX].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
      __debugbreak();
  }
  nextPageIndex = _R15->m_linkPageIndices[_RBX];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 6 )
  {
    LODWORD(v52) = 6;
    LODWORD(v51) = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI = NULL;
  if ( nextPageIndex == 6 )
    goto LABEL_76;
  while ( 1 )
  {
    if ( nextPageIndex >= 6u )
    {
      LODWORD(v50) = 6;
      LODWORD(v49) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v49, v50) )
        __debugbreak();
    }
    v18 = nextPageIndex;
    keyCount = _R15->m_pages[v18].meta.keyCount;
    _RSI = &_R15->m_pages[v18];
    if ( keyCount < 7u )
      goto LABEL_31;
    __asm { vmovss  xmm0, dword ptr [r14+4] }
    _RCX = keyCount;
    __asm
    {
      vmovss  xmm1, dword ptr [rsi+rcx*8]
      vcomiss xmm0, xmm1
      vucomiss xmm0, xmm1
    }
    if ( keyCount == 7 && _R14->index < _RSI->keys[6].index )
    {
LABEL_31:
      while ( 1 )
      {
        lock = _RSI->lock;
        if ( (_RSI->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v24 = _RSI->meta.keyCount;
      if ( v24 < 7u )
        goto LABEL_75;
      __asm { vmovss  xmm0, dword ptr [r14+4] }
      _RCX = v24;
      __asm
      {
        vmovss  xmm1, dword ptr [rsi+rcx*8]
        vcomiss xmm0, xmm1
        vucomiss xmm0, xmm1
      }
      if ( v24 == 7 && _R14->index < _RSI->keys[6].index )
        goto LABEL_75;
      v28 = _RSI->lock;
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      v29 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v28 & 0xFFFFFF, v28);
      if ( v28 != v29 )
      {
        LODWORD(v52) = v28;
        LODWORD(v51) = v29;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
          __debugbreak();
      }
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    if ( _RSI->meta.nextPageIndex == 6 )
      break;
LABEL_69:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 6 )
    {
      _RSI = NULL;
      goto LABEL_76;
    }
  }
  while ( 1 )
  {
    v30 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      if ( v30 == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v30 | 0xFF000000, v30) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( _RSI->meta.nextPageIndex != 6 )
  {
    v31 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
      __debugbreak();
    v32 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v31 & 0xFFFFFF, v31);
    if ( v31 != v32 )
    {
      LODWORD(v52) = v31;
      LODWORD(v51) = v32;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
        __debugbreak();
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    goto LABEL_69;
  }
  v33 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(_R15);
  if ( v33 == 6 )
  {
    LODWORD(v52) = 6;
    LODWORD(v51) = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI->meta.nextPageIndex = v33;
  _RSI = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(_R15, _RSI, &outNextPageIndex);
LABEL_75:
  if ( _RSI )
    goto LABEL_79;
LABEL_76:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_79:
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v34 = (__int64)*_R14;
  v54 = (__int64)*_R14;
  while ( 1 )
  {
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    _R8 = _RSI->keys;
    v36 = (8i64 * _RSI->meta.keyCount) >> 3;
    if ( v36 > 0 )
    {
      __asm { vmovss  xmm1, dword ptr [rsp+98h+arg_10+4] }
      do
      {
        _RDX = v36 >> 1;
        __asm
        {
          vmovss  xmm0, dword ptr [r8+rdx*8+4]
          vcomiss xmm0, xmm1
        }
        if ( v36 & 1 )
          goto LABEL_92;
        __asm { vucomiss xmm0, xmm1 }
        if ( v36 >> 1 )
          goto LABEL_91;
        if ( _R8[_RDX].index < (unsigned int)v34 )
        {
LABEL_92:
          _R8 += _RDX + 1;
          v36 += -1 - _RDX;
        }
        else
        {
LABEL_91:
          v36 >>= 1;
        }
      }
      while ( v36 > 0 );
    }
    v40 = truncate_cast<unsigned char,__int64>(((char *)_R8 - (char *)_RSI - 4) >> 3);
    v41 = _RSI->meta.keyCount;
    v55 = v34;
    if ( v40 < v41 )
    {
      do
      {
        v42 = v40;
        v43 = v34;
        ++v40;
        v34 = (__int64)_RSI->keys[v42];
        _RSI->keys[v42] = (CgDistanceCacheMpKey)v43;
        v41 = _RSI->meta.keyCount;
      }
      while ( v40 < v41 );
      v55 = v34;
    }
    if ( v40 < 7u )
      break;
    v54 = v34;
    if ( (_BYTE)v41 == 7 && _RSI->meta.nextPageIndex == 6 )
    {
      if ( _R15->m_nextFreePage == 6 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)_R15 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", _R15) )
        __debugbreak();
      v44 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&_R15->m_nextFreePage, 1u));
      v45 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(_R15, &_R15->m_pages[v44]);
      v45->meta.nextPageIndex = 6;
      v45->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, v45);
      if ( (_DWORD)v44 == 6 )
      {
        LODWORD(v52) = 6;
        LODWORD(v51) = 6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      if ( _RSI->meta.nextPageIndex != 6 )
      {
        LODWORD(v52) = 6;
        LODWORD(v51) = _RSI->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      _RSI->meta.nextPageIndex = v44;
    }
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( _RSI->meta.nextPageIndex == 6 )
    {
      LODWORD(v52) = 6;
      LODWORD(v51) = 6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
        __debugbreak();
    }
    outNextPageIndex = _RSI->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(_R15, outNextPageIndex);
    v47 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(_R15, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
    _RSI = v47;
  }
  _RSI->keys[(unsigned __int8)v41] = (CgDistanceCacheMpKey)v34;
  ++_RSI->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  __int64 v5; 
  unsigned __int16 v9; 
  bool v11; 
  bool v12; 
  bool v13; 
  unsigned __int16 nextPageIndex; 
  __int64 v18; 
  unsigned __int8 keyCount; 
  signed __int32 lock; 
  unsigned __int8 v24; 
  signed __int32 v28; 
  signed __int32 v29; 
  signed __int32 v30; 
  signed __int32 v31; 
  signed __int32 v32; 
  unsigned __int16 v33; 
  __int64 v34; 
  __int64 v36; 
  unsigned __int16 v40; 
  unsigned __int16 v41; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v45; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v47; 
  __int64 v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  unsigned __int16 outNextPageIndex; 
  __int64 v54; 
  __int64 v55; 

  _R9 = this->m_linkKeys;
  _R14 = key;
  _R15 = this;
  v5 = 5i64;
  __asm { vmovss  xmm1, dword ptr [rdx+4] }
  do
  {
    _RCX = v5 >> 1;
    __asm
    {
      vmovss  xmm0, dword ptr [r9+rcx*8+4]
      vcomiss xmm0, xmm1
    }
    if ( v5 & 1 )
      goto LABEL_6;
    __asm { vucomiss xmm0, xmm1 }
    if ( v5 >> 1 )
      goto LABEL_5;
    if ( _R9[_RCX].index < key->index )
    {
LABEL_6:
      _R9 += _RCX + 1;
      v5 += -1 - _RCX;
    }
    else
    {
LABEL_5:
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)_R9 - (char *)_R15 - 664) >> 3);
  LOWORD(_RBX) = v9;
  if ( v9 == 5 )
    return 0;
  v11 = v9 < 5u;
  v12 = v9 == 5;
  if ( v9 >= 5u )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5);
    v11 = 0;
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm { vmovss  xmm0, dword ptr [r14+4] }
  _RBX = (unsigned __int16)_RBX;
  __asm
  {
    vmovss  xmm1, dword ptr [r15+rbx*8+29Ch]
    vcomiss xmm0, xmm1
  }
  if ( !v11 )
  {
    __asm { vucomiss xmm0, xmm1 }
    if ( (!v12 || _R14->index >= _R15->m_linkKeys[_RBX].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
      __debugbreak();
  }
  nextPageIndex = _R15->m_linkPageIndices[_RBX];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 11 )
  {
    LODWORD(v52) = 11;
    LODWORD(v51) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI = NULL;
  if ( nextPageIndex == 11 )
    goto LABEL_76;
  while ( 1 )
  {
    if ( nextPageIndex >= 0xBu )
    {
      LODWORD(v50) = 11;
      LODWORD(v49) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v49, v50) )
        __debugbreak();
    }
    v18 = nextPageIndex;
    keyCount = _R15->m_pages[v18].meta.keyCount;
    _RSI = &_R15->m_pages[v18];
    if ( keyCount < 7u )
      goto LABEL_31;
    __asm { vmovss  xmm0, dword ptr [r14+4] }
    _RCX = keyCount;
    __asm
    {
      vmovss  xmm1, dword ptr [rsi+rcx*8]
      vcomiss xmm0, xmm1
      vucomiss xmm0, xmm1
    }
    if ( keyCount == 7 && _R14->index < _RSI->keys[6].index )
    {
LABEL_31:
      while ( 1 )
      {
        lock = _RSI->lock;
        if ( (_RSI->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v24 = _RSI->meta.keyCount;
      if ( v24 < 7u )
        goto LABEL_75;
      __asm { vmovss  xmm0, dword ptr [r14+4] }
      _RCX = v24;
      __asm
      {
        vmovss  xmm1, dword ptr [rsi+rcx*8]
        vcomiss xmm0, xmm1
        vucomiss xmm0, xmm1
      }
      if ( v24 == 7 && _R14->index < _RSI->keys[6].index )
        goto LABEL_75;
      v28 = _RSI->lock;
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      v29 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v28 & 0xFFFFFF, v28);
      if ( v28 != v29 )
      {
        LODWORD(v52) = v28;
        LODWORD(v51) = v29;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
          __debugbreak();
      }
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    if ( _RSI->meta.nextPageIndex == 11 )
      break;
LABEL_69:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 11 )
    {
      _RSI = NULL;
      goto LABEL_76;
    }
  }
  while ( 1 )
  {
    v30 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      if ( v30 == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v30 | 0xFF000000, v30) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( _RSI->meta.nextPageIndex != 11 )
  {
    v31 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
      __debugbreak();
    v32 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v31 & 0xFFFFFF, v31);
    if ( v31 != v32 )
    {
      LODWORD(v52) = v31;
      LODWORD(v51) = v32;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
        __debugbreak();
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    goto LABEL_69;
  }
  v33 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(_R15);
  if ( v33 == 11 )
  {
    LODWORD(v52) = 11;
    LODWORD(v51) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI->meta.nextPageIndex = v33;
  _RSI = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(_R15, _RSI, &outNextPageIndex);
LABEL_75:
  if ( _RSI )
    goto LABEL_79;
LABEL_76:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_79:
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v34 = (__int64)*_R14;
  v54 = (__int64)*_R14;
  while ( 1 )
  {
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    _R8 = _RSI->keys;
    v36 = (8i64 * _RSI->meta.keyCount) >> 3;
    if ( v36 > 0 )
    {
      __asm { vmovss  xmm1, dword ptr [rsp+98h+arg_10+4] }
      do
      {
        _RDX = v36 >> 1;
        __asm
        {
          vmovss  xmm0, dword ptr [r8+rdx*8+4]
          vcomiss xmm0, xmm1
        }
        if ( v36 & 1 )
          goto LABEL_92;
        __asm { vucomiss xmm0, xmm1 }
        if ( v36 >> 1 )
          goto LABEL_91;
        if ( _R8[_RDX].index < (unsigned int)v34 )
        {
LABEL_92:
          _R8 += _RDX + 1;
          v36 += -1 - _RDX;
        }
        else
        {
LABEL_91:
          v36 >>= 1;
        }
      }
      while ( v36 > 0 );
    }
    v40 = truncate_cast<unsigned char,__int64>(((char *)_R8 - (char *)_RSI - 4) >> 3);
    v41 = _RSI->meta.keyCount;
    v55 = v34;
    if ( v40 < v41 )
    {
      do
      {
        v42 = v40;
        v43 = v34;
        ++v40;
        v34 = (__int64)_RSI->keys[v42];
        _RSI->keys[v42] = (CgDistanceCacheMpKey)v43;
        v41 = _RSI->meta.keyCount;
      }
      while ( v40 < v41 );
      v55 = v34;
    }
    if ( v40 < 7u )
      break;
    v54 = v34;
    if ( (_BYTE)v41 == 7 && _RSI->meta.nextPageIndex == 11 )
    {
      if ( _R15->m_nextFreePage == 11 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)_R15 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", _R15) )
        __debugbreak();
      v44 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&_R15->m_nextFreePage, 1u));
      v45 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(_R15, &_R15->m_pages[v44]);
      v45->meta.nextPageIndex = 11;
      v45->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, v45);
      if ( (_DWORD)v44 == 11 )
      {
        LODWORD(v52) = 11;
        LODWORD(v51) = 11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      if ( _RSI->meta.nextPageIndex != 11 )
      {
        LODWORD(v52) = 11;
        LODWORD(v51) = _RSI->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      _RSI->meta.nextPageIndex = v44;
    }
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( _RSI->meta.nextPageIndex == 11 )
    {
      LODWORD(v52) = 11;
      LODWORD(v51) = 11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
        __debugbreak();
    }
    outNextPageIndex = _RSI->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(_R15, outNextPageIndex);
    v47 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(_R15, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
    _RSI = v47;
  }
  _RSI->keys[(unsigned __int8)v41] = (CgDistanceCacheMpKey)v34;
  ++_RSI->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  __int64 v5; 
  CgDistanceCacheMpKey *v9; 
  unsigned __int16 v10; 
  bool v12; 
  bool v13; 
  bool v14; 
  unsigned __int16 nextPageIndex; 
  __int64 v19; 
  unsigned __int8 keyCount; 
  signed __int32 lock; 
  unsigned __int8 v25; 
  signed __int32 v29; 
  signed __int32 v30; 
  signed __int32 v31; 
  signed __int32 v32; 
  signed __int32 v33; 
  unsigned __int16 v34; 
  __int64 v35; 
  __int64 v37; 
  unsigned __int16 v41; 
  unsigned __int16 v42; 
  __int64 v43; 
  __int64 v44; 
  __int64 v45; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v46; 
  unsigned __int16 v47; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v48; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  __int64 v53; 
  unsigned __int16 outNextPageIndex; 
  __int64 v55; 
  __int64 v56; 

  _R9 = this->m_linkKeys;
  _R14 = key;
  _R15 = this;
  v5 = 5i64;
  __asm { vmovss  xmm1, dword ptr [rdx+4] }
  do
  {
    _RCX = v5 >> 1;
    __asm
    {
      vmovss  xmm0, dword ptr [r9+rcx*8+4]
      vcomiss xmm0, xmm1
    }
    v9 = &_R9[v5 >> 1];
    if ( v5 & 1 )
      goto LABEL_6;
    __asm { vucomiss xmm0, xmm1 }
    if ( v5 >> 1 )
      goto LABEL_5;
    if ( v9->index < _R14->index )
    {
LABEL_6:
      _R9 = v9 + 1;
      v5 += -1 - _RCX;
    }
    else
    {
LABEL_5:
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v10 = truncate_cast<unsigned short,__int64>(((char *)_R9 - (char *)_R15 - 15724) >> 3);
  LOWORD(_RBX) = v10;
  if ( v10 == 5 )
    return 0;
  v12 = v10 < 5u;
  v13 = v10 == 5;
  if ( v10 >= 5u )
  {
    v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v10, 5);
    v12 = 0;
    v13 = !v14;
    if ( v14 )
      __debugbreak();
  }
  __asm { vmovss  xmm0, dword ptr [r14+4] }
  _RBX = (unsigned __int16)_RBX;
  __asm
  {
    vmovss  xmm1, dword ptr [r15+rbx*8+3D70h]
    vcomiss xmm0, xmm1
  }
  if ( !v12 )
  {
    __asm { vucomiss xmm0, xmm1 }
    if ( (!v13 || _R14->index >= _R15->m_linkKeys[_RBX].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
      __debugbreak();
  }
  nextPageIndex = _R15->m_linkPageIndices[_RBX];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 262 )
  {
    LODWORD(v53) = 262;
    LODWORD(v52) = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v52, v53) )
      __debugbreak();
  }
  _RSI = NULL;
  if ( nextPageIndex == 262 )
    goto LABEL_76;
  while ( 1 )
  {
    if ( nextPageIndex >= 0x106u )
    {
      LODWORD(v51) = 262;
      LODWORD(v50) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v50, v51) )
        __debugbreak();
    }
    v19 = nextPageIndex;
    keyCount = _R15->m_pages[v19].meta.keyCount;
    _RSI = &_R15->m_pages[v19];
    if ( keyCount < 7u )
      goto LABEL_31;
    __asm { vmovss  xmm0, dword ptr [r14+4] }
    _RCX = keyCount;
    __asm
    {
      vmovss  xmm1, dword ptr [rsi+rcx*8]
      vcomiss xmm0, xmm1
      vucomiss xmm0, xmm1
    }
    if ( keyCount == 7 && _R14->index < _RSI->keys[6].index )
    {
LABEL_31:
      while ( 1 )
      {
        lock = _RSI->lock;
        if ( (_RSI->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v25 = _RSI->meta.keyCount;
      if ( v25 < 7u )
        goto LABEL_75;
      __asm { vmovss  xmm0, dword ptr [r14+4] }
      _RCX = v25;
      __asm
      {
        vmovss  xmm1, dword ptr [rsi+rcx*8]
        vcomiss xmm0, xmm1
        vucomiss xmm0, xmm1
      }
      if ( v25 == 7 && _R14->index < _RSI->keys[6].index )
        goto LABEL_75;
      v29 = _RSI->lock;
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      v30 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v29 & 0xFFFFFF, v29);
      if ( v29 != v30 )
      {
        LODWORD(v53) = v29;
        LODWORD(v52) = v30;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v52, v53) )
          __debugbreak();
      }
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    if ( _RSI->meta.nextPageIndex == 262 )
      break;
LABEL_69:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 262 )
    {
      _RSI = NULL;
      goto LABEL_76;
    }
  }
  while ( 1 )
  {
    v31 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      if ( v31 == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v31 | 0xFF000000, v31) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( _RSI->meta.nextPageIndex != 262 )
  {
    v32 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
      __debugbreak();
    v33 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v32 & 0xFFFFFF, v32);
    if ( v32 != v33 )
    {
      LODWORD(v53) = v32;
      LODWORD(v52) = v33;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v52, v53) )
        __debugbreak();
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    goto LABEL_69;
  }
  v34 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(_R15);
  if ( v34 == 262 )
  {
    LODWORD(v53) = 262;
    LODWORD(v52) = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v52, v53) )
      __debugbreak();
  }
  _RSI->meta.nextPageIndex = v34;
  _RSI = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(_R15, _RSI, &outNextPageIndex);
LABEL_75:
  if ( _RSI )
    goto LABEL_79;
LABEL_76:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_79:
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v35 = (__int64)*_R14;
  v55 = (__int64)*_R14;
  while ( 1 )
  {
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    _R8 = _RSI->keys;
    v37 = (8i64 * _RSI->meta.keyCount) >> 3;
    if ( v37 > 0 )
    {
      __asm { vmovss  xmm1, dword ptr [rsp+98h+arg_10+4] }
      do
      {
        _RDX = v37 >> 1;
        __asm
        {
          vmovss  xmm0, dword ptr [r8+rdx*8+4]
          vcomiss xmm0, xmm1
        }
        if ( v37 & 1 )
          goto LABEL_92;
        __asm { vucomiss xmm0, xmm1 }
        if ( v37 >> 1 )
          goto LABEL_91;
        if ( _R8[_RDX].index < (unsigned int)v35 )
        {
LABEL_92:
          _R8 += _RDX + 1;
          v37 += -1 - _RDX;
        }
        else
        {
LABEL_91:
          v37 >>= 1;
        }
      }
      while ( v37 > 0 );
    }
    v41 = truncate_cast<unsigned char,__int64>(((char *)_R8 - (char *)_RSI - 4) >> 3);
    v42 = _RSI->meta.keyCount;
    v56 = v35;
    if ( v41 < v42 )
    {
      do
      {
        v43 = v41;
        v44 = v35;
        ++v41;
        v35 = (__int64)_RSI->keys[v43];
        _RSI->keys[v43] = (CgDistanceCacheMpKey)v44;
        v42 = _RSI->meta.keyCount;
      }
      while ( v41 < v42 );
      v56 = v35;
    }
    if ( v41 < 7u )
      break;
    v55 = v35;
    if ( (_BYTE)v42 == 7 && _RSI->meta.nextPageIndex == 262 )
    {
      if ( _R15->m_nextFreePage == 262 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)_R15 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", _R15) )
        __debugbreak();
      v45 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&_R15->m_nextFreePage, 1u));
      v46 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(_R15, &_R15->m_pages[v45]);
      v46->meta.nextPageIndex = 262;
      v46->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, v46);
      if ( (_WORD)v45 == 262 )
      {
        LODWORD(v53) = 262;
        LODWORD(v52) = 262;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v52, v53) )
          __debugbreak();
      }
      if ( _RSI->meta.nextPageIndex != 262 )
      {
        LODWORD(v53) = 262;
        LODWORD(v52) = _RSI->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v52, v53) )
          __debugbreak();
      }
      _RSI->meta.nextPageIndex = v45;
    }
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( _RSI->meta.nextPageIndex == 262 )
    {
      LODWORD(v53) = 262;
      LODWORD(v52) = 262;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v52, v53) )
        __debugbreak();
    }
    v47 = _RSI->meta.nextPageIndex;
    outNextPageIndex = v47;
    if ( v47 >= 0x106u )
    {
      LODWORD(v51) = 262;
      LODWORD(v50) = v47;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v50, v51) )
        __debugbreak();
    }
    v48 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(_R15, &_R15->m_pages[v47]);
    OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
    _RSI = v48;
  }
  _RSI->keys[(unsigned __int8)v42] = (CgDistanceCacheMpKey)v35;
  ++_RSI->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  __int64 v5; 
  unsigned __int16 v9; 
  bool v11; 
  bool v12; 
  bool v13; 
  unsigned __int16 nextPageIndex; 
  __int64 v18; 
  unsigned __int8 keyCount; 
  signed __int32 lock; 
  unsigned __int8 v24; 
  signed __int32 v28; 
  signed __int32 v29; 
  signed __int32 v30; 
  signed __int32 v31; 
  signed __int32 v32; 
  unsigned __int16 v33; 
  __int64 v34; 
  __int64 v36; 
  unsigned __int16 v40; 
  unsigned __int16 v41; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v45; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v47; 
  __int64 v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  unsigned __int16 outNextPageIndex; 
  __int64 v54; 
  __int64 v55; 

  _R9 = this->m_linkKeys;
  _R14 = key;
  _R15 = this;
  v5 = 5i64;
  __asm { vmovss  xmm1, dword ptr [rdx+4] }
  do
  {
    _RCX = v5 >> 1;
    __asm
    {
      vmovss  xmm0, dword ptr [r9+rcx*8+4]
      vcomiss xmm0, xmm1
    }
    if ( v5 & 1 )
      goto LABEL_6;
    __asm { vucomiss xmm0, xmm1 }
    if ( v5 >> 1 )
      goto LABEL_5;
    if ( _R9[_RCX].index < key->index )
    {
LABEL_6:
      _R9 += _RCX + 1;
      v5 += -1 - _RCX;
    }
    else
    {
LABEL_5:
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)_R9 - (char *)_R15 - 1984) >> 3);
  LOWORD(_RBX) = v9;
  if ( v9 == 5 )
    return 0;
  v11 = v9 < 5u;
  v12 = v9 == 5;
  if ( v9 >= 5u )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5);
    v11 = 0;
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm { vmovss  xmm0, dword ptr [r14+4] }
  _RBX = (unsigned __int16)_RBX;
  __asm
  {
    vmovss  xmm1, dword ptr [r15+rbx*8+7C4h]
    vcomiss xmm0, xmm1
  }
  if ( !v11 )
  {
    __asm { vucomiss xmm0, xmm1 }
    if ( (!v12 || _R14->index >= _R15->m_linkKeys[_RBX].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
      __debugbreak();
  }
  nextPageIndex = _R15->m_linkPageIndices[_RBX];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 33 )
  {
    LODWORD(v52) = 33;
    LODWORD(v51) = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI = NULL;
  if ( nextPageIndex == 33 )
    goto LABEL_76;
  while ( 1 )
  {
    if ( nextPageIndex >= 0x21u )
    {
      LODWORD(v50) = 33;
      LODWORD(v49) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v49, v50) )
        __debugbreak();
    }
    v18 = nextPageIndex;
    keyCount = _R15->m_pages[v18].meta.keyCount;
    _RSI = &_R15->m_pages[v18];
    if ( keyCount < 7u )
      goto LABEL_31;
    __asm { vmovss  xmm0, dword ptr [r14+4] }
    _RCX = keyCount;
    __asm
    {
      vmovss  xmm1, dword ptr [rsi+rcx*8]
      vcomiss xmm0, xmm1
      vucomiss xmm0, xmm1
    }
    if ( keyCount == 7 && _R14->index < _RSI->keys[6].index )
    {
LABEL_31:
      while ( 1 )
      {
        lock = _RSI->lock;
        if ( (_RSI->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v24 = _RSI->meta.keyCount;
      if ( v24 < 7u )
        goto LABEL_75;
      __asm { vmovss  xmm0, dword ptr [r14+4] }
      _RCX = v24;
      __asm
      {
        vmovss  xmm1, dword ptr [rsi+rcx*8]
        vcomiss xmm0, xmm1
        vucomiss xmm0, xmm1
      }
      if ( v24 == 7 && _R14->index < _RSI->keys[6].index )
        goto LABEL_75;
      v28 = _RSI->lock;
      if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      v29 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v28 & 0xFFFFFF, v28);
      if ( v28 != v29 )
      {
        LODWORD(v52) = v28;
        LODWORD(v51) = v29;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
          __debugbreak();
      }
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    if ( _RSI->meta.nextPageIndex == 33 )
      break;
LABEL_69:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 33 )
    {
      _RSI = NULL;
      goto LABEL_76;
    }
  }
  while ( 1 )
  {
    v30 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
        __debugbreak();
      if ( v30 == _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v30 | 0xFF000000, v30) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( _RSI->meta.nextPageIndex != 33 )
  {
    v31 = _RSI->lock;
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)_RSI & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", _RSI) )
      __debugbreak();
    v32 = _InterlockedCompareExchange((volatile signed __int32 *)_RSI, v31 & 0xFFFFFF, v31);
    if ( v31 != v32 )
    {
      LODWORD(v52) = v31;
      LODWORD(v51) = v32;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v51, v52) )
        __debugbreak();
    }
    nextPageIndex = _RSI->meta.nextPageIndex;
    goto LABEL_69;
  }
  v33 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(_R15);
  if ( v33 == 33 )
  {
    LODWORD(v52) = 33;
    LODWORD(v51) = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
      __debugbreak();
  }
  _RSI->meta.nextPageIndex = v33;
  _RSI = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(_R15, _RSI, &outNextPageIndex);
LABEL_75:
  if ( _RSI )
    goto LABEL_79;
LABEL_76:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_79:
  if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v34 = (__int64)*_R14;
  v54 = (__int64)*_R14;
  while ( 1 )
  {
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    _R8 = _RSI->keys;
    v36 = (8i64 * _RSI->meta.keyCount) >> 3;
    if ( v36 > 0 )
    {
      __asm { vmovss  xmm1, dword ptr [rsp+98h+arg_10+4] }
      do
      {
        _RDX = v36 >> 1;
        __asm
        {
          vmovss  xmm0, dword ptr [r8+rdx*8+4]
          vcomiss xmm0, xmm1
        }
        if ( v36 & 1 )
          goto LABEL_92;
        __asm { vucomiss xmm0, xmm1 }
        if ( v36 >> 1 )
          goto LABEL_91;
        if ( _R8[_RDX].index < (unsigned int)v34 )
        {
LABEL_92:
          _R8 += _RDX + 1;
          v36 += -1 - _RDX;
        }
        else
        {
LABEL_91:
          v36 >>= 1;
        }
      }
      while ( v36 > 0 );
    }
    v40 = truncate_cast<unsigned char,__int64>(((char *)_R8 - (char *)_RSI - 4) >> 3);
    v41 = _RSI->meta.keyCount;
    v55 = v34;
    if ( v40 < v41 )
    {
      do
      {
        v42 = v40;
        v43 = v34;
        ++v40;
        v34 = (__int64)_RSI->keys[v42];
        _RSI->keys[v42] = (CgDistanceCacheMpKey)v43;
        v41 = _RSI->meta.keyCount;
      }
      while ( v40 < v41 );
      v55 = v34;
    }
    if ( v40 < 7u )
      break;
    v54 = v34;
    if ( (_BYTE)v41 == 7 && _RSI->meta.nextPageIndex == 33 )
    {
      if ( _R15->m_nextFreePage == 33 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)_R15 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", _R15) )
        __debugbreak();
      v44 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&_R15->m_nextFreePage, 1u));
      v45 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(_R15, &_R15->m_pages[v44]);
      v45->meta.nextPageIndex = 33;
      v45->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, v45);
      if ( (_DWORD)v44 == 33 )
      {
        LODWORD(v52) = 33;
        LODWORD(v51) = 33;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      if ( _RSI->meta.nextPageIndex != 33 )
      {
        LODWORD(v52) = 33;
        LODWORD(v51) = _RSI->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
          __debugbreak();
      }
      _RSI->meta.nextPageIndex = v44;
    }
    if ( (_RSI->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( _RSI->meta.nextPageIndex == 33 )
    {
      LODWORD(v52) = 33;
      LODWORD(v51) = 33;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v51, v52) )
        __debugbreak();
    }
    outNextPageIndex = _RSI->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(_R15, outNextPageIndex);
    v47 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(_R15, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
    _RSI = v47;
  }
  _RSI->keys[(unsigned __int8)v41] = (CgDistanceCacheMpKey)v34;
  ++_RSI->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(_R15, _RSI);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 6 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 6;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 11 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 11;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 262 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.keyCount = 0;
  v3->meta.nextPageIndex = 262;
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 33 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 33;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 0xBu )
  {
    v6 = 11;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  __int64 v6; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  _RDI = inOutKey;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  _R9 = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    __asm { vmovss  xmm1, dword ptr [rdi+4] }
    do
    {
      _RDX = v6 >> 1;
      __asm
      {
        vmovss  xmm0, dword ptr [r9+rdx*8+4]
        vcomiss xmm0, xmm1
      }
      if ( v6 & 1 )
        goto LABEL_10;
      __asm { vucomiss xmm0, xmm1 }
      if ( v6 >> 1 )
        goto LABEL_9;
      if ( _R9[_RDX].index < _RDI->index )
      {
LABEL_10:
        _R9 += _RDX + 1;
        v6 += -1 - _RDX;
      }
      else
      {
LABEL_9:
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)_R9 - (char *)page - 4) >> 3);
  v11 = *_RDI;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *_RDI = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  __int64 v6; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  _RDI = inOutKey;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  _R9 = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    __asm { vmovss  xmm1, dword ptr [rdi+4] }
    do
    {
      _RDX = v6 >> 1;
      __asm
      {
        vmovss  xmm0, dword ptr [r9+rdx*8+4]
        vcomiss xmm0, xmm1
      }
      if ( v6 & 1 )
        goto LABEL_10;
      __asm { vucomiss xmm0, xmm1 }
      if ( v6 >> 1 )
        goto LABEL_9;
      if ( _R9[_RDX].index < _RDI->index )
      {
LABEL_10:
        _R9 += _RDX + 1;
        v6 += -1 - _RDX;
      }
      else
      {
LABEL_9:
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)_R9 - (char *)page - 4) >> 3);
  v11 = *_RDI;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *_RDI = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  __int64 v6; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  _RDI = inOutKey;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  _R9 = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    __asm { vmovss  xmm1, dword ptr [rdi+4] }
    do
    {
      _RDX = v6 >> 1;
      __asm
      {
        vmovss  xmm0, dword ptr [r9+rdx*8+4]
        vcomiss xmm0, xmm1
      }
      if ( v6 & 1 )
        goto LABEL_10;
      __asm { vucomiss xmm0, xmm1 }
      if ( v6 >> 1 )
        goto LABEL_9;
      if ( _R9[_RDX].index < _RDI->index )
      {
LABEL_10:
        _R9 += _RDX + 1;
        v6 += -1 - _RDX;
      }
      else
      {
LABEL_9:
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)_R9 - (char *)page - 4) >> 3);
  v11 = *_RDI;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *_RDI = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  __int64 v6; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  _RDI = inOutKey;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  _R9 = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    __asm { vmovss  xmm1, dword ptr [rdi+4] }
    do
    {
      _RDX = v6 >> 1;
      __asm
      {
        vmovss  xmm0, dword ptr [r9+rdx*8+4]
        vcomiss xmm0, xmm1
      }
      if ( v6 & 1 )
        goto LABEL_10;
      __asm { vucomiss xmm0, xmm1 }
      if ( v6 >> 1 )
        goto LABEL_9;
      if ( _R9[_RDX].index < _RDI->index )
      {
LABEL_10:
        _R9 += _RDX + 1;
        v6 += -1 - _RDX;
      }
      else
      {
LABEL_9:
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)_R9 - (char *)page - 4) >> 3);
  v11 = *_RDI;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *_RDI = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 6 )
  {
    v11 = 6;
    v10 = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 11 )
  {
    v11 = 11;
    v10 = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v7; 
  __int64 v9; 
  __int64 v10; 
  int v11; 
  int v12; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 262 )
  {
    v12 = 262;
    v11 = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v11, v12) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  if ( nextPageIndex >= 0x106u )
  {
    LODWORD(v10) = 262;
    LODWORD(v9) = nextPageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[nextPageIndex]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v7;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 33 )
  {
    v11 = 33;
    v10 = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  bool v10; 
  bool v11; 
  signed __int32 v17; 
  signed __int32 v18; 
  char *fmt; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 

  _RBP = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 6u;
    if ( nextPageIndex != 6 )
      break;
LABEL_34:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v22) = 6;
      LODWORD(v21) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_24:
    v17 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v18 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v17 & 0xFFFFFF, v17);
    if ( v17 != v18 )
    {
      LODWORD(v24) = v17;
      LODWORD(v23) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v23, v24) )
        __debugbreak();
    }
    v5 = nextPageIndex < 6u;
    if ( nextPageIndex == 6 )
      goto LABEL_34;
  }
  v9 = 0;
  v10 = 0;
  v11 = keyCount == 0;
  _R10 = &this->m_linkKeys[v3];
  __asm { vmovss  xmm2, dword ptr [r10+4] }
  while ( 1 )
  {
    _RDX = &v6->keys[v9];
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+4]
      vcomiss xmm0, xmm2
    }
    if ( !v10 )
    {
      __asm { vucomiss xmm0, xmm2 }
      if ( !v11 || _RDX->index >= _R10->index )
        break;
    }
    if ( _RBP )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+4]
        vcomiss xmm1, xmm0
        vucomiss xmm1, xmm0
      }
      LODWORD(v21) = v9;
      LODWORD(fmt) = nextPageIndex;
      Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", _RBP, v3, fmt, v21, &v6->keys[v9]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    ++v9;
    _RBP = _RDX;
    v10 = v9 < keyCount;
    v11 = v9 == keyCount;
    if ( v9 >= keyCount )
      goto LABEL_24;
  }
  Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  bool v10; 
  bool v11; 
  signed __int32 v17; 
  signed __int32 v18; 
  char *fmt; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 

  _RBP = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0xBu;
    if ( nextPageIndex != 11 )
      break;
LABEL_34:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v22) = 11;
      LODWORD(v21) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_24:
    v17 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v18 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v17 & 0xFFFFFF, v17);
    if ( v17 != v18 )
    {
      LODWORD(v24) = v17;
      LODWORD(v23) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v23, v24) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0xBu;
    if ( nextPageIndex == 11 )
      goto LABEL_34;
  }
  v9 = 0;
  v10 = 0;
  v11 = keyCount == 0;
  _R10 = &this->m_linkKeys[v3];
  __asm { vmovss  xmm2, dword ptr [r10+4] }
  while ( 1 )
  {
    _RDX = &v6->keys[v9];
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+4]
      vcomiss xmm0, xmm2
    }
    if ( !v10 )
    {
      __asm { vucomiss xmm0, xmm2 }
      if ( !v11 || _RDX->index >= _R10->index )
        break;
    }
    if ( _RBP )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+4]
        vcomiss xmm1, xmm0
        vucomiss xmm1, xmm0
      }
      LODWORD(v21) = v9;
      LODWORD(fmt) = nextPageIndex;
      Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", _RBP, v3, fmt, v21, &v6->keys[v9]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    ++v9;
    _RBP = _RDX;
    v10 = v9 < keyCount;
    v11 = v9 == keyCount;
    if ( v9 >= keyCount )
      goto LABEL_24;
  }
  Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  bool v10; 
  bool v11; 
  signed __int32 v17; 
  signed __int32 v18; 
  char *fmt; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 

  _RBP = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0x106u;
    if ( nextPageIndex != 262 )
      break;
LABEL_34:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v22) = 262;
      LODWORD(v21) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_24:
    v17 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v18 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v17 & 0xFFFFFF, v17);
    if ( v17 != v18 )
    {
      LODWORD(v24) = v17;
      LODWORD(v23) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v23, v24) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0x106u;
    if ( nextPageIndex == 262 )
      goto LABEL_34;
  }
  v9 = 0;
  v10 = 0;
  v11 = keyCount == 0;
  _R10 = &this->m_linkKeys[v3];
  __asm { vmovss  xmm2, dword ptr [r10+4] }
  while ( 1 )
  {
    _RDX = &v6->keys[v9];
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+4]
      vcomiss xmm0, xmm2
    }
    if ( !v10 )
    {
      __asm { vucomiss xmm0, xmm2 }
      if ( !v11 || _RDX->index >= _R10->index )
        break;
    }
    if ( _RBP )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+4]
        vcomiss xmm1, xmm0
        vucomiss xmm1, xmm0
      }
      LODWORD(v21) = v9;
      LODWORD(fmt) = nextPageIndex;
      Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", _RBP, v3, fmt, v21, &v6->keys[v9]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    ++v9;
    _RBP = _RDX;
    v10 = v9 < keyCount;
    v11 = v9 == keyCount;
    if ( v9 >= keyCount )
      goto LABEL_24;
  }
  Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  bool v10; 
  bool v11; 
  signed __int32 v17; 
  signed __int32 v18; 
  char *fmt; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 

  _RBP = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0x21u;
    if ( nextPageIndex != 33 )
      break;
LABEL_34:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v22) = 33;
      LODWORD(v21) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_24:
    v17 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v18 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v17 & 0xFFFFFF, v17);
    if ( v17 != v18 )
    {
      LODWORD(v24) = v17;
      LODWORD(v23) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v23, v24) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0x21u;
    if ( nextPageIndex == 33 )
      goto LABEL_34;
  }
  v9 = 0;
  v10 = 0;
  v11 = keyCount == 0;
  _R10 = &this->m_linkKeys[v3];
  __asm { vmovss  xmm2, dword ptr [r10+4] }
  while ( 1 )
  {
    _RDX = &v6->keys[v9];
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+4]
      vcomiss xmm0, xmm2
    }
    if ( !v10 )
    {
      __asm { vucomiss xmm0, xmm2 }
      if ( !v11 || _RDX->index >= _R10->index )
        break;
    }
    if ( _RBP )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+4]
        vcomiss xmm1, xmm0
        vucomiss xmm1, xmm0
      }
      LODWORD(v21) = v9;
      LODWORD(fmt) = nextPageIndex;
      Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", _RBP, v3, fmt, v21, &v6->keys[v9]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    ++v9;
    _RBP = _RDX;
    v10 = v9 < keyCount;
    v11 = v9 == keyCount;
    if ( v9 >= keyCount )
      goto LABEL_24;
  }
  Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

