/*
==============
RBT_DOF_DownsampleTile_Vertical
==============
*/

void __fastcall RBT_DOF_DownsampleTile_Vertical(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_DownsampleTile_Vertical@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DOF_CreateTemporal<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_CreateTemporal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DOF_CreateTemporal@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_DOF_CircularFilter
==============
*/

void __fastcall RBT_DOF_CircularFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_CircularFilter@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DOF_TileNeighor
==============
*/

void __fastcall RBT_DOF_TileNeighor(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_TileNeighor@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DOF_Prepass
==============
*/

void __fastcall RBT_DOF_Prepass(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_Prepass@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DOF_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  return ??$cRBT_DOF_Upsample@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DOF_DownsampleTile_Vertical@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_DOF_CircularFilterFullres
==============
*/

void __fastcall RBT_DOF_CircularFilterFullres(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_CircularFilterFullres@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DOF_DownsampleTile_Horizontal
==============
*/

void __fastcall RBT_DOF_DownsampleTile_Horizontal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_DownsampleTile_Horizontal@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
R_TGS_DOF_Fullres_Apply
==============
*/

void __fastcall R_TGS_DOF_Fullres_Apply(R_TG_Script *pScript, R_TG_Handle *sceneColor, R_TG_Handle floatZ, R_TG_Handle scope, R_TG_Handle *dofTile0Handle)
{
  ?R_TGS_DOF_Fullres_Apply@@YAXPEAUR_TG_Script@@AEAUR_TG_Handle@@U2@21@Z(pScript, sceneColor, floatZ, scope, dofTile0Handle);
}

/*
==============
cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DOF_DownsampleTile_Horizontal@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_DOF_CircularFilterFullres<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_CircularFilterFullres<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_DOF_CircularFilterFullres@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_DOF_Sharpen<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_Sharpen<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DOF_Sharpen@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_DOF_Median<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_Median<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_DOF_Median@UR_TG_Handle@@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
R_TGS_DOF_Apply
==============
*/

void __fastcall R_TGS_DOF_Apply(R_TG_Script *pScript, R_TG_Handle *sceneColor, R_TG_Handle floatZ, R_TG_Handle velocity, R_TG_Handle scope, R_TG_Handle *dofTile0Handle)
{
  ?R_TGS_DOF_Apply@@YAXPEAUR_TG_Script@@AEAUR_TG_Handle@@U2@221@Z(pScript, sceneColor, floatZ, velocity, scope, dofTile0Handle);
}

/*
==============
RBT_DOF_Median
==============
*/

void __fastcall RBT_DOF_Median(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_Median@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DOF_Downsample
==============
*/

void __fastcall RBT_DOF_Downsample(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_Downsample@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DOF_Downsample<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_Downsample<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DOF_Downsample@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_DOF_Upsample
==============
*/

void __fastcall RBT_DOF_Upsample(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_Upsample@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DOF_CircularFilter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_CircularFilter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_DOF_CircularFilter@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_DOF_Prepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_Prepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  return ??$cRBT_DOF_Prepass@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
RBT_DOF_Sharpen
==============
*/

void __fastcall RBT_DOF_Sharpen(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DOF_Sharpen@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DOF_TileNeighor@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_DOF_CircularFilter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_CircularFilter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_CircularFilter.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_CircularFilterFullres<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_CircularFilterFullres<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_CircularFilterFullres.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_CreateTemporal<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_CreateTemporal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_CreateTemporal.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_Downsample<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_Downsample<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_Downsample.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_DownsampleTile_Horizontal.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_DownsampleTile_Vertical.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_Median<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_Median<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_Median.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &<args_2>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_3>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_Prepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_Prepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DOF_Prepass.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_DOF_Sharpen<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_Sharpen<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_Sharpen.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_TileNeighor.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DOF_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DOF_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DOF_Upsample.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
RBT_DOF_CircularFilter
==============
*/
void RBT_DOF_CircularFilter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v27; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int width; 
  R_RT_Handle v37; 
  R_RT_Handle v38; 
  R_RT_ColorHandle v39; 
  R_RT_ColorHandle v40; 
  R_RT_ColorHandle v41; 

  _RAX = taskInfo->attachments;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_30], ymm1
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_30], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_30], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_50], ymm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_50], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_50], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_70], ymm1
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_70], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
        vmovups [rbp+57h+var_70], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v38);
    if ( (R_RT_Handle::GetSurface(&v38)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID]
        vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_90.m_surfaceID]
        vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID] }
      if ( v27 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rbp+57h+var_90.m_surfaceID], ymm0 }
  height = R_RT_Handle::GetSurface(&v38)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v38);
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  width = Surface->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rbp+57h+var_90.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v38, viewInfo, width, height);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+57h+var_B0.m_surfaceID]
    vmovups ymm1, [rbp+57h+var_70]
    vmovups ymmword ptr [rbp+57h+var_B0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+57h+var_50]
    vmovups [rbp+57h+var_50], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+57h+var_70], ymm1
    vmovups ymm1, [rbp+57h+var_30]
    vmovups xmmword ptr [rbp+57h+var_90.m_surfaceID], xmm0
    vmovups [rbp+57h+var_30], ymm1
  }
  R_DOF_CircularFilter((GfxCmdBufContext *)&v38, viewInfo, &v41, &v40, &v39, (R_RT_ColorHandle *)&v37);
}

/*
==============
RBT_DOF_CircularFilterFullres
==============
*/
void RBT_DOF_CircularFilterFullres(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v22; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int width; 
  R_RT_Handle v46; 
  R_RT_Handle v47; 
  R_RT_Handle v48; 
  R_RT_ColorHandle v49; 
  R_RT_ColorHandle v50; 
  R_RT_ColorHandle v51; 

  _RAX = taskInfo->attachments;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+30h+var_50], ymm0
    vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID]
        vmovups [rbp+30h+var_50], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID]
        vmovups [rbp+30h+var_50], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+30h+var_70], ymm1
    vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID]
        vmovups [rbp+30h+var_70], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID]
        vmovups [rbp+30h+var_70], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+130h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v46);
    if ( (R_RT_Handle::GetSurface(&v46)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v22 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID] }
      if ( v22 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+30h+var_B0.m_surfaceID], ymm0
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+30h+var_30], ymm1
    vmovups ymmword ptr [rsp+130h+var_F0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v46);
    if ( (R_RT_Handle::GetSurface(&v46)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups [rbp+30h+var_30], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups [rbp+30h+var_30], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+30h+var_90], ymm0
    vmovups ymmword ptr [rsp+130h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v46);
    if ( (R_RT_Handle::GetSurface(&v46)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups [rbp+30h+var_90], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+130h+var_F0.m_surfaceID]
        vmovups [rbp+30h+var_90], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+130h+var_F0.m_surfaceID], xmm0
  }
  R_DOF_UpdateEquationParams((GfxCmdBufContext *)&v46, viewInfo);
  height = R_RT_Handle::GetSurface(&v48)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v48);
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  width = Surface->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rsp+130h+var_F0.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v46, viewInfo, width, height);
  __asm
  {
    vmovups ymm0, [rbp+30h+var_90]
    vmovups ymm1, [rbp+30h+var_30]
    vmovups ymmword ptr [rbp+30h+var_B0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rsp+130h+var_D0.m_surfaceID]
    vmovups ymmword ptr [rsp+130h+var_D0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+30h+var_50]
    vmovups [rbp+30h+var_50], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+30h+var_90], ymm1
    vmovups ymm1, [rbp+30h+var_70]
    vmovups xmmword ptr [rsp+130h+var_F0.m_surfaceID], xmm0
    vmovups [rbp+30h+var_70], ymm1
  }
  R_DOF_CircularFilterFullres((GfxCmdBufContext *)&v46, viewInfo, &v51, &v50, (R_RT_ColorHandle *)&v47, &v49, (R_RT_ColorHandle *)&v48);
  __asm
  {
    vmovups ymm0, [rbp+30h+var_30]
    vmovups ymmword ptr [rbp+30h+var_B0.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+130h+var_F0.m_surfaceID], xmm0
  }
  RB_DOF_UpdateDistanceMeter((GfxCmdBufContext *)&v46, viewInfo, (R_RT_ColorHandle *)&v48);
}

/*
==============
RBT_DOF_Downsample
==============
*/
void RBT_DOF_Downsample(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v14; 
  R_RT_Handle v15; 
  R_RT_ColorHandle v16; 
  R_RT_ColorHandle v17; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v15);
    if ( (R_RT_Handle::GetSurface(&v15)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+0C8h+var_78] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rsp+0C8h+var_58], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v15);
    if ( (R_RT_Handle::GetSurface(&v15)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0C8h+var_78] }
      if ( v14 )
        __debugbreak();
    }
  }
  __asm { vmovups [rsp+0C8h+var_78], ymm0 }
  R_DOF_Downsample(computeState, viewInfo, &v16, &v17);
}

/*
==============
RBT_DOF_DownsampleTile_Horizontal
==============
*/
void RBT_DOF_DownsampleTile_Horizontal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  unsigned int width; 
  const R_RT_Surface *v14; 
  R_RT_Handle v17; 
  R_RT_Handle v19; 
  vec2_t scale; 
  vec2_t bias; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v17);
    if ( (R_RT_Handle::GetSurface(&v17)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+0C8h+var_78] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+0C8h+var_58.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(taskInfo->rtGroup.m_colorRts);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  width = Surface->m_image.m_base.width;
  R_DOF_UpdateEquationParams((GfxCmdBufContext *)&v17, viewInfo);
  v14 = R_RT_Handle::GetSurface(&v19);
  R_DOF_TileDownsample_GetParams(v14->m_image.m_base.width, 0, width, 0, &bias, &scale);
  __asm
  {
    vmovups ymm0, [rsp+0C8h+var_78]
    vmovups ymmword ptr [rsp+0C8h+var_58.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  R_DOF_TileDownsample_Horizontal((GfxCmdBufContext *)&v17, (R_RT_ColorHandle *)&v19, &bias, &scale);
}

/*
==============
RBT_DOF_DownsampleTile_Vertical
==============
*/
void RBT_DOF_DownsampleTile_Vertical(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  unsigned int height; 
  const R_RT_Surface *v14; 
  R_RT_Handle v17; 
  R_RT_Handle v19; 
  vec2_t scale; 
  vec2_t bias; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v17);
    if ( (R_RT_Handle::GetSurface(&v17)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+0C8h+var_78] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+0C8h+var_58.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(taskInfo->rtGroup.m_colorRts);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  height = Surface->m_image.m_base.height;
  R_DOF_UpdateEquationParams((GfxCmdBufContext *)&v17, viewInfo);
  v14 = R_RT_Handle::GetSurface(&v19);
  R_DOF_TileDownsample_GetParams(0, v14->m_image.m_base.height, 0, height, &bias, &scale);
  __asm
  {
    vmovups ymm0, [rsp+0C8h+var_78]
    vmovups ymmword ptr [rsp+0C8h+var_58.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  R_DOF_TileDownsample_Vertical((GfxCmdBufContext *)&v17, (R_RT_ColorHandle *)&v19, &bias, &scale);
}

/*
==============
RBT_DOF_Median
==============
*/
void RBT_DOF_Median(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v16; 
  R_RT_Handle v19; 
  R_RT_ColorHandle v20; 
  R_RT_ColorHandle v21; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rsp+98h+var_48], ymm1
    vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v19);
    if ( (R_RT_Handle::GetSurface(&v19)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
        vmovups [rsp+98h+var_48], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID]
        vmovups [rsp+98h+var_48], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+98h+var_28], ymm0
    vmovups ymmword ptr [rsp+98h+var_68.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v19);
    if ( (R_RT_Handle::GetSurface(&v19)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+98h+var_68.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+98h+var_28] }
      if ( v16 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+98h+var_48]
    vmovups [rsp+98h+var_48], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+98h+var_68.m_surfaceID], xmm0
    vmovups [rsp+98h+var_28], ymm1
  }
  R_DOF_Median((GfxCmdBufContext *)&v19, &v20, &v21);
}

/*
==============
RBT_DOF_Prepass
==============
*/
void RBT_DOF_Prepass(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v32; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int width; 
  R_RT_Handle v52; 
  R_RT_Handle v53; 
  R_RT_Handle v54; 
  R_RT_ColorHandle v55; 
  R_RT_ColorHandle v56; 
  R_RT_ColorHandle v57; 
  R_RT_ColorHandle v58; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_70], ymm0
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v52);
    if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_70], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_70], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_50], ymm1
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v52);
    if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_50], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_50], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_30], ymm0
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v52);
    if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_30], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_30], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_90], ymm1
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v52);
    if ( (R_RT_Handle::GetSurface(&v52)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_90], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID]
        vmovups [rbp+50h+var_90], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+150h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_F0.m_surfaceID]
        vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_F0.m_surfaceID]
        vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_110.m_surfaceID] }
      if ( v32 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_B0], ymm0
    vmovups ymmword ptr [rsp+150h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v53);
    if ( (R_RT_Handle::GetSurface(&v53)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_F0.m_surfaceID]
        vmovups [rbp+50h+var_B0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_F0.m_surfaceID]
        vmovups [rbp+50h+var_B0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+150h+var_F0.m_surfaceID], xmm0
  }
  R_DOF_UpdateEquationParams((GfxCmdBufContext *)&v53, viewInfo);
  height = R_RT_Handle::GetSurface(&v54)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v54);
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  width = Surface->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rsp+150h+var_F0.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v53, viewInfo, width, height);
  __asm
  {
    vmovups ymm0, [rbp+50h+var_B0]
    vmovups ymm1, ymmword ptr [rsp+150h+var_110.m_surfaceID]
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+50h+var_90]
    vmovups [rbp+50h+var_90], ymm0
    vmovups ymm0, [rbp+50h+var_50]
    vmovups [rbp+50h+var_50], ymm0
    vmovups ymm0, [rbp+50h+var_30]
    vmovups ymmword ptr [rsp+150h+var_110.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rbp+50h+var_B0], ymm1
    vmovups ymm1, [rbp+50h+var_70]
    vmovups xmmword ptr [rsp+150h+var_F0.m_surfaceID], xmm0
    vmovups [rbp+50h+var_70], ymm1
  }
  R_DOF_Prepass((GfxCmdBufContext *)&v53, (R_RT_ColorHandle *)&v52, &v58, &v57, &v56, &v55, (R_RT_ColorHandle *)&v54);
  __asm
  {
    vmovups ymm0, [rbp+50h+var_30]
    vmovups ymmword ptr [rbp+50h+var_D0.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+150h+var_F0.m_surfaceID], xmm0
  }
  RB_DOF_UpdateDistanceMeter((GfxCmdBufContext *)&v53, viewInfo, (R_RT_ColorHandle *)&v54);
}

/*
==============
RBT_DOF_Sharpen
==============
*/
void RBT_DOF_Sharpen(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v10; 
  const R_RT_Surface *Surface; 
  unsigned int v13; 
  R_RT_Handle v16; 
  R_RT_ColorHandle v17; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v16);
    if ( (R_RT_Handle::GetSurface(&v16)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID]
        vmovups [rsp+78h+var_28], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID]
        vmovups [rsp+78h+var_28], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0 }
  v10 = 2 * R_RT_Handle::GetSurface(&v16)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v16);
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  v13 = 2 * Surface->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v16, viewInfo, v13, v10);
  __asm
  {
    vmovups ymm0, [rsp+78h+var_28]
    vmovups [rsp+78h+var_28], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_DOF_Sharpen((GfxCmdBufContext *)&v16, &v17);
}

/*
==============
RBT_DOF_TileNeighor
==============
*/
void RBT_DOF_TileNeighor(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int height; 
  unsigned int width; 
  R_RT_Handle v17; 
  R_RT_ColorHandle v18; 

  _RAX = taskInfo->attachments;
  _RDI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v17);
    if ( (R_RT_Handle::GetSurface(&v17)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID]
        vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID]
        vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  height = viewInfo->sceneViewport.height;
  width = viewInfo->sceneViewport.width;
  __asm { vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v17, viewInfo, width, height);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID]
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_DOF_TileNeighor((GfxCmdBufContext *)&v17, &v18);
}

/*
==============
RBT_DOF_Upsample
==============
*/
void RBT_DOF_Upsample(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v42; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int width; 
  R_RT_Handle v56; 
  R_RT_Handle v57; 
  R_RT_ColorHandle v58; 
  R_RT_ColorHandle v59; 
  R_RT_ColorHandle v60; 
  R_RT_ColorHandle v61; 
  R_RT_ColorHandle v62; 
  R_RT_ColorHandle v63; 
  R_RT_Handle v64; 

  _RAX = taskInfo->attachments;
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+80h+var_F0], ymm0
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_F0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_F0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+80h+var_50], ymm1
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_50], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_50], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+80h+var_70], ymm0
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_70], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_70], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+80h+var_90], ymm1
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_90], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_90], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+80h+var_B0], ymm0
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_B0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_B0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm1
    vmovups [rbp+80h+var_D0], ymm1
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v56);
    if ( (R_RT_Handle::GetSurface(&v56)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_D0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
        vmovups [rbp+80h+var_D0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+180h+var_110.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v57);
    if ( (R_RT_Handle::GetSurface(&v57)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_110.m_surfaceID]
        vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+180h+var_110.m_surfaceID]
        vmovups ymmword ptr [rsp+180h+var_130.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v42 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID] }
      if ( v42 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymmword ptr [rbp+80h+var_30.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+180h+var_110.m_surfaceID], xmm0
  }
  R_DOF_UpdateEquationParams((GfxCmdBufContext *)&v57, viewInfo);
  height = R_RT_Handle::GetSurface(&v64)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v64);
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  width = Surface->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rsp+180h+var_110.m_surfaceID], xmm0 }
  R_DOF_UpdateBufferParams((GfxCmdBufContext *)&v57, viewInfo, width, height);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+180h+var_130.m_surfaceID]
    vmovups ymm1, [rbp+80h+var_F0]
    vmovups ymmword ptr [rbp+80h+var_30.m_surfaceID], ymm0
    vmovups ymm0, [rbp+80h+var_D0]
    vmovups [rbp+80h+var_D0], ymm0
    vmovups ymm0, [rbp+80h+var_90]
    vmovups [rbp+80h+var_90], ymm0
    vmovups ymm0, [rbp+80h+var_50]
    vmovups [rbp+80h+var_F0], ymm1
    vmovups ymm1, [rbp+80h+var_B0]
    vmovups [rbp+80h+var_50], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+80h+var_B0], ymm1
    vmovups ymm1, [rbp+80h+var_70]
    vmovups xmmword ptr [rsp+180h+var_110.m_surfaceID], xmm0
    vmovups [rbp+80h+var_70], ymm1
  }
  R_DOF_Upsample((GfxCmdBufContext *)&v57, viewInfo, &v63, &v62, &v61, &v60, &v59, &v58, (R_RT_ColorHandle *)&v64);
}

/*
==============
R_TGS_DOF_Apply
==============
*/
void R_TGS_DOF_Apply(R_TG_Script *pScript, R_TG_Handle *sceneColor, R_TG_Handle floatZ, R_TG_Handle velocity, R_TG_Handle scope, R_TG_Handle *dofTile0Handle)
{
  R_TG_Handle *v6; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  unsigned int v26; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  unsigned int v30; 
  __int64 v31; 
  unsigned int v32; 
  __int64 v33; 
  __int64 v34; 
  __int64 v35; 
  __int64 v36; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  __int64 v40; 
  int v41; 
  R_TG_Handle v42; 
  R_TG_Handle v43; 
  int v44; 
  int v45; 
  R_TG_AddTaskStack stack; 
  R_TG_Handle v47; 
  unsigned int index; 

  index = velocity.index;
  v47.index = floatZ.index;
  v6 = dofTile0Handle;
  cConditionBegin(pScript, R_DOF_GetEnabled);
  v42.index = -1;
  v43.index = -1;
  cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(pScript, &v43, sceneColor, &v47);
  cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>(pScript, v6, sceneColor, &v43);
  cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>(pScript, &v42, v6);
  v40 = -1i64;
  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_CreateTemporal.m_index;
  stack.handleArgs[0] = (unsigned int *)&v40;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit", v40) )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = (unsigned int *)&v40 + 1;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &sceneColor->index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, m_index, &stack);
  v41 = -1;
  memset_0(&stack, 0, sizeof(stack));
  v12 = g_R_TG_Def_RBT_DOF_Prepass.m_index;
  stack.handleArgs[0] = (unsigned int *)&v41;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = (unsigned int *)&v40 + 1;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( (unsigned int)v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = (unsigned int *)&v40 + 1;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( (unsigned int)v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = (unsigned int *)&v40;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( (unsigned int)v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = (unsigned int *)&v47;
  v17 = stack.handleArgCount + 1;
  stack.handleArgCount = v17;
  if ( (unsigned int)v17 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v17 = stack.handleArgCount;
  }
  stack.handleArgs[v17] = (unsigned int *)&v42;
  v18 = stack.handleArgCount + 1;
  stack.handleArgCount = v18;
  if ( (unsigned int)v18 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v18 = stack.handleArgCount;
  }
  stack.handleArgs[v18] = &sceneColor->index;
  v19 = stack.handleArgCount + 1;
  stack.handleArgCount = v19;
  if ( (unsigned int)v19 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v19 = stack.handleArgCount;
  }
  stack.handleArgs[v19] = &index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v12, &stack);
  v44 = -1;
  memset_0(&stack, 0, sizeof(stack));
  v20 = g_R_TG_Def_RBT_DOF_CircularFilter.m_index;
  stack.handleArgs[0] = (unsigned int *)&v40;
  v21 = stack.handleArgCount + 1;
  stack.handleArgCount = v21;
  if ( (unsigned int)v21 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v21 = stack.handleArgCount;
  }
  stack.handleArgs[v21] = (unsigned int *)&v44;
  v22 = stack.handleArgCount + 1;
  stack.handleArgCount = v22;
  if ( (unsigned int)v22 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v22 = stack.handleArgCount;
  }
  stack.handleArgs[v22] = (unsigned int *)&v40 + 1;
  v23 = stack.handleArgCount + 1;
  stack.handleArgCount = v23;
  if ( (unsigned int)v23 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v23 = stack.handleArgCount;
  }
  stack.handleArgs[v23] = (unsigned int *)&v41;
  v24 = stack.handleArgCount + 1;
  stack.handleArgCount = v24;
  if ( (unsigned int)v24 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v24 = stack.handleArgCount;
  }
  stack.handleArgs[v24] = (unsigned int *)&v42;
  v25 = stack.handleArgCount + 1;
  stack.handleArgCount = v25;
  if ( (unsigned int)v25 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v25 = stack.handleArgCount;
  }
  stack.handleArgs[v25] = &sceneColor->index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v20, &stack);
  v45 = -1;
  memset_0(&stack, 0, sizeof(stack));
  v26 = g_R_TG_Def_RBT_DOF_Median.m_index;
  stack.handleArgs[0] = (unsigned int *)&v41;
  v27 = stack.handleArgCount + 1;
  stack.handleArgCount = v27;
  if ( (unsigned int)v27 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v27 = stack.handleArgCount;
  }
  stack.handleArgs[v27] = (unsigned int *)&v45;
  v28 = stack.handleArgCount + 1;
  stack.handleArgCount = v28;
  if ( (unsigned int)v28 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v28 = stack.handleArgCount;
  }
  stack.handleArgs[v28] = (unsigned int *)&v40;
  v29 = stack.handleArgCount + 1;
  stack.handleArgCount = v29;
  if ( (unsigned int)v29 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v29 = stack.handleArgCount;
  }
  stack.handleArgs[v29] = (unsigned int *)&v44;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v26, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v30 = g_R_TG_Def_RBT_DOF_Sharpen.m_index;
  stack.handleArgs[0] = (unsigned int *)&v40;
  v31 = stack.handleArgCount + 1;
  stack.handleArgCount = v31;
  if ( (unsigned int)v31 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v31 = stack.handleArgCount;
  }
  stack.handleArgs[v31] = (unsigned int *)&v41;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v30, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v32 = g_R_TG_Def_RBT_DOF_Upsample.m_index;
  v33 = stack.handleArgCount + 1;
  stack.handleArgs[0] = &sceneColor->index;
  stack.handleArgCount = v33;
  if ( (unsigned int)v33 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v33 = stack.handleArgCount;
  }
  stack.handleArgs[v33] = (unsigned int *)&v47;
  v34 = stack.handleArgCount + 1;
  stack.handleArgCount = v34;
  if ( (unsigned int)v34 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v34 = stack.handleArgCount;
  }
  stack.handleArgs[v34] = (unsigned int *)&v42;
  v35 = stack.handleArgCount + 1;
  stack.handleArgCount = v35;
  if ( (unsigned int)v35 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v35 = stack.handleArgCount;
  }
  stack.handleArgs[v35] = (unsigned int *)&v40;
  v36 = stack.handleArgCount + 1;
  stack.handleArgCount = v36;
  if ( (unsigned int)v36 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v36 = stack.handleArgCount;
  }
  stack.handleArgs[v36] = (unsigned int *)&v45;
  v37 = stack.handleArgCount + 1;
  stack.handleArgCount = v37;
  if ( (unsigned int)v37 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v37 = stack.handleArgCount;
  }
  stack.handleArgs[v37] = (unsigned int *)&v40 + 1;
  v38 = stack.handleArgCount + 1;
  stack.handleArgCount = v38;
  if ( (unsigned int)v38 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v38 = stack.handleArgCount;
  }
  stack.handleArgs[v38] = (unsigned int *)&scope;
  v39 = stack.handleArgCount + 1;
  stack.handleArgCount = v39;
  if ( (unsigned int)v39 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v39 = stack.handleArgCount;
  }
  stack.handleArgs[v39] = &sceneColor->index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v32, &stack);
  cConditionEnd(pScript);
}

/*
==============
R_TGS_DOF_Fullres_Apply
==============
*/
void R_TGS_DOF_Fullres_Apply(R_TG_Script *pScript, R_TG_Handle *sceneColor, R_TG_Handle floatZ, R_TG_Handle scope, R_TG_Handle *dofTile0Handle)
{
  R_TG_Handle *v5; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  unsigned int v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  R_TG_Handle v16; 
  R_TG_Handle v17; 
  int v18; 
  R_TG_AddTaskStack stack; 
  R_TG_Handle v20; 
  unsigned int index; 

  index = scope.index;
  v20.index = floatZ.index;
  v5 = dofTile0Handle;
  cConditionBegin(pScript, R_DOF_GetEnabled);
  v17.index = -1;
  v16.index = -1;
  cRBT_DOF_DownsampleTile_Horizontal<R_TG_Handle,R_TG_Handle,R_TG_Handle>(pScript, &v16, sceneColor, &v20);
  cRBT_DOF_DownsampleTile_Vertical<R_TG_Handle,R_TG_Handle,R_TG_Handle>(pScript, v5, sceneColor, &v16);
  cRBT_DOF_TileNeighor<R_TG_Handle,R_TG_Handle>(pScript, &v17, v5);
  v18 = -1;
  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DOF_Downsample.m_index;
  stack.handleArgs[0] = (unsigned int *)&v18;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &sceneColor->index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, m_index, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v10 = g_R_TG_Def_RBT_DOF_CircularFilterFullres.m_index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgs[0] = &sceneColor->index;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = (unsigned int *)&v17;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( (unsigned int)v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = (unsigned int *)&v18;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &sceneColor->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( (unsigned int)v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = (unsigned int *)&v20;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( (unsigned int)v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v10, &stack);
  cConditionEnd(pScript);
}

