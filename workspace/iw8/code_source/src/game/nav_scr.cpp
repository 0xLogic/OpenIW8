/*
==============
Scr_GetClosestReachablePointOnNavmesh
==============
*/

void __fastcall Scr_GetClosestReachablePointOnNavmesh(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetClosestReachablePointOnNavmesh@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetModifierLocationBetween
==============
*/

void __fastcall Scr_GetModifierLocationBetween(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetModifierLocationBetween@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_IsPointOnNavMesh3d
==============
*/

void __fastcall Scr_IsPointOnNavMesh3d(scrContext_t *scrContext)
{
  ?Scr_IsPointOnNavMesh3d@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByBounds
==============
*/

void __fastcall Scr_CreateNavObstacleByBounds(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByBounds@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNavSpaceEnt
==============
*/

void __fastcall Scr_GetNavSpaceEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNavSpaceEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_FindPathCustom
==============
*/

void __fastcall Scr_FindPathCustom(scrContext_t *scrContext)
{
  ?Scr_FindPathCustom@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_FindPath
==============
*/

void __fastcall Scr_FindPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_FindPath@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_CreateNavObstacleByEnt
==============
*/

void __fastcall Scr_CreateNavObstacleByEnt(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByEnt@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavIsStraightLineReachable
==============
*/

void __fastcall Scr_NavIsStraightLineReachable(scrContext_t *scrContext)
{
  ?Scr_NavIsStraightLineReachable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetModifierLocationOnPath
==============
*/

void __fastcall Scr_GetModifierLocationOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetModifierLocationOnPath@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_NavTrace
==============
*/

void __fastcall Scr_NavTrace(scrContext_t *scrContext)
{
  ?Scr_NavTrace@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetRandomNavPoint
==============
*/

void __fastcall Scr_GetRandomNavPoint(scrContext_t *scrContext)
{
  ?Scr_GetRandomNavPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByShapeForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByShapeForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByShapeForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_UndockMovingPlatform
==============
*/

void __fastcall Scr_UndockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_UndockMovingPlatform@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_CreateNavBadplaceByEnt
==============
*/

void __fastcall Scr_CreateNavBadplaceByEnt(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByEnt@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavBadplaceByBounds
==============
*/

void __fastcall Scr_CreateNavBadplaceByBounds(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByBounds@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsNavMeshLoaded
==============
*/

void __fastcall Scr_IsNavMeshLoaded(scrContext_t *scrContext)
{
  ?Scr_IsNavMeshLoaded@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetClosestPointOnNavmesh3d
==============
*/

void __fastcall Scr_GetClosestPointOnNavmesh3d(scrContext_t *scrContext)
{
  ?Scr_GetClosestPointOnNavmesh3d@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavBadplaceByShape
==============
*/

void __fastcall Scr_CreateNavBadplaceByShape(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByShape@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByEntForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByEntForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByEntForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
NAV_GetModifierFlagsFromString
==============
*/

unsigned int __fastcall NAV_GetModifierFlagsFromString(const char *flagString)
{
  return ?NAV_GetModifierFlagsFromString@@YAIPEBD@Z(flagString);
}

/*
==============
Scr_AreAnyNavVolumesLoaded
==============
*/

void __fastcall Scr_AreAnyNavVolumesLoaded(scrContext_t *scrContext)
{
  ?Scr_AreAnyNavVolumesLoaded@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavIsStraightLineReachable3D
==============
*/

void __fastcall Scr_NavIsStraightLineReachable3D(scrContext_t *scrContext)
{
  ?Scr_NavIsStraightLineReachable3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByShape
==============
*/

void __fastcall Scr_CreateNavObstacleByShape(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByShape@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavObstacle
==============
*/

void __fastcall Scr_DestroyNavObstacle(scrContext_t *scrContext)
{
  ?Scr_DestroyNavObstacle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavRepulsor
==============
*/

void __fastcall Scr_DestroyNavRepulsor(scrContext_t *scrContext)
{
  ?Scr_DestroyNavRepulsor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetRandomNavPoints
==============
*/

void __fastcall Scr_GetRandomNavPoints(scrContext_t *scrContext)
{
  ?Scr_GetRandomNavPoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavLink
==============
*/

void __fastcall Scr_CreateNavLink(scrContext_t *scrContext)
{
  ?Scr_CreateNavLink@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_FindPath3D
==============
*/

void __fastcall Scr_FindPath3D(scrContext_t *scrContext)
{
  ?Scr_FindPath3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByBoundsForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByBoundsForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByBoundsForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavRepulsor
==============
*/

void __fastcall Scr_CreateNavRepulsor(scrContext_t *scrContext)
{
  ?Scr_CreateNavRepulsor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavLink
==============
*/

void __fastcall Scr_DestroyNavLink(scrContext_t *scrContext)
{
  ?Scr_DestroyNavLink@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsPointOnNavMesh
==============
*/

void __fastcall Scr_IsPointOnNavMesh(scrContext_t *scrContext)
{
  ?Scr_IsPointOnNavMesh@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNavPosition
==============
*/

void __fastcall Scr_GetNavPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNavPosition@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetClosestPointOnNavmesh
==============
*/

void __fastcall Scr_GetClosestPointOnNavmesh(scrContext_t *scrContext)
{
  ?Scr_GetClosestPointOnNavmesh@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavModifier
==============
*/

void __fastcall Scr_CreateNavModifier(scrContext_t *scrContext)
{
  ?Scr_CreateNavModifier@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavTrace3D
==============
*/

void __fastcall Scr_NavTrace3D(scrContext_t *scrContext)
{
  ?Scr_NavTrace3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DockMovingPlatform
==============
*/

void __fastcall Scr_DockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_DockMovingPlatform@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GetLayerFromName
==============
*/
__int64 GetLayerFromName(scrContext_t *scrContext, const scr_string_t layerName)
{
  const char *v4; 
  const char *v5; 

  if ( layerName == scr_const.tank_med )
    return 2i64;
  if ( layerName != scr_const.human && layerName != scr_const.soldier )
  {
    v4 = SL_ConvertToString(layerName);
    v5 = j_va("Unsupported layer name %s", v4);
    Scr_Error(COM_ERR_1496, scrContext, v5);
  }
  return 0i64;
}

/*
==============
NAV_GetModifierFlagsFromString
==============
*/
__int64 NAV_GetModifierFlagsFromString(const char *flagString)
{
  __int64 result; 
  bool v3; 

  if ( !flagString )
    return 0xFFFFFFFFi64;
  if ( !I_stricmp(flagString, "door") )
    return 0x10000000i64;
  if ( !I_stricmp(flagString, "prone") )
    return 0x40000000i64;
  v3 = I_stricmp(flagString, "crouch") == 0;
  result = 0x20000000i64;
  if ( !v3 )
    return 0xFFFFFFFFi64;
  return result;
}

/*
==============
Scr_AreAnyNavVolumesLoaded
==============
*/
void Scr_AreAnyNavVolumesLoaded(scrContext_t *scrContext)
{
  bool v2; 

  v2 = Nav_AnyVolumesLoaded();
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_CreateNavBadplaceByBounds
==============
*/
void Scr_CreateNavBadplaceByBounds(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavBadplaceByEnt
==============
*/
void Scr_CreateNavBadplaceByEnt(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavBadplaceByShape
==============
*/
void Scr_CreateNavBadplaceByShape(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByShape_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavLink
==============
*/
void Scr_CreateNavLink(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  pathnode_t *Pathnode; 
  unsigned int Int; 
  int v6; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  const char *v9; 
  signed int v10; 
  unsigned __int16 v11; 
  bfx::LinkDat pLinkDat; 
  vec3_t targetPos; 
  vec3_t vectorValue; 
  bfx::PathSpec pPathSpec; 

  pLinkDat.m_penaltyMult = FLOAT_1_0;
  pLinkDat.m_type = JUMP_LINK;
  pLinkDat.m_userData = 0i64;
  pLinkDat.m_layerMask = -1;
  *(_WORD *)&pLinkDat.m_bidirectional = 1;
  *(_QWORD *)&pLinkDat.m_forwardLinkUsageFlags = -1i64;
  pLinkDat.m_maxSnapDist = bfx::GetScale() * 4.0;
  pLinkDat.m_flowTune.m_maxSimultaneous = 0;
  pLinkDat.m_mustUseDist = 0.0;
  pLinkDat.m_flowTune.m_delayBeforeNextUser = 0.0;
  pLinkDat.m_mayUseDist = bfx::GetScale();
  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_1501, scrContext, "CreateNavLink( linkName, startPos, endPos, animscript ): invalid number of arguments.");
  if ( *Scr_GetString(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = 0;
  v3 = 1;
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &targetPos);
  if ( Scr_GetType(scrContext, 3u) == VAR_STRING )
  {
    Scr_GetString(scrContext, 3u);
    v11 = -1;
  }
  else
  {
    Pathnode = Scr_GetPathnode(scrContext, 3u);
    v11 = Path_ConvertNodeToIndex(Pathnode);
    if ( ((1 << LOBYTE(Pathnode->constant.type)) & 0x68010000) == 0 )
      Scr_Error(COM_ERR_1502, scrContext, "CreateNavLink: pathnode (arg4) must be a negotiation begin node.");
  }
  Int = 2047;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) == VAR_INTEGER )
    Int = Scr_GetInt(scrContext, 4u);
  v6 = -1;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER )
    v6 = Scr_GetInt(scrContext, 5u);
  if ( Scr_GetNumParam(scrContext) <= 6 || Scr_GetType(scrContext, 6u) != VAR_POINTER )
  {
    DefaultSpace = Nav_GetDefaultSpace();
    if ( DefaultSpace )
      goto LABEL_26;
    goto LABEL_24;
  }
  Entity = GScr_GetEntity(6u);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 369, ASSERT_TYPE_ASSERT, "( pSpaceEnt )", (const char *)&queryFormat, "pSpaceEnt") )
    __debugbreak();
  DefaultSpace = Nav_GetSpaceByEntity(Entity);
  if ( !DefaultSpace )
  {
    v9 = j_va("CreateNavLink: unable to find navigational space associated with entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1504, scrContext, v9);
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 379, ASSERT_TYPE_ASSERT, "( pSpace )", (const char *)&queryFormat, "pSpace") )
      __debugbreak();
  }
LABEL_26:
  Nav_SetLinkDatToDefault(&pLinkDat);
  pLinkDat.m_forwardLinkUsageFlags = Int;
  pLinkDat.m_backwardLinkUsageFlags = Int;
  pLinkDat.m_userData = Nav_ConstructLinkUserData(v11, 0xFFFFu);
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pPathSpec.m_usePathSharingPenalty = 0;
  pPathSpec.m_pathSharingPenalty = 0.0;
  pPathSpec.m_maxPathSharingPenalty = 0.0;
  pPathSpec.m_maxSearchDist = 0.0;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  v10 = 0;
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  pPathSpec.m_obstacleBlockageFlags = 0;
  do
  {
    if ( (v3 & v6) != 0 )
    {
      pLinkDat.m_layerMask = v3;
      Nav_GetClosestVerticalPos(&vectorValue, &g_navUp, v10, &DefaultSpace->hSpace, &pPathSpec, &vectorValue, NULL);
      Nav_GetClosestVerticalPos(&targetPos, &g_navUp, v10, &DefaultSpace->hSpace, &pPathSpec, &targetPos, NULL);
      Nav_CreateLink(DefaultSpace, &vectorValue, &targetPos, ConstString, -1, &pLinkDat);
    }
    ++v10;
    v3 = __ROL4__(v3, 1);
  }
  while ( v10 < 3 );
}

/*
==============
Scr_CreateNavModifier
==============
*/
void Scr_CreateNavModifier(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int outModifierID; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString )
    Scr_Error(COM_ERR_1536, scrContext, "CreateNavModifier: invalid name.");
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = v3;
  if ( v3 != scr_const.target && v3 != scr_const.targetname && v3 != scr_const.script_linkname && v3 != scr_const.script_noteworthy )
    Scr_Error(COM_ERR_1537, scrContext, "CreateNavModifier: invalid key provided.  Must be target, targetname, script_linkname, or script_noteworthy");
  if ( !Nav_CreateModifierByName(v4, ConstString, &outModifierID) )
    Scr_Error(COM_ERR_1538, scrContext, "CreateNavModifier: creation failed for some reason.  Possible causes: no modifier found by that name, no modifier found that was marked NOT_ON_LOAD.");
  Scr_AddInt(scrContext, outModifierID);
}

/*
==============
Scr_CreateNavObstacleByBounds
==============
*/
void Scr_CreateNavObstacleByBounds(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByBoundsForLayer
==============
*/
void Scr_CreateNavObstacleByBoundsForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByBounds_Internal
==============
*/
void Scr_CreateNavObstacleByBounds_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v9; 
  float v10; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  int NumParam; 
  double Float; 
  unsigned int v14; 
  bitarray<224> *p_result; 
  bitarray<224> *AllCombatTeamFlags; 
  int v19; 
  int blockageFlags; 
  int v21; 
  nav_space_s *MostLikelySpaceWithRadius; 
  int v23; 
  Bounds vectorValue; 
  bitarray<224> result; 
  vec3_t angles; 

  Scr_GetVector(scrContext, argOffset, &vectorValue.midPoint);
  Scr_GetVector(scrContext, argOffset + 1, &vectorValue.halfSize);
  Scr_GetVector(scrContext, argOffset + 2, &angles);
  v9 = 3;
  v10 = FLOAT_15_0;
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 3 || (unsigned __int8)(Scr_GetType(scrContext, 3u) - 5) > 1u )
    goto LABEL_11;
  if ( bSolid )
    Scr_Error(COM_ERR_6161, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6162, scrContext, "weight arg cannot be used with any blockage flags");
  if ( NumParam > 4 )
    Scr_Error(COM_ERR_6163, scrContext, "weight arg cannot be used with team blockage flags");
  v9 = 4;
  Float = Scr_GetFloat(scrContext, 3u);
  v10 = *(float *)&Float;
  if ( *(float *)&Float >= 15.0 )
  {
LABEL_11:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, argOffset + v9);
      v14 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v14;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v14 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllCombatTeamFlags();
          else
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
          result = *AllCombatTeamFlags;
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  else
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  _XMM0 = LODWORD(vectorValue.halfSize.v[0]);
  __asm { vmaxss  xmm6, xmm0, dword ptr [rsp+0D8h+var_9C+4] }
  v19 = 0;
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v21 = 1;
  while ( 1 )
  {
    if ( (v21 & layermask) != 0 )
    {
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&vectorValue.midPoint, *(float *)&_XMM6, (const AINavLayer)v19, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v19;
    v21 = __ROL4__(v21, 1);
    if ( v19 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  v23 = Nav_CreateObstacleByBounds(MostLikelySpaceWithRadius, &vectorValue, &angles, v10, layermask, blockageFlags);
  Scr_AddInt(scrContext, v23);
}

/*
==============
Scr_CreateNavObstacleByEnt
==============
*/
void Scr_CreateNavObstacleByEnt(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByEntForLayer
==============
*/
void Scr_CreateNavObstacleByEntForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByEnt_Internal
==============
*/
void Scr_CreateNavObstacleByEnt_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v8; 
  int v9; 
  gentity_s *Entity; 
  float v11; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  int NumParam; 
  double Float; 
  unsigned int v15; 
  bitarray<224> *p_result; 
  bitarray<224> *AllCombatTeamFlags; 
  int blockageFlags; 
  int v21; 
  nav_space_s *MostLikelySpaceWithRadius; 
  bitarray<224> result; 

  v8 = 1;
  v9 = 1;
  Entity = GScr_GetEntity(argOffset);
  v11 = FLOAT_15_0;
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 1 || (unsigned __int8)(Scr_GetType(scrContext, 1u) - 5) > 1u )
    goto LABEL_11;
  if ( bSolid )
    Scr_Error(COM_ERR_6158, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6159, scrContext, "weight arg cannot be used with any other blockage flags.");
  if ( NumParam > 2 )
    Scr_Error(COM_ERR_6160, scrContext, "weight arg cannot be used with team blockage flags.");
  v9 = 2;
  Float = Scr_GetFloat(scrContext, 1u);
  v11 = *(float *)&Float;
  if ( *(float *)&Float >= 15.0 )
  {
LABEL_11:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, argOffset + v9);
      v15 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v15;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v15 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllCombatTeamFlags();
          else
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
          result = *AllCombatTeamFlags;
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  else
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  _XMM0 = LODWORD(Entity->r.box.halfSize.v[1]);
  __asm { vmaxss  xmm6, xmm0, dword ptr [rbp+10Ch] }
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v21 = 0;
  while ( 1 )
  {
    if ( (v8 & layermask) != 0 )
    {
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&Entity->r.currentOrigin, *(float *)&_XMM6, (const AINavLayer)v21, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v21;
    v8 = __ROL4__(v8, 1);
    if ( v21 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  Nav_CreateObstacleByEnt(MostLikelySpaceWithRadius, Entity, v11, layermask, blockageFlags, 0, 0);
  Scr_AddInt(scrContext, Entity->s.number);
}

/*
==============
Scr_CreateNavObstacleByShape
==============
*/
void Scr_CreateNavObstacleByShape(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByShape_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByShapeForLayer
==============
*/
void Scr_CreateNavObstacleByShapeForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByShape_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByShape_Internal
==============
*/
void Scr_CreateNavObstacleByShape_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v7; 
  int Int; 
  int v10; 
  double Float; 
  float v12; 
  double v13; 
  signed int v14; 
  float v15; 
  const char *v16; 
  const char *v17; 
  float v18; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  signed int NumParam; 
  double v21; 
  unsigned int v22; 
  bitarray<224> *p_result; 
  bitarray<224> *AllCombatTeamFlags; 
  int v25; 
  int blockageFlags; 
  int v27; 
  nav_space_s *MostLikelySpaceWithRadius; 
  int v29; 
  vec3_t vectorValue; 
  bitarray<224> result; 

  v7 = argOffset;
  Scr_GetVector(scrContext, argOffset, &vectorValue);
  Int = Scr_GetInt(scrContext, v7 + 1);
  v7 += 2;
  v10 = Int;
  Float = Scr_GetFloat(scrContext, v7);
  v12 = *(float *)&Float;
  v13 = Scr_GetFloat(scrContext, v7 + 1);
  v14 = v7 + 2;
  v15 = *(float *)&v13;
  if ( (unsigned int)(v10 - 2) > 8 )
  {
    v16 = j_va("Number of sides must be greater than 2 and no more than %d", 10i64);
    Scr_Error(COM_ERR_6402, scrContext, v16);
  }
  if ( v12 < 0.0 )
  {
    v17 = j_va("distFromCenter ( %.f ) must be greater than 0", v12);
    Scr_Error(COM_ERR_6403, scrContext, v17);
  }
  v18 = FLOAT_15_0;
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= v14 || (unsigned __int8)(Scr_GetType(scrContext, v14) - 5) > 1u )
    goto LABEL_15;
  if ( bSolid )
    Scr_Error(COM_ERR_6404, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6405, scrContext, "weight arg cannot be used with any other blockage flags.");
  if ( NumParam > v14 + 1 )
    Scr_Error(COM_ERR_6406, scrContext, "weight arg cannot be used with team blockage flags.");
  v21 = Scr_GetFloat(scrContext, v14);
  v18 = *(float *)&v21;
  ++v14;
  if ( *(float *)&v21 >= 15.0 )
  {
LABEL_15:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, v14);
      v22 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v22;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v22 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllCombatTeamFlags();
          else
            AllCombatTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
          result = *AllCombatTeamFlags;
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  else
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  v25 = 1;
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v27 = 0;
  while ( 1 )
  {
    if ( (v25 & layermask) != 0 )
    {
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&vectorValue, v12, (const AINavLayer)v27, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v27;
    v25 = __ROL4__(v25, 1);
    if ( v27 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  v29 = Nav_CreateObstacleByShape(MostLikelySpaceWithRadius, &vectorValue, v10, v12, v15, v18, layermask, blockageFlags, 0, 0);
  Scr_AddInt(scrContext, v29);
}

/*
==============
Scr_CreateNavRepulsor
==============
*/
void Scr_CreateNavRepulsor(scrContext_t *scrContext)
{
  __int128 v1; 
  __int128 v2; 
  bool bBadplace; 
  unsigned int v5; 
  scr_string_t name; 
  int v9; 
  double Float; 
  unsigned int v12; 
  int entNum; 
  nav_space_s *m_pSpace; 
  const char *v15; 
  const char *v16; 
  bitarray<224> *p_result; 
  bitarray<224> *AllCombatTeamFlags; 
  gentity_s *Entity; 
  double v20; 
  AINavigator *Navigator; 
  int usageFlags; 
  const char *v24; 
  vec3_t vectorValue; 
  bitarray<224> result; 
  __int128 v27; 
  __int128 v28; 

  bBadplace = 0;
  v28 = v1;
  v5 = 0;
  if ( *Scr_GetString(scrContext, 0) )
    name = Scr_GetConstString(scrContext, 0);
  else
    name = 0;
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 2 }
  v9 = (int)*(float *)&_XMM4;
  if ( Scr_GetType(scrContext, 2u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    Float = Scr_GetFloat(scrContext, 3u);
    LODWORD(_XMM6) = LODWORD(Float);
    v12 = 4;
    if ( *(float *)&Float < 0.0 )
      Scr_Error(COM_ERR_1506, scrContext, "CreateNavRepulsor: cannot create repulsor with non-positive radius.");
    entNum = 2047;
  }
  else
  {
    v27 = v2;
    Entity = GScr_GetEntity(2u);
    v12 = 3;
    if ( !Entity )
      Scr_Error(COM_ERR_1507, scrContext, "CreateNavRepulsor requires a valid entity. If no entity is desired, then create a repulsor with a point/radius instead.");
    vectorValue = Entity->r.currentOrigin;
    if ( Scr_GetType(scrContext, 3u) != VAR_INTEGER && Scr_GetType(scrContext, 3u) != VAR_FLOAT || (v20 = Scr_GetFloat(scrContext, 3u), LODWORD(_XMM6) = LODWORD(v20), v12 = 4, *(float *)&v20 <= 0.0) )
    {
      _XMM0 = LODWORD(Entity->r.box.halfSize.v[1]);
      __asm { vmaxss  xmm6, xmm0, dword ptr [rbp+10Ch] }
      if ( *(float *)&_XMM6 <= 0.0 )
        Scr_Error(COM_ERR_1508, scrContext, "CreateNavRepulsor: entity has non-positive radius.");
    }
    entNum = Entity->s.number;
    Navigator = Nav_GetNavigator(Entity);
    if ( Navigator )
    {
      m_pSpace = Navigator->m_pSpace;
      goto LABEL_9;
    }
  }
  m_pSpace = Nav_FindMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, NULL);
LABEL_9:
  if ( !m_pSpace )
  {
    v15 = vtos(&vectorValue);
    v16 = j_va("CreateNavRepulsor: unable to create repulsor in non-navigable space at %s.", v15);
    Scr_Error(COM_ERR_1509, scrContext, v16);
  }
  if ( v12 < Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, v12) == VAR_INTEGER )
    bBadplace = Scr_GetInt(scrContext, v12++) != 0;
  Scr_GetTeamFlags(&result, scrContext, v12);
  p_result = &result;
  while ( !p_result->array[0] )
  {
    ++v5;
    p_result = (bitarray<224> *)((char *)p_result + 4);
    if ( v5 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllCombatTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllCombatTeamFlags();
      else
        AllCombatTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
      result = *AllCombatTeamFlags;
      break;
    }
  }
  usageFlags = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&result);
  if ( !Nav_CreateRepulsor(m_pSpace, &vectorValue, &vec3_origin, v9, *(float *)&_XMM6, entNum, usageFlags, name, bBadplace) )
  {
    v24 = j_va("CreateNavRepulsor: unable to alloc repulsor.  Exceeded max (%d)?", 256i64);
    Scr_Error(COM_ERR_1510, scrContext, v24);
  }
}

/*
==============
Scr_DestroyNavLink
==============
*/
void Scr_DestroyNavLink(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const pathnode_t *Pathnode; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1505, scrContext, "DestroyNavLink( linkName ): invalid number of parameters.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Nav_DestroyLinkByName(ConstString);
  }
  else
  {
    Pathnode = Scr_GetPathnode(scrContext, 0);
    Nav_DestroyLinkByNode(Pathnode);
  }
}

/*
==============
Scr_DestroyNavObstacle
==============
*/
void Scr_DestroyNavObstacle(scrContext_t *scrContext)
{
  unsigned int Int; 

  Int = Scr_GetInt(scrContext, 0);
  Nav_DestroyObstacleByID(Int);
}

/*
==============
Scr_DestroyNavRepulsor
==============
*/
void Scr_DestroyNavRepulsor(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  nav_repulsor_s *RepulsorByName; 
  gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    RepulsorByName = Nav_FindRepulsorByName(ConstString);
  }
  else
  {
    Entity = GScr_GetEntity(0);
    if ( !Entity )
      Scr_Error(COM_ERR_1511, scrContext, "DestroyNavRepulsor: Invalid entity.");
    RepulsorByName = Nav_FindRepulsorByEntNum(Entity->s.number);
  }
  if ( RepulsorByName )
    Nav_DestroyRepulsor(RepulsorByName);
}

/*
==============
Scr_DockMovingPlatform
==============
*/
void Scr_DockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  nav_resource_s *ResourceByEntNum; 
  const char *v6; 
  const char *v7; 
  nav_space_s *SpaceByEntity; 
  const char *v9; 
  nav_space_s *v10; 
  nav_space_s *v11; 
  const char *v12; 
  vec4_t quat; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1037, ASSERT_TYPE_ASSERT, "( pPlatform )", (const char *)&queryFormat, "pPlatform") )
    __debugbreak();
  v4 = NULL;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_POINTER )
    v4 = GScr_GetEntity(0);
  ResourceByEntNum = Nav_GetResourceByEntNum(Entity->s.number);
  if ( !ResourceByEntNum )
  {
    v6 = j_va("DockMovingPlatform: No mesh found attached to entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1512, scrContext, v6);
  }
  if ( !ResourceByEntNum->bDockable )
  {
    v7 = j_va("DockMovingPlatform: Mesh attached to entity %d is not dockable.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1513, scrContext, v7);
  }
  if ( v4 )
  {
    SpaceByEntity = Nav_GetSpaceByEntity(v4);
    if ( !SpaceByEntity )
    {
      v9 = j_va("DockMovingPlatform: Unable to find navigational space associated with entity %d.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_1514, scrContext, v9);
    }
  }
  else
  {
    SpaceByEntity = Nav_GetDefaultSpace();
  }
  v10 = Nav_GetSpaceByEntity(Entity);
  v11 = v10;
  if ( v10 )
  {
    if ( v10->numResources == 1 )
    {
      Nav_ClearSpace(v10, 0, SpaceByEntity);
      Nav_RemoveResourceFromSpace(v11, ResourceByEntNum);
      Nav_DestroySpace(v11);
    }
    else
    {
      Nav_RemoveResourceFromSpace(v10, ResourceByEntNum);
    }
  }
  else
  {
    v12 = j_va("DockMovingPlatform: Unable to find navigational space associated with entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1515, scrContext, v12);
  }
  if ( !SpaceByEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1080, ASSERT_TYPE_ASSERT, "( pSpace2 )", (const char *)&queryFormat, "pSpace2") )
    __debugbreak();
  AnglesToQuat(&Entity->r.currentAngles, &quat);
  Nav_AddResourceToOldSpace(SpaceByEntity, ResourceByEntNum, &Entity->r.currentOrigin, &quat, 0);
}

/*
==============
Scr_FindPath3D
==============
*/
void Scr_FindPath3D(scrContext_t *scrContext)
{
  nav_space_s *DefaultSpace; 
  bfx::PolylinePath3DRCPtr v3; 
  unsigned int v4; 
  __int64 v5; 
  vec3_t *p_outPath; 
  bfx::PolylinePath3DRCPtr result; 
  bfx::PolylinePath3DRCPtr v8; 
  __int64 v9; 
  vec3_t vectorValue; 
  vec3_t endPos; 
  vec3_t outPath; 

  v9 = -2i64;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  Nav_FindPath3D(&result, &vectorValue, &endPos);
  if ( !bfx::PolylinePath3DRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1312, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  if ( bfx::PolylinePath3DRCPtr::GetNumSegments(&result) )
  {
    DefaultSpace = Nav_GetDefaultSpace();
    bfx::PolylinePath3DRCPtr::PolylinePath3DRCPtr(&v8, &result);
    v4 = Nav_Simplify3DPath(DefaultSpace, &vectorValue, v3, 128, &outPath);
    v5 = v4;
    if ( v4 - 1 > 0x7F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1326, ASSERT_TYPE_ASSERT, "( numPathPoints > 0 && numPathPoints <= cMaxPathPoints )", (const char *)&queryFormat, "numPathPoints > 0 && numPathPoints <= cMaxPathPoints") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    if ( (int)v5 > 0 )
    {
      p_outPath = &outPath;
      do
      {
        Scr_AddVector(scrContext, p_outPath->v);
        Scr_AddArray(scrContext);
        ++p_outPath;
        --v5;
      }
      while ( v5 );
    }
  }
  bfx::PolylinePath3DRCPtr::~PolylinePath3DRCPtr(&result);
}

/*
==============
Scr_FindPath
==============
*/
void Scr_FindPath(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  AINavLayer layer; 
  nav_repulsor_s *RepulsorByEntNum; 
  nav_space_s *pSpace; 
  AINavigator *Navigator; 
  AINavLayer v9; 
  AINavigator2D *v10; 
  int Int; 
  unsigned int m_obstacleBlockageFlags; 
  int v13; 
  unsigned int m_linkUsageFlags; 
  bfx::PathSpec pathSpec; 
  vec3_t endPt; 
  vec3_t vectorValue; 

  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pathSpec.m_pathSharingPenalty = 0.0;
  pathSpec.m_maxPathSharingPenalty = 0.0;
  pathSpec.m_maxSearchDist = 0.0;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    layer = NAV_LAYER_HUMAN;
    RepulsorByEntNum = Nav_FindRepulsorByEntNum(Entity->s.number);
    if ( RepulsorByEntNum )
      pSpace = RepulsorByEntNum->pSpace;
    else
      pSpace = Nav_GetDefaultSpace();
  }
  else
  {
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
      Scr_Error(COM_ERR_1519, scrContext, "Unsupported ent type.  Currently supporting player, actor, and bot.");
    v9 = Nav_GetLayer(Navigator);
    pSpace = Navigator->m_pSpace;
    layer = v9;
    v10 = Navigator->Get2DNavigator(Navigator);
    if ( v10 )
      pathSpec = *AINavigator2D::GetPathSpec(v10);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPt);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) == VAR_INTEGER )
  {
    Int = Scr_GetInt(scrContext, 2u);
    m_obstacleBlockageFlags = pathSpec.m_obstacleBlockageFlags;
    if ( Int > 0 )
      m_obstacleBlockageFlags = 0;
    pathSpec.m_obstacleBlockageFlags = m_obstacleBlockageFlags;
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
  {
    v13 = Scr_GetInt(scrContext, 3u);
    m_linkUsageFlags = pathSpec.m_linkUsageFlags;
    if ( v13 > 0 )
      m_linkUsageFlags = 0;
    pathSpec.m_linkUsageFlags = m_linkUsageFlags;
  }
  Scr_FindPathInternal(scrContext, pSpace, &vectorValue, &endPt, layer, &pathSpec);
}

/*
==============
Scr_FindPathCustom
==============
*/
void Scr_FindPathCustom(scrContext_t *scrContext)
{
  AINavLayer layer; 
  int NumParam; 
  int Int; 
  unsigned int m_obstacleBlockageFlags; 
  int v6; 
  unsigned int m_linkUsageFlags; 
  scr_string_t ConstString; 
  nav_space_s *DefaultSpace; 
  vec3_t vectorValue; 
  bfx::PathSpec pathSpec; 
  vec3_t endPt; 

  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  layer = NAV_LAYER_HUMAN;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pathSpec.m_pathSharingPenalty = 0.0;
  pathSpec.m_maxPathSharingPenalty = 0.0;
  pathSpec.m_maxSearchDist = 0.0;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPt);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) == VAR_INTEGER )
  {
    Int = Scr_GetInt(scrContext, 2u);
    m_obstacleBlockageFlags = pathSpec.m_obstacleBlockageFlags;
    if ( Int > 0 )
      m_obstacleBlockageFlags = 0;
    pathSpec.m_obstacleBlockageFlags = m_obstacleBlockageFlags;
  }
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
  {
    v6 = Scr_GetInt(scrContext, 3u);
    m_linkUsageFlags = pathSpec.m_linkUsageFlags;
    if ( v6 > 0 )
      m_linkUsageFlags = 0;
    pathSpec.m_linkUsageFlags = m_linkUsageFlags;
  }
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 4u);
    layer = (unsigned int)GetLayerFromName(scrContext, ConstString);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( NumParam > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER && Scr_GetInt(scrContext, 5u) )
    DefaultSpace = Nav_FindMostLikelySpace(&vectorValue, layer, NULL);
  Scr_FindPathInternal(scrContext, DefaultSpace, &vectorValue, &endPt, layer, &pathSpec);
}

/*
==============
Scr_FindPathInternal
==============
*/
void Scr_FindPathInternal(scrContext_t *scrContext, nav_space_s *pSpace, const vec3_t *startPt, const vec3_t *endPt, AINavLayer layer, const bfx::PathSpec *pathSpec)
{
  int NumSegments; 
  const dvar_t *v10; 
  int i; 
  bfx::SurfaceSegment *SurfaceSegment; 
  const bfx::Vector3 *StartPos; 
  float m_z; 
  float m_y; 
  const bfx::Vector3 *EndPos; 
  float v17; 
  float v18; 
  bfx::PolylinePathRCPtr v19; 
  unsigned int v20; 
  __int64 v21; 
  vec3_t *p_outPath; 
  bfx::PolylinePathRCPtr result; 
  __int64 v24; 
  vec3_t end; 
  vec3_t start; 
  vec3_t outPath; 

  v24 = -2i64;
  Nav_FindPathCustom(&result, pSpace, startPt, endPt, layer, pathSpec->m_areaUsageFlags, pathSpec->m_linkUsageFlags, pathSpec->m_obstacleBlockageFlags);
  if ( !bfx::PolylinePathRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1133, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  NumSegments = bfx::PolylinePathRCPtr::GetNumSegments(&result);
  if ( NumSegments )
  {
    v10 = DVARINT_ai_showPaths;
    if ( !DVARINT_ai_showPaths && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_showPaths") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    if ( v10->current.integer > 0 )
    {
      for ( i = 0; i < NumSegments; ++i )
      {
        if ( bfx::PolylinePathRCPtr::GetSegmentType(&result, i) == SURFACE_SEGMENT )
        {
          SurfaceSegment = bfx::PolylinePathRCPtr::GetSurfaceSegment(&result, i);
          StartPos = bfx::SurfaceSegment::GetStartPos(SurfaceSegment);
          m_z = StartPos->m_z;
          m_y = StartPos->m_y;
          start.v[0] = StartPos->m_x;
          start.v[1] = m_y;
          start.v[2] = m_z;
          EndPos = bfx::SurfaceSegment::GetEndPos(SurfaceSegment);
          v17 = EndPos->m_z;
          v18 = EndPos->m_y;
          end.v[0] = EndPos->m_x;
          end.v[1] = v18;
          end.v[2] = v17;
          G_DebugLineWithDuration(&start, &end, &colorBlue, 0, 60);
          G_DebugCircle(&end, 6.0, &colorBlue, 0, 1, 60);
        }
      }
    }
    bfx::PolylinePathRCPtr::PolylinePathRCPtr((bfx::PolylinePathRCPtr *)&end, &result);
    v20 = Nav_SimplifyPath(pSpace, startPt, v19, layer, pathSpec, 128, &outPath);
    v21 = v20;
    if ( v20 - 1 > 0x7F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1164, ASSERT_TYPE_ASSERT, "( numPathPoints > 0 && numPathPoints <= cMaxPathPoints )", (const char *)&queryFormat, "numPathPoints > 0 && numPathPoints <= cMaxPathPoints") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    if ( (int)v21 > 0 )
    {
      p_outPath = &outPath;
      do
      {
        Scr_AddVector(scrContext, p_outPath->v);
        Scr_AddArray(scrContext);
        ++p_outPath;
        --v21;
      }
      while ( v21 );
    }
  }
  bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&result);
}

/*
==============
Scr_GetClosestPointOnNavmesh3d
==============
*/
void Scr_GetClosestPointOnNavmesh3d(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  nav_space_s *m_pSpace; 
  bfx::Path3DSpec pathSpec; 
  vec3_t vectorValue; 
  vec3_t outClosestPos; 

  if ( !Nav_AnyVolumesLoaded() )
    Scr_Error(COM_ERR_1526, scrContext, "GetClosestPointOnNavmesh3d can only be used when navmesh is loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 1 && (Entity = GScr_GetEntity(1u), (Navigator = Nav_GetNavigator(Entity)) != NULL) )
    m_pSpace = Navigator->m_pSpace;
  else
    m_pSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_volumeUsageFlags = -1i64;
  pathSpec.m_maxSearchDist = 0.0;
  if ( !Nav3D_GetClosestPointOnMesh(m_pSpace, &pathSpec, &vectorValue, &outClosestPos) )
    Scr_Error(COM_ERR_1527, scrContext, "Either NavMesh is not loaded or no 3d volumes found!");
  Scr_AddVector(scrContext, outClosestPos.v);
}

/*
==============
Scr_GetClosestPointOnNavmesh
==============
*/
void Scr_GetClosestPointOnNavmesh(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int NumParam; 
  char v4; 
  const AINavigator *Navigator; 
  AINavigator *v6; 
  AINavLayer Layer; 
  nav_space_s *m_pSpace; 
  AINavLayer LayerFromName; 
  AINavigator2D *v10; 
  scr_string_t ConstString; 
  unsigned int LayersLoaded; 
  const char *v13; 
  const char *v14; 
  float v15; 
  bool v16; 
  vec3_t outClosestPos; 
  vec3_t vectorValue; 
  bfx::PathSpec pPathSpec; 
  vec3_t outUp; 

  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  Entity = NULL;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  pPathSpec.m_pathSharingPenalty = 0.0;
  pPathSpec.m_maxPathSharingPenalty = 0.0;
  pPathSpec.m_maxSearchDist = 0.0;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( !Nav_MeshLoaded() )
    Scr_Error(COM_ERR_1524, scrContext, "GetClosestPointOnNavmesh can only be used when navmesh is loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    v4 = 1;
    if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
    {
      Entity = GScr_GetEntity(1u);
      Navigator = Nav_GetNavigator(Entity);
      v6 = (AINavigator *)Navigator;
      if ( Navigator )
      {
        Layer = Nav_GetLayer(Navigator);
        m_pSpace = v6->m_pSpace;
        LayerFromName = Layer;
        if ( NumParam > 3 )
        {
          if ( Scr_GetType(scrContext, 3u) )
          {
            if ( Scr_GetInt(scrContext, 3u) )
            {
              v10 = v6->Get2DNavigator(v6);
              if ( v10 )
                pPathSpec = *AINavigator2D::GetPathSpec(v10);
            }
          }
        }
        goto LABEL_18;
      }
    }
  }
  else
  {
    v4 = 0;
  }
  LayerFromName = NAV_LAYER_HUMAN;
  if ( v4 )
  {
    if ( Scr_GetType(scrContext, 1u) == VAR_STRING )
    {
      ConstString = Scr_GetConstString(scrContext, 1u);
      LayerFromName = (unsigned int)GetLayerFromName(scrContext, ConstString);
      LayersLoaded = bfx::GetLayersLoaded();
      if ( !_bittest((const int *)&LayersLoaded, LayerFromName) )
      {
        v13 = SL_ConvertToString(ConstString);
        v14 = j_va("GetClosestPointOnNavmesh: No navmesh loaded in layer %s", v13);
        Scr_Error(COM_ERR_1525, scrContext, v14);
      }
    }
  }
  m_pSpace = Nav_GetDefaultSpace();
LABEL_18:
  if ( NumParam > 2 && Scr_GetInt(scrContext, 2u) )
  {
    if ( Entity )
      v15 = Entity->r.box.halfSize.v[0];
    else
      v15 = FLOAT_N1_0;
    v16 = Nav_GetClosestVerticalPosInMostLikelySpace(&vectorValue, LayerFromName, v15, &pPathSpec, &outClosestPos, NULL) == NULL;
  }
  else
  {
    Nav_GetSpaceUp(m_pSpace, &outUp);
    v16 = !Nav_GetClosestVerticalPos(&vectorValue, &outUp, LayerFromName, &m_pSpace->hSpace, &pPathSpec, &outClosestPos, NULL);
  }
  if ( !v16 )
    Scr_AddVector(scrContext, outClosestPos.v);
}

/*
==============
Scr_GetClosestReachablePointOnNavmesh
==============
*/
void Scr_GetClosestReachablePointOnNavmesh(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v5; 
  AINavigator_vtbl *v6; 
  __int64 v7; 
  float v8; 
  vec3_t vectorValue; 
  float value[4]; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_5789, scrContext, "GetClosestReachablePointOnNavmesh : invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetClosestReachablePointOnNavmesh : Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_5790, scrContext, v5);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  v8 = vectorValue.v[2];
  v6 = Navigator->__vftable;
  v7 = *(__int64 *)vectorValue.v;
  ((void (__fastcall *)(AINavigator *, __int64 *, float *))v6->GetClosestReachablePoint)(Navigator, &v7, value);
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_GetModifierLocationBetween
==============
*/
void Scr_GetModifierLocationBetween(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int layer; 
  nav_repulsor_s *RepulsorByEntNum; 
  nav_space_s *pSpace; 
  AINavigator *Navigator; 
  unsigned int ModifierFlagsFromString; 
  float v9; 
  const char *String; 
  double Float; 
  bfx::PolylinePathRCPtr result; 
  __int64 v13; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  float value[4]; 
  vec3_t goalPos; 
  vec3_t vectorValue; 

  v13 = -2i64;
  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    layer = 0;
    RepulsorByEntNum = Nav_FindRepulsorByEntNum(Entity->s.number);
    if ( RepulsorByEntNum )
      pSpace = RepulsorByEntNum->pSpace;
    else
      pSpace = Nav_GetDefaultSpace();
  }
  else
  {
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
      Scr_Error(COM_ERR_1532, scrContext, "Unsupported ent type.  Currently supporting player, actor, scripted agents, and bot.");
    layer = Nav_GetLayer(Navigator);
    pSpace = Navigator->m_pSpace;
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &goalPos);
  Nav_FindPath(&result, pSpace, &vectorValue, &goalPos, layer);
  if ( !bfx::PolylinePathRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1819, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  if ( bfx::PolylinePathRCPtr::GetNumSegments(&result) )
  {
    ModifierFlagsFromString = -1;
    v9 = 0.0;
    if ( Scr_GetNumParam(scrContext) >= 3 )
    {
      String = Scr_GetString(scrContext, 2u);
      ModifierFlagsFromString = NAV_GetModifierFlagsFromString(String);
    }
    if ( Scr_GetNumParam(scrContext) >= 4 )
    {
      Float = Scr_GetFloat(scrContext, 3u);
      v9 = *(float *)&Float;
    }
    if ( Nav_GetModifierLocationOnPath(&result, ModifierFlagsFromString, 0, v9, 3.4028235e38, &outStartPoint, &outEndPoint) )
    {
      value[0] = (float)(outEndPoint.v[0] + outStartPoint.v[0]) * 0.5;
      value[1] = (float)(outEndPoint.v[1] + outStartPoint.v[1]) * 0.5;
      value[2] = (float)(outEndPoint.v[2] + outStartPoint.v[2]) * 0.5;
      Scr_AddVector(scrContext, value);
    }
  }
  bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&result);
}

/*
==============
Scr_GetModifierLocationOnPath
==============
*/
void Scr_GetModifierLocationOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v7; 
  AINavigator2D *v8; 
  const char *v9; 
  unsigned int ModifierFlagsFromString; 
  float v11; 
  unsigned int v12; 
  double Float; 
  const char *String; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  float value[4]; 

  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1533, scrContext, "GetModifierLocationOnPath: invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v7 = j_va("GetModifierLocationOnPath: Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1534, scrContext, v7);
  }
  v8 = Navigator->Get2DNavigator(Navigator);
  if ( !v8 )
  {
    v9 = j_va("GetModifierLocationOnPath: Entity %d does not have a 2D navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1535, scrContext, v9);
  }
  ModifierFlagsFromString = -1;
  v11 = FLOAT_3_4028235e38;
  v12 = NumParam - 1;
  if ( v12 )
  {
    if ( v12 != 1 )
      goto LABEL_11;
    Float = Scr_GetFloat(scrContext, 1u);
    v11 = *(float *)&Float;
  }
  String = Scr_GetString(scrContext, 0);
  ModifierFlagsFromString = NAV_GetModifierFlagsFromString(String);
LABEL_11:
  if ( AINavigator2D::GetModifierLocationOnEntPath(v8, ModifierFlagsFromString, v11, &outStartPoint, &outEndPoint) )
  {
    value[0] = (float)(outStartPoint.v[0] + outEndPoint.v[0]) * 0.5;
    value[1] = (float)(outEndPoint.v[1] + outStartPoint.v[1]) * 0.5;
    value[2] = (float)(outEndPoint.v[2] + outStartPoint.v[2]) * 0.5;
    Scr_AddVector(scrContext, value);
  }
}

/*
==============
Scr_GetNavPosition
==============
*/
void Scr_GetNavPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const AINavigator *Navigator; 
  const char *v5; 
  vec3_t outCurPos; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1539, scrContext, "GetNavPosition: invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetNavPosition: Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1540, scrContext, v5);
  }
  Nav_GetPos(Navigator, &outCurPos);
  Scr_AddVector(scrContext, outCurPos.v);
}

/*
==============
Scr_GetNavSpaceEnt
==============
*/
void Scr_GetNavSpaceEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v5; 
  nav_space_s *m_pSpace; 
  const char *v7; 
  int parentEntNum; 
  const char *v9; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1528, scrContext, "GetNavSpaceEnt : invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetNavSpaceEnt : Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1529, scrContext, v5);
  }
  m_pSpace = Navigator->m_pSpace;
  if ( !m_pSpace )
  {
    v7 = j_va("GetNavSpaceEnt : Navigator (ent %d) is not in any space!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1530, scrContext, v7);
  }
  parentEntNum = m_pSpace->parentEntNum;
  if ( parentEntNum != 2047 )
  {
    if ( !G_IsEntityInUse(parentEntNum) )
    {
      v9 = j_va("GetNavSpaceEnt : Space has invalid parent ent %d.", (unsigned int)m_pSpace->parentEntNum);
      Scr_Error(COM_ERR_1531, scrContext, v9);
    }
    GScr_AddEntity(&g_entities[m_pSpace->parentEntNum]);
  }
}

/*
==============
Scr_GetRandomNavPoint
==============
*/
void Scr_GetRandomNavPoint(scrContext_t *scrContext)
{
  double Float; 
  int v3; 
  nav_space_s *DefaultSpace; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v7; 
  AINavLayer Layer; 
  AINavigator2D *v9; 
  bfx::PathSpec pathSpec; 
  vec3_t origin; 
  vec3_t outPoints; 

  Scr_GetVector(scrContext, 0, &origin);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = 0;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pathSpec.m_pathSharingPenalty = 0.0;
  pathSpec.m_maxPathSharingPenalty = 0.0;
  pathSpec.m_maxSearchDist = 0.0;
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
    {
      v7 = j_va("GetRandomNavPoint: Ref ent %d must have a navigator.", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1520, scrContext, v7);
    }
    Layer = Nav_GetLayer(Navigator);
    DefaultSpace = Navigator->m_pSpace;
    v3 = Layer;
    v9 = Navigator->Get2DNavigator(Navigator);
    if ( v9 )
      pathSpec = *AINavigator2D::GetPathSpec(v9);
  }
  if ( Nav_GetKindaRandomReachablePoints(DefaultSpace, &origin, *(float *)&Float, v3, &pathSpec, 1, &outPoints) )
    Scr_AddVector(scrContext, outPoints.v);
}

/*
==============
Scr_GetRandomNavPoints
==============
*/
void Scr_GetRandomNavPoints(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  int Int; 
  int numPoints; 
  const char *v6; 
  int v7; 
  nav_space_s *DefaultSpace; 
  int NumParam; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v12; 
  AINavLayer Layer; 
  AINavigator2D *v14; 
  unsigned int KindaRandomReachablePoints; 
  __int64 v16; 
  vec3_t *p_outPoints; 
  bfx::PathSpec pathSpec; 
  vec3_t origin; 
  vec3_t vectorValue; 
  vec3_t outPoints; 

  Scr_GetVector(scrContext, 0, &origin);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float;
  Int = Scr_GetInt(scrContext, 2u);
  numPoints = Int;
  if ( Int > 64 )
  {
    v6 = j_va("GetRandomNavPoints: Can only find %d points at a time.  User requested %d.", 64i64, (unsigned int)Int);
    Scr_Error(COM_ERR_1521, scrContext, v6);
  }
  v7 = 0;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pathSpec.m_pathSharingPenalty = 0.0;
  pathSpec.m_maxPathSharingPenalty = 0.0;
  pathSpec.m_maxSearchDist = 0.0;
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
  {
    Entity = GScr_GetEntity(3u);
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
    {
      v12 = j_va("GetRandomNavPoints: ref ent %d must have a navigator.", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1522, scrContext, v12);
    }
    Layer = Nav_GetLayer(Navigator);
    DefaultSpace = Navigator->m_pSpace;
    v7 = Layer;
    v14 = Navigator->Get2DNavigator(Navigator);
    if ( v14 )
      pathSpec = *AINavigator2D::GetPathSpec(v14);
  }
  if ( NumParam > 4 )
  {
    if ( NumParam < 6 )
      Scr_Error(COM_ERR_1523, scrContext, "GetRandomNavPoints: origin2 must be accompanied by radius2.");
    Scr_GetVector(scrContext, 4u, &vectorValue);
    Scr_GetFloat(scrContext, 5u);
  }
  KindaRandomReachablePoints = Nav_GetKindaRandomReachablePoints(DefaultSpace, &origin, v3, v7, &pathSpec, numPoints, &outPoints);
  v16 = KindaRandomReachablePoints;
  if ( KindaRandomReachablePoints )
  {
    Scr_MakeArray(scrContext);
    if ( (int)v16 > 0 )
    {
      p_outPoints = &outPoints;
      do
      {
        Scr_AddVector(scrContext, p_outPoints->v);
        Scr_AddArray(scrContext);
        ++p_outPoints;
        --v16;
      }
      while ( v16 );
    }
  }
}

/*
==============
Scr_IsNavMeshLoaded
==============
*/
void Scr_IsNavMeshLoaded(scrContext_t *scrContext)
{
  if ( Nav_MeshLoaded() || Nav_MeshWillBeLoaded() )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
Scr_IsPointOnNavMesh3d
==============
*/
void Scr_IsPointOnNavMesh3d(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  nav_space_s *m_pSpace; 
  __int64 v5; 
  bool IsPointOnMesh; 
  bfx::Path3DSpec pPathSpec; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  *(_QWORD *)&pPathSpec.m_volumeUsageFlags = -1i64;
  pPathSpec.m_maxSearchDist = 0.0;
  if ( (int)Scr_GetNumParam(scrContext) > 1 && (Entity = GScr_GetEntity(1u), (Navigator = Nav_GetNavigator(Entity)) != NULL) )
  {
    m_pSpace = Navigator->m_pSpace;
    v5 = (__int64)Navigator->Get3DNavigator(Navigator);
    if ( v5 )
      pPathSpec = *(bfx::Path3DSpec *)(v5 + 220);
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
  }
  IsPointOnMesh = Nav3D_IsPointOnMesh(m_pSpace, &vectorValue, &pPathSpec);
  Scr_AddBool(scrContext, IsPointOnMesh);
}

/*
==============
Scr_IsPointOnNavMesh
==============
*/
void Scr_IsPointOnNavMesh(scrContext_t *scrContext)
{
  AINavLayer Layer; 
  int NumParam; 
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  bool v6; 
  nav_space_s *m_pSpace; 
  AINavigator2D *v8; 
  bool IsPointOnMeshCustom; 
  bfx::PathSpec pPathSpec; 
  vec3_t vectorValue; 
  vec3_t outSnappedPos; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Layer = NAV_LAYER_HUMAN;
  NumParam = Scr_GetNumParam(scrContext);
  Navigator = NULL;
  if ( NumParam > 1 )
  {
    Entity = GScr_GetEntity(1u);
    Navigator = Nav_GetNavigator(Entity);
  }
  v6 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v6 = Scr_GetInt(scrContext, 2u) != 0;
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pPathSpec.m_pathSharingPenalty = 0.0;
  pPathSpec.m_maxPathSharingPenalty = 0.0;
  pPathSpec.m_maxSearchDist = 0.0;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Navigator )
  {
    m_pSpace = Navigator->m_pSpace;
    Layer = Nav_GetLayer(Navigator);
    v8 = Navigator->Get2DNavigator(Navigator);
    if ( v6 && v8 )
      pPathSpec = *AINavigator2D::GetPathSpec(v8);
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
  }
  IsPointOnMeshCustom = Nav_IsPointOnMeshCustom(m_pSpace, &vectorValue, Layer, &pPathSpec, &outSnappedPos);
  Scr_AddBool(scrContext, IsPointOnMeshCustom);
}

/*
==============
Scr_NavIsStraightLineReachable3D
==============
*/
void Scr_NavIsStraightLineReachable3D(scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  __int64 v5; 
  bool IsStraightLineReachable; 
  bfx::Path3DSpec pPathSpec; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  Navigator = NULL;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( Navigator )
    DefaultSpace = Navigator->m_pSpace;
  *(_QWORD *)&pPathSpec.m_volumeUsageFlags = -1i64;
  pPathSpec.m_maxSearchDist = 0.0;
  if ( Navigator )
  {
    v5 = (__int64)Navigator->Get3DNavigator(Navigator);
    if ( v5 )
      pPathSpec = *(bfx::Path3DSpec *)(v5 + 220);
  }
  IsStraightLineReachable = Nav3D_IsStraightLineReachable(DefaultSpace, &vectorValue, &endPos, &pPathSpec);
  Scr_AddBool(scrContext, IsStraightLineReachable);
}

/*
==============
Scr_NavIsStraightLineReachable
==============
*/
void Scr_NavIsStraightLineReachable(scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  AINavLayer Layer; 
  AINavigator2D *v6; 
  bool IsStraightLineReachable; 
  bfx::PathSpec pPathSpec; 
  vec3_t vectorValue; 
  vec3_t startPos; 

  Scr_GetVector(scrContext, 0, &startPos);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Navigator = NULL;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( Navigator )
  {
    DefaultSpace = Navigator->m_pSpace;
    Layer = Nav_GetLayer(Navigator);
  }
  else
  {
    Layer = NAV_LAYER_HUMAN;
  }
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pPathSpec.m_pathSharingPenalty = 0.0;
  pPathSpec.m_maxPathSharingPenalty = 0.0;
  pPathSpec.m_maxSearchDist = 0.0;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Navigator )
  {
    v6 = Navigator->Get2DNavigator(Navigator);
    if ( v6 )
      pPathSpec = *AINavigator2D::GetPathSpec(v6);
  }
  IsStraightLineReachable = Nav_IsStraightLineReachable(DefaultSpace, &startPos, &vectorValue, Layer, &pPathSpec);
  Scr_AddBool(scrContext, IsStraightLineReachable);
}

/*
==============
Scr_NavTrace3D
==============
*/
void Scr_NavTrace3D(scrContext_t *scrContext)
{
  bool v2; 
  nav_space_s *DefaultSpace; 
  bool v5; 
  bool v6; 
  float v7; 
  bfx::Path3DSpec pathSpec; 
  vec3_t endPos; 
  vec3_t vectorValue; 
  nav_probe_results_3D_s pOutResults; 

  if ( !Nav_AnyVolumesLoaded() )
    Scr_Error(COM_ERR_1500, scrContext, "NavTrace3D: No nav volumes loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  v2 = Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u);
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_volumeUsageFlags = -1i64;
  _XMM6 = 0i64;
  pathSpec.m_maxSearchDist = 0.0;
  v5 = Nav_Trace3D(DefaultSpace, &vectorValue, &endPos, &pathSpec, &pOutResults);
  v6 = v5;
  if ( v2 )
  {
    Scr_MakeArray(scrContext);
    v7 = fsqrt((float)((float)((float)(endPos.v[1] - vectorValue.v[1]) * (float)(endPos.v[1] - vectorValue.v[1])) + (float)((float)(endPos.v[0] - vectorValue.v[0]) * (float)(endPos.v[0] - vectorValue.v[0]))) + (float)((float)(endPos.v[2] - vectorValue.v[2]) * (float)(endPos.v[2] - vectorValue.v[2])));
    if ( v7 <= 0.0 )
    {
      _XMM0 = v6;
      __asm
      {
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm1, xmm6, xmm1, xmm2; value
      }
    }
    else
    {
      *(float *)&_XMM1 = pOutResults.m_DistTraveled / v7;
    }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
    Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
    Scr_AddVector(scrContext, pOutResults.m_EndPos.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.position);
    Scr_AddVector(scrContext, pOutResults.m_Normal.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
  }
  else
  {
    Scr_AddBool(scrContext, v5);
  }
}

/*
==============
Scr_NavTrace
==============
*/
void Scr_NavTrace(scrContext_t *scrContext)
{
  int NumParam; 
  const AINavigator *Navigator; 
  const gentity_s *Entity; 
  bool v5; 
  nav_space_s *m_pSpace; 
  AINavigator2D *v8; 
  AINavLayer Layer; 
  bool v10; 
  bool v11; 
  float v12; 
  float v13; 
  float v17; 
  __int128 v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  __int128 v23; 
  float v27; 
  float v28; 
  float v29; 
  int v30; 
  float v31; 
  float v32; 
  float value; 
  int v34; 
  float v35; 
  vec3_t vectorValue; 
  vec3_t endPos; 
  nav_probe_results_s pOutResults; 
  bfx::PathSpec pathSpec; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  NumParam = Scr_GetNumParam(scrContext);
  Navigator = NULL;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  v5 = NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  _XMM7 = 0i64;
  pathSpec.m_pathSharingPenalty = 0.0;
  pathSpec.m_maxPathSharingPenalty = 0.0;
  pathSpec.m_maxSearchDist = 0.0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  bfx::AreaHandle::AreaHandle(&pOutResults.m_hEndArea);
  if ( Navigator )
  {
    m_pSpace = Navigator->m_pSpace;
    v8 = Navigator->Get2DNavigator(Navigator);
    if ( v8 )
      pathSpec = *AINavigator2D::GetPathSpec(v8);
    Layer = Nav_GetLayer(Navigator);
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
    Layer = NAV_LAYER_HUMAN;
  }
  v10 = Nav_Trace(m_pSpace, &vectorValue, &endPos, Layer, &pathSpec, &pOutResults);
  v11 = v10;
  if ( v5 )
  {
    Scr_MakeArray(scrContext);
    v12 = fsqrt((float)((float)((float)(endPos.v[1] - vectorValue.v[1]) * (float)(endPos.v[1] - vectorValue.v[1])) + (float)((float)(endPos.v[0] - vectorValue.v[0]) * (float)(endPos.v[0] - vectorValue.v[0]))) + (float)((float)(endPos.v[2] - vectorValue.v[2]) * (float)(endPos.v[2] - vectorValue.v[2])));
    if ( v12 <= 0.0 )
    {
      _XMM0 = v11;
      __asm
      {
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm0, xmm7, xmm6, xmm2
      }
      v13 = *(float *)&_XMM0;
    }
    else
    {
      v13 = pOutResults.m_DistTraveled / v12;
    }
    Scr_AddFloat(scrContext, v13);
    Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
    Scr_AddVector(scrContext, pOutResults.m_EndPos.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.position);
    if ( v11 )
    {
      if ( (LODWORD(pOutResults.m_edgeStartPos.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(pOutResults.m_edgeStartPos.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(pOutResults.m_edgeStartPos.v[2]) & 0x7F800000) == 2139095040 )
        Scr_Error(COM_ERR_1497, scrContext, "NavTrace: edge start pos NAN");
      v17 = pOutResults.m_edgeEndPos.v[0];
      if ( (LODWORD(pOutResults.m_edgeEndPos.v[0]) & 0x7F800000) == 2139095040 || (v18 = LODWORD(pOutResults.m_edgeEndPos.v[1]), (LODWORD(pOutResults.m_edgeEndPos.v[1]) & 0x7F800000) == 2139095040) || (v19 = pOutResults.m_edgeEndPos.v[2], (LODWORD(pOutResults.m_edgeEndPos.v[2]) & 0x7F800000) == 2139095040) )
      {
        Scr_Error(COM_ERR_1498, scrContext, "NavTrace: edge end pos NAN");
        v19 = pOutResults.m_edgeEndPos.v[2];
        v18 = LODWORD(pOutResults.m_edgeEndPos.v[1]);
        v17 = pOutResults.m_edgeEndPos.v[0];
      }
      v20 = v17 - pOutResults.m_edgeStartPos.v[0];
      v23 = v18;
      v21 = *(float *)&v18 - pOutResults.m_edgeStartPos.v[1];
      v22 = v19 - pOutResults.m_edgeStartPos.v[2];
      *(float *)&v23 = (float)((float)(v21 * v21) + (float)(v20 * v20)) + (float)(v22 * v22);
      if ( *(float *)&v23 > 0.0 )
      {
        *(float *)&v23 = fsqrt(*(float *)&v23);
        _XMM1 = v23;
        __asm
        {
          vcmpless xmm0, xmm1, cs:__real@80000000
          vblendvps xmm1, xmm1, xmm6, xmm0
        }
        v27 = v20 * (float)(1.0 / *(float *)&_XMM1);
        v28 = v21 * (float)(1.0 / *(float *)&_XMM1);
        v29 = (float)((float)(v22 * (float)(1.0 / *(float *)&_XMM1)) * pOutResults.m_areaNormal.v[1]) - (float)(v28 * pOutResults.m_areaNormal.v[2]);
        value = v29;
        *(float *)&v30 = (float)(v27 * pOutResults.m_areaNormal.v[2]) - (float)((float)(v22 * (float)(1.0 / *(float *)&_XMM1)) * pOutResults.m_areaNormal.v[0]);
        v34 = v30;
        *(float *)&_XMM1 = v28 * pOutResults.m_areaNormal.v[0];
        v32 = (float)(v28 * pOutResults.m_areaNormal.v[0]) - (float)(v27 * pOutResults.m_areaNormal.v[1]);
        v31 = v32;
        v35 = *(float *)&_XMM1 - (float)(v27 * pOutResults.m_areaNormal.v[1]);
        if ( (LODWORD(v29) & 0x7F800000) == 2139095040 || (v30 & 0x7F800000) == 2139095040 || (LODWORD(v32) & 0x7F800000) == 2139095040 )
        {
          Scr_Error(COM_ERR_1499, scrContext, "NavTrace: normal NAN");
          v31 = v35;
          v30 = v34;
          v29 = value;
        }
        if ( (float)((float)((float)(*(float *)&v30 * (float)(vectorValue.v[1] - pOutResults.m_edgeStartPos.v[1])) + (float)(v29 * (float)(vectorValue.v[0] - pOutResults.m_edgeStartPos.v[0]))) + (float)(v31 * (float)(vectorValue.v[2] - pOutResults.m_edgeStartPos.v[2]))) < 0.0 )
        {
          LODWORD(value) = LODWORD(v29) ^ _xmm;
          v34 = v30 ^ _xmm;
          LODWORD(v35) = LODWORD(v31) ^ _xmm;
        }
        Scr_AddVector(scrContext, &value);
        Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
      }
    }
  }
  else
  {
    Scr_AddBool(scrContext, v10);
  }
  bfx::AreaHandle::~AreaHandle(&pOutResults.m_hEndArea);
}

/*
==============
Scr_UndockMovingPlatform
==============
*/
void Scr_UndockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  nav_resource_s *ResourceByEntNum; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  nav_space_s *Space; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1104, ASSERT_TYPE_ASSERT, "( pPlatform )", (const char *)&queryFormat, "pPlatform") )
    __debugbreak();
  ResourceByEntNum = Nav_GetResourceByEntNum(Entity->s.number);
  if ( !ResourceByEntNum )
  {
    v5 = j_va("UndockMovingPlatform: Unable to find navmesh associated with platform entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1516, scrContext, v5);
  }
  if ( !ResourceByEntNum->bDockable )
  {
    v6 = j_va("UndockMovingPlatform: mesh associated with platform entity %d is not marked dockable.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1517, scrContext, v6);
  }
  if ( !ResourceByEntNum->pSpace && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1113, ASSERT_TYPE_ASSERT, "( pResource->pSpace )", (const char *)&queryFormat, "pResource->pSpace") )
    __debugbreak();
  if ( Nav_GetSpaceByEntNum(Entity->s.number) )
  {
    v7 = j_va("UndockMovingPlatform: space attached to ent %d already exists. Calling UndockMovingPlatform on something that is not currently docked?", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1518, scrContext, v7);
  }
  Nav_RemoveResourceFromSpace(ResourceByEntNum->pSpace, ResourceByEntNum);
  Space = Nav_CreateSpace(Entity->s.number);
  Nav_AddResourceToNewSpace(Space, ResourceByEntNum, &vec3_origin, &quat_identity, 0);
  Nav_UpdateSpace(Space);
  Nav_TransferObjsToSpace(Space);
}

